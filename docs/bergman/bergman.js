//# 1 "bergman.bc.runtime.js"
// Generated by js_of_ocaml 4.0.0
(function(Object)
   {typeof globalThis
    !==
    "object"
    &&
    (this
      ?get()
      :(Object.defineProperty
         (Object.prototype,"_T_",{configurable:true,get:get}),
        _T_));
    function get()
     {var global=this || self;
      global.globalThis = global;
      delete Object.prototype._T_}}
  (Object));
(function(globalThis)
   {"use strict";
    function caml_int64_is_zero(x){return + x.isZero()}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_constant(tag){throw tag}
    var caml_global_data=[0];
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_int64_to_int32(x){return x.toInt()}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_neg(x){return x.neg()}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function caml_jsbytes_of_string(s)
     {s.t & 6 && caml_convert_string_to_bytes(s);return s.c}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return this.c
        }};
    MlBytes.prototype.toUtf16
    =
    function()
     {var r=this.toString();
      if(this.t == 9)return r;
      return caml_utf16_of_utf8(r)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_string_of_jsbytes(msg))}
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_expm1_float(x){return Math.expm1(x)}
    function caml_jsstring_of_string(s){return s.toUtf16()}
    function fs_node_supported()
     {return typeof globalThis.process
             !==
             "undefined"
             &&
             typeof globalThis.process.versions
             !==
             "undefined"
             &&
             typeof globalThis.process.versions.node
             !==
             "undefined"}
    function make_path_is_absolute()
     {function posix(path)
       {if(path.charAt(0) === "/")return ["",path.substring(1)];return}
      function win32(path)
       {var
         splitDeviceRe=
          /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/,
         result=splitDeviceRe.exec(path),
         device=result[1] || "",
         isUnc=Boolean(device && device.charAt(1) !== ":");
        if(Boolean(result[2] || isUnc))
         {var root=result[1] || "",sep=result[2] || "";
          return [root,path.substring(root.length + sep.length)]}
        return}
      return fs_node_supported()
              &&
              globalThis.process
              &&
              globalThis.process.platform
              ?globalThis.process.platform === "win32"?win32:posix
              :posix}
    var path_is_absolute=make_path_is_absolute();
    function caml_trailing_slash(name)
     {return name.slice(- 1) !== "/"?name + "/":name}
    if(fs_node_supported() && globalThis.process && globalThis.process.cwd)
     var caml_current_dir=globalThis.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    caml_current_dir = caml_trailing_slash(caml_current_dir);
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(! path_is_absolute(name))name = caml_current_dir + name;
      var comp0=path_is_absolute(name),comp=comp0[1].split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         default:ncomp.push(comp[i]);break}
      ncomp.unshift(comp0[0]);
      ncomp.orig = name;
      return ncomp}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    var
     unix_error=
      ["E2BIG",
       "EACCES",
       "EAGAIN",
       "EBADF",
       "EBUSY",
       "ECHILD",
       "EDEADLK",
       "EDOM",
       "EEXIST",
       "EFAULT",
       "EFBIG",
       "EINTR",
       "EINVAL",
       "EIO",
       "EISDIR",
       "EMFILE",
       "EMLINK",
       "ENAMETOOLONG",
       "ENFILE",
       "ENODEV",
       "ENOENT",
       "ENOEXEC",
       "ENOLCK",
       "ENOMEM",
       "ENOSPC",
       "ENOSYS",
       "ENOTDIR",
       "ENOTEMPTY",
       "ENOTTY",
       "ENXIO",
       "EPERM",
       "EPIPE",
       "ERANGE",
       "EROFS",
       "ESPIPE",
       "ESRCH",
       "EXDEV",
       "EWOULDBLOCK",
       "EINPROGRESS",
       "EALREADY",
       "ENOTSOCK",
       "EDESTADDRREQ",
       "EMSGSIZE",
       "EPROTOTYPE",
       "ENOPROTOOPT",
       "EPROTONOSUPPORT",
       "ESOCKTNOSUPPORT",
       "EOPNOTSUPP",
       "EPFNOSUPPORT",
       "EAFNOSUPPORT",
       "EADDRINUSE",
       "EADDRNOTAVAIL",
       "ENETDOWN",
       "ENETUNREACH",
       "ENETRESET",
       "ECONNABORTED",
       "ECONNRESET",
       "ENOBUFS",
       "EISCONN",
       "ENOTCONN",
       "ESHUTDOWN",
       "ETOOMANYREFS",
       "ETIMEDOUT",
       "ECONNREFUSED",
       "EHOSTDOWN",
       "EHOSTUNREACH",
       "ELOOP",
       "EOVERFLOW"];
    function make_unix_err_args(code,syscall,path,errno)
     {var variant=unix_error.indexOf(code);
      if(variant < 0){if(errno == null)errno = - 9999;variant = [0,errno]}
      var
       args=
        [variant,
         caml_string_of_jsstring(syscall || ""),
         caml_string_of_jsstring(path || "")];
      return args}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    function caml_raise_with_args(tag,args){throw [0,tag].concat(args)}
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_bytes_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_bytes_of_string(s){return s}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {caml_raise_sys_error(name + ": No such file or directory")}
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_convert_bytes_to_array(s)
     {if(globalThis.Uint8Array)
       var a=new (globalThis.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_string(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.create_dir_if_needed
    =
    function(name)
     {var comp=name.split("/"),res="";
      for(var i=0;i < comp.length - 1;i++)
       {res += comp[i] + "/";
        if(this.content[res])continue;
        this.content[res] = Symbol("directory")}};
    MlFakeDevice.prototype.slash
    =
    function(name){return /\/$/.test(name)?name:name + "/"};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         {this.create_dir_if_needed(name);
          this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=this.slash(name);
      if(this.content[name_slash])return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.mkdir
    =
    function(name,mode,raise_unix)
     {var unix_error=raise_unix && caml_named_value("Unix.Unix_error");
      if(this.exists(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("EEXIST","mkdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": File exists");
      var parent=/^(.*)\/[^/]+/.exec(name);
      parent = parent && parent[1] || "";
      if(! this.exists(parent))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOENT","mkdir",this.nm(parent)));
       else
        caml_raise_sys_error(parent + ": No such file or directory");
      if(! this.is_dir(parent))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOTDIR","mkdir",this.nm(parent)));
       else
        caml_raise_sys_error(parent + ": Not a directory");
      this.create_dir_if_needed(this.slash(name))};
    MlFakeDevice.prototype.rmdir
    =
    function(name,raise_unix)
     {var
       unix_error=raise_unix && caml_named_value("Unix.Unix_error"),
       name_slash=name == ""?"":this.slash(name),
       r=new RegExp("^" + name_slash + "([^/]+)");
      if(! this.exists(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOENT","rmdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": No such file or directory");
      if(! this.is_dir(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOTDIR","rmdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": Not a directory");
      for(var n in this.content)
       if(n.match(r))
        if(unix_error)
         caml_raise_with_args
          (unix_error,make_unix_err_args("ENOTEMPTY","rmdir",this.nm(name)));
        else
         caml_raise_sys_error(this.nm(name) + ": Directory not empty");
      delete this.content[name_slash]};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var name_slash=name == ""?"":this.slash(name);
      if(! this.exists(name))
       caml_raise_sys_error(name + ": No such file or directory");
      if(! this.is_dir(name))caml_raise_sys_error(name + ": Not a directory");
      var r=new RegExp("^" + name_slash + "([^/]+)"),seen={},a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {if(name == "")return true;
      var name_slash=this.slash(name);
      return this.content[name_slash]?1:0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.create_dir_if_needed(name);
         this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {var file;
      if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))file = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       file = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        file = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         file = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           file = new MlFakeFile(bytes)}
      if(file)
       {this.create_dir_if_needed(name);this.content[name] = file}
      else
       caml_raise_sys_error
        (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof globalThis.Uint8Array))
       a = new (globalThis.Uint8Array)(a);
      var buffer=globalThis.Buffer.from(a);
      try
       {this.fs.writeSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_bytes(buf);
      if(! (a instanceof globalThis.Uint8Array))
       a = new (globalThis.Uint8Array)(a);
      var buffer=globalThis.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var a=new (globalThis.Uint8Array)(1),buffer=globalThis.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,0,1,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return buffer[0]};
    MlNodeFile.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try {return this.fs.existsSync(this.nm(name))?1:0}catch(err){return 0}};
    MlNodeDevice.prototype.mkdir
    =
    function(name,mode,raise_unix)
     {try
       {this.fs.mkdirSync(this.nm(name),{mode:mode});return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.rmdir
    =
    function(name,raise_unix)
     {try
       {this.fs.rmdirSync(this.nm(name));return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.readdir
    =
    function(name,raise_unix)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name,raise_unix)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name));
        return b}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.open
    =
    function(name,f,raise_unix)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var fd=this.fs.openSync(this.nm(name),res);return new MlNodeFile(fd)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.rename
    =
    function(o,n,raise_unix)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.stat
    =
    function(name,raise_unix)
     {try
       {var js_stats=this.fs.statSync(this.nm(name));
        return this.stats_from_js(js_stats)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.lstat
    =
    function(name,raise_unix)
     {try
       {var js_stats=this.fs.lstatSync(this.nm(name));
        return this.stats_from_js(js_stats)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.symlink
    =
    function(to_dir,target,path,raise_unix)
     {try
       {this.fs.symlinkSync(this.nm(target),this.nm(path),to_dir?"dir":"file");
        return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.readlink
    =
    function(name,raise_unix)
     {try
       {var link=this.fs.readlinkSync(this.nm(name),"utf8");
        return caml_string_of_jsstring(link)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.raise_nodejs_error
    =
    function(err,raise_unix)
     {var unix_error=caml_named_value("Unix.Unix_error");
      if(raise_unix && unix_error)
       {var args=make_unix_err_args(err.code,err.syscall,err.path,err.errno);
        caml_raise_with_args(unix_error,args)}
      else
       caml_raise_sys_error(err.toString())};
    MlNodeDevice.prototype.stats_from_js
    =
    function(js_stats)
     {var file_kind;
      if(js_stats.isFile())
       file_kind = 0;
      else
       if(js_stats.isDirectory())
        file_kind = 1;
       else
        if(js_stats.isCharacterDevice())
         file_kind = 2;
        else
         if(js_stats.isBlockDevice())
          file_kind = 3;
         else
          if(js_stats.isSymbolicLink())
           file_kind = 4;
          else
           if(js_stats.isFIFO())
            file_kind = 5;
           else
            if(js_stats.isSocket())file_kind = 6;
      return [0,
              js_stats.dev,
              js_stats.ino,
              file_kind,
              js_stats.mode,
              js_stats.nlink,
              js_stats.uid,
              js_stats.gid,
              js_stats.rdev,
              js_stats.size,
              js_stats.atimeMs,
              js_stats.mtimeMs,
              js_stats.ctimeMs]};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    function caml_get_root(path)
     {var x=path_is_absolute(path);if(! x)return;return x[0] + "/"}
    function caml_failwith(msg)
     {if(! caml_global_data.Failure)
       caml_global_data.Failure = [248,caml_string_of_jsbytes("Failure"),- 3];
      caml_raise_with_string(caml_global_data.Failure,msg)}
    var
     caml_root=
      caml_get_root(caml_current_dir)
      ||
      caml_failwith("unable to compute caml_root"),
     jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:"/static/",device:new MlFakeDevice("/static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=caml_trailing_slash(name),
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      if(! res && fs_node_supported())
       {var root=caml_get_root(name);
        if(root && root.match(/^[a-zA-Z]:\/$/))
         {var m={path:root,device:new MlNodeDevice(root)};
          jsoo_mount_point.push(m);
          res
          =
          {path:m.path,
           device:m.device,
           rest:name.substring(m.path.length,name.length)}}}
      if(res)return res;
      caml_raise_sys_error("no device found for " + name_slash)}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=globalThis,n=caml_jsstring_of_string(name);
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_string_of_jsstring(g.process.env[n]);
      if(globalThis.jsoo_static_env && globalThis.jsoo_static_env[n])
       return caml_string_of_jsstring(globalThis.jsoo_static_env[n]);
      caml_raise_not_found()}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    var caml_gr_state;
    function caml_gr_state_get()
     {if(caml_gr_state)return caml_gr_state;
      throw [0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]}
    function caml_gr_point_color(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.getImageData(x,s.height - y,1,1),
       d=im.data;
      return (d[0] << 16) + (d[1] << 8) + d[2]}
    var MlObjectTable;
    if(typeof globalThis.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function(){this.objs = [];this.lookup = new (globalThis.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    function caml_log10_float(x){return Math.log10(x)}
    function unix_unlink(name)
     {var root=resolve_fs_device(name);
      if(! root.device.unlink)caml_failwith("unix_unlink: not implemented");
      return root.device.unlink(root.rest,true)}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function unix_rmdir(name)
     {var root=resolve_fs_device(name);
      if(! root.device.rmdir)caml_failwith("unix_rmdir: not implemented");
      return root.device.rmdir(root.rest,true)}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_string_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    var caml_ml_channels=new Array();
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_gc_minor(){return 0}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_ba_uint8_get64(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3),
       b5=ba.get(ofs + 4),
       b6=ba.get(ofs + 5),
       b7=ba.get(ofs + 6),
       b8=ba.get(ofs + 7);
      return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1])}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_ba_num_dims(ba){return ba.dims.length}
    function caml_return_exn_constant(tag){return tag}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (globalThis.RangeError
        &&
        e instanceof globalThis.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (globalThis.InternalError
        &&
        e instanceof globalThis.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof globalThis.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function caml_create_file(name,content)
     {var root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function jsoo_create_file(name,content)
     {var
       name=caml_string_of_jsbytes(name),
       content=caml_string_of_jsbytes(content);
      return caml_create_file(name,content)}
    function caml_fs_init()
     {var tmp=globalThis.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        jsoo_create_file(tmp[i].name,tmp[i].content);
      globalThis.jsoo_create_file = jsoo_create_file;
      globalThis.caml_fs_tmp = [];
      return 0}
    function caml_set_parser_trace(){return 0}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    function caml_js_wrap_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[args])}}
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {if(root.rest)
         caml_current_dir = caml_trailing_slash(root.path + root.rest);
        else
         caml_current_dir = root.path;
        return 0}
      else
       caml_raise_no_such_file(caml_jsbytes_of_string(dir))}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_gr_synchronize()
     {caml_failwith("caml_gr_synchronize not Implemented")}
    function unix_has_symlink(unit){return fs_node_supported()?1:0}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (globalThis.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (globalThis.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      if(ba.caml_custom == "_bigarr02")
       for(var i=0;i < ba.dims.length;i++)
        if(ba.dims[i] < 0xffff)
         writer.write(16,ba.dims[i]);
        else
         {writer.write(16,0xffff);
          writer.write(32,0);
          writer.write(32,ba.dims[i])}
      else
       for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=globalThis,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new (globalThis.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (globalThis.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    var caml_ba_custom_name="_bigarr02";
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_ba_deserialize(reader,sz,name)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      if(name == "_bigarr02")
       for(var i=0;i < num_dims;i++)
        {var size_dim=reader.read16u();
         if(size_dim == 0xffff)
          {var size_dim_hi=reader.read32u(),size_dim_lo=reader.read32u();
           if(size_dim_hi != 0)
            caml_failwith("input_value: bigarray dimension overflow in 32bit");
           size_dim = size_dim_lo}
         dims.push(size_dim)}
      else
       for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarray")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarr02")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function MlNat(x)
     {this.data = new (globalThis.Int32Array)(x);
      this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function caml_ba_blit(src,dst)
     {if(dst.dims.length != src.dims.length)
       caml_invalid_argument("Bigarray.blit: dimension mismatch");
      for(var i=0;i < dst.dims.length;i++)
       if(dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
      dst.data.set(src.data);
      return 0}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function caml_int64_div(x,y){return x.div(y)}
    function caml_js_html_entities(s)
     {var entity=/^&#?[0-9a-zA-Z]+;$/;
      if(s.match(entity))
       {var str,temp=document.createElement("p");
        temp.innerHTML = s;
        str = temp.textContent || temp.innerText;
        temp = null;
        return str}
      else
       caml_failwith("Invalid entity " + s)}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    function caml_ba_set_2(ba,i0,i1,v){ba.set(ba.offset([i0,i1]),v);return 0}
    var
     caml_argv=
      function()
        {var g=globalThis,main="a.out",args=[];
         if(g.process && g.process.argv && g.process.argv.length > 1)
          {var argv=g.process.argv;main = argv[1];args = argv.slice(2)}
         var p=caml_string_of_jsstring(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_string_of_jsstring(args[i]));
         return args2}
       (),
     caml_executable_name=caml_argv[1];
    function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s))}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function caml_memprof_set(_control){return 0}
    function caml_sys_exit(code)
     {var g=globalThis;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    function caml_channel_descriptor(chanid)
     {var chan=caml_ml_channels[chanid];return chan.fd}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_ba_reshape(ba,vind)
     {vind = caml_js_from_array(vind);
      var new_dim=[],num_dims=vind.length;
      if(num_dims < 0 || num_dims > 16)
       caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
      var num_elts=1;
      for(var i=0;i < num_dims;i++)
       {new_dim[i] = vind[i];
        if(new_dim[i] < 0)
         caml_invalid_argument("Bigarray.reshape: negative dimension");
        num_elts = num_elts * new_dim[i]}
      var size=caml_ba_get_size(ba.dims);
      if(num_elts != size)
       caml_invalid_argument("Bigarray.reshape: size mismatch");
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dim,ba.data)}
    var caml_oo_last_id=0;
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_gr_fill_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.fillRect(x,s.height - y,w,- h);
      return 0}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_string_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function caml_gr_set_window_title(name)
     {var s=caml_gr_state_get();
      s.title = name;
      var jsname=caml_jsstring_of_string(name);
      if(s.set_title)s.set_title(jsname);
      return 0}
    function caml_get_global_data(){return caml_global_data}
    function caml_int64_shift_right_unsigned(x,s)
     {return x.shift_right_unsigned(s)}
    function caml_ba_uint8_get16(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      var b1=ba.get(ofs),b2=ba.get(ofs + 1);
      return b1 | b2 << 8}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x){return x.toFloat()}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function caml_bigstring_memcmp(s1,pos1,s2,pos2,len)
     {for(var i=0;i < len;i++)
       {var a=caml_ba_get_1(s1,pos1 + i),b=caml_ba_get_1(s2,pos2 + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_new_string(s){return caml_string_of_jsbytes(s)}
    function caml_erf_float(x)
     {var
       a1=0.254829592,
       a2=- 0.284496736,
       a3=1.421413741,
       a4=- 1.453152027,
       a5=1.061405429,
       p=0.3275911,
       sign=1;
      if(x < 0)sign = - 1;
      x = Math.abs(x);
      var
       t=1.0 / (1.0 + p * x),
       y=
        1.0
        -
        ((((a5 * t + a4) * t + a3) * t + a2) * t + a1)
        *
        t
        *
        Math.exp(- (x * x));
      return sign * y}
    function caml_ba_uint8_get32(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3);
      return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24}
    function caml_raw_backtrace_length(){return 0}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function caml_gr_clear_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = s.width;
      s.canvas.height = s.height;
      return 0}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function caml_sys_const_naked_pointers_checked(_unit){return 0}
    function lxor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] ^= nat2.data[ofs2];return 0}
    function caml_obj_add_offset(v,offset)
     {caml_failwith("Obj.add_offset is not supported")}
    function caml_final_release(){return 0}
    function caml_js_to_array(a)
     {var len=a.length,b=new Array(len + 1);
      b[0] = 0;
      for(var i=0;i < len;i++)b[i + 1] = a[i];
      return b}
    function caml_gr_plot(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.createImageData(1,1),
       d=im.data,
       color=s.color;
      d[0] = color >> 16 & 0xff;
      d[1] = color >> 8 & 0xff,d[2] = color >> 0 & 0xff;
      d[3] = 0xFF;
      s.x = x;
      s.y = y;
      s.context.putImageData(im,x,s.height - y);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_bytes_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_int64_bswap(x)
     {var y=caml_int64_to_bytes(x);
      return caml_int64_of_bytes([y[7],y[6],y[5],y[4],y[3],y[2],y[1],y[0]])}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_string=caml_fill_bytes;
    function caml_gc_major(){return 0}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function unix_getuid(unit)
     {if(globalThis.process && globalThis.process.getuid)
       return globalThis.process.getuid();
      caml_raise_not_found()}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_gr_size_x(){var s=caml_gr_state_get();return s.width}
    function caml_ml_debug_info_status(){return 0}
    var
     os_type=
      globalThis.process
       &&
       globalThis.process.platform
       &&
       globalThis.process.platform
       ==
       "win32"
       ?"Cygwin"
       :"Unix";
    function caml_sys_const_ostype_cygwin(){return os_type == "Cygwin"?1:0}
    function caml_cosh_float(x){return Math.cosh(x)}
    var caml_ephe_key_offset=3;
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    var caml_ephe_check_key=caml_weak_check;
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_gr_text_size(txt)
     {var
       s=caml_gr_state_get(),
       w=s.context.measureText(caml_jsstring_of_string(txt)).width;
      return [0,w,s.text_size]}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)
         mem[dst + 1] = curr_pos;
        else
         mem[dst + 1] = mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)mem[dst + 1] = - 1;else mem[dst + 1] = mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          if(tbl.lex_check_code[base_code + c] == pstate)
           pc_off = tbl.lex_trans_code[base_code + c];
          else
           pc_off = tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function caml_ba_uint8_set64(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var v=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)ba.set(ofs + i,v[7 - i]);
      return 0}
    function caml_sys_executable_name(a){return caml_executable_name}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_acosh_float(x){return Math.acosh(x)}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_flush(chanid);
      caml_ml_channels[chanid].offset = caml_int64_to_float(pos);
      return 0}
    function compare_nat_real(nat1,nat2)
     {return compare_nat(nat1,0,nat1.data.length,nat2,0,nat2.data.length)}
    function caml_gc_set(_control){return 0}
    function caml_js_get(o,f){return o[f]}
    function caml_ml_set_buffered(c,v){return 0}
    function caml_gc_compaction(){return 0}
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    var caml_ephe_get_key=caml_weak_get;
    function caml_bigstring_blit_bytes_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_bytes_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_bytes(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function win_cleanup(){}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (globalThis.Error)("Js exception containing backtrace");
      return exn}
    function caml_sys_isatty(_chan){return 0}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function unix_inet_addr_of_string(){return 0}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function caml_log2_float(x){return Math.log2(x)}
    function caml_gc_huge_fallback_count(unit){return 0}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function caml_int64_sub(x,y){return x.sub(y)}
    function caml_ml_seek_in_64(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = caml_int64_to_float(pos);
      return 0}
    function caml_int64_shift_left(x,s){return x.shift_left(s)}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_sys_const_int_size(){return 32}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_is_js(){return 1}
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_js_meth_call(o,f,args)
     {return o[caml_jsstring_of_string(f)].apply(o,caml_js_from_array(args))}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    var caml_ephe_create=caml_weak_create;
    function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s)}
    function unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=unix_localtime(t);
      return [0,t,tm2]}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_bytes_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(caml_jsbytes_of_string(name));
      return 0}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_hypot_float(x,y){return Math.hypot(x,y)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function caml_hash_mix_bytes_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_jsbytes(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_ml_bytes_content(s)
     {switch(s.t & 6)
       {default:caml_convert_string_to_bytes(s);case 0:return s.c;
        case 4:return s.c
        }}
    function caml_hash_mix_bytes(h,v)
     {var content=caml_ml_bytes_content(v);
      return typeof content === "string"
              ?caml_hash_mix_jsbytes(h,content)
              :caml_hash_mix_bytes_arr(h,content)}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_erfc_float(x){return 1 - caml_erf_float(x)}
    function caml_gr_fill_poly(ar)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(ar[1][1],s.height - ar[1][2]);
      for(var i=2;i < ar.length;i++)
       s.context.lineTo(ar[i][1],s.height - ar[i][2]);
      s.context.lineTo(ar[1][1],s.height - ar[1][2]);
      s.context.fill();
      return 0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],file=chan.file;
      while(chan.offset + 3 >= file.length())
       {var l=caml_ml_refill_input(chan);if(l == 0)caml_raise_end_of_file()}
      var
       o=chan.offset,
       r=
        file.read_one(o)
        <<
        24
        |
        file.read_one(o + 1)
        <<
        16
        |
        file.read_one(o + 2)
        <<
        8
        |
        file.read_one(o + 3);
      chan.offset += 4;
      return r}
    function caml_gr_display_mode()
     {caml_failwith("caml_gr_display_mode not Implemented")}
    function caml_obj_reachable_words(o){return 0}
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)(p([+-]?[0-9]+))?/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[5] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_sys_getcwd()
     {return caml_string_of_jsbytes(caml_current_dir)}
    function caml_sys_const_big_endian(){return 0}
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var
     caml_legacy_custom_code=false,
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            globalThis.console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom)
              {if(memo(v))return;
               var
                name=v.caml_custom,
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(caml_is_ml_bytes(v))
                {if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
                  caml_failwith
                   ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
                 if(memo(v))return;
                 var len=caml_ml_bytes_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_bytes_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(caml_is_ml_string(v))
                 {var len=caml_ml_string_length(v);
                  if(len < 0x20)
                   writer.write(8,0x20 + len);
                  else
                   if(len < 0x100)
                    writer.write_code(8,0x09,len);
                   else
                    writer.write_code(32,0x0A,len);
                  for(var i=0;i < len;i++)
                   writer.write(8,caml_string_unsafe_get(v,i));
                  writer.size_32 += 1 + ((len + 4) / 4 | 0);
                  writer.size_64 += 1 + ((len + 8) / 8 | 0)}
                else
                 if(v != (v | 0))
                  {var type_of_v=typeof v;
                   caml_failwith
                    ("output_value: abstract value (" + type_of_v + ")")}
                 else
                  if(v >= 0 && v < 0x40)
                   writer.write(8,0X40 + v);
                  else
                   if(v >= - (1 << 7) && v < 1 << 7)
                    writer.write_code(8,0x00,v);
                   else
                    if(v >= - (1 << 15) && v < 1 << 15)
                     writer.write_code(16,0x01,v);
                    else
                     writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_string_of_array(a)
     {return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length))}
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_raise_not_a_dir(name)
     {caml_raise_sys_error(name + ": Not a directory")}
    function caml_sys_system_command(cmd)
     {var cmd=caml_jsstring_of_string(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try
        {require("child_process").execSync(cmd,{stdio:"inherit"});return 0}
       catch(e){return 1}
      else
       return 127}
    function unix_isatty(fileDescriptor)
     {if(fs_node_supported())
       {var tty=require("tty");return tty.isatty(fileDescriptor)?1:0}
      else
       return 0}
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function caml_gr_open_subwindow(a,b,c,d)
     {caml_failwith("caml_gr_open_subwindow not Implemented")}
    function unix_lstat(name)
     {var root=resolve_fs_device(name);
      if(! root.device.lstat)caml_failwith("unix_lstat: not implemented");
      return root.device.lstat(root.rest,true)}
    var unix_lstat_64=unix_lstat;
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=globalThis;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_gr_set_text_size(size)
     {var s=caml_gr_state_get();
      s.text_size = size;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    var
     caml_md5_bytes=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[],content=caml_ml_bytes_content(s);
           if(typeof content === "string")
            {var b=content;
             for(var i=0;i < len;i += 4)
              {var j=i + ofs;
               buf[i >> 2]
               =
               b.charCodeAt(j)
               |
               b.charCodeAt(j + 1)
               <<
               8
               |
               b.charCodeAt(j + 2)
               <<
               16
               |
               b.charCodeAt(j + 3)
               <<
               24}
             for(;i < len;i++)
              buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3)}
           else
            {var a=content;
             for(var i=0;i < len;i += 4)
              {var j=i + ofs;
               buf[i >> 2]
               =
               a[j]
               |
               a[j + 1]
               <<
               8
               |
               a[j + 2]
               <<
               16
               |
               a[j + 3]
               <<
               24}
             for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)}
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_ba_set_generic(ba,i,v)
     {ba.set(ba.offset(caml_js_from_array(i)),v);return 0}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_lessequal(s1,s2){return caml_bytes_lessequal(s1,s2)}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      if(x < y == x > 0)
       bits = caml_int64_add(bits,one);
      else
       bits = caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function caml_gr_size_y(){var s=caml_gr_state_get();return s.height}
    function caml_ml_pos_in(chanid){return caml_ml_channels[chanid].offset}
    function caml_int64_and(x,y){return x.and(y)}
    function caml_sys_const_word_size(){return 32}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_string_of_jsbytes(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=globalThis;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function MlStringReader(s,i)
     {this.s = caml_jsbytes_of_string(s);this.i = i}
    MlStringReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_string_of_jsbytes(this.s.substring(i,i + len))}};
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
            case 0x18:
            case 0x19:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             var ops=caml_custom_ops[s],expected_size;
             if(! ops)
              caml_failwith("input_value: unknown custom block identifier");
             switch(code)
              {case 0x12:break;
               case 0x19:
                if(! ops.fixed_length)
                 caml_failwith
                  ("input_value: expected a fixed-size custom block");
                expected_size = ops.fixed_length;
                break;
               case 0x18:
                expected_size = reader.read32u();
                reader.read32s();
                reader.read32s();
                break
               }
             var old_pos=reader.i,size=[0],v=ops.deserialize(reader,size);
             if(expected_size != undefined)
              if(expected_size != size[0])
               caml_failwith
                ("input_value: incorrect length of serialized custom block");
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function caml_string_of_bytes(s){return s}
    function caml_input_value_from_bytes(s,ofs)
     {var
       reader=
        new
         MlStringReader
         (caml_string_of_bytes(s),typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    var
     re_match=
      function()
        {var
          re_word_letters=
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
          opcodes=
           {CHAR:0,
            CHARNORM:1,
            STRING:2,
            STRINGNORM:3,
            CHARCLASS:4,
            BOL:5,
            EOL:6,
            WORDBOUNDARY:7,
            BEGGROUP:8,
            ENDGROUP:9,
            REFGROUP:10,
            ACCEPT:11,
            SIMPLEOPT:12,
            SIMPLESTAR:13,
            SIMPLEPLUS:14,
            GOTO:15,
            PUSHBACK:16,
            SETMARK:17,
            CHECKPROGRESS:18};
         function is_word_letter(c)
          {return re_word_letters[c >> 3] >> (c & 7) & 1}
         function in_bitset(s,i)
          {return caml_string_get(s,i >> 3) >> (i & 7) & 1}
         function re_match_impl(re,s,pos,partial)
          {var
            prog=caml_js_from_array(re[1]),
            cpool=caml_js_from_array(re[2]),
            normtable=caml_jsbytes_of_string(re[3]),
            numgroups=re[4] | 0,
            numregisters=re[5] | 0,
            startchars=re[6] | 0,
            s=caml_array_of_string(s),
            pc=0,
            quit=false,
            stack=[],
            groups=new Array(numgroups),
            re_register=new Array(numregisters);
           for(var i=0;i < groups.length;i++)groups[i] = {start:- 1,end:- 1};
           groups[0].start = pos;
           function backtrack()
            {while(stack.length)
              {var item=stack.pop();
               if(item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
               else
                if(item.pos){pc = item.pos.pc;pos = item.pos.txt;return}}
             quit = true}
           function push(item){stack.push(item)}
           function accept()
            {groups[0].end = pos;
             var result=new Array(1 + groups.length * 2);
             result[0] = 0;
             for(var i=0;i < groups.length;i++)
              {var g=groups[i];
               if(g.start < 0 || g.end < 0)g.start = g.end = - 1;
               result[2 * i + 1] = g.start;
               result[2 * i + 1 + 1] = g.end}
             return result}
           function prefix_match()
            {if(partial)return accept();else backtrack()}
           while(! quit)
            {var
              op=prog[pc] & 0xff,
              sarg=prog[pc] >> 8,
              uarg=sarg & 0xff,
              c=s[pos],
              group;
             pc++;
             switch(op)
              {case opcodes.CHAR:
                if(pos === s.length){prefix_match();break}
                if(c === uarg)pos++;else backtrack();
                break;
               case opcodes.CHARNORM:
                if(pos === s.length){prefix_match();break}
                if(normtable.charCodeAt(c) === uarg)pos++;else backtrack();
                break;
               case opcodes.STRING:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(c === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.STRINGNORM:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(normtable.charCodeAt(c) === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.CHARCLASS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))pos++;else backtrack();
                break;
               case opcodes.BOL:
                if(pos > 0 && s[pos - 1] != 10)backtrack();break;
               case opcodes.EOL:
                if(pos < s.length && s[pos] != 10)backtrack();break;
               case opcodes.WORDBOUNDARY:
                if(pos == 0)
                 {if(pos === s.length){prefix_match();break}
                  if(is_word_letter(s[0]))break;
                  backtrack()}
                else
                 if(pos === s.length)
                  {if(is_word_letter(s[pos - 1]))break;backtrack()}
                 else
                  {if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos]))
                    break;
                   backtrack()}
                break;
               case opcodes.BEGGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"start",value:group.start}});
                group.start = pos;
                break;
               case opcodes.ENDGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"end",value:group.end}});
                group.end = pos;
                break;
               case opcodes.REFGROUP:
                group = groups[uarg];
                if(group.start < 0 || group.end < 0){backtrack();break}
                for(var i=group.start;i < group.end;i++)
                 {if(pos === s.length){prefix_match();break}
                  if(s[i] != s[pos]){backtrack();break}
                  pos++}
                break;
               case opcodes.SIMPLEOPT:if(in_bitset(cpool[uarg],c))pos++;break;
               case opcodes.SIMPLESTAR:
                while(in_bitset(cpool[uarg],c))c = s[++pos];break;
               case opcodes.SIMPLEPLUS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))
                 do c = s[++pos];while(in_bitset(cpool[uarg],c));
                else
                 backtrack();
                break;
               case opcodes.ACCEPT:return accept();
               case opcodes.GOTO:pc = pc + sarg;break;
               case opcodes.PUSHBACK:push({pos:{pc:pc + sarg,txt:pos}});break;
               case opcodes.SETMARK:
                push
                 ({undo:{obj:re_register,prop:uarg,value:re_register[uarg]}});
                re_register[uarg] = pos;
                break;
               case opcodes.CHECKPROGRESS:
                if(re_register[uarg] === pos)backtrack();break;
               default:throw new Error("Invalid bytecode")}}
           return 0}
         return re_match_impl}
       ();
    function re_search_backward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_backward");
      while(pos >= 0){var res=re_match(re,s,pos,0);if(res)return res;pos--}
      return [0]}
    function caml_js_from_string(s){return caml_jsstring_of_string(s)}
    function caml_ba_sub(ba,ofs,len)
     {var changed_dim,mul=1;
      if(ba.layout == 0)
       {for(var i=1;i < ba.dims.length;i++)mul = mul * ba.dims[i];
        changed_dim = 0}
      else
       {for(var i=0;i < ba.dims.length - 1;i++)mul = mul * ba.dims[i];
        changed_dim = ba.dims.length - 1;
        ofs = ofs - 1}
      if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
       caml_invalid_argument("Bigarray.sub: bad sub-array");
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)new_dims[i] = ba.dims[i];
      new_dims[changed_dim] = len;
      mul *= caml_ba_get_size_per_element(ba.kind);
      var new_data=ba.data.subarray(ofs * mul,(ofs + len) * mul);
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dims,new_data)}
    function caml_gc_full_major(){return 0}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      caml_bytes_unsafe_set(s,i + 2,b3);
      caml_bytes_unsafe_set(s,i + 3,b4);
      return 0}
    function caml_gr_sigio_signal(){return 0}
    function caml_ba_uint8_set32(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      ba.set(ofs + 2,v >>> 16 & 0xff);
      ba.set(ofs + 3,v >>> 24 & 0xff);
      return 0}
    function caml_sys_const_ostype_unix(){return os_type == "Unix"?1:0}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_gr_set_line_width(w)
     {var s=caml_gr_state_get();
      s.line_width = w;
      s.context.lineWidth = w;
      return 0}
    function caml_gr_set_font(f)
     {var s=caml_gr_state_get();
      s.font = f;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_color(color)
     {var s=caml_gr_state_get();
      function convert(number)
       {var str="" + number.toString(16);
        while(str.length < 2)str = "0" + str;
        return str}
      var r=color >> 16 & 0xff,g=color >> 8 & 0xff,b=color >> 0 & 0xff;
      s.color = color;
      var c_str="#" + convert(r) + convert(g) + convert(b);
      s.context.fillStyle = c_str;
      s.context.strokeStyle = c_str;
      return 0}
    function caml_gr_moveto(x,y)
     {var s=caml_gr_state_get();s.x = x;s.y = y;return 0}
    function caml_gr_resize_window(w,h)
     {var s=caml_gr_state_get();
      s.width = w;
      s.height = h;
      s.canvas.width = w;
      s.canvas.height = h;
      return 0}
    function caml_gr_state_init()
     {caml_gr_moveto(caml_gr_state.x,caml_gr_state.y);
      caml_gr_resize_window(caml_gr_state.width,caml_gr_state.height);
      caml_gr_set_line_width(caml_gr_state.line_width);
      caml_gr_set_text_size(caml_gr_state.text_size);
      caml_gr_set_font(caml_gr_state.font);
      caml_gr_set_color(caml_gr_state.color);
      caml_gr_set_window_title(caml_gr_state.title);
      caml_gr_state.context.textBaseline = "bottom"}
    function caml_gr_current_x(){var s=caml_gr_state_get();return s.x}
    function caml_ba_kind_of_typed_array(ta)
     {var g=globalThis,kind;
      if(ta instanceof g.Float32Array)
       kind = 0;
      else
       if(ta instanceof g.Float64Array)
        kind = 1;
       else
        if(ta instanceof g.Int8Array)
         kind = 2;
        else
         if(ta instanceof g.Uint8Array)
          kind = 3;
         else
          if(ta instanceof g.Int16Array)
           kind = 4;
          else
           if(ta instanceof g.Uint16Array)
            kind = 5;
           else
            if(ta instanceof g.Int32Array)
             kind = 6;
            else
             if(ta instanceof g.Uint32Array)
              kind = 6;
             else
              caml_invalid_argument
               ("caml_ba_kind_of_typed_array: unsupported kind");
      return kind}
    function caml_ba_from_typed_array(ta)
     {var kind=caml_ba_kind_of_typed_array(ta);
      return caml_ba_create_unsafe(kind,0,[ta.length],ta)}
    function caml_ml_seek_out(chanid,pos)
     {caml_ml_flush(chanid);caml_ml_channels[chanid].offset = pos;return 0}
    function caml_js_typeof(o){return typeof o}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function caml_gr_lineto(x,y)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(s.x,s.height - s.y);
      s.context.lineTo(x,s.height - y);
      s.context.stroke();
      s.x = x;
      s.y = y;
      return 0}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return f.apply(null,args)}}
    function caml_ba_dim_3(ba){return caml_ba_dim(ba,2)}
    function caml_is_special_exception(exn)
     {switch(exn[2]){case - 8:case - 11:case - 12:return 1;default:return 0}}
    function caml_format_exception(exn)
     {var r="";
      if(exn[0] == 0)
       {r += exn[1][1];
        if
         (exn.length
          ==
          3
          &&
          exn[2][0]
          ==
          0
          &&
          caml_is_special_exception(exn[1]))
         var bucket=exn[2],start=1;
        else
         var start=2,bucket=exn;
        r += "(";
        for(var i=start;i < bucket.length;i++)
         {if(i > start)r += ", ";
          var v=bucket[i];
          if(typeof v == "number")
           r += v.toString();
          else
           if(v instanceof MlBytes)
            r += '"' + v.toString() + '"';
           else
            if(typeof v == "string")
             r += '"' + v.toString() + '"';
            else
             r += "_"}
        r += ")"}
      else
       if(exn[0] == 248)r += exn[1];
      return r}
    function caml_fatal_uncaught_exception(err)
     {if(err instanceof Array && (err[0] == 0 || err[0] == 248))
       {var handler=caml_named_value("Printexc.handle_uncaught_exception");
        if(handler)
         handler(err,false);
        else
         {var
           msg=caml_format_exception(err),
           at_exit=caml_named_value("Pervasives.do_at_exit");
          if(at_exit)at_exit(0);
          globalThis.console.error("Fatal error: exception " + msg + "\n")}}
      else
       throw err}
    var caml_ephe_data_offset=2;
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b1=caml_bytes_unsafe_get(s,i),b2=caml_bytes_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function caml_js_from_bool(x){return ! ! x}
    function caml_ml_set_channel_name(){return 0}
    function caml_exp2_float(x){return Math.pow(2,x)}
    function caml_gr_close_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = 0;
      s.canvas.height = 0;
      return 0}
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_md5_string(s,ofs,len)
     {return caml_md5_bytes(caml_bytes_of_string(s),ofs,len)}
    function caml_md5_chan(chanid,len)
     {var chan=caml_ml_channels[chanid],chan_len=chan.file.length();
      if(len < 0)len = chan_len - chan.offset;
      if(chan.offset + len > chan_len)caml_raise_end_of_file();
      var buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      return caml_md5_string(caml_string_of_bytes(buf),0,len)}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_atanh_float(x){return Math.atanh(x)}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var bytes;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       bytes = buffer;
      else
       {bytes = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,bytes,0,len)}
      var
       string=caml_string_of_bytes(bytes),
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_xmlhttprequest_create(unit)
     {var g=globalThis;
      if(typeof g.XMLHttpRequest !== "undefined")
       try {return new (g.XMLHttpRequest)()}catch(e){}
      if(typeof g.activeXObject !== "undefined")
       {try {return new (g.activeXObject)("Msxml2.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Msxml3.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Microsoft.XMLHTTP")}catch(e){}}
      caml_failwith("Cannot create a XMLHttpRequest")}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_ml_is_buffered(c){return 1}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_js_expr(s)
     {js_print_stderr("caml_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function caml_int64_mul(x,y){return x.mul(y)}
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function caml_output_value_to_bytes(v,flags)
     {return caml_bytes_of_array(caml_output_val(v,flags))}
    function caml_eventlog_resume(unit){return 0}
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(caml_is_ml_bytes(obj))
          {count--;
           var content=caml_ml_bytes_content(obj);
           if(typeof content === "string")
            for(var b=content,l=b.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
           else
            for(var a=content,l=a.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + a[i] | 0}
         else
          if(caml_is_ml_string(obj))
           {var jsbytes=caml_jsbytes_of_string(obj);
            for(var b=jsbytes,l=jsbytes.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0}
          else
           if(typeof obj === "string")
            for(var b=obj,l=obj.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
           else
            if(obj === (obj | 0))
             {count--;hash_accu = hash_accu * 65599 + obj | 0}
            else
             if(obj === + obj)
              {count--;
               var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
               for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
             else
              if(obj && obj.caml_custom)
               if
                (caml_custom_ops[obj.caml_custom]
                 &&
                 caml_custom_ops[obj.caml_custom].hash)
                {var h=caml_custom_ops[obj.caml_custom].hash(obj) | 0;
                 hash_accu = hash_accu * 65599 + h | 0}}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_output_value_to_buffer(s,ofs,len,v,flags)
     {var t=caml_output_val(v,flags);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function re_replacement_text(repl,groups,orig)
     {var
       repl=caml_jsbytes_of_string(repl),
       len=repl.length,
       orig=caml_jsbytes_of_string(orig),
       res="",
       n=0,
       cur,
       start,
       end,
       c;
      while(n < len)
       {cur = repl.charAt(n++);
        if(cur != "\\")
         res += cur;
        else
         {if(n == len)
           caml_failwith("Str.replace: illegal backslash sequence");
          cur = repl.charAt(n++);
          switch(cur)
           {case "\\":res += cur;break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
             c = + cur;
             if(c * 2 >= groups.length - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             start = caml_array_get(groups,c * 2);
             end = caml_array_get(groups,c * 2 + 1);
             if(start == - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             res += orig.slice(start,end);
             break;
            default:res += "\\" + cur}}}
      return caml_string_of_jsbytes(res)}
    function caml_pure_js_expr(s)
     {js_print_stderr("caml_pure_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function caml_int64_ult(x,y){return x.ucompare(y) < 0}
    function caml_int64_xor(x,y){return x.xor(y)}
    function caml_bigstring_blit_ba_to_bytes(ba1,pos1,bytes2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(pos2 + len > caml_ml_bytes_length(bytes2))caml_array_bound_error();
      var slice=ba1.data.slice(ofs1,ofs1 + len);
      caml_blit_bytes(caml_bytes_of_array(slice),0,bytes2,pos2,len);
      return 0}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function jsoo_create_file_extern(name,content)
     {if(globalThis.jsoo_create_file)
       globalThis.jsoo_create_file(name,content);
      else
       {if(! globalThis.caml_fs_tmp)globalThis.caml_fs_tmp = [];
        globalThis.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_to_js_string(s){return caml_jsstring_of_string(s)}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=
        new MlInt64(0xffffff,0xfffffff,0xffff).udivmod(base64).quotient,
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(base == 10 && caml_int64_ult(new MlInt64(0,0,0x8000),res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function re_search_forward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_forward");
      while(pos <= caml_ml_string_length(s))
       {var res=re_match(re,s,pos,0);if(res)return res;pos++}
      return [0]}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_ml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
      return 0}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_string_of_jsbytes(a[i]);
      return l}
    function caml_ml_output_char(chanid,c)
     {var s=caml_string_of_jsbytes(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_sys_const_ostype_win32(){return os_type == "Win32"?1:0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_obj_set_raw_field(o,i,v){return o[i + 1] = v}
    function caml_js_var(x)
     {var x=caml_jsstring_of_string(x);
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function caml_trunc_float(x){return Math.trunc(x)}
    function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];return 0}
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function re_partial_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.partial_match");
      var res=re_match(re,s,pos,1);
      return res?res:[0]}
    function caml_sys_random_seed()
     {if(globalThis.crypto)
       if(typeof globalThis.crypto.getRandomValues === "function")
        {var a=new (globalThis.Uint32Array)(1);
         globalThis.crypto.getRandomValues(a);
         return [0,a[0]]}
       else
        if(globalThis.crypto.randomBytes === "function")
         {var
           buff=globalThis.crypto.randomBytes(4),
           a=new (globalThis.Uint32Array)(buff);
          return [0,a[0]]}
      var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_final_register_called_without_value(){return 0}
    function caml_ba_get_2(ba,i0,i1){return ba.get(ba.offset([i0,i1]))}
    function win_handle_fd(x){return x}
    function caml_ba_uint8_set16(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      return 0}
    var win_filedescr_of_channel=caml_channel_descriptor;
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;
        prev = [0,caml_string_of_jsbytes(jsoo_mount_point[i].path),old]}
      return prev}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12,
       CODE_CUSTOM_LEN:0x18,
       CODE_CUSTOM_FIXED:0x19};
    function caml_obj_raw_field(o,i){return o[i + 1]}
    function caml_js_equals(x,y){return + (x == y)}
    function bigstring_to_typed_array(bs){return bs.data}
    function caml_gr_arc_aux(ctx,cx,cy,ry,rx,a1,a2)
     {while(a1 > a2)a2 += 360;
      a1 /= 180;
      a2 /= 180;
      var
       rot=0,
       xPos,
       yPos,
       xPos_prev,
       yPos_prev,
       space=2,
       num=(a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
       delta=(a2 - a1) * Math.PI / num,
       i=a1 * Math.PI;
      for(var j=0;j <= num;j++)
       {xPos
        =
        cx
        -
        rx
        *
        Math.sin(i)
        *
        Math.sin(rot * Math.PI)
        +
        ry
        *
        Math.cos(i)
        *
        Math.cos(rot * Math.PI);
        xPos = xPos.toFixed(2);
        yPos
        =
        cy
        +
        ry
        *
        Math.cos(i)
        *
        Math.sin(rot * Math.PI)
        +
        rx
        *
        Math.sin(i)
        *
        Math.cos(rot * Math.PI);
        yPos = yPos.toFixed(2);
        if(j == 0)
         ctx.moveTo(xPos,yPos);
        else
         if(xPos_prev != xPos || yPos_prev != yPos)ctx.lineTo(xPos,yPos);
        xPos_prev = xPos;
        yPos_prev = yPos;
        i -= delta}
      return 0}
    function caml_gr_fill_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.fill();
      return 0}
    function caml_ba_slice(ba,vind)
     {vind = caml_js_from_array(vind);
      var num_inds=vind.length,index=[],sub_dims=[],ofs;
      if(num_inds > ba.dims.length)
       caml_invalid_argument("Bigarray.slice: too many indices");
      if(ba.layout == 0)
       {for(var i=0;i < num_inds;i++)index[i] = vind[i];
        for(;i < ba.dims.length;i++)index[i] = 0;
        sub_dims = ba.dims.slice(num_inds)}
      else
       {for(var i=0;i < num_inds;i++)
         index[ba.dims.length - num_inds + i] = vind[i];
        for(var i=0;i < ba.dims.length - num_inds;i++)index[i] = 1;
        sub_dims = ba.dims.slice(0,ba.dims.length - num_inds)}
      ofs = ba.offset(index);
      var
       size=caml_ba_get_size(sub_dims),
       size_per_element=caml_ba_get_size_per_element(ba.kind),
       new_data=
        ba.data.subarray
         (ofs * size_per_element,(ofs + size) * size_per_element);
      return caml_ba_create_unsafe(ba.kind,ba.layout,sub_dims,new_data)}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],buf=caml_create_bytes(8);
      chan.file.read(chan.offset,buf,0,8);
      var len=caml_marshal_data_size(buf,0) + 20,buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      var offset=[0],res=caml_input_value_from_bytes(buf,offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_ba_kind(ba){return ba.kind}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_gc_major_slice(work){return 0}
    function caml_js_pure_expr(f){return f()}
    function compare_digits_nat(nat1,ofs1,nat2,ofs2)
     {if(nat1.data[ofs1] > nat2.data[ofs2])return 1;
      if(nat1.data[ofs1] < nat2.data[ofs2])return - 1;
      return 0}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_gr_wait_event(_evl)
     {caml_failwith
       ("caml_gr_wait_event not Implemented: use Graphics_js instead")}
    function caml_gr_sigio_handler(){return 0}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_bytes_arr(h,bs.data)}
    function caml_record_backtrace(){return 0}
    function unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_sys_const_backend_type()
     {return [0,caml_string_of_jsbytes("js_of_ocaml")]}
    function caml_sys_get_config()
     {return [0,caml_string_of_jsbytes(os_type),32,0]}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function caml_asinh_float(x){return Math.asinh(x)}
    function bigstring_of_array_buffer(ab)
     {var ta=new (globalThis.Uint8Array)(ab);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_ba_init(){return 0}
    function re_string_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.string_match");
      var res=re_match(re,s,pos,0);
      return res?res:[0]}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_gr_dump_image(im)
     {var data=[0];
      for(var i=0;i < im.height;i++)
       {data[i + 1] = [0];
        for(var j=0;j < im.width;j++)
         {var
           o=i * (im.width * 4) + j * 4,
           r=im.data[o + 0],
           g=im.data[o + 1],
           b=im.data[o + 2];
          data[i + 1][j + 1] = (r << 16) + (g << 8) + b}}
      return data}
    function caml_ba_get_generic(ba,i)
     {var ofs=ba.offset(caml_js_from_array(i));return ba.get(ofs)}
    function caml_get_exception_backtrace(){return 0}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=caml_trailing_slash(path.join("/"));
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function caml_bigstring_blit_ba_to_ba(ba1,pos1,ba2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(12 != ba2.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1),ofs2=ba2.offset(pos2);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=ba1.data.subarray(ofs1,ofs1 + len);
      ba2.data.set(slice,pos2);
      return 0}
    var caml_blit_bigstring_to_bigstring=caml_bigstring_blit_ba_to_ba;
    function caml_string_lessthan(s1,s2){return caml_bytes_lessthan(s1,s2)}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_memprof_start(rate,stack_size,tracker){return 0}
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_js_to_bool(x){return + x}
    function caml_gr_create_image(x,y)
     {var s=caml_gr_state_get();return s.context.createImageData(x,y)}
    var caml_ephe_get_key_copy=caml_weak_get_copy;
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_raw_backtrace_next_slot(){return 0}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && globalThis.toplevelReloc)
       n = globalThis.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function caml_js_from_float(x){return x}
    function caml_floatarray_create(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_get_major_credit(n){return 0}
    function caml_sys_modify_argv(arg){caml_argv = arg;return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === undefined)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_js_get_console()
     {var
       c=globalThis.console?globalThis.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name)}
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var refill=null;
      if(fd == 0 && fs_node_supported())
       {var fs=require("fs");
        refill
        =
        function(){return caml_string_of_jsstring(fs.readFileSync(0,"utf8"))}}
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:refill};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function bigstring_of_typed_array(ba)
     {var
       ta=
        new
         (globalThis.Uint8Array)
         (ba.buffer,ba.byteOffset,ba.length * ba.BYTES_PER_ELEMENT);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_round_float(x){return Math.round(x)}
    function unix_stat(name)
     {var root=resolve_fs_device(name);
      if(! root.device.stat)caml_failwith("unix_stat: not implemented");
      return root.device.stat(root.rest,true)}
    var unix_stat_64=unix_stat;
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    function complement_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)
       nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)}
    var caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ba_dim_2(ba){return caml_ba_dim(ba,1)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[this,args])}}
    function caml_sinh_float(x){return Math.sinh(x)}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_gr_state_set(ctx)
     {caml_gr_state = ctx;caml_gr_state_init();return 0}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity && f.length == arity)return f.apply(null,arguments);
        var args=new Array(arity),len=Math.min(arguments.length,arity);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_gc_minor_words(unit){return 0}
    function caml_ba_set_1(ba,i0,v){ba.set(ba.offset(i0),v);return 0}
    function caml_get_current_callstack(){return [0]}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function caml_int64_mod(x,y){return x.mod(y)}
    function unix_readlink(name)
     {var root=resolve_fs_device(name);
      if(! root.device.readlink)
       caml_failwith("unix_readlink: not implemented");
      return root.device.readlink(root.rest,true)}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function win_startup(){}
    function caml_ba_set_3(ba,i0,i1,i2,v)
     {ba.set(ba.offset([i0,i1,i2]),v);return 0}
    function caml_js_instanceof(o,c){return o instanceof c?1:0}
    function caml_get_major_bucket(n){return 0}
    var caml_blit_bigstring_to_string=caml_bigstring_blit_ba_to_bytes;
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function caml_gr_state_create(canvas,w,h)
     {var context=canvas.getContext("2d");
      return {context:context,
              canvas:canvas,
              x:0,
              y:0,
              width:w,
              height:h,
              line_width:1,
              font:caml_string_of_jsbytes("fixed"),
              text_size:26,
              color:0x000000,
              title:caml_string_of_jsbytes("")}}
    function caml_js_wrap_callback(f)
     {return function()
       {var len=arguments.length;
        if(len > 0)
         {var args=new Array(len);
          for(var i=0;i < len;i++)args[i] = arguments[i];
          return caml_call_gen(f,args)}
        else
         return caml_call_gen(f,[undefined])}}
    function caml_gr_draw_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.stroke();
      return 0}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function unix_symlink(to_dir,src,dst)
     {var src_root=resolve_fs_device(src),dst_root=resolve_fs_device(dst);
      if(src_root.device != dst_root.device)
       caml_failwith("unix_symlink: cannot symlink between two filesystems");
      if(! src_root.device.symlink)
       caml_failwith("unix_symlink: not implemented");
      return src_root.device.symlink(to_dir,src_root.rest,dst_root.rest,true)}
    function caml_ba_create_from(data1,data2,jstyp,kind,layout,dims)
     {if(data2 || caml_ba_get_size_per_element(kind) == 2)
       caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
      return caml_ba_create_unsafe(kind,layout,dims,data1)}
    function caml_tanh_float(x){return Math.tanh(x)}
    function caml_gr_draw_str(str)
     {var s=caml_gr_state_get(),m=s.context.measureText(str),dx=m.width;
      s.context.fillText(str,s.x,s.height - s.y);
      s.x += dx | 0;
      return 0}
    function caml_gr_draw_string(str)
     {caml_gr_draw_str(caml_jsstring_of_string(str));return 0}
    function caml_gr_draw_char(c)
     {caml_gr_draw_str(String.fromCharCode(c));return 0}
    function caml_unmount(name)
     {var
       path=caml_make_path(name),
       name=caml_trailing_slash(path.join("/")),
       idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlStringReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_draw_image(im,x,y)
     {var s=caml_gr_state_get();
      if(! im.image)
       {var canvas=document.createElement("canvas");
        canvas.width = s.width;
        canvas.height = s.height;
        canvas.getContext("2d").putImageData(im,0,0);
        var image=new (globalThis.Image)();
        image.onload
        =
        function()
         {s.context.drawImage(image,x,s.height - im.height - y);
          im.image = image};
        image.src = canvas.toDataURL("image/png")}
      else
       s.context.drawImage(im.image,x,s.height - im.height - y);
      return 0}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function caml_sys_rmdir(name)
     {var root=resolve_fs_device(name);root.device.rmdir(root.rest);return 0}
    function caml_ml_pos_out(chanid)
     {caml_ml_flush(chanid);return caml_ml_channels[chanid].offset}
    function caml_spacetime_enabled(_unit){return 0}
    function caml_bytes_notequal(s1,s2){return 1 - caml_bytes_equal(s1,s2)}
    function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("")}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++)
       {var p=a[i];o[caml_jsstring_of_string(p[1])] = p[2]}
      return o}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    function caml_gr_remember_mode()
     {caml_failwith("caml_gr_remember_mode not Implemented")}
    function caml_fma_float(x,y,z)
     {var
       SPLIT=Math.pow(2,27) + 1,
       MIN_VALUE=Math.pow(2,- 1022),
       EPSILON=Math.pow(2,- 52),
       C=416,
       A=Math.pow(2,+ C),
       B=Math.pow(2,- C);
      function multiply(a,b)
       {var
         at=SPLIT * a,
         ahi=at - (at - a),
         alo=a - ahi,
         bt=SPLIT * b,
         bhi=bt - (bt - b),
         blo=b - bhi,
         p=a * b,
         e=ahi * bhi - p + ahi * blo + alo * bhi + alo * blo;
        return {p:p,e:e}}
      function add(a,b)
       {var s=a + b,v=s - a,e=a - (s - v) + (b - v);return {s:s,e:e}}
      function adjust(x,y)
       {return x !== 0 && y !== 0 && SPLIT * x - (SPLIT * x - x) === x
                ?x * (1 + (x < 0?- 1:+ 1) * (y < 0?- 1:+ 1) * EPSILON)
                :x}
      if
       (x
        ===
        0
        ||
        x
        !==
        x
        ||
        x
        ===
        +
        (1 / 0)
        ||
        x
        ===
        -
        (1 / 0)
        ||
        y
        ===
        0
        ||
        y
        !==
        y
        ||
        y
        ===
        +
        (1 / 0)
        ||
        y
        ===
        -
        (1 / 0))
       return x * y + z;
      if(z === 0)return x * y;
      if(z !== z || z === + (1 / 0) || z === - (1 / 0))return z;
      var scale=1;
      while(Math.abs(x) > A){scale *= A;x *= B}
      while(Math.abs(y) > A){scale *= A;y *= B}
      if(scale === 1 / 0)return x * y * scale;
      while(Math.abs(x) < B){scale *= B;x *= A}
      while(Math.abs(y) < B){scale *= B;y *= A}
      if(scale === 0)return z;
      var xs=x,ys=y,zs=z / scale;
      if(Math.abs(zs) > Math.abs(xs * ys) * 4 / EPSILON)return z;
      if(Math.abs(zs) < Math.abs(xs * ys) * EPSILON / 4 * EPSILON / 4)
       zs = (z < 0?- 1:+ 1) * MIN_VALUE;
      var
       xy=multiply(xs,ys),
       s=add(xy.p,zs),
       u=add(xy.e,s.e),
       i=add(s.s,u.s),
       f=i.s + adjust(i.e,u.e);
      if(f === 0)return f;
      var fs=f * scale;
      if(Math.abs(fs) > MIN_VALUE)return fs;
      return fs + adjust(f - fs / scale,i.e) * scale}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid],data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
      return 0}
    function caml_final_register(){return 0}
    function caml_gr_draw_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.strokeRect(x,s.height - y,w,- h);
      return 0}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;return 0}
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get(ba.offset([i0,i1,i2]))}
    var
     caml_ephe_blit_key=caml_weak_blit,
     caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_sys_time_include_children(b){return caml_sys_time()}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function unix_getpwuid(unit){caml_raise_not_found()}
    function caml_hash_mix_string(h,v)
     {return caml_hash_mix_jsbytes(h,caml_jsbytes_of_string(v))}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            default:
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(caml_is_ml_bytes(v))
           {h = caml_hash_mix_bytes(h,v);num--}
          else
           if(caml_is_ml_string(v))
            {h = caml_hash_mix_string(h,v);num--}
           else
            if(typeof v === "string")
             {h = caml_hash_mix_jsbytes(h,v);num--}
            else
             if(v === (v | 0))
              {h = caml_hash_mix_int(h,v + v + 1);num--}
             else
              if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    function caml_ba_to_typed_array(ba){return ba.data}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b1=caml_bytes_unsafe_get(s,i),
       b2=caml_bytes_unsafe_get(s,i + 1),
       b3=caml_bytes_unsafe_get(s,i + 2),
       b4=caml_bytes_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_js_error_option_of_exception(exn)
     {if(exn.js_error)return [0,exn.js_error];return 0}
    function caml_ml_pos_out_64(chanid)
     {caml_ml_flush(chanid);
      return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_close_subwindow(a)
     {caml_failwith("caml_gr_close_subwindow not Implemented")}
    function caml_floatarray_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_get_minor_free(unit){return 0}
    function caml_set_static_env(k,v)
     {if(! globalThis.jsoo_static_env)globalThis.jsoo_static_env = {};
      globalThis.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)
       new_dims[i] = ba.dims[ba.dims.length - i - 1];
      return caml_ba_create_unsafe(ba.kind,layout,new_dims,ba.data)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    function unix_mkdir(name,perm)
     {var root=resolve_fs_device(name);
      if(! root.device.mkdir)caml_failwith("unix_mkdir: not implemented");
      return root.device.mkdir(root.rest,perm,true)}
    function caml_gr_current_y(){var s=caml_gr_state_get();return s.y}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function caml_js_to_string(s){return caml_string_of_jsstring(s)}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function caml_runtime_variant(_unit){return caml_string_of_jsbytes("")}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_gr_open_graph(info)
     {var g=globalThis,info=caml_jsstring_of_string(info);
      function get(name)
       {var res=info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
        if(res)return res[2]}
      var specs=[];
      if(! (info == ""))specs.push(info);
      var target=get("target");
      if(! target)target = "";
      var status=get("status");
      if(! status)specs.push("status=1");
      var w=get("width");
      w = w?parseInt(w):200;
      specs.push("width=" + w);
      var h=get("height");
      h = h?parseInt(h):200;
      specs.push("height=" + h);
      var win=g.open("about:blank",target,specs.join(","));
      if(! win)caml_failwith("Graphics.open_graph: cannot open the window");
      var doc=win.document,canvas=doc.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      var ctx=caml_gr_state_create(canvas,w,h);
      ctx.set_title = function(title){doc.title = title};
      caml_gr_state_set(ctx);
      var body=doc.body;
      body.style.margin = "0px";
      body.appendChild(canvas);
      return 0}
    function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;return 0}
    function caml_make_float_vect(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_cbrt_float(x){return Math.cbrt(x)}
    function caml_memprof_stop(unit){return 0}
    function caml_eventlog_pause(unit){return 0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_log1p_float(x){return Math.log1p(x)}
    function caml_int64_or(x,y){return x.or(y)}
    function caml_lazy_make_forward(v){return [250,v]}
    function lor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] |= nat2.data[ofs2];return 0}
    function caml_gr_blit_image(im,x,y)
     {var
       s=caml_gr_state_get(),
       im2=
        s.context.getImageData(x,s.height - im.height - y,im.width,im.height);
      for(var i=0;i < im2.data.length;i += 4)
       {im.data[i] = im2.data[i];
        im.data[i + 1] = im2.data[i + 1];
        im.data[i + 2] = im2.data[i + 2];
        im.data[i + 3] = im2.data[i + 3]}
      return 0}
    function caml_gr_window_id(a)
     {caml_failwith("caml_gr_window_id not Implemented")}
    function caml_js_on_ie()
     {var ua=globalThis.navigator?globalThis.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_int64_shift_right(x,s){return x.shift_right(s)}
    function caml_ba_layout(ba){return ba.layout}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function caml_gr_doc_of_state(state)
     {if(state.canvas.ownerDocument)return state.canvas.ownerDocument}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    function caml_obj_with_tag(tag,x)
     {var l=x.length,a=new Array(l);
      a[0] = tag;
      for(var i=1;i < l;i++)a[i] = x[i];
      return a}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var args=new Array(arity + 1),len=Math.min(arguments.length,arity);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_backtrace_status(){return 0}
    function caml_sys_argv(a){return caml_argv}
    function caml_install_signal_handler(){return 0}
    function caml_ba_fill(ba,v){ba.fill(v);return 0}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function caml_sys_mkdir(name,perm)
     {var root=resolve_fs_device(name);
      root.device.mkdir(root.rest,perm);
      return 0}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_gr_make_image(arr)
     {var
       s=caml_gr_state_get(),
       h=arr.length - 1,
       w=arr[1].length - 1,
       im=s.context.createImageData(w,h);
      for(var i=0;i < h;i++)
       for(var j=0;j < w;j++)
        {var c=arr[i + 1][j + 1],o=i * (w * 4) + j * 4;
         if(c == - 1)
          {im.data[o + 0] = 0;
           im.data[o + 1] = 0;
           im.data[o + 2] = 0;
           im.data[o + 3] = 0}
         else
          {im.data[o + 0] = c >> 16 & 0xff;
           im.data[o + 1] = c >> 8 & 0xff;
           im.data[o + 2] = c >> 0 & 0Xff;
           im.data[o + 3] = 0xff}}
      return im}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_read_file_content(name)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=caml_create_bytes(len);
        file.read(0,buf,0,len);
        return caml_string_of_bytes(buf)}
      caml_raise_no_such_file(caml_jsbytes_of_string(name))}
    function caml_js_to_float(x){return x}
    function caml_setup_uncaught_exception_handler()
     {var g=globalThis;
      if(g.process && g.process.on)
       g.process.on
        ("uncaughtException",
         function(err,origin)
          {caml_fatal_uncaught_exception(err);g.process.exit(2)});
      else
       if(g.addEventListener)
        g.addEventListener
         ("error",
          function(event)
           {if(event.error)caml_fatal_uncaught_exception(event.error)})}
    caml_setup_uncaught_exception_handler();
    globalThis.jsoo_runtime
    =
    {caml_ephe_key_offset:caml_ephe_key_offset,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_weak_create:caml_weak_create,
     caml_weak_set:caml_weak_set,
     caml_weak_get:caml_weak_get,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_check:caml_weak_check,
     caml_weak_blit:caml_weak_blit,
     caml_ephe_create:caml_ephe_create,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_check_data:caml_ephe_check_data,
     unix_gettimeofday:unix_gettimeofday,
     unix_time:unix_time,
     unix_gmtime:unix_gmtime,
     unix_localtime:unix_localtime,
     unix_mktime:unix_mktime,
     win_startup:win_startup,
     win_cleanup:win_cleanup,
     win_handle_fd:win_handle_fd,
     unix_isatty:unix_isatty,
     make_unix_err_args:make_unix_err_args,
     unix_stat:unix_stat,
     unix_stat_64:unix_stat_64,
     unix_lstat:unix_lstat,
     unix_lstat_64:unix_lstat_64,
     unix_mkdir:unix_mkdir,
     unix_rmdir:unix_rmdir,
     unix_symlink:unix_symlink,
     unix_readlink:unix_readlink,
     unix_unlink:unix_unlink,
     unix_getuid:unix_getuid,
     unix_getpwuid:unix_getpwuid,
     unix_has_symlink:unix_has_symlink,
     re_match:re_match,
     re_search_forward:re_search_forward,
     re_search_backward:re_search_backward,
     re_string_match:re_string_match,
     re_partial_match:re_partial_match,
     re_replacement_text:re_replacement_text,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_sys_exit:caml_sys_exit,
     caml_is_special_exception:caml_is_special_exception,
     caml_format_exception:caml_format_exception,
     caml_fatal_uncaught_exception:caml_fatal_uncaught_exception,
     caml_set_static_env:caml_set_static_env,
     caml_sys_getenv:caml_sys_getenv,
     caml_sys_unsafe_getenv:caml_sys_unsafe_getenv,
     caml_argv:caml_argv,
     caml_executable_name:caml_executable_name,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_sys_argv:caml_sys_argv,
     caml_sys_modify_argv:caml_sys_modify_argv,
     caml_sys_executable_name:caml_sys_executable_name,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_time:caml_sys_time,
     caml_sys_time_include_children:caml_sys_time_include_children,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     os_type:os_type,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_isatty:caml_sys_isatty,
     caml_runtime_variant:caml_runtime_variant,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_install_signal_handler:caml_install_signal_handler,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_runtime_warnings:caml_runtime_warnings,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_sys_const_naked_pointers_checked:
     caml_sys_const_naked_pointers_checked,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_call_gen:caml_call_gen,
     caml_named_values:caml_named_values,
     caml_register_named_value:caml_register_named_value,
     caml_named_value:caml_named_value,
     caml_global_data:caml_global_data,
     caml_register_global:caml_register_global,
     caml_get_global_data:caml_get_global_data,
     caml_is_printable:caml_is_printable,
     caml_parse_engine:caml_parse_engine,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_update_dummy:caml_update_dummy,
     caml_obj_is_block:caml_obj_is_block,
     caml_obj_tag:caml_obj_tag,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_block:caml_obj_block,
     caml_obj_with_tag:caml_obj_with_tag,
     caml_obj_dup:caml_obj_dup,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_make_forward:caml_obj_make_forward,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_get_public_method:caml_get_public_method,
     caml_oo_last_id:caml_oo_last_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_obj_raw_field:caml_obj_raw_field,
     caml_obj_set_raw_field:caml_obj_set_raw_field,
     caml_obj_reachable_words:caml_obj_reachable_words,
     caml_obj_add_offset:caml_obj_add_offset,
     initialize_nat:initialize_nat,
     MlNat:MlNat,
     caml_hash_nat:caml_hash_nat,
     nat_of_array:nat_of_array,
     create_nat:create_nat,
     set_to_zero_nat:set_to_zero_nat,
     blit_nat:blit_nat,
     set_digit_nat:set_digit_nat,
     nth_digit_nat:nth_digit_nat,
     set_digit_nat_native:set_digit_nat_native,
     nth_digit_nat_native:nth_digit_nat_native,
     num_digits_nat:num_digits_nat,
     num_leading_zero_bits_in_digit:num_leading_zero_bits_in_digit,
     is_digit_int:is_digit_int,
     is_digit_zero:is_digit_zero,
     is_digit_odd:is_digit_odd,
     incr_nat:incr_nat,
     add_nat:add_nat,
     complement_nat:complement_nat,
     decr_nat:decr_nat,
     sub_nat:sub_nat,
     mult_digit_nat:mult_digit_nat,
     mult_nat:mult_nat,
     square_nat:square_nat,
     shift_left_nat:shift_left_nat,
     div_helper:div_helper,
     div_digit_nat:div_digit_nat,
     div_nat:div_nat,
     shift_right_nat:shift_right_nat,
     compare_digits_nat:compare_digits_nat,
     compare_nat:compare_nat,
     compare_nat_real:compare_nat_real,
     land_digit_nat:land_digit_nat,
     lor_digit_nat:lor_digit_nat,
     lxor_digit_nat:lxor_digit_nat,
     serialize_nat:serialize_nat,
     deserialize_nat:deserialize_nat,
     caml_str_repeat:caml_str_repeat,
     caml_subarray_to_jsbytes:caml_subarray_to_jsbytes,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     jsoo_is_ascii:jsoo_is_ascii,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_string_bound_error:caml_string_bound_error,
     caml_bytes_bound_error:caml_bytes_bound_error,
     caml_string_get:caml_string_get,
     caml_string_get16:caml_string_get16,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get32:caml_string_get32,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get64:caml_string_get64,
     caml_bytes_get64:caml_bytes_get64,
     caml_bytes_get:caml_bytes_get,
     caml_string_set:caml_string_set,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set16:caml_string_set16,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set32:caml_string_set32,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set64:caml_string_set64,
     caml_bytes_set:caml_bytes_set,
     caml_bytes_of_utf16_jsstring:caml_bytes_of_utf16_jsstring,
     MlBytes:MlBytes,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     caml_convert_bytes_to_array:caml_convert_bytes_to_array,
     caml_array_of_bytes:caml_array_of_bytes,
     caml_array_of_string:caml_array_of_string,
     caml_create_string:caml_create_string,
     caml_create_bytes:caml_create_bytes,
     caml_string_of_array:caml_string_of_array,
     caml_bytes_of_array:caml_bytes_of_array,
     caml_bytes_compare:caml_bytes_compare,
     caml_bytes_equal:caml_bytes_equal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_fill_bytes:caml_fill_bytes,
     caml_fill_string:caml_fill_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_blit_string:caml_blit_string,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_bytes_of_jsbytes:caml_bytes_of_jsbytes,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_ml_string_length:caml_ml_string_length,
     caml_string_compare:caml_string_compare,
     caml_string_equal:caml_string_equal,
     caml_string_lessequal:caml_string_lessequal,
     caml_string_lessthan:caml_string_lessthan,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_jsbytes:caml_string_of_jsbytes,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_jsstring_of_string:caml_jsstring_of_string,
     caml_string_of_jsstring:caml_string_of_jsstring,
     caml_is_ml_bytes:caml_is_ml_bytes,
     caml_ml_bytes_content:caml_ml_bytes_content,
     caml_is_ml_string:caml_is_ml_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_new_string:caml_new_string,
     caml_js_from_string:caml_js_from_string,
     caml_to_js_string:caml_to_js_string,
     caml_js_to_string:caml_js_to_string,
     caml_md5_chan:caml_md5_chan,
     caml_md5_string:caml_md5_string,
     caml_md5_bytes:caml_md5_bytes,
     caml_marshal_constants:caml_marshal_constants,
     MlStringReader:MlStringReader,
     BigStringReader:BigStringReader,
     caml_float_of_bytes:caml_float_of_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_int64_unmarshal:caml_int64_unmarshal,
     caml_int64_marshal:caml_int64_marshal,
     caml_int32_unmarshal:caml_int32_unmarshal,
     caml_nativeint_unmarshal:caml_nativeint_unmarshal,
     caml_custom_ops:caml_custom_ops,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_marshal_data_size:caml_marshal_data_size,
     MlObjectTable:MlObjectTable,
     caml_legacy_custom_code:caml_legacy_custom_code,
     caml_output_val:caml_output_val,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_lex_array:caml_lex_array,
     caml_lex_engine:caml_lex_engine,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_get_console:caml_js_get_console,
     caml_xmlhttprequest_create:caml_xmlhttprequest_create,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_js_pure_expr:caml_js_pure_expr,
     caml_js_set:caml_js_set,
     caml_js_get:caml_js_get,
     caml_js_delete:caml_js_delete,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_typeof:caml_js_typeof,
     caml_trampoline:caml_trampoline,
     caml_trampoline_return:caml_trampoline_return,
     js_print_stdout:js_print_stdout,
     js_print_stderr:js_print_stderr,
     caml_is_js:caml_is_js,
     caml_wrap_exception:caml_wrap_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_js_error_option_of_exception:caml_js_error_option_of_exception,
     caml_js_from_bool:caml_js_from_bool,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_array:caml_js_from_array,
     caml_js_to_array:caml_js_to_array,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_list_to_js_array:caml_list_to_js_array,
     caml_js_var:caml_js_var,
     caml_js_call:caml_js_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_new:caml_js_new,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_equals:caml_js_equals,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_expr:caml_js_expr,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_object:caml_js_object,
     caml_sys_close:caml_sys_close,
     caml_std_output:caml_std_output,
     caml_sys_open:caml_sys_open,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_ml_channels:caml_ml_channels,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_channel_descriptor:caml_channel_descriptor,
     win_filedescr_of_channel:win_filedescr_of_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_input:caml_ml_input,
     caml_input_value:caml_input_value,
     caml_ml_input_char:caml_ml_input_char,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_flush:caml_ml_flush,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_output:caml_ml_output,
     caml_ml_output_char:caml_ml_output_char,
     caml_output_value:caml_output_value,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_is_buffered:caml_ml_is_buffered,
     caml_ml_set_buffered:caml_ml_set_buffered,
     caml_format_int:caml_format_int,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_parse_digit:caml_parse_digit,
     caml_int_of_string:caml_int_of_string,
     caml_mul:caml_mul,
     caml_div:caml_div,
     caml_mod:caml_mod,
     caml_bswap16:caml_bswap16,
     caml_int32_bswap:caml_int32_bswap,
     caml_int64_bswap:caml_int64_bswap,
     caml_int64_offset:caml_int64_offset,
     MlInt64:MlInt64,
     caml_int64_ult:caml_int64_ult,
     caml_int64_compare:caml_int64_compare,
     caml_int64_neg:caml_int64_neg,
     caml_int64_add:caml_int64_add,
     caml_int64_sub:caml_int64_sub,
     caml_int64_mul:caml_int64_mul,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_and:caml_int64_and,
     caml_int64_or:caml_int64_or,
     caml_int64_xor:caml_int64_xor,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_div:caml_int64_div,
     caml_int64_mod:caml_int64_mod,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_format:caml_int64_format,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_create_lo_mi_hi:caml_int64_create_lo_mi_hi,
     caml_int64_create_lo_hi:caml_int64_create_lo_hi,
     caml_int64_lo32:caml_int64_lo32,
     caml_int64_hi32:caml_int64_hi32,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_hash:caml_int64_hash,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_nextafter_float:caml_nextafter_float,
     caml_trunc_float:caml_trunc_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_classify_float:caml_classify_float,
     caml_modf_float:caml_modf_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_frexp_float:caml_frexp_float,
     caml_float_compare:caml_float_compare,
     caml_copysign_float:caml_copysign_float,
     caml_signbit_float:caml_signbit_float,
     caml_expm1_float:caml_expm1_float,
     caml_exp2_float:caml_exp2_float,
     caml_log1p_float:caml_log1p_float,
     caml_log2_float:caml_log2_float,
     caml_hypot_float:caml_hypot_float,
     caml_log10_float:caml_log10_float,
     caml_cosh_float:caml_cosh_float,
     caml_acosh_float:caml_acosh_float,
     caml_sinh_float:caml_sinh_float,
     caml_asinh_float:caml_asinh_float,
     caml_tanh_float:caml_tanh_float,
     caml_atanh_float:caml_atanh_float,
     caml_round_float:caml_round_float,
     caml_cbrt_float:caml_cbrt_float,
     caml_erf_float:caml_erf_float,
     caml_erfc_float:caml_erfc_float,
     caml_fma_float:caml_fma_float,
     caml_format_float:caml_format_float,
     caml_float_of_string:caml_float_of_string,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_jsbytes:caml_hash_mix_jsbytes,
     caml_hash_mix_bytes_arr:caml_hash_mix_bytes_arr,
     caml_hash_mix_bytes:caml_hash_mix_bytes,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash:caml_hash,
     caml_gr_state:caml_gr_state,
     caml_gr_state_get:caml_gr_state_get,
     caml_gr_state_set:caml_gr_state_set,
     caml_gr_open_graph:caml_gr_open_graph,
     caml_gr_state_init:caml_gr_state_init,
     caml_gr_state_create:caml_gr_state_create,
     caml_gr_doc_of_state:caml_gr_doc_of_state,
     caml_gr_close_graph:caml_gr_close_graph,
     caml_gr_set_window_title:caml_gr_set_window_title,
     caml_gr_resize_window:caml_gr_resize_window,
     caml_gr_clear_graph:caml_gr_clear_graph,
     caml_gr_size_x:caml_gr_size_x,
     caml_gr_size_y:caml_gr_size_y,
     caml_gr_set_color:caml_gr_set_color,
     caml_gr_plot:caml_gr_plot,
     caml_gr_point_color:caml_gr_point_color,
     caml_gr_moveto:caml_gr_moveto,
     caml_gr_current_x:caml_gr_current_x,
     caml_gr_current_y:caml_gr_current_y,
     caml_gr_lineto:caml_gr_lineto,
     caml_gr_draw_rect:caml_gr_draw_rect,
     caml_gr_arc_aux:caml_gr_arc_aux,
     caml_gr_draw_arc:caml_gr_draw_arc,
     caml_gr_set_line_width:caml_gr_set_line_width,
     caml_gr_fill_rect:caml_gr_fill_rect,
     caml_gr_fill_poly:caml_gr_fill_poly,
     caml_gr_fill_arc:caml_gr_fill_arc,
     caml_gr_draw_str:caml_gr_draw_str,
     caml_gr_draw_char:caml_gr_draw_char,
     caml_gr_draw_string:caml_gr_draw_string,
     caml_gr_set_font:caml_gr_set_font,
     caml_gr_set_text_size:caml_gr_set_text_size,
     caml_gr_text_size:caml_gr_text_size,
     caml_gr_make_image:caml_gr_make_image,
     caml_gr_dump_image:caml_gr_dump_image,
     caml_gr_draw_image:caml_gr_draw_image,
     caml_gr_create_image:caml_gr_create_image,
     caml_gr_blit_image:caml_gr_blit_image,
     caml_gr_sigio_handler:caml_gr_sigio_handler,
     caml_gr_sigio_signal:caml_gr_sigio_signal,
     caml_gr_wait_event:caml_gr_wait_event,
     caml_gr_synchronize:caml_gr_synchronize,
     caml_gr_remember_mode:caml_gr_remember_mode,
     caml_gr_display_mode:caml_gr_display_mode,
     caml_gr_window_id:caml_gr_window_id,
     caml_gr_open_subwindow:caml_gr_open_subwindow,
     caml_gr_close_subwindow:caml_gr_close_subwindow,
     caml_gc_minor:caml_gc_minor,
     caml_gc_major:caml_gc_major,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_counters:caml_gc_counters,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_stat:caml_gc_stat,
     caml_gc_set:caml_gc_set,
     caml_gc_get:caml_gc_get,
     caml_memprof_set:caml_memprof_set,
     caml_final_register:caml_final_register,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_release:caml_final_release,
     caml_memprof_start:caml_memprof_start,
     caml_memprof_stop:caml_memprof_stop,
     caml_eventlog_resume:caml_eventlog_resume,
     caml_eventlog_pause:caml_eventlog_pause,
     caml_gc_huge_fallback_count:caml_gc_huge_fallback_count,
     caml_gc_major_slice:caml_gc_major_slice,
     caml_gc_minor_words:caml_gc_minor_words,
     caml_get_minor_free:caml_get_minor_free,
     caml_get_major_bucket:caml_get_major_bucket,
     caml_get_major_credit:caml_get_major_credit,
     fs_node_supported:fs_node_supported,
     MlNodeDevice:MlNodeDevice,
     MlNodeFile:MlNodeFile,
     MlFakeDevice:MlFakeDevice,
     MlFakeFile:MlFakeFile,
     caml_trailing_slash:caml_trailing_slash,
     caml_current_dir:caml_current_dir,
     caml_get_root:caml_get_root,
     caml_root:caml_root,
     MlFile:MlFile,
     path_is_absolute:path_is_absolute,
     caml_make_path:caml_make_path,
     jsoo_mount_point:jsoo_mount_point,
     caml_list_mount_point:caml_list_mount_point,
     resolve_fs_device:resolve_fs_device,
     caml_mount_autoload:caml_mount_autoload,
     caml_unmount:caml_unmount,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_sys_chdir:caml_sys_chdir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_rename:caml_sys_rename,
     caml_sys_mkdir:caml_sys_mkdir,
     caml_sys_rmdir:caml_sys_rmdir,
     caml_ba_map_file:caml_ba_map_file,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     jsoo_create_file_extern:jsoo_create_file_extern,
     caml_fs_init:caml_fs_init,
     caml_create_file:caml_create_file,
     jsoo_create_file:jsoo_create_file,
     caml_read_file_content:caml_read_file_content,
     caml_parse_format:caml_parse_format,
     caml_finish_formatting:caml_finish_formatting,
     caml_raise_constant:caml_raise_constant,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_raise_with_args:caml_raise_with_args,
     caml_raise_with_string:caml_raise_with_string,
     caml_failwith:caml_failwith,
     caml_invalid_argument:caml_invalid_argument,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_not_found:caml_raise_not_found,
     caml_array_bound_error:caml_array_bound_error,
     caml_compare_val_tag:caml_compare_val_tag,
     caml_compare_val_get_custom:caml_compare_val_get_custom,
     caml_compare_val_number_custom:caml_compare_val_number_custom,
     caml_compare_val:caml_compare_val,
     caml_compare:caml_compare,
     caml_int_compare:caml_int_compare,
     caml_equal:caml_equal,
     caml_notequal:caml_notequal,
     caml_greaterequal:caml_greaterequal,
     caml_greaterthan:caml_greaterthan,
     caml_lessequal:caml_lessequal,
     caml_lessthan:caml_lessthan,
     caml_blit_bigstring_to_bigstring:caml_blit_bigstring_to_bigstring,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     bigstring_to_typed_array:bigstring_to_typed_array,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_of_typed_array:bigstring_of_typed_array,
     caml_bigstring_memcmp:caml_bigstring_memcmp,
     caml_bigstring_blit_ba_to_ba:caml_bigstring_blit_ba_to_ba,
     caml_bigstring_blit_string_to_ba:caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_bytes_to_ba:caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_ba_to_bytes:caml_bigstring_blit_ba_to_bytes,
     caml_ba_init:caml_ba_init,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_get_size_per_element:caml_ba_get_size_per_element,
     caml_ba_create_buffer:caml_ba_create_buffer,
     caml_ba_custom_name:caml_ba_custom_name,
     Ml_Bigarray:Ml_Bigarray,
     Ml_Bigarray_c_1_1:Ml_Bigarray_c_1_1,
     caml_ba_compare:caml_ba_compare,
     caml_ba_create_unsafe:caml_ba_create_unsafe,
     caml_ba_create:caml_ba_create,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_layout:caml_ba_layout,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_dim:caml_ba_dim,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_fill:caml_ba_fill,
     caml_ba_blit:caml_ba_blit,
     caml_ba_sub:caml_ba_sub,
     caml_ba_slice:caml_ba_slice,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_serialize:caml_ba_serialize,
     caml_ba_deserialize:caml_ba_deserialize,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_hash:caml_ba_hash,
     caml_ba_to_typed_array:caml_ba_to_typed_array,
     caml_ba_kind_of_typed_array:caml_ba_kind_of_typed_array,
     caml_ba_from_typed_array:caml_ba_from_typed_array,
     caml_ml_debug_info_status:caml_ml_debug_info_status,
     caml_backtrace_status:caml_backtrace_status,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_array_sub:caml_array_sub,
     caml_array_append:caml_array_append,
     caml_array_concat:caml_array_concat,
     caml_array_blit:caml_array_blit,
     caml_floatarray_blit:caml_floatarray_blit,
     caml_array_set:caml_array_set,
     caml_array_get:caml_array_get,
     caml_array_fill:caml_array_fill,
     caml_check_bound:caml_check_bound,
     caml_make_vect:caml_make_vect,
     caml_make_float_vect:caml_make_float_vect,
     caml_floatarray_create:caml_floatarray_create};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_string_of_jsbytes("Out_of_memory"),-1],"Out_of_memory");
    caml_register_global
     (1,[248,caml_string_of_jsbytes("Sys_error"),-2],"Sys_error");
    caml_register_global
     (2,[248,caml_string_of_jsbytes("Failure"),-3],"Failure");
    caml_register_global
     (3,
      [248,caml_string_of_jsbytes("Invalid_argument"),-4],
      "Invalid_argument");
    caml_register_global
     (4,[248,caml_string_of_jsbytes("End_of_file"),-5],"End_of_file");
    caml_register_global
     (5,
      [248,caml_string_of_jsbytes("Division_by_zero"),-6],
      "Division_by_zero");
    caml_register_global
     (6,[248,caml_string_of_jsbytes("Not_found"),-7],"Not_found");
    caml_register_global
     (7,[248,caml_string_of_jsbytes("Match_failure"),-8],"Match_failure");
    caml_register_global
     (8,[248,caml_string_of_jsbytes("Stack_overflow"),-9],"Stack_overflow");
    caml_register_global
     (9,[248,caml_string_of_jsbytes("Sys_blocked_io"),-10],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_string_of_jsbytes("Assert_failure"),-11],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-12],
      "Undefined_recursive_module");
    return}
  (globalThis));


//# 1 "../../.js/stdlib/stdlib.cma.js"
(function(globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_array_concat=runtime.caml_array_concat,
     caml_array_get=runtime.caml_array_get,
     caml_array_set=runtime.caml_array_set,
     caml_array_sub=runtime.caml_array_sub,
     caml_ba_change_layout=runtime.caml_ba_change_layout,
     caml_ba_create=runtime.caml_ba_create,
     caml_ba_dim_1=runtime.caml_ba_dim_1,
     caml_ba_dim_2=runtime.caml_ba_dim_2,
     caml_ba_kind=runtime.caml_ba_kind,
     caml_ba_num_dims=runtime.caml_ba_num_dims,
     caml_ba_reshape=runtime.caml_ba_reshape,
     caml_ba_set_1=runtime.caml_ba_set_1,
     caml_ba_set_2=runtime.caml_ba_set_2,
     caml_ba_set_3=runtime.caml_ba_set_3,
     caml_ba_set_generic=runtime.caml_ba_set_generic,
     caml_ba_slice=runtime.caml_ba_slice,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_blit_string=runtime.caml_blit_string,
     caml_bswap16=runtime.caml_bswap16,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_get16=runtime.caml_bytes_get16,
     caml_bytes_get32=runtime.caml_bytes_get32,
     caml_bytes_get64=runtime.caml_bytes_get64,
     caml_bytes_of_string=runtime.caml_bytes_of_string,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_set16=runtime.caml_bytes_set16,
     caml_bytes_set32=runtime.caml_bytes_set32,
     caml_bytes_set64=runtime.caml_bytes_set64,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_div=runtime.caml_div,
     caml_ephe_set_key=runtime.caml_ephe_set_key,
     caml_ephe_unset_key=runtime.caml_ephe_unset_key,
     caml_equal=runtime.caml_equal,
     caml_fill_bytes=runtime.caml_fill_bytes,
     caml_float_compare=runtime.caml_float_compare,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_floatarray_blit=runtime.caml_floatarray_blit,
     caml_floatarray_create=runtime.caml_floatarray_create,
     caml_format_float=runtime.caml_format_float,
     caml_format_int=runtime.caml_format_int,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_get_exception_raw_backtra=runtime.caml_get_exception_raw_backtrace,
     caml_get_public_method=runtime.caml_get_public_method,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_hash=runtime.caml_hash,
     caml_input_value=runtime.caml_input_value,
     caml_int32_bswap=runtime.caml_int32_bswap,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_bswap=runtime.caml_int64_bswap,
     caml_int64_compare=runtime.caml_int64_compare,
     caml_int64_float_of_bits=runtime.caml_int64_float_of_bits,
     caml_int64_format=runtime.caml_int64_format,
     caml_int64_mul=runtime.caml_int64_mul,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_of_string=runtime.caml_int64_of_string,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int_compare=runtime.caml_int_compare,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_lessequal=runtime.caml_lessequal,
     caml_lessthan=runtime.caml_lessthan,
     caml_make_vect=runtime.caml_make_vect,
     caml_marshal_data_size=runtime.caml_marshal_data_size,
     caml_md5_string=runtime.caml_md5_string,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_channel_size=runtime.caml_ml_channel_size,
     caml_ml_channel_size_64=runtime.caml_ml_channel_size_64,
     caml_ml_close_channel=runtime.caml_ml_close_channel,
     caml_ml_flush=runtime.caml_ml_flush,
     caml_ml_input=runtime.caml_ml_input,
     caml_ml_input_char=runtime.caml_ml_input_char,
     caml_ml_open_descriptor_in=runtime.caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out=runtime.caml_ml_open_descriptor_out,
     caml_ml_output=runtime.caml_ml_output,
     caml_ml_output_bytes=runtime.caml_ml_output_bytes,
     caml_ml_output_char=runtime.caml_ml_output_char,
     caml_ml_set_binary_mode=runtime.caml_ml_set_binary_mode,
     caml_ml_set_channel_name=runtime.caml_ml_set_channel_name,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_nextafter_float=runtime.caml_nextafter_float,
     caml_notequal=runtime.caml_notequal,
     caml_obj_block=runtime.caml_obj_block,
     caml_obj_make_forward=runtime.caml_obj_make_forward,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_output_value=runtime.caml_output_value,
     caml_register_global=runtime.caml_register_global,
     caml_register_named_value=runtime.caml_register_named_value,
     caml_restore_raw_backtrace=runtime.caml_restore_raw_backtrace,
     caml_set_oo_id=runtime.caml_set_oo_id,
     caml_signbit_float=runtime.caml_signbit_float,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_bytes=runtime.caml_string_of_bytes,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_sys_argv=runtime.caml_sys_argv,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_sys_open=runtime.caml_sys_open,
     caml_sys_random_seed=runtime.caml_sys_random_seed,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$0=caml_string_of_jsbytes("%,"),
     cst_really_input=caml_string_of_jsbytes("really_input"),
     cst_input=caml_string_of_jsbytes("input"),
     cst_output_substring=caml_string_of_jsbytes("output_substring"),
     cst_output=caml_string_of_jsbytes("output"),
     cst_12g=caml_string_of_jsbytes("%.12g"),
     cst=caml_string_of_jsbytes("."),
     cst_false$1=caml_string_of_jsbytes("false"),
     cst_true$1=caml_string_of_jsbytes("true"),
     cst_false$0=caml_string_of_jsbytes("false"),
     cst_true$0=caml_string_of_jsbytes("true"),
     cst_bool_of_string=caml_string_of_jsbytes("bool_of_string"),
     cst_true=caml_string_of_jsbytes("true"),
     cst_false=caml_string_of_jsbytes("false"),
     cst_char_of_int=caml_string_of_jsbytes("char_of_int"),
     cst_Stdlib_Exit=caml_string_of_jsbytes("Stdlib.Exit"),
     cst_Stdlib_Pervasives_Exit=
      caml_string_of_jsbytes("Stdlib.Pervasives.Exit"),
     cst_option_is_None=caml_string_of_jsbytes("option is None"),
     cst_result_is_Ok=caml_string_of_jsbytes("result is Ok _"),
     cst_result_is_Error=caml_string_of_jsbytes("result is Error _"),
     cst_true$2=caml_string_of_jsbytes("true"),
     cst_false$2=caml_string_of_jsbytes("false"),
     cst$1=caml_string_of_jsbytes("\\\\"),
     cst$2=caml_string_of_jsbytes("\\'"),
     cst_b=caml_string_of_jsbytes("\\b"),
     cst_t=caml_string_of_jsbytes("\\t"),
     cst_n=caml_string_of_jsbytes("\\n"),
     cst_r=caml_string_of_jsbytes("\\r"),
     cst_Char_chr=caml_string_of_jsbytes("Char.chr"),
     cst_is_not_a_latin1_character=
      caml_string_of_jsbytes(" is not a latin1 character"),
     cst_04X=caml_string_of_jsbytes("%04X"),
     cst_U=caml_string_of_jsbytes("U+"),
     cst_is_not_an_Unicode_scalar_v=
      caml_string_of_jsbytes(" is not an Unicode scalar value"),
     cst_X=caml_string_of_jsbytes("%X"),
     err_no_pred=caml_string_of_jsbytes("U+0000 has no predecessor"),
     err_no_succ=caml_string_of_jsbytes("U+10FFFF has no successor"),
     cst_Stdlib_Sys_Break=caml_string_of_jsbytes("Stdlib.Sys.Break"),
     ocaml_version=caml_string_of_jsbytes("4.13.0"),
     cst_List_map2=caml_string_of_jsbytes("List.map2"),
     cst_List_iter2=caml_string_of_jsbytes("List.iter2"),
     cst_List_fold_left2=caml_string_of_jsbytes("List.fold_left2"),
     cst_List_fold_right2=caml_string_of_jsbytes("List.fold_right2"),
     cst_List_for_all2=caml_string_of_jsbytes("List.for_all2"),
     cst_List_exists2=caml_string_of_jsbytes("List.exists2"),
     cst_List_combine=caml_string_of_jsbytes("List.combine"),
     cst_List_rev_map2=caml_string_of_jsbytes("List.rev_map2"),
     cst_List_init=caml_string_of_jsbytes("List.init"),
     cst_List_nth$0=caml_string_of_jsbytes("List.nth"),
     cst_nth=caml_string_of_jsbytes("nth"),
     cst_List_nth=caml_string_of_jsbytes("List.nth"),
     cst_tl=caml_string_of_jsbytes("tl"),
     cst_hd=caml_string_of_jsbytes("hd"),
     cst_Bytes_of_seq_cannot_grow_b=
      caml_string_of_jsbytes("Bytes.of_seq: cannot grow bytes"),
     cst_String_rcontains_from_Byte=
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes=
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Byt=
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_r=
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Byte=
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_in=
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
     cst_Bytes_concat=caml_string_of_jsbytes("Bytes.concat"),
     cst_String_blit_Bytes_blit_str=
      caml_string_of_jsbytes("String.blit / Bytes.blit_string"),
     cst_Bytes_blit=caml_string_of_jsbytes("Bytes.blit"),
     cst_String_fill_Bytes_fill=
      caml_string_of_jsbytes("String.fill / Bytes.fill"),
     cst_Bytes_extend=caml_string_of_jsbytes("Bytes.extend"),
     cst_String_sub_Bytes_sub=caml_string_of_jsbytes("String.sub / Bytes.sub"),
     cst_String_rcontains_from_Byte$0=
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes$0=
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Byt$0=
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_r$0=
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Byte$0=
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_in$0=
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
     cst$4=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_String_concat=caml_string_of_jsbytes("String.concat"),
     empty$1=caml_string_of_jsbytes(""),
     cst$5=caml_string_of_jsbytes("()"),
     cst_Marshal_from_bytes=caml_string_of_jsbytes("Marshal.from_bytes"),
     cst_Marshal_from_bytes$0=caml_string_of_jsbytes("Marshal.from_bytes"),
     cst_Marshal_data_size=caml_string_of_jsbytes("Marshal.data_size"),
     cst_Marshal_to_buffer_substrin=
      caml_string_of_jsbytes("Marshal.to_buffer: substring out of bounds"),
     cst_Obj_Ephemeron_blit_key=
      caml_string_of_jsbytes("Obj.Ephemeron.blit_key"),
     cst_Obj_Ephemeron_check_key=
      caml_string_of_jsbytes("Obj.Ephemeron.check_key"),
     cst_Obj_Ephemeron_unset_key=
      caml_string_of_jsbytes("Obj.Ephemeron.unset_key"),
     cst_Obj_Ephemeron_set_key=caml_string_of_jsbytes("Obj.Ephemeron.set_key"),
     cst_Obj_Ephemeron_get_key_copy=
      caml_string_of_jsbytes("Obj.Ephemeron.get_key_copy"),
     cst_Obj_Ephemeron_get_key=caml_string_of_jsbytes("Obj.Ephemeron.get_key"),
     cst_Obj_Ephemeron_create=caml_string_of_jsbytes("Obj.Ephemeron.create"),
     cst_Obj_extension_constructor$0=
      caml_string_of_jsbytes("Obj.extension_constructor"),
     cst_Obj_extension_constructor=
      caml_string_of_jsbytes("Obj.extension_constructor"),
     cst_Array_combine=caml_string_of_jsbytes("Array.combine"),
     cst_Array_exists2=caml_string_of_jsbytes("Array.exists2"),
     cst_Array_for_all2=caml_string_of_jsbytes("Array.for_all2"),
     cst_Array_map2_arrays_must_hav=
      caml_string_of_jsbytes("Array.map2: arrays must have the same length"),
     cst_Array_iter2_arrays_must_ha=
      caml_string_of_jsbytes("Array.iter2: arrays must have the same length"),
     cst_Array_blit=caml_string_of_jsbytes("Array.blit"),
     cst_Array_fill=caml_string_of_jsbytes("Array.fill"),
     cst_Array_sub=caml_string_of_jsbytes("Array.sub"),
     cst_Array_init=caml_string_of_jsbytes("Array.init"),
     cst_Stdlib_Array_Bottom=caml_string_of_jsbytes("Stdlib.Array.Bottom"),
     cst_Float_Array_map2_arrays_mu=
      caml_string_of_jsbytes
       ("Float.Array.map2: arrays must have the same length"),
     cst_Float_Array_iter2_arrays_m=
      caml_string_of_jsbytes
       ("Float.Array.iter2: arrays must have the same length"),
     cst_Float_array_blit=caml_string_of_jsbytes("Float.array.blit"),
     cst_Float_array_blit$0=caml_string_of_jsbytes("Float.array.blit"),
     cst_Float_Array_fill=caml_string_of_jsbytes("Float.Array.fill"),
     cst_Float_Array_sub=caml_string_of_jsbytes("Float.Array.sub"),
     cst_Float_Array_concat=caml_string_of_jsbytes("Float.Array.concat"),
     cst_Float_Array_init=caml_string_of_jsbytes("Float.Array.init"),
     cst_Stdlib_Float_Array_Bottom=
      caml_string_of_jsbytes("Stdlib.Float.Array.Bottom"),
     cst_d=caml_string_of_jsbytes("%d"),
     cst_d$0=caml_string_of_jsbytes("%d"),
     zero$2=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     one$2=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     minus_one$2=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     min_int$2=runtime.caml_int64_create_lo_mi_hi(0,0,32768),
     max_int$2=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32767),
     cst_d$1=caml_string_of_jsbytes("%d"),
     cst_Lexing_lex_refill_cannot_g=
      caml_string_of_jsbytes("Lexing.lex_refill: cannot grow buffer"),
     dummy_pos=[0,caml_string_of_jsbytes(""),0,0,-1],
     zero_pos=[0,caml_string_of_jsbytes(""),1,0,0],
     cst_syntax_error=caml_string_of_jsbytes("syntax error"),
     cst_Stdlib_Parsing_YYexit=caml_string_of_jsbytes("Stdlib.Parsing.YYexit"),
     cst_Stdlib_Parsing_Parse_error=
      caml_string_of_jsbytes("Stdlib.Parsing.Parse_error"),
     cst_Set_remove_min_elt=caml_string_of_jsbytes("Set.remove_min_elt"),
     cst_Set_bal=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$0=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$1=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$2=caml_string_of_jsbytes("Set.bal"),
     cst_Map_remove_min_elt=caml_string_of_jsbytes("Map.remove_min_elt"),
     cst_Map_bal=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$0=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$1=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$2=caml_string_of_jsbytes("Map.bal"),
     cst_Stdlib_Stack_Empty=caml_string_of_jsbytes("Stdlib.Stack.Empty"),
     cst_Stdlib_Queue_Empty=caml_string_of_jsbytes("Stdlib.Queue.Empty"),
     cst_CamlinternalLazy_Undefined=
      caml_string_of_jsbytes("CamlinternalLazy.Undefined"),
     cst_count=caml_string_of_jsbytes("{count = "),
     cst_data=caml_string_of_jsbytes("; data = "),
     cst$6=caml_string_of_jsbytes("}"),
     cst_Sempty=caml_string_of_jsbytes("Sempty"),
     cst_Scons=caml_string_of_jsbytes("Scons ("),
     cst$7=caml_string_of_jsbytes(", "),
     cst$8=caml_string_of_jsbytes(")"),
     cst_Sapp=caml_string_of_jsbytes("Sapp ("),
     cst$9=caml_string_of_jsbytes(", "),
     cst$10=caml_string_of_jsbytes(")"),
     cst_Slazy=caml_string_of_jsbytes("Slazy"),
     cst_Sgen=caml_string_of_jsbytes("Sgen"),
     cst_Sbuffio=caml_string_of_jsbytes("Sbuffio"),
     cst_Stdlib_Stream_Failure=caml_string_of_jsbytes("Stdlib.Stream.Failure"),
     cst_Stdlib_Stream_Error=caml_string_of_jsbytes("Stdlib.Stream.Error"),
     cst_Buffer_truncate=caml_string_of_jsbytes("Buffer.truncate"),
     cst_Buffer_add_channel=caml_string_of_jsbytes("Buffer.add_channel"),
     cst_Buffer_add_substring_add_s=
      caml_string_of_jsbytes("Buffer.add_substring/add_subbytes"),
     cst_Buffer_add_cannot_grow_buf=
      caml_string_of_jsbytes("Buffer.add: cannot grow buffer"),
     cst_Buffer_nth=caml_string_of_jsbytes("Buffer.nth"),
     cst_Buffer_blit=caml_string_of_jsbytes("Buffer.blit"),
     cst_Buffer_sub=caml_string_of_jsbytes("Buffer.sub"),
     cst_c=caml_string_of_jsbytes("%c"),
     cst_s=caml_string_of_jsbytes("%s"),
     cst_i=caml_string_of_jsbytes("%i"),
     cst_li=caml_string_of_jsbytes("%li"),
     cst_ni=caml_string_of_jsbytes("%ni"),
     cst_Li=caml_string_of_jsbytes("%Li"),
     cst_f=caml_string_of_jsbytes("%f"),
     cst_B=caml_string_of_jsbytes("%B"),
     cst$21=caml_string_of_jsbytes("%{"),
     cst$22=caml_string_of_jsbytes("%}"),
     cst$23=caml_string_of_jsbytes("%("),
     cst$24=caml_string_of_jsbytes("%)"),
     cst_a=caml_string_of_jsbytes("%a"),
     cst_t$0=caml_string_of_jsbytes("%t"),
     cst$25=caml_string_of_jsbytes("%?"),
     cst_r$0=caml_string_of_jsbytes("%r"),
     cst_r$1=caml_string_of_jsbytes("%_r"),
     cst_u$0=caml_string_of_jsbytes("%u"),
     cst_Printf_bad_conversion=
      caml_string_of_jsbytes("Printf: bad conversion %["),
     cst_Printf_bad_conversion$0=
      caml_string_of_jsbytes("Printf: bad conversion %_"),
     cst$30=caml_string_of_jsbytes("@{"),
     cst$31=caml_string_of_jsbytes("@["),
     cst$32=caml_string_of_jsbytes("@{"),
     cst$33=caml_string_of_jsbytes("@["),
     cst$34=caml_string_of_jsbytes("@{"),
     cst$35=caml_string_of_jsbytes("@["),
     cst_0=caml_string_of_jsbytes("0"),
     cst_padding=caml_string_of_jsbytes("padding"),
     cst_precision=caml_string_of_jsbytes("precision"),
     cst$40=caml_string_of_jsbytes("'*'"),
     cst$38=caml_string_of_jsbytes("'-'"),
     cst_0$2=caml_string_of_jsbytes("'0'"),
     cst$39=caml_string_of_jsbytes("'*'"),
     cst_0$0=caml_string_of_jsbytes("0"),
     cst_0$1=caml_string_of_jsbytes("0"),
     cst_precision$0=caml_string_of_jsbytes("precision"),
     cst_precision$1=caml_string_of_jsbytes("precision"),
     cst$41=caml_string_of_jsbytes("'+'"),
     cst$42=caml_string_of_jsbytes("'#'"),
     cst$43=caml_string_of_jsbytes("' '"),
     cst_padding$0=caml_string_of_jsbytes("`padding'"),
     cst_precision$2=caml_string_of_jsbytes("`precision'"),
     cst$44=caml_string_of_jsbytes("'+'"),
     cst$45=caml_string_of_jsbytes("'_'"),
     sub_format=[0,0,caml_string_of_jsbytes("")],
     formatting_lit=[0,caml_string_of_jsbytes("@;"),1,0],
     cst_digit=caml_string_of_jsbytes("digit"),
     cst_character=caml_string_of_jsbytes("character ')'"),
     cst_character$0=caml_string_of_jsbytes("character '}'"),
     cst$49=caml_string_of_jsbytes("'#'"),
     cst$46=caml_string_of_jsbytes("'+'"),
     cst$47=caml_string_of_jsbytes("'+'"),
     cst$48=caml_string_of_jsbytes("' '"),
     cst$50=caml_string_of_jsbytes("'+'"),
     cst_non_zero_widths_are_unsupp=
      caml_string_of_jsbytes
       ("non-zero widths are unsupported for %c conversions"),
     cst_unexpected_end_of_format=
      caml_string_of_jsbytes("unexpected end of format"),
     cst$36=caml_string_of_jsbytes(""),
     cst$37=caml_string_of_jsbytes(""),
     cst_b$0=caml_string_of_jsbytes("b"),
     cst_h=caml_string_of_jsbytes("h"),
     cst_hov=caml_string_of_jsbytes("hov"),
     cst_hv=caml_string_of_jsbytes("hv"),
     cst_v=caml_string_of_jsbytes("v"),
     cst_nan=caml_string_of_jsbytes("nan"),
     cst_neg_infinity=caml_string_of_jsbytes("neg_infinity"),
     cst_infinity=caml_string_of_jsbytes("infinity"),
     cst$29=caml_string_of_jsbytes("."),
     cst_nd$0=caml_string_of_jsbytes("%+nd"),
     cst_nd$1=caml_string_of_jsbytes("% nd"),
     cst_ni$1=caml_string_of_jsbytes("%+ni"),
     cst_ni$2=caml_string_of_jsbytes("% ni"),
     cst_nx=caml_string_of_jsbytes("%nx"),
     cst_nx$0=caml_string_of_jsbytes("%#nx"),
     cst_nX=caml_string_of_jsbytes("%nX"),
     cst_nX$0=caml_string_of_jsbytes("%#nX"),
     cst_no=caml_string_of_jsbytes("%no"),
     cst_no$0=caml_string_of_jsbytes("%#no"),
     cst_nd=caml_string_of_jsbytes("%nd"),
     cst_ni$0=caml_string_of_jsbytes("%ni"),
     cst_nu=caml_string_of_jsbytes("%nu"),
     cst_ld$0=caml_string_of_jsbytes("%+ld"),
     cst_ld$1=caml_string_of_jsbytes("% ld"),
     cst_li$1=caml_string_of_jsbytes("%+li"),
     cst_li$2=caml_string_of_jsbytes("% li"),
     cst_lx=caml_string_of_jsbytes("%lx"),
     cst_lx$0=caml_string_of_jsbytes("%#lx"),
     cst_lX=caml_string_of_jsbytes("%lX"),
     cst_lX$0=caml_string_of_jsbytes("%#lX"),
     cst_lo=caml_string_of_jsbytes("%lo"),
     cst_lo$0=caml_string_of_jsbytes("%#lo"),
     cst_ld=caml_string_of_jsbytes("%ld"),
     cst_li$0=caml_string_of_jsbytes("%li"),
     cst_lu=caml_string_of_jsbytes("%lu"),
     cst_Ld$0=caml_string_of_jsbytes("%+Ld"),
     cst_Ld$1=caml_string_of_jsbytes("% Ld"),
     cst_Li$1=caml_string_of_jsbytes("%+Li"),
     cst_Li$2=caml_string_of_jsbytes("% Li"),
     cst_Lx=caml_string_of_jsbytes("%Lx"),
     cst_Lx$0=caml_string_of_jsbytes("%#Lx"),
     cst_LX=caml_string_of_jsbytes("%LX"),
     cst_LX$0=caml_string_of_jsbytes("%#LX"),
     cst_Lo=caml_string_of_jsbytes("%Lo"),
     cst_Lo$0=caml_string_of_jsbytes("%#Lo"),
     cst_Ld=caml_string_of_jsbytes("%Ld"),
     cst_Li$0=caml_string_of_jsbytes("%Li"),
     cst_Lu=caml_string_of_jsbytes("%Lu"),
     cst_d$3=caml_string_of_jsbytes("%+d"),
     cst_d$4=caml_string_of_jsbytes("% d"),
     cst_i$1=caml_string_of_jsbytes("%+i"),
     cst_i$2=caml_string_of_jsbytes("% i"),
     cst_x=caml_string_of_jsbytes("%x"),
     cst_x$0=caml_string_of_jsbytes("%#x"),
     cst_X$0=caml_string_of_jsbytes("%X"),
     cst_X$1=caml_string_of_jsbytes("%#X"),
     cst_o=caml_string_of_jsbytes("%o"),
     cst_o$0=caml_string_of_jsbytes("%#o"),
     cst_d$2=caml_string_of_jsbytes("%d"),
     cst_i$0=caml_string_of_jsbytes("%i"),
     cst_u=caml_string_of_jsbytes("%u"),
     cst$26=caml_string_of_jsbytes("%!"),
     cst$27=caml_string_of_jsbytes("@{"),
     cst$28=caml_string_of_jsbytes("@["),
     cst_0c=caml_string_of_jsbytes("0c"),
     cst$20=caml_string_of_jsbytes("%%"),
     cst$12=caml_string_of_jsbytes("@]"),
     cst$13=caml_string_of_jsbytes("@}"),
     cst$14=caml_string_of_jsbytes("@?"),
     cst$15=caml_string_of_jsbytes("@\n"),
     cst$16=caml_string_of_jsbytes("@."),
     cst$17=caml_string_of_jsbytes("@@"),
     cst$18=caml_string_of_jsbytes("@%"),
     cst$19=caml_string_of_jsbytes("@"),
     cst$11=caml_string_of_jsbytes(".*"),
     cst_CamlinternalFormat_Type_mi=
      caml_string_of_jsbytes("CamlinternalFormat.Type_mismatch"),
     cst$58=caml_string_of_jsbytes(""),
     cst$59=caml_string_of_jsbytes("\n"),
     cst_a_boolean=caml_string_of_jsbytes("a boolean"),
     cst_an_integer=caml_string_of_jsbytes("an integer"),
     cst_an_integer$0=caml_string_of_jsbytes("an integer"),
     cst_a_float=caml_string_of_jsbytes("a float"),
     cst_a_float$0=caml_string_of_jsbytes("a float"),
     cst$55=caml_string_of_jsbytes(""),
     cst$56=caml_string_of_jsbytes(" "),
     cst$57=caml_string_of_jsbytes(""),
     cst_one_of=caml_string_of_jsbytes("one of: "),
     cst_Arg_Expand_is_is_only_allo=
      caml_string_of_jsbytes
       ("Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"),
     cst_no_argument=caml_string_of_jsbytes("no argument"),
     cst$54=caml_string_of_jsbytes("(?)"),
     cst_help$3=caml_string_of_jsbytes("--help"),
     cst_help$4=caml_string_of_jsbytes("-help"),
     cst_help$2=caml_string_of_jsbytes("-help"),
     cst_Display_this_list_of_optio=
      caml_string_of_jsbytes(" Display this list of options"),
     cst_help=caml_string_of_jsbytes("-help"),
     cst_help$1=caml_string_of_jsbytes("--help"),
     cst_Display_this_list_of_optio$0=
      caml_string_of_jsbytes(" Display this list of options"),
     cst_help$0=caml_string_of_jsbytes("--help"),
     cst$51=caml_string_of_jsbytes("}"),
     cst$52=caml_string_of_jsbytes("|"),
     cst$53=caml_string_of_jsbytes("{"),
     cst_none=caml_string_of_jsbytes("<none>"),
     cst_Stdlib_Arg_Bad=caml_string_of_jsbytes("Stdlib.Arg.Bad"),
     cst_Stdlib_Arg_Help=caml_string_of_jsbytes("Stdlib.Arg.Help"),
     cst_Stdlib_Arg_Stop=caml_string_of_jsbytes("Stdlib.Arg.Stop"),
     cst$61=caml_string_of_jsbytes(""),
     cst_Fatal_error_out_of_memory_=
      caml_string_of_jsbytes
       ("Fatal error: out of memory in uncaught exception handler"),
     cst$65=caml_string_of_jsbytes(""),
     cst_Program_not_linked_with_g_=
      caml_string_of_jsbytes
       ("(Program not linked with -g, cannot print stack backtrace)\n"),
     cst_Raised_at=caml_string_of_jsbytes("Raised at"),
     cst_Re_raised_at=caml_string_of_jsbytes("Re-raised at"),
     cst_Raised_by_primitive_operat=
      caml_string_of_jsbytes("Raised by primitive operation at"),
     cst_Called_from=caml_string_of_jsbytes("Called from"),
     cst_inlined=caml_string_of_jsbytes(" (inlined)"),
     cst$64=caml_string_of_jsbytes(""),
     partial=[4,0,0,0,[12,45,[4,0,0,0,0]]],
     cst_Out_of_memory=caml_string_of_jsbytes("Out of memory"),
     cst_Stack_overflow=caml_string_of_jsbytes("Stack overflow"),
     cst_Pattern_matching_failed=
      caml_string_of_jsbytes("Pattern matching failed"),
     cst_Assertion_failed=caml_string_of_jsbytes("Assertion failed"),
     cst_Undefined_recursive_module=
      caml_string_of_jsbytes("Undefined recursive module"),
     cst$62=caml_string_of_jsbytes(""),
     cst$63=caml_string_of_jsbytes(""),
     cst$60=caml_string_of_jsbytes("_"),
     locfmt=
      [0,
       [11,
        caml_string_of_jsbytes('File "'),
        [2,
         0,
         [11,
          caml_string_of_jsbytes('", line '),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", characters "),
            [4,
             0,
             0,
             0,
             [12,45,[4,0,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]]]]]]]],
       caml_string_of_jsbytes('File "%s", line %d, characters %d-%d: %s')],
     cst_Fun_Finally_raised=caml_string_of_jsbytes("Fun.Finally_raised: "),
     cst_Stdlib_Fun_Finally_raised=
      caml_string_of_jsbytes("Stdlib.Fun.Finally_raised"),
     cst_Digest_from_hex$0=caml_string_of_jsbytes("Digest.from_hex"),
     cst_Digest_from_hex=caml_string_of_jsbytes("Digest.from_hex"),
     cst_Digest_to_hex=caml_string_of_jsbytes("Digest.to_hex"),
     cst_Digest_substring=caml_string_of_jsbytes("Digest.substring"),
     cst_Random_int64=caml_string_of_jsbytes("Random.int64"),
     cst_Random_int32=caml_string_of_jsbytes("Random.int32"),
     cst_Random_full_int=caml_string_of_jsbytes("Random.full_int"),
     cst_Random_int=caml_string_of_jsbytes("Random.int"),
     cst_x$1=caml_string_of_jsbytes("x"),
     cst_Hashtbl_unsupported_hash_t=
      caml_string_of_jsbytes("Hashtbl: unsupported hash table format"),
     cst_OCAMLRUNPARAM=caml_string_of_jsbytes("OCAMLRUNPARAM"),
     cst_CAMLRUNPARAM=caml_string_of_jsbytes("CAMLRUNPARAM"),
     cst$66=caml_string_of_jsbytes(""),
     cst_Weak_Make_hash_bucket_cann=
      caml_string_of_jsbytes("Weak.Make: hash bucket cannot grow more"),
     cst_Weak_fill=caml_string_of_jsbytes("Weak.fill"),
     cst_Weak_blit=caml_string_of_jsbytes("Weak.blit"),
     cst_Weak_check=caml_string_of_jsbytes("Weak.check"),
     cst_Weak_get_copy=caml_string_of_jsbytes("Weak.get_copy"),
     cst_Weak_get=caml_string_of_jsbytes("Weak.get"),
     cst_Weak_set=caml_string_of_jsbytes("Weak.set"),
     cst_Weak_create=caml_string_of_jsbytes("Weak.create"),
     cst$84=caml_string_of_jsbytes(""),
     cst$85=caml_string_of_jsbytes(""),
     cst$83=caml_string_of_jsbytes("."),
     cst$80=caml_string_of_jsbytes(">"),
     cst$81=caml_string_of_jsbytes("<\/"),
     cst$82=caml_string_of_jsbytes(""),
     cst$77=caml_string_of_jsbytes(">"),
     cst$78=caml_string_of_jsbytes("<"),
     cst$79=caml_string_of_jsbytes(""),
     cst$76=caml_string_of_jsbytes("\n"),
     cst_Format_pp_set_geometry=
      caml_string_of_jsbytes("Format.pp_set_geometry: "),
     cst$72=caml_string_of_jsbytes(""),
     cst$73=caml_string_of_jsbytes(""),
     cst$74=caml_string_of_jsbytes(""),
     cst$75=caml_string_of_jsbytes(""),
     cst$68=caml_string_of_jsbytes(""),
     cst$69=caml_string_of_jsbytes(""),
     cst$70=caml_string_of_jsbytes(""),
     cst$71=caml_string_of_jsbytes(""),
     cst$67=caml_string_of_jsbytes(""),
     cst_Stdlib_Format_String_tag=
      caml_string_of_jsbytes("Stdlib.Format.String_tag"),
     cst_end_of_input_not_found=
      caml_string_of_jsbytes("end of input not found"),
     cst_scanf_bad_conversion_a=
      caml_string_of_jsbytes('scanf: bad conversion "%a"'),
     cst_scanf_bad_conversion_t=
      caml_string_of_jsbytes('scanf: bad conversion "%t"'),
     cst_scanf_missing_reader=caml_string_of_jsbytes("scanf: missing reader"),
     cst_scanf_bad_conversion_custo=
      caml_string_of_jsbytes('scanf: bad conversion "%?" (custom converter)'),
     cst_scanf_bad_conversion=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$0=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$1=
      caml_string_of_jsbytes('scanf: bad conversion "%-"'),
     cst_scanf_bad_conversion$2=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst$91=caml_string_of_jsbytes('"'),
     cst$92=caml_string_of_jsbytes('"'),
     cst$89=caml_string_of_jsbytes('"'),
     cst$90=caml_string_of_jsbytes('"'),
     cst$88=caml_string_of_jsbytes('"'),
     cst_in_format=caml_string_of_jsbytes(' in format "'),
     cst_an=caml_string_of_jsbytes("an"),
     cst_x$2=caml_string_of_jsbytes("x"),
     cst_nfinity=caml_string_of_jsbytes("nfinity"),
     cst_digits=caml_string_of_jsbytes("digits"),
     cst_decimal_digits=caml_string_of_jsbytes("decimal digits"),
     cst_0b=caml_string_of_jsbytes("0b"),
     cst_0o=caml_string_of_jsbytes("0o"),
     cst_0u=caml_string_of_jsbytes("0u"),
     cst_0x=caml_string_of_jsbytes("0x"),
     cst_false$3=caml_string_of_jsbytes("false"),
     cst_true$3=caml_string_of_jsbytes("true"),
     cst_not_a_valid_float_in_hexad=
      caml_string_of_jsbytes("not a valid float in hexadecimal notation"),
     cst_no_dot_or_exponent_part_fo=
      caml_string_of_jsbytes("no dot or exponent part found in float token"),
     cst$87=caml_string_of_jsbytes("-"),
     cst_unnamed_function=caml_string_of_jsbytes("unnamed function"),
     cst_unnamed_character_string=
      caml_string_of_jsbytes("unnamed character string"),
     cst_unnamed_Stdlib_input_chann=
      caml_string_of_jsbytes("unnamed Stdlib input channel"),
     cst$86=caml_string_of_jsbytes("-"),
     cst_Stdlib_Scanf_Scan_failure=
      caml_string_of_jsbytes("Stdlib.Scanf.Scan_failure"),
     cst_binary=caml_string_of_jsbytes("binary"),
     cst_octal=caml_string_of_jsbytes("octal"),
     cst_hexadecimal=caml_string_of_jsbytes("hexadecimal"),
     cst_a_Char=caml_string_of_jsbytes("a Char"),
     cst_a_String=caml_string_of_jsbytes("a String"),
     cst$93=caml_string_of_jsbytes(""),
     cst_CamlinternalMod_update_mod=
      caml_string_of_jsbytes("CamlinternalMod.update_mod: not a module"),
     cst_CamlinternalMod_init_mod_n=
      caml_string_of_jsbytes("CamlinternalMod.init_mod: not a module"),
     cst$94=caml_string_of_jsbytes(""),
     cst$95=caml_string_of_jsbytes(""),
     cst$96=caml_string_of_jsbytes(""),
     cst$97=caml_string_of_jsbytes(""),
     cst$99=caml_string_of_jsbytes(""),
     cst$98=caml_string_of_jsbytes(""),
     cst_Illegal_character=caml_string_of_jsbytes("Illegal character "),
     cst_Filename_chop_extension=
      caml_string_of_jsbytes("Filename.chop_extension"),
     cst$127=caml_string_of_jsbytes(""),
     cst_Filename_chop_suffix=caml_string_of_jsbytes("Filename.chop_suffix"),
     cst$126=caml_string_of_jsbytes(""),
     cst_2_1$0=caml_string_of_jsbytes(" 2>&1"),
     cst_2$0=caml_string_of_jsbytes(" 2>"),
     cst$125=caml_string_of_jsbytes(""),
     cst$117=caml_string_of_jsbytes(" >"),
     cst$124=caml_string_of_jsbytes(""),
     cst$118=caml_string_of_jsbytes(" <"),
     cst$123=caml_string_of_jsbytes(""),
     cst$119=caml_string_of_jsbytes(" "),
     cst$120=caml_string_of_jsbytes(" "),
     cst$121=caml_string_of_jsbytes('"'),
     cst$122=caml_string_of_jsbytes(""),
     cst_Filename_quote_command_bad=
      caml_string_of_jsbytes("Filename.quote_command: bad file name "),
     cst$115=caml_string_of_jsbytes('"'),
     cst$116=caml_string_of_jsbytes('"'),
     cst$113=caml_string_of_jsbytes("./"),
     cst$112=caml_string_of_jsbytes(".\\"),
     cst$111=caml_string_of_jsbytes("../"),
     cst$110=caml_string_of_jsbytes("..\\"),
     cst_2_1=caml_string_of_jsbytes(" 2>&1"),
     cst_2=caml_string_of_jsbytes(" 2>"),
     cst$109=caml_string_of_jsbytes(""),
     cst$104=caml_string_of_jsbytes(" >"),
     cst$108=caml_string_of_jsbytes(""),
     cst$105=caml_string_of_jsbytes(" <"),
     cst$107=caml_string_of_jsbytes(""),
     cst$106=caml_string_of_jsbytes(" "),
     cst$103=caml_string_of_jsbytes("./"),
     cst$102=caml_string_of_jsbytes("../"),
     cst$101=caml_string_of_jsbytes(""),
     cst$100=caml_string_of_jsbytes(""),
     null$0=caml_string_of_jsbytes("/dev/null"),
     current_dir_name=caml_string_of_jsbytes("."),
     parent_dir_name=caml_string_of_jsbytes(".."),
     dir_sep=caml_string_of_jsbytes("/"),
     cst_TMPDIR=caml_string_of_jsbytes("TMPDIR"),
     cst_tmp=caml_string_of_jsbytes("/tmp"),
     quotequote=caml_string_of_jsbytes("'\\''"),
     null$1=caml_string_of_jsbytes("NUL"),
     current_dir_name$0=caml_string_of_jsbytes("."),
     parent_dir_name$0=caml_string_of_jsbytes(".."),
     dir_sep$0=caml_string_of_jsbytes("\\"),
     cst_TEMP=caml_string_of_jsbytes("TEMP"),
     cst$114=caml_string_of_jsbytes("."),
     null$2=caml_string_of_jsbytes("/dev/null"),
     current_dir_name$1=caml_string_of_jsbytes("."),
     parent_dir_name$1=caml_string_of_jsbytes(".."),
     dir_sep$1=caml_string_of_jsbytes("/"),
     cst_Cygwin=caml_string_of_jsbytes("Cygwin"),
     cst_Win32=caml_string_of_jsbytes("Win32"),
     zero$4=[254,0.,0.],
     one$4=[254,1.,0.],
     i=[254,0.,1.],
     cst_Bigarray_array3_of_genarra=
      caml_string_of_jsbytes("Bigarray.array3_of_genarray"),
     cst_Bigarray_array2_of_genarra=
      caml_string_of_jsbytes("Bigarray.array2_of_genarray"),
     cst_Bigarray_array1_of_genarra=
      caml_string_of_jsbytes("Bigarray.array1_of_genarray"),
     cst_Bigarray_array0_of_genarra=
      caml_string_of_jsbytes("Bigarray.array0_of_genarray"),
     cst_Bigarray_Array3_of_array_n=
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array3_of_array_n$0=
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array2_of_array_n=
      caml_string_of_jsbytes("Bigarray.Array2.of_array: non-rectangular data"),
     Invalid_argument=global_data.Invalid_argument,
     Failure=global_data.Failure,
     Match_failure=global_data.Match_failure,
     Assert_failure=global_data.Assert_failure,
     Not_found=global_data.Not_found,
     Out_of_memory=global_data.Out_of_memory,
     Stack_overflow=global_data.Stack_overflow,
     Sys_error=global_data.Sys_error,
     End_of_file=global_data.End_of_file,
     Division_by_zero=global_data.Division_by_zero,
     Sys_blocked_io=global_data.Sys_blocked_io,
     Undefined_recursive_module=global_data.Undefined_recursive_module,
     _l_=[0,0,[0,6,0]],
     _k_=[0,0,[0,7,0]],
     _j_=[0,1,[0,3,[0,4,[0,6,0]]]],
     _i_=[0,1,[0,3,[0,4,[0,7,0]]]],
     _g_=[0,1],
     _h_=[0,0],
     _a_=runtime.caml_int64_create_lo_mi_hi(0,0,32752),
     _b_=runtime.caml_int64_create_lo_mi_hi(0,0,65520),
     _c_=runtime.caml_int64_create_lo_mi_hi(1,0,32752),
     _d_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32751),
     _e_=runtime.caml_int64_create_lo_mi_hi(0,0,16),
     _f_=runtime.caml_int64_create_lo_mi_hi(0,0,15536),
     _p_=[0,0,0],
     _q_=[0,caml_string_of_jsbytes("obj.ml"),100,4],
     _u_=[0,caml_string_of_jsbytes("array.ml"),322,4],
     _w_=[0,caml_string_of_jsbytes("float.ml"),395,6],
     _v_=[0,caml_string_of_jsbytes("float.ml"),222,14],
     _H_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     _G_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _F_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _E_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _I_=[0,0,0,0],
     _J_=[0,0,0],
     _K_=[0,caml_string_of_jsbytes("set.ml"),570,18],
     _L_=[0,0,0,0],
     _M_=[0,caml_string_of_jsbytes("map.ml"),400,10],
     _N_=[0,0,0],
     _O_=[0,caml_string_of_jsbytes("stream.ml"),53,12],
     _P_=[0,0],
     _Q_=[0,caml_string_of_jsbytes("stream.ml"),82,12],
     ___=[0,caml_string_of_jsbytes("buffer.ml"),282,9],
     _Z_=[0,caml_string_of_jsbytes("buffer.ml"),263,2],
     _Y_=[0,caml_string_of_jsbytes("buffer.ml"),195,19],
     _X_=[0,caml_string_of_jsbytes("buffer.ml"),213,8],
     _W_=[0,caml_string_of_jsbytes("buffer.ml"),174,19],
     _V_=[0,caml_string_of_jsbytes("buffer.ml"),192,8],
     _U_=[0,caml_string_of_jsbytes("buffer.ml"),138,19],
     _T_=[0,caml_string_of_jsbytes("buffer.ml"),171,8],
     _S_=[0,caml_string_of_jsbytes("buffer.ml"),93,2],
     _R_=[0,caml_string_of_jsbytes("buffer.ml"),94,2],
     _aa_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),850,23],
     _al_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),814,21],
     _ad_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),815,21],
     _am_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),818,21],
     _ae_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),819,21],
     _an_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),822,19],
     _af_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),823,19],
     _ao_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),826,22],
     _ag_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),827,22],
     _ap_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),831,30],
     _ah_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),832,30],
     _aj_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),836,26],
     _ab_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),837,26],
     _ak_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),846,28],
     _ac_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),847,28],
     _ai_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),851,23],
     _ar_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1558,4],
     _as_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1626,39],
     _at_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1649,31],
     _au_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1650,31],
     _av_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1830,8],
     _aZ_=
      [0,
       [11,
        caml_string_of_jsbytes("bad input: format type mismatch between "),
        [3,0,[11,caml_string_of_jsbytes(" and "),[3,0,0]]]],
       caml_string_of_jsbytes
        ("bad input: format type mismatch between %S and %S")],
     _aY_=
      [0,
       [11,
        caml_string_of_jsbytes("bad input: format type mismatch between "),
        [3,0,[11,caml_string_of_jsbytes(" and "),[3,0,0]]]],
       caml_string_of_jsbytes
        ("bad input: format type mismatch between %S and %S")],
     _aB_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", duplicate flag "),[1,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, duplicate flag %C")],
     _aC_=[0,1,0],
     _aD_=[0,0],
     _aE_=[1,0],
     _aF_=[1,1],
     _aH_=[1,1],
     _aG_=[1,1],
     _aL_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", flag "),
            [1,
             [11,
              caml_string_of_jsbytes(" is only allowed after the '"),
              [12,
               37,
               [11,
                caml_string_of_jsbytes("', before padding and precision"),
                0]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision")],
     _aI_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(', invalid conversion "'),
            [12,37,[0,[12,34,0]]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: at character number %d, invalid conversion "%%%c"')],
     _aJ_=[0,0],
     _aK_=[0,0],
     _aM_=[0,[12,64,0]],
     _aN_=[0,caml_string_of_jsbytes("@ "),1,0],
     _aO_=[0,caml_string_of_jsbytes("@,"),0,0],
     _aP_=[2,60],
     _aQ_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": '"),
          [12,
           37,
           [11,
            caml_string_of_jsbytes
             ("' alone is not accepted in character sets, use "),
            [12,
             37,
             [12,
              37,
              [11,
               caml_string_of_jsbytes(" instead at position "),
               [4,0,0,0,[12,46,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d.")],
     _aR_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": integer "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(" is greater than the limit "),
            [4,0,0,0,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: integer %d is greater than the limit %d")],
     _aS_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2837,11],
     _aT_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(': unclosed sub-format, expected "'),
          [12,
           37,
           [0,
            [11,caml_string_of_jsbytes('" at character number '),[4,0,0,0,0]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: unclosed sub-format, expected "%%%c" at character number %d')],
     _aU_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2899,34],
     _aV_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2935,28],
     _aW_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2957,11],
     _aX_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,
             0,
             [11,
              caml_string_of_jsbytes(" is incompatible with '"),
              [0,[11,caml_string_of_jsbytes("' in sub-format "),[3,0,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S")],
     _aA_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(" expected, read "),[1,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s expected, read %C")],
     _az_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", '"),
            [0,[11,caml_string_of_jsbytes("' without "),[2,0,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, '%c' without %s")],
     _ay_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]]]],
       caml_string_of_jsbytes("invalid format %S: at character number %d, %s")],
     _ax_=
      [0,
       [11,caml_string_of_jsbytes("invalid box description "),[3,0,0]],
       caml_string_of_jsbytes("invalid box description %S")],
     _aw_=[0,0,4],
     _aq_=[0,103],
     _$_=[0,0,0],
     _bj_=[0,[2,0,[0,0]],caml_string_of_jsbytes("%s%c")],
     _bd_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _be_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _bb_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _bc_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a$_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _ba_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a5_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": unknown option '"),
         [2,0,[11,caml_string_of_jsbytes("'.\n"),0]]]],
       caml_string_of_jsbytes("%s: unknown option '%s'.\n")],
     _a8_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": wrong argument '"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("'; option '"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("' expects "),
             [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]]]]]],
       caml_string_of_jsbytes
        ("%s: wrong argument '%s'; option '%s' expects %s.\n")],
     _a9_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": option '"),
         [2,0,[11,caml_string_of_jsbytes("' needs an argument.\n"),0]]]],
       caml_string_of_jsbytes("%s: option '%s' needs an argument.\n")],
     _a__=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": "),
         [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]],
       caml_string_of_jsbytes("%s: %s.\n")],
     _a6_=[0,caml_string_of_jsbytes("-help")],
     _a7_=[0,caml_string_of_jsbytes("--help")],
     _a4_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a3_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _a2_=[0,caml_string_of_jsbytes("-help")],
     _a0_=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[12,10,0]]]]],
       caml_string_of_jsbytes("  %s %s\n")],
     _a1_=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[2,0,[12,10,0]]]]]],
       caml_string_of_jsbytes("  %s %s%s\n")],
     _bo_=
      [0,
       [11,caml_string_of_jsbytes(", "),[2,0,[2,0,0]]],
       caml_string_of_jsbytes(", %s%s")],
     _bA_=
      [0,
       [11,caml_string_of_jsbytes("Fatal error: exception "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Fatal error: exception %s\n")],
     _bB_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Fatal error in uncaught exception handler: exception "),
        [2,0,[12,10,0]]],
       caml_string_of_jsbytes
        ("Fatal error in uncaught exception handler: exception %s\n")],
     _bz_=
      [0,
       [11,caml_string_of_jsbytes("Fatal error: exception "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Fatal error: exception %s\n")],
     _bx_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _bv_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _bw_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("(Program not linked with -g, cannot print stack backtrace)\n"),
        0],
       caml_string_of_jsbytes
        ("(Program not linked with -g, cannot print stack backtrace)\n")],
     _bt_=
      [0,
       [2,
        0,
        [12,
         32,
         [2,
          0,
          [11,
           caml_string_of_jsbytes(' in file "'),
           [2,
            0,
            [12,
             34,
             [2,
              0,
              [11,
               caml_string_of_jsbytes(", line "),
               [4,0,0,0,[11,caml_string_of_jsbytes(", characters "),partial]]]]]]]]]],
       caml_string_of_jsbytes
        ('%s %s in file "%s"%s, line %d, characters %d-%d')],
     _bu_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" unknown location"),0]],
       caml_string_of_jsbytes("%s unknown location")],
     _bs_=
      [0,
       [11,caml_string_of_jsbytes("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Uncaught exception: %s\n")],
     _br_=
      [0,
       [11,caml_string_of_jsbytes("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Uncaught exception: %s\n")],
     _bp_=[0,[12,40,[2,0,[2,0,[12,41,0]]]],caml_string_of_jsbytes("(%s%s)")],
     _bq_=[0,[12,40,[2,0,[12,41,0]]],caml_string_of_jsbytes("(%s)")],
     _bn_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bm_=[0,[3,0,0],caml_string_of_jsbytes("%S")],
     _by_=
      [0,
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file not found)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file appears to be corrupt)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file has wrong magic number)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file cannot be opened;\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)")],
     _bI_=
      [0,
       [11,
        caml_string_of_jsbytes("minor_collections:      "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("minor_collections:      %d\n")],
     _bJ_=
      [0,
       [11,
        caml_string_of_jsbytes("major_collections:      "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("major_collections:      %d\n")],
     _bK_=
      [0,
       [11,
        caml_string_of_jsbytes("compactions:            "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("compactions:            %d\n")],
     _bL_=
      [0,
       [11,
        caml_string_of_jsbytes("forced_major_collections: "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("forced_major_collections: %d\n")],
     _bM_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bN_=[0,[8,[0,0,0],0,[0,0],0],caml_string_of_jsbytes("%.0f")],
     _bO_=
      [0,
       [11,
        caml_string_of_jsbytes("minor_words:    "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("minor_words:    %*.0f\n")],
     _bP_=
      [0,
       [11,
        caml_string_of_jsbytes("promoted_words: "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("promoted_words: %*.0f\n")],
     _bQ_=
      [0,
       [11,
        caml_string_of_jsbytes("major_words:    "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("major_words:    %*.0f\n")],
     _bR_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bS_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bT_=
      [0,
       [11,caml_string_of_jsbytes("top_heap_words: "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("top_heap_words: %*d\n")],
     _bU_=
      [0,
       [11,caml_string_of_jsbytes("heap_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("heap_words:     %*d\n")],
     _bV_=
      [0,
       [11,caml_string_of_jsbytes("live_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("live_words:     %*d\n")],
     _bW_=
      [0,
       [11,caml_string_of_jsbytes("free_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("free_words:     %*d\n")],
     _bX_=
      [0,
       [11,caml_string_of_jsbytes("largest_free:   "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("largest_free:   %*d\n")],
     _bY_=
      [0,
       [11,caml_string_of_jsbytes("fragments:      "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("fragments:      %*d\n")],
     _bZ_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _b0_=
      [0,
       [11,caml_string_of_jsbytes("live_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("live_blocks: %d\n")],
     _b1_=
      [0,
       [11,caml_string_of_jsbytes("free_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("free_blocks: %d\n")],
     _b2_=
      [0,
       [11,caml_string_of_jsbytes("heap_chunks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("heap_chunks: %d\n")],
     _b__=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _b$_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _ca_=
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
     _cd_=[0,0],
     _cj_=[3,0,3],
     _ci_=[1,caml_string_of_jsbytes("max_indent < 2")],
     _cg_=[1,caml_string_of_jsbytes("margin <= max_indent")],
     _ch_=[0,0],
     _cf_=[0,caml_string_of_jsbytes("")],
     _ce_=[0,caml_string_of_jsbytes(""),0,caml_string_of_jsbytes("")],
     _cz_=[0,91],
     _cy_=[0,123],
     _cA_=[0,caml_string_of_jsbytes("scanf.ml"),1453,13],
     _cB_=[0,[3,0,[10,0]],caml_string_of_jsbytes("%S%!")],
     _cx_=[0,37,caml_string_of_jsbytes("")],
     _cw_=
      [0,
       [11,
        caml_string_of_jsbytes("scanf: bad input at char number "),
        [4,3,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]],
       caml_string_of_jsbytes("scanf: bad input at char number %i: %s")],
     _cv_=
      [0,
       [11,
        caml_string_of_jsbytes("the character "),
        [1,[11,caml_string_of_jsbytes(" cannot start a boolean"),0]]],
       caml_string_of_jsbytes("the character %C cannot start a boolean")],
     _cu_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character hexadecimal encoding \\"),
        [0,[0,0]]],
       caml_string_of_jsbytes("bad character hexadecimal encoding \\%c%c")],
     _ct_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character decimal encoding \\"),
        [0,[0,[0,0]]]],
       caml_string_of_jsbytes("bad character decimal encoding \\%c%c%c")],
     _cs_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,
         [11,
          caml_string_of_jsbytes(" is not a valid "),
          [2,0,[11,caml_string_of_jsbytes(" digit"),0]]]]],
       caml_string_of_jsbytes("character %C is not a valid %s digit")],
     _cr_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,[11,caml_string_of_jsbytes(" is not a decimal digit"),0]]],
       caml_string_of_jsbytes("character %C is not a decimal digit")],
     _cq_=[0,caml_string_of_jsbytes("scanf.ml"),555,9],
     _cp_=
      [0,
       [11,caml_string_of_jsbytes("invalid boolean '"),[2,0,[12,39,0]]],
       caml_string_of_jsbytes("invalid boolean '%s'")],
     _co_=
      [0,
       [11,
        caml_string_of_jsbytes("looking for "),
        [1,[11,caml_string_of_jsbytes(", found "),[1,0]]]],
       caml_string_of_jsbytes("looking for %C, found %C")],
     _cn_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: premature end of file occurred before end of token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: premature end of file occurred before end of token")],
     _cm_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: the specified length was too short for token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: the specified length was too short for token")],
     _cl_=
      [0,
       [11,caml_string_of_jsbytes("illegal escape character "),[1,0]],
       caml_string_of_jsbytes("illegal escape character %C")],
     _cI_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),439,17],
     _cH_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),421,13],
     _cG_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),418,13],
     _cF_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),415,13],
     _cE_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),412,13],
     _cD_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),409,13],
     _cC_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),281,50],
     _cJ_=[0,caml_string_of_jsbytes("camlinternalMod.ml"),72,5],
     _cK_=[0,caml_string_of_jsbytes("camlinternalMod.ml"),81,2],
     _cN_=[0,0],
     _cM_=[0,0],
     _cL_=[0,0],
     _cS_=[0,7,0],
     _cR_=[0,1,[0,3,[0,5,0]]],
     _cQ_=[0,[2,0,[4,6,[0,2,6],0,[2,0,0]]],caml_string_of_jsbytes("%s%06x%s")],
     _cP_=[0,caml_string_of_jsbytes('"'),0],
     _cT_=[254,0.,0.];
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    var CamlinternalFormatBasics=[0,concat_fmtty,erase_rel,concat_fmt];
    caml_register_global
     (745,CamlinternalFormatBasics,"CamlinternalFormatBasics");
    function make(v){return [0,v]}
    function get(r){return r[1]}
    function set(r,v){r[1] = v;return 0}
    function exchange(r,v){var cur=r[1];r[1] = v;return cur}
    function compare_and_set(r,seen,v)
     {var cur=r[1];return cur === seen?(r[1] = v,1):0}
    function fetch_and_add(r,n){var cur=r[1];r[1] = cur + n | 0;return cur}
    function incr(r){fetch_and_add(r,1);return 0}
    function decr(r){fetch_and_add(r,-1);return 0}
    var
     include=
      [0,make,get,set,exchange,compare_and_set,fetch_and_add,incr,decr];
    caml_register_global(746,include,"CamlinternalAtomic");
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    var Exit=[248,cst_Stdlib_Exit,caml_fresh_oo_id(0)];
    function min(x,y){return caml_lessequal(x,y)?x:y}
    function max(x,y){return caml_greaterequal(x,y)?x:y}
    function abs(x){return 0 <= x?x:- x | 0}
    function lnot(x){return x ^ -1}
    var
     infinity=caml_int64_float_of_bits(_a_),
     neg_infinity=caml_int64_float_of_bits(_b_),
     nan=caml_int64_float_of_bits(_c_),
     max_float=caml_int64_float_of_bits(_d_),
     min_float=caml_int64_float_of_bits(_e_),
     epsilon=caml_int64_float_of_bits(_f_),
     max_int=2147483647,
     min_int=-2147483648;
    function cat(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       s=caml_create_bytes(l1 + l2 | 0);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return caml_string_of_bytes(s)}
    function char_of_int(n)
     {if(0 <= n && ! (255 < n))return n;return invalid_arg(cst_char_of_int)}
    function string_of_bool(b){return b?cst_true:cst_false}
    function bool_of_string(param)
     {return caml_string_notequal(param,cst_false$0)
              ?caml_string_notequal(param,cst_true$0)
                ?invalid_arg(cst_bool_of_string)
                :1
              :0}
    function bool_of_string_opt(param)
     {return caml_string_notequal(param,cst_false$1)
              ?caml_string_notequal(param,cst_true$1)?0:_g_
              :_h_}
    function string_of_int(n){return caml_string_of_jsbytes("" + n)}
    function int_of_string_opt(s)
     {try
       {var _CD_=[0,caml_int_of_string(s)];return _CD_}
      catch(_CE_)
       {_CE_ = caml_wrap_exception(_CE_);
        if(_CE_[1] === Failure)return 0;
        throw _CE_}}
    function valid_float_lexem(s)
     {var l=caml_ml_string_length(s),i=0;
      for(;;)
       {if(l <= i)return cat(s,cst);
        var match=caml_string_get(s,i),switch$0=0;
        if(48 <= match)
         {if(! (58 <= match))switch$0 = 1}
        else
         if(45 === match)switch$0 = 1;
        if(switch$0){var i$0=i + 1 | 0,i=i$0;continue}
        return s}}
    function to_string(f)
     {return valid_float_lexem(caml_format_float(cst_12g,f))}
    function of_string_opt(s)
     {try
       {var _CB_=[0,caml_float_of_string(s)];return _CB_}
      catch(_CC_)
       {_CC_ = caml_wrap_exception(_CC_);
        if(_CC_[1] === Failure)return 0;
        throw _CC_}}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    var
     stdin=caml_ml_open_descriptor_in(0),
     stdout=caml_ml_open_descriptor_out(1),
     stderr=caml_ml_open_descriptor_out(2);
    function open_out_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_out(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_out(name){return open_out_gen(_i_,438,name)}
    function open_out_bin(name){return open_out_gen(_j_,438,name)}
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_CA_)
             {_CA_ = caml_wrap_exception(_CA_);
              if(_CA_[1] !== Sys_error)throw _CA_;
              var _Cz_=_CA_}
            var param$0=l;
            continue}
          return 0}}
      return iter(runtime.caml_ml_out_channels_list(0))}
    function output_bytes(oc,s)
     {return caml_ml_output_bytes(oc,s,0,caml_ml_bytes_length(s))}
    function output_string(oc,s)
     {return caml_ml_output(oc,s,0,caml_ml_string_length(s))}
    function output(oc,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_output_bytes(oc,s,ofs,len);
      return invalid_arg(cst_output)}
    function output_substring(oc,s,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(s) - len | 0) < ofs))
       return caml_ml_output(oc,s,ofs,len);
      return invalid_arg(cst_output_substring)}
    function output_value(chan,v){return caml_output_value(chan,v,0)}
    function close_out(oc){caml_ml_flush(oc);return caml_ml_close_channel(oc)}
    function close_out_noerr(oc)
     {try {caml_ml_flush(oc)}catch(_Cy_){}
      try
       {var _Cw_=caml_ml_close_channel(oc);return _Cw_}
      catch(_Cx_){return 0}}
    function open_in_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_in(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_in(name){return open_in_gen(_k_,0,name)}
    function open_in_bin(name){return open_in_gen(_l_,0,name)}
    function input(ic,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_input(ic,s,ofs,len);
      return invalid_arg(cst_input)}
    function unsafe_really_input(ic,s,ofs,len)
     {var ofs$0=ofs,len$0=len;
      for(;;)
       {if(0 < len$0)
         {var r=caml_ml_input(ic,s,ofs$0,len$0);
          if(0 === r)throw End_of_file;
          var len$1=len$0 - r | 0,ofs$1=ofs$0 + r | 0,ofs$0=ofs$1,len$0=len$1;
          continue}
        return 0}}
    function really_input(ic,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return unsafe_really_input(ic,s,ofs,len);
      return invalid_arg(cst_really_input)}
    function really_input_string(ic,len)
     {var s=caml_create_bytes(len);
      really_input(ic,s,0,len);
      return caml_string_of_bytes(s)}
    function input_line(chan)
     {function build_result(buf,pos,param)
       {var pos$0=pos,param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1],len=caml_ml_bytes_length(hd);
            caml_blit_bytes(hd,0,buf,pos$0 - len | 0,len);
            var pos$1=pos$0 - len | 0,pos$0=pos$1,param$0=tl;
            continue}
          return buf}}
      var accu=0,len=0;
      for(;;)
       {var n=runtime.caml_ml_input_scan_line(chan);
        if(0 === n)
         {if(! accu)throw End_of_file;
          var _Cv_=build_result(caml_create_bytes(len),len,accu)}
        else
         {if(! (0 < n))
           {var beg=caml_create_bytes(- n | 0);
            caml_ml_input(chan,beg,0,- n | 0);
            var len$1=len - n | 0,accu$0=[0,beg,accu],accu=accu$0,len=len$1;
            continue}
          var res=caml_create_bytes(n - 1 | 0);
          caml_ml_input(chan,res,0,n - 1 | 0);
          caml_ml_input_char(chan);
          if(accu)
           var
            len$0=(len + n | 0) - 1 | 0,
            _Cv_=build_result(caml_create_bytes(len$0),len$0,[0,res,accu]);
          else
           var _Cv_=res}
        return caml_string_of_bytes(_Cv_)}}
    function close_in_noerr(ic)
     {try
       {var _Ct_=caml_ml_close_channel(ic);return _Ct_}
      catch(_Cu_){return 0}}
    function print_char(c){return caml_ml_output_char(stdout,c)}
    function print_string(s){return output_string(stdout,s)}
    function print_bytes(s){return output_bytes(stdout,s)}
    function print_int(i)
     {return output_string(stdout,caml_string_of_jsbytes("" + i))}
    function print_float(f){return output_string(stdout,to_string(f))}
    function print_endline(s)
     {output_string(stdout,s);
      caml_ml_output_char(stdout,10);
      return caml_ml_flush(stdout)}
    function print_newline(param)
     {caml_ml_output_char(stdout,10);return caml_ml_flush(stdout)}
    function prerr_char(c){return caml_ml_output_char(stderr,c)}
    function prerr_string(s){return output_string(stderr,s)}
    function prerr_bytes(s){return output_bytes(stderr,s)}
    function prerr_int(i)
     {return output_string(stderr,caml_string_of_jsbytes("" + i))}
    function prerr_float(f){return output_string(stderr,to_string(f))}
    function prerr_endline(s)
     {output_string(stderr,s);
      caml_ml_output_char(stderr,10);
      return caml_ml_flush(stderr)}
    function prerr_newline(param)
     {caml_ml_output_char(stderr,10);return caml_ml_flush(stderr)}
    function read_line(param){caml_ml_flush(stdout);return input_line(stdin)}
    function read_int(param){return caml_int_of_string(read_line(0))}
    function read_int_opt(param){return int_of_string_opt(read_line(0))}
    function read_float(param){return caml_float_of_string(read_line(0))}
    function read_float_opt(param){return of_string_opt(read_line(0))}
    function string_of_format(param){var str=param[2];return str}
    function symbol(param,_Cr_)
     {var
       str2=_Cr_[2],
       fmt2=_Cr_[1],
       str1=param[2],
       fmt1=param[1],
       _Cs_=cat(str1,cat(cst$0,str2));
      return [0,concat_fmt(fmt1,fmt2),_Cs_]}
    var exit_function=[0,flush_all];
    function at_exit(f)
     {for(;;)
       {var
         f_yet_to_run=[0,1],
         old_exit=exit_function[1],
         new_exit$0=
          function(f_yet_to_run,old_exit)
           {function new_exit(param)
             {if(compare_and_set(f_yet_to_run,1,0))caml_call1(f,0);
              return caml_call1(old_exit,0)}
            return new_exit},
         new_exit=new_exit$0(f_yet_to_run,old_exit),
         success=compare_and_set(exit_function,old_exit,new_exit),
         _Cq_=1 - success;
        if(_Cq_)continue;
        return _Cq_}}
    function do_at_exit(param){return caml_call1(exit_function[1],0)}
    function exit(retcode)
     {do_at_exit(0);return runtime.caml_sys_exit(retcode)}
    caml_register_named_value
     (caml_string_of_jsbytes("Pervasives.do_at_exit"),do_at_exit);
    var
     set_binary_mode_in=caml_ml_set_binary_mode,
     close_in=caml_ml_close_channel,
     in_channel_length=caml_ml_channel_size,
     pos_in=runtime.caml_ml_pos_in,
     seek_in=runtime.caml_ml_seek_in,
     input_value=caml_input_value,
     input_binary_int=runtime.caml_ml_input_int,
     input_byte=caml_ml_input_char,
     input_char=caml_ml_input_char,
     set_binary_mode_out=caml_ml_set_binary_mode,
     out_channel_length=caml_ml_channel_size,
     pos_out=runtime.caml_ml_pos_out,
     seek_out=runtime.caml_ml_seek_out,
     output_binary_int=runtime.caml_ml_output_int,
     output_byte=caml_ml_output_char,
     output_char=caml_ml_output_char,
     flush=caml_ml_flush,
     Stdlib=
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       cat,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit];
    caml_register_global(759,Stdlib,"Stdlib");
    var
     Exit$0=[248,cst_Stdlib_Pervasives_Exit,caml_fresh_oo_id(0)],
     Stdlib_Pervasives=
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       cat,
       char_of_int,
       string_of_bool,
       bool_of_string,
       bool_of_string_opt,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int,
       read_int_opt,
       read_float,
       read_float_opt,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       do_at_exit];
    caml_register_global(760,Stdlib_Pervasives,"Stdlib__Pervasives");
    function empty(param){return 0}
    function return$0(x,param){return [0,x,empty]}
    function cons(x,next,param){return [0,x,next]}
    function append$0(seq1,seq2,param)
     {var match=caml_call1(seq1,0);
      if(match)
       {var next=match[2],x=match[1];
        return [0,x,function(_Cp_){return append$0(next,seq2,_Cp_)}]}
      return caml_call1(seq2,0)}
    function map(f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var
         next=match[2],
         x=match[1],
         _Cn_=function(_Co_){return map(f,next,_Co_)};
        return [0,caml_call1(f,x),_Cn_]}
      return 0}
    function filter_map(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1],match$0=caml_call1(f,x);
          if(match$0)
           {var y=match$0[1];
            return [0,y,function(_Cm_){return filter_map(f,next,_Cm_)}]}
          var seq$0=next;
          continue}
        return 0}}
    function filter(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          if(caml_call1(f,x))
           return [0,x,function(_Cl_){return filter(f,next,_Cl_)}];
          var seq$0=next;
          continue}
        return 0}}
    function concat(seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1],_Cj_=0;
        return append$0(x,function(_Ck_){return concat(next,_Ck_)},_Cj_)}
      return 0}
    function flat_map(f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var
         next=match[2],
         x=match[1],
         _Cg_=0,
         _Ch_=function(_Ci_){return flat_map(f,next,_Ci_)};
        return append$0(caml_call1(f,x),_Ch_,_Cg_)}
      return 0}
    function fold_left(f,acc,seq)
     {var acc$0=acc,seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var
           next=match[2],
           x=match[1],
           acc$1=caml_call2(f,acc$0,x),
           acc$0=acc$1,
           seq$0=next;
          continue}
        return acc$0}}
    function iter(f,seq)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          caml_call1(f,x);
          var seq$0=next;
          continue}
        return 0}}
    function unfold(f,u,param)
     {var match=caml_call1(f,u);
      if(match)
       {var match$0=match[1],u$0=match$0[2],x=match$0[1];
        return [0,x,function(_Cf_){return unfold(f,u$0,_Cf_)}]}
      return 0}
    var
     Stdlib_Seq=
      [0,
       empty,
       return$0,
       cons,
       append$0,
       map,
       filter,
       filter_map,
       concat,
       flat_map,
       flat_map,
       fold_left,
       iter,
       unfold];
    caml_register_global(761,Stdlib_Seq,"Stdlib__Seq");
    var none=0;
    function some(v){return [0,v]}
    function value(o,default$0){if(o){var v=o[1];return v}return default$0}
    function get$0(param)
     {if(param){var v=param[1];return v}
      return invalid_arg(cst_option_is_None)}
    function bind(o,f){if(o){var v=o[1];return caml_call1(f,v)}return 0}
    function join(param){if(param){var o=param[1];return o}return 0}
    function map$0(f,o){if(o){var v=o[1];return [0,caml_call1(f,v)]}return 0}
    function fold(none,some,param)
     {if(param){var v=param[1];return caml_call1(some,v)}return none}
    function iter$0(f,param)
     {if(param){var v=param[1];return caml_call1(f,v)}return 0}
    function is_none(param){return param?0:1}
    function is_some(param){return param?1:0}
    function equal(eq,o0,o1)
     {if(o0)
       {if(o1){var v1=o1[1],v0=o0[1];return caml_call2(eq,v0,v1)}}
      else
       if(! o1)return 1;
      return 0}
    function compare(cmp,o0,o1)
     {if(o0)
       {var _Ce_=o0[1];
        if(o1){var v1=o1[1];return caml_call2(cmp,_Ce_,v1)}
        return 1}
      return o1?-1:0}
    function to_result(none,param)
     {if(param){var v=param[1];return [0,v]}return [1,none]}
    function to_list(param){if(param){var v=param[1];return [0,v,0]}return 0}
    function to_seq(param)
     {if(param){var v=param[1];return function(_Cd_){return return$0(v,_Cd_)}}
      return empty}
    var
     Stdlib_Option=
      [0,
       none,
       some,
       value,
       get$0,
       bind,
       join,
       map$0,
       fold,
       iter$0,
       is_none,
       is_some,
       equal,
       compare,
       to_result,
       to_list,
       to_seq];
    caml_register_global(762,Stdlib_Option,"Stdlib__Option");
    function left(v){return [0,v]}
    function right(v){return [1,v]}
    function is_left(param){return 0 === param[0]?1:0}
    function is_right(param){return 0 === param[0]?0:1}
    function find_left(param)
     {if(0 === param[0]){var v=param[1];return [0,v]}return 0}
    function find_right(param)
     {if(0 === param[0])return 0;var v=param[1];return [0,v]}
    function map_left(f,e)
     {if(0 === e[0]){var v=e[1];return [0,caml_call1(f,v)]}return e}
    function map_right(f,e)
     {if(0 === e[0])return e;var v=e[1];return [1,caml_call1(f,v)]}
    function map$1(left,right,param)
     {if(0 === param[0]){var v=param[1];return [0,caml_call1(left,v)]}
      var v$0=param[1];
      return [1,caml_call1(right,v$0)]}
    function fold$0(left,right,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(left,v)}
      var v$0=param[1];
      return caml_call1(right,v$0)}
    function equal$0(left,right,e1,e2)
     {if(0 === e1[0])
       {var _Cb_=e1[1];
        if(0 === e2[0]){var v2=e2[1];return caml_call2(left,_Cb_,v2)}}
      else
       {var _Cc_=e1[1];
        if(0 !== e2[0]){var v2$0=e2[1];return caml_call2(right,_Cc_,v2$0)}}
      return 0}
    function compare$0(left,right,e1,e2)
     {if(0 === e1[0])
       {var _B$_=e1[1];
        if(0 === e2[0]){var v2=e2[1];return caml_call2(left,_B$_,v2)}
        return -1}
      var _Ca_=e1[1];
      if(0 === e2[0])return 1;
      var v2$0=e2[1];
      return caml_call2(right,_Ca_,v2$0)}
    var
     Stdlib_Either=
      [0,
       left,
       right,
       is_left,
       is_right,
       find_left,
       find_right,
       map_left,
       map_right,
       map$1,
       fold$0,
       fold$0,
       fold$0,
       equal$0,
       compare$0];
    caml_register_global(763,Stdlib_Either,"Stdlib__Either");
    function ok(v){return [0,v]}
    function error(e){return [1,e]}
    function value$0(r,default$0)
     {if(0 === r[0]){var v=r[1];return v}return default$0}
    function get_ok(param)
     {if(0 === param[0]){var v=param[1];return v}
      return invalid_arg(cst_result_is_Error)}
    function get_error(param)
     {if(0 === param[0])return invalid_arg(cst_result_is_Ok);
      var e=param[1];
      return e}
    function bind$0(r,f)
     {if(0 === r[0]){var v=r[1];return caml_call1(f,v)}return r}
    function join$0(e){if(0 === e[0]){var r=e[1];return r}return e}
    function map$2(f,e)
     {if(0 === e[0]){var v=e[1];return [0,caml_call1(f,v)]}return e}
    function map_error(f,v)
     {if(0 === v[0])return v;var e=v[1];return [1,caml_call1(f,e)]}
    function fold$1(ok,error,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(ok,v)}
      var e=param[1];
      return caml_call1(error,e)}
    function iter$1(f,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(f,v)}return 0}
    function iter_error(f,param)
     {if(0 === param[0])return 0;var e=param[1];return caml_call1(f,e)}
    function is_ok(param){return 0 === param[0]?1:0}
    function is_error(param){return 0 === param[0]?0:1}
    function equal$1(ok,error,r0,r1)
     {if(0 === r0[0])
       {var _B9_=r0[1];
        if(0 === r1[0]){var v1=r1[1];return caml_call2(ok,_B9_,v1)}}
      else
       {var _B__=r0[1];
        if(0 !== r1[0]){var e1=r1[1];return caml_call2(error,_B__,e1)}}
      return 0}
    function compare$1(ok,error,r0,r1)
     {if(0 === r0[0])
       {var _B7_=r0[1];
        if(0 === r1[0]){var v1=r1[1];return caml_call2(ok,_B7_,v1)}
        return -1}
      var _B8_=r0[1];
      if(0 === r1[0])return 1;
      var e1=r1[1];
      return caml_call2(error,_B8_,e1)}
    function to_option(param)
     {if(0 === param[0]){var v=param[1];return [0,v]}return 0}
    function to_list$0(param)
     {if(0 === param[0]){var v=param[1];return [0,v,0]}return 0}
    function to_seq$0(param)
     {if(0 === param[0])
       {var v=param[1];return function(_B6_){return return$0(v,_B6_)}}
      return empty}
    var
     Stdlib_Result=
      [0,
       ok,
       error,
       value$0,
       get_ok,
       get_error,
       bind$0,
       join$0,
       map$2,
       map_error,
       fold$1,
       iter$1,
       iter_error,
       is_ok,
       is_error,
       equal$1,
       compare$1,
       to_option,
       to_list$0,
       to_seq$0];
    caml_register_global(764,Stdlib_Result,"Stdlib__Result");
    function equal$2(_B5_,_B4_){return _B5_ === _B4_?1:0}
    var compare$2=caml_int_compare;
    function to_float(param){return param?1.:0.}
    function to_string$0(param){return param?cst_true$2:cst_false$2}
    function _m_(_B3_){return _B3_}
    var
     Stdlib_Bool=
      [0,
       function(_B2_){return 1 - _B2_},
       equal$2,
       compare$2,
       _m_,
       to_float,
       to_string$0];
    caml_register_global(765,Stdlib_Bool,"Stdlib__Bool");
    function chr(n)
     {if(0 <= n && ! (255 < n))return n;return invalid_arg(cst_Char_chr)}
    function escaped(c)
     {var switch$0=0;
      if(40 <= c)
       {if(92 === c)return cst$1;if(! (127 <= c))switch$0 = 1}
      else
       if(32 <= c)
        {if(39 <= c)return cst$2;switch$0 = 1}
       else
        if(! (14 <= c))
         switch(c)
          {case 8:return cst_b;
           case 9:return cst_t;
           case 10:return cst_n;
           case 13:return cst_r
           }
      if(switch$0)
       {var s$0=caml_create_bytes(1);
        caml_bytes_unsafe_set(s$0,0,c);
        return caml_string_of_bytes(s$0)}
      var s=caml_create_bytes(4);
      caml_bytes_unsafe_set(s,0,92);
      caml_bytes_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
      caml_bytes_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
      caml_bytes_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
      return caml_string_of_bytes(s)}
    function lowercase(c)
     {var _B1_=c - 192 | 0,switch$0=0;
      if(30 < _B1_ >>> 0)
       {if(! (25 < _B1_ + 127 >>> 0))switch$0 = 1}
      else
       if(23 !== _B1_)switch$0 = 1;
      return switch$0?c + 32 | 0:c}
    function uppercase(c)
     {var _B0_=c - 224 | 0,switch$0=0;
      if(30 < _B0_ >>> 0)
       {if(! (25 < _B0_ + 127 >>> 0))switch$0 = 1}
      else
       if(23 !== _B0_)switch$0 = 1;
      return switch$0?c - 32 | 0:c}
    function lowercase_ascii(c){return 25 < c - 65 >>> 0?c:c + 32 | 0}
    function uppercase_ascii(c){return 25 < c - 97 >>> 0?c:c - 32 | 0}
    function compare$3(c1,c2){return c1 - c2 | 0}
    function equal$3(c1,c2){return 0 === (c1 - c2 | 0)?1:0}
    var
     Stdlib_Char=
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare$3,
       equal$3];
    caml_register_global(766,Stdlib_Char,"Stdlib__Char");
    var
     min$0=0,
     max$0=1114111,
     lo_bound=55295,
     hi_bound=57344,
     bom=65279,
     rep=65533;
    function succ(u)
     {return u === 55295
              ?hi_bound
              :u === 1114111?invalid_arg(err_no_succ):u + 1 | 0}
    function pred(u)
     {return u === 57344?lo_bound:u === 0?invalid_arg(err_no_pred):u - 1 | 0}
    function is_valid(i)
     {var _BW_=0 <= i?1:0,_BX_=_BW_?i <= 55295?1:0:_BW_;
      if(_BX_)
       var _BY_=_BX_;
      else
       var _BZ_=57344 <= i?1:0,_BY_=_BZ_?i <= 1114111?1:0:_BZ_;
      return _BY_}
    function of_int(i)
     {return is_valid(i)
              ?i
              :invalid_arg
                (cat(caml_format_int(cst_X,i),cst_is_not_an_Unicode_scalar_v))}
    function is_char(u){return u < 256?1:0}
    function of_char(c){return c}
    function to_char(u)
     {return 255 < u
              ?invalid_arg
                (cat
                  (cst_U,
                   cat
                    (caml_format_int(cst_04X,u),cst_is_not_a_latin1_character)))
              :u}
    function unsafe_to_char(_BV_){return _BV_}
    function equal$4(_BU_,_BT_){return _BU_ === _BT_?1:0}
    var compare$4=caml_int_compare;
    function hash(_BS_){return _BS_}
    function _n_(_BR_){return _BR_}
    var
     Stdlib_Uchar=
      [0,
       min$0,
       max$0,
       bom,
       rep,
       succ,
       pred,
       is_valid,
       of_int,
       function(_BQ_){return _BQ_},
       _n_,
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal$4,
       compare$4,
       hash];
    caml_register_global(767,Stdlib_Uchar,"Stdlib__Uchar");
    var
     executable_name=runtime.caml_sys_executable_name(0),
     match=runtime.caml_sys_get_config(0),
     os_type=match[1],
     match$0=[0,caml_string_of_jsbytes("js_of_ocaml")],
     unix=runtime.caml_sys_const_ostype_unix(0),
     win32=runtime.caml_sys_const_ostype_win32(0),
     cygwin=runtime.caml_sys_const_ostype_cygwin(0),
     max_array_length=runtime.caml_sys_const_max_wosize(0),
     max_floatarray_length=max_array_length / 2 | 0,
     max_string_length=(4 * max_array_length | 0) - 1 | 0,
     big_endian=0,
     match$1=32,
     int_size=32;
    function getenv_opt(s)
     {try
       {var _BO_=[0,caml_sys_getenv(s)];return _BO_}
      catch(_BP_)
       {_BP_ = caml_wrap_exception(_BP_);
        if(_BP_ === Not_found)return 0;
        throw _BP_}}
    var interactive=[0,0];
    function set_signal(sig_num,sig_beh){return 0}
    var
     Break=[248,cst_Stdlib_Sys_Break,caml_fresh_oo_id(0)],
     sigabrt=-1,
     sigalrm=-2,
     sigfpe=-3,
     sighup=-4,
     sigill=-5,
     sigint=-6,
     sigkill=-7,
     sigpipe=-8,
     sigquit=-9,
     sigsegv=-10,
     sigterm=-11,
     sigusr1=-12,
     sigusr2=-13,
     sigchld=-14,
     sigcont=-15,
     sigstop=-16,
     sigtstp=-17,
     sigttin=-18,
     sigttou=-19,
     sigvtalrm=-20,
     sigprof=-21,
     sigbus=-22,
     sigpoll=-23,
     sigsys=-24,
     sigtrap=-25,
     sigurg=-26,
     sigxcpu=-27,
     sigxfsz=-28;
    function catch_break(on){return on?0:0}
    function Make(_BN_,_BM_){return [0,1]}
    var
     Immediate64=[0,Make],
     Stdlib_Sys=
      [0,
       executable_name,
       getenv_opt,
       interactive,
       os_type,
       match$0,
       unix,
       win32,
       cygwin,
       match$1,
       int_size,
       big_endian,
       max_string_length,
       max_array_length,
       max_floatarray_length,
       set_signal,
       sigabrt,
       sigalrm,
       sigfpe,
       sighup,
       sigill,
       sigint,
       sigkill,
       sigpipe,
       sigquit,
       sigsegv,
       sigterm,
       sigusr1,
       sigusr2,
       sigchld,
       sigcont,
       sigstop,
       sigtstp,
       sigttin,
       sigttou,
       sigvtalrm,
       sigprof,
       sigbus,
       sigpoll,
       sigsys,
       sigtrap,
       sigurg,
       sigxcpu,
       sigxfsz,
       Break,
       catch_break,
       ocaml_version,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled,
       Immediate64];
    caml_register_global(768,Stdlib_Sys,"Stdlib__Sys");
    function length(l)
     {var len=0,param=l;
      for(;;)
       {if(param)
         {var param$0=param[2],len$0=len + 1 | 0,len=len$0,param=param$0;
          continue}
        return len}}
    function cons$0(a,l){return [0,a,l]}
    function hd(param)
     {if(param){var a=param[1];return a}return failwith(cst_hd)}
    function tl(param)
     {if(param){var l=param[2];return l}return failwith(cst_tl)}
    function nth(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return a;
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return failwith(cst_nth)}}
      return invalid_arg(cst_List_nth)}
    function nth_opt(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return [0,a];
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return 0}}
      return invalid_arg(cst_List_nth$0)}
    function rev_append(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var l1$1=l1$0[2],a=l1$0[1],l2$1=[0,a,l2$0],l1$0=l1$1,l2$0=l2$1;
          continue}
        return l2$0}}
    function rev(l){return rev_append(l,0)}
    function init_aux(i,n,f)
     {if(n <= i)return 0;
      var r=caml_call1(f,i);
      return [0,r,init_aux(i + 1 | 0,n,f)]}
    function init(len,f)
     {if(0 <= len)
       {if(50 < len)
         {var acc=0,i=0;
          for(;;)
           {if(len <= i)return rev(acc);
            var i$0=i + 1 | 0,acc$0=[0,caml_call1(f,i),acc],acc=acc$0,i=i$0;
            continue}}
        return init_aux(0,len,f)}
      return invalid_arg(cst_List_init)}
    function flatten(param)
     {if(param){var r=param[2],l=param[1];return append(l,flatten(r))}
      return 0}
    function map$3(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map$3(f,l)]}
      return 0}
    function _o_(i,f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call2(f,i,a);
        return [0,r,_o_(i + 1 | 0,f,l)]}
      return 0}
    function mapi(f,l){return _o_(0,f,l)}
    function rev_map(f,param)
     {var accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           a=param$0[1],
           accu$0=[0,caml_call1(f,a),accu],
           accu=accu$0,
           param$0=l;
          continue}
        return accu}}
    function iter$2(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1];
          caml_call1(f,a);
          var param$0=l;
          continue}
        return 0}}
    function iteri(f,l$0)
     {var i=0,param=l$0;
      for(;;)
       {if(param)
         {var l=param[2],a=param[1];
          caml_call2(f,i,a);
          var i$0=i + 1 | 0,i=i$0,param=l;
          continue}
        return 0}}
    function fold_left$0(f,accu,l)
     {var accu$0=accu,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           a=l$0[1],
           accu$1=caml_call2(f,accu$0,a),
           accu$0=accu$1,
           l$0=l$1;
          continue}
        return accu$0}}
    function fold_right(f,l,accu)
     {if(l){var l$0=l[2],a=l[1];return caml_call2(f,a,fold_right(f,l$0,accu))}
      return accu}
    function map2(f,l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1],r=caml_call2(f,a1,a2);
          return [0,r,map2(f,l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_map2)}
    function rev_map2(f,l1,l2)
     {var accu=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$0=[0,caml_call2(f,a1,a2),accu],
             accu=accu$0,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu;
        return invalid_arg(cst_List_rev_map2)}}
    function iter2(f,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],l1$1=l1$0[2],a1=l1$0[1];
            caml_call2(f,a1,a2);
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_iter2)}}
    function fold_left2(f,accu,l1,l2)
     {var accu$0=accu,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$1=caml_call3(f,accu$0,a1,a2),
             accu$0=accu$1,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu$0;
        return invalid_arg(cst_List_fold_left2)}}
    function fold_right2(f,l1,l2,accu)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return caml_call3(f,a1,a2,fold_right2(f,l1$0,l2$0,accu))}}
      else
       if(! l2)return accu;
      return invalid_arg(cst_List_fold_right2)}
    function for_all(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_BL_=caml_call1(p,a);
          if(_BL_){var param$0=l;continue}
          return _BL_}
        return 1}}
    function exists(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_BK_=caml_call1(p,a);
          if(_BK_)return _BK_;
          var param$0=l;
          continue}
        return 0}}
    function for_all2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _BJ_=caml_call2(p,a1,a2);
            if(_BJ_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _BJ_}}
        else
         if(! l2$0)return 1;
        return invalid_arg(cst_List_for_all2)}}
    function exists2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _BI_=caml_call2(p,a1,a2);
            if(_BI_)return _BI_;
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_exists2)}}
    function mem(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_BH_=0 === caml_compare(a,x)?1:0;
          if(_BH_)return _BH_;
          var param$0=l;
          continue}
        return 0}}
    function memq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_BG_=a === x?1:0;
          if(_BG_)return _BG_;
          var param$0=l;
          continue}
        return 0}}
    function assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assoc_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assq_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function mem_assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           match=param$0[1],
           a=match[1],
           _BF_=0 === caml_compare(a,x)?1:0;
          if(_BF_)return _BF_;
          var param$0=l;
          continue}
        return 0}}
    function mem_assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],a=match[1],_BE_=a === x?1:0;
          if(_BE_)return _BE_;
          var param$0=l;
          continue}
        return 0}}
    function remove_assoc(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return 0 === caml_compare(a,x)?l:[0,pair,remove_assoc(x,l)]}
      return 0}
    function remove_assq(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return a === x?l:[0,pair,remove_assq(x,l)]}
      return 0}
    function find(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return x;
          var param$0=l;
          continue}
        throw Not_found}}
    function find_opt(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return [0,x];
          var param$0=l;
          continue}
        return 0}}
    function find_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1],result=caml_call1(f,x);
          if(result)return result;
          var param$0=l;
          continue}
        return 0}}
    function find_all(p)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1];
            if(caml_call1(p,x))
             {var accu$1=[0,x,accu$0],accu$0=accu$1,param=l;continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function filteri(p,param)
     {var i=0,acc=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           acc$0=caml_call2(p,i,x)?[0,x,acc]:acc,
           i$0=i + 1 | 0,
           i=i$0,
           acc=acc$0,
           param$0=l;
          continue}
        return rev(acc)}}
    function filter_map$0(f)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1],match=caml_call1(f,x);
            if(match)
             {var v=match[1],accu$1=[0,v,accu$0],accu$0=accu$1,param=l;
              continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function concat_map(f,param)
     {var acc=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           xs=caml_call1(f,x),
           acc$0=rev_append(xs,acc),
           acc=acc$0,
           param$0=l;
          continue}
        return rev(acc)}}
    function fold_left_map(f,accu,param)
     {var accu$0=accu,l_accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           match=caml_call2(f,accu$0,x),
           x$0=match[2],
           accu$1=match[1],
           l_accu$0=[0,x$0,l_accu],
           accu$0=accu$1,
           l_accu=l_accu$0,
           param$0=l;
          continue}
        return [0,accu$0,rev(l_accu)]}}
    function partition(p,param)
     {var yes=0,no=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))
           {var yes$0=[0,x,yes],yes=yes$0,param$0=l;continue}
          var no$0=[0,x,no],no=no$0,param$0=l;
          continue}
        var _BD_=rev(no);
        return [0,rev(yes),_BD_]}}
    function partition_map(p,param)
     {var left=0,right=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1],match=caml_call1(p,x);
          if(0 === match[0])
           {var v=match[1],left$0=[0,v,left],left=left$0,param$0=l;continue}
          var v$0=match[1],right$0=[0,v$0,right],right=right$0,param$0=l;
          continue}
        var _BC_=rev(right);
        return [0,rev(left),_BC_]}}
    function split(param)
     {if(param)
       {var
         l=param[2],
         match=param[1],
         y=match[2],
         x=match[1],
         match$0=split(l),
         ry=match$0[2],
         rx=match$0[1];
        return [0,[0,x,rx],[0,y,ry]]}
      return _p_}
    function combine(l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return [0,[0,a1,a2],combine(l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_combine)}
    function merge(cmp,l1,l2)
     {if(l1)
       {if(l2)
         {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
          return 0 < caml_call2(cmp,h1,h2)
                  ?[0,h2,merge(cmp,l1,t2)]
                  :[0,h1,merge(cmp,t1,l2)]}
        return l1}
      return l2}
    function fast_sort(cmp,l)
     {function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _By_=l[2];
            if(_By_)
             {var
               tl=_By_[2],
               x2=_By_[1],
               x1=l[1],
               s=0 < caml_call2(cmp,x1,x2)?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _BA_=l[2];
           if(_BA_)
            {var _BB_=_BA_[2];
             if(_BB_)
              {var
                tl$1=_BB_[2],
                x3=_BB_[1],
                x2$0=_BA_[1],
                x1$0=l[1],
                s$0=
                 0 < caml_call2(cmp,x1$0,x2$0)
                  ?0 < caml_call2(cmp,x2$0,x3)
                    ?[0,x1$0,[0,x2$0,[0,x3,0]]]
                    :0 < caml_call2(cmp,x1$0,x3)
                      ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                      :[0,x3,[0,x1$0,[0,x2$0,0]]]
                  :0 < caml_call2(cmp,x1$0,x3)
                    ?[0,x2$0,[0,x1$0,[0,x3,0]]]
                    :0 < caml_call2(cmp,x2$0,x3)
                      ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                      :[0,x3,[0,x2$0,[0,x1$0,0]]];
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h2,accu],l2=t2,accu=accu$0;continue}
              var accu$1=[0,h1,accu],l1=t1,accu=accu$1;
              continue}
            var _Bz_=rev_append(l1,accu)}
          else
           var _Bz_=rev_append(l2,accu);
          return [0,_Bz_,tl$0]}}
      function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _Bu_=l[2];
            if(_Bu_)
             {var
               tl=_Bu_[2],
               x2=_Bu_[1],
               x1=l[1],
               s=0 < caml_call2(cmp,x1,x2)?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _Bw_=l[2];
           if(_Bw_)
            {var _Bx_=_Bw_[2];
             if(_Bx_)
              {var
                tl$1=_Bx_[2],
                x3=_Bx_[1],
                x2$0=_Bw_[1],
                x1$0=l[1],
                s$0=
                 0 < caml_call2(cmp,x1$0,x2$0)
                  ?0 < caml_call2(cmp,x1$0,x3)
                    ?0 < caml_call2(cmp,x2$0,x3)
                      ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                      :[0,x2$0,[0,x3,[0,x1$0,0]]]
                    :[0,x2$0,[0,x1$0,[0,x3,0]]]
                  :0 < caml_call2(cmp,x2$0,x3)
                    ?0 < caml_call2(cmp,x1$0,x3)
                      ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                      :[0,x1$0,[0,x3,[0,x2$0,0]]]
                    :[0,x1$0,[0,x2$0,[0,x3,0]]];
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=rev_sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=rev_sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h1,accu],l1=t1,accu=accu$0;continue}
              var accu$1=[0,h2,accu],l2=t2,accu=accu$1;
              continue}
            var _Bv_=rev_append(l1,accu)}
          else
           var _Bv_=rev_append(l2,accu);
          return [0,_Bv_,tl$0]}}
      var len=length(l);
      return 2 <= len?sort(len,l)[1]:l}
    function sort_uniq(cmp,l)
     {function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _Bl_=l[2];
            if(_Bl_)
             {var
               tl=_Bl_[2],
               x2=_Bl_[1],
               x1=l[1],
               c$0=caml_call2(cmp,x1,x2),
               s=0 === c$0?[0,x1,0]:0 < c$0?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _Bn_=l[2];
           if(_Bn_)
            {var _Bo_=_Bn_[2];
             if(_Bo_)
              {var
                tl$1=_Bo_[2],
                x3=_Bo_[1],
                x2$0=_Bn_[1],
                x1$0=l[1],
                c$1=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$1)
                var
                 c$2=caml_call2(cmp,x2$0,x3),
                 _Bp_=
                  0 === c$2
                   ?[0,x2$0,0]
                   :0 < c$2?[0,x2$0,[0,x3,0]]:[0,x3,[0,x2$0,0]],
                 s$0=_Bp_;
               else
                if(0 < c$1)
                 {var c$3=caml_call2(cmp,x2$0,x3);
                  if(0 === c$3)
                   var _Bq_=[0,x1$0,[0,x2$0,0]];
                  else
                   if(0 < c$3)
                    var _Bq_=[0,x1$0,[0,x2$0,[0,x3,0]]];
                   else
                    var
                     c$4=caml_call2(cmp,x1$0,x3),
                     _Br_=
                      0 === c$4
                       ?[0,x1$0,[0,x2$0,0]]
                       :0 < c$4
                         ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                         :[0,x3,[0,x1$0,[0,x2$0,0]]],
                     _Bq_=_Br_;
                  var s$0=_Bq_}
                else
                 {var c$5=caml_call2(cmp,x1$0,x3);
                  if(0 === c$5)
                   var _Bs_=[0,x2$0,[0,x1$0,0]];
                  else
                   if(0 < c$5)
                    var _Bs_=[0,x2$0,[0,x1$0,[0,x3,0]]];
                   else
                    var
                     c$6=caml_call2(cmp,x2$0,x3),
                     _Bt_=
                      0 === c$6
                       ?[0,x2$0,[0,x1$0,0]]
                       :0 < c$6
                         ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                         :[0,x3,[0,x2$0,[0,x1$0,0]]],
                     _Bs_=_Bt_;
                  var s$0=_Bs_}
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 <= c){var accu$1=[0,h2,accu],l2=t2,accu=accu$1;continue}
              var accu$2=[0,h1,accu],l1=t1,accu=accu$2;
              continue}
            var _Bm_=rev_append(l1,accu)}
          else
           var _Bm_=rev_append(l2,accu);
          return [0,_Bm_,tl$0]}}
      function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _Bc_=l[2];
            if(_Bc_)
             {var
               tl=_Bc_[2],
               x2=_Bc_[1],
               x1=l[1],
               c$0=caml_call2(cmp,x1,x2),
               s=0 === c$0?[0,x1,0]:0 <= c$0?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _Be_=l[2];
           if(_Be_)
            {var _Bf_=_Be_[2];
             if(_Bf_)
              {var
                tl$1=_Bf_[2],
                x3=_Bf_[1],
                x2$0=_Be_[1],
                x1$0=l[1],
                c$1=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$1)
                var
                 c$2=caml_call2(cmp,x2$0,x3),
                 _Bg_=
                  0 === c$2
                   ?[0,x2$0,0]
                   :0 <= c$2?[0,x3,[0,x2$0,0]]:[0,x2$0,[0,x3,0]],
                 s$0=_Bg_;
               else
                if(0 <= c$1)
                 {var c$3=caml_call2(cmp,x1$0,x3);
                  if(0 === c$3)
                   var _Bh_=[0,x2$0,[0,x1$0,0]];
                  else
                   if(0 <= c$3)
                    var
                     c$4=caml_call2(cmp,x2$0,x3),
                     _Bi_=
                      0 === c$4
                       ?[0,x2$0,[0,x1$0,0]]
                       :0 <= c$4
                         ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                         :[0,x2$0,[0,x3,[0,x1$0,0]]],
                     _Bh_=_Bi_;
                   else
                    var _Bh_=[0,x2$0,[0,x1$0,[0,x3,0]]];
                  var s$0=_Bh_}
                else
                 {var c$5=caml_call2(cmp,x2$0,x3);
                  if(0 === c$5)
                   var _Bj_=[0,x1$0,[0,x2$0,0]];
                  else
                   if(0 <= c$5)
                    var
                     c$6=caml_call2(cmp,x1$0,x3),
                     _Bk_=
                      0 === c$6
                       ?[0,x1$0,[0,x2$0,0]]
                       :0 <= c$6
                         ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                         :[0,x1$0,[0,x3,[0,x2$0,0]]],
                     _Bj_=_Bk_;
                   else
                    var _Bj_=[0,x1$0,[0,x2$0,[0,x3,0]]];
                  var s$0=_Bj_}
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=rev_sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=rev_sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 < c){var accu$1=[0,h1,accu],l1=t1,accu=accu$1;continue}
              var accu$2=[0,h2,accu],l2=t2,accu=accu$2;
              continue}
            var _Bd_=rev_append(l1,accu)}
          else
           var _Bd_=rev_append(l2,accu);
          return [0,_Bd_,tl$0]}}
      var len=length(l);
      return 2 <= len?sort(len,l)[1]:l}
    function compare_lengths(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0){var l2$1=l2$0[2],l1$1=l1$0[2],l1$0=l1$1,l2$0=l2$1;continue}
          return 1}
        return l2$0?-1:0}}
    function compare_length_with(l,n)
     {var l$0=l,n$0=n;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2];
          if(0 < n$0){var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;continue}
          return 1}
        return 0 === n$0?0:0 < n$0?-1:1}}
    function equal$5(eq,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _Bb_=caml_call2(eq,a1,a2);
            if(_Bb_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _Bb_}}
        else
         if(! l2$0)return 1;
        return 0}}
    function compare$5(cmp,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var _A$_=l1$0[2],_Ba_=l1$0[1];
          if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],c=caml_call2(cmp,_Ba_,a2);
            if(0 === c){var l1$0=_A$_,l2$0=l2$1;continue}
            return c}
          return 1}
        return l2$0?-1:0}}
    function to_seq$1(l)
     {function aux(l,param)
       {if(l)
         {var tail=l[2],x=l[1];
          return [0,x,function(_A__){return aux(tail,_A__)}]}
        return 0}
      return function(_A9_){return aux(l,_A9_)}}
    function of_seq(seq)
     {function direct(depth,seq)
       {if(0 === depth)
         {var _A8_=0;
          return rev(fold_left(function(acc,x){return [0,x,acc]},_A8_,seq))}
        var match=caml_call1(seq,0);
        if(match)
         {var next=match[2],x=match[1];
          return [0,x,direct(depth - 1 | 0,next)]}
        return 0}
      return direct(500,seq)}
    var
     include$0=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons$0,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal$5,
       compare$5,
       iter$2,
       iteri,
       map$3,
       mapi,
       rev_map,
       filter_map$0,
       concat_map,
       fold_left_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(769,include$0,"Stdlib__List");
    var zero=0,one=1,minus_one=-1;
    function abs$0(x){return 0 <= x?x:- x | 0}
    var max_int$0=2147483647,min_int$0=-2147483648;
    function lognot(x){return x ^ -1}
    function equal$6(_A7_,_A6_){return _A7_ === _A6_?1:0}
    var compare$6=caml_int_compare;
    function min$1(x,y){return x <= y?x:y}
    function max$1(x,y){return y <= x?x:y}
    function to_string$1(x){return caml_string_of_jsbytes("" + x)}
    var
     Stdlib_Int=
      [0,
       zero,
       one,
       minus_one,
       abs$0,
       max_int$0,
       min_int$0,
       lognot,
       equal$6,
       compare$6,
       min$1,
       max$1,
       to_string$1];
    caml_register_global(770,Stdlib_Int,"Stdlib__Int");
    function make$0(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    function init$0(n,f)
     {var s=caml_create_bytes(n),_A4_=n - 1 | 0,_A3_=0;
      if(! (_A4_ < 0))
       {var i=_A3_;
        for(;;)
         {caml_bytes_unsafe_set(s,i,caml_call1(f,i));
          var _A5_=i + 1 | 0;
          if(_A4_ !== i){var i=_A5_;continue}
          break}}
      return s}
    var empty$0=caml_create_bytes(0);
    function copy(s)
     {var len=caml_ml_bytes_length(s),r=caml_create_bytes(len);
      caml_blit_bytes(s,0,r,0,len);
      return r}
    function of_bytes(b){return caml_string_of_bytes(copy(b))}
    function to_bytes(s){return copy(caml_bytes_of_string(s))}
    function sub(s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       {var r=caml_create_bytes(len);caml_blit_bytes(s,ofs,r,0,len);return r}
      return invalid_arg(cst_String_sub_Bytes_sub)}
    function sub_string(b,ofs,len)
     {return caml_string_of_bytes(sub(b,ofs,len))}
    function symbol$0(a,b)
     {var c=a + b | 0,_A2_=b < 0?1:0,match=c < 0?1:0,switch$0=0;
      if(a < 0)
       {if(_A2_ && ! match)switch$0 = 1}
      else
       if(! _A2_ && match)switch$0 = 1;
      return switch$0?invalid_arg(cst_Bytes_extend):c}
    function extend(s,left,right)
     {var
       len=symbol$0(symbol$0(caml_ml_bytes_length(s),left),right),
       r=caml_create_bytes(len);
      if(0 <= left)
       var dstoff=left,srcoff=0;
      else
       var dstoff=0,srcoff=- left | 0;
      var cpylen=min$1(caml_ml_bytes_length(s) - srcoff | 0,len - dstoff | 0);
      if(0 < cpylen)caml_blit_bytes(s,srcoff,r,dstoff,cpylen);
      return r}
    function fill(s,ofs,len,c)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_fill_bytes(s,ofs,len,c);
      return invalid_arg(cst_String_fill_Bytes_fill)}
    function blit(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_bytes_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_Bytes_blit)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_string_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_String_blit_Bytes_blit_str)}
    function iter$3(f,a)
     {var _A0_=caml_ml_bytes_length(a) - 1 | 0,_AZ_=0;
      if(! (_A0_ < 0))
       {var i=_AZ_;
        for(;;)
         {caml_call1(f,caml_bytes_unsafe_get(a,i));
          var _A1_=i + 1 | 0;
          if(_A0_ !== i){var i=_A1_;continue}
          break}}
      return 0}
    function iteri$0(f,a)
     {var _AX_=caml_ml_bytes_length(a) - 1 | 0,_AW_=0;
      if(! (_AX_ < 0))
       {var i=_AW_;
        for(;;)
         {caml_call2(f,i,caml_bytes_unsafe_get(a,i));
          var _AY_=i + 1 | 0;
          if(_AX_ !== i){var i=_AY_;continue}
          break}}
      return 0}
    function concat$0(sep,l)
     {if(l)
       {var seplen=caml_ml_bytes_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _AT_=param[1];
            if(param[2])
             {var
               tl=param[2],
               x=(caml_ml_bytes_length(_AT_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_Bytes_concat),
               acc=acc$0,
               param=tl;
              continue}
            var _AV_=caml_ml_bytes_length(_AT_) + acc | 0}
          else
           var _AV_=acc;
          var dst=caml_create_bytes(_AV_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _AU_=param$0[1];
              if(param$0[2])
               {var tl$0=param$0[2];
                caml_blit_bytes(_AU_,0,dst,pos,caml_ml_bytes_length(_AU_));
                caml_blit_bytes
                 (sep,0,dst,pos + caml_ml_bytes_length(_AU_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_bytes_length(_AU_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=tl$0;
                continue}
              caml_blit_bytes(_AU_,0,dst,pos,caml_ml_bytes_length(_AU_));
              return dst}
            return dst}}}
      return empty$0}
    function cat$0(s1,s2)
     {var
       l1=caml_ml_bytes_length(s1),
       l2=caml_ml_bytes_length(s2),
       r=caml_create_bytes(l1 + l2 | 0);
      caml_blit_bytes(s1,0,r,0,l1);
      caml_blit_bytes(s2,0,r,l1,l2);
      return r}
    function is_space(param)
     {var _AS_=param - 9 | 0,switch$0=0;
      if(4 < _AS_ >>> 0)
       {if(23 === _AS_)switch$0 = 1}
      else
       if(2 !== _AS_)switch$0 = 1;
      return switch$0?1:0}
    function trim(s)
     {var len=caml_ml_bytes_length(s),i=[0,0];
      for(;;)
       {if(i[1] < len && is_space(caml_bytes_unsafe_get(s,i[1])))
         {i[1]++;continue}
        var j=[0,len - 1 | 0];
        for(;;)
         {if(i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s,j[1])))
           {j[1] += -1;continue}
          return i[1] <= j[1]?sub(s,i[1],(j[1] - i[1] | 0) + 1 | 0):empty$0}}}
    function escaped$0(s)
     {var n=[0,0],_AL_=caml_ml_bytes_length(s) - 1 | 0,_AK_=0;
      if(! (_AL_ < 0))
       {var i$0=_AK_;
        for(;;)
         {var match=caml_bytes_unsafe_get(s,i$0),switch$0=0;
          if(32 <= match)
           {var _AP_=match - 34 | 0,switch$1=0;
            if(58 < _AP_ >>> 0)
             {if(93 <= _AP_)switch$1 = 1}
            else
             if(56 < _AP_ - 1 >>> 0){switch$0 = 1;switch$1 = 1}
            if(! switch$1){var _AQ_=1;switch$0 = 2}}
          else
           if(11 <= match)
            {if(13 === match)switch$0 = 1}
           else
            if(8 <= match)switch$0 = 1;
          switch(switch$0){case 0:var _AQ_=4;break;case 1:var _AQ_=2;break}
          n[1] = n[1] + _AQ_ | 0;
          var _AR_=i$0 + 1 | 0;
          if(_AL_ !== i$0){var i$0=_AR_;continue}
          break}}
      if(n[1] === caml_ml_bytes_length(s))return copy(s);
      var s$0=caml_create_bytes(n[1]);
      n[1] = 0;
      var _AN_=caml_ml_bytes_length(s) - 1 | 0,_AM_=0;
      if(! (_AN_ < 0))
       {var i=_AM_;
        for(;;)
         {var c=caml_bytes_unsafe_get(s,i),switch$2=0;
          if(35 <= c)
           if(92 === c)
            switch$2 = 2;
           else
            if(127 <= c)switch$2 = 1;else switch$2 = 3;
          else
           if(32 <= c)
            if(34 <= c)switch$2 = 2;else switch$2 = 3;
           else
            if(14 <= c)
             switch$2 = 1;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                break;
               default:switch$2 = 1}
          switch(switch$2)
           {case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c / 100 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c % 10 | 0) | 0);
             break;
            case 2:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 3:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _AO_=i + 1 | 0;
          if(_AN_ !== i){var i=_AO_;continue}
          break}}
      return s$0}
    function map$4(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_AI_=l - 1 | 0,_AH_=0;
      if(! (_AI_ < 0))
       {var i=_AH_;
        for(;;)
         {caml_bytes_unsafe_set(r,i,caml_call1(f,caml_bytes_unsafe_get(s,i)));
          var _AJ_=i + 1 | 0;
          if(_AI_ !== i){var i=_AJ_;continue}
          break}}
      return r}
    function mapi$0(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_AF_=l - 1 | 0,_AE_=0;
      if(! (_AF_ < 0))
       {var i=_AE_;
        for(;;)
         {caml_bytes_unsafe_set
           (r,i,caml_call2(f,i,caml_bytes_unsafe_get(s,i)));
          var _AG_=i + 1 | 0;
          if(_AF_ !== i){var i=_AG_;continue}
          break}}
      return r}
    function fold_left$1(f,x,a)
     {var r=[0,x],_AC_=caml_ml_bytes_length(a) - 1 | 0,_AB_=0;
      if(! (_AC_ < 0))
       {var i=_AB_;
        for(;;)
         {r[1] = caml_call2(f,r[1],caml_bytes_unsafe_get(a,i));
          var _AD_=i + 1 | 0;
          if(_AC_ !== i){var i=_AD_;continue}
          break}}
      return r[1]}
    function fold_right$0(f,a,x)
     {var r=[0,x],_Az_=caml_ml_bytes_length(a) - 1 | 0;
      if(! (_Az_ < 0))
       {var i=_Az_;
        for(;;)
         {r[1] = caml_call2(f,caml_bytes_unsafe_get(a,i),r[1]);
          var _AA_=i - 1 | 0;
          if(0 !== i){var i=_AA_;continue}
          break}}
      return r[1]}
    function exists$0(p,s)
     {var n=caml_ml_bytes_length(s),i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,caml_bytes_unsafe_get(s,i)))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$0(p,s)
     {var n=caml_ml_bytes_length(s),i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,caml_bytes_unsafe_get(s,i)))
         {var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function uppercase_ascii$0(s){return map$4(uppercase_ascii,s)}
    function lowercase_ascii$0(s){return map$4(lowercase_ascii,s)}
    function apply1(f,s)
     {if(0 === caml_ml_bytes_length(s))return s;
      var r=copy(s);
      caml_bytes_unsafe_set(r,0,caml_call1(f,caml_bytes_unsafe_get(s,0)));
      return r}
    function capitalize_ascii(s){return apply1(uppercase_ascii,s)}
    function uncapitalize_ascii(s){return apply1(lowercase_ascii,s)}
    function starts_with(prefix,s)
     {var
       len_s=caml_ml_bytes_length(s),
       len_pre=caml_ml_bytes_length(prefix),
       _Ay_=len_pre <= len_s?1:0;
      if(_Ay_)
       {var i=0;
        for(;;)
         {if(i === len_pre)return 1;
          if(caml_bytes_unsafe_get(s,i) !== caml_bytes_unsafe_get(prefix,i))
           return 0;
          var i$0=i + 1 | 0,i=i$0;
          continue}}
      return _Ay_}
    function ends_with(suffix,s)
     {var
       len_s=caml_ml_bytes_length(s),
       len_suf=caml_ml_bytes_length(suffix),
       diff=len_s - len_suf | 0,
       _Ax_=0 <= diff?1:0;
      if(_Ax_)
       {var i=0;
        for(;;)
         {if(i === len_suf)return 1;
          if
           (caml_bytes_unsafe_get(s,diff + i | 0)
            !==
            caml_bytes_unsafe_get(suffix,i))
           return 0;
          var i$0=i + 1 | 0,i=i$0;
          continue}}
      return _Ax_}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index(s,c){return index_rec(s,caml_ml_bytes_length(s),0,c)}
    function index_rec_opt(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt(s,c)
     {return index_rec_opt(s,caml_ml_bytes_length(s),0,c)}
    function index_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))return index_rec(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_in)}
    function index_from_opt(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))return index_rec_opt(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Byte)}
    function rindex_rec(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex(s,c)
     {return rindex_rec(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from(s,i,c)
     {if(-1 <= i && ! (caml_ml_bytes_length(s) <= i))return rindex_rec(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_r)}
    function rindex_rec_opt(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt(s,c)
     {return rindex_rec_opt(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from_opt(s,i,c)
     {if(-1 <= i && ! (caml_ml_bytes_length(s) <= i))
       return rindex_rec_opt(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Byt)}
    function contains_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec(s,l,i,c);var _Av_=1;return _Av_}
       catch(_Aw_)
        {_Aw_ = caml_wrap_exception(_Aw_);
         if(_Aw_ === Not_found)return 0;
         throw _Aw_}
      return invalid_arg(cst_String_contains_from_Bytes)}
    function contains(s,c){return contains_from(s,0,c)}
    function rcontains_from(s,i,c)
     {if(0 <= i && ! (caml_ml_bytes_length(s) <= i))
       try
        {rindex_rec(s,i,c);var _At_=1;return _At_}
       catch(_Au_)
        {_Au_ = caml_wrap_exception(_Au_);
         if(_Au_ === Not_found)return 0;
         throw _Au_}
      return invalid_arg(cst_String_rcontains_from_Byte)}
    function compare$7(x,y){return runtime.caml_bytes_compare(x,y)}
    function split_on_char(sep,s)
     {var
       r=[0,0],
       j=[0,caml_ml_bytes_length(s)],
       _Ap_=caml_ml_bytes_length(s) - 1 | 0;
      if(! (_Ap_ < 0))
       {var i=_Ap_;
        for(;;)
         {if(caml_bytes_unsafe_get(s,i) === sep)
           {var _Ar_=r[1];
            r[1] = [0,sub(s,i + 1 | 0,(j[1] - i | 0) - 1 | 0),_Ar_];
            j[1] = i}
          var _As_=i - 1 | 0;
          if(0 !== i){var i=_As_;continue}
          break}}
      var _Aq_=r[1];
      return [0,sub(s,0,j[1]),_Aq_]}
    function uppercase$0(s){return map$4(uppercase,s)}
    function lowercase$0(s){return map$4(lowercase,s)}
    function capitalize(s){return apply1(uppercase,s)}
    function uncapitalize(s){return apply1(lowercase,s)}
    function to_seq$2(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_An_=i + 1 | 0;
        return [0,x,function(_Ao_){return aux(_An_,_Ao_)}]}
      var _Al_=0;
      return function(_Am_){return aux(_Al_,_Am_)}}
    function to_seqi(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_Aj_=i + 1 | 0;
        return [0,[0,i,x],function(_Ak_){return aux(_Aj_,_Ak_)}]}
      var _Ah_=0;
      return function(_Ai_){return aux(_Ah_,_Ai_)}}
    function of_seq$0(i)
     {var n=[0,0],buf=[0,make$0(256,0)];
      iter
       (function(c)
         {if(n[1] === caml_ml_bytes_length(buf[1]))
           {var
             new_len=
              min$1(2 * caml_ml_bytes_length(buf[1]) | 0,max_string_length);
            if(caml_ml_bytes_length(buf[1]) === new_len)
             failwith(cst_Bytes_of_seq_cannot_grow_b);
            var new_buf=make$0(new_len,0);
            blit(buf[1],0,new_buf,0,n[1]);
            buf[1] = new_buf}
          caml_bytes_set(buf[1],n[1],c);
          n[1]++;
          return 0},
        i);
      return sub(buf[1],0,n[1])}
    function get_int8(b,i){return caml_bytes_get(b,i) << 24 >> 24}
    function get_uint16_le(b,i){return caml_bytes_get16(b,i)}
    function get_uint16_be(b,i){return caml_bswap16(caml_bytes_get16(b,i))}
    function get_int16_ne(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_le(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_be(b,i){return get_uint16_be(b,i) << 16 >> 16}
    function get_int32_le(b,i){return caml_bytes_get32(b,i)}
    function get_int32_be(b,i){return caml_int32_bswap(caml_bytes_get32(b,i))}
    function get_int64_le(b,i){return caml_bytes_get64(b,i)}
    function get_int64_be(b,i){return caml_int64_bswap(caml_bytes_get64(b,i))}
    function set_int16_le(b,i,x){return caml_bytes_set16(b,i,x)}
    function set_int16_be(b,i,x){return caml_bytes_set16(b,i,caml_bswap16(x))}
    function set_int32_le(b,i,x){return caml_bytes_set32(b,i,x)}
    function set_int32_be(b,i,x)
     {return caml_bytes_set32(b,i,caml_int32_bswap(x))}
    function set_int64_le(b,i,x){return caml_bytes_set64(b,i,x)}
    function set_int64_be(b,i,x)
     {return caml_bytes_set64(b,i,caml_int64_bswap(x))}
    var
     set_uint8=caml_bytes_set,
     set_uint16_ne=caml_bytes_set16,
     set_int64_ne=caml_bytes_set64,
     set_int32_ne=caml_bytes_set32,
     set_int16_ne=caml_bytes_set16,
     set_int8=caml_bytes_set,
     get_int64_ne=caml_bytes_get64,
     get_int32_ne=caml_bytes_get32,
     get_uint16_ne=caml_bytes_get16,
     get_uint8=caml_bytes_get,
     unsafe_of_string=caml_bytes_of_string,
     unsafe_to_string=caml_string_of_bytes,
     equal$7=runtime.caml_bytes_equal,
     include$1=
      [0,
       make$0,
       init$0,
       empty$0,
       copy,
       to_bytes,
       of_bytes,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat$0,
       cat$0,
       iter$3,
       iteri$0,
       map$4,
       mapi$0,
       fold_left$1,
       fold_right$0,
       for_all$0,
       exists$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$7,
       equal$7,
       starts_with,
       ends_with,
       unsafe_to_string,
       unsafe_of_string,
       split_on_char,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le];
    caml_register_global(771,include$1,"Stdlib__Bytes");
    function make$1(n,c){return caml_string_of_bytes(make$0(n,c))}
    function init$1(n,f){return caml_string_of_bytes(init$0(n,f))}
    function copy$0(s)
     {return caml_string_of_bytes(copy(caml_bytes_of_string(s)))}
    function sub$0(s,ofs,len)
     {return caml_string_of_bytes(sub(caml_bytes_of_string(s),ofs,len))}
    function concat$1(sep,l)
     {if(l)
       {var seplen=caml_ml_string_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _Ae_=param[1];
            if(param[2])
             {var
               tl=param[2],
               x=(caml_ml_string_length(_Ae_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_String_concat),
               acc=acc$0,
               param=tl;
              continue}
            var _Ag_=caml_ml_string_length(_Ae_) + acc | 0}
          else
           var _Ag_=acc;
          var dst=caml_create_bytes(_Ag_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _Af_=param$0[1];
              if(param$0[2])
               {var tl$0=param$0[2];
                caml_blit_string(_Af_,0,dst,pos,caml_ml_string_length(_Af_));
                caml_blit_string
                 (sep,0,dst,pos + caml_ml_string_length(_Af_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_string_length(_Af_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=tl$0;
                continue}
              caml_blit_string(_Af_,0,dst,pos,caml_ml_string_length(_Af_))}
            return caml_string_of_bytes(dst)}}}
      return cst$3}
    function iter$4(f,s)
     {var _Ac_=caml_ml_string_length(s) - 1 | 0,_Ab_=0;
      if(! (_Ac_ < 0))
       {var i=_Ab_;
        for(;;)
         {caml_call1(f,caml_string_unsafe_get(s,i));
          var _Ad_=i + 1 | 0;
          if(_Ac_ !== i){var i=_Ad_;continue}
          break}}
      return 0}
    function iteri$1(f,s)
     {var _z$_=caml_ml_string_length(s) - 1 | 0,_z__=0;
      if(! (_z$_ < 0))
       {var i=_z__;
        for(;;)
         {caml_call2(f,i,caml_string_unsafe_get(s,i));
          var _Aa_=i + 1 | 0;
          if(_z$_ !== i){var i=_Aa_;continue}
          break}}
      return 0}
    function map$5(f,s)
     {return caml_string_of_bytes(map$4(f,caml_bytes_of_string(s)))}
    function mapi$1(f,s)
     {return caml_string_of_bytes(mapi$0(f,caml_bytes_of_string(s)))}
    function fold_right$1(f,x,a)
     {return fold_right$0(f,caml_bytes_of_string(x),a)}
    function fold_left$2(f,a,x)
     {return fold_left$1(f,a,caml_bytes_of_string(x))}
    function exists$1(f,s){return exists$0(f,caml_bytes_of_string(s))}
    function for_all$1(f,s){return for_all$0(f,caml_bytes_of_string(s))}
    function is_space$0(param)
     {var _z9_=param - 9 | 0,switch$0=0;
      if(4 < _z9_ >>> 0)
       {if(23 === _z9_)switch$0 = 1}
      else
       if(2 !== _z9_)switch$0 = 1;
      return switch$0?1:0}
    function trim$0(s)
     {if(caml_string_equal(s,cst$4))return s;
      if
       (!
        is_space$0(caml_string_unsafe_get(s,0))
        &&
        !
        is_space$0(caml_string_unsafe_get(s,caml_ml_string_length(s) - 1 | 0)))
       return s;
      return caml_string_of_bytes(trim(caml_bytes_of_string(s)))}
    function escaped$1(s)
     {var n=caml_ml_string_length(s),i=0;
      for(;;)
       {if(n <= i)return s;
        var match=caml_string_unsafe_get(s,i),_z8_=match - 32 | 0,switch$0=0;
        if(59 < _z8_ >>> 0)
         {if(33 < _z8_ - 61 >>> 0)switch$0 = 1}
        else
         if(2 === _z8_)switch$0 = 1;
        if(switch$0)
         return caml_string_of_bytes(escaped$0(caml_bytes_of_string(s)));
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function index_rec$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_string_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index$0(s,c){return index_rec$0(s,caml_ml_string_length(s),0,c)}
    function index_rec_opt$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt$0(s,c)
     {return index_rec_opt$0(s,caml_ml_string_length(s),0,c)}
    function index_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))return index_rec$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_in$0)}
    function index_from_opt$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))return index_rec_opt$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Byte$0)}
    function rindex_rec$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex$0(s,c)
     {return rindex_rec$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from$0(s,i,c)
     {if(-1 <= i && ! (caml_ml_string_length(s) <= i))
       return rindex_rec$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_r$0)}
    function rindex_rec_opt$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt$0(s,c)
     {return rindex_rec_opt$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from_opt$0(s,i,c)
     {if(-1 <= i && ! (caml_ml_string_length(s) <= i))
       return rindex_rec_opt$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Byt$0)}
    function contains_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec$0(s,l,i,c);var _z6_=1;return _z6_}
       catch(_z7_)
        {_z7_ = caml_wrap_exception(_z7_);
         if(_z7_ === Not_found)return 0;
         throw _z7_}
      return invalid_arg(cst_String_contains_from_Bytes$0)}
    function contains$0(s,c){return contains_from$0(s,0,c)}
    function rcontains_from$0(s,i,c)
     {if(0 <= i && ! (caml_ml_string_length(s) <= i))
       try
        {rindex_rec$0(s,i,c);var _z4_=1;return _z4_}
       catch(_z5_)
        {_z5_ = caml_wrap_exception(_z5_);
         if(_z5_ === Not_found)return 0;
         throw _z5_}
      return invalid_arg(cst_String_rcontains_from_Byte$0)}
    function uppercase_ascii$1(s)
     {return caml_string_of_bytes(uppercase_ascii$0(caml_bytes_of_string(s)))}
    function lowercase_ascii$1(s)
     {return caml_string_of_bytes(lowercase_ascii$0(caml_bytes_of_string(s)))}
    function capitalize_ascii$0(s)
     {return caml_string_of_bytes(capitalize_ascii(caml_bytes_of_string(s)))}
    function uncapitalize_ascii$0(s)
     {return caml_string_of_bytes(uncapitalize_ascii(caml_bytes_of_string(s)))}
    function starts_with$0(prefix,s)
     {var
       len_s=caml_ml_string_length(s),
       len_pre=caml_ml_string_length(prefix),
       _z3_=len_pre <= len_s?1:0;
      if(_z3_)
       {var i=0;
        for(;;)
         {if(i === len_pre)return 1;
          if(caml_string_unsafe_get(s,i) !== caml_string_unsafe_get(prefix,i))
           return 0;
          var i$0=i + 1 | 0,i=i$0;
          continue}}
      return _z3_}
    function ends_with$0(suffix,s)
     {var
       len_s=caml_ml_string_length(s),
       len_suf=caml_ml_string_length(suffix),
       diff=len_s - len_suf | 0,
       _z2_=0 <= diff?1:0;
      if(_z2_)
       {var i=0;
        for(;;)
         {if(i === len_suf)return 1;
          if
           (caml_string_unsafe_get(s,diff + i | 0)
            !==
            caml_string_unsafe_get(suffix,i))
           return 0;
          var i$0=i + 1 | 0,i=i$0;
          continue}}
      return _z2_}
    function split_on_char$0(sep,s)
     {var
       r=[0,0],
       j=[0,caml_ml_string_length(s)],
       _zY_=caml_ml_string_length(s) - 1 | 0;
      if(! (_zY_ < 0))
       {var i=_zY_;
        for(;;)
         {if(caml_string_unsafe_get(s,i) === sep)
           {var _z0_=r[1];
            r[1] = [0,sub$0(s,i + 1 | 0,(j[1] - i | 0) - 1 | 0),_z0_];
            j[1] = i}
          var _z1_=i - 1 | 0;
          if(0 !== i){var i=_z1_;continue}
          break}}
      var _zZ_=r[1];
      return [0,sub$0(s,0,j[1]),_zZ_]}
    function uppercase$1(s)
     {return caml_string_of_bytes(uppercase$0(caml_bytes_of_string(s)))}
    function lowercase$1(s)
     {return caml_string_of_bytes(lowercase$0(caml_bytes_of_string(s)))}
    function capitalize$0(s)
     {return caml_string_of_bytes(capitalize(caml_bytes_of_string(s)))}
    function uncapitalize$0(s)
     {return caml_string_of_bytes(uncapitalize(caml_bytes_of_string(s)))}
    function compare$8(x,y){return caml_string_compare(x,y)}
    function to_seq$3(s){return to_seq$2(caml_bytes_of_string(s))}
    function to_seqi$0(s){return to_seqi(caml_bytes_of_string(s))}
    function of_seq$1(g){return caml_string_of_bytes(of_seq$0(g))}
    function get_int8$0(s,i){return get_int8(caml_bytes_of_string(s),i)}
    function get_uint16_le$0(s,i)
     {return caml_bytes_get16(caml_bytes_of_string(s),i)}
    function get_uint16_be$0(s,i)
     {return get_uint16_be(caml_bytes_of_string(s),i)}
    function get_int16_ne$0(s,i)
     {return get_int16_ne(caml_bytes_of_string(s),i)}
    function get_int16_le$0(s,i)
     {return get_int16_le(caml_bytes_of_string(s),i)}
    function get_int16_be$0(s,i)
     {return get_int16_be(caml_bytes_of_string(s),i)}
    function get_int32_le$0(s,i)
     {return caml_bytes_get32(caml_bytes_of_string(s),i)}
    function get_int32_be$0(s,i)
     {return get_int32_be(caml_bytes_of_string(s),i)}
    function get_int64_le$0(s,i)
     {return caml_bytes_get64(caml_bytes_of_string(s),i)}
    function get_int64_be$0(s,i)
     {return get_int64_be(caml_bytes_of_string(s),i)}
    var
     get_int64_ne$0=runtime.caml_string_get64,
     get_int32_ne$0=runtime.caml_string_get32,
     get_uint16_ne$0=runtime.caml_string_get16,
     get_uint8$0=caml_string_get,
     equal$8=caml_string_equal,
     include$2=
      [0,
       make$1,
       init$1,
       empty$1,
       of_bytes,
       to_bytes,
       concat$1,
       cat,
       equal$8,
       compare$8,
       starts_with$0,
       ends_with$0,
       contains_from$0,
       rcontains_from$0,
       contains$0,
       sub$0,
       split_on_char$0,
       map$5,
       mapi$1,
       fold_left$2,
       fold_right$1,
       for_all$1,
       exists$1,
       trim$0,
       escaped$1,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       iter$4,
       iteri$1,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       to_seq$3,
       to_seqi$0,
       of_seq$1,
       blit$0,
       copy$0,
       fill,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       get_uint8$0,
       get_int8$0,
       get_uint16_ne$0,
       get_uint16_be$0,
       get_uint16_le$0,
       get_int16_ne$0,
       get_int16_be$0,
       get_int16_le$0,
       get_int32_ne$0,
       get_int32_be$0,
       get_int32_le$0,
       get_int64_ne$0,
       get_int64_be$0,
       get_int64_le$0];
    caml_register_global(772,include$2,"Stdlib__String");
    function equal$9(param,_zX_){return 1}
    function compare$9(param,_zW_){return 0}
    function to_string$2(param){return cst$5}
    var Stdlib_Unit=[0,equal$9,compare$9,to_string$2];
    caml_register_global(773,Stdlib_Unit,"Stdlib__Unit");
    function to_buffer(buff,ofs,len,v,flags)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_bytes_length(buff) - len | 0) < ofs))
       return runtime.caml_output_value_to_buffer(buff,ofs,len,v,flags);
      return invalid_arg(cst_Marshal_to_buffer_substrin)}
    var header_size=20;
    function data_size(buff,ofs)
     {if(0 <= ofs && ! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
       return caml_marshal_data_size(buff,ofs);
      return invalid_arg(cst_Marshal_data_size)}
    function total_size(buff,ofs){return 20 + data_size(buff,ofs) | 0}
    function from_bytes(buff,ofs)
     {if(0 <= ofs && ! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
       {var len=caml_marshal_data_size(buff,ofs);
        return (caml_ml_bytes_length(buff) - (20 + len | 0) | 0) < ofs
                ?invalid_arg(cst_Marshal_from_bytes$0)
                :runtime.caml_input_value_from_bytes(buff,ofs)}
      return invalid_arg(cst_Marshal_from_bytes)}
    function from_string(buff,ofs)
     {return from_bytes(caml_bytes_of_string(buff),ofs)}
    var
     Stdlib_Marshal=
      [0,
       caml_output_value,
       to_buffer,
       caml_input_value,
       from_bytes,
       from_string,
       header_size,
       data_size,
       total_size];
    caml_register_global(774,Stdlib_Marshal,"Stdlib__Marshal");
    function is_block(a){return 1 - (typeof a === "number"?1:0)}
    function double_field(x,i){return caml_array_get(x,i)}
    function set_double_field(x,i,v){return caml_array_set(x,i,v)}
    function marshal(obj){return runtime.caml_output_value_to_bytes(obj,0)}
    function unmarshal(str,pos)
     {var _zV_=pos + total_size(str,pos) | 0;
      return [0,from_bytes(str,pos),_zV_]}
    var
     first_non_constant_constructor=0,
     last_non_constant_constructor_=245,
     lazy_tag=246,
     closure_tag=247,
     object_tag=248,
     infix_tag=249,
     forward_tag=250,
     no_scan_tag=251,
     abstract_tag=251,
     string_tag=252,
     double_tag=253,
     double_array_tag=254,
     custom_tag=255,
     int_tag=1000,
     out_of_heap_tag=1001,
     unaligned_tag=1002;
    function info(obj)
     {if(caml_obj_tag(obj) === 247)
       {var
         info=runtime.caml_obj_raw_field(obj,1),
         arity=info >> 24,
         start_env=info << 8 >>> 9 | 0;
        return [0,arity,start_env]}
      throw [0,Assert_failure,_q_]}
    function of_val(x)
     {var switch$0=0;
      if(is_block(x) && caml_obj_tag(x) !== 248 && 1 <= x.length - 1)
       {var slot=x[1];switch$0 = 1}
      if(! switch$0)var slot=x;
      var switch$1=0;
      if(is_block(slot) && caml_obj_tag(slot) === 248)
       {var name=slot[1];switch$1 = 1}
      if(! switch$1)var name=invalid_arg(cst_Obj_extension_constructor$0);
      return caml_obj_tag(name) === 252
              ?slot
              :invalid_arg(cst_Obj_extension_constructor)}
    function name(slot){return slot[1]}
    function id(slot){return slot[2]}
    var
     Extension_constructor=[0,of_val,name,id],
     extension_constructor=Extension_constructor[1],
     extension_name=Extension_constructor[2],
     extension_id=Extension_constructor[3],
     max_ephe_length=max_array_length - 2 | 0;
    function create(l)
     {var _zT_=0 <= l?1:0,_zU_=_zT_?l <= max_ephe_length?1:0:_zT_;
      if(1 - _zU_)invalid_arg(cst_Obj_Ephemeron_create);
      return runtime.caml_ephe_create(l)}
    function length$0(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset(e,o,msg)
     {var _zQ_=0 <= o?1:0,_zR_=_zQ_?o < length$0(e)?1:0:_zQ_,_zS_=1 - _zR_;
      return _zS_?invalid_arg(msg):_zS_}
    function get_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key);
      return runtime.caml_ephe_get_key(e,o)}
    function get_key_copy(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key_copy);
      return runtime.caml_ephe_get_key_copy(e,o)}
    function set_key(e,o,x)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_set_key);
      return caml_ephe_set_key(e,o,x)}
    function unset_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_unset_key);
      return caml_ephe_unset_key(e,o)}
    function check_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_check_key);
      return runtime.caml_ephe_check_key(e,o)}
    function blit_key(e1,o1,e2,o2,l)
     {if
       (0
        <=
        l
        &&
        0
        <=
        o1
        &&
        !
        ((length$0(e1) - l | 0) < o1)
        &&
        0
        <=
        o2
        &&
        !
        ((length$0(e2) - l | 0) < o2))
       {var
         _zO_=0 !== l?1:0,
         _zP_=_zO_?runtime.caml_ephe_blit_key(e1,o1,e2,o2,l):_zO_;
        return _zP_}
      return invalid_arg(cst_Obj_Ephemeron_blit_key)}
    var
     _r_=runtime.caml_ephe_blit_data,
     _s_=runtime.caml_ephe_check_data,
     _t_=
      [0,
       create,
       length$0,
       get_key,
       get_key_copy,
       set_key,
       unset_key,
       check_key,
       blit_key,
       runtime.caml_ephe_get_data,
       runtime.caml_ephe_get_data_copy,
       runtime.caml_ephe_set_data,
       function(_zN_){return runtime.caml_ephe_unset_data(_zN_)},
       _s_,
       _r_,
       max_ephe_length],
     Stdlib_Obj=
      [0,
       is_block,
       double_field,
       set_double_field,
       first_non_constant_constructor,
       last_non_constant_constructor_,
       lazy_tag,
       closure_tag,
       object_tag,
       infix_tag,
       forward_tag,
       no_scan_tag,
       abstract_tag,
       string_tag,
       double_tag,
       double_array_tag,
       custom_tag,
       custom_tag,
       int_tag,
       out_of_heap_tag,
       unaligned_tag,
       [0,info],
       Extension_constructor,
       extension_constructor,
       extension_name,
       extension_id,
       marshal,
       unmarshal,
       _t_];
    caml_register_global(775,Stdlib_Obj,"Stdlib__Obj");
    var make_float=runtime.caml_make_float_vect,Floatarray=[0];
    function init$2(l,f)
     {if(0 === l)return [0];
      if(0 <= l)
       {var res=caml_make_vect(l,caml_call1(f,0)),_zL_=l - 1 | 0,_zK_=1;
        if(! (_zL_ < 1))
         {var i=_zK_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _zM_=i + 1 | 0;
            if(_zL_ !== i){var i=_zM_;continue}
            break}}
        return res}
      return invalid_arg(cst_Array_init)}
    function create_matrix(sx,sy,init)
     {var res=caml_make_vect(sx,[0]),_zI_=sx - 1 | 0,_zH_=0;
      if(! (_zI_ < 0))
       {var x=_zH_;
        for(;;)
         {res[1 + x] = caml_make_vect(sy,init);
          var _zJ_=x + 1 | 0;
          if(_zI_ !== x){var x=_zJ_;continue}
          break}}
      return res}
    function copy$1(a)
     {var l=a.length - 1;return 0 === l?[0]:caml_array_sub(a,0,l)}
    function append$1(a1,a2)
     {var l1=a1.length - 1;
      return 0 === l1
              ?copy$1(a2)
              :0 === a2.length - 1
                ?caml_array_sub(a1,0,l1)
                :runtime.caml_array_append(a1,a2)}
    function sub$1(a,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return caml_array_sub(a,ofs,len);
      return invalid_arg(cst_Array_sub)}
    function fill$0(a,ofs,len,v)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return runtime.caml_array_fill(a,ofs,len,v);
      return invalid_arg(cst_Array_fill)}
    function blit$1(a1,ofs1,a2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((a1.length - 1 - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((a2.length - 1 - len | 0) < ofs2))
       return runtime.caml_array_blit(a1,ofs1,a2,ofs2,len);
      return invalid_arg(cst_Array_blit)}
    function iter$5(f,a)
     {var _zF_=a.length - 1 - 1 | 0,_zE_=0;
      if(! (_zF_ < 0))
       {var i=_zE_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _zG_=i + 1 | 0;
          if(_zF_ !== i){var i=_zG_;continue}
          break}}
      return 0}
    function iter2$0(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Array_iter2_arrays_must_ha);
      var _zC_=a.length - 1 - 1 | 0,_zB_=0;
      if(! (_zC_ < 0))
       {var i=_zB_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _zD_=i + 1 | 0;
          if(_zC_ !== i){var i=_zD_;continue}
          break}}
      return 0}
    function map$6(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_zz_=l - 1 | 0,_zy_=1;
      if(! (_zz_ < 1))
       {var i=_zy_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _zA_=i + 1 | 0;
          if(_zz_ !== i){var i=_zA_;continue}
          break}}
      return r}
    function map2$0(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)return invalid_arg(cst_Array_map2_arrays_must_hav);
      if(0 === la)return [0];
      var r=caml_make_vect(la,caml_call2(f,a[1],b[1])),_zw_=la - 1 | 0,_zv_=1;
      if(! (_zw_ < 1))
       {var i=_zv_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _zx_=i + 1 | 0;
          if(_zw_ !== i){var i=_zx_;continue}
          break}}
      return r}
    function iteri$2(f,a)
     {var _zt_=a.length - 1 - 1 | 0,_zs_=0;
      if(! (_zt_ < 0))
       {var i=_zs_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _zu_=i + 1 | 0;
          if(_zt_ !== i){var i=_zu_;continue}
          break}}
      return 0}
    function mapi$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call2(f,0,a[1])),_zq_=l - 1 | 0,_zp_=1;
      if(! (_zq_ < 1))
       {var i=_zp_;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _zr_=i + 1 | 0;
          if(_zq_ !== i){var i=_zr_;continue}
          break}}
      return r}
    function to_list$1(a)
     {var i$1=a.length - 1 - 1 | 0,i=i$1,res=0;
      for(;;)
       {if(0 <= i)
         {var res$0=[0,a[1 + i],res],i$0=i - 1 | 0,i=i$0,res=res$0;continue}
        return res}}
    function list_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[2],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function of_list(l)
     {if(l)
       {var
         tl=l[2],
         hd=l[1],
         a=caml_make_vect(list_length(0,l),hd),
         i=1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[1 + i] = hd$0;
            var i$0=i + 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    function fold_left$3(f,x,a)
     {var r=[0,x],_zn_=a.length - 1 - 1 | 0,_zm_=0;
      if(! (_zn_ < 0))
       {var i=_zm_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _zo_=i + 1 | 0;
          if(_zn_ !== i){var i=_zo_;continue}
          break}}
      return r[1]}
    function fold_left_map$0(f,acc,input_array)
     {var len=input_array.length - 1;
      if(0 === len)return [0,acc,[0]];
      var
       match=caml_call2(f,acc,input_array[1]),
       elt=match[2],
       acc$0=match[1],
       output_array=caml_make_vect(len,elt),
       acc$1=[0,acc$0],
       _zk_=len - 1 | 0,
       _zj_=1;
      if(! (_zk_ < 1))
       {var i=_zj_;
        for(;;)
         {var
           match$0=caml_call2(f,acc$1[1],input_array[1 + i]),
           elt$0=match$0[2],
           acc$2=match$0[1];
          acc$1[1] = acc$2;
          output_array[1 + i] = elt$0;
          var _zl_=i + 1 | 0;
          if(_zk_ !== i){var i=_zl_;continue}
          break}}
      return [0,acc$1[1],output_array]}
    function fold_right$2(f,a,x)
     {var r=[0,x],_zh_=a.length - 1 - 1 | 0;
      if(! (_zh_ < 0))
       {var i=_zh_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _zi_=i - 1 | 0;
          if(0 !== i){var i=_zi_;continue}
          break}}
      return r[1]}
    function exists$2(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$2(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function for_all2$0(p,l1,l2)
     {var n1=l1.length - 1,n2=l2.length - 1;
      if(n1 !== n2)return invalid_arg(cst_Array_for_all2);
      var i=0;
      for(;;)
       {if(i === n1)return 1;
        if(caml_call2(p,l1[1 + i],l2[1 + i]))
         {var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function exists2$0(p,l1,l2)
     {var n1=l1.length - 1,n2=l2.length - 1;
      if(n1 !== n2)return invalid_arg(cst_Array_exists2);
      var i=0;
      for(;;)
       {if(i === n1)return 0;
        if(caml_call2(p,l1[1 + i],l2[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function mem$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function memq$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x === a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function find_opt$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        var x=a[1 + i];
        if(caml_call1(p,x))return [0,x];
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function find_map$0(f,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        var r=caml_call1(f,a[1 + i]);
        if(r)return r;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function split$0(x)
     {if(caml_equal(x,[0]))return [0,[0],[0]];
      var
       match=x[1],
       b0=match[2],
       a0=match[1],
       n=x.length - 1,
       a=caml_make_vect(n,a0),
       b=caml_make_vect(n,b0),
       _zf_=n - 1 | 0,
       _ze_=1;
      if(! (_zf_ < 1))
       {var i=_ze_;
        for(;;)
         {var match$0=x[1 + i],bi=match$0[2],ai=match$0[1];
          a[1 + i] = ai;
          b[1 + i] = bi;
          var _zg_=i + 1 | 0;
          if(_zf_ !== i){var i=_zg_;continue}
          break}}
      return [0,a,b]}
    function combine$0(a,b)
     {var na=a.length - 1,nb=b.length - 1;
      if(na !== nb)invalid_arg(cst_Array_combine);
      if(0 === na)return [0];
      var x=caml_make_vect(na,[0,a[1],b[1]]),_zc_=na - 1 | 0,_zb_=1;
      if(! (_zc_ < 1))
       {var i=_zb_;
        for(;;)
         {x[1 + i] = [0,a[1 + i],b[1 + i]];
          var _zd_=i + 1 | 0;
          if(_zc_ !== i){var i=_zd_;continue}
          break}}
      return x}
    var Bottom=[248,cst_Stdlib_Array_Bottom,caml_fresh_oo_id(0)];
    function sort(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {var _y6_=i31 + 1 | 0,_y7_=caml_check_bound(a,_y6_)[1 + _y6_];
          if(caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_y7_) < 0)
           x[1] = i31 + 1 | 0;
          var
           _y8_=i31 + 2 | 0,
           _y9_=caml_check_bound(a,_y8_)[1 + _y8_],
           _y__=x[1];
          if(caml_call2(cmp,caml_check_bound(a,_y__)[1 + _y__],_y9_) < 0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if((i31 + 1 | 0) < l)
         {var _y$_=i31 + 1 | 0,_za_=caml_check_bound(a,_y$_)[1 + _y$_];
          if(! (0 <= caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_za_)))
           return i31 + 1 | 0}
        if(i31 < l)return i31;
        throw [0,Bottom,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_check_bound(a,j)[1 + j],e))
           {var _y5_=caml_check_bound(a,j)[1 + j];
            caml_check_bound(a,i$0)[1 + i$0] = _y5_;
            var i$0=j;
            continue}
          caml_check_bound(a,i$0)[1 + i$0] = e;
          return 0}}
      function trickle(l,i,e)
       {try
         {var _y4_=trickledown(l,i,e);return _y4_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom)
           {var i$0=exn[2];caml_check_bound(a,i$0)[1 + i$0] = e;return 0}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0),_y3_=caml_check_bound(a,i$1)[1 + i$1];
          caml_check_bound(a,i$0)[1 + i$0] = _y3_;
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _y2_=bubbledown(l,i);return _y2_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_yU_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_yU_ < 0))
       {var i$2=_yU_;
        for(;;)
         {trickle(l,i$2,caml_check_bound(a,i$2)[1 + i$2]);
          var _y1_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_y1_;continue}
          break}}
      var _yV_=l - 1 | 0;
      if(! (_yV_ < 2))
       {var i$0=_yV_;
        a:
        for(;;)
         {var
           e$0=caml_check_bound(a,i$0)[1 + i$0],
           _yZ_=caml_check_bound(a,0)[1];
          caml_check_bound(a,i$0)[1 + i$0] = _yZ_;
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_u_];
            if
             (0 <= caml_call2(cmp,caml_check_bound(a,father)[1 + father],e$0))
             caml_check_bound(a,i)[1 + i] = e$0;
            else
             {var _yT_=caml_check_bound(a,father)[1 + father];
              caml_check_bound(a,i)[1 + i] = _yT_;
              if(0 < father){var i=father;continue}
              caml_check_bound(a,0)[1] = e$0}
            var _y0_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_y0_;continue a}
            break}
          break}}
      var _yW_=1 < l?1:0;
      if(_yW_)
       {var e=caml_check_bound(a,1)[2],_yX_=caml_check_bound(a,0)[1];
        caml_check_bound(a,1)[2] = _yX_;
        caml_check_bound(a,0)[1] = e;
        var _yY_=0}
      else
       var _yY_=_yW_;
      return _yY_}
    function fast_sort$0(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_check_bound(src2,src2ofs)[1 + src2ofs],
         s1$1=caml_check_bound(a,src1ofs)[1 + src1ofs],
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_check_bound(dst,d)[1 + d] = s2;
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_check_bound(src2,i2$0)[1 + i2$0],
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$1(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_check_bound(dst,d)[1 + d] = s1;
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_check_bound(a,i1$0)[1 + i1$0],
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$1(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _yL_=len - 1 | 0,_yK_=0;
        if(! (_yL_ < 0))
         {var i=_yK_;
          a:
          for(;;)
           {var
             _yM_=srcofs + i | 0,
             e=caml_check_bound(a,_yM_)[1 + _yM_],
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if(dstofs <= j[1])
               {var _yN_=j[1];
                if(0 < caml_call2(cmp,caml_check_bound(dst,_yN_)[1 + _yN_],e))
                 {var
                   _yO_=j[1],
                   _yP_=caml_check_bound(dst,_yO_)[1 + _yO_],
                   _yQ_=j[1] + 1 | 0;
                  caml_check_bound(dst,_yQ_)[1 + _yQ_] = _yP_;
                  j[1] += -1;
                  continue}}
              var _yR_=j[1] + 1 | 0;
              caml_check_bound(dst,_yR_)[1 + _yR_] = e;
              var _yS_=i + 1 | 0;
              if(_yL_ !== i){var i=_yS_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var
       l1=l / 2 | 0,
       l2=l - l1 | 0,
       t=caml_make_vect(l2,caml_check_bound(a,0)[1]);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$4(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_yI_=i + 1 | 0;
          return [0,x,function(_yJ_){return aux(_yI_,_yJ_)}]}
        return 0}
      var _yG_=0;
      return function(_yH_){return aux(_yG_,_yH_)}}
    function to_seqi$1(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_yE_=i + 1 | 0;
          return [0,[0,i,x],function(_yF_){return aux(_yE_,_yF_)}]}
        return 0}
      var _yC_=0;
      return function(_yD_){return aux(_yC_,_yD_)}}
    function of_seq$2(i$2)
     {var _yB_=0,l=fold_left(function(acc,x){return [0,x,acc]},_yB_,i$2);
      if(l)
       {var
         tl=l[2],
         hd=l[1],
         len=list_length(0,l),
         a=caml_make_vect(len,hd),
         i$1=len - 2 | 0,
         i=i$1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[1 + i] = hd$0;
            var i$0=i - 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    var
     concat$2=caml_array_concat,
     include$3=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$1,
       concat$2,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       iteri$2,
       map$6,
       mapi$2,
       fold_left$3,
       fold_left_map$0,
       fold_right$2,
       iter2$0,
       map2$0,
       for_all$2,
       exists$2,
       for_all2$0,
       exists2$0,
       mem$0,
       memq$0,
       find_opt$0,
       find_map$0,
       split$0,
       combine$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(776,include$3,"Stdlib__Array");
    var zero$0=0.,one$0=1.,minus_one$0=-1.;
    function is_finite(x){return x - x == 0.?1:0}
    function is_infinite(x){return 1. / x == 0.?1:0}
    function is_nan(x){return x != x?1:0}
    var pi=3.14159265358979312;
    function is_integer(x)
     {var _yA_=x == runtime.caml_trunc_float(x)?1:0;
      return _yA_?is_finite(x):_yA_}
    function succ$0(x){return caml_nextafter_float(x,infinity)}
    function pred$0(x){return caml_nextafter_float(x,neg_infinity)}
    function equal$10(x,y){return 0 === caml_float_compare(x,y)?1:0}
    function min$2(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return x != x?x:y}
      return y != y?y:x}
    function max$2(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return y != y?y:x}
      return x != x?x:y}
    function min_max(x,y)
     {if(x == x && y == y)
       {if(! (x < y))
         {var switch$0=0;
          if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
          if(switch$0)return [0,y,x]}
        return [0,x,y]}
      return [0,nan,nan]}
    function min_num(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return y != y?x:y}
      return x != x?y:x}
    function max_num(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return x != x?y:x}
      return y != y?x:y}
    function min_max_num(x,y)
     {if(x != x)return [0,y,y];
      if(y != y)return [0,x,x];
      if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return [0,y,x]}
      return [0,x,y]}
    function hash$0(x){return caml_hash(10,100,0,x)}
    function unsafe_fill(a,ofs,len,v)
     {var _yy_=(ofs + len | 0) - 1 | 0;
      if(! (_yy_ < ofs))
       {var i=ofs;
        for(;;)
         {a[1 + i] = v;
          var _yz_=i + 1 | 0;
          if(_yy_ !== i){var i=_yz_;continue}
          break}}
      return 0}
    function check(a,ofs,len,msg)
     {var _yu_=ofs < 0?1:0;
      if(_yu_)
       var _yv_=_yu_;
      else
       {var _yw_=len < 0?1:0;
        if(_yw_)
         var _yv_=_yw_;
        else
         var
          _yx_=(ofs + len | 0) < 0?1:0,
          _yv_=_yx_ || (a.length - 1 < (ofs + len | 0)?1:0)}
      return _yv_?invalid_arg(msg):_yv_}
    function make$2(n,v)
     {var result=caml_floatarray_create(n);
      unsafe_fill(result,0,n,v);
      return result}
    function init$3(l,f)
     {if(0 <= l)
       {var res=caml_floatarray_create(l),_ys_=l - 1 | 0,_yr_=0;
        if(! (_ys_ < 0))
         {var i=_yr_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _yt_=i + 1 | 0;
            if(_ys_ !== i){var i=_yt_;continue}
            break}}
        return res}
      return invalid_arg(cst_Float_Array_init)}
    function append$2(a1,a2)
     {var
       l1=a1.length - 1,
       l2=a2.length - 1,
       result=caml_floatarray_create(l1 + l2 | 0);
      caml_floatarray_blit(a1,0,result,0,l1);
      caml_floatarray_blit(a2,0,result,l1,l2);
      return result}
    function concat$3(l)
     {var acc=0,param=l;
      for(;;)
       {if(param)
         {var
           tl=param[2],
           hd=param[1],
           x=hd.length - 1 + acc | 0,
           acc$0=acc <= x?x:invalid_arg(cst_Float_Array_concat),
           acc=acc$0,
           param=tl;
          continue}
        var result=caml_floatarray_create(acc),l$0=l,i=0;
        for(;;)
         {if(l$0)
           {var tl$0=l$0[2],hd$0=l$0[1],hlen=hd$0.length - 1;
            caml_floatarray_blit(hd$0,0,result,i,hlen);
            var i$0=i + hlen | 0,l$0=tl$0,i=i$0;
            continue}
          if(i === acc)return result;
          throw [0,Assert_failure,_v_]}}}
    function sub$2(a,ofs,len)
     {check(a,ofs,len,cst_Float_Array_sub);
      var result=caml_floatarray_create(len);
      caml_floatarray_blit(a,ofs,result,0,len);
      return result}
    function copy$2(a)
     {var l=a.length - 1,result=caml_floatarray_create(l);
      caml_floatarray_blit(a,0,result,0,l);
      return result}
    function fill$1(a,ofs,len,v)
     {check(a,ofs,len,cst_Float_Array_fill);return unsafe_fill(a,ofs,len,v)}
    function blit$2(src,sofs,dst,dofs,len)
     {check(src,sofs,len,cst_Float_array_blit);
      check(dst,dofs,len,cst_Float_array_blit$0);
      return caml_floatarray_blit(src,sofs,dst,dofs,len)}
    function to_list$2(a)
     {return init(a.length - 1,function(_yq_){return a[1 + _yq_]})}
    function of_list$0(l)
     {var result=caml_floatarray_create(length(l)),i=0,l$0=l;
      for(;;)
       {if(l$0)
         {var t=l$0[2],h=l$0[1];
          result[1 + i] = h;
          var i$0=i + 1 | 0,i=i$0,l$0=t;
          continue}
        return result}}
    function iter$6(f,a)
     {var _yo_=a.length - 1 - 1 | 0,_yn_=0;
      if(! (_yo_ < 0))
       {var i=_yn_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _yp_=i + 1 | 0;
          if(_yo_ !== i){var i=_yp_;continue}
          break}}
      return 0}
    function iter2$1(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Float_Array_iter2_arrays_m);
      var _yl_=a.length - 1 - 1 | 0,_yk_=0;
      if(! (_yl_ < 0))
       {var i=_yk_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _ym_=i + 1 | 0;
          if(_yl_ !== i){var i=_ym_;continue}
          break}}
      return 0}
    function map$7(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_yi_=l - 1 | 0,_yh_=0;
      if(! (_yi_ < 0))
       {var i=_yh_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _yj_=i + 1 | 0;
          if(_yi_ !== i){var i=_yj_;continue}
          break}}
      return r}
    function map2$1(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)return invalid_arg(cst_Float_Array_map2_arrays_mu);
      var r=caml_floatarray_create(la),_yf_=la - 1 | 0,_ye_=0;
      if(! (_yf_ < 0))
       {var i=_ye_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _yg_=i + 1 | 0;
          if(_yf_ !== i){var i=_yg_;continue}
          break}}
      return r}
    function iteri$3(f,a)
     {var _yc_=a.length - 1 - 1 | 0,_yb_=0;
      if(! (_yc_ < 0))
       {var i=_yb_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _yd_=i + 1 | 0;
          if(_yc_ !== i){var i=_yd_;continue}
          break}}
      return 0}
    function mapi$3(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_x$_=l - 1 | 0,_x__=0;
      if(! (_x$_ < 0))
       {var i=_x__;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _ya_=i + 1 | 0;
          if(_x$_ !== i){var i=_ya_;continue}
          break}}
      return r}
    function fold_left$4(f,x,a)
     {var r=[0,x],_x8_=a.length - 1 - 1 | 0,_x7_=0;
      if(! (_x8_ < 0))
       {var i=_x7_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _x9_=i + 1 | 0;
          if(_x8_ !== i){var i=_x9_;continue}
          break}}
      return r[1]}
    function fold_right$3(f,a,x)
     {var r=[0,x],_x5_=a.length - 1 - 1 | 0;
      if(! (_x5_ < 0))
       {var i=_x5_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _x6_=i - 1 | 0;
          if(0 !== i){var i=_x6_;continue}
          break}}
      return r[1]}
    function exists$3(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$3(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function mem$1(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_float_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function mem_ieee(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x == a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom$0=[248,cst_Stdlib_Float_Array_Bottom,caml_fresh_oo_id(0)];
    function sort$0(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {if
           (caml_call2
             (cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))
            <
            0)
           x[1] = i31 + 1 | 0;
          if
           (caml_call2
             (cmp,caml_array_get(a,x[1]),caml_array_get(a,i31 + 2 | 0))
            <
            0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if
         ((i31 + 1 | 0)
          <
          l
          &&
          !
          (0
           <=
           caml_call2(cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))))
         return i31 + 1 | 0;
        if(i31 < l)return i31;
        throw [0,Bottom$0,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_array_get(a,j),e))
           {caml_array_set(a,i$0,caml_array_get(a,j));var i$0=j;continue}
          return caml_array_set(a,i$0,e)}}
      function trickle(l,i,e)
       {try
         {var _x4_=trickledown(l,i,e);return _x4_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0)
           {var i$0=exn[2];return caml_array_set(a,i$0,e)}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0);
          caml_array_set(a,i$0,caml_array_get(a,i$1));
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _x3_=bubbledown(l,i);return _x3_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_xX_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_xX_ < 0))
       {var i$2=_xX_;
        for(;;)
         {trickle(l,i$2,caml_array_get(a,i$2));
          var _x2_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_x2_;continue}
          break}}
      var _xY_=l - 1 | 0;
      if(! (_xY_ < 2))
       {var i$0=_xY_;
        a:
        for(;;)
         {var e$0=caml_array_get(a,i$0);
          caml_array_set(a,i$0,caml_array_get(a,0));
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_w_];
            if(0 <= caml_call2(cmp,caml_array_get(a,father),e$0))
             caml_array_set(a,i,e$0);
            else
             {caml_array_set(a,i,caml_array_get(a,father));
              if(0 < father){var i=father;continue}
              caml_array_set(a,0,e$0)}
            var _x1_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_x1_;continue a}
            break}
          break}}
      var _xZ_=1 < l?1:0;
      if(_xZ_)
       {var e=caml_array_get(a,1);
        caml_array_set(a,1,caml_array_get(a,0));
        var _x0_=caml_array_set(a,0,e)}
      else
       var _x0_=_xZ_;
      return _x0_}
    function stable_sort(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_array_get(src2,src2ofs),
         s1$1=caml_array_get(a,src1ofs),
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_array_set(dst,d,s2);
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_array_get(src2,i2$0),
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$2(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_array_set(dst,d,s1);
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_array_get(a,i1$0),
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$2(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _xV_=len - 1 | 0,_xU_=0;
        if(! (_xV_ < 0))
         {var i=_xU_;
          a:
          for(;;)
           {var
             e=caml_array_get(a,srcofs + i | 0),
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if
               (dstofs
                <=
                j[1]
                &&
                0
                <
                caml_call2(cmp,caml_array_get(dst,j[1]),e))
               {caml_array_set(dst,j[1] + 1 | 0,caml_array_get(dst,j[1]));
                j[1] += -1;
                continue}
              caml_array_set(dst,j[1] + 1 | 0,e);
              var _xW_=i + 1 | 0;
              if(_xV_ !== i){var i=_xW_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var l1=l / 2 | 0,l2=l - l1 | 0,t=caml_floatarray_create(l2);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$5(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_xS_=i + 1 | 0;
          return [0,x,function(_xT_){return aux(_xS_,_xT_)}]}
        return 0}
      var _xQ_=0;
      return function(_xR_){return aux(_xQ_,_xR_)}}
    function to_seqi$2(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_xO_=i + 1 | 0;
          return [0,[0,i,x],function(_xP_){return aux(_xO_,_xP_)}]}
        return 0}
      var _xM_=0;
      return function(_xN_){return aux(_xM_,_xN_)}}
    function of_seq$3(i$2)
     {var
       _xL_=0,
       param$0=fold_left(function(acc,x){return [0,x,acc]},_xL_,i$2),
       len=length(param$0),
       a=caml_floatarray_create(len),
       i$1=len - 1 | 0,
       i=i$1,
       param=param$0;
      for(;;)
       {if(param)
         {var tl=param[2],hd=param[1];
          a[1 + i] = hd;
          var i$0=i - 1 | 0,i=i$0,param=tl;
          continue}
        return a}}
    function map_to_array(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_xJ_=l - 1 | 0,_xI_=1;
      if(! (_xJ_ < 1))
       {var i=_xI_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _xK_=i + 1 | 0;
          if(_xJ_ !== i){var i=_xK_;continue}
          break}}
      return r}
    function map_from_array(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_xG_=l - 1 | 0,_xF_=0;
      if(! (_xG_ < 0))
       {var i=_xF_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _xH_=i + 1 | 0;
          if(_xG_ !== i){var i=_xH_;continue}
          break}}
      return r}
    var
     _x_=caml_floatarray_create,
     _y_=caml_array_set,
     _z_=caml_array_get,
     _A_=
      [0,
       function(_xE_){return _xE_.length - 1},
       _z_,
       _y_,
       make$2,
       _x_,
       init$3,
       append$2,
       concat$3,
       sub$2,
       copy$2,
       fill$1,
       blit$2,
       to_list$2,
       of_list$0,
       iter$6,
       iteri$3,
       map$7,
       mapi$3,
       fold_left$4,
       fold_right$3,
       iter2$1,
       map2$1,
       for_all$3,
       exists$3,
       mem$1,
       mem_ieee,
       sort$0,
       stable_sort,
       stable_sort,
       to_seq$5,
       to_seqi$2,
       of_seq$3,
       map_to_array,
       map_from_array],
     _B_=caml_floatarray_create,
     _C_=caml_array_set,
     _D_=caml_array_get,
     Stdlib_Float=
      [0,
       zero$0,
       one$0,
       minus_one$0,
       succ$0,
       pred$0,
       infinity,
       neg_infinity,
       nan,
       pi,
       max_float,
       min_float,
       epsilon,
       is_finite,
       is_infinite,
       is_nan,
       is_integer,
       of_string_opt,
       to_string,
       caml_float_compare,
       equal$10,
       min$2,
       max$2,
       min_max,
       min_num,
       max_num,
       min_max_num,
       hash$0,
       [0,
        function(_xD_){return _xD_.length - 1},
        _D_,
        _C_,
        make$2,
        _B_,
        init$3,
        append$2,
        concat$3,
        sub$2,
        copy$2,
        fill$1,
        blit$2,
        to_list$2,
        of_list$0,
        iter$6,
        iteri$3,
        map$7,
        mapi$3,
        fold_left$4,
        fold_right$3,
        iter2$1,
        map2$1,
        for_all$3,
        exists$3,
        mem$1,
        mem_ieee,
        sort$0,
        stable_sort,
        stable_sort,
        to_seq$5,
        to_seqi$2,
        of_seq$3,
        map_to_array,
        map_from_array],
       _A_];
    caml_register_global(777,Stdlib_Float,"Stdlib__Float");
    var zero$1=0,one$1=1,minus_one$1=-1;
    function succ$1(n){return n + 1 | 0}
    function pred$1(n){return n - 1 | 0}
    function abs$1(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$1=-2147483648,max_int$1=2147483647;
    function lognot$0(n){return n ^ -1}
    function unsigned_to_int(n)
     {if
       (!
        (0 < caml_int_compare(0,n))
        &&
        !
        (0 < caml_int_compare(n,2147483647)))
       return [0,n];
      return 0}
    function to_string$3(n){return caml_format_int(cst_d,n)}
    function of_string_opt$0(s)
     {try
       {var _xB_=[0,caml_int_of_string(s)];return _xB_}
      catch(_xC_)
       {_xC_ = caml_wrap_exception(_xC_);
        if(_xC_[1] === Failure)return 0;
        throw _xC_}}
    function compare$10(x,y){return caml_int_compare(x,y)}
    function equal$11(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function min$3(x,y){return caml_lessequal(x,y)?x:y}
    function max$3(x,y){return caml_greaterequal(x,y)?x:y}
    function unsigned_div(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare(n,d)?one$1:zero$1;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare(r,d)?q + 1 | 0:q}
    function unsigned_rem(n,d){return n - caml_mul(unsigned_div(n,d),d) | 0}
    var
     Stdlib_Int32=
      [0,
       zero$1,
       one$1,
       minus_one$1,
       unsigned_div,
       unsigned_rem,
       succ$1,
       pred$1,
       abs$1,
       max_int$1,
       min_int$1,
       lognot$0,
       unsigned_to_int,
       of_string_opt$0,
       to_string$3,
       compare$10,
       unsigned_compare,
       equal$11,
       min$3,
       max$3];
    caml_register_global(778,Stdlib_Int32,"Stdlib__Int32");
    function succ$2(n){return caml_int64_add(n,_E_)}
    function pred$2(n){return caml_int64_sub(n,_F_)}
    function abs$2(n)
     {return caml_greaterequal(n,_G_)?n:runtime.caml_int64_neg(n)}
    function lognot$1(n){return runtime.caml_int64_xor(n,_H_)}
    var max_int$3=caml_int64_of_int32(2147483647);
    function unsigned_to_int$0(n)
     {if
       (!
        (0 < caml_int64_compare(zero$2,n))
        &&
        !
        (0 < caml_int64_compare(n,max_int$3)))
       return [0,runtime.caml_int64_to_int32(n)];
      return 0}
    function to_string$4(n){return caml_int64_format(cst_d$0,n)}
    function of_string_opt$1(s)
     {try
       {var _xz_=[0,caml_int64_of_string(s)];return _xz_}
      catch(_xA_)
       {_xA_ = caml_wrap_exception(_xA_);
        if(_xA_[1] === Failure)return 0;
        throw _xA_}}
    function compare$11(x,y){return caml_int64_compare(x,y)}
    function equal$12(x,y){return 0 === caml_int64_compare(x,y)?1:0}
    function unsigned_compare$0(n,m)
     {return caml_int64_compare
              (caml_int64_sub(n,min_int$2),caml_int64_sub(m,min_int$2))}
    function min$4(x,y){return caml_lessequal(x,y)?x:y}
    function max$4(x,y){return caml_greaterequal(x,y)?x:y}
    function unsigned_div$0(n,d)
     {if(caml_lessthan(d,zero$2))
       return 0 <= unsigned_compare$0(n,d)?one$2:zero$2;
      var
       q=
        caml_int64_shift_left
         (runtime.caml_int64_div
           (runtime.caml_int64_shift_right_unsigned(n,1),d),
          1),
       r=caml_int64_sub(n,caml_int64_mul(q,d));
      return 0 <= unsigned_compare$0(r,d)?succ$2(q):q}
    function unsigned_rem$0(n,d)
     {return caml_int64_sub(n,caml_int64_mul(unsigned_div$0(n,d),d))}
    var
     Stdlib_Int64=
      [0,
       zero$2,
       one$2,
       minus_one$2,
       unsigned_div$0,
       unsigned_rem$0,
       succ$2,
       pred$2,
       abs$2,
       max_int$2,
       min_int$2,
       lognot$1,
       unsigned_to_int$0,
       of_string_opt$1,
       to_string$4,
       compare$11,
       unsigned_compare$0,
       equal$12,
       min$4,
       max$4];
    caml_register_global(779,Stdlib_Int64,"Stdlib__Int64");
    var zero$3=0,one$3=1,minus_one$3=-1;
    function succ$3(n){return n + 1 | 0}
    function pred$3(n){return n - 1 | 0}
    function abs$3(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$3=-2147483648,max_int$4=2147483647;
    function lognot$2(n){return n ^ -1}
    function unsigned_to_int$1(n)
     {if
       (!
        (0 < caml_int_compare(0,n))
        &&
        !
        (0 < caml_int_compare(n,2147483647)))
       return [0,n];
      return 0}
    function to_string$5(n){return caml_format_int(cst_d$1,n)}
    function of_string_opt$2(s)
     {try
       {var _xx_=[0,caml_int_of_string(s)];return _xx_}
      catch(_xy_)
       {_xy_ = caml_wrap_exception(_xy_);
        if(_xy_[1] === Failure)return 0;
        throw _xy_}}
    function compare$12(x,y){return caml_int_compare(x,y)}
    function equal$13(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare$1(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function min$5(x,y){return caml_lessequal(x,y)?x:y}
    function max$5(x,y){return caml_greaterequal(x,y)?x:y}
    function unsigned_div$1(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare$1(n,d)?one$3:zero$3;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare$1(r,d)?q + 1 | 0:q}
    function unsigned_rem$1(n,d)
     {return n - caml_mul(unsigned_div$1(n,d),d) | 0}
    var
     Stdlib_Nativeint=
      [0,
       zero$3,
       one$3,
       minus_one$3,
       unsigned_div$1,
       unsigned_rem$1,
       succ$3,
       pred$3,
       abs$3,
       match$1,
       max_int$4,
       min_int$3,
       lognot$2,
       unsigned_to_int$1,
       of_string_opt$2,
       to_string$5,
       compare$12,
       unsigned_compare$1,
       equal$13,
       min$5,
       max$5];
    caml_register_global(780,Stdlib_Nativeint,"Stdlib__Nativeint");
    function engine(tbl,state,buf)
     {var
       result=runtime.caml_lex_engine(tbl,state,buf),
       _xu_=0 <= result?1:0,
       _xv_=_xu_?buf[12] !== dummy_pos?1:0:_xu_;
      if(_xv_)
       {buf[11] = buf[12];
        var _xw_=buf[12];
        buf[12] = [0,_xw_[1],_xw_[2],_xw_[3],buf[4] + buf[6] | 0]}
      return result}
    function new_engine(tbl,state,buf)
     {var
       result=runtime.caml_new_lex_engine(tbl,state,buf),
       _xr_=0 <= result?1:0,
       _xs_=_xr_?buf[12] !== dummy_pos?1:0:_xr_;
      if(_xs_)
       {buf[11] = buf[12];
        var _xt_=buf[12];
        buf[12] = [0,_xt_[1],_xt_[2],_xt_[3],buf[4] + buf[6] | 0]}
      return result}
    function from_function(opt,f)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _xd_=with_positions?zero_pos:dummy_pos,
       _xe_=with_positions?zero_pos:dummy_pos,
       aux_buffer=caml_create_bytes(512),
       _xf_=[0],
       _xg_=0,
       _xh_=0,
       _xi_=0,
       _xj_=0,
       _xk_=0,
       _xl_=0,
       _xm_=0,
       _xn_=caml_create_bytes(1024);
      return [0,
              function(lexbuf)
               {var
                 read=
                  caml_call2(f,aux_buffer,caml_ml_bytes_length(aux_buffer)),
                 n=0 < read?read:(lexbuf[9] = 1,0);
                if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0))
                 {if
                   (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                    <=
                    caml_ml_bytes_length(lexbuf[2]))
                   blit
                    (lexbuf[2],lexbuf[5],lexbuf[2],0,lexbuf[3] - lexbuf[5] | 0);
                  else
                   {var
                     newlen=
                      min$1
                       (2 * caml_ml_bytes_length(lexbuf[2]) | 0,max_string_length);
                    if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                     failwith(cst_Lexing_lex_refill_cannot_g);
                    var newbuf=caml_create_bytes(newlen);
                    blit(lexbuf[2],lexbuf[5],newbuf,0,lexbuf[3] - lexbuf[5] | 0);
                    lexbuf[2] = newbuf}
                  var s=lexbuf[5];
                  lexbuf[4] = lexbuf[4] + s | 0;
                  lexbuf[6] = lexbuf[6] - s | 0;
                  lexbuf[5] = 0;
                  lexbuf[7] = lexbuf[7] - s | 0;
                  lexbuf[3] = lexbuf[3] - s | 0;
                  var t=lexbuf[10],_xp_=t.length - 1 - 1 | 0,_xo_=0;
                  if(! (_xp_ < 0))
                   {var i=_xo_;
                    for(;;)
                     {var v=caml_check_bound(t,i)[1 + i];
                      if(0 <= v)caml_check_bound(t,i)[1 + i] = v - s | 0;
                      var _xq_=i + 1 | 0;
                      if(_xp_ !== i){var i=_xq_;continue}
                      break}}}
                blit(aux_buffer,0,lexbuf[2],lexbuf[3],n);
                lexbuf[3] = lexbuf[3] + n | 0;
                return 0},
              _xn_,
              _xm_,
              _xl_,
              _xk_,
              _xj_,
              _xi_,
              _xh_,
              _xg_,
              _xf_,
              _xe_,
              _xd_]}
    function from_channel(with_positions,ic)
     {return from_function
              (with_positions,function(buf,n){return input(ic,buf,0,n)})}
    function from_string$0(opt,s)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _w4_=with_positions?zero_pos:dummy_pos,
       _w5_=with_positions?zero_pos:dummy_pos,
       _w6_=[0],
       _w7_=1,
       _w8_=0,
       _w9_=0,
       _w__=0,
       _w$_=0,
       _xa_=0,
       _xb_=caml_ml_string_length(s),
       _xc_=to_bytes(s);
      return [0,
              function(lexbuf){lexbuf[9] = 1;return 0},
              _xc_,
              _xb_,
              _xa_,
              _w$_,
              _w__,
              _w9_,
              _w8_,
              _w7_,
              _w6_,
              _w5_,
              _w4_]}
    function set_position(lexbuf,position)
     {lexbuf[12] = [0,lexbuf[12][1],position[2],position[3],position[4]];
      lexbuf[4] = position[4];
      return 0}
    function set_filename(lexbuf,fname)
     {var _w3_=lexbuf[12];
      lexbuf[12] = [0,fname,_w3_[2],_w3_[3],_w3_[4]];
      return 0}
    function with_positions(lexbuf){return lexbuf[12] !== dummy_pos?1:0}
    function lexeme(lexbuf)
     {var len=lexbuf[6] - lexbuf[5] | 0;
      return sub_string(lexbuf[2],lexbuf[5],len)}
    function sub_lexeme(lexbuf,i1,i2)
     {var len=i2 - i1 | 0;return sub_string(lexbuf[2],i1,len)}
    function sub_lexeme_opt(lexbuf,i1,i2)
     {if(0 <= i1){var len=i2 - i1 | 0;return [0,sub_string(lexbuf[2],i1,len)]}
      return 0}
    function sub_lexeme_char(lexbuf,i){return caml_bytes_get(lexbuf[2],i)}
    function sub_lexeme_char_opt(lexbuf,i)
     {return 0 <= i?[0,caml_bytes_get(lexbuf[2],i)]:0}
    function lexeme_char(lexbuf,i)
     {return caml_bytes_get(lexbuf[2],lexbuf[5] + i | 0)}
    function lexeme_start(lexbuf){return lexbuf[11][4]}
    function lexeme_end(lexbuf){return lexbuf[12][4]}
    function lexeme_start_p(lexbuf){return lexbuf[11]}
    function lexeme_end_p(lexbuf){return lexbuf[12]}
    function new_line(lexbuf)
     {var
       lcp=lexbuf[12],
       _w1_=lcp !== dummy_pos?1:0,
       _w2_=_w1_?(lexbuf[12] = [0,lcp[1],lcp[2] + 1 | 0,lcp[4],lcp[4]],0):_w1_;
      return _w2_}
    function flush_input(lb)
     {lb[6] = 0;
      lb[4] = 0;
      var lcp=lb[12];
      if(lcp !== dummy_pos)
       lb[12] = [0,lcp[1],zero_pos[2],zero_pos[3],zero_pos[4]];
      lb[3] = 0;
      return 0}
    var
     Stdlib_Lexing=
      [0,
       dummy_pos,
       from_channel,
       from_string$0,
       from_function,
       set_position,
       set_filename,
       with_positions,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
    caml_register_global(781,Stdlib_Lexing,"Stdlib__Lexing");
    var
     YYexit=[248,cst_Stdlib_Parsing_YYexit,caml_fresh_oo_id(0)],
     Parse_error=[248,cst_Stdlib_Parsing_Parse_error,caml_fresh_oo_id(0)],
     env=
      [0,
       caml_make_vect(100,0),
       caml_make_vect(100,0),
       caml_make_vect(100,dummy_pos),
       caml_make_vect(100,dummy_pos),
       100,
       0,
       0,
       0,
       dummy_pos,
       dummy_pos,
       0,
       0,
       0,
       0,
       0,
       0];
    function grow_stacks(param)
     {var
       oldsize=env[5],
       newsize=oldsize * 2 | 0,
       new_s=caml_make_vect(newsize,0),
       new_v=caml_make_vect(newsize,0),
       new_start=caml_make_vect(newsize,dummy_pos),
       new_end=caml_make_vect(newsize,dummy_pos);
      blit$1(env[1],0,new_s,0,oldsize);
      env[1] = new_s;
      blit$1(env[2],0,new_v,0,oldsize);
      env[2] = new_v;
      blit$1(env[3],0,new_start,0,oldsize);
      env[3] = new_start;
      blit$1(env[4],0,new_end,0,oldsize);
      env[4] = new_end;
      env[5] = newsize;
      return 0}
    function clear_parser(param)
     {fill$0(env[2],0,env[5],0);env[8] = 0;return 0}
    var current_lookahead_fun=[0,function(param){return 0}];
    function yyparse(tables,start,lexer,lexbuf)
     {var
       init_asp=env[11],
       init_sp=env[14],
       init_stackbase=env[6],
       init_state=env[15],
       init_curr_char=env[7],
       init_lval=env[8],
       init_errflag=env[16];
      env[6] = env[14] + 1 | 0;
      env[7] = start;
      env[10] = lexbuf[12];
      try
       {var cmd=0,arg=0;
        for(;;)
         {var match=runtime.caml_parse_engine(tables,env,cmd,arg);
          switch(match)
           {case 0:
             var arg$0=caml_call1(lexer,lexbuf);
             env[9] = lexbuf[11];
             env[10] = lexbuf[12];
             var cmd=1,arg=arg$0;
             continue;
            case 1:throw Parse_error;
            case 2:grow_stacks(0);var cmd=2,arg=0;continue;
            case 3:grow_stacks(0);var cmd=3,arg=0;continue;
            case 4:
             try
              {var
                _wV_=env[13],
                _wW_=
                 caml_call1(caml_check_bound(tables[1],_wV_)[1 + _wV_],env),
                _wX_=4,
                arg$1=_wW_,
                cmd$0=_wX_}
             catch(_w0_)
              {_w0_ = caml_wrap_exception(_w0_);
               if(_w0_ !== Parse_error)throw _w0_;
               var arg$1=0,cmd$0=5,_wY_=_w0_}
             var cmd=cmd$0,arg=arg$1;
             continue;
            default:
             caml_call1(tables[14],cst_syntax_error);var cmd=5,arg=0;continue}}}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var curr_char=env[7];
        env[11] = init_asp;
        env[14] = init_sp;
        env[6] = init_stackbase;
        env[15] = init_state;
        env[7] = init_curr_char;
        env[8] = init_lval;
        env[16] = init_errflag;
        if(exn[1] === YYexit){var v=exn[2];return v}
        current_lookahead_fun[1]
        =
        function(tok)
         {if(is_block(tok))
           {var _wZ_=caml_obj_tag(tok);
            return caml_check_bound(tables[3],_wZ_)[1 + _wZ_] === curr_char
                    ?1
                    :0}
          return caml_check_bound(tables[2],tok)[1 + tok] === curr_char?1:0};
        throw exn}}
    function peek_val(env,n)
     {var _wU_=env[11] - n | 0;return caml_check_bound(env[2],_wU_)[1 + _wU_]}
    function symbol_start_pos(param)
     {var i=env[12];
      for(;;)
       {if(0 < i)
         {var
           _wR_=(env[11] - i | 0) + 1 | 0,
           st=caml_check_bound(env[3],_wR_)[1 + _wR_],
           _wS_=(env[11] - i | 0) + 1 | 0,
           en=caml_check_bound(env[4],_wS_)[1 + _wS_];
          if(caml_notequal(st,en))return st;
          var i$0=i - 1 | 0,i=i$0;
          continue}
        var _wT_=env[11];
        return caml_check_bound(env[4],_wT_)[1 + _wT_]}}
    function symbol_end_pos(param)
     {var _wQ_=env[11];return caml_check_bound(env[4],_wQ_)[1 + _wQ_]}
    function rhs_start_pos(n)
     {var _wP_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[3],_wP_)[1 + _wP_]}
    function rhs_end_pos(n)
     {var _wO_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[4],_wO_)[1 + _wO_]}
    function symbol_start(param){return symbol_start_pos(0)[4]}
    function symbol_end(param){return symbol_end_pos(0)[4]}
    function rhs_start(n){return rhs_start_pos(n)[4]}
    function rhs_end(n){return rhs_end_pos(n)[4]}
    function is_current_lookahead(tok)
     {return caml_call1(current_lookahead_fun[1],tok)}
    function parse_error(param){return 0}
    var
     Stdlib_Parsing=
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       function(_wN_){return runtime.caml_set_parser_trace(_wN_)},
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
    caml_register_global(782,Stdlib_Parsing,"Stdlib__Parsing");
    var
     Stdlib_Set=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[4];return h}return 0}
         function create(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           var _wM_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_wM_]}
         function bal(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[3],lv=l[2],ll=l[1],_wH_=height(lr);
               if(_wH_ <= height(ll))return create(ll,lv,create(lr,v,r));
               if(lr)
                {var lrr=lr[3],lrv=lr[2],lrl=lr[1],_wI_=create(lrr,v,r);
                 return create(create(ll,lv,lrl),lrv,_wI_)}
               return invalid_arg(cst_Set_bal)}
             return invalid_arg(cst_Set_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[3],rv=r[2],rl=r[1],_wJ_=height(rl);
               if(_wJ_ <= height(rr))return create(create(l,v,rl),rv,rr);
               if(rl)
                {var rlr=rl[3],rlv=rl[2],rll=rl[1],_wK_=create(rlr,rv,rr);
                 return create(create(l,v,rll),rlv,_wK_)}
               return invalid_arg(cst_Set_bal$1)}
             return invalid_arg(cst_Set_bal$2)}
           var _wL_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_wL_]}
         function add(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return t;
             if(0 <= c){var rr=add(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=add(x,l);
             return l === ll?t:bal(ll,v,r)}
           return [0,0,x,0,1]}
         function singleton(x){return [0,0,x,0,1]}
         function add_min_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(add_min_element(x,l),v,r)}
           return singleton(x)}
         function add_max_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(l,v,add_max_element(x,r))}
           return singleton(x)}
         function join(l,v,r)
          {if(l)
            {if(r)
              {var
                rh=r[4],
                rr=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[4],
                lr=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,join(lr,v,r))
                       :(lh + 2 | 0) < rh?bal(join(l,v,rl),rv,rr):create(l,v,r)}
             return add_max_element(v,l)}
           return add_min_element(v,r)}
         function min_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _wG_=param$0[1];
               if(_wG_){var param$0=_wG_;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function min_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _wF_=param$0[1];
               if(_wF_){var param$0=_wF_;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function max_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function max_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function remove_min_elt(param)
          {if(param)
            {var _wE_=param[1];
             if(_wE_)
              {var r=param[3],v=param[2];return bal(remove_min_elt(_wE_),v,r)}
             var r$0=param[3];
             return r$0}
           return invalid_arg(cst_Set_remove_min_elt)}
         function concat(t1,t2)
          {if(t1)
            {if(t2)
              {var _wD_=remove_min_elt(t2);return join(t1,min_elt(t2),_wD_)}
             return t1}
           return t2}
         function split(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,1,r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,r)]}
           return _I_}
         var empty=0;
         function is_empty(param){return param?0:1}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _wC_=0 === c?1:0;
               if(_wC_)return _wC_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function remove(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {if(l)
                {if(r)
                  {var _wB_=remove_min_elt(r);return bal(l,min_elt(r),_wB_)}
                 return l}
               return r}
             if(0 <= c){var rr=remove(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=remove(x,l);
             return l === ll?t:bal(ll,v,r)}
           return 0}
         function union(s1,s2)
          {if(s1)
            {if(s2)
              {var
                h2=s2[4],
                r2=s2[3],
                v2=s2[2],
                l2=s2[1],
                h1=s1[4],
                r1=s1[3],
                v1=s1[2],
                l1=s1[1];
               if(h2 <= h1)
                {if(1 === h2)return add(v2,s1);
                 var
                  match=split(v1,s2),
                  r2$0=match[3],
                  l2$0=match[1],
                  _wz_=union(r1,r2$0);
                 return join(union(l1,l2$0),v1,_wz_)}
               if(1 === h1)return add(v1,s2);
               var
                match$0=split(v2,s1),
                r1$0=match$0[3],
                l1$0=match$0[1],
                _wA_=union(r1$0,r2);
               return join(union(l1$0,l2),v2,_wA_)}
             return s1}
           return s2}
         function inter(s1,s2)
          {if(s1)
            {if(s2)
              {var r1=s1[3],v1=s1[2],l1=s1[1],_wv_=split(v1,s2),_ww_=_wv_[1];
               if(_wv_[2])
                {var r2=_wv_[3],_wx_=inter(r1,r2);
                 return join(inter(l1,_ww_),v1,_wx_)}
               var r2$0=_wv_[3],_wy_=inter(r1,r2$0);
               return concat(inter(l1,_ww_),_wy_)}
             return 0}
           return 0}
         function split_bis(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return 0;
             if(0 <= c)
              {var match=split_bis(x,r);
               if(match)
                {var rr=match[2],lr=match[1];return [0,join(l,v,lr),rr]}
               return 0}
             var match$0=split_bis(x,l);
             if(match$0)
              {var rl=match$0[2],ll=match$0[1];
               return [0,
                       ll,
                       function(param){return join(caml_call1(rl,0),v,r)}]}
             return 0}
           return [0,0,function(param){return 0}]}
         function disjoint(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0 && s2$0)
              {var r1=s1$0[3],v1=s1$0[2],l1=s1$0[1];
               if(s1$0 === s2$0)return 0;
               var match=split_bis(v1,s2$0);
               if(match)
                {var r2=match[2],l2=match[1],_wu_=disjoint(l1,l2);
                 if(_wu_)
                  {var s2$1=caml_call1(r2,0),s1$0=r1,s2$0=s2$1;continue}
                 return _wu_}
               return 0}
             return 1}}
         function diff(s1,s2)
          {if(s1)
            {if(s2)
              {var r1=s1[3],v1=s1[2],l1=s1[1],_wq_=split(v1,s2),_wr_=_wq_[1];
               if(_wq_[2])
                {var r2=_wq_[3],_ws_=diff(r1,r2);
                 return concat(diff(l1,_wr_),_ws_)}
               var r2$0=_wq_[3],_wt_=diff(r1,r2$0);
               return join(diff(l1,_wr_),v1,_wt_)}
             return s1}
           return 0}
         function cons_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                s$1=s$0[1],
                e$1=[0,v,r,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(s1,s2)
          {var e2$2=cons_enum(s2,0),e1$2=cons_enum(s1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[3],
                  r2=e2[2],
                  v2=e2[1],
                  e1$0=e1[3],
                  r1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var
                    e2$1=cons_enum(r2,e2$0),
                    e1$1=cons_enum(r1,e1$0),
                    e1=e1$1,
                    e2=e2$1;
                   continue}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(s1,s2){return 0 === compare(s1,s2)?1:0}
         function subset(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0)
              {if(s2$0)
                {var
                  r2=s2$0[3],
                  v2=s2$0[2],
                  l2=s2$0[1],
                  r1=s1$0[3],
                  v1=s1$0[2],
                  l1=s1$0[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var _wn_=subset(l1,l2);
                   if(_wn_){var s1$0=r1,s2$0=r2;continue}
                   return _wn_}
                 if(0 <= c)
                  {var _wo_=subset([0,0,v1,r1,0],r2);
                   if(_wo_){var s1$0=l1;continue}
                   return _wo_}
                 var _wp_=subset([0,l1,v1,0,0],l2);
                 if(_wp_){var s1$0=r1;continue}
                 return _wp_}
               return 0}
             return 1}}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call1(f,v);
               var param$0=r;
               continue}
             return 0}}
         function fold(f,s,accu)
          {var s$0=s,accu$0=accu;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                l=s$0[1],
                accu$1=caml_call2(f,v,fold(f,l,accu$0)),
                s$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _wk_=caml_call1(p,v);
               if(_wk_)
                {var _wl_=for_all(p,l);
                 if(_wl_){var param$0=r;continue}
                 var _wm_=_wl_}
               else
                var _wm_=_wk_;
               return _wm_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _wh_=caml_call1(p,v);
               if(_wh_)
                var _wi_=_wh_;
               else
                {var _wj_=exists(p,l);
                 if(! _wj_){var param$0=r;continue}
                 var _wi_=_wj_}
               return _wi_}
             return 0}}
         function filter(p,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=filter(p,l),
              pv=caml_call1(p,v),
              r$0=filter(p,r);
             if(pv){if(l === l$0 && r === r$0)return t;return join(l$0,v,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pv=caml_call1(p,v),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pv){var _wf_=concat(lf,rf);return [0,join(lt,v,rt),_wf_]}
             var _wg_=join(lf,v,rf);
             return [0,concat(lt,rt),_wg_]}
           return _J_}
         function cardinal(param)
          {if(param)
            {var r=param[3],l=param[1],_we_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _we_ | 0}
           return 0}
         function elements_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,v,elements_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function elements(s){return elements_aux(0,s)}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return v;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return v0}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return v0}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,v];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function try_join(l,v,r)
          {var switch$0=0;
           if(0 !== l)
            {var _wd_=max_elt(l);
             if(0 <= caml_call2(Ord[1],_wd_,v))switch$0 = 1}
           if(! switch$0)
            {var switch$1=0;
             if(0 !== r)
              {var _wc_=min_elt(r);
               if(0 <= caml_call2(Ord[1],v,_wc_))switch$1 = 1}
             if(! switch$1)return join(l,v,r)}
           return union(l,add(v,r))}
         function map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=map(f,l),
              v$0=caml_call1(f,v),
              r$0=map(f,r);
             if(l === l$0 && v === v$0 && r === r$0)return t;
             return try_join(l$0,v$0,r$0)}
           return 0}
         function filter_map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              t1=filter_map(f,l),
              v$0=caml_call1(f,v),
              t2=filter_map(f,r);
             if(v$0)
              {var v$1=v$0[1];
               if(l === t1 && v === v$1 && r === t2)return t;
               return try_join(t1,v$1,t2)}
             if(t1)
              {if(t2)
                {var _wb_=remove_min_elt(t2);
                 return try_join(t1,min_elt(t2),_wb_)}
               return t1}
             return t2}
           return 0}
         function of_list(l)
          {if(l)
            {var _v2_=l[2],_v3_=l[1];
             if(_v2_)
              {var _v4_=_v2_[2],_v5_=_v2_[1];
               if(_v4_)
                {var _v6_=_v4_[2],_v7_=_v4_[1];
                 if(_v6_)
                  {var _v8_=_v6_[2],_v9_=_v6_[1];
                   if(_v8_)
                    {if(_v8_[2])
                      {var
                        l$0=sort_uniq(Ord[1],l),
                        sub=
                         function(n,l)
                          {if(! (3 < n >>> 0))
                            switch(n)
                             {case 0:return [0,0,l];
                              case 1:
                               if(l){var l$3=l[2],x0=l[1];return [0,[0,0,x0,0,1],l$3]}
                               break;
                              case 2:
                               if(l)
                                {var _v__=l[2];
                                 if(_v__)
                                  {var l$4=_v__[2],x1=_v__[1],x0$0=l[1];
                                   return [0,[0,[0,0,x0$0,0,1],x1,0,2],l$4]}}
                               break;
                              default:
                               if(l)
                                {var _v$_=l[2];
                                 if(_v$_)
                                  {var _wa_=_v$_[2];
                                   if(_wa_)
                                    {var l$5=_wa_[2],x2=_wa_[1],x1$0=_v$_[1],x0$1=l[1];
                                     return [0,[0,[0,0,x0$1,0,1],x1$0,[0,0,x2,0,1],2],l$5]}}}}
                           var nl=n / 2 | 0,match=sub(nl,l),l$0=match[2],left=match[1];
                           if(l$0)
                            {var
                              l$1=l$0[2],
                              mid=l$0[1],
                              match$0=sub((n - nl | 0) - 1 | 0,l$1),
                              l$2=match$0[2],
                              right=match$0[1];
                             return [0,create(left,mid,right),l$2]}
                           throw [0,Assert_failure,_K_]};
                       return sub(length(l$0),l$0)[1]}
                     var x4=_v8_[1];
                     return add(x4,add(_v9_,add(_v7_,add(_v5_,singleton(_v3_)))))}
                   return add(_v9_,add(_v7_,add(_v5_,singleton(_v3_))))}
                 return add(_v7_,add(_v5_,singleton(_v3_)))}
               return add(_v5_,singleton(_v3_))}
             return singleton(_v3_)}
           return empty}
         function add_seq(i,m)
          {return fold_left(function(s,x){return add(x,s)},m,i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[3],t=c[2],x=c[1],_v0_=cons_enum(t,rest);
             return [0,x,function(_v1_){return seq_of_enum(_v0_,_v1_)}]}
           return 0}
         function to_seq(c)
          {var _vY_=cons_enum(c,0);
           return function(_vZ_){return seq_of_enum(_vY_,_vZ_)}}
         function snoc_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                s$1=s$0[3],
                v=s$0[2],
                l=s$0[1],
                e$1=[0,v,l,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function rev_seq_of_enum(c,param)
          {if(c)
            {var rest=c[3],t=c[2],x=c[1],_vW_=snoc_enum(t,rest);
             return [0,x,function(_vX_){return rev_seq_of_enum(_vW_,_vX_)}]}
           return 0}
         function to_rev_seq(c)
          {var _vU_=snoc_enum(c,0);
           return function(_vV_){return rev_seq_of_enum(_vU_,_vV_)}}
         function to_seq_from(low,s)
          {var s$0=s,c=0;
           for(;;)
            {if(s$0)
              {var r=s$0[3],v=s$0[2],l=s$0[1],n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,r,c],s$0=l,c=c$0;continue}
                 var s$0=r;
                 continue}
               var _vS_=[0,v,r,c]}
             else
              var _vS_=c;
             return function(_vT_){return seq_of_enum(_vS_,_vT_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 singleton,
                 remove,
                 union,
                 inter,
                 disjoint,
                 diff,
                 compare,
                 equal,
                 subset,
                 iter,
                 map,
                 fold,
                 for_all,
                 exists,
                 filter,
                 filter_map,
                 partition,
                 cardinal,
                 elements,
                 min_elt,
                 min_elt_opt,
                 max_elt,
                 max_elt_opt,
                 min_elt,
                 min_elt_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 of_list,
                 to_seq_from,
                 to_seq,
                 to_rev_seq,
                 add_seq,
                 of_seq]}];
    caml_register_global(783,Stdlib_Set,"Stdlib__Set");
    var
     Stdlib_Map=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[5];return h}return 0}
         function create(l,x,d,r)
          {var hl=height(l),hr=height(r),_vR_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_vR_]}
         function singleton(x,d){return [0,0,x,d,0,1]}
         function bal(l,x,d,r)
          {if(l)var h=l[5],hl=h;else var hl=0;
           if(r)var h$0=r[5],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_vM_=height(lr);
               if(_vM_ <= height(ll))return create(ll,lv,ld,create(lr,x,d,r));
               if(lr)
                {var
                  lrr=lr[4],
                  lrd=lr[3],
                  lrv=lr[2],
                  lrl=lr[1],
                  _vN_=create(lrr,x,d,r);
                 return create(create(ll,lv,ld,lrl),lrv,lrd,_vN_)}
               return invalid_arg(cst_Map_bal)}
             return invalid_arg(cst_Map_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_vO_=height(rl);
               if(_vO_ <= height(rr))return create(create(l,x,d,rl),rv,rd,rr);
               if(rl)
                {var
                  rlr=rl[4],
                  rld=rl[3],
                  rlv=rl[2],
                  rll=rl[1],
                  _vP_=create(rlr,rv,rd,rr);
                 return create(create(l,x,d,rll),rlv,rld,_vP_)}
               return invalid_arg(cst_Map_bal$1)}
             return invalid_arg(cst_Map_bal$2)}
           var _vQ_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_vQ_]}
         var empty=0;
         function is_empty(param){return param?0:1}
         function add(x,data,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return d === data?m:[0,l,x,data,r,h];
             if(0 <= c){var rr=add(x,data,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=add(x,data,l);
             return l === ll?m:bal(ll,v,d,r)}
           return [0,0,x,data,0,1]}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return d;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0,d0]}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0,d0]}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,d];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _vL_=0 === c?1:0;
               if(_vL_)return _vL_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function min_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vK_=param$0[1];
               if(_vK_){var param$0=_vK_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function min_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vJ_=param$0[1];
               if(_vJ_){var param$0=_vJ_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function max_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function max_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function remove_min_binding(param)
          {if(param)
            {var _vI_=param[1];
             if(_vI_)
              {var r=param[4],d=param[3],v=param[2];
               return bal(remove_min_binding(_vI_),v,d,r)}
             var r$0=param[4];
             return r$0}
           return invalid_arg(cst_Map_remove_min_elt)}
         function _vh_(t1,t2)
          {if(t1)
            {if(t2)
              {var match=min_binding(t2),d=match[2],x=match[1];
               return bal(t1,x,d,remove_min_binding(t2))}
             return t1}
           return t2}
         function remove(x,m)
          {if(m)
            {var r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return _vh_(l,r);
             if(0 <= c){var rr=remove(x,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=remove(x,l);
             return l === ll?m:bal(ll,v,d,r)}
           return 0}
         function update(x,f,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {var match=caml_call1(f,[0,d]);
               if(match)
                {var data=match[1];return d === data?m:[0,l,x,data,r,h]}
               return _vh_(l,r)}
             if(0 <= c){var rr=update(x,f,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=update(x,f,l);
             return l === ll?m:bal(ll,v,d,r)}
           var match$0=caml_call1(f,0);
           if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
           return 0}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call2(f,v,d);
               var param$0=r;
               continue}
             return 0}}
         function map(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=map(f,l),
              d$0=caml_call1(f,d),
              r$0=map(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function mapi(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=mapi(f,l),
              d$0=caml_call2(f,v,d),
              r$0=mapi(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function fold(f,m,accu)
          {var m$0=m,accu$0=accu;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                accu$1=caml_call3(f,v,d,fold(f,l,accu$0)),
                m$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _vF_=caml_call2(p,v,d);
               if(_vF_)
                {var _vG_=for_all(p,l);
                 if(_vG_){var param$0=r;continue}
                 var _vH_=_vG_}
               else
                var _vH_=_vF_;
               return _vH_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _vC_=caml_call2(p,v,d);
               if(_vC_)
                var _vD_=_vC_;
               else
                {var _vE_=exists(p,l);
                 if(! _vE_){var param$0=r;continue}
                 var _vD_=_vE_}
               return _vD_}
             return 0}}
         function add_min_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(add_min_binding(k,x,l),v,d,r)}
           return singleton(k,x)}
         function add_max_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(l,v,d,add_max_binding(k,x,r))}
           return singleton(k,x)}
         function join(l,v,d,r)
          {if(l)
            {if(r)
              {var
                rh=r[5],
                rr=r[4],
                rd=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[5],
                lr=l[4],
                ld=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,ld,join(lr,v,d,r))
                       :(lh + 2 | 0) < rh
                         ?bal(join(l,v,d,rl),rv,rd,rr)
                         :create(l,v,d,r)}
             return add_max_binding(v,d,l)}
           return add_min_binding(v,d,r)}
         function concat(t1,t2)
          {if(t1)
            {if(t2)
              {var match=min_binding(t2),d=match[2],x=match[1];
               return join(t1,x,d,remove_min_binding(t2))}
             return t1}
           return t2}
         function concat_or_join(t1,v,d,t2)
          {if(d){var d$0=d[1];return join(t1,v,d$0,t2)}return concat(t1,t2)}
         function split(x,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,[0,d],r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,d,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,d,r)]}
           return _L_}
         function merge(f,s1,s2)
          {if(s1)
            {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
             if(height(s2) <= h1)
              {var
                match=split(v1,s2),
                r2=match[3],
                d2=match[2],
                l2=match[1],
                _vy_=merge(f,r1,r2),
                _vz_=caml_call3(f,v1,[0,d1],d2);
               return concat_or_join(merge(f,l1,l2),v1,_vz_,_vy_)}}
           else
            if(! s2)return 0;
           if(s2)
            {var
              r2$0=s2[4],
              d2$0=s2[3],
              v2=s2[2],
              l2$0=s2[1],
              match$0=split(v2,s1),
              r1$0=match$0[3],
              d1$0=match$0[2],
              l1$0=match$0[1],
              _vA_=merge(f,r1$0,r2$0),
              _vB_=caml_call3(f,v2,d1$0,[0,d2$0]);
             return concat_or_join(merge(f,l1$0,l2$0),v2,_vB_,_vA_)}
           throw [0,Assert_failure,_M_]}
         function union(f,s1,s2)
          {if(s1)
            {if(s2)
              {var
                h2=s2[5],
                r2=s2[4],
                d2=s2[3],
                v2=s2[2],
                l2=s2[1],
                h1=s1[5],
                r1=s1[4],
                d1=s1[3],
                v1=s1[2],
                l1=s1[1];
               if(h2 <= h1)
                {var
                  match=split(v1,s2),
                  r2$0=match[3],
                  d2$0=match[2],
                  l2$0=match[1],
                  l=union(f,l1,l2$0),
                  r=union(f,r1,r2$0);
                 if(d2$0)
                  {var d2$1=d2$0[1];
                   return concat_or_join(l,v1,caml_call3(f,v1,d1,d2$1),r)}
                 return join(l,v1,d1,r)}
               var
                match$0=split(v2,s1),
                r1$0=match$0[3],
                d1$0=match$0[2],
                l1$0=match$0[1],
                l$0=union(f,l1$0,l2),
                r$0=union(f,r1$0,r2);
               if(d1$0)
                {var d1$1=d1$0[1];
                 return concat_or_join(l$0,v2,caml_call3(f,v2,d1$1,d2),r$0)}
               return join(l$0,v2,d2,r$0)}
             var s=s1}
           else
            var s=s2;
           return s}
         function filter(p,m)
          {if(m)
            {var
              r=m[4],
              d=m[3],
              v=m[2],
              l=m[1],
              l$0=filter(p,l),
              pvd=caml_call2(p,v,d),
              r$0=filter(p,r);
             if(pvd)
              {if(l === l$0 && r === r$0)return m;return join(l$0,v,d,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function filter_map(f,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=filter_map(f,l),
              fvd=caml_call2(f,v,d),
              r$0=filter_map(f,r);
             if(fvd){var d$0=fvd[1];return join(l$0,v,d$0,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pvd=caml_call2(p,v,d),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pvd){var _vw_=concat(lf,rf);return [0,join(lt,v,d,rt),_vw_]}
             var _vx_=join(lf,v,d,rf);
             return [0,concat(lt,rt),_vx_]}
           return _N_}
         function cons_enum(m,e)
          {var m$0=m,e$0=e;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                m$1=m$0[1],
                e$1=[0,v,d,r,e$0],
                m$0=m$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var c$0=caml_call2(cmp,d1,d2);
                   if(0 === c$0)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   return c$0}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  _vt_=0 === caml_call2(Ord[1],v1,v2)?1:0;
                 if(_vt_)
                  {var _vu_=caml_call2(cmp,d1,d2);
                   if(_vu_)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   var _vv_=_vu_}
                 else
                  var _vv_=_vt_;
                 return _vv_}
               return 0}
             return e2?0:1}}
         function cardinal(param)
          {if(param)
            {var r=param[4],l=param[1],_vs_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _vs_ | 0}
           return 0}
         function bindings_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function bindings(s){return bindings_aux(0,s)}
         function add_seq(i,m)
          {return fold_left
                   (function(m,param)
                     {var v=param[2],k=param[1];return add(k,v,m)},
                    m,
                    i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[4],t=c[3],v=c[2],k=c[1],_vq_=cons_enum(t,rest);
             return [0,[0,k,v],function(_vr_){return seq_of_enum(_vq_,_vr_)}]}
           return 0}
         function to_seq(m)
          {var _vo_=cons_enum(m,0);
           return function(_vp_){return seq_of_enum(_vo_,_vp_)}}
         function snoc_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                s$1=s$0[4],
                d=s$0[3],
                v=s$0[2],
                l=s$0[1],
                e$1=[0,v,d,l,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function rev_seq_of_enum(c,param)
          {if(c)
            {var rest=c[4],t=c[3],v=c[2],k=c[1],_vm_=snoc_enum(t,rest);
             return [0,
                     [0,k,v],
                     function(_vn_){return rev_seq_of_enum(_vm_,_vn_)}]}
           return 0}
         function to_rev_seq(c)
          {var _vk_=snoc_enum(c,0);
           return function(_vl_){return rev_seq_of_enum(_vk_,_vl_)}}
         function to_seq_from(low,m)
          {var m$0=m,c=0;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,d,r,c],m$0=l,c=c$0;continue}
                 var m$0=r;
                 continue}
               var _vi_=[0,v,d,r,c]}
             else
              var _vi_=c;
             return function(_vj_){return seq_of_enum(_vi_,_vj_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 update,
                 singleton,
                 remove,
                 merge,
                 union,
                 compare,
                 equal,
                 iter,
                 fold,
                 for_all,
                 exists,
                 filter,
                 filter_map,
                 partition,
                 cardinal,
                 bindings,
                 min_binding,
                 min_binding_opt,
                 max_binding,
                 max_binding_opt,
                 min_binding,
                 min_binding_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 map,
                 mapi,
                 to_seq,
                 to_rev_seq,
                 to_seq_from,
                 add_seq,
                 of_seq]}];
    caml_register_global(784,Stdlib_Map,"Stdlib__Map");
    var Empty=[248,cst_Stdlib_Stack_Empty,caml_fresh_oo_id(0)];
    function create$0(param){return [0,0,0]}
    function clear(s){s[1] = 0;s[2] = 0;return 0}
    function copy$3(s){return [0,s[1],s[2]]}
    function push(x,s){s[1] = [0,x,s[1]];s[2] = s[2] + 1 | 0;return 0}
    function pop(s)
     {var _vg_=s[1];
      if(_vg_)
       {var tl=_vg_[2],hd=_vg_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return hd}
      throw Empty}
    function pop_opt(s)
     {var _vf_=s[1];
      if(_vf_)
       {var tl=_vf_[2],hd=_vf_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return [0,hd]}
      return 0}
    function top(s)
     {var _ve_=s[1];if(_ve_){var hd=_ve_[1];return hd}throw Empty}
    function top_opt(s)
     {var _vd_=s[1];if(_vd_){var hd=_vd_[1];return [0,hd]}return 0}
    function is_empty(s){return 0 === s[1]?1:0}
    function length$1(s){return s[2]}
    function iter$7(f,s){return iter$2(f,s[1])}
    function fold$2(f,acc,s){return fold_left$0(f,acc,s[1])}
    function to_seq$6(s){return to_seq$1(s[1])}
    function add_seq(q,i){return iter(function(x){return push(x,q)},i)}
    function of_seq$4(g){var s=create$0(0);add_seq(s,g);return s}
    var
     Stdlib_Stack=
      [0,
       Empty,
       create$0,
       push,
       pop,
       pop_opt,
       top,
       top_opt,
       clear,
       copy$3,
       is_empty,
       length$1,
       iter$7,
       fold$2,
       to_seq$6,
       add_seq,
       of_seq$4];
    caml_register_global(785,Stdlib_Stack,"Stdlib__Stack");
    var Empty$0=[248,cst_Stdlib_Queue_Empty,caml_fresh_oo_id(0)];
    function create$1(param){return [0,0,0,0]}
    function clear$0(q){q[1] = 0;q[2] = 0;q[3] = 0;return 0}
    function add(x,q)
     {var cell=[0,x,0],_vc_=q[3];
      return _vc_
              ?(q[1] = q[1] + 1 | 0,_vc_[2] = cell,q[3] = cell,0)
              :(q[1] = 1,q[2] = cell,q[3] = cell,0)}
    function peek(q)
     {var _vb_=q[2];if(_vb_){var content=_vb_[1];return content}throw Empty$0}
    function peek_opt(q)
     {var _va_=q[2];if(_va_){var content=_va_[1];return [0,content]}return 0}
    function take(q)
     {var _u__=q[2];
      if(_u__)
       {var _u$_=_u__[1];
        if(_u__[2])
         {var next=_u__[2];q[1] = q[1] - 1 | 0;q[2] = next;return _u$_}
        clear$0(q);
        return _u$_}
      throw Empty$0}
    function take_opt(q)
     {var _u8_=q[2];
      if(_u8_)
       {var _u9_=_u8_[1];
        if(_u8_[2])
         {var next=_u8_[2];q[1] = q[1] - 1 | 0;q[2] = next;return [0,_u9_]}
        clear$0(q);
        return [0,_u9_]}
      return 0}
    function copy$4(q)
     {var q_res=[0,q[1],0,0],prev=0,cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2],res=[0,content,0];
          if(prev)prev[2] = res;else q_res[2] = res;
          var prev=res,cell=next;
          continue}
        q_res[3] = prev;
        return q_res}}
    function is_empty$0(q){return 0 === q[1]?1:0}
    function length$2(q){return q[1]}
    function iter$8(f,q)
     {var cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2];
          caml_call1(f,content);
          var cell=next;
          continue}
        return 0}}
    function fold$3(f,accu$1,q)
     {var accu=accu$1,cell=q[2];
      for(;;)
       {if(cell)
         {var
           content=cell[1],
           next=cell[2],
           accu$0=caml_call2(f,accu,content),
           accu=accu$0,
           cell=next;
          continue}
        return accu}}
    function transfer(q1,q2)
     {var _u6_=0 < q1[1]?1:0;
      if(_u6_)
       {var _u7_=q2[3];
        return _u7_
                ?(q2[1]
                  =
                  q2[1]
                  +
                  q1[1]
                  |
                  0,
                  _u7_[2]
                  =
                  q1[2],
                  q2[3]
                  =
                  q1[3],
                  clear$0(q1))
                :(q2[1] = q1[1],q2[2] = q1[2],q2[3] = q1[3],clear$0(q1))}
      return _u6_}
    function to_seq$7(q)
     {function aux(c,param)
       {if(c)
         {var x=c[1],next=c[2];
          return [0,x,function(_u5_){return aux(next,_u5_)}]}
        return 0}
      var _u3_=q[2];
      return function(_u4_){return aux(_u3_,_u4_)}}
    function add_seq$0(q,i){return iter(function(x){return add(x,q)},i)}
    function of_seq$5(g){var q=create$1(0);add_seq$0(q,g);return q}
    var
     Stdlib_Queue=
      [0,
       Empty$0,
       create$1,
       add,
       add,
       take,
       take_opt,
       take,
       peek,
       peek_opt,
       peek,
       clear$0,
       copy$4,
       is_empty$0,
       length$2,
       iter$8,
       fold$3,
       transfer,
       to_seq$7,
       add_seq$0,
       of_seq$5];
    caml_register_global(786,Stdlib_Queue,"Stdlib__Queue");
    var Undefined=[248,cst_CamlinternalLazy_Undefined,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      try
       {var result=caml_call1(closure,0);
        caml_obj_make_forward(blk,result);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);blk[1] = function(param){throw e};throw e}}
    function force_val_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      var result=caml_call1(closure,0);
      caml_obj_make_forward(blk,result);
      return result}
    function force(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_lazy_block(lzv)}
    function force_val(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_val_lazy_block(lzv)}
    var
     CamlinternalLazy=
      [0,Undefined,force_lazy_block,force_val_lazy_block,force,force_val];
    caml_register_global(787,CamlinternalLazy,"CamlinternalLazy");
    function from_fun(f){var x=caml_obj_block(246,1);x[1] = f;return x}
    function from_val(v)
     {var t=caml_obj_tag(v);
      if(t !== 250 && t !== 246 && t !== 253)return v;
      return runtime.caml_lazy_make_forward(v)}
    function is_val(l){return caml_obj_tag(l) !== 246?1:0}
    function map$8(f,x)
     {return [246,
              function(_u0_)
               {var
                 _u1_=caml_obj_tag(x),
                 _u2_=250 === _u1_?x[1]:246 === _u1_?force_lazy_block(x):x;
                return caml_call1(f,_u2_)}]}
    function map_val(f,x)
     {if(is_val(x))
       {var
         _uV_=caml_obj_tag(x),
         _uW_=250 === _uV_?x[1]:246 === _uV_?force_lazy_block(x):x;
        return from_val(caml_call1(f,_uW_))}
      return [246,
              function(_uX_)
               {var
                 _uY_=caml_obj_tag(x),
                 _uZ_=250 === _uY_?x[1]:246 === _uY_?force_lazy_block(x):x;
                return caml_call1(f,_uZ_)}]}
    var
     Stdlib_Lazy=
      [0,
       Undefined,
       map$8,
       is_val,
       from_val,
       map_val,
       from_fun,
       force_val,
       from_fun,
       from_val,
       is_val];
    caml_register_global(788,Stdlib_Lazy,"Stdlib__Lazy");
    var
     Failure$0=[248,cst_Stdlib_Stream_Failure,caml_fresh_oo_id(0)],
     Error=[248,cst_Stdlib_Stream_Error,caml_fresh_oo_id(0)];
    function count(param)
     {if(param){var match=param[1],count=match[1];return count}return 0}
    function data(param)
     {if(param){var match=param[1],data=match[2];return data}return 0}
    function fill_buff(b)
     {b[3] = input(b[1],b[2],0,caml_ml_bytes_length(b[2]));b[4] = 0;return 0}
    function get_data(count,d)
     {var d$0=d;
      for(;;)
       {if(typeof d$0 !== "number")
         switch(d$0[0])
          {case 1:
            var d2=d$0[2],d1=d$0[1],match=get_data(count,d1);
            if(typeof match === "number")
             {var d$0=d2;continue}
            else
             {if(0 === match[0])
               {var d11=match[2],a=match[1];return [0,a,[1,d11,d2]]}
              throw [0,Assert_failure,_O_]}
           case 2:
            var
             f=d$0[1],
             _uR_=caml_obj_tag(f),
             d$1=250 === _uR_?f[1]:246 === _uR_?force_lazy_block(f):f,
             d$0=d$1;
            continue;
           case 3:
            var _uS_=d$0[1],_uT_=_uS_[1];
            if(_uT_)
             {var _uU_=_uT_[1];
              if(_uU_){var a$0=_uU_[1];_uS_[1] = 0;return [0,a$0,d$0]}
              return 0}
            var match$0=caml_call1(_uS_[2],count);
            if(match$0){var a$1=match$0[1];return [0,a$1,d$0]}
            _uS_[1] = _P_;
            return 0;
           case 4:
            var b=d$0[1];
            if(b[3] <= b[4])fill_buff(b);
            if(0 === b[3])return 0;
            var r=caml_bytes_unsafe_get(b[2],b[4]);
            b[4] = b[4] + 1 | 0;
            return [0,r,d$0]
           }
        return d$0}}
    function peek_data(s)
     {for(;;)
       {var _uM_=s[2];
        if(typeof _uM_ === "number")
         return 0;
        else
         switch(_uM_[0])
          {case 0:var a=_uM_[1];return [0,a];
           case 1:
            var d=get_data(s[1],s[2]);
            if(typeof d === "number")
             return 0;
            else
             {if(0 === d[0]){var a$0=d[1];s[2] = d;return [0,a$0]}
              throw [0,Assert_failure,_Q_]}
           case 2:
            var
             f=_uM_[1],
             _uN_=caml_obj_tag(f),
             _uO_=250 === _uN_?f[1]:246 === _uN_?force_lazy_block(f):f;
            s[2] = _uO_;
            continue;
           case 3:
            var _uP_=_uM_[1],_uQ_=_uP_[1];
            if(_uQ_){var a$1=_uQ_[1];return a$1}
            var x=caml_call1(_uP_[2],s[1]);
            _uP_[1] = [0,x];
            return x;
           default:
            var b=_uM_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :[0,caml_bytes_unsafe_get(b[2],b[4])]}}}
    function peek$0(param)
     {if(param){var s=param[1];return peek_data(s)}return 0}
    function junk_data(s)
     {for(;;)
       {var _uK_=s[2];
        if(typeof _uK_ !== "number")
         switch(_uK_[0])
          {case 0:var d=_uK_[2];s[1] = s[1] + 1 | 0;s[2] = d;return 0;
           case 3:
            var _uL_=_uK_[1];
            if(_uL_[1]){s[1] = s[1] + 1 | 0;_uL_[1] = 0;return 0}
            break;
           case 4:
            var b=_uK_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :(s[1] = s[1] + 1 | 0,b[4] = b[4] + 1 | 0,0)
           }
        var match=peek_data(s);
        if(match)continue;
        return 0}}
    function junk(param)
     {if(param){var data=param[1];return junk_data(data)}return 0}
    function nget_data(n,s)
     {if(0 < n)
       {var match=peek_data(s);
        if(match)
         {var a=match[1];
          junk_data(s);
          var
           match$0=nget_data(n - 1 | 0,s),
           k=match$0[3],
           d=match$0[2],
           al=match$0[1];
          return [0,[0,a,al],[0,a,d],k + 1 | 0]}
        return [0,0,s[2],0]}
      return [0,0,s[2],0]}
    function npeek(n,param)
     {if(param)
       {var
         d$0=param[1],
         match=nget_data(n,d$0),
         len=match[3],
         d=match[2],
         al=match[1];
        d$0[1] = d$0[1] - len | 0;
        d$0[2] = d;
        return al}
      return 0}
    function next(s)
     {var match=peek$0(s);
      if(match){var a=match[1];junk(s);return a}
      throw Failure$0}
    function empty$2(s){var match=peek$0(s);if(match)throw Failure$0;return 0}
    function iter$9(f,strm)
     {for(;;)
       {var match=peek$0(strm);
        if(match){var a=match[1];junk(strm);caml_call1(f,a);continue}
        return 0}}
    function from(f){return [0,[0,0,[3,[0,0,f]]]]}
    function of_list$1(l)
     {var _uJ_=0;
      return [0,[0,0,fold_right(function(x,l){return [0,x,l]},l,_uJ_)]]}
    function of_string(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_string_length(s)
                         ?(count[1]++,[0,caml_string_get(s,c)])
                         :0})}
    function of_bytes$0(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_bytes_length(s)
                         ?(count[1]++,[0,caml_bytes_get(s,c)])
                         :0})}
    function of_channel(ic)
     {return [0,[0,0,[4,[0,ic,caml_create_bytes(4096),0,0]]]]}
    function iapp(i,s){var _uI_=data(s);return [0,[0,0,[1,data(i),_uI_]]]}
    function icons(i,s){return [0,[0,0,[0,i,data(s)]]]}
    function ising(i){return [0,[0,0,[0,i,0]]]}
    function lapp(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_uG_)
                  {var _uH_=data(s);return [1,data(caml_call1(f,0)),_uH_]}]]]]}
    function lcons(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_uE_)
                  {var _uF_=data(s);return [0,caml_call1(f,0),_uF_]}]]]]}
    function lsing(f)
     {return [0,[0,0,[2,[246,function(_uD_){return [0,caml_call1(f,0),0]}]]]]}
    var sempty=0;
    function slazy(f)
     {return [0,[0,0,[2,[246,function(_uC_){return data(caml_call1(f,0))}]]]]}
    function dump_data(f,param)
     {if(typeof param === "number")
       return print_string(cst_Sempty);
      else
       switch(param[0])
        {case 0:
          var d=param[2],a=param[1];
          print_string(cst_Scons);
          caml_call1(f,a);
          print_string(cst$7);
          dump_data(f,d);
          return print_string(cst$8);
         case 1:
          var d2=param[2],d1=param[1];
          print_string(cst_Sapp);
          dump_data(f,d1);
          print_string(cst$9);
          dump_data(f,d2);
          return print_string(cst$10);
         case 2:return print_string(cst_Slazy);
         case 3:return print_string(cst_Sgen);
         default:return print_string(cst_Sbuffio)}}
    function dump(f,s)
     {print_string(cst_count);
      print_int(count(s));
      print_string(cst_data);
      dump_data(f,data(s));
      print_string(cst$6);
      return print_newline(0)}
    var
     Stdlib_Stream=
      [0,
       Failure$0,
       Error,
       from,
       of_list$1,
       of_string,
       of_bytes$0,
       of_channel,
       iter$9,
       next,
       empty$2,
       peek$0,
       junk,
       count,
       npeek,
       iapp,
       icons,
       ising,
       lapp,
       lcons,
       lsing,
       sempty,
       slazy,
       dump];
    caml_register_global(789,Stdlib_Stream,"Stdlib__Stream");
    function create$2(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function to_bytes$0(b){return sub(b[1],0,b[2])}
    function sub$3(b,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((b[2] - len | 0) < ofs))
       return sub_string(b[1],ofs,len);
      return invalid_arg(cst_Buffer_sub)}
    function blit$3(src,srcoff,dst,dstoff,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        srcoff
        &&
        !
        ((src[2] - len | 0) < srcoff)
        &&
        0
        <=
        dstoff
        &&
        !
        ((caml_ml_bytes_length(dst) - len | 0) < dstoff))
       return caml_blit_bytes(src[1],srcoff,dst,dstoff,len);
      return invalid_arg(cst_Buffer_blit)}
    function nth$0(b,ofs)
     {if(0 <= ofs && ! (b[2] <= ofs))return caml_bytes_unsafe_get(b[1],ofs);
      return invalid_arg(cst_Buffer_nth)}
    function length$3(b){return b[2]}
    function clear$1(b){b[2] = 0;return 0}
    function reset(b)
     {b[2] = 0;b[1] = b[4];b[3] = caml_ml_bytes_length(b[1]);return 0}
    function resize(b,more)
     {var old_pos=b[2],old_len=b[3],new_len=[0,old_len];
      for(;;)
       {if(new_len[1] < (old_pos + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((old_pos + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(cst_Buffer_add_cannot_grow_buf);
        var new_buffer=caml_create_bytes(new_len[1]);
        blit(b[1],0,new_buffer,0,b[2]);
        b[1] = new_buffer;
        b[3] = new_len[1];
        if((b[2] + more | 0) <= b[3])
         {if((old_pos + more | 0) <= b[3])return 0;
          throw [0,Assert_failure,_R_]}
        throw [0,Assert_failure,_S_]}}
    function add_char(b,c)
     {var pos=b[2];
      if(b[3] <= pos)resize(b,1);
      caml_bytes_unsafe_set(b[1],pos,c);
      b[2] = pos + 1 | 0;
      return 0}
    function add_utf_8_uchar(b,u)
     {if(0 <= u)
       {if(127 < u)
         {if(2047 < u)
           {if(65535 < u)
             {if(1114111 < u)throw [0,Assert_failure,_T_];
              var pos=b[2];
              if(b[3] < (pos + 4 | 0))resize(b,4);
              caml_bytes_unsafe_set(b[1],pos,240 | u >>> 18 | 0);
              caml_bytes_unsafe_set
               (b[1],pos + 1 | 0,128 | (u >>> 12 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 2 | 0,128 | (u >>> 6 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 3 | 0,128 | u & 63);
              b[2] = pos + 4 | 0;
              return 0}
            var pos$0=b[2];
            if(b[3] < (pos$0 + 3 | 0))resize(b,3);
            caml_bytes_unsafe_set(b[1],pos$0,224 | u >>> 12 | 0);
            caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,128 | (u >>> 6 | 0) & 63);
            caml_bytes_unsafe_set(b[1],pos$0 + 2 | 0,128 | u & 63);
            b[2] = pos$0 + 3 | 0;
            return 0}
          var pos$1=b[2];
          if(b[3] < (pos$1 + 2 | 0))resize(b,2);
          caml_bytes_unsafe_set(b[1],pos$1,192 | u >>> 6 | 0);
          caml_bytes_unsafe_set(b[1],pos$1 + 1 | 0,128 | u & 63);
          b[2] = pos$1 + 2 | 0;
          return 0}
        return add_char(b,u)}
      throw [0,Assert_failure,_U_]}
    function add_utf_16be_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_V_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo & 255);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u >>> 8 | 0);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u & 255);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_W_]}
    function add_utf_16le_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_X_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo & 255);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo >>> 8 | 0);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u & 255);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u >>> 8 | 0);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_Y_]}
    function add_substring(b,s,offset,len)
     {var _uz_=offset < 0?1:0;
      if(_uz_)
       var _uA_=_uz_;
      else
       var
        _uB_=len < 0?1:0,
        _uA_=_uB_ || ((caml_ml_string_length(s) - len | 0) < offset?1:0);
      if(_uA_)invalid_arg(cst_Buffer_add_substring_add_s);
      var new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      caml_blit_string(s,offset,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_subbytes(b,s,offset,len)
     {return add_substring(b,caml_string_of_bytes(s),offset,len)}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      caml_blit_string(s,0,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_bytes(b,s){return add_string(b,caml_string_of_bytes(s))}
    function add_buffer(b,bs){return add_subbytes(b,bs[1],0,bs[2])}
    function add_channel(b,ic,len)
     {var _ux_=len < 0?1:0,_uy_=_ux_ || (max_string_length < len?1:0);
      if(_uy_)invalid_arg(cst_Buffer_add_channel);
      if(b[3] < (b[2] + len | 0))resize(b,len);
      var already_read=0,ofs=b[2],to_read=len,_uw_=b[1];
      for(;;)
       {if(0 !== to_read)
         {var r=input(ic,_uw_,ofs,to_read);
          if(0 !== r)
           {var
             already_read$0=already_read + r | 0,
             ofs$0=ofs + r | 0,
             to_read$0=to_read - r | 0,
             already_read=already_read$0,
             ofs=ofs$0,
             to_read=to_read$0;
            continue}}
        if((b[2] + already_read | 0) <= b[3])
         {b[2] = b[2] + already_read | 0;
          if(already_read < len)throw End_of_file;
          return 0}
        throw [0,Assert_failure,_Z_]}}
    function output_buffer(oc,b){return output(oc,b[1],0,b[2])}
    function add_substitute(b,f,s)
     {var lim$1=caml_ml_string_length(s),previous=32,i$7=0;
      for(;;)
       {if(i$7 < lim$1)
         {var current=caml_string_get(s,i$7);
          if(36 === current)
           {if(92 === previous)
             {add_char(b,current);
              var i$8=i$7 + 1 | 0,previous=32,i$7=i$8;
              continue}
            var start=i$7 + 1 | 0;
            if(lim$1 <= start)throw Not_found;
            var opening=caml_string_get(s,start),switch$0=0;
            if(40 !== opening && 123 !== opening)
             {var i$6=start + 1 | 0,lim$0=caml_ml_string_length(s),i$3=i$6;
              for(;;)
               {if(lim$0 <= i$3)
                 var stop=lim$0;
                else
                 {var match=caml_string_get(s,i$3),switch$1=0;
                  if(91 <= match)
                   {if(97 <= match)
                     {if(! (123 <= match))switch$1 = 1}
                    else
                     if(95 === match)switch$1 = 1}
                  else
                   if(58 <= match)
                    {if(65 <= match)switch$1 = 1}
                   else
                    if(48 <= match)switch$1 = 1;
                  if(switch$1){var i$4=i$3 + 1 | 0,i$3=i$4;continue}
                  var stop=i$3}
                var match$0=[0,sub$0(s,start,stop - start | 0),stop];
                switch$0 = 1;
                break}}
            if(! switch$0)
             {var i$5=start + 1 | 0,k$2=0;
              if(40 === opening)
               var _uu_=41;
              else
               {if(123 !== opening)throw [0,Assert_failure,___];var _uu_=125}
              var lim=caml_ml_string_length(s),k=k$2,i=i$5;
              for(;;)
               {if(lim <= i)throw Not_found;
                if(caml_string_get(s,i) === opening)
                 {var i$0=i + 1 | 0,k$0=k + 1 | 0,k=k$0,i=i$0;continue}
                if(caml_string_get(s,i) !== _uu_)
                 {var i$2=i + 1 | 0,i=i$2;continue}
                if(0 !== k)
                 {var i$1=i + 1 | 0,k$1=k - 1 | 0,k=k$1,i=i$1;continue}
                var
                 match$0=
                  [0,sub$0(s,i$5,(i - start | 0) - 1 | 0),i + 1 | 0];
                break}}
            var next_i=match$0[2],ident=match$0[1];
            add_string(b,caml_call1(f,ident));
            var previous=32,i$7=next_i;
            continue}
          if(92 === previous)
           {add_char(b,92);
            add_char(b,current);
            var i$9=i$7 + 1 | 0,previous=32,i$7=i$9;
            continue}
          if(92 === current)
           {var i$10=i$7 + 1 | 0,previous=current,i$7=i$10;continue}
          add_char(b,current);
          var i$11=i$7 + 1 | 0,previous=current,i$7=i$11;
          continue}
        var _uv_=92 === previous?1:0;
        return _uv_?add_char(b,previous):_uv_}}
    function truncate(b,len)
     {if(0 <= len && ! (b[2] < len)){b[2] = len;return 0}
      return invalid_arg(cst_Buffer_truncate)}
    function to_seq$8(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_unsafe_get(b[1],i),_us_=i + 1 | 0;
        return [0,x,function(_ut_){return aux(_us_,_ut_)}]}
      var _uq_=0;
      return function(_ur_){return aux(_uq_,_ur_)}}
    function to_seqi$3(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_unsafe_get(b[1],i),_uo_=i + 1 | 0;
        return [0,[0,i,x],function(_up_){return aux(_uo_,_up_)}]}
      var _um_=0;
      return function(_un_){return aux(_um_,_un_)}}
    function add_seq$1(b,seq)
     {return iter(function(_ul_){return add_char(b,_ul_)},seq)}
    function of_seq$6(i){var b=create$2(32);add_seq$1(b,i);return b}
    function add_int8(b,x)
     {var new_position=b[2] + 1 | 0;
      if(b[3] < new_position)resize(b,1);
      caml_bytes_unsafe_set(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_ne(b,x)
     {var new_position=b[2] + 2 | 0;
      if(b[3] < new_position)resize(b,2);
      caml_bytes_set16(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int32_ne(b,x)
     {var new_position=b[2] + 4 | 0;
      if(b[3] < new_position)resize(b,4);
      caml_bytes_set32(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int64_ne(b,x)
     {var new_position=b[2] + 8 | 0;
      if(b[3] < new_position)resize(b,8);
      caml_bytes_set64(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_le(b,x){return add_int16_ne(b,x)}
    function add_int16_be(b,x)
     {var x$0=caml_bswap16(x);return add_int16_ne(b,x$0)}
    function add_int32_le(b,x){return add_int32_ne(b,x)}
    function add_int32_be(b,x)
     {var x$0=caml_int32_bswap(x);return add_int32_ne(b,x$0)}
    function add_int64_le(b,x){return add_int64_ne(b,x)}
    function add_int64_be(b,x)
     {var x$0=caml_int64_bswap(x);return add_int64_ne(b,x$0)}
    var
     Stdlib_Buffer=
      [0,
       create$2,
       contents,
       to_bytes$0,
       sub$3,
       blit$3,
       nth$0,
       length$3,
       clear$1,
       reset,
       output_buffer,
       truncate,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       to_seq$8,
       to_seqi$3,
       add_seq$1,
       of_seq$6,
       add_int8,
       add_int8,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int32_ne,
       add_int32_be,
       add_int32_le,
       add_int64_ne,
       add_int64_be,
       add_int64_le];
    caml_register_global(790,Stdlib_Buffer,"Stdlib__Buffer");
    function create_char_set(param){return make$0(32,0)}
    function add_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return caml_bytes_set
              (char_set,
               str_ind,
               char_of_int(caml_bytes_get(char_set,str_ind) | mask))}
    function freeze_char_set(char_set){return of_bytes(char_set)}
    function rev_char_set(char_set)
     {var char_set$0=create_char_set(0),i=0;
      for(;;)
       {caml_bytes_set
         (char_set$0,i,char_of_int(caml_string_get(char_set,i) ^ 255));
        var _uk_=i + 1 | 0;
        if(31 !== i){var i=_uk_;continue}
        return caml_string_of_bytes(char_set$0)}}
    function is_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return 0 !== (caml_string_get(char_set,str_ind) & mask)?1:0}
    function pad_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return [0,1,width]}return 0}
    function param_format_of_ignored_format(ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:return [0,[0,fmt]];
         case 1:return [0,[1,fmt]];
         case 2:return [0,[19,fmt]];
         default:return [0,[22,fmt]]}
      else
       switch(ign[0])
        {case 0:var pad_opt=ign[1];return [0,[2,pad_of_pad_opt(pad_opt),fmt]];
         case 1:
          var pad_opt$0=ign[1];return [0,[3,pad_of_pad_opt(pad_opt$0),fmt]];
         case 2:
          var pad_opt$1=ign[2],iconv=ign[1];
          return [0,[4,iconv,pad_of_pad_opt(pad_opt$1),0,fmt]];
         case 3:
          var pad_opt$2=ign[2],iconv$0=ign[1];
          return [0,[5,iconv$0,pad_of_pad_opt(pad_opt$2),0,fmt]];
         case 4:
          var pad_opt$3=ign[2],iconv$1=ign[1];
          return [0,[6,iconv$1,pad_of_pad_opt(pad_opt$3),0,fmt]];
         case 5:
          var pad_opt$4=ign[2],iconv$2=ign[1];
          return [0,[7,iconv$2,pad_of_pad_opt(pad_opt$4),0,fmt]];
         case 6:
          var prec_opt=ign[2],pad_opt$5=ign[1];
          if(prec_opt)var ndec=prec_opt[1],_uj_=[0,ndec];else var _uj_=0;
          return [0,[8,_$_,pad_of_pad_opt(pad_opt$5),_uj_,fmt]];
         case 7:
          var pad_opt$6=ign[1];return [0,[9,pad_of_pad_opt(pad_opt$6),fmt]];
         case 8:
          var fmtty=ign[2],pad_opt$7=ign[1];
          return [0,[13,pad_opt$7,fmtty,fmt]];
         case 9:
          var fmtty$0=ign[2],pad_opt$8=ign[1];
          return [0,[14,pad_opt$8,fmtty$0,fmt]];
         case 10:
          var char_set=ign[2],width_opt=ign[1];
          return [0,[20,width_opt,char_set,fmt]];
         default:var counter=ign[1];return [0,[21,counter,fmt]]}}
    function default_float_precision(fconv){return 5 === fconv[2]?12:-6}
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       min_len=buf[1] + overhead | 0,
       _uh_=len < min_len?1:0;
      if(_uh_)
       {var
         new_len=max$1(len * 2 | 0,min_len),
         new_str=caml_create_bytes(new_len);
        blit(buf[2],0,new_str,0,len);
        buf[2] = new_str;
        var _ui_=0}
      else
       var _ui_=_uh_;
      return _ui_}
    function buffer_add_char(buf,c)
     {buffer_check_size(buf,1);
      caml_bytes_set(buf[2],buf[1],c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      blit$0(s,0,buf[2],buf[1],str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function char_of_iconv(iconv)
     {switch(iconv)
       {case 6:
        case 7:return 120;
        case 8:
        case 9:return 88;
        case 10:
        case 11:return 111;
        case 12:
        case 15:return 117;
        case 0:
        case 1:
        case 2:
        case 13:return 100;
        default:return 105}}
    function char_of_fconv(opt,fconv)
     {if(opt)var sth=opt[1],cF=sth;else var cF=70;
      switch(fconv[2])
       {case 0:return 102;
        case 1:return 101;
        case 2:return 69;
        case 3:return 103;
        case 4:return 71;
        case 5:return cF;
        case 6:return 104;
        case 7:return 72;
        default:return 70}}
    function bprint_padty(buf,padty)
     {switch(padty)
       {case 0:return buffer_add_char(buf,45);
        case 1:return 0;
        default:return buffer_add_char(buf,48)}}
    function bprint_ignored_flag(buf,ign_flag)
     {return ign_flag?buffer_add_char(buf,95):ign_flag}
    function bprint_pad_opt(buf,pad_opt)
     {if(pad_opt)
       {var width=pad_opt[1];
        return buffer_add_string(buf,caml_string_of_jsbytes("" + width))}
      return 0}
    function bprint_padding(buf,pad)
     {if(typeof pad === "number")
       return 0;
      else
       {if(0 === pad[0])
         {var n=pad[2],padty=pad[1];
          bprint_padty(buf,padty);
          return buffer_add_string(buf,caml_string_of_jsbytes("" + n))}
        var padty$0=pad[1];
        bprint_padty(buf,padty$0);
        return buffer_add_char(buf,42)}}
    function bprint_precision(buf,prec)
     {if(typeof prec === "number")return prec?buffer_add_string(buf,cst$11):0;
      var n=prec[1];
      buffer_add_char(buf,46);
      return buffer_add_string(buf,caml_string_of_jsbytes("" + n))}
    function bprint_iconv_flag(buf,iconv)
     {switch(iconv)
       {case 1:
        case 4:return buffer_add_char(buf,43);
        case 2:
        case 5:return buffer_add_char(buf,32);
        case 7:
        case 9:
        case 11:
        case 13:
        case 14:
        case 15:return buffer_add_char(buf,35);
        default:return 0}}
    function bprint_altint_fmt(buf,ign_flag,iconv,pad,prec,c)
     {buffer_add_char(buf,37);
      bprint_ignored_flag(buf,ign_flag);
      bprint_iconv_flag(buf,iconv);
      bprint_padding(buf,pad);
      bprint_precision(buf,prec);
      buffer_add_char(buf,c);
      return buffer_add_char(buf,char_of_iconv(iconv))}
    function bprint_fconv_flag(buf,fconv)
     {switch(fconv[1])
       {case 0:break;
        case 1:buffer_add_char(buf,43);break;
        default:buffer_add_char(buf,32)}
      return 8 <= fconv[2]?buffer_add_char(buf,35):0}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return cst$12;
         case 1:return cst$13;
         case 2:return cst$14;
         case 3:return cst$15;
         case 4:return cst$16;
         case 5:return cst$17;
         default:return cst$18}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:var c=formatting_lit[1];return cat(cst$19,make$1(1,c))}}
    function bprint_char_literal(buf,chr)
     {return 37 === chr?buffer_add_string(buf,cst$20):buffer_add_char(buf,chr)}
    function bprint_string_literal(buf,str)
     {var _uf_=caml_ml_string_length(str) - 1 | 0,_ue_=0;
      if(! (_uf_ < 0))
       {var i=_ue_;
        for(;;)
         {bprint_char_literal(buf,caml_string_get(str,i));
          var _ug_=i + 1 | 0;
          if(_uf_ !== i){var i=_ug_;continue}
          break}}
      return 0}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var rest=fmtty$0[1];
           buffer_add_string(buf,cst_c);
           var fmtty$0=rest;
           continue;
          case 1:
           var rest$0=fmtty$0[1];
           buffer_add_string(buf,cst_s);
           var fmtty$0=rest$0;
           continue;
          case 2:
           var rest$1=fmtty$0[1];
           buffer_add_string(buf,cst_i);
           var fmtty$0=rest$1;
           continue;
          case 3:
           var rest$2=fmtty$0[1];
           buffer_add_string(buf,cst_li);
           var fmtty$0=rest$2;
           continue;
          case 4:
           var rest$3=fmtty$0[1];
           buffer_add_string(buf,cst_ni);
           var fmtty$0=rest$3;
           continue;
          case 5:
           var rest$4=fmtty$0[1];
           buffer_add_string(buf,cst_Li);
           var fmtty$0=rest$4;
           continue;
          case 6:
           var rest$5=fmtty$0[1];
           buffer_add_string(buf,cst_f);
           var fmtty$0=rest$5;
           continue;
          case 7:
           var rest$6=fmtty$0[1];
           buffer_add_string(buf,cst_B);
           var fmtty$0=rest$6;
           continue;
          case 8:
           var rest$7=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,cst$21);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,cst$22);
           var fmtty$0=rest$7;
           continue;
          case 9:
           var rest$8=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,cst$23);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,cst$24);
           var fmtty$0=rest$8;
           continue;
          case 10:
           var rest$9=fmtty$0[1];
           buffer_add_string(buf,cst_a);
           var fmtty$0=rest$9;
           continue;
          case 11:
           var rest$10=fmtty$0[1];
           buffer_add_string(buf,cst_t$0);
           var fmtty$0=rest$10;
           continue;
          case 12:
           var rest$11=fmtty$0[1];
           buffer_add_string(buf,cst$25);
           var fmtty$0=rest$11;
           continue;
          case 13:
           var rest$12=fmtty$0[1];
           buffer_add_string(buf,cst_r$0);
           var fmtty$0=rest$12;
           continue;
          default:
           var rest$13=fmtty$0[1];
           buffer_add_string(buf,cst_r$1);
           var fmtty$0=rest$13;
           continue}}
    function int_of_custom_arity(param)
     {if(param){var x=param[1];return 1 + int_of_custom_arity(x) | 0}return 0}
    function string_of_fmt(fmt)
     {var buf=buffer_create(16);
      function fmtiter(fmt,ign_flag)
       {var fmt$0=fmt,ign_flag$0=ign_flag;
        a:
        for(;;)
         if(typeof fmt$0 === "number")
          return 0;
         else
          switch(fmt$0[0])
           {case 0:
             var rest=fmt$0[1];
             buffer_add_char(buf,37);
             bprint_ignored_flag(buf,ign_flag$0);
             buffer_add_char(buf,99);
             var fmt$0=rest,ign_flag$0=0;
             continue;
            case 1:
             var rest$0=fmt$0[1];
             buffer_add_char(buf,37);
             bprint_ignored_flag(buf,ign_flag$0);
             buffer_add_char(buf,67);
             var fmt$0=rest$0,ign_flag$0=0;
             continue;
            case 2:
             var rest$1=fmt$0[2],pad=fmt$0[1];
             buffer_add_char(buf,37);
             bprint_ignored_flag(buf,ign_flag$0);
             bprint_padding(buf,pad);
             buffer_add_char(buf,115);
             var fmt$0=rest$1,ign_flag$0=0;
             continue;
            case 3:
             var rest$2=fmt$0[2],pad$0=fmt$0[1];
             buffer_add_char(buf,37);
             bprint_ignored_flag(buf,ign_flag$0);
             bprint_padding(buf,pad$0);
             buffer_add_char(buf,83);
             var fmt$0=rest$2,ign_flag$0=0;
             continue;
            case 4:
             var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
             buffer_add_char(buf,37);
             bprint_ignored_flag(buf,ign_flag$0);
             bprint_iconv_flag(buf,iconv);
             bprint_padding(buf,pad$1);
             bprint_precision(buf,prec);
             buffer_add_char(buf,char_of_iconv(iconv));
             var fmt$0=rest$3,ign_flag$0=0;
             continue;
            case 5:
             var
              rest$4=fmt$0[4],
              prec$0=fmt$0[3],
              pad$2=fmt$0[2],
              iconv$0=fmt$0[1];
             bprint_altint_fmt(buf,ign_flag$0,iconv$0,pad$2,prec$0,108);
             var fmt$0=rest$4,ign_flag$0=0;
             continue;
            case 6:
             var
              rest$5=fmt$0[4],
              prec$1=fmt$0[3],
              pad$3=fmt$0[2],
              iconv$1=fmt$0[1];
             bprint_altint_fmt(buf,ign_flag$0,iconv$1,pad$3,prec$1,110);
             var fmt$0=rest$5,ign_flag$0=0;
             continue;
            case 7:
             var
              rest$6=fmt$0[4],
              prec$2=fmt$0[3],
              pad$4=fmt$0[2],
              iconv$2=fmt$0[1];
             bprint_altint_fmt(buf,ign_flag$0,iconv$2,pad$4,prec$2,76);
             var fmt$0=rest$6,ign_flag$0=0;
             continue;
            case 8:
             var
              rest$7=fmt$0[4],
              prec$3=fmt$0[3],
              pad$5=fmt$0[2],
              fconv=fmt$0[1];
             buffer_add_char(buf,37);
             bprint_ignored_flag(buf,ign_flag$0);
             bprint_fconv_flag(buf,fconv);
             bprint_padding(buf,pad$5);
             bprint_precision(buf,prec$3);
             buffer_add_char(buf,char_of_fconv(0,fconv));
             var fmt$0=rest$7,ign_flag$0=0;
             continue;
            case 9:
             var rest$8=fmt$0[2],pad$6=fmt$0[1];
             buffer_add_char(buf,37);
             bprint_ignored_flag(buf,ign_flag$0);
             bprint_padding(buf,pad$6);
             buffer_add_char(buf,66);
             var fmt$0=rest$8,ign_flag$0=0;
             continue;
            case 10:
             var rest$9=fmt$0[1];
             buffer_add_string(buf,cst$26);
             var fmt$0=rest$9;
             continue;
            case 11:
             var rest$10=fmt$0[2],str=fmt$0[1];
             bprint_string_literal(buf,str);
             var fmt$0=rest$10;
             continue;
            case 12:
             var rest$11=fmt$0[2],chr$0=fmt$0[1];
             bprint_char_literal(buf,chr$0);
             var fmt$0=rest$11;
             continue;
            case 13:
             var rest$12=fmt$0[3],fmtty=fmt$0[2],pad_opt=fmt$0[1];
             buffer_add_char(buf,37);
             bprint_ignored_flag(buf,ign_flag$0);
             bprint_pad_opt(buf,pad_opt);
             buffer_add_char(buf,123);
             bprint_fmtty(buf,fmtty);
             buffer_add_char(buf,37);
             buffer_add_char(buf,125);
             var fmt$0=rest$12,ign_flag$0=0;
             continue;
            case 14:
             var rest$13=fmt$0[3],fmtty$0=fmt$0[2],pad_opt$0=fmt$0[1];
             buffer_add_char(buf,37);
             bprint_ignored_flag(buf,ign_flag$0);
             bprint_pad_opt(buf,pad_opt$0);
             buffer_add_char(buf,40);
             bprint_fmtty(buf,fmtty$0);
             buffer_add_char(buf,37);
             buffer_add_char(buf,41);
             var fmt$0=rest$13,ign_flag$0=0;
             continue;
            case 15:
             var rest$14=fmt$0[1];
             buffer_add_char(buf,37);
             bprint_ignored_flag(buf,ign_flag$0);
             buffer_add_char(buf,97);
             var fmt$0=rest$14,ign_flag$0=0;
             continue;
            case 16:
             var rest$15=fmt$0[1];
             buffer_add_char(buf,37);
             bprint_ignored_flag(buf,ign_flag$0);
             buffer_add_char(buf,116);
             var fmt$0=rest$15,ign_flag$0=0;
             continue;
            case 17:
             var rest$16=fmt$0[2],fmting_lit=fmt$0[1];
             bprint_string_literal(buf,string_of_formatting_lit(fmting_lit));
             var fmt$0=rest$16;
             continue;
            case 18:
             var rest$17=fmt$0[2],fmting_gen=fmt$0[1];
             if(0 === fmting_gen[0])
              {var match$1=fmting_gen[1],str$0=match$1[2];
               buffer_add_string(buf,cst$27);
               buffer_add_string(buf,str$0)}
             else
              {var match$2=fmting_gen[1],str$1=match$2[2];
               buffer_add_string(buf,cst$28);
               buffer_add_string(buf,str$1)}
             var fmt$0=rest$17;
             continue;
            case 19:
             var rest$18=fmt$0[1];
             buffer_add_char(buf,37);
             bprint_ignored_flag(buf,ign_flag$0);
             buffer_add_char(buf,114);
             var fmt$0=rest$18,ign_flag$0=0;
             continue;
            case 20:
             var rest$19=fmt$0[3],char_set=fmt$0[2],width_opt=fmt$0[1];
             buffer_add_char(buf,37);
             bprint_ignored_flag(buf,ign_flag$0);
             bprint_pad_opt(buf,width_opt);
             var
              print_char=
               function(buf,i)
                {var c=char_of_int(i);
                 return 37 === c
                         ?(buffer_add_char(buf,37),buffer_add_char(buf,37))
                         :64 === c
                           ?(buffer_add_char(buf,37),buffer_add_char(buf,64))
                           :buffer_add_char(buf,c)};
             buffer_add_char(buf,91);
             var
              _t6_=
               is_in_char_set(char_set,0)
                ?(buffer_add_char(buf,94),rev_char_set(char_set))
                :char_set,
              is_alone$0=
               function(_t$_)
                {function is_alone(c)
                  {var
                    after=chr(c + 1 | 0),
                    before=chr(c - 1 | 0),
                    _ua_=is_in_char_set(_t$_,c);
                   if(_ua_)
                    var
                     _ub_=is_in_char_set(_t$_,before),
                     _uc_=_ub_?is_in_char_set(_t$_,after):_ub_,
                     _ud_=1 - _uc_;
                   else
                    var _ud_=_ua_;
                   return _ud_}
                 return is_alone},
              is_alone=is_alone$0(_t6_);
             if(is_alone(93))buffer_add_char(buf,93);
             var i=1;
             b:
             for(;;)
              {if(i < 256)
                {if(! is_in_char_set(_t6_,char_of_int(i)))
                  {var i$0=i + 1 | 0,i=i$0;continue}
                 var match=char_of_int(i),switcher=match - 45 | 0,switch$0=0;
                 if(48 < switcher >>> 0)
                  if(210 <= switcher)print_char(buf,255);else switch$0 = 1;
                 else
                  {if(46 < switcher - 1 >>> 0)
                    {var i$2=i + 1 | 0,i=i$2;continue}
                   switch$0 = 1}
                 if(switch$0)
                  {var i$1=i + 1 | 0;
                   if(! is_in_char_set(_t6_,char_of_int(i$1)))
                    {print_char(buf,i$1 - 1 | 0);
                     var i$6=i$1 + 1 | 0,i=i$6;
                     continue}
                   var
                    match$0=char_of_int(i$1),
                    switcher$0=match$0 - 45 | 0,
                    switch$1=0;
                   if(48 < switcher$0 >>> 0)
                    if(210 <= switcher$0)
                     {print_char(buf,254);print_char(buf,255)}
                    else
                     switch$1 = 1;
                   else
                    if(46 < switcher$0 - 1 >>> 0)
                     {if(! is_in_char_set(_t6_,char_of_int(i$1 + 1 | 0)))
                       {print_char(buf,i$1 - 1 | 0);
                        var i$5=i$1 + 1 | 0,i=i$5;
                        continue}
                      switch$1 = 1}
                    else
                     switch$1 = 1;
                   if(switch$1)
                    {if(! is_in_char_set(_t6_,char_of_int(i$1 + 1 | 0)))
                      {print_char(buf,i$1 - 1 | 0);
                       print_char(buf,i$1);
                       var i$4=i$1 + 2 | 0,i=i$4;
                       continue}
                     var j=i$1 + 2 | 0,i$3=i$1 - 1 | 0,j$0=j;
                     for(;;)
                      {if(256 !== j$0 && is_in_char_set(_t6_,char_of_int(j$0)))
                        {var j$1=j$0 + 1 | 0,j$0=j$1;continue}
                       print_char(buf,i$3);
                       print_char(buf,45);
                       print_char(buf,j$0 - 1 | 0);
                       if(j$0 < 256){var i$7=j$0 + 1 | 0,i=i$7;continue b}
                       break}}}}
               if(is_alone(45))buffer_add_char(buf,45);
               buffer_add_char(buf,93);
               var fmt$0=rest$19,ign_flag$0=0;
               continue a}
            case 21:
             var rest$20=fmt$0[2],counter=fmt$0[1];
             buffer_add_char(buf,37);
             bprint_ignored_flag(buf,ign_flag$0);
             switch(counter)
              {case 0:var _t7_=108;break;
               case 1:var _t7_=110;break;
               default:var _t7_=78}
             buffer_add_char(buf,_t7_);
             var fmt$0=rest$20,ign_flag$0=0;
             continue;
            case 22:
             var rest$21=fmt$0[1];
             buffer_add_char(buf,37);
             bprint_ignored_flag(buf,ign_flag$0);
             bprint_string_literal(buf,cst_0c);
             var fmt$0=rest$21,ign_flag$0=0;
             continue;
            case 23:
             var
              rest$22=fmt$0[2],
              ign=fmt$0[1],
              match$3=param_format_of_ignored_format(ign,rest$22),
              fmt$1=match$3[1],
              fmt$0=fmt$1,
              ign_flag$0=1;
             continue;
            default:
             var
              rest$23=fmt$0[3],
              arity=fmt$0[1],
              _t9_=int_of_custom_arity(arity),
              _t8_=1;
             if(! (_t9_ < 1))
              {var i$8=_t8_;
               for(;;)
                {buffer_add_char(buf,37);
                 bprint_ignored_flag(buf,ign_flag$0);
                 buffer_add_char(buf,63);
                 var _t__=i$8 + 1 | 0;
                 if(_t9_ !== i$8){var i$8=_t__;continue}
                 break}}
             var fmt$0=rest$23,ign_flag$0=0;
             continue}}
      fmtiter(fmt,0);
      return buffer_contents(buf)}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function trans(ty1,ty2)
     {var switch$0=0;
      if(typeof ty1 === "number")
       if(typeof ty2 === "number")
        return 0;
       else
        switch(ty2[0])
         {case 10:break;
          case 11:switch$0 = 1;break;
          case 12:switch$0 = 2;break;
          case 13:switch$0 = 3;break;
          case 14:switch$0 = 4;break;
          case 8:switch$0 = 5;break;
          case 9:switch$0 = 6;break;
          default:throw [0,Assert_failure,_aa_]}
      else
       switch(ty1[0])
        {case 0:
          var switch$1=0,_tN_=ty1[1];
          if(typeof ty2 !== "number")
           switch(ty2[0])
            {case 0:var rest2=ty2[1];return [0,trans(_tN_,rest2)];
             case 8:switch$0 = 5;switch$1 = 1;break;
             case 9:switch$0 = 6;switch$1 = 1;break;
             case 10:switch$1 = 1;break;
             case 11:switch$0 = 1;switch$1 = 1;break;
             case 12:switch$0 = 2;switch$1 = 1;break;
             case 13:switch$0 = 3;switch$1 = 1;break;
             case 14:switch$0 = 4;switch$1 = 1;break
             }
          if(! switch$1)switch$0 = 7;
          break;
         case 1:
          var switch$2=0,_tO_=ty1[1];
          if(typeof ty2 !== "number")
           switch(ty2[0])
            {case 1:var rest2$0=ty2[1];return [1,trans(_tO_,rest2$0)];
             case 8:switch$0 = 5;switch$2 = 1;break;
             case 9:switch$0 = 6;switch$2 = 1;break;
             case 10:switch$2 = 1;break;
             case 11:switch$0 = 1;switch$2 = 1;break;
             case 12:switch$0 = 2;switch$2 = 1;break;
             case 13:switch$0 = 3;switch$2 = 1;break;
             case 14:switch$0 = 4;switch$2 = 1;break
             }
          if(! switch$2)switch$0 = 7;
          break;
         case 2:
          var switch$3=0,_tP_=ty1[1];
          if(typeof ty2 === "number")
           switch$3 = 1;
          else
           switch(ty2[0])
            {case 2:var rest2$1=ty2[1];return [2,trans(_tP_,rest2$1)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$3 = 1}
          if(switch$3)switch$0 = 7;
          break;
         case 3:
          var switch$4=0,_tQ_=ty1[1];
          if(typeof ty2 === "number")
           switch$4 = 1;
          else
           switch(ty2[0])
            {case 3:var rest2$2=ty2[1];return [3,trans(_tQ_,rest2$2)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$4 = 1}
          if(switch$4)switch$0 = 7;
          break;
         case 4:
          var switch$5=0,_tR_=ty1[1];
          if(typeof ty2 === "number")
           switch$5 = 1;
          else
           switch(ty2[0])
            {case 4:var rest2$3=ty2[1];return [4,trans(_tR_,rest2$3)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$5 = 1}
          if(switch$5)switch$0 = 7;
          break;
         case 5:
          var switch$6=0,_tS_=ty1[1];
          if(typeof ty2 === "number")
           switch$6 = 1;
          else
           switch(ty2[0])
            {case 5:var rest2$4=ty2[1];return [5,trans(_tS_,rest2$4)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$6 = 1}
          if(switch$6)switch$0 = 7;
          break;
         case 6:
          var switch$7=0,_tT_=ty1[1];
          if(typeof ty2 === "number")
           switch$7 = 1;
          else
           switch(ty2[0])
            {case 6:var rest2$5=ty2[1];return [6,trans(_tT_,rest2$5)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$7 = 1}
          if(switch$7)switch$0 = 7;
          break;
         case 7:
          var switch$8=0,_tU_=ty1[1];
          if(typeof ty2 === "number")
           switch$8 = 1;
          else
           switch(ty2[0])
            {case 7:var rest2$6=ty2[1];return [7,trans(_tU_,rest2$6)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$8 = 1}
          if(switch$8)switch$0 = 7;
          break;
         case 8:
          var switch$9=0,_tV_=ty1[2],_tW_=ty1[1];
          if(typeof ty2 === "number")
           switch$9 = 1;
          else
           switch(ty2[0])
            {case 8:
              var rest2$7=ty2[2],ty2$0=ty2[1],_tX_=trans(_tV_,rest2$7);
              return [8,trans(_tW_,ty2$0),_tX_];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$9 = 1}
          if(switch$9)throw [0,Assert_failure,_aj_];
          break;
         case 9:
          var switch$10=0,_tY_=ty1[3],_tZ_=ty1[2],_t0_=ty1[1];
          if(typeof ty2 === "number")
           switch$10 = 1;
          else
           switch(ty2[0])
            {case 8:switch$0 = 5;break;
             case 9:
              var
               rest2$8=ty2[3],
               ty22=ty2[2],
               ty21=ty2[1],
               ty=trans(symm(_tZ_),ty21),
               match=fmtty_rel_det(ty),
               f4=match[4],
               f2=match[2];
              caml_call1(f2,0);
              caml_call1(f4,0);
              return [9,_t0_,ty22,trans(_tY_,rest2$8)];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$10 = 1}
          if(switch$10)throw [0,Assert_failure,_ak_];
          break;
         case 10:
          var _t1_=ty1[1];
          if(typeof ty2 !== "number" && 10 === ty2[0])
           {var rest2$9=ty2[1];return [10,trans(_t1_,rest2$9)]}
          throw [0,Assert_failure,_al_];
         case 11:
          var switch$11=0,_t2_=ty1[1];
          if(typeof ty2 === "number")
           switch$11 = 1;
          else
           switch(ty2[0])
            {case 10:break;
             case 11:var rest2$10=ty2[1];return [11,trans(_t2_,rest2$10)];
             default:switch$11 = 1}
          if(switch$11)throw [0,Assert_failure,_am_];
          break;
         case 12:
          var switch$12=0,_t3_=ty1[1];
          if(typeof ty2 === "number")
           switch$12 = 1;
          else
           switch(ty2[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:var rest2$11=ty2[1];return [12,trans(_t3_,rest2$11)];
             default:switch$12 = 1}
          if(switch$12)throw [0,Assert_failure,_an_];
          break;
         case 13:
          var switch$13=0,_t4_=ty1[1];
          if(typeof ty2 === "number")
           switch$13 = 1;
          else
           switch(ty2[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:var rest2$12=ty2[1];return [13,trans(_t4_,rest2$12)];
             default:switch$13 = 1}
          if(switch$13)throw [0,Assert_failure,_ao_];
          break;
         default:
          var switch$14=0,_t5_=ty1[1];
          if(typeof ty2 === "number")
           switch$14 = 1;
          else
           switch(ty2[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:var rest2$13=ty2[1];return [14,trans(_t5_,rest2$13)];
             default:switch$14 = 1}
          if(switch$14)throw [0,Assert_failure,_ap_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_ad_];
        case 1:throw [0,Assert_failure,_ae_];
        case 2:throw [0,Assert_failure,_af_];
        case 3:throw [0,Assert_failure,_ag_];
        case 4:throw [0,Assert_failure,_ah_];
        case 5:throw [0,Assert_failure,_ab_];
        case 6:throw [0,Assert_failure,_ac_];
        default:throw [0,Assert_failure,_ai_]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _tp_=function(param){return 0},
         _tq_=function(param){return 0},
         _tr_=function(param){return 0};
        return [0,function(param){return 0},_tr_,_tq_,_tp_]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _ts_=function(param){caml_call1(af,0);return 0};
          return [0,function(param){caml_call1(fa,0);return 0},_ts_,ed,de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _tt_=function(param){caml_call1(af$0,0);return 0};
          return [0,
                  function(param){caml_call1(fa$0,0);return 0},
                  _tt_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _tu_=function(param){caml_call1(af$1,0);return 0};
          return [0,
                  function(param){caml_call1(fa$1,0);return 0},
                  _tu_,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _tv_=function(param){caml_call1(af$2,0);return 0};
          return [0,
                  function(param){caml_call1(fa$2,0);return 0},
                  _tv_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _tw_=function(param){caml_call1(af$3,0);return 0};
          return [0,
                  function(param){caml_call1(fa$3,0);return 0},
                  _tw_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _tx_=function(param){caml_call1(af$4,0);return 0};
          return [0,
                  function(param){caml_call1(fa$4,0);return 0},
                  _tx_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _ty_=function(param){caml_call1(af$5,0);return 0};
          return [0,
                  function(param){caml_call1(fa$5,0);return 0},
                  _ty_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _tz_=function(param){caml_call1(af$6,0);return 0};
          return [0,
                  function(param){caml_call1(fa$6,0);return 0},
                  _tz_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _tA_=function(param){caml_call1(af$7,0);return 0};
          return [0,
                  function(param){caml_call1(fa$7,0);return 0},
                  _tA_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           ty=trans(symm(ty1),ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _tB_=function(param){caml_call1(jd,0);caml_call1(de$8,0);return 0},
           _tC_=function(param){caml_call1(ed$8,0);caml_call1(dj,0);return 0},
           _tD_=function(param){caml_call1(ga,0);caml_call1(af$8,0);return 0};
          return [0,
                  function(param)
                   {caml_call1(fa$8,0);caml_call1(ag,0);return 0},
                  _tD_,
                  _tC_,
                  _tB_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _tE_=function(param){caml_call1(af$9,0);return 0};
          return [0,
                  function(param){caml_call1(fa$9,0);return 0},
                  _tE_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _tF_=function(param){caml_call1(af$10,0);return 0};
          return [0,
                  function(param){caml_call1(fa$10,0);return 0},
                  _tF_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _tG_=function(param){caml_call1(af$11,0);return 0};
          return [0,
                  function(param){caml_call1(fa$11,0);return 0},
                  _tG_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _tH_=function(param){caml_call1(de$12,0);return 0},
           _tI_=function(param){caml_call1(ed$12,0);return 0},
           _tJ_=function(param){caml_call1(af$12,0);return 0};
          return [0,
                  function(param){caml_call1(fa$12,0);return 0},
                  _tJ_,
                  _tI_,
                  _tH_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           _tK_=function(param){caml_call1(de$13,0);return 0},
           _tL_=function(param){caml_call1(ed$13,0);return 0},
           _tM_=function(param){caml_call1(af$13,0);return 0};
          return [0,
                  function(param){caml_call1(fa$13,0);return 0},
                  _tM_,
                  _tL_,
                  _tK_]}}
    function fmtty_of_precision_fmtty(prec,fmtty)
     {return typeof prec === "number"?prec?[2,fmtty]:fmtty:fmtty}
    function fmtty_of_padding_fmtty(pad,fmtty)
     {return typeof pad === "number"?fmtty:0 === pad[0]?fmtty:[2,fmtty]}
    function fmtty_of_custom(arity,fmtty)
     {if(arity)
       {var arity$0=arity[1];return [12,fmtty_of_custom(arity$0,fmtty)]}
      return fmtty}
    function fmtty_of_fmt(fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:var rest=fmtty$0[1];return [0,fmtty_of_fmt(rest)];
          case 1:var rest$0=fmtty$0[1];return [0,fmtty_of_fmt(rest$0)];
          case 2:
           var rest$1=fmtty$0[2],pad=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad,[1,fmtty_of_fmt(rest$1)]);
          case 3:
           var rest$2=fmtty$0[2],pad$0=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$0,[1,fmtty_of_fmt(rest$2)]);
          case 4:
           var
            rest$3=fmtty$0[4],
            prec=fmtty$0[3],
            pad$1=fmtty$0[2],
            ty_rest=fmtty_of_fmt(rest$3),
            prec_ty=fmtty_of_precision_fmtty(prec,[2,ty_rest]);
           return fmtty_of_padding_fmtty(pad$1,prec_ty);
          case 5:
           var
            rest$4=fmtty$0[4],
            prec$0=fmtty$0[3],
            pad$2=fmtty$0[2],
            ty_rest$0=fmtty_of_fmt(rest$4),
            prec_ty$0=fmtty_of_precision_fmtty(prec$0,[3,ty_rest$0]);
           return fmtty_of_padding_fmtty(pad$2,prec_ty$0);
          case 6:
           var
            rest$5=fmtty$0[4],
            prec$1=fmtty$0[3],
            pad$3=fmtty$0[2],
            ty_rest$1=fmtty_of_fmt(rest$5),
            prec_ty$1=fmtty_of_precision_fmtty(prec$1,[4,ty_rest$1]);
           return fmtty_of_padding_fmtty(pad$3,prec_ty$1);
          case 7:
           var
            rest$6=fmtty$0[4],
            prec$2=fmtty$0[3],
            pad$4=fmtty$0[2],
            ty_rest$2=fmtty_of_fmt(rest$6),
            prec_ty$2=fmtty_of_precision_fmtty(prec$2,[5,ty_rest$2]);
           return fmtty_of_padding_fmtty(pad$4,prec_ty$2);
          case 8:
           var
            rest$7=fmtty$0[4],
            prec$3=fmtty$0[3],
            pad$5=fmtty$0[2],
            ty_rest$3=fmtty_of_fmt(rest$7),
            prec_ty$3=fmtty_of_precision_fmtty(prec$3,[6,ty_rest$3]);
           return fmtty_of_padding_fmtty(pad$5,prec_ty$3);
          case 9:
           var rest$8=fmtty$0[2],pad$6=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$6,[7,fmtty_of_fmt(rest$8)]);
          case 10:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 11:var fmtty$2=fmtty$0[2],fmtty$0=fmtty$2;continue;
          case 12:var fmtty$3=fmtty$0[2],fmtty$0=fmtty$3;continue;
          case 13:
           var rest$9=fmtty$0[3],ty=fmtty$0[2];
           return [8,ty,fmtty_of_fmt(rest$9)];
          case 14:
           var rest$10=fmtty$0[3],ty$0=fmtty$0[2];
           return [9,ty$0,ty$0,fmtty_of_fmt(rest$10)];
          case 15:var rest$11=fmtty$0[1];return [10,fmtty_of_fmt(rest$11)];
          case 16:var rest$12=fmtty$0[1];return [11,fmtty_of_fmt(rest$12)];
          case 17:var fmtty$4=fmtty$0[2],fmtty$0=fmtty$4;continue;
          case 18:
           var
            rest$13=fmtty$0[2],
            fmting_gen=fmtty$0[1],
            _tn_=fmtty_of_fmt(rest$13);
           if(0 === fmting_gen[0])
            var match=fmting_gen[1],fmt=match[1],_to_=fmtty_of_fmt(fmt);
           else
            var
             match$0=fmting_gen[1],
             fmt$0=match$0[1],
             _to_=fmtty_of_fmt(fmt$0);
           return concat_fmtty(_to_,_tn_);
          case 19:var rest$14=fmtty$0[1];return [13,fmtty_of_fmt(rest$14)];
          case 20:var rest$15=fmtty$0[3];return [1,fmtty_of_fmt(rest$15)];
          case 21:var rest$16=fmtty$0[2];return [2,fmtty_of_fmt(rest$16)];
          case 22:var rest$17=fmtty$0[1];return [0,fmtty_of_fmt(rest$17)];
          case 23:
           var rest$18=fmtty$0[2],ign=fmtty$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:return [14,fmtty_of_fmt(rest$18)];
              default:var fmtty$0=rest$18;continue}
           else
            switch(ign[0])
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:var fmtty$0=rest$18;continue;
              case 3:var fmtty$0=rest$18;continue;
              case 4:var fmtty$0=rest$18;continue;
              case 5:var fmtty$0=rest$18;continue;
              case 6:var fmtty$0=rest$18;continue;
              case 7:var fmtty$0=rest$18;continue;
              case 8:var fmtty$0=rest$18;continue;
              case 9:
               var fmtty$5=ign[2];
               return concat_fmtty(fmtty$5,fmtty_of_fmt(rest$18));
              case 10:var fmtty$0=rest$18;continue;
              default:var fmtty$0=rest$18;continue}
          default:
           var rest$19=fmtty$0[3],arity=fmtty$0[1];
           return fmtty_of_custom(arity,fmtty_of_fmt(rest$19))}}
    var
     Type_mismatch=
      [248,cst_CamlinternalFormat_Type_mi,caml_fresh_oo_id(0)];
    function type_padding(pad,fmtty)
     {if(typeof pad === "number")
       return [0,0,fmtty];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],fmtty]}
        if(typeof fmtty !== "number" && 2 === fmtty[0])
         {var rest=fmtty[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(prec)
         {var _tm_=match[2];
          if(typeof _tm_ !== "number" && 2 === _tm_[0])
           {var rest=_tm_[1],pad$0=match[1];return [0,pad$0,1,rest]}
          throw Type_mismatch}
        var rest$0=match[2],pad$1=match[1];
        return [0,pad$1,0,rest$0]}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_ignored_format_substituti(sub_fmtty,fmt,fmtty)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,fmtty)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             sub_fmtty_rest=sub_fmtty[1],
             match=
              type_ignored_format_substituti(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match[2],
             sub_fmtty_rest$0=match[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$0=
              type_ignored_format_substituti
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$0[2],
             sub_fmtty_rest$2=match$0[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$1=fmtty[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$1=
              type_ignored_format_substituti
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$1[2],
             sub_fmtty_rest$4=match$1[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof fmtty !== "number" && 3 === fmtty[0])
           {var
             fmtty_rest$2=fmtty[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$2=
              type_ignored_format_substituti
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$2[2],
             sub_fmtty_rest$6=match$2[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof fmtty !== "number" && 4 === fmtty[0])
           {var
             fmtty_rest$3=fmtty[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$3=
              type_ignored_format_substituti
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$3[2],
             sub_fmtty_rest$8=match$3[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof fmtty !== "number" && 5 === fmtty[0])
           {var
             fmtty_rest$4=fmtty[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$4=
              type_ignored_format_substituti
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$4[2],
             sub_fmtty_rest$10=match$4[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof fmtty !== "number" && 6 === fmtty[0])
           {var
             fmtty_rest$5=fmtty[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$5=
              type_ignored_format_substituti
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$5[2],
             sub_fmtty_rest$12=match$5[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof fmtty !== "number" && 7 === fmtty[0])
           {var
             fmtty_rest$6=fmtty[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$6=
              type_ignored_format_substituti
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$6[2],
             sub_fmtty_rest$14=match$6[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$7=fmtty[2],
             sub2_fmtty=fmtty[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1];
            if(caml_notequal([0,sub2_fmtty$0],[0,sub2_fmtty]))
             throw Type_mismatch;
            var
             match$7=
              type_ignored_format_substituti
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$7[2],
             sub_fmtty_rest$16=match$7[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$8=fmtty[3],
             sub2_fmtty$1=fmtty[2],
             sub1_fmtty=fmtty[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _tk_=[0,erase_rel(sub1_fmtty)];
            if(caml_notequal([0,erase_rel(sub1_fmtty$0)],_tk_))
             throw Type_mismatch;
            var _tl_=[0,erase_rel(sub2_fmtty$1)];
            if(caml_notequal([0,erase_rel(sub2_fmtty$2)],_tl_))
             throw Type_mismatch;
            var
             sub_fmtty$0=trans(symm(sub1_fmtty),sub2_fmtty$1),
             match$8=fmtty_rel_det(sub_fmtty$0),
             f4=match$8[4],
             f2=match$8[2];
            caml_call1(f2,0);
            caml_call1(f4,0);
            var
             match$9=
              type_ignored_format_substituti
               (erase_rel(sub_fmtty_rest$17),fmt,fmtty_rest$8),
             fmt$9=match$9[2],
             sub_fmtty_rest$18=match$9[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$10=
              type_ignored_format_substituti
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$10[2],
             sub_fmtty_rest$20=match$10[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$11=
              type_ignored_format_substituti
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$11[2],
             sub_fmtty_rest$22=match$11[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$12=
              type_ignored_format_substituti
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$12[2],
             sub_fmtty_rest$24=match$12[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 14 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$13=
              type_ignored_format_substituti
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$13[2],
             sub_fmtty_rest$26=match$13[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           match$1=type_padding(pad,fmtty),
           _s5_=match$1[2],
           _s4_=match$1[1];
          if(typeof _s5_ !== "number" && 1 === _s5_[0])
           {var
             fmtty_rest$1=_s5_[1],
             match$2=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$2[2],
             fmt$2=match$2[1];
            return [0,[2,_s4_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           match$3=type_padding(pad$0,fmtty),
           _s7_=match$3[2],
           _s6_=match$3[1];
          if(typeof _s7_ !== "number" && 1 === _s7_[0])
           {var
             fmtty_rest$2=_s7_[1],
             match$4=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$4[2],
             fmt$3=match$4[1];
            return [0,[3,_s6_,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           match$5=type_padprec(pad$1,prec,fmtty),
           _s9_=match$5[3],
           _s8_=match$5[1];
          if(typeof _s9_ !== "number" && 2 === _s9_[0])
           {var
             fmtty_rest$3=_s9_[1],
             prec$0=match$5[2],
             match$6=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$6[2],
             fmt$4=match$6[1];
            return [0,[4,iconv,_s8_,prec$0,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$1=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           match$7=type_padprec(pad$2,prec$1,fmtty),
           _s$_=match$7[3],
           _s__=match$7[1];
          if(typeof _s$_ !== "number" && 3 === _s$_[0])
           {var
             fmtty_rest$4=_s$_[1],
             prec$2=match$7[2],
             match$8=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$8[2],
             fmt$5=match$8[1];
            return [0,[5,iconv$0,_s__,prec$2,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$3=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           match$9=type_padprec(pad$3,prec$3,fmtty),
           _tb_=match$9[3],
           _ta_=match$9[1];
          if(typeof _tb_ !== "number" && 4 === _tb_[0])
           {var
             fmtty_rest$5=_tb_[1],
             prec$4=match$9[2],
             match$10=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$10[2],
             fmt$6=match$10[1];
            return [0,[6,iconv$1,_ta_,prec$4,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$5=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           match$11=type_padprec(pad$4,prec$5,fmtty),
           _td_=match$11[3],
           _tc_=match$11[1];
          if(typeof _td_ !== "number" && 5 === _td_[0])
           {var
             fmtty_rest$6=_td_[1],
             prec$6=match$11[2],
             match$12=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$12[2],
             fmt$7=match$12[1];
            return [0,[7,iconv$2,_tc_,prec$6,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$7=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           match$13=type_padprec(pad$5,prec$7,fmtty),
           _tf_=match$13[3],
           _te_=match$13[1];
          if(typeof _tf_ !== "number" && 6 === _tf_[0])
           {var
             fmtty_rest$7=_tf_[1],
             prec$8=match$13[2],
             match$14=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$14[2],
             fmt$8=match$14[1];
            return [0,[8,fconv,_te_,prec$8,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           match$15=type_padding(pad$6,fmtty),
           _th_=match$15[2],
           _tg_=match$15[1];
          if(typeof _th_ !== "number" && 7 === _th_[0])
           {var
             fmtty_rest$8=_th_[1],
             match$16=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$16[2],
             fmt$9=match$16[1];
            return [0,[9,_tg_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$17=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$17[2],
           fmt$10=match$17[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$18=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$18[2],
           fmt$11=match$18[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$19=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$19[2],
           fmt$12=match$19[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1];
            if(caml_notequal([0,sub_fmtty$0],[0,sub_fmtty]))
             throw Type_mismatch;
            var
             match$20=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$20[2],
             fmt$13=match$20[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _ti_=[0,erase_rel(sub_fmtty1)];
            if(caml_notequal([0,erase_rel(sub_fmtty$1)],_ti_))
             throw Type_mismatch;
            var
             match$21=type_format_gen(fmt_rest$13,erase_rel(fmtty_rest$10)),
             fmtty$14=match$21[2],
             fmt$14=match$21[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$22=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$22[2],
             fmt$15=match$22[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$23=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$23[2],
             fmt$16=match$23[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$24=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$24[2],
           fmt$17=match$24[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          if(0 === formatting_gen[0])
           {var
             match$28=formatting_gen[1],
             str$0=match$28[2],
             fmt1=match$28[1],
             match$29=type_format_gen(fmt1,fmtty),
             fmtty2=match$29[2],
             fmt2=match$29[1],
             match$30=type_format_gen(fmt_rest$17,fmtty2),
             fmtty3=match$30[2],
             fmt3=match$30[1];
            return [0,[18,[0,[0,fmt2,str$0]],fmt3],fmtty3]}
          var
           match$31=formatting_gen[1],
           str$1=match$31[2],
           fmt1$0=match$31[1],
           match$32=type_format_gen(fmt1$0,fmtty),
           fmtty2$0=match$32[2],
           fmt2$0=match$32[1],
           match$33=type_format_gen(fmt_rest$17,fmtty2$0),
           fmtty3$0=match$33[2],
           fmt3$0=match$33[1];
          return [0,[18,[1,[0,fmt2$0,str$1]],fmt3$0],fmtty3$0];
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$25=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$25[2],
             fmt$18=match$25[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$26=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$26[2],
             fmt$19=match$26[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$27=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$27[2],
             fmt$20=match$27[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];
          if(typeof ign === "number")
           switch(ign)
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:
              if(typeof fmtty !== "number" && 14 === fmtty[0])
               {var
                 fmtty_rest$16=fmtty[1],
                 match$34=type_format_gen(rest,fmtty_rest$16),
                 fmtty$21=match$34[2],
                 fmt$21=match$34[1];
                return [0,[23,2,fmt$21],fmtty$21]}
              throw Type_mismatch;
             default:return type_ignored_param_one(ign,rest,fmtty)}
          else
           switch(ign[0])
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:return type_ignored_param_one(ign,rest,fmtty);
             case 3:return type_ignored_param_one(ign,rest,fmtty);
             case 4:return type_ignored_param_one(ign,rest,fmtty);
             case 5:return type_ignored_param_one(ign,rest,fmtty);
             case 6:return type_ignored_param_one(ign,rest,fmtty);
             case 7:return type_ignored_param_one(ign,rest,fmtty);
             case 8:
              var sub_fmtty$2=ign[2],pad_opt$1=ign[1];
              return type_ignored_param_one
                      ([8,pad_opt$1,sub_fmtty$2],rest,fmtty);
             case 9:
              var
               sub_fmtty$3=ign[2],
               pad_opt$2=ign[1],
               _tj_=type_ignored_format_substituti(sub_fmtty$3,rest,fmtty),
               match$35=_tj_[2],
               fmtty$22=match$35[2],
               fmt$22=match$35[1],
               sub_fmtty$4=_tj_[1];
              return [0,[23,[9,pad_opt$2,sub_fmtty$4],fmt$22],fmtty$22];
             case 10:return type_ignored_param_one(ign,rest,fmtty);
             default:return type_ignored_param_one(ign,rest,fmtty)}
         }
      throw Type_mismatch}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function type_format(fmt,fmtty)
     {var _s3_=type_format_gen(fmt,fmtty);
      if(typeof _s3_[2] === "number"){var fmt$0=_s3_[1];return fmt$0}
      throw Type_mismatch}
    function recast(fmt,fmtty){return type_format(fmt,erase_rel(symm(fmtty)))}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _s2_=2 === padty$0?48:32,res=make$0(width$0,_s2_);
      switch(padty$0)
       {case 0:blit$0(str,0,res,0,len);break;
        case 1:blit$0(str,0,res,width$0 - len | 0,len);break;
        default:
         var switch$0=0;
         if(0 < len)
          {var switch$1=0;
           if
            (43
             !==
             caml_string_get(str,0)
             &&
             45
             !==
             caml_string_get(str,0)
             &&
             32
             !==
             caml_string_get(str,0))
            {switch$0 = 1;switch$1 = 1}
           if(! switch$1)
            {caml_bytes_set(res,0,caml_string_get(str,0));
             blit$0(str,1,res,(width$0 - len | 0) + 1 | 0,len - 1 | 0)}}
         else
          switch$0 = 1;
         if(switch$0)
          {var switch$2=0;
           if(1 < len && 48 === caml_string_get(str,0))
            {var switch$3=0;
             if
              (120
               !==
               caml_string_get(str,1)
               &&
               88
               !==
               caml_string_get(str,1))
              {switch$2 = 1;switch$3 = 1}
             if(! switch$3)
              {caml_bytes_set(res,1,caml_string_get(str,1));
               blit$0(str,2,res,(width$0 - len | 0) + 2 | 0,len - 2 | 0)}}
           else
            switch$2 = 1;
           if(switch$2)blit$0(str,0,res,width$0 - len | 0,len)}}
      return caml_string_of_bytes(res)}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0),
       switch$0=0;
      if(58 <= c)
       {if(71 <= c)
         {if(! (5 < c - 97 >>> 0))switch$0 = 1}
        else
         if(65 <= c)switch$0 = 1}
      else
       {var switch$1=0;
        if(32 !== c)
         if(43 <= c)
          switch(c - 43 | 0)
           {case 5:
             if(len < (prec$0 + 2 | 0) && 1 < len)
              {var switch$2=0;
               if
                (120
                 ===
                 caml_string_get(str,1)
                 ||
                 88
                 ===
                 caml_string_get(str,1))
                switch$2 = 1;
               if(switch$2)
                {var res$1=make$0(prec$0 + 2 | 0,48);
                 caml_bytes_set(res$1,1,caml_string_get(str,1));
                 blit$0(str,2,res$1,(prec$0 - len | 0) + 4 | 0,len - 2 | 0);
                 return caml_string_of_bytes(res$1)}}
             switch$0 = 1;
             switch$1 = 1;
             break;
            case 0:
            case 2:break;
            case 1:
            case 3:
            case 4:switch$1 = 1;break;
            default:switch$0 = 1;switch$1 = 1}
         else
          switch$1 = 1;
        if(! switch$1 && len < (prec$0 + 1 | 0))
         {var res$0=make$0(prec$0 + 1 | 0,48);
          caml_bytes_set(res$0,0,c);
          blit$0(str,1,res$0,(prec$0 - len | 0) + 2 | 0,len - 1 | 0);
          return caml_string_of_bytes(res$0)}}
      if(switch$0 && len < prec$0)
       {var res=make$0(prec$0,48);
        blit$0(str,0,res,prec$0 - len | 0,len);
        return caml_string_of_bytes(res)}
      return str}
    function string_to_caml_string(str)
     {var
       str$0=escaped$1(str),
       l=caml_ml_string_length(str$0),
       res=make$0(l + 2 | 0,34);
      caml_blit_string(str$0,0,res,1,l);
      return caml_string_of_bytes(res)}
    function format_of_fconv(fconv,prec)
     {var
       prec$0=abs(prec),
       symb=char_of_fconv(_aq_,fconv),
       buf=buffer_create(16);
      buffer_add_char(buf,37);
      bprint_fconv_flag(buf,fconv);
      buffer_add_char(buf,46);
      buffer_add_string(buf,caml_string_of_jsbytes("" + prec$0));
      buffer_add_char(buf,symb);
      return buffer_contents(buf)}
    function transform_int_alt(iconv,s)
     {if(13 <= iconv)
       {var n=[0,0],_sX_=caml_ml_string_length(s) - 1 | 0,_sW_=0;
        if(! (_sX_ < 0))
         {var i$0=_sW_;
          for(;;)
           {var match=caml_string_unsafe_get(s,i$0);
            if(! (9 < match - 48 >>> 0))n[1]++;
            var _s1_=i$0 + 1 | 0;
            if(_sX_ !== i$0){var i$0=_s1_;continue}
            break}}
        var
         digits=n[1],
         buf=
          caml_create_bytes
           (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
         pos=[0,0],
         put=function(c){caml_bytes_set(buf,pos[1],c);pos[1]++;return 0},
         left=[0,((digits - 1 | 0) % 3 | 0) + 1 | 0],
         _sZ_=caml_ml_string_length(s) - 1 | 0,
         _sY_=0;
        if(! (_sZ_ < 0))
         {var i=_sY_;
          for(;;)
           {var c=caml_string_unsafe_get(s,i);
            if(9 < c - 48 >>> 0)
             put(c);
            else
             {if(0 === left[1]){put(95);left[1] = 3}left[1] += -1;put(c)}
            var _s0_=i + 1 | 0;
            if(_sZ_ !== i){var i=_s0_;continue}
            break}}
        return caml_string_of_bytes(buf)}
      return s}
    function convert_int(iconv,n)
     {switch(iconv)
       {case 1:var _sV_=cst_d$3;break;
        case 2:var _sV_=cst_d$4;break;
        case 4:var _sV_=cst_i$1;break;
        case 5:var _sV_=cst_i$2;break;
        case 6:var _sV_=cst_x;break;
        case 7:var _sV_=cst_x$0;break;
        case 8:var _sV_=cst_X$0;break;
        case 9:var _sV_=cst_X$1;break;
        case 10:var _sV_=cst_o;break;
        case 11:var _sV_=cst_o$0;break;
        case 0:
        case 13:var _sV_=cst_d$2;break;
        case 3:
        case 14:var _sV_=cst_i$0;break;
        default:var _sV_=cst_u}
      return transform_int_alt(iconv,caml_format_int(_sV_,n))}
    function convert_int32(iconv,n)
     {switch(iconv)
       {case 1:var _sU_=cst_ld$0;break;
        case 2:var _sU_=cst_ld$1;break;
        case 4:var _sU_=cst_li$1;break;
        case 5:var _sU_=cst_li$2;break;
        case 6:var _sU_=cst_lx;break;
        case 7:var _sU_=cst_lx$0;break;
        case 8:var _sU_=cst_lX;break;
        case 9:var _sU_=cst_lX$0;break;
        case 10:var _sU_=cst_lo;break;
        case 11:var _sU_=cst_lo$0;break;
        case 0:
        case 13:var _sU_=cst_ld;break;
        case 3:
        case 14:var _sU_=cst_li$0;break;
        default:var _sU_=cst_lu}
      return transform_int_alt(iconv,caml_format_int(_sU_,n))}
    function convert_nativeint(iconv,n)
     {switch(iconv)
       {case 1:var _sT_=cst_nd$0;break;
        case 2:var _sT_=cst_nd$1;break;
        case 4:var _sT_=cst_ni$1;break;
        case 5:var _sT_=cst_ni$2;break;
        case 6:var _sT_=cst_nx;break;
        case 7:var _sT_=cst_nx$0;break;
        case 8:var _sT_=cst_nX;break;
        case 9:var _sT_=cst_nX$0;break;
        case 10:var _sT_=cst_no;break;
        case 11:var _sT_=cst_no$0;break;
        case 0:
        case 13:var _sT_=cst_nd;break;
        case 3:
        case 14:var _sT_=cst_ni$0;break;
        default:var _sT_=cst_nu}
      return transform_int_alt(iconv,caml_format_int(_sT_,n))}
    function convert_int64(iconv,n)
     {switch(iconv)
       {case 1:var _sS_=cst_Ld$0;break;
        case 2:var _sS_=cst_Ld$1;break;
        case 4:var _sS_=cst_Li$1;break;
        case 5:var _sS_=cst_Li$2;break;
        case 6:var _sS_=cst_Lx;break;
        case 7:var _sS_=cst_Lx$0;break;
        case 8:var _sS_=cst_LX;break;
        case 9:var _sS_=cst_LX$0;break;
        case 10:var _sS_=cst_Lo;break;
        case 11:var _sS_=cst_Lo$0;break;
        case 0:
        case 13:var _sS_=cst_Ld;break;
        case 3:
        case 14:var _sS_=cst_Li$0;break;
        default:var _sS_=cst_Lu}
      return transform_int_alt(iconv,caml_int64_format(_sS_,n))}
    function convert_float(fconv,prec,x)
     {function hex(param)
       {switch(fconv[1])
         {case 0:var sign=45;break;
          case 1:var sign=43;break;
          default:var sign=32}
        return runtime.caml_hexstring_of_float(x,prec,sign)}
      function caml_special_val(str)
       {var match=runtime.caml_classify_float(x);
        return 3 === match
                ?x < 0.?cst_neg_infinity:cst_infinity
                :4 <= match?cst_nan:str}
      switch(fconv[2])
       {case 5:
         var
          str=caml_format_float(format_of_fconv(fconv,prec),x),
          len=caml_ml_string_length(str),
          i=0;
         for(;;)
          {if(i === len)
            var _sQ_=0;
           else
            {var match=caml_string_get(str,i),_sP_=match - 46 | 0,switch$0=0;
             if(23 < _sP_ >>> 0)
              {if(55 === _sP_)switch$0 = 1}
             else
              if(21 < _sP_ - 1 >>> 0)switch$0 = 1;
             if(! switch$0){var i$0=i + 1 | 0,i=i$0;continue}
             var _sQ_=1}
           var _sR_=_sQ_?str:cat(str,cst$29);
           return caml_special_val(_sR_)}
        case 6:return hex(0);
        case 7:return uppercase_ascii$1(hex(0));
        case 8:return caml_special_val(hex(0));
        default:return caml_format_float(format_of_fconv(fconv,prec),x)}}
    function string_of_fmtty(fmtty)
     {var buf=buffer_create(16);
      bprint_fmtty(buf,fmtty);
      return buffer_contents(buf)}
    function make_printf$0(counter,k,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {var
              str=escaped(c),
              l=caml_ml_string_length(str),
              res=make$0(l + 2 | 0,39);
             caml_blit_string(str,0,res,1,l);
             var new_acc=[4,acc$0,caml_string_of_bytes(res)];
             return make_printf(k$0,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding(k$0,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           if(typeof pad$5 === "number")
            {if(typeof prec$3 === "number")
              return prec$3
                      ?function(p,x)
                        {var str=convert_float(fconv,p,x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(x)
                        {var
                          str=
                           convert_float(fconv,default_float_precision(fconv),x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)};
             var p=prec$3[1];
             return function(x)
              {var str=convert_float(fconv,p,x);
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
           else
            {if(0 === pad$5[0])
              {var _sM_=pad$5[2],_sN_=pad$5[1];
               if(typeof prec$3 === "number")
                return prec$3
                        ?function(p,x)
                          {var str=fix_padding(_sN_,_sM_,convert_float(fconv,p,x));
                           return make_printf(k$0,[4,acc$0,str],rest$7)}
                        :function(x)
                          {var
                            str=convert_float(fconv,default_float_precision(fconv),x),
                            str$0=fix_padding(_sN_,_sM_,str);
                           return make_printf(k$0,[4,acc$0,str$0],rest$7)};
               var p$0=prec$3[1];
               return function(x)
                {var str=fix_padding(_sN_,_sM_,convert_float(fconv,p$0,x));
                 return make_printf(k$0,[4,acc$0,str],rest$7)}}
             var _sO_=pad$5[1];
             if(typeof prec$3 === "number")
              return prec$3
                      ?function(w,p,x)
                        {var str=fix_padding(_sO_,w,convert_float(fconv,p,x));
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(w,x)
                        {var
                          str=convert_float(fconv,default_float_precision(fconv),x),
                          str$0=fix_padding(_sO_,w,str);
                         return make_printf(k$0,[4,acc$0,str$0],rest$7)};
             var p$1=prec$3[1];
             return function(w,x)
              {var str=fix_padding(_sO_,w,convert_float(fconv,p$1,x));
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var
            rest$9=fmt$0[3],
            sub_fmtty=fmt$0[2],
            ty=string_of_fmtty(sub_fmtty);
           return function(str){return make_printf(k$0,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_printf
                     (k$0,acc$0,concat_fmt(recast(fmt,fmtty),rest$10))};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _sK_=fmt$0[1];
           if(0 === _sK_[0])
            {var
              rest$13=fmt$0[2],
              match=_sK_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(kacc)
                  {return make_printf(k,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_sK_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(kacc){return make_printf(k,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_ar_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,cst_Printf_bad_conversion];
           return function(param){return make_printf(k$0,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(cst_u$0,n)];
             return make_printf(k$0,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return make_ignored_param$0(counter$1,k$0,acc$0,ign,rest$18)}
           return caml_trampoline_return
                   (make_ignored_param$0,[0,k$0,acc$0,ign,rest$18]);
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _sL_=caml_call1(f,0);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,acc$0,rest$19,arity,_sL_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,acc$0,rest$19,arity,_sL_])}}
    function make_ignored_param$0(counter,k,acc,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return make_invalid_arg(counter$0,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return make_invalid_arg(counter$1,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:throw [0,Assert_failure,_as_];
         default:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return make_invalid_arg(counter$2,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return make_invalid_arg(counter$3,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return make_invalid_arg(counter$4,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return make_invalid_arg(counter$5,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 3:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return make_invalid_arg(counter$6,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 4:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return make_invalid_arg(counter$7,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 5:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return make_invalid_arg(counter$8,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 6:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return make_invalid_arg(counter$9,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 7:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return make_invalid_arg(counter$10,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 8:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return make_invalid_arg(counter$11,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 9:
          var fmtty=ign[2];
          if(counter < 50)
           {var counter$14=counter + 1 | 0;
            return make_from_fmtty$0(counter$14,k,acc,fmtty,fmt)}
          return caml_trampoline_return(make_from_fmtty$0,[0,k,acc,fmtty,fmt]);
         case 10:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return make_invalid_arg(counter$12,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         default:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return make_invalid_arg(counter$13,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}}
    function make_from_fmtty$0(counter,k,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           ty=trans(symm(ty1),ty2);
          return function(param)
           {return make_from_fmtty(k,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_sJ_)
           {return make_from_fmtty(k,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_at_];
         default:throw [0,Assert_failure,_au_]}}
    function make_invalid_arg(counter,k,acc,fmt)
     {var _sI_=[8,acc,cst_Printf_bad_conversion$0];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_sI_,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,_sI_,fmt])}
    function make_custom$0(counter,k,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,acc,rest,arity$0,caml_call1(f,x))}}
      var _sH_=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_sH_,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,_sH_,rest])}
    function make_printf(k,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,acc,fmt))}
    function make_ignored_param(k,acc,ign,fmt)
     {return caml_trampoline(make_ignored_param$0(0,k,acc,ign,fmt))}
    function make_from_fmtty(k,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,acc,fmtty,fmt))}
    function make_custom(k,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,acc,rest,arity,f))}
    function make_padding(k,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var new_acc=[4,acc,fix_padding(padty,width,caml_call1(trans,x))];
            return make_printf(k,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var new_acc=[4,acc,fix_padding(padty$0,w,caml_call1(trans,x))];
          return make_printf(k,new_acc,fmt)}}}
    function make_int_padding_precision(k,acc,fmt,pad,prec,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         return prec
                 ?function(p,x)
                   {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,[4,acc,str],fmt)};
        var p=prec[1];
        return function(x)
         {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
          return make_printf(k,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _sE_=pad[2],_sF_=pad[1];
          if(typeof prec === "number")
           return prec
                   ?function(p,x)
                     {var
                       str=
                        fix_padding
                         (_sF_,_sE_,fix_int_precision(p,caml_call2(trans,iconv,x)));
                      return make_printf(k,[4,acc,str],fmt)}
                   :function(x)
                     {var str=fix_padding(_sF_,_sE_,caml_call2(trans,iconv,x));
                      return make_printf(k,[4,acc,str],fmt)};
          var p$0=prec[1];
          return function(x)
           {var
             str=
              fix_padding
               (_sF_,_sE_,fix_int_precision(p$0,caml_call2(trans,iconv,x)));
            return make_printf(k,[4,acc,str],fmt)}}
        var _sG_=pad[1];
        if(typeof prec === "number")
         return prec
                 ?function(w,p,x)
                   {var
                     str=
                      fix_padding
                       (_sG_,w,fix_int_precision(p,caml_call2(trans,iconv,x)));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(w,x)
                   {var str=fix_padding(_sG_,w,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)};
        var p$1=prec[1];
        return function(w,x)
         {var
           str=
            fix_padding
             (_sG_,w,fix_int_precision(p$1,caml_call2(trans,iconv,x)));
          return make_printf(k,[4,acc,str],fmt)}}}
    function make_iprintf$0(counter,k,o,fmt)
     {var k$0=k,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,o);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1],_rV_=make_iprintf(k$0,o,rest);
           return function(_sD_){return _rV_};
          case 1:
           var rest$0=fmt$0[1],_rW_=make_iprintf(k$0,o,rest$0);
           return function(_sC_){return _rW_};
          case 2:
           var _rX_=fmt$0[1];
           if(typeof _rX_ === "number")
            {var rest$1=fmt$0[2],_rY_=make_iprintf(k$0,o,rest$1);
             return function(_sy_){return _rY_}}
           else
            {if(0 === _rX_[0])
              {var rest$2=fmt$0[2],_rZ_=make_iprintf(k$0,o,rest$2);
               return function(_sB_){return _rZ_}}
             var
              rest$3=fmt$0[2],
              _r0_=make_iprintf(k$0,o,rest$3),
              _r1_=function(_sA_){return _r0_};
             return function(_sz_){return _r1_}}
          case 3:
           var _r2_=fmt$0[1];
           if(typeof _r2_ === "number")
            {var rest$4=fmt$0[2],_r3_=make_iprintf(k$0,o,rest$4);
             return function(_su_){return _r3_}}
           else
            {if(0 === _r2_[0])
              {var rest$5=fmt$0[2],_r4_=make_iprintf(k$0,o,rest$5);
               return function(_sx_){return _r4_}}
             var
              rest$6=fmt$0[2],
              _r5_=make_iprintf(k$0,o,rest$6),
              _r6_=function(_sw_){return _r5_};
             return function(_sv_){return _r6_}}
          case 4:
           var rest$7=fmt$0[4],prec=fmt$0[3],pad=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$7,pad,prec);
          case 5:
           var rest$8=fmt$0[4],prec$0=fmt$0[3],pad$0=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$8,pad$0,prec$0);
          case 6:
           var rest$9=fmt$0[4],prec$1=fmt$0[3],pad$1=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$9,pad$1,prec$1);
          case 7:
           var rest$10=fmt$0[4],prec$2=fmt$0[3],pad$2=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$10,pad$2,prec$2);
          case 8:
           var rest$11=fmt$0[4],prec$3=fmt$0[3],pad$3=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$11,pad$3,prec$3);
          case 9:
           var _r7_=fmt$0[1];
           if(typeof _r7_ === "number")
            {var rest$12=fmt$0[2],_r8_=make_iprintf(k$0,o,rest$12);
             return function(_sq_){return _r8_}}
           else
            {if(0 === _r7_[0])
              {var rest$13=fmt$0[2],_r9_=make_iprintf(k$0,o,rest$13);
               return function(_st_){return _r9_}}
             var
              rest$14=fmt$0[2],
              _r__=make_iprintf(k$0,o,rest$14),
              _r$_=function(_ss_){return _r__};
             return function(_sr_){return _r$_}}
          case 10:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 11:var fmt$2=fmt$0[2],fmt$0=fmt$2;continue;
          case 12:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 13:
           var rest$15=fmt$0[3],_sa_=make_iprintf(k$0,o,rest$15);
           return function(_sp_){return _sa_};
          case 14:
           var rest$16=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_iprintf(k$0,o,concat_fmt(recast(fmt,fmtty),rest$16))};
          case 15:
           var
            rest$17=fmt$0[1],
            _sb_=make_iprintf(k$0,o,rest$17),
            _sc_=function(_so_){return _sb_};
           return function(_sn_){return _sc_};
          case 16:
           var rest$18=fmt$0[1],_sd_=make_iprintf(k$0,o,rest$18);
           return function(_sm_){return _sd_};
          case 17:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 18:
           var _se_=fmt$0[1];
           if(0 === _se_[0])
            {var
              rest$19=fmt$0[2],
              match=_se_[1],
              fmt$5=match[1],
              k$3=
               function(k,rest)
                {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
              k$1=k$3(k$0,rest$19),
              k$0=k$1,
              fmt$0=fmt$5;
             continue}
           var
            rest$20=fmt$0[2],
            match$0=_se_[1],
            fmt$6=match$0[1],
            k$4=
             function(k,rest)
              {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
            k$2=k$4(k$0,rest$20),
            k$0=k$2,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_av_];
          case 20:
           var rest$21=fmt$0[3],_sf_=make_iprintf(k$0,o,rest$21);
           return function(_sl_){return _sf_};
          case 21:
           var rest$22=fmt$0[2],_sg_=make_iprintf(k$0,o,rest$22);
           return function(_sk_){return _sg_};
          case 22:
           var rest$23=fmt$0[1],_sh_=make_iprintf(k$0,o,rest$23);
           return function(_sj_){return _sh_};
          case 23:
           var rest$24=fmt$0[2],ign=fmt$0[1],_si_=0;
           return make_ignored_param
                   (function(param){return caml_call1(k$0,o)},_si_,ign,rest$24);
          default:
           var rest$25=fmt$0[3],arity=fmt$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return fn_of_custom_arity$0(counter$0,k$0,o,rest$25,arity)}
           return caml_trampoline_return
                   (fn_of_custom_arity$0,[0,k$0,o,rest$25,arity])}}
    function fn_of_custom_arity$0(counter,k,o,fmt,param)
     {if(param)
       {var arity=param[1],_rT_=fn_of_custom_arity(k,o,fmt,arity);
        return function(_rU_){return _rT_}}
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_iprintf$0(counter$0,k,o,fmt)}
      return caml_trampoline_return(make_iprintf$0,[0,k,o,fmt])}
    function make_iprintf(k,o,fmt)
     {return caml_trampoline(make_iprintf$0(0,k,o,fmt))}
    function fn_of_custom_arity(k,o,fmt,param)
     {return caml_trampoline(fn_of_custom_arity$0(0,k,o,fmt,param))}
    function fn_of_padding_precision(k,o,fmt,pad,prec)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(prec)
           {var _rp_=make_iprintf(k,o,fmt),_rq_=function(_rH_){return _rp_};
            return function(_rG_){return _rq_}}
          var _rr_=make_iprintf(k,o,fmt);
          return function(_rF_){return _rr_}}
        var _rs_=make_iprintf(k,o,fmt);
        return function(_rE_){return _rs_}}
      else
       {if(0 === pad[0])
         {if(typeof prec === "number")
           {if(prec)
             {var _rt_=make_iprintf(k,o,fmt),_ru_=function(_rS_){return _rt_};
              return function(_rR_){return _ru_}}
            var _rv_=make_iprintf(k,o,fmt);
            return function(_rQ_){return _rv_}}
          var _rw_=make_iprintf(k,o,fmt);
          return function(_rP_){return _rw_}}
        if(typeof prec === "number")
         {if(prec)
           {var
             _rx_=make_iprintf(k,o,fmt),
             _ry_=function(_rO_){return _rx_},
             _rz_=function(_rN_){return _ry_};
            return function(_rM_){return _rz_}}
          var _rA_=make_iprintf(k,o,fmt),_rB_=function(_rL_){return _rA_};
          return function(_rK_){return _rB_}}
        var _rC_=make_iprintf(k,o,fmt),_rD_=function(_rJ_){return _rC_};
        return function(_rI_){return _rD_}}}
    function output_acc(o,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           output_acc(o,p);
           return output_string(o,s);
          case 1:
           var _rn_=acc$0[2],_ro_=acc$0[1];
           if(0 === _rn_[0])
            {var acc$1=_rn_[1];
             output_acc(o,_ro_);
             output_string(o,cst$30);
             var acc$0=acc$1;
             continue}
           var acc$2=_rn_[1];
           output_acc(o,_ro_);
           output_string(o,cst$31);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           output_acc(o,p$2);
           return caml_call1(f,o);
          case 7:var p$3=acc$0[1];output_acc(o,p$3);return caml_ml_flush(o);
          case 8:
           var msg=acc$0[2],p$4=acc$0[1];
           output_acc(o,p$4);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           output_acc(o,p$0);
           return output_string(o,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           output_acc(o,p$1);
           return caml_ml_output_char(o,c)}}
    function bufput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           bufput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _rl_=acc$0[2],_rm_=acc$0[1];
           if(0 === _rl_[0])
            {var acc$1=_rl_[1];
             bufput_acc(b,_rm_);
             add_string(b,cst$32);
             var acc$0=acc$1;
             continue}
           var acc$2=_rl_[1];
           bufput_acc(b,_rm_);
           add_string(b,cst$33);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           bufput_acc(b,p$2);
           return caml_call1(f,b);
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           bufput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           bufput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];bufput_acc(b,p$1);return add_char(b,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _rj_=acc$0[2],_rk_=acc$0[1];
           if(0 === _rj_[0])
            {var acc$1=_rj_[1];
             strput_acc(b,_rk_);
             add_string(b,cst$34);
             var acc$0=acc$1;
             continue}
           var acc$2=_rj_[1];
           strput_acc(b,_rk_);
           add_string(b,cst$35);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           return add_string(b,caml_call1(f,0));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];strput_acc(b,p$1);return add_char(b,c)}}
    function failwith_message(param)
     {var fmt=param[1],buf=create$2(256);
      function k(acc){strput_acc(buf,acc);return failwith(contents(buf))}
      return make_printf(k,0,fmt)}
    function open_box_of_string(str)
     {if(caml_string_equal(str,cst$36))return _aw_;
      var len=caml_ml_string_length(str);
      function invalid_box(param)
       {return caml_call1(failwith_message(_ax_),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match && 32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0);
          if(25 < match - 97 >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switch$0=0;
          if(48 <= match)
           {if(! (58 <= match))switch$0 = 1}
          else
           if(45 === match)switch$0 = 1;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       wstart=parse_spaces(0),
       wend=parse_lword(wstart,wstart),
       box_name=sub$0(str,wstart,wend - wstart | 0),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _rh_=caml_int_of_string(sub$0(str,nstart,nend - nstart | 0)),
          indent=_rh_}
       catch(_ri_)
        {_ri_ = caml_wrap_exception(_ri_);
         if(_ri_[1] !== Failure)throw _ri_;
         var indent=invalid_box(0)}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len)invalid_box(0);
      var switch$0=0;
      if
       (caml_string_notequal(box_name,cst$37)
        &&
        caml_string_notequal(box_name,cst_b$0))
       var
        box_type=
         caml_string_notequal(box_name,cst_h)
          ?caml_string_notequal(box_name,cst_hov)
            ?caml_string_notequal(box_name,cst_hv)
              ?caml_string_notequal(box_name,cst_v)?invalid_box(0):1
              :2
            :3
          :0;
      else
       switch$0 = 1;
      if(switch$0)var box_type=4;
      return [0,indent,box_type]}
    function make_padding_fmt_ebb(pad,fmt)
     {if(typeof pad === "number")
       return [0,0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],fmt]}}
    function make_padprec_fmt_ebb(pad,prec,fmt)
     {if(typeof prec === "number")
       var match=prec?[0,1,fmt]:[0,0,fmt];
      else
       var p=prec[1],match=[0,[0,p],fmt];
      var prec$0=match[1];
      if(typeof pad === "number")
       return [0,0,prec$0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],prec$0,fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],prec$0,fmt]}}
    function fmt_ebb_of_string(legacy_behavior,str)
     {if(legacy_behavior)
       var flag=legacy_behavior[1],legacy_behavior$0=flag;
      else
       var legacy_behavior$0=1;
      function invalid_format_message(str_ind,msg)
       {return caml_call3(failwith_message(_ay_),str,str_ind,msg)}
      function unexpected_end_of_format(end_ind)
       {return invalid_format_message(end_ind,cst_unexpected_end_of_format)}
      function invalid_format_without(str_ind,c,s)
       {return caml_call4(failwith_message(_az_),str,str_ind,c,s)}
      function expected_character(str_ind,expected,read)
       {return caml_call4(failwith_message(_aA_),str,str_ind,expected,read)}
      function add_literal(lit_start,str_ind,fmt)
       {var size=str_ind - lit_start | 0;
        return 0 === size
                ?[0,fmt]
                :1 === size
                  ?[0,[12,caml_string_get(str,lit_start),fmt]]
                  :[0,[11,sub$0(str,lit_start,size),fmt]]}
      function parse_positive(str_ind,end_ind,acc)
       {var str_ind$0=str_ind,acc$0=acc;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var c=caml_string_get(str,str_ind$0);
          if(9 < c - 48 >>> 0)return [0,str_ind$0,acc$0];
          var acc$1=(acc$0 * 10 | 0) + (c - 48 | 0) | 0;
          if(max_string_length < acc$1)
           return caml_call3
                   (failwith_message(_aR_),str,acc$1,max_string_length);
          var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,acc$0=acc$1;
          continue}}
      function parse_integer(str_ind,end_ind)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var match=caml_string_get(str,str_ind);
        if(48 <= match)
         {if(! (58 <= match))return parse_positive(str_ind,end_ind,0)}
        else
         if(45 === match)
          {if((str_ind + 1 | 0) === end_ind)unexpected_end_of_format(end_ind);
           var c=caml_string_get(str,str_ind + 1 | 0);
           if(9 < c - 48 >>> 0)
            return expected_character(str_ind + 1 | 0,cst_digit,c);
           var
            match$0=parse_positive(str_ind + 1 | 0,end_ind,0),
            n=match$0[2],
            next_ind=match$0[1];
           return [0,next_ind,- n | 0]}
        throw [0,Assert_failure,_aS_]}
      function parse_spaces(str_ind,end_ind)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          if(32 === caml_string_get(str,str_ind$0))
           {var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;continue}
          return str_ind$0}}
      function incompatible_flag(pct_ind,str_ind,symb,option)
       {var subfmt=sub$0(str,pct_ind,str_ind - pct_ind | 0);
        return caml_call5
                (failwith_message(_aX_),str,pct_ind,option,symb,subfmt)}
      function compute_int_conv(pct_ind,str_ind,plus,hash,space,symb)
       {var plus$0=plus,hash$0=hash,space$0=space;
        for(;;)
         {var switch$0=0;
          if(plus$0)
           {if(hash$0)
             switch$0 = 1;
            else
             if(! space$0){if(100 === symb)return 1;if(105 === symb)return 4}}
          else
           if(hash$0)
            if(space$0)
             switch$0 = 1;
            else
             {var switcher$0=symb - 88 | 0;
              if(32 < switcher$0 >>> 0)
               switch$0 = 1;
              else
               switch(switcher$0)
                {case 0:return 9;
                 case 12:return 13;
                 case 17:return 14;
                 case 23:return 11;
                 case 29:return 15;
                 case 32:return 7;
                 default:switch$0 = 1}}
           else
            if(space$0)
             {if(100 === symb)return 2;if(105 === symb)return 5}
            else
             {var switcher$1=symb - 88 | 0;
              if(! (32 < switcher$1 >>> 0))
               switch(switcher$1)
                {case 0:return 8;
                 case 12:return 0;
                 case 17:return 3;
                 case 23:return 10;
                 case 29:return 12;
                 case 32:return 6
                 }}
          if(switch$0)
           {var switcher=symb - 88 | 0;
            if(! (32 < switcher >>> 0))
             switch(switcher)
              {case 0:if(legacy_behavior$0)return 9;break;
               case 23:if(legacy_behavior$0)return 11;break;
               case 32:if(legacy_behavior$0)return 7;break;
               case 12:
               case 17:
               case 29:
                if(legacy_behavior$0){var hash$0=0;continue}
                return incompatible_flag(pct_ind,str_ind,symb,cst$49)
               }}
          if(plus$0)
           {if(space$0)
             {if(legacy_behavior$0){var space$0=0;continue}
              return incompatible_flag(pct_ind,str_ind,32,cst$46)}
            if(legacy_behavior$0){var plus$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$47)}
          if(space$0)
           {if(legacy_behavior$0){var space$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$48)}
          throw [0,Assert_failure,_aV_]}}
      function search_subformat_end(str_ind,end_ind,c)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)
           caml_call3(failwith_message(_aT_),str,c,end_ind);
          var match=caml_string_get(str,str_ind$0);
          if(37 === match)
           {if((str_ind$0 + 1 | 0) === end_ind)
             unexpected_end_of_format(end_ind);
            if(caml_string_get(str,str_ind$0 + 1 | 0) === c)return str_ind$0;
            var match$0=caml_string_get(str,str_ind$0 + 1 | 0);
            if(95 <= match$0)
             {if(123 <= match$0)
               {if(! (126 <= match$0))
                 switch(match$0 - 123 | 0)
                  {case 0:
                    var
                     sub_end=search_subformat_end(str_ind$0 + 2 | 0,end_ind,125),
                     str_ind$2=sub_end + 2 | 0,
                     str_ind$0=str_ind$2;
                    continue;
                   case 1:break;
                   default:
                    return expected_character
                            (str_ind$0 + 1 | 0,cst_character,125)}}
              else
               if(! (96 <= match$0))
                {if((str_ind$0 + 2 | 0) === end_ind)
                  unexpected_end_of_format(end_ind);
                 var match$1=caml_string_get(str,str_ind$0 + 2 | 0);
                 if(40 === match$1)
                  {var
                    sub_end$0=search_subformat_end(str_ind$0 + 3 | 0,end_ind,41),
                    str_ind$3=sub_end$0 + 2 | 0,
                    str_ind$0=str_ind$3;
                   continue}
                 if(123 === match$1)
                  {var
                    sub_end$1=
                     search_subformat_end(str_ind$0 + 3 | 0,end_ind,125),
                    str_ind$4=sub_end$1 + 2 | 0,
                    str_ind$0=str_ind$4;
                   continue}
                 var str_ind$5=str_ind$0 + 3 | 0,str_ind$0=str_ind$5;
                 continue}}
            else
             {if(40 === match$0)
               {var
                 sub_end$2=search_subformat_end(str_ind$0 + 2 | 0,end_ind,41),
                 str_ind$6=sub_end$2 + 2 | 0,
                 str_ind$0=str_ind$6;
                continue}
              if(41 === match$0)
               return expected_character(str_ind$0 + 1 | 0,cst_character$0,41)}
            var str_ind$1=str_ind$0 + 2 | 0,str_ind$0=str_ind$1;
            continue}
          var str_ind$7=str_ind$0 + 1 | 0,str_ind$0=str_ind$7;
          continue}}
      function parse_magic_size(str_ind,end_ind)
       {try
         {var
           str_ind_1=parse_spaces(str_ind,end_ind),
           match$2=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$2)
           {if(! (58 <= match$2))switch$0 = 1}
          else
           if(45 === match$2)switch$0 = 1;
          if(switch$0)
           {var
             match$3=parse_integer(str_ind_1,end_ind),
             size=match$3[2],
             str_ind_2=match$3[1],
             str_ind_3=parse_spaces(str_ind_2,end_ind);
            if(62 !== caml_string_get(str,str_ind_3))throw Not_found;
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _rf_=[0,[0,str_ind_3 + 1 | 0,[1,s,size]]]}
          else
           var _rf_=0;
          var _re_=_rf_}
        catch(_rg_)
         {_rg_ = caml_wrap_exception(_rg_);
          if(_rg_ !== Not_found && _rg_[1] !== Failure)throw _rg_;
          var _re_=0}
        if(_re_)
         {var
           match=_re_[1],
           formatting_lit=match[2],
           next_ind=match[1],
           match$0=parse(next_ind,end_ind),
           fmt_rest=match$0[1];
          return [0,[17,formatting_lit,fmt_rest]]}
        var match$1=parse(str_ind,end_ind),fmt_rest$0=match$1[1];
        return [0,[17,_aP_,fmt_rest$0]]}
      function parse_good_break(str_ind,end_ind)
       {try
         {var
           _q9_=str_ind === end_ind?1:0,
           _q__=_q9_ || (60 !== caml_string_get(str,str_ind)?1:0);
          if(_q__)throw Not_found;
          var
           str_ind_1=parse_spaces(str_ind + 1 | 0,end_ind),
           match$0=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$0)
           {if(! (58 <= match$0))switch$0 = 1}
          else
           if(45 === match$0)switch$0 = 1;
          if(! switch$0)throw Not_found;
          var
           match$1=parse_integer(str_ind_1,end_ind),
           width=match$1[2],
           str_ind_2=match$1[1],
           str_ind_3=parse_spaces(str_ind_2,end_ind),
           match$2=caml_string_get(str,str_ind_3),
           switcher=match$2 - 45 | 0,
           switch$1=0;
          if(12 < switcher >>> 0)
           if(17 === switcher)
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _q$_=[0,s,width,0],
             _ra_=str_ind_3 + 1 | 0,
             formatting_lit$0=_q$_,
             next_ind=_ra_;
           else
            switch$1 = 1;
          else
           if(1 < switcher - 1 >>> 0)
            {var
              match$3=parse_integer(str_ind_3,end_ind),
              offset=match$3[2],
              str_ind_4=match$3[1],
              str_ind_5=parse_spaces(str_ind_4,end_ind);
             if(62 !== caml_string_get(str,str_ind_5))throw Not_found;
             var
              s$0=sub$0(str,str_ind - 2 | 0,(str_ind_5 - str_ind | 0) + 3 | 0),
              _rb_=[0,s$0,width,offset],
              _rc_=str_ind_5 + 1 | 0,
              formatting_lit$0=_rb_,
              next_ind=_rc_}
           else
            switch$1 = 1;
          if(switch$1)throw Not_found}
        catch(_rd_)
         {_rd_ = caml_wrap_exception(_rd_);
          if(_rd_ !== Not_found && _rd_[1] !== Failure)throw _rd_;
          var formatting_lit$0=formatting_lit,next_ind=str_ind}
        var match=parse(next_ind,end_ind),fmt_rest=match[1];
        return [0,[17,formatting_lit$0,fmt_rest]]}
      function parse_tag(is_open_tag,str_ind,end_ind)
       {try
         {if(str_ind === end_ind)throw Not_found;
          var match$0=caml_string_get(str,str_ind);
          if(60 === match$0)
           {var ind=index_from$0(str,str_ind + 1 | 0,62);
            if(end_ind <= ind)throw Not_found;
            var
             sub_str=sub$0(str,str_ind,(ind - str_ind | 0) + 1 | 0),
             match$1=parse(ind + 1 | 0,end_ind),
             fmt_rest$0=match$1[1],
             match$2=parse(str_ind,ind + 1 | 0),
             sub_fmt=match$2[1],
             sub_format$0=[0,sub_fmt,sub_str],
             formatting$0=is_open_tag?[0,sub_format$0]:[1,sub_format$0],
             _q7_=[0,[18,formatting$0,fmt_rest$0]];
            return _q7_}
          throw Not_found}
        catch(_q8_)
         {_q8_ = caml_wrap_exception(_q8_);
          if(_q8_ === Not_found)
           {var
             match=parse(str_ind,end_ind),
             fmt_rest=match[1],
             formatting=is_open_tag?[0,sub_format]:[1,sub_format];
            return [0,[18,formatting,fmt_rest]]}
          throw _q8_}}
      function parse_flags(pct_ind,str_ind,end_ind,ign)
       {var zero=[0,0],minus=[0,0],plus=[0,0],space=[0,0],hash=[0,0];
        function set_flag(str_ind,flag)
         {var _q4_=flag[1],_q5_=_q4_?1 - legacy_behavior$0:_q4_;
          if(_q5_)
           {var _q6_=caml_string_get(str,str_ind);
            caml_call3(failwith_message(_aB_),str,str_ind,_q6_)}
          flag[1] = 1;
          return 0}
        var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var match=caml_string_get(str,str_ind$0),switcher=match - 32 | 0;
          if(! (16 < switcher >>> 0))
           switch(switcher)
            {case 0:
              set_flag(str_ind$0,space);
              var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
              continue;
             case 3:
              set_flag(str_ind$0,hash);
              var str_ind$2=str_ind$0 + 1 | 0,str_ind$0=str_ind$2;
              continue;
             case 11:
              set_flag(str_ind$0,plus);
              var str_ind$3=str_ind$0 + 1 | 0,str_ind$0=str_ind$3;
              continue;
             case 13:
              set_flag(str_ind$0,minus);
              var str_ind$4=str_ind$0 + 1 | 0,str_ind$0=str_ind$4;
              continue;
             case 16:
              set_flag(str_ind$0,zero);
              var str_ind$5=str_ind$0 + 1 | 0,str_ind$0=str_ind$5;
              continue
             }
          var
           _qZ_=space[1],
           _q0_=hash[1],
           _q1_=plus[1],
           _q2_=minus[1],
           _q3_=zero[1];
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           padty=
            _q3_
             ?_q2_
               ?legacy_behavior$0
                 ?0
                 :incompatible_flag(pct_ind,str_ind$0,45,cst_0)
               :2
             :_q2_?0:1,
           match$0=caml_string_get(str,str_ind$0);
          if(48 <= match$0)
           {if(! (58 <= match$0))
             {var
               match$1=parse_positive(str_ind$0,end_ind,0),
               width=match$1[2],
               new_ind=match$1[1];
              return parse_after_padding
                      (pct_ind,
                       new_ind,
                       end_ind,
                       _q2_,
                       _q1_,
                       _q0_,
                       _qZ_,
                       ign,
                       [0,padty,width])}}
          else
           if(42 === match$0)
            return parse_after_padding
                    (pct_ind,
                     str_ind$0 + 1 | 0,
                     end_ind,
                     _q2_,
                     _q1_,
                     _q0_,
                     _qZ_,
                     ign,
                     [1,padty]);
          switch(padty)
           {case 0:
             if(1 - legacy_behavior$0)
              invalid_format_without(str_ind$0 - 1 | 0,45,cst_padding);
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_q2_,_q1_,_q0_,_qZ_,ign,0);
            case 1:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_q2_,_q1_,_q0_,_qZ_,ign,0);
            default:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_q2_,_q1_,_q0_,_qZ_,ign,_aC_)}}}
      function parse_after_padding
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var symb=caml_string_get(str,str_ind);
        if(46 === symb)
         {var str_ind$0=str_ind + 1 | 0;
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           parse_literal=
            function(minus,str_ind)
             {var
               match=parse_positive(str_ind,end_ind,0),
               prec=match[2],
               new_ind=match[1];
              return parse_after_precision
                      (pct_ind,
                       new_ind,
                       end_ind,
                       minus,
                       plus,
                       hash,
                       space,
                       ign,
                       pad,
                       [0,prec])},
           symb$0=caml_string_get(str,str_ind$0);
          if(48 <= symb$0)
           {if(! (58 <= symb$0))return parse_literal(minus,str_ind$0)}
          else
           if(42 <= symb$0)
            switch(symb$0 - 42 | 0)
             {case 0:
               return parse_after_precision
                       (pct_ind,
                        str_ind$0 + 1 | 0,
                        end_ind,
                        minus,
                        plus,
                        hash,
                        space,
                        ign,
                        pad,
                        1);
              case 1:
              case 3:
               if(legacy_behavior$0)
                {var
                  _qY_=str_ind$0 + 1 | 0,
                  minus$0=minus || (45 === symb$0?1:0);
                 return parse_literal(minus$0,_qY_)}
               break
              }
          return legacy_behavior$0
                  ?parse_after_precision
                    (pct_ind,
                     str_ind$0,
                     end_ind,
                     minus,
                     plus,
                     hash,
                     space,
                     ign,
                     pad,
                     _aD_)
                  :invalid_format_without(str_ind$0 - 1 | 0,46,cst_precision)}
        return parse_conversion
                (pct_ind,
                 str_ind + 1 | 0,
                 end_ind,
                 plus,
                 hash,
                 space,
                 ign,
                 pad,
                 0,
                 pad,
                 symb)}
      function parse_after_precision
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad,prec)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        function parse_conv(padprec)
         {return parse_conversion
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   plus,
                   hash,
                   space,
                   ign,
                   pad,
                   prec,
                   padprec,
                   caml_string_get(str,str_ind))}
        if(typeof pad === "number")
         {if(typeof prec === "number" && ! prec)return parse_conv(0);
          if(minus)
           {if(typeof prec === "number")return parse_conv(_aE_);
            var n=prec[1];
            return parse_conv([0,0,n])}
          if(typeof prec === "number")return parse_conv(_aF_);
          var n$0=prec[1];
          return parse_conv([0,1,n$0])}
        return parse_conv(pad)}
      function parse_conversion
       (pct_ind,str_ind,end_ind,plus,hash,space,ign,pad,prec,padprec,symb)
       {var
         plus_used=[0,0],
         hash_used=[0,0],
         space_used=[0,0],
         ign_used=[0,0],
         pad_used=[0,0],
         prec_used=[0,0];
        function get_plus(param){plus_used[1] = 1;return plus}
        function get_hash(param){hash_used[1] = 1;return hash}
        function get_space(param){space_used[1] = 1;return space}
        function get_ign(param){ign_used[1] = 1;return ign}
        function get_pad(param){pad_used[1] = 1;return pad}
        function get_prec(param){prec_used[1] = 1;return prec}
        function get_padprec(param){pad_used[1] = 1;return padprec}
        function get_int_pad(param)
         {var pad=get_pad(0),match=get_prec(0);
          if(typeof match === "number" && ! match)return pad;
          if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var n=pad[2];
                return legacy_behavior$0
                        ?[0,1,n]
                        :incompatible_flag(pct_ind,str_ind,48,cst_precision$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aG_
                      :incompatible_flag(pct_ind,str_ind,48,cst_precision$1)
                    :pad}}
        function check_no_0(symb,pad)
         {if(typeof pad === "number")
           return pad;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var width=pad[2];
                return legacy_behavior$0
                        ?[0,1,width]
                        :incompatible_flag(pct_ind,str_ind,symb,cst_0$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aH_
                      :incompatible_flag(pct_ind,str_ind,symb,cst_0$1)
                    :pad}}
        function opt_of_pad(c,pad)
         {if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             switch(pad[1])
              {case 0:
                var width=pad[2];
                return legacy_behavior$0
                        ?[0,width]
                        :incompatible_flag(pct_ind,str_ind,c,cst$38);
               case 1:var width$0=pad[2];return [0,width$0];
               default:
                var width$1=pad[2];
                return legacy_behavior$0
                        ?[0,width$1]
                        :incompatible_flag(pct_ind,str_ind,c,cst_0$2)}
            return incompatible_flag(pct_ind,str_ind,c,cst$39)}}
        function get_pad_opt(c){return opt_of_pad(c,get_pad(0))}
        function get_padprec_opt(c){return opt_of_pad(c,get_padprec(0))}
        var switch$0=0;
        if(124 <= symb)
         switch$0 = 1;
        else
         switch(symb)
          {case 33:
            var
             match$6=parse(str_ind,end_ind),
             fmt_rest$5=match$6[1],
             fmt_result=[0,[10,fmt_rest$5]];
            break;
           case 40:
            var
             sub_end=search_subformat_end(str_ind,end_ind,41),
             match$8=parse(sub_end + 2 | 0,end_ind),
             fmt_rest$7=match$8[1],
             match$9=parse(str_ind,sub_end),
             sub_fmt=match$9[1],
             sub_fmtty=fmtty_of_fmt(sub_fmt);
            if(get_ign(0))
             var
              ignored$2=[9,get_pad_opt(95),sub_fmtty],
              _qv_=[0,[23,ignored$2,fmt_rest$7]];
            else
             var _qv_=[0,[14,get_pad_opt(40),sub_fmtty,fmt_rest$7]];
            var fmt_result=_qv_;
            break;
           case 44:var fmt_result=parse(str_ind,end_ind);break;
           case 67:
            var
             match$12=parse(str_ind,end_ind),
             fmt_rest$10=match$12[1],
             _qx_=get_ign(0)?[0,[23,1,fmt_rest$10]]:[0,[1,fmt_rest$10]],
             fmt_result=_qx_;
            break;
           case 78:
            var
             match$16=parse(str_ind,end_ind),
             fmt_rest$14=match$16[1],
             counter$0=2;
            if(get_ign(0))
             var ignored$6=[11,counter$0],_qD_=[0,[23,ignored$6,fmt_rest$14]];
            else
             var _qD_=[0,[21,counter$0,fmt_rest$14]];
            var fmt_result=_qD_;
            break;
           case 83:
            var
             pad$6=check_no_0(symb,get_padprec(0)),
             match$17=parse(str_ind,end_ind),
             fmt_rest$15=match$17[1];
            if(get_ign(0))
             var
              ignored$7=[1,get_padprec_opt(95)],
              _qE_=[0,[23,ignored$7,fmt_rest$15]];
            else
             var
              match$18=make_padding_fmt_ebb(pad$6,fmt_rest$15),
              fmt_rest$16=match$18[2],
              pad$7=match$18[1],
              _qE_=[0,[3,pad$7,fmt_rest$16]];
            var fmt_result=_qE_;
            break;
           case 91:
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var
             char_set=create_char_set(0),
             add_char=function(c){return add_in_char_set(char_set,c)},
             add_range=
              function(c$0,c)
               {if(! (c < c$0))
                 {var i=c$0;
                  for(;;)
                   {add_in_char_set(char_set,char_of_int(i));
                    var _qX_=i + 1 | 0;
                    if(c !== i){var i=_qX_;continue}
                    break}}
                return 0},
             fail_single_percent=
              function(str_ind)
               {return caml_call2(failwith_message(_aQ_),str,str_ind)},
             parse_char_set_content=
              function(counter,str_ind,end_ind)
               {var str_ind$0=str_ind;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c=caml_string_get(str,str_ind$0);
                  if(45 === c)
                   {add_char(45);
                    var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
                    continue}
                  if(93 === c)return str_ind$0 + 1 | 0;
                  var _qW_=str_ind$0 + 1 | 0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return parse_char_set_after_char$0(counter$0,_qW_,end_ind,c)}
                  return caml_trampoline_return
                          (parse_char_set_after_char$0,[0,_qW_,end_ind,c])}},
             parse_char_set_after_char$0=
              function(counter,str_ind,end_ind,c)
               {var str_ind$0=str_ind,c$0=c;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c$1=caml_string_get(str,str_ind$0),switch$0=0;
                  if(46 <= c$1)
                   {if(64 === c$1)
                     switch$0 = 1;
                    else
                     if(93 === c$1){add_char(c$0);return str_ind$0 + 1 | 0}}
                  else
                   if(37 === c$1)
                    switch$0 = 1;
                   else
                    if(45 <= c$1)
                     {var str_ind$2=str_ind$0 + 1 | 0;
                      if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
                      var c$2=caml_string_get(str,str_ind$2);
                      if(37 === c$2)
                       {if((str_ind$2 + 1 | 0) === end_ind)
                         unexpected_end_of_format(end_ind);
                        var c$3=caml_string_get(str,str_ind$2 + 1 | 0);
                        if(37 !== c$3 && 64 !== c$3)
                         return fail_single_percent(str_ind$2);
                        add_range(c$0,c$3);
                        var _qU_=str_ind$2 + 2 | 0;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return parse_char_set_content(counter$2,_qU_,end_ind)}
                        return caml_trampoline_return
                                (parse_char_set_content,[0,_qU_,end_ind])}
                      if(93 === c$2)
                       {add_char(c$0);add_char(45);return str_ind$2 + 1 | 0}
                      add_range(c$0,c$2);
                      var _qV_=str_ind$2 + 1 | 0;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return parse_char_set_content(counter$1,_qV_,end_ind)}
                      return caml_trampoline_return
                              (parse_char_set_content,[0,_qV_,end_ind])}
                  if(switch$0 && 37 === c$0)
                   {add_char(c$1);
                    var _qT_=str_ind$0 + 1 | 0;
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return parse_char_set_content(counter$0,_qT_,end_ind)}
                    return caml_trampoline_return
                            (parse_char_set_content,[0,_qT_,end_ind])}
                  if(37 === c$0)fail_single_percent(str_ind$0);
                  add_char(c$0);
                  var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,c$0=c$1;
                  continue}},
             parse_char_set_after_char=
              function(str_ind,end_ind,c)
               {return caml_trampoline
                        (parse_char_set_after_char$0(0,str_ind,end_ind,c))};
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var match$31=caml_string_get(str,str_ind);
            if(94 === match$31)
             var str_ind$0=str_ind + 1 | 0,reverse=1,str_ind$1=str_ind$0;
            else
             var reverse=0,str_ind$1=str_ind;
            if(str_ind$1 === end_ind)unexpected_end_of_format(end_ind);
            var
             c=caml_string_get(str,str_ind$1),
             next_ind=parse_char_set_after_char(str_ind$1 + 1 | 0,end_ind,c),
             char_set$0=freeze_char_set(char_set),
             char_set$1=reverse?rev_char_set(char_set$0):char_set$0,
             match$21=parse(next_ind,end_ind),
             fmt_rest$19=match$21[1];
            if(get_ign(0))
             var
              ignored$9=[10,get_pad_opt(95),char_set$1],
              _qJ_=[0,[23,ignored$9,fmt_rest$19]];
            else
             var _qJ_=[0,[20,get_pad_opt(91),char_set$1,fmt_rest$19]];
            var fmt_result=_qJ_;
            break;
           case 97:
            var
             match$22=parse(str_ind,end_ind),
             fmt_rest$20=match$22[1],
             fmt_result=[0,[15,fmt_rest$20]];
            break;
           case 99:
            var
             char_format=
              function(fmt_rest)
               {return get_ign(0)?[0,[23,0,fmt_rest]]:[0,[0,fmt_rest]]},
             match$23=parse(str_ind,end_ind),
             fmt_rest$21=match$23[1],
             match$24=get_pad_opt(99);
            if(match$24)
             {if(0 === match$24[1])
               var
                _qK_=get_ign(0)?[0,[23,3,fmt_rest$21]]:[0,[22,fmt_rest$21]],
                _qL_=_qK_;
              else
               var
                _qL_=
                 legacy_behavior$0
                  ?char_format(fmt_rest$21)
                  :invalid_format_message
                    (str_ind,cst_non_zero_widths_are_unsupp);
              var _qM_=_qL_}
            else
             var _qM_=char_format(fmt_rest$21);
            var fmt_result=_qM_;
            break;
           case 114:
            var
             match$25=parse(str_ind,end_ind),
             fmt_rest$22=match$25[1],
             _qN_=get_ign(0)?[0,[23,2,fmt_rest$22]]:[0,[19,fmt_rest$22]],
             fmt_result=_qN_;
            break;
           case 115:
            var
             pad$9=check_no_0(symb,get_padprec(0)),
             match$26=parse(str_ind,end_ind),
             fmt_rest$23=match$26[1];
            if(get_ign(0))
             var
              ignored$10=[0,get_padprec_opt(95)],
              _qO_=[0,[23,ignored$10,fmt_rest$23]];
            else
             var
              match$27=make_padding_fmt_ebb(pad$9,fmt_rest$23),
              fmt_rest$24=match$27[2],
              pad$10=match$27[1],
              _qO_=[0,[2,pad$10,fmt_rest$24]];
            var fmt_result=_qO_;
            break;
           case 116:
            var
             match$28=parse(str_ind,end_ind),
             fmt_rest$25=match$28[1],
             fmt_result=[0,[16,fmt_rest$25]];
            break;
           case 123:
            var
             sub_end$0=search_subformat_end(str_ind,end_ind,125),
             match$29=parse(str_ind,sub_end$0),
             sub_fmt$0=match$29[1],
             match$30=parse(sub_end$0 + 2 | 0,end_ind),
             fmt_rest$26=match$30[1],
             sub_fmtty$0=fmtty_of_fmt(sub_fmt$0);
            if(get_ign(0))
             var
              ignored$11=[8,get_pad_opt(95),sub_fmtty$0],
              _qP_=[0,[23,ignored$11,fmt_rest$26]];
            else
             var _qP_=[0,[13,get_pad_opt(123),sub_fmtty$0,fmt_rest$26]];
            var fmt_result=_qP_;
            break;
           case 66:
           case 98:
            var
             pad$3=check_no_0(symb,get_padprec(0)),
             match$10=parse(str_ind,end_ind),
             fmt_rest$8=match$10[1];
            if(get_ign(0))
             var
              ignored$3=[7,get_padprec_opt(95)],
              _qw_=[0,[23,ignored$3,fmt_rest$8]];
            else
             var
              match$11=make_padding_fmt_ebb(pad$3,fmt_rest$8),
              fmt_rest$9=match$11[2],
              pad$4=match$11[1],
              _qw_=[0,[9,pad$4,fmt_rest$9]];
            var fmt_result=_qw_;
            break;
           case 37:
           case 64:
            var
             match$7=parse(str_ind,end_ind),
             fmt_rest$6=match$7[1],
             fmt_result=[0,[12,symb,fmt_rest$6]];
            break;
           case 76:
           case 108:
           case 110:
            var switch$1=0;
            if(str_ind !== end_ind)
             {var
               symb$0=caml_string_get(str,str_ind),
               _qQ_=symb$0 - 88 | 0,
               switch$2=0;
              if(! (32 < _qQ_ >>> 0))
               switch(_qQ_)
                {case 0:
                 case 12:
                 case 17:
                 case 23:
                 case 29:
                 case 32:var _qC_=1;switch$2 = 1;break
                 }
              if(! switch$2)var _qC_=0;
              if(_qC_){switch$0 = 1;switch$1 = 1}}
            if(! switch$1)
             {var
               match$15=parse(str_ind,end_ind),
               fmt_rest$13=match$15[1],
               switch$3=0;
              if(108 <= symb)
               {if(! (111 <= symb))
                 switch(symb - 108 | 0)
                  {case 0:var counter=0;switch$3 = 1;break;
                   case 1:break;
                   default:var counter=1;switch$3 = 1}}
              else
               if(76 === symb){var counter=2;switch$3 = 1}
              if(! switch$3)throw [0,Assert_failure,_aU_];
              if(get_ign(0))
               var ignored$5=[11,counter],_qB_=[0,[23,ignored$5,fmt_rest$13]];
              else
               var _qB_=[0,[21,counter,fmt_rest$13]];
              var fmt_result=_qB_}
            break;
           case 32:
           case 35:
           case 43:
           case 45:
           case 95:
            var
             fmt_result=
              caml_call3(failwith_message(_aL_),str,pct_ind,symb);
            break;
           case 88:
           case 100:
           case 105:
           case 111:
           case 117:
           case 120:
            var
             _qF_=get_space(0),
             _qG_=get_hash(0),
             iconv$2=
              compute_int_conv(pct_ind,str_ind,get_plus(0),_qG_,_qF_,symb),
             match$19=parse(str_ind,end_ind),
             fmt_rest$17=match$19[1];
            if(get_ign(0))
             var
              ignored$8=[2,iconv$2,get_pad_opt(95)],
              _qH_=[0,[23,ignored$8,fmt_rest$17]];
            else
             var
              _qI_=get_prec(0),
              match$20=make_padprec_fmt_ebb(get_int_pad(0),_qI_,fmt_rest$17),
              fmt_rest$18=match$20[3],
              prec$4=match$20[2],
              pad$8=match$20[1],
              _qH_=[0,[4,iconv$2,pad$8,prec$4,fmt_rest$18]];
            var fmt_result=_qH_;
            break;
           case 69:
           case 70:
           case 71:
           case 72:
           case 101:
           case 102:
           case 103:
           case 104:
            var
             space$1=get_space(0),
             hash$1=get_hash(0),
             plus$2=get_plus(0),
             flag=
              plus$2
               ?space$1
                 ?legacy_behavior$0
                   ?1
                   :incompatible_flag(pct_ind,str_ind,32,cst$50)
                 :1
               :space$1?2:0,
             switch$4=0;
            if(73 <= symb)
             {var switcher=symb - 101 | 0;
              if(3 < switcher >>> 0)
               switch$4 = 1;
              else
               {switch(switcher)
                 {case 0:var _qR_=1;break;
                  case 1:var _qR_=0;break;
                  case 2:var _qR_=3;break;
                  default:var _qR_=6}
                var kind=_qR_}}
            else
             if(69 <= symb)
              {var switch$5=0;
               switch(symb - 69 | 0)
                {case 0:var _qS_=2;break;
                 case 1:switch$4 = 1;switch$5 = 1;break;
                 case 2:var _qS_=4;break;
                 default:var _qS_=7}
               if(! switch$5)var kind=_qS_}
             else
              switch$4 = 1;
            if(switch$4)
             {var switch$6=0;
              if(hash$1)
               if(70 === symb)var kind=8;else switch$6 = 1;
              else
               if(70 === symb)var kind=5;else switch$6 = 1;
              if(switch$6)throw [0,Assert_failure,_aW_]}
            var
             fconv=[0,flag,kind],
             match$13=parse(str_ind,end_ind),
             fmt_rest$11=match$13[1];
            if(get_ign(0))
             {var match=get_prec(0);
              if(typeof match === "number")
               var _qy_=match?incompatible_flag(pct_ind,str_ind,95,cst$40):0;
              else
               var ndec=match[1],_qy_=[0,ndec];
              var
               ignored$4=[6,get_pad_opt(95),_qy_],
               _qz_=[0,[23,ignored$4,fmt_rest$11]]}
            else
             var
              _qA_=get_prec(0),
              match$14=make_padprec_fmt_ebb(get_pad(0),_qA_,fmt_rest$11),
              fmt_rest$12=match$14[3],
              prec$3=match$14[2],
              pad$5=match$14[1],
              _qz_=[0,[8,fconv,pad$5,prec$3,fmt_rest$12]];
            var fmt_result=_qz_;
            break;
           default:switch$0 = 1}
        if(switch$0)
         {var switch$7=0;
          if(108 <= symb)
           if(111 <= symb)
            switch$7 = 1;
           else
            {var switch$8=0;
             switch(symb - 108 | 0)
              {case 0:
                var
                 _qf_=caml_string_get(str,str_ind),
                 _qg_=get_space(0),
                 _qh_=get_hash(0),
                 iconv=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_qh_,_qg_,_qf_),
                 match$0=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest=match$0[1];
                if(get_ign(0))
                 var
                  ignored=[3,iconv,get_pad_opt(95)],
                  _qi_=[0,[23,ignored,fmt_rest]];
                else
                 var
                  _qk_=get_prec(0),
                  match$1=make_padprec_fmt_ebb(get_int_pad(0),_qk_,fmt_rest),
                  fmt_rest$0=match$1[3],
                  prec$0=match$1[2],
                  pad$0=match$1[1],
                  _qi_=[0,[5,iconv,pad$0,prec$0,fmt_rest$0]];
                var _qj_=_qi_;
                break;
               case 1:switch$7 = 1;switch$8 = 1;break;
               default:
                var
                 _ql_=caml_string_get(str,str_ind),
                 _qm_=get_space(0),
                 _qn_=get_hash(0),
                 iconv$0=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_qn_,_qm_,_ql_),
                 match$2=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest$1=match$2[1];
                if(get_ign(0))
                 var
                  ignored$0=[4,iconv$0,get_pad_opt(95)],
                  _qo_=[0,[23,ignored$0,fmt_rest$1]];
                else
                 var
                  _qp_=get_prec(0),
                  match$3=make_padprec_fmt_ebb(get_int_pad(0),_qp_,fmt_rest$1),
                  fmt_rest$2=match$3[3],
                  prec$1=match$3[2],
                  pad$1=match$3[1],
                  _qo_=[0,[6,iconv$0,pad$1,prec$1,fmt_rest$2]];
                var _qj_=_qo_}
             if(! switch$8)var fmt_result=_qj_}
          else
           if(76 === symb)
            {var
              _qq_=caml_string_get(str,str_ind),
              _qr_=get_space(0),
              _qs_=get_hash(0),
              iconv$1=
               compute_int_conv
                (pct_ind,str_ind + 1 | 0,get_plus(0),_qs_,_qr_,_qq_),
              match$4=parse(str_ind + 1 | 0,end_ind),
              fmt_rest$3=match$4[1];
             if(get_ign(0))
              var
               ignored$1=[5,iconv$1,get_pad_opt(95)],
               _qt_=[0,[23,ignored$1,fmt_rest$3]];
             else
              var
               _qu_=get_prec(0),
               match$5=make_padprec_fmt_ebb(get_int_pad(0),_qu_,fmt_rest$3),
               fmt_rest$4=match$5[3],
               prec$2=match$5[2],
               pad$2=match$5[1],
               _qt_=[0,[7,iconv$1,pad$2,prec$2,fmt_rest$4]];
             var fmt_result=_qt_}
           else
            switch$7 = 1;
          if(switch$7)
           var
            fmt_result=
             caml_call3(failwith_message(_aI_),str,str_ind - 1 | 0,symb)}
        if(1 - legacy_behavior$0)
         {var _p8_=1 - plus_used[1],plus$0=_p8_?plus:_p8_;
          if(plus$0)incompatible_flag(pct_ind,str_ind,symb,cst$41);
          var _p9_=1 - hash_used[1],hash$0=_p9_?hash:_p9_;
          if(hash$0)incompatible_flag(pct_ind,str_ind,symb,cst$42);
          var _p__=1 - space_used[1],space$0=_p__?space:_p__;
          if(space$0)incompatible_flag(pct_ind,str_ind,symb,cst$43);
          var _p$_=1 - pad_used[1],_qa_=_p$_?caml_notequal([0,pad],_aJ_):_p$_;
          if(_qa_)incompatible_flag(pct_ind,str_ind,symb,cst_padding$0);
          var
           _qb_=1 - prec_used[1],
           _qc_=_qb_?caml_notequal([0,prec],_aK_):_qb_;
          if(_qc_)
           {var _qd_=ign?95:symb;
            incompatible_flag(pct_ind,str_ind,_qd_,cst_precision$2)}
          var plus$1=ign?plus:ign;
          if(plus$1)incompatible_flag(pct_ind,str_ind,95,cst$44)}
        var _qe_=1 - ign_used[1],ign$0=_qe_?ign:_qe_;
        if(ign$0)
         {var switch$9=0;
          if(38 <= symb)
           {if(44 !== symb && 64 !== symb)switch$9 = 1}
          else
           if(33 !== symb && ! (37 <= symb))switch$9 = 1;
          var switch$10=0;
          if(switch$9 || ! legacy_behavior$0)switch$10 = 1;
          if(switch$10)incompatible_flag(pct_ind,str_ind,symb,cst$45)}
        return fmt_result}
      function parse(lit_start,end_ind)
       {var str_ind=lit_start;
        for(;;)
         {if(str_ind === end_ind)return add_literal(lit_start,str_ind,0);
          var match=caml_string_get(str,str_ind);
          if(37 === match)
           {var str_ind$2=str_ind + 1 | 0;
            if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
            var
             match$1=caml_string_get(str,str_ind$2),
             _p7_=
              95 === match$1
               ?parse_flags(str_ind,str_ind$2 + 1 | 0,end_ind,1)
               :parse_flags(str_ind,str_ind$2,end_ind,0),
             fmt_rest=_p7_[1];
            return add_literal(lit_start,str_ind,fmt_rest)}
          if(64 === match)
           {var str_ind$0=str_ind + 1 | 0;
            if(str_ind$0 === end_ind)
             var match$0=_aM_;
            else
             {var c=caml_string_get(str,str_ind$0),switch$0=0;
              if(65 <= c)
               if(94 <= c)
                {var switcher=c - 123 | 0;
                 if(2 < switcher >>> 0)
                  switch$0 = 1;
                 else
                  switch(switcher)
                   {case 0:
                     var match$0=parse_tag(1,str_ind$0 + 1 | 0,end_ind);break;
                    case 1:switch$0 = 1;break;
                    default:
                     var
                      match$3=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$2=match$3[1],
                      match$0=[0,[17,1,fmt_rest$2]]}}
               else
                if(91 <= c)
                 switch(c - 91 | 0)
                  {case 0:
                    var match$0=parse_tag(0,str_ind$0 + 1 | 0,end_ind);break;
                   case 1:switch$0 = 1;break;
                   default:
                    var
                     match$4=parse(str_ind$0 + 1 | 0,end_ind),
                     fmt_rest$3=match$4[1],
                     match$0=[0,[17,0,fmt_rest$3]]}
                else
                 switch$0 = 1;
              else
               if(10 === c)
                var
                 match$5=parse(str_ind$0 + 1 | 0,end_ind),
                 fmt_rest$4=match$5[1],
                 match$0=[0,[17,3,fmt_rest$4]];
               else
                if(32 <= c)
                 switch(c - 32 | 0)
                  {case 0:
                    var
                     match$6=parse(str_ind$0 + 1 | 0,end_ind),
                     fmt_rest$5=match$6[1],
                     match$0=[0,[17,_aN_,fmt_rest$5]];
                    break;
                   case 5:
                    var switch$1=0;
                    if
                     ((str_ind$0 + 1 | 0)
                      <
                      end_ind
                      &&
                      37
                      ===
                      caml_string_get(str,str_ind$0 + 1 | 0))
                     {var
                       match$7=parse(str_ind$0 + 2 | 0,end_ind),
                       fmt_rest$6=match$7[1],
                       match$0=[0,[17,6,fmt_rest$6]];
                      switch$1 = 1}
                    if(! switch$1)
                     var
                      match$8=parse(str_ind$0,end_ind),
                      fmt_rest$7=match$8[1],
                      match$0=[0,[12,64,fmt_rest$7]];
                    break;
                   case 12:
                    var
                     match$9=parse(str_ind$0 + 1 | 0,end_ind),
                     fmt_rest$8=match$9[1],
                     match$0=[0,[17,_aO_,fmt_rest$8]];
                    break;
                   case 14:
                    var
                     match$10=parse(str_ind$0 + 1 | 0,end_ind),
                     fmt_rest$9=match$10[1],
                     match$0=[0,[17,4,fmt_rest$9]];
                    break;
                   case 27:
                    var match$0=parse_good_break(str_ind$0 + 1 | 0,end_ind);
                    break;
                   case 28:
                    var match$0=parse_magic_size(str_ind$0 + 1 | 0,end_ind);
                    break;
                   case 31:
                    var
                     match$11=parse(str_ind$0 + 1 | 0,end_ind),
                     fmt_rest$10=match$11[1],
                     match$0=[0,[17,2,fmt_rest$10]];
                    break;
                   case 32:
                    var
                     match$12=parse(str_ind$0 + 1 | 0,end_ind),
                     fmt_rest$11=match$12[1],
                     match$0=[0,[17,5,fmt_rest$11]];
                    break;
                   default:switch$0 = 1}
                else
                 switch$0 = 1;
              if(switch$0)
               var
                match$2=parse(str_ind$0 + 1 | 0,end_ind),
                fmt_rest$1=match$2[1],
                match$0=[0,[17,[2,c],fmt_rest$1]]}
            var fmt_rest$0=match$0[1];
            return add_literal(lit_start,str_ind,fmt_rest$0)}
          var str_ind$1=str_ind + 1 | 0,str_ind=str_ind$1;
          continue}}
      return parse(0,caml_ml_string_length(str))}
    function format_of_string_fmtty(str,fmtty)
     {var match=fmt_ebb_of_string(0,str),fmt=match[1];
      try
       {var _p5_=[0,type_format(fmt,fmtty),str];return _p5_}
      catch(_p6_)
       {_p6_ = caml_wrap_exception(_p6_);
        if(_p6_ === Type_mismatch)
         {var _p4_=string_of_fmtty(fmtty);
          return caml_call2(failwith_message(_aY_),str,_p4_)}
        throw _p6_}}
    function format_of_string_format(str,param)
     {var
       str$0=param[2],
       fmt=param[1],
       match=fmt_ebb_of_string(0,str),
       fmt$0=match[1];
      try
       {var _p2_=[0,type_format(fmt$0,fmtty_of_fmt(fmt)),str];return _p2_}
      catch(_p3_)
       {_p3_ = caml_wrap_exception(_p3_);
        if(_p3_ === Type_mismatch)
         return caml_call2(failwith_message(_aZ_),str,str$0);
        throw _p3_}}
    var
     CamlinternalFormat=
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
    caml_register_global(791,CamlinternalFormat,"CamlinternalFormat");
    function kfprintf(k,o,param)
     {var fmt=param[1],_p1_=0;
      return make_printf
              (function(acc){output_acc(o,acc);return caml_call1(k,o)},
               _p1_,
               fmt)}
    function kbprintf(k,b,param)
     {var fmt=param[1],_p0_=0;
      return make_printf
              (function(acc){bufput_acc(b,acc);return caml_call1(k,b)},
               _p0_,
               fmt)}
    function ikfprintf(k,oc,param)
     {var fmt=param[1];return make_iprintf(k,oc,fmt)}
    function fprintf(oc,fmt){return kfprintf(function(_pZ_){return 0},oc,fmt)}
    function bprintf(b,fmt){return kbprintf(function(_pY_){return 0},b,fmt)}
    function ifprintf(oc,fmt)
     {return ikfprintf(function(_pX_){return 0},oc,fmt)}
    function ibprintf(b,fmt){return ikfprintf(function(_pW_){return 0},b,fmt)}
    function printf(fmt){return fprintf(stdout,fmt)}
    function eprintf(fmt){return fprintf(stderr,fmt)}
    function ksprintf(k,param)
     {var fmt=param[1];
      function k$0(acc)
       {var buf=create$2(64);
        strput_acc(buf,acc);
        return caml_call1(k,contents(buf))}
      return make_printf(k$0,0,fmt)}
    function sprintf(fmt){return ksprintf(function(s){return s},fmt)}
    var
     Stdlib_Printf=
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       ibprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ikfprintf,
       ksprintf];
    caml_register_global(792,Stdlib_Printf,"Stdlib__Printf");
    var
     Bad=[248,cst_Stdlib_Arg_Bad,caml_fresh_oo_id(0)],
     Help=[248,cst_Stdlib_Arg_Help,caml_fresh_oo_id(0)],
     Stop=[248,cst_Stdlib_Arg_Stop,caml_fresh_oo_id(0)];
    function assoc3(x,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var match=l$0[1],y2=match[2],y1=match[1];
          if(caml_equal(y1,x))return y2;
          var l$1=l$0[2],l$0=l$1;
          continue}
        throw Not_found}}
    function split$1(s)
     {var
       i=index$0(s,61),
       len=caml_ml_string_length(s),
       _pV_=sub$0(s,i + 1 | 0,len - (i + 1 | 0) | 0);
      return [0,sub$0(s,0,i),_pV_]}
    function make_symlist(prefix,sep,suffix,l)
     {if(l)
       {var t=l[2],h=l[1],_pU_=cat(prefix,h);
        return cat
                (fold_left$0(function(x,y){return cat(x,cat(sep,y))},_pU_,t),
                 suffix)}
      return cst_none}
    function help_action(param){throw [0,Stop,_a2_]}
    function add_help(speclist)
     {try
       {assoc3(cst_help$2,speclist);var _pR_=0,_pP_=_pR_}
      catch(_pT_)
       {_pT_ = caml_wrap_exception(_pT_);
        if(_pT_ !== Not_found)throw _pT_;
        var
         _pP_=
          [0,[0,cst_help,[0,help_action],cst_Display_this_list_of_optio],0]}
      try
       {assoc3(cst_help$1,speclist);var _pQ_=0,add2=_pQ_}
      catch(_pS_)
       {_pS_ = caml_wrap_exception(_pS_);
        if(_pS_ !== Not_found)throw _pS_;
        var
         add2=
          [0,
           [0,cst_help$0,[0,help_action],cst_Display_this_list_of_optio$0],
           0]}
      return append(speclist,append(_pP_,add2))}
    function usage_b(buf,speclist,errmsg)
     {caml_call1(bprintf(buf,_a3_),errmsg);
      var _pM_=add_help(speclist);
      return iter$2
              (function(param)
                {var
                  doc=param[3],
                  spec=param[2],
                  key=param[1],
                  _pN_=0 < caml_ml_string_length(doc)?1:0;
                 if(_pN_)
                  {if(11 === spec[0])
                    {var l=spec[1],_pO_=make_symlist(cst$53,cst$52,cst$51,l);
                     return caml_call3(bprintf(buf,_a1_),key,_pO_,doc)}
                   return caml_call2(bprintf(buf,_a0_),key,doc)}
                 return _pN_},
               _pM_)}
    function usage_string(speclist,errmsg)
     {var b=create$2(200);usage_b(b,speclist,errmsg);return contents(b)}
    function usage(speclist,errmsg)
     {var _pL_=usage_string(speclist,errmsg);
      return caml_call1(eprintf(_a4_),_pL_)}
    var current=[0,0];
    function bool_of_string_opt$0(x)
     {try
       {var _pJ_=[0,bool_of_string(x)];return _pJ_}
      catch(_pK_)
       {_pK_ = caml_wrap_exception(_pK_);
        if(_pK_[1] === Invalid_argument)return 0;
        throw _pK_}}
    function int_of_string_opt$0(x)
     {try
       {var _pH_=[0,caml_int_of_string(x)];return _pH_}
      catch(_pI_)
       {_pI_ = caml_wrap_exception(_pI_);
        if(_pI_[1] === Failure)return 0;
        throw _pI_}}
    function float_of_string_opt(x)
     {try
       {var _pF_=[0,caml_float_of_string(x)];return _pF_}
      catch(_pG_)
       {_pG_ = caml_wrap_exception(_pG_);
        if(_pG_[1] === Failure)return 0;
        throw _pG_}}
    function parse_and_expand_argv_dynamic_
     (allow_expand,current,argv,speclist,anonfun,errmsg)
     {var initpos=current[1];
      function convert_error(error)
       {var
         b=create$2(200),
         progname=
          initpos < argv[1].length - 1
           ?caml_check_bound(argv[1],initpos)[1 + initpos]
           :cst$54;
        switch(error[0])
         {case 0:
           var _pE_=error[1];
           if
            (caml_string_notequal(_pE_,cst_help$3)
             &&
             caml_string_notequal(_pE_,cst_help$4))
            caml_call2(bprintf(b,_a5_),progname,_pE_);
           break;
          case 1:
           var expected=error[3],arg=error[2],opt=error[1];
           caml_call4(bprintf(b,_a8_),progname,arg,opt,expected);
           break;
          case 2:var s=error[1];caml_call2(bprintf(b,_a9_),progname,s);break;
          default:var s$0=error[1];caml_call2(bprintf(b,_a__),progname,s$0)}
        usage_b(b,speclist[1],errmsg);
        if(! caml_equal(error,_a6_) && ! caml_equal(error,_a7_))
         return [0,Bad,contents(b)];
        return [0,Help,contents(b)]}
      current[1]++;
      for(;;)
       {if(current[1] < argv[1].length - 1)
         {try
           {var
             _pt_=current[1],
             s=caml_check_bound(argv[1],_pt_)[1 + _pt_],
             switch$0=0;
            if(1 <= caml_ml_string_length(s) && 45 === caml_string_get(s,0))
             {try
               {var
                 follow$1=0,
                 _pv_=assoc3(s,speclist[1]),
                 follow$0=follow$1,
                 action=_pv_}
              catch(_pC_)
               {_pC_ = caml_wrap_exception(_pC_);
                if(_pC_ !== Not_found)throw _pC_;
                try
                 {var
                   match=split$1(s),
                   arg=match[2],
                   keyword=match[1],
                   follow=[0,arg],
                   _pu_=assoc3(keyword,speclist[1])}
                catch(_pD_)
                 {_pD_ = caml_wrap_exception(_pD_);
                  if(_pD_ === Not_found)throw [0,Stop,[0,s]];
                  throw _pD_;
                  var _pw_=_pD_}
                var follow$0=follow,action=_pu_,_px_=_pC_}
              var
               no_arg$0=
                function(s,follow)
                 {function no_arg(param)
                   {if(follow)
                     {var arg=follow[1];throw [0,Stop,[1,s,arg,cst_no_argument]]}
                    return 0}
                  return no_arg},
               no_arg=no_arg$0(s,follow$0),
               get_arg$0=
                function(s,follow)
                 {function get_arg(param)
                   {if(follow){var arg=follow[1];return arg}
                    if((current[1] + 1 | 0) < argv[1].length - 1)
                     {var _pB_=current[1] + 1 | 0;
                      return caml_check_bound(argv[1],_pB_)[1 + _pB_]}
                    throw [0,Stop,[2,s]]}
                  return get_arg},
               get_arg=get_arg$0(s,follow$0),
               consume_arg$0=
                function(follow)
                 {function consume_arg(param)
                   {return follow?0:(current[1]++,0)}
                  return consume_arg},
               consume_arg=consume_arg$0(follow$0),
               treat_action$0=
                function(s,no_arg,get_arg,consume_arg)
                 {function treat_action(param)
                   {switch(param[0])
                     {case 0:var f=param[1];no_arg(0);return caml_call1(f,0);
                      case 1:
                       var
                        f$0=param[1],
                        arg=get_arg(0),
                        match=bool_of_string_opt$0(arg);
                       if(match)
                        {var s$0=match[1];caml_call1(f$0,s$0);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg,cst_a_boolean]];
                      case 2:var r=param[1];no_arg(0);r[1] = 1;return 0;
                      case 3:var r$0=param[1];no_arg(0);r$0[1] = 0;return 0;
                      case 4:
                       var f$1=param[1],arg$0=get_arg(0);
                       caml_call1(f$1,arg$0);
                       return consume_arg(0);
                      case 5:
                       var r$1=param[1];r$1[1] = get_arg(0);return consume_arg(0);
                      case 6:
                       var
                        f$2=param[1],
                        arg$1=get_arg(0),
                        match$0=int_of_string_opt$0(arg$1);
                       if(match$0)
                        {var x=match$0[1];caml_call1(f$2,x);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$1,cst_an_integer]];
                      case 7:
                       var
                        r$2=param[1],
                        arg$2=get_arg(0),
                        match$1=int_of_string_opt$0(arg$2);
                       if(match$1)
                        {var x$0=match$1[1];r$2[1] = x$0;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$2,cst_an_integer$0]];
                      case 8:
                       var
                        f$3=param[1],
                        arg$3=get_arg(0),
                        match$2=float_of_string_opt(arg$3);
                       if(match$2)
                        {var x$1=match$2[1];
                         caml_call1(f$3,x$1);
                         return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$3,cst_a_float]];
                      case 9:
                       var
                        r$3=param[1],
                        arg$4=get_arg(0),
                        match$3=float_of_string_opt(arg$4);
                       if(match$3)
                        {var x$2=match$3[1];r$3[1] = x$2;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$4,cst_a_float$0]];
                      case 10:
                       var specs=param[1];
                       no_arg(0);
                       return iter$2(treat_action,specs);
                      case 11:
                       var f$4=param[2],symb=param[1],arg$5=get_arg(0);
                       if(mem(arg$5,symb))
                        {caml_call1(f$4,arg$5);return consume_arg(0)}
                       throw [0,
                              Stop,
                              [1,
                               s,
                               arg$5,
                               cat(cst_one_of,make_symlist(cst$57,cst$56,cst$55,symb))]];
                      case 12:
                       var f$5=param[1];
                       no_arg(0);
                       for(;;)
                        {if(current[1] < (argv[1].length - 1 - 1 | 0))
                          {var _py_=current[1] + 1 | 0;
                           caml_call1(f$5,caml_check_bound(argv[1],_py_)[1 + _py_]);
                           consume_arg(0);
                           continue}
                         return 0}
                      case 13:
                       var f$6=param[1];
                       no_arg(0);
                       var acc=[0,0];
                       for(;;)
                        {if(current[1] < (argv[1].length - 1 - 1 | 0))
                          {var _pA_=current[1] + 1 | 0,_pz_=acc[1];
                           acc[1] = [0,caml_check_bound(argv[1],_pA_)[1 + _pA_],_pz_];
                           consume_arg(0);
                           continue}
                         return caml_call1(f$6,rev(acc[1]))}
                      default:
                       var f$7=param[1];
                       if(1 - allow_expand)
                        throw [0,Invalid_argument,cst_Arg_Expand_is_is_only_allo];
                       var arg$6=get_arg(0),newarg=caml_call1(f$7,arg$6);
                       consume_arg(0);
                       var
                        before=sub$1(argv[1],0,current[1] + 1 | 0),
                        after=
                         sub$1
                          (argv[1],
                           current[1] + 1 | 0,
                           (argv[1].length - 1 - current[1] | 0) - 1 | 0);
                       argv[1]
                       =
                       caml_array_concat([0,before,[0,newarg,[0,after,0]]]);
                       return 0}}
                  return treat_action},
               treat_action=treat_action$0(s,no_arg,get_arg,consume_arg);
              treat_action(action);
              switch$0 = 1}
            if(! switch$0)caml_call1(anonfun,s)}
          catch(exn$0)
           {exn$0 = caml_wrap_exception(exn$0);
            if(exn$0[1] === Bad){var m=exn$0[2];throw convert_error([3,m])}
            if(exn$0[1] === Stop){var e=exn$0[2];throw convert_error(e)}
            throw exn$0;
            var exn=exn$0}
          current[1]++;
          continue}
        return 0}}
    function parse_and_expand_argv_dynamic
     (current,argv,speclist,anonfun,errmsg)
     {return parse_and_expand_argv_dynamic_
              (1,current,argv,speclist,anonfun,errmsg)}
    function parse_argv_dynamic(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_and_expand_argv_dynamic_
              (0,current$0,[0,argv],speclist,anonfun,errmsg)}
    function parse_argv(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_argv_dynamic
              ([0,current$0],argv,[0,speclist],anonfun,errmsg)}
    function parse(l,f,msg)
     {try
       {var _ps_=parse_argv(0,caml_sys_argv(0),l,f,msg);return _ps_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_a$_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_ba_),msg$1);return exit(0)}
        throw exn}}
    function parse_dynamic(l,f,msg)
     {try
       {var _pr_=parse_argv_dynamic(0,caml_sys_argv(0),l,f,msg);return _pr_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bb_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bc_),msg$1);return exit(0)}
        throw exn}}
    function parse_expand(l,f,msg)
     {try
       {var
         argv=[0,caml_sys_argv(0)],
         spec=[0,l],
         current$0=[0,current[1]],
         _pq_=parse_and_expand_argv_dynamic(current$0,argv,spec,f,msg);
        return _pq_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bd_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_be_),msg$1);return exit(0)}
        throw exn}}
    function second_word(s)
     {var len=caml_ml_string_length(s);
      function loop(n)
       {var n$0=n;
        for(;;)
         {if(len <= n$0)return len;
          if(32 === caml_string_get(s,n$0))
           {var n$1=n$0 + 1 | 0,n$0=n$1;continue}
          return n$0}}
      try
       {var n$0=index$0(s,9)}
      catch(_po_)
       {_po_ = caml_wrap_exception(_po_);
        if(_po_ === Not_found)
         {try
           {var n=index$0(s,32)}
          catch(_pp_)
           {_pp_ = caml_wrap_exception(_pp_);
            if(_pp_ === Not_found)return len;
            throw _pp_}
          return loop(n + 1 | 0)}
        throw _po_}
      return loop(n$0 + 1 | 0)}
    function max_arg_len(cur,param)
     {var doc=param[3],spec=param[2],kwd=param[1];
      return 11 === spec[0]
              ?max$1(cur,caml_ml_string_length(kwd))
              :max$1(cur,caml_ml_string_length(kwd) + second_word(doc) | 0)}
    function replace_leading_tab(s)
     {var seen=[0,0];
      return map$5
              (function(c)
                {if(9 === c && ! seen[1]){seen[1] = 1;return 32}return c},
               s)}
    function align(opt,speclist)
     {if(opt)var sth=opt[1],limit=sth;else var limit=max_int;
      var
       completed=add_help(speclist),
       len=fold_left$0(max_arg_len,0,completed),
       len$0=min$1(len,limit);
      return map$3
              (function(ksd)
                {var _pm_=ksd[1],_pn_=ksd[2];
                 if(caml_string_notequal(ksd[3],cst$58))
                  {if(11 === _pn_[0])
                    {var
                      msg$0=ksd[3],
                      cutcol$0=second_word(msg$0),
                      spaces$0=make$1(max$1(0,len$0 - cutcol$0 | 0) + 3 | 0,32);
                     return [0,
                             _pm_,
                             _pn_,
                             cat(cst$59,cat(spaces$0,replace_leading_tab(msg$0)))]}
                   var
                    msg=ksd[3],
                    spec=ksd[2],
                    cutcol=second_word(msg),
                    kwd_len=caml_ml_string_length(_pm_),
                    diff=(len$0 - kwd_len | 0) - cutcol | 0;
                   if(0 < diff)
                    {var
                      spaces=make$1(diff,32),
                      prefix=sub$0(replace_leading_tab(msg),0,cutcol),
                      suffix=
                       sub$0(msg,cutcol,caml_ml_string_length(msg) - cutcol | 0);
                     return [0,_pm_,spec,cat(prefix,cat(spaces,suffix))]}
                   return [0,_pm_,spec,replace_leading_tab(msg)]}
                 return ksd},
               completed)}
    function read_aux(trim,sep,file)
     {var ic=open_in_bin(file),buf=create$2(200),words=[0,0];
      function stash(param)
       {var s=contents(buf);
        if(trim)
         {var len=caml_ml_string_length(s),switch$0=0;
          if(0 < len && 13 === caml_string_get(s,len - 1 | 0))
           {var _pl_=sub$0(s,0,len - 1 | 0);switch$0 = 1}
          if(! switch$0)var _pl_=s;
          var word=_pl_}
        else
         var word=s;
        words[1] = [0,word,words[1]];
        return clear$1(buf)}
      try
       {for(;;)
         {var c=caml_ml_input_char(ic);
          if(c === sep)stash(0);else add_char(buf,c);
          continue}}
      catch(_pk_)
       {_pk_ = caml_wrap_exception(_pk_);
        if(_pk_ === End_of_file)
         {if(0 < buf[2])stash(0);
          caml_ml_close_channel(ic);
          return of_list(rev(words[1]))}
        throw _pk_}}
    var _bf_=10,_bg_=1;
    function read_arg(_pj_){return read_aux(_bg_,_bf_,_pj_)}
    var _bh_=0,_bi_=0;
    function read_arg0(_pi_){return read_aux(_bi_,_bh_,_pi_)}
    function write_aux(sep,file,args)
     {var oc=open_out_bin(file);
      iter$5(function(s){return caml_call2(fprintf(oc,_bj_),s,sep)},args);
      return close_out(oc)}
    var _bk_=10;
    function write_arg(_pg_,_ph_){return write_aux(_bk_,_pg_,_ph_)}
    var _bl_=0;
    function write_arg0(_pe_,_pf_){return write_aux(_bl_,_pe_,_pf_)}
    var
     Stdlib_Arg=
      [0,
       parse,
       parse_dynamic,
       parse_argv,
       parse_argv_dynamic,
       parse_and_expand_argv_dynamic,
       parse_expand,
       Help,
       Bad,
       usage,
       usage_string,
       align,
       current,
       read_arg,
       read_arg0,
       write_arg,
       write_arg0];
    caml_register_global(793,Stdlib_Arg,"Stdlib__Arg");
    var
     Stdlib_Atomic=
      [0,make,get,set,exchange,compare_and_set,fetch_and_add,incr,decr];
    caml_register_global(794,Stdlib_Atomic,"Stdlib__Atomic");
    var printers=[0,0];
    function field(x,i)
     {var f=x[1 + i];
      return is_block(f)
              ?caml_obj_tag(f) === 252
                ?caml_call1(sprintf(_bm_),f)
                :caml_obj_tag(f) === 253?to_string(f):cst$60
              :caml_call1(sprintf(_bn_),f)}
    function other_fields(x,i)
     {if(x.length - 1 <= i)return cst$61;
      var _pc_=other_fields(x,i + 1 | 0),_pd_=field(x,i);
      return caml_call2(sprintf(_bo_),_pd_,_pc_)}
    function use_printers(x)
     {function conv(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1];
            try
             {var switch$0=0,val=caml_call1(hd,x);switch$0 = 1}
            catch(_pb_){}
            if(switch$0 && val){var s=val[1];return [0,s]}
            var param$0=tl;
            continue}
          return 0}}
      return conv(printers[1])}
    function to_string_default(x)
     {if(x === Out_of_memory)return cst_Out_of_memory;
      if(x === Stack_overflow)return cst_Stack_overflow;
      if(x[1] === Match_failure)
       {var match$0=x[2],char$0=match$0[3],line=match$0[2],file=match$0[1];
        return caml_call5
                (sprintf(locfmt),
                 file,
                 line,
                 char$0,
                 char$0 + 5 | 0,
                 cst_Pattern_matching_failed)}
      if(x[1] === Assert_failure)
       {var
         match$1=x[2],
         char$1=match$1[3],
         line$0=match$1[2],
         file$0=match$1[1];
        return caml_call5
                (sprintf(locfmt),
                 file$0,
                 line$0,
                 char$1,
                 char$1 + 6 | 0,
                 cst_Assertion_failed)}
      if(x[1] === Undefined_recursive_module)
       {var
         match$2=x[2],
         char$2=match$2[3],
         line$1=match$2[2],
         file$1=match$2[1];
        return caml_call5
                (sprintf(locfmt),
                 file$1,
                 line$1,
                 char$2,
                 char$2 + 6 | 0,
                 cst_Undefined_recursive_module)}
      if(0 === caml_obj_tag(x))
       {var constructor=x[1][1],match=x.length - 1;
        if(2 < match >>> 0)
         var
          _o9_=other_fields(x,2),
          _o__=field(x,1),
          _pa_=caml_call2(sprintf(_bp_),_o__,_o9_);
        else
         switch(match)
          {case 0:var _pa_=cst$62;break;
           case 1:var _pa_=cst$63;break;
           default:var _o$_=field(x,1),_pa_=caml_call1(sprintf(_bq_),_o$_)}
        return cat(constructor,_pa_)}
      return x[1]}
    function to_string$6(e)
     {var match=use_printers(e);
      if(match){var s=match[1];return s}
      return to_string_default(e)}
    function print(fct,arg)
     {try
       {var _o8_=caml_call1(fct,arg);return _o8_}
      catch(x)
       {x = caml_wrap_exception(x);
        var _o7_=to_string$6(x);
        caml_call1(eprintf(_br_),_o7_);
        caml_ml_flush(stderr);
        throw x}}
    function catch$0(fct,arg)
     {try
       {var _o6_=caml_call1(fct,arg);return _o6_}
      catch(x)
       {x = caml_wrap_exception(x);
        caml_ml_flush(stdout);
        var _o5_=to_string$6(x);
        caml_call1(eprintf(_bs_),_o5_);
        return exit(2)}}
    function raw_backtrace_entries(bt){return bt}
    function convert_raw_backtrace(bt)
     {return [0,runtime.caml_convert_raw_backtrace(bt)]}
    function format_backtrace_slot(pos,slot)
     {function info(is_raise)
       {return is_raise
                ?0 === pos?cst_Raised_at:cst_Re_raised_at
                :0 === pos?cst_Raised_by_primitive_operat:cst_Called_from}
      if(0 === slot[0])
       {var
         _oX_=slot[5],
         _oY_=slot[4],
         _oZ_=slot[3],
         _o0_=slot[6]?cst_inlined:cst$64,
         _o1_=slot[2],
         _o2_=slot[7],
         _o3_=info(slot[1]);
        return [0,
                caml_call7(sprintf(_bt_),_o3_,_o2_,_o1_,_o0_,_oZ_,_oY_,_oX_)]}
      if(slot[1])return 0;
      var _o4_=info(0);
      return [0,caml_call1(sprintf(_bu_),_o4_)]}
    function print_raw_backtrace(outchan,raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],_oV_=a.length - 1 - 1 | 0,_oU_=0;
        if(! (_oV_ < 0))
         {var i=_oU_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(fprintf(outchan,_bv_),str)}
            var _oW_=i + 1 | 0;
            if(_oV_ !== i){var i=_oW_;continue}
            break}}
        return 0}
      return fprintf(outchan,_bw_)}
    function print_backtrace(outchan)
     {return print_raw_backtrace(outchan,caml_get_exception_raw_backtra(0))}
    function raw_backtrace_to_string(raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],b=create$2(1024),_oS_=a.length - 1 - 1 | 0,_oR_=0;
        if(! (_oS_ < 0))
         {var i=_oR_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(bprintf(b,_bx_),str)}
            var _oT_=i + 1 | 0;
            if(_oS_ !== i){var i=_oT_;continue}
            break}}
        return contents(b)}
      return cst_Program_not_linked_with_g_}
    function backtrace_slot_is_raise(param)
     {return 0 === param[0]?param[1]:param[1]}
    function backtrace_slot_is_inline(param){return 0 === param[0]?param[6]:0}
    function backtrace_slot_location(param)
     {return 0 === param[0]?[0,[0,param[2],param[3],param[4],param[5]]]:0}
    function backtrace_slot_defname(param)
     {if(0 === param[0] && caml_string_notequal(param[7],cst$65))
       return [0,param[7]];
      return 0}
    function backtrace_slots(raw_backtrace)
     {var match=convert_raw_backtrace(raw_backtrace);
      if(match)
       {var backtrace=match[1],i$1=backtrace.length - 1 - 1 | 0,i=i$1;
        for(;;)
         {if(-1 === i)
           var _oQ_=0;
          else
           {var
             param=caml_check_bound(backtrace,i)[1 + i],
             _oP_=0 === param[0]?1:0;
            if(! _oP_){var i$0=i - 1 | 0,i=i$0;continue}
            var _oQ_=_oP_}
          return _oQ_?[0,backtrace]:0}}
      return 0}
    function backtrace_slots_of_raw_entry(entry)
     {return backtrace_slots([0,entry])}
    function raw_backtrace_length(bt){return bt.length - 1}
    function get_backtrace(param)
     {return raw_backtrace_to_string(caml_get_exception_raw_backtra(0))}
    function register_printer(fn)
     {for(;;)
       {var
         old_printers=printers[1],
         new_printers=[0,fn,old_printers],
         success=compare_and_set(printers,old_printers,new_printers),
         _oO_=1 - success;
        if(_oO_)continue;
        return _oO_}}
    function exn_slot(x){return 0 === caml_obj_tag(x)?x[1]:x}
    function exn_slot_id(x){var slot=exn_slot(x);return slot[2]}
    function exn_slot_name(x){var slot=exn_slot(x);return slot[1]}
    var errors=_by_.slice();
    function default_uncaught_exception_han(exn,raw_backtrace)
     {var _oM_=to_string$6(exn);
      caml_call1(eprintf(_bz_),_oM_);
      print_raw_backtrace(stderr,raw_backtrace);
      var status=runtime.caml_ml_debug_info_status(0);
      if(status < 0)
       {var _oN_=abs(status);
        prerr_endline(caml_check_bound(errors,_oN_)[1 + _oN_])}
      return caml_ml_flush(stderr)}
    var uncaught_exception_handler=[0,default_uncaught_exception_han];
    function set_uncaught_exception_handler(fn)
     {uncaught_exception_handler[1] = fn;return 0}
    var empty_backtrace=[0];
    function handle_uncaught_exception(exn,debugger_in_use)
     {try
       {try
         {var
           raw_backtrace=
            debugger_in_use?empty_backtrace:caml_get_exception_raw_backtra(0);
          try {do_at_exit(0)}catch(_oL_){}
          try
           {var
             _oH_=caml_call2(uncaught_exception_handler[1],exn,raw_backtrace),
             _oG_=_oH_}
          catch(exn$0)
           {exn$0 = caml_wrap_exception(exn$0);
            var
             raw_backtrace$0=caml_get_exception_raw_backtra(0),
             _oE_=to_string$6(exn);
            caml_call1(eprintf(_bA_),_oE_);
            print_raw_backtrace(stderr,raw_backtrace);
            var _oF_=to_string$6(exn$0);
            caml_call1(eprintf(_bB_),_oF_);
            print_raw_backtrace(stderr,raw_backtrace$0);
            var _oG_=caml_ml_flush(stderr)}
          var _oI_=_oG_}
        catch(_oK_)
         {_oK_ = caml_wrap_exception(_oK_);
          if(_oK_ !== Out_of_memory)throw _oK_;
          var _oI_=prerr_endline(cst_Fatal_error_out_of_memory_)}
        return _oI_}
      catch(_oJ_){return 0}}
    caml_register_named_value
     (caml_string_of_jsbytes("Printexc.handle_uncaught_exception"),
      handle_uncaught_exception);
    function _bC_(_oD_){return runtime.caml_raw_backtrace_next_slot(_oD_)}
    function _bD_(_oC_){return runtime.caml_convert_raw_backtrace_slot(_oC_)}
    function _bE_(_oB_,_oA_)
     {return runtime.caml_raw_backtrace_slot(_oB_,_oA_)}
    var
     _bF_=
      [0,
       backtrace_slot_is_raise,
       backtrace_slot_is_inline,
       backtrace_slot_location,
       backtrace_slot_defname,
       format_backtrace_slot];
    function _bG_(_oz_){return caml_get_exception_raw_backtra(_oz_)}
    function _bH_(_oy_){return runtime.caml_backtrace_status(_oy_)}
    var
     Stdlib_Printexc=
      [0,
       to_string$6,
       to_string_default,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       function(_ox_){return runtime.caml_record_backtrace(_ox_)},
       _bH_,
       register_printer,
       use_printers,
       raw_backtrace_entries,
       _bG_,
       print_raw_backtrace,
       raw_backtrace_to_string,
       default_uncaught_exception_han,
       set_uncaught_exception_handler,
       backtrace_slots,
       backtrace_slots_of_raw_entry,
       _bF_,
       raw_backtrace_length,
       _bE_,
       _bD_,
       _bC_,
       exn_slot_id,
       exn_slot_name];
    caml_register_global(795,Stdlib_Printexc,"Stdlib__Printexc");
    function const$0(c,param){return c}
    function flip(f,x,y){return caml_call2(f,y,x)}
    function negate(p,v){return 1 - caml_call1(p,v)}
    var
     Finally_raised=
      [248,cst_Stdlib_Fun_Finally_raised,caml_fresh_oo_id(0)];
    register_printer
     (function(param)
       {if(param[1] === Finally_raised)
         {var exn=param[2];
          return [0,cat(cst_Fun_Finally_raised,to_string$6(exn))]}
        return 0});
    function protect(finally$0,work)
     {function finally_no_exn(param)
       {try
         {var _ow_=caml_call1(finally$0,0);return _ow_}
        catch(e)
         {e = caml_wrap_exception(e);
          var bt=caml_get_exception_raw_backtra(0),exn=[0,Finally_raised,e];
          caml_restore_raw_backtrace(exn,bt);
          throw exn}}
      try
       {var result=caml_call1(work,0)}
      catch(work_exn)
       {work_exn = caml_wrap_exception(work_exn);
        var work_bt=caml_get_exception_raw_backtra(0);
        finally_no_exn(0);
        caml_restore_raw_backtrace(work_exn,work_bt);
        throw work_exn}
      finally_no_exn(0);
      return result}
    var Stdlib_Fun=[0,const$0,flip,negate,protect,Finally_raised];
    caml_register_global(796,Stdlib_Fun,"Stdlib__Fun");
    function print_stat(c)
     {var st=runtime.caml_gc_stat(0),_oe_=st[4];
      caml_call1(fprintf(c,_bI_),_oe_);
      var _of_=st[5];
      caml_call1(fprintf(c,_bJ_),_of_);
      var _og_=st[14];
      caml_call1(fprintf(c,_bK_),_og_);
      var _oh_=st[17];
      caml_call1(fprintf(c,_bL_),_oh_);
      fprintf(c,_bM_);
      var
       _oi_=st[1],
       l1=caml_ml_string_length(caml_call1(sprintf(_bN_),_oi_)),
       _oj_=st[1];
      caml_call2(fprintf(c,_bO_),l1,_oj_);
      var _ok_=st[2];
      caml_call2(fprintf(c,_bP_),l1,_ok_);
      var _ol_=st[3];
      caml_call2(fprintf(c,_bQ_),l1,_ol_);
      fprintf(c,_bR_);
      var
       _om_=st[15],
       l2=caml_ml_string_length(caml_call1(sprintf(_bS_),_om_)),
       _on_=st[15];
      caml_call2(fprintf(c,_bT_),l2,_on_);
      var _oo_=st[6];
      caml_call2(fprintf(c,_bU_),l2,_oo_);
      var _op_=st[8];
      caml_call2(fprintf(c,_bV_),l2,_op_);
      var _oq_=st[10];
      caml_call2(fprintf(c,_bW_),l2,_oq_);
      var _or_=st[12];
      caml_call2(fprintf(c,_bX_),l2,_or_);
      var _os_=st[13];
      caml_call2(fprintf(c,_bY_),l2,_os_);
      fprintf(c,_bZ_);
      var _ot_=st[9];
      caml_call1(fprintf(c,_b0_),_ot_);
      var _ou_=st[11];
      caml_call1(fprintf(c,_b1_),_ou_);
      var _ov_=st[7];
      return caml_call1(fprintf(c,_b2_),_ov_)}
    function allocated_bytes(param)
     {var
       match=runtime.caml_gc_counters(0),
       ma=match[3],
       pro=match[2],
       mi=match[1];
      return (mi + ma - pro) * 4}
    function create_alarm(f){return [0,1]}
    function delete_alarm(a){a[1] = 0;return 0}
    function _b3_(param){return 0}
    function _b4_(param){return 0}
    function _b5_(param){return 0}
    function _b6_(param){return 0}
    var null_tracker=[0,function(param){return 0},_b6_,_b5_,_b4_,_b3_];
    function start(sampling_rate,opt,tracker)
     {if(opt)
       var sth=opt[1],callstack_size=sth;
      else
       var callstack_size=max_int;
      return runtime.caml_memprof_start(sampling_rate,callstack_size,tracker)}
    var _b7_=[0,null_tracker,start,runtime.caml_memprof_stop];
    function _b8_(_od_){return runtime.caml_final_release(_od_)}
    function _b9_(_oc_,_ob_)
     {return runtime.caml_final_register_called_without_value(_oc_,_ob_)}
    var
     Stdlib_Gc=
      [0,
       print_stat,
       allocated_bytes,
       function(_oa_,_n$_){return runtime.caml_final_register(_oa_,_n$_)},
       _b9_,
       _b8_,
       create_alarm,
       delete_alarm,
       _b7_];
    caml_register_global(797,Stdlib_Gc,"Stdlib__Gc");
    function string(str)
     {return caml_md5_string(str,0,caml_ml_string_length(str))}
    function bytes(b){return string(caml_string_of_bytes(b))}
    function substring(str,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(str) - len | 0) < ofs))
       return caml_md5_string(str,ofs,len);
      return invalid_arg(cst_Digest_substring)}
    function subbytes(b,ofs,len)
     {return substring(caml_string_of_bytes(b),ofs,len)}
    function file(filename)
     {var ic=open_in_bin(filename);
      try
       {var d=runtime.caml_md5_chan(ic,-1)}
      catch(e){e = caml_wrap_exception(e);caml_ml_close_channel(ic);throw e}
      caml_ml_close_channel(ic);
      return d}
    function output$0(chan,digest){return output_string(chan,digest)}
    function input$0(chan){return really_input_string(chan,16)}
    function char_hex(n){var _n__=10 <= n?87:48;return n + _n__ | 0}
    function to_hex(d)
     {if(16 !== caml_ml_string_length(d))invalid_arg(cst_Digest_to_hex);
      var result=caml_create_bytes(32),i=0;
      for(;;)
       {var x=caml_string_get(d,i);
        caml_bytes_unsafe_set(result,i * 2 | 0,char_hex(x >>> 4 | 0));
        caml_bytes_unsafe_set(result,(i * 2 | 0) + 1 | 0,char_hex(x & 15));
        var _n9_=i + 1 | 0;
        if(15 !== i){var i=_n9_;continue}
        return caml_string_of_bytes(result)}}
    function from_hex(s)
     {if(32 !== caml_ml_string_length(s))invalid_arg(cst_Digest_from_hex);
      function digit(c)
       {if(65 <= c)
         {if(97 <= c)
           {if(! (103 <= c))return (c - 97 | 0) + 10 | 0}
          else
           if(! (71 <= c))return (c - 65 | 0) + 10 | 0}
        else
         if(! (9 < c - 48 >>> 0))return c - 48 | 0;
        throw [0,Invalid_argument,cst_Digest_from_hex$0]}
      var result=caml_create_bytes(16),i=0;
      for(;;)
       {var i$0=2 * i | 0,_n7_=digit(caml_string_get(s,i$0 + 1 | 0));
        caml_bytes_set
         (result,i,chr((digit(caml_string_get(s,i$0)) << 4) + _n7_ | 0));
        var _n8_=i + 1 | 0;
        if(15 !== i){var i=_n8_;continue}
        return caml_string_of_bytes(result)}}
    var
     Stdlib_Digest=
      [0,
       compare$8,
       equal$8,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output$0,
       input$0,
       to_hex,
       from_hex];
    caml_register_global(798,Stdlib_Digest,"Stdlib__Digest");
    function new_state(param){return [0,caml_make_vect(55,0),0]}
    function assign(st1,st2)
     {blit$1(st2[1],0,st1[1],0,55);st1[2] = st2[2];return 0}
    function full_init(s,seed)
     {var seed$0=0 === seed.length - 1?[0,0]:seed,l=seed$0.length - 1,i$0=0;
      for(;;)
       {caml_check_bound(s[1],i$0)[1 + i$0] = i$0;
        var _n6_=i$0 + 1 | 0;
        if(54 !== i$0){var i$0=_n6_;continue}
        var accu=[0,cst_x$1],_n2_=54 + max$1(55,l) | 0,_n1_=0;
        if(! (_n2_ < 0))
         {var i=_n1_;
          for(;;)
           {var
             j=i % 55 | 0,
             k=caml_mod(i,l),
             x=caml_check_bound(seed$0,k)[1 + k];
            accu[1] = string(cat(accu[1],caml_string_of_jsbytes("" + x)));
            var
             _n3_=accu[1],
             _nX_=caml_string_get(_n3_,3) << 24,
             _nY_=caml_string_get(_n3_,2) << 16,
             _nZ_=caml_string_get(_n3_,1) << 8,
             _n0_=((caml_string_get(_n3_,0) + _nZ_ | 0) + _nY_ | 0) + _nX_ | 0,
             _n4_=(caml_check_bound(s[1],j)[1 + j] ^ _n0_) & 1073741823;
            caml_check_bound(s[1],j)[1 + j] = _n4_;
            var _n5_=i + 1 | 0;
            if(_n2_ !== i){var i=_n5_;continue}
            break}}
        s[2] = 0;
        return 0}}
    function make$3(seed)
     {var result=new_state(0);full_init(result,seed);return result}
    function make_self_init(param){return make$3(caml_sys_random_seed(0))}
    function copy$5(s){var result=new_state(0);assign(result,s);return result}
    function bits(s)
     {s[2] = (s[2] + 1 | 0) % 55 | 0;
      var
       _nU_=s[2],
       curval=caml_check_bound(s[1],_nU_)[1 + _nU_],
       _nV_=(s[2] + 24 | 0) % 55 | 0,
       newval=
        caml_check_bound(s[1],_nV_)[1 + _nV_]
        +
        (curval ^ (curval >>> 25 | 0) & 31)
        |
        0,
       newval30=newval & 1073741823,
       _nW_=s[2];
      caml_check_bound(s[1],_nW_)[1 + _nW_] = newval30;
      return newval30}
    function intaux(s,n)
     {for(;;)
       {var r=bits(s),v=caml_mod(r,n);
        if(((1073741823 - n | 0) + 1 | 0) < (r - v | 0))continue;
        return v}}
    function int$0(s,bound)
     {if(! (1073741823 < bound) && 0 < bound)return intaux(s,bound);
      return invalid_arg(cst_Random_int)}
    function full_int(s,bound)
     {if(0 < bound)
       {if(1073741823 < bound)
         for(;;)
          {var b1=bits(s),b2=bits(s);
           if(bound <= 2147483647)
            var bpos=(b2 & 1073725440) << 1 | b1 >>> 15 | 0,r=bpos;
           else
            var
             b3=bits(s),
             bpos$0=
              ((b3 & 1073741312) << 12 | b2 >>> 9 | 0)
              <<
              20
              |
              b1
              >>>
              10
              |
              0,
             r=bpos$0;
           var v=caml_mod(r,bound);
           if(((2147483647 - bound | 0) + 1 | 0) < (r - v | 0))continue;
           return v}
        return intaux(s,bound)}
      return invalid_arg(cst_Random_full_int)}
    function int32(s,bound)
     {if(caml_lessequal(bound,0))return invalid_arg(cst_Random_int32);
      for(;;)
       {var b1=bits(s),b2=(bits(s) & 1) << 30,r=b1 | b2,v=caml_mod(r,bound);
        if(caml_greaterthan(r - v | 0,(2147483647 - bound | 0) + 1 | 0))
         continue;
        return v}}
    function int64(s,bound)
     {if(caml_lessequal(bound,_b$_))return invalid_arg(cst_Random_int64);
      for(;;)
       {var
         b1=caml_int64_of_int32(bits(s)),
         b2=caml_int64_shift_left(caml_int64_of_int32(bits(s)),30),
         b3=caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7),60),
         r=caml_int64_or(b1,caml_int64_or(b2,b3)),
         v=runtime.caml_int64_mod(r,bound);
        if
         (caml_greaterthan
           (caml_int64_sub(r,v),
            caml_int64_add(caml_int64_sub(max_int$2,bound),_b__)))
         continue;
        return v}}
    function nativeint(s,bound){return int32(s,bound)}
    function float$0(s,bound)
     {var r1=bits(s),r2=bits(s);
      return (r1 / 1073741824. + r2) / 1073741824. * bound}
    function bool(s){return 0 === (bits(s) & 1)?1:0}
    var default$0=[0,_ca_.slice(),0];
    function bits$0(param){return bits(default$0)}
    function int$1(bound){return int$0(default$0,bound)}
    function full_int$0(bound){return full_int(default$0,bound)}
    function int32$0(bound){return int32(default$0,bound)}
    function nativeint$0(bound){return nativeint(default$0,bound)}
    function int64$0(bound){return int64(default$0,bound)}
    function float$1(scale){return float$0(default$0,scale)}
    function bool$0(param){return bool(default$0)}
    function full_init$0(seed){return full_init(default$0,seed)}
    function init$4(seed){return full_init(default$0,[0,seed])}
    function self_init(param){return full_init$0(caml_sys_random_seed(0))}
    function get_state(param){return copy$5(default$0)}
    function set_state(s){return assign(default$0,s)}
    var
     _cb_=
      [0,
       make$3,
       make_self_init,
       copy$5,
       bits,
       int$0,
       full_int,
       int32,
       nativeint,
       int64,
       float$0,
       bool],
     Stdlib_Random=
      [0,
       init$4,
       full_init$0,
       self_init,
       bits$0,
       int$1,
       full_int$0,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       _cb_,
       get_state,
       set_state];
    caml_register_global(799,Stdlib_Random,"Stdlib__Random");
    function ongoing_traversal(h)
     {var _nS_=h.length - 1 < 4?1:0,_nT_=_nS_ || (h[4] < 0?1:0);return _nT_}
    function flip_ongoing_traversal(h){h[4] = - h[4] | 0;return 0}
    try
     {var _cX_=caml_sys_getenv(cst_OCAMLRUNPARAM),params=_cX_}
    catch(_nQ_)
     {_nQ_ = caml_wrap_exception(_nQ_);
      if(_nQ_ !== Not_found)throw _nQ_;
      try
       {var _cW_=caml_sys_getenv(cst_CAMLRUNPARAM),_cc_=_cW_}
      catch(_nR_)
       {_nR_ = caml_wrap_exception(_nR_);
        if(_nR_ !== Not_found)throw _nR_;
        var _cc_=cst$66}
      var params=_cc_}
    var
     randomized_default=contains$0(params,82),
     randomized=[0,randomized_default];
    function randomize(param){randomized[1] = 1;return 0}
    function is_randomized(param){return randomized[1]}
    var prng=[246,function(_nP_){return caml_call1(_cb_[2],0)}];
    function power_2_above(x,n)
     {var x$0=x;
      for(;;)
       {if(n <= x$0)return x$0;
        if(max_array_length < (x$0 * 2 | 0))return x$0;
        var x$1=x$0 * 2 | 0,x$0=x$1;
        continue}}
    function create$3(opt,initial_size)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var s=power_2_above(16,initial_size);
      if(random)
       var
        _nN_=caml_obj_tag(prng),
        _nO_=250 === _nN_?prng[1]:246 === _nN_?force_lazy_block(prng):prng,
        seed=caml_call1(_cb_[4],_nO_);
      else
       var seed=0;
      return [0,0,caml_make_vect(s,0),seed,s]}
    function clear$2(h)
     {var _nM_=0 < h[1]?1:0;
      return _nM_?(h[1] = 0,fill$0(h[2],0,h[2].length - 1,0)):_nM_}
    function reset$0(h)
     {var len=h[2].length - 1;
      if(4 <= h.length - 1 && len !== abs(h[4]))
       {h[1] = 0;h[2] = caml_make_vect(abs(h[4]),0);return 0}
      return clear$2(h)}
    function copy_bucketlist(param)
     {if(param)
       {var
         key=param[1],
         data=param[2],
         next=param[3],
         prec$0=[0,key,data,next],
         prec=prec$0,
         param$0=next;
        for(;;)
         {if(param$0)
           {var
             key$0=param$0[1],
             data$0=param$0[2],
             next$0=param$0[3],
             r=[0,key$0,data$0,next$0];
            prec[3] = r;
            var prec=r,param$0=next$0;
            continue}
          return prec$0}}
      return 0}
    function copy$6(init)
     {var _nJ_=init[4],_nK_=init[3],_nL_=map$6(copy_bucketlist,init[2]);
      return [0,init[1],_nL_,_nK_,_nJ_]}
    function length$4(h){return h[1]}
    function insert_all_buckets(indexfun,inplace,odata,ndata)
     {var
       nsize=ndata.length - 1,
       ndata_tail=caml_make_vect(nsize,0),
       _nD_=odata.length - 1 - 1 | 0,
       _nC_=0;
      if(! (_nD_ < 0))
       {var i$0=_nC_;
        a:
        for(;;)
         {var cell$1=caml_check_bound(odata,i$0)[1 + i$0],cell=cell$1;
          for(;;)
           {if(cell)
             {var
               key=cell[1],
               data=cell[2],
               next=cell[3],
               cell$0=inplace?cell:[0,key,data,0],
               nidx=caml_call1(indexfun,key),
               match=caml_check_bound(ndata_tail,nidx)[1 + nidx];
              if(match)
               match[3] = cell$0;
              else
               caml_check_bound(ndata,nidx)[1 + nidx] = cell$0;
              caml_check_bound(ndata_tail,nidx)[1 + nidx] = cell$0;
              var cell=next;
              continue}
            var _nI_=i$0 + 1 | 0;
            if(_nD_ !== i$0){var i$0=_nI_;continue a}
            break}
          break}}
      if(inplace)
       {var _nF_=nsize - 1 | 0,_nE_=0;
        if(! (_nF_ < 0))
         {var i=_nE_;
          for(;;)
           {var match$0=caml_check_bound(ndata_tail,i)[1 + i];
            if(match$0)match$0[3] = 0;
            var _nH_=i + 1 | 0;
            if(_nF_ !== i){var i=_nH_;continue}
            break}}
        var _nG_=0}
      else
       var _nG_=inplace;
      return _nG_}
    function resize$0(indexfun,h)
     {var
       odata=h[2],
       osize=odata.length - 1,
       nsize=osize * 2 | 0,
       _nB_=nsize < max_array_length?1:0;
      if(_nB_)
       {var ndata=caml_make_vect(nsize,0),inplace=1 - ongoing_traversal(h);
        h[2] = ndata;
        return insert_all_buckets(caml_call1(indexfun,h),inplace,odata,ndata)}
      return _nB_}
    function iter$10(f,h)
     {function do_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var key=param$0[1],data=param$0[2],next=param$0[3];
            caml_call2(f,key,data);
            var param$0=next;
            continue}
          return 0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],_nx_=d.length - 1 - 1 | 0,_nw_=0;
        if(! (_nx_ < 0))
         {var i=_nw_;
          for(;;)
           {do_bucket(caml_check_bound(d,i)[1 + i]);
            var _nA_=i + 1 | 0;
            if(_nx_ !== i){var i=_nA_;continue}
            break}}
        var _ny_=1 - old_trav,_nz_=_ny_?flip_ongoing_traversal(h):_ny_;
        return _nz_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function filter_map_inplace_bucket(f,h,i,prec,slot)
     {var prec$0=prec,slot$0=slot;
      for(;;)
       {if(slot$0)
         {var
           key=slot$0[1],
           data=slot$0[2],
           next=slot$0[3],
           match=caml_call2(f,key,data);
          if(match)
           {var data$0=match[1];
            if(prec$0)
             prec$0[3] = slot$0;
            else
             caml_check_bound(h[2],i)[1 + i] = slot$0;
            slot$0[2] = data$0;
            var prec$0=slot$0,slot$0=next;
            continue}
          h[1] = h[1] - 1 | 0;
          var slot$0=next;
          continue}
        return prec$0
                ?(prec$0[3] = 0,0)
                :(caml_check_bound(h[2],i)[1 + i] = 0,0)}}
    function filter_map_inplace(f,h)
     {var d=h[2],old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var _ns_=d.length - 1 - 1 | 0,_nr_=0;
        if(! (_ns_ < 0))
         {var i=_nr_;
          for(;;)
           {filter_map_inplace_bucket(f,h,i,0,caml_check_bound(h[2],i)[1 + i]);
            var _nv_=i + 1 | 0;
            if(_ns_ !== i){var i=_nv_;continue}
            break}}
        var _nt_=1 - old_trav,_nu_=_nt_?flip_ongoing_traversal(h):_nt_;
        return _nu_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function fold$4(f,h,init)
     {function do_bucket(b,accu)
       {var b$0=b,accu$0=accu;
        for(;;)
         {if(b$0)
           {var
             key=b$0[1],
             data=b$0[2],
             next=b$0[3],
             accu$1=caml_call3(f,key,data,accu$0),
             b$0=next,
             accu$0=accu$1;
            continue}
          return accu$0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],accu=[0,init],_nn_=d.length - 1 - 1 | 0,_nm_=0;
        if(! (_nn_ < 0))
         {var i=_nm_;
          for(;;)
           {var _np_=accu[1];
            accu[1] = do_bucket(caml_check_bound(d,i)[1 + i],_np_);
            var _nq_=i + 1 | 0;
            if(_nn_ !== i){var i=_nq_;continue}
            break}}
        if(1 - old_trav)flip_ongoing_traversal(h);
        var _no_=accu[1];
        return _no_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function bucket_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[3],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function stats(h)
     {var
       _ni_=h[2],
       _nj_=0,
       mbl=
        fold_left$3
         (function(m,b){return max$1(m,bucket_length(0,b))},_nj_,_ni_),
       histo=caml_make_vect(mbl + 1 | 0,0),
       _nk_=h[2];
      iter$5
       (function(b)
         {var
           l=bucket_length(0,b),
           _nl_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
          caml_check_bound(histo,l)[1 + l] = _nl_;
          return 0},
        _nk_);
      return [0,h[1],h[2].length - 1,mbl,histo]}
    function to_seq$9(tbl)
     {var tbl_data=tbl[2];
      function aux(i,buck,param)
       {var i$0=i,buck$0=buck;
        for(;;)
         {if(buck$0)
           {var key=buck$0[1],data=buck$0[2],next=buck$0[3];
            return [0,[0,key,data],function(_nh_){return aux(i$0,next,_nh_)}]}
          if(i$0 === tbl_data.length - 1)return 0;
          var
           buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           buck$0=buck$1;
          continue}}
      var _ne_=0,_nf_=0;
      return function(_ng_){return aux(_nf_,_ne_,_ng_)}}
    function to_seq_keys(m)
     {var _na_=to_seq$9(m);
      function _nb_(_nd_){return _nd_[1]}
      return function(_nc_){return map(_nb_,_na_,_nc_)}}
    function to_seq_values(m)
     {var _m8_=to_seq$9(m);
      function _m9_(_m$_){return _m$_[2]}
      return function(_m__){return map(_m9_,_m8_,_m__)}}
    function MakeSeeded(H)
     {function key_index(h,key)
       {var _m7_=h[2].length - 1 - 1 | 0;
        return caml_call2(H[2],h[3],key) & _m7_}
      function add(h,key,data)
       {var
         i=key_index(h,key),
         bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _m6_=h[2].length - 1 << 1 < h[1]?1:0;
        return _m6_?resize$0(key_index,h):_m6_}
      function remove(h,key)
       {var
         i=key_index(h,key),
         c$0=caml_check_bound(h[2],i)[1 + i],
         prec=0,
         c=c$0;
        for(;;)
         {if(c)
           {var k=c[1],next=c[3];
            if(caml_call2(H[1],k,key))
             {h[1] = h[1] - 1 | 0;
              return prec
                      ?(prec[3] = next,0)
                      :(caml_check_bound(h[2],i)[1 + i] = next,0)}
            var prec=c,c=next;
            continue}
          return 0}}
      function find(h,key)
       {var _m5_=key_index(h,key),match=caml_check_bound(h[2],_m5_)[1 + _m5_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return d1;
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return d2;
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return d3;
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return data;
                  var param=next;
                  continue}
                throw Not_found}}
            throw Not_found}
          throw Not_found}
        throw Not_found}
      function find_opt(h,key)
       {var _m4_=key_index(h,key),match=caml_check_bound(h[2],_m4_)[1 + _m4_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return [0,d1];
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return [0,d2];
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return [0,d3];
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return [0,data];
                  var param=next;
                  continue}
                return 0}}
            return 0}
          return 0}
        return 0}
      function find_all(h,key)
       {function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var k=param$0[1],d=param$0[2],next=param$0[3];
              if(caml_call2(H[1],k,key))return [0,d,find_in_bucket(next)];
              var param$0=next;
              continue}
            return 0}}
        var _m3_=key_index(h,key);
        return find_in_bucket(caml_check_bound(h[2],_m3_)[1 + _m3_])}
      function replace(h,key,data)
       {var
         i=key_index(h,key),
         param$0=caml_check_bound(h[2],i)[1 + i],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3];
            if(! caml_call2(H[1],k,key)){var param=next;continue}
            param[1] = key;
            param[2] = data;
            var _m0_=0}
          else
           var _m0_=1;
          if(_m0_)
           {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
            h[1] = h[1] + 1 | 0;
            var _m1_=h[2].length - 1 << 1 < h[1]?1:0;
            if(_m1_)return resize$0(key_index,h);
            var _m2_=_m1_}
          else
           var _m2_=_m0_;
          return _m2_}}
      function mem(h,key)
       {var
         _mZ_=key_index(h,key),
         param$0=caml_check_bound(h[2],_mZ_)[1 + _mZ_],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3],_mY_=caml_call2(H[1],k,key);
            if(_mY_)return _mY_;
            var param=next;
            continue}
          return 0}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create$3,
              clear$2,
              reset$0,
              copy$6,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$10,
              filter_map_inplace,
              fold$4,
              length$4,
              stats,
              to_seq$9,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function Make$0(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       _mX_=include[1];
      function create(sz){return caml_call2(_mX_,_cd_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function hash$1(x){return caml_hash(10,100,0,x)}
    function hash_param(n1,n2,x){return caml_hash(n1,n2,0,x)}
    function seeded_hash(seed,x){return caml_hash(10,100,seed,x)}
    function key_index(h,key)
     {return 4 <= h.length - 1
              ?caml_hash(10,100,h[3],key) & (h[2].length - 1 - 1 | 0)
              :invalid_arg(cst_Hashtbl_unsupported_hash_t)}
    function add$0(h,key,data)
     {var
       i=key_index(h,key),
       bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
      caml_check_bound(h[2],i)[1 + i] = bucket;
      h[1] = h[1] + 1 | 0;
      var _mW_=h[2].length - 1 << 1 < h[1]?1:0;
      return _mW_?resize$0(key_index,h):_mW_}
    function remove(h,key)
     {var i=key_index(h,key),c$0=caml_check_bound(h[2],i)[1 + i],prec=0,c=c$0;
      for(;;)
       {if(c)
         {var k=c[1],next=c[3];
          if(0 === caml_compare(k,key))
           {h[1] = h[1] - 1 | 0;
            return prec
                    ?(prec[3] = next,0)
                    :(caml_check_bound(h[2],i)[1 + i] = next,0)}
          var prec=c,c=next;
          continue}
        return 0}}
    function find$0(h,key)
     {var _mV_=key_index(h,key),match=caml_check_bound(h[2],_mV_)[1 + _mV_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return d1;
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return d2;
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return d3;
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return data;
                var param=next;
                continue}
              throw Not_found}}
          throw Not_found}
        throw Not_found}
      throw Not_found}
    function find_opt$1(h,key)
     {var _mU_=key_index(h,key),match=caml_check_bound(h[2],_mU_)[1 + _mU_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return [0,d1];
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return [0,d2];
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return [0,d3];
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return [0,data];
                var param=next;
                continue}
              return 0}}
          return 0}
        return 0}
      return 0}
    function find_all$0(h,key)
     {function find_in_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var k=param$0[1],data=param$0[2],next=param$0[3];
            if(0 === caml_compare(k,key))return [0,data,find_in_bucket(next)];
            var param$0=next;
            continue}
          return 0}}
      var _mT_=key_index(h,key);
      return find_in_bucket(caml_check_bound(h[2],_mT_)[1 + _mT_])}
    function replace(h,key,data)
     {var
       i=key_index(h,key),
       param$0=caml_check_bound(h[2],i)[1 + i],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3];
          if(0 !== caml_compare(k,key)){var param=next;continue}
          param[1] = key;
          param[2] = data;
          var _mQ_=0}
        else
         var _mQ_=1;
        if(_mQ_)
         {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
          h[1] = h[1] + 1 | 0;
          var _mR_=h[2].length - 1 << 1 < h[1]?1:0;
          if(_mR_)return resize$0(key_index,h);
          var _mS_=_mR_}
        else
         var _mS_=_mQ_;
        return _mS_}}
    function mem$2(h,key)
     {var
       _mP_=key_index(h,key),
       param$0=caml_check_bound(h[2],_mP_)[1 + _mP_],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3],_mO_=0 === caml_compare(k,key)?1:0;
          if(_mO_)return _mO_;
          var param=next;
          continue}
        return 0}}
    function add_seq$2(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return add$0(tbl,k,v)},
               i)}
    function replace_seq(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return replace(tbl,k,v)},
               i)}
    function of_seq$7(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
    function rebuild(opt,h)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var s=power_2_above(16,h[2].length - 1);
      if(random)
       var
        _mH_=caml_obj_tag(prng),
        _mI_=250 === _mH_?prng[1]:246 === _mH_?force_lazy_block(prng):prng,
        seed=caml_call1(_cb_[4],_mI_);
      else
       var seed=4 <= h.length - 1?h[3]:0;
      var
       _mJ_=4 <= h.length - 1?h[4]:s,
       h$0=[0,h[1],caml_make_vect(s,0),seed,_mJ_],
       _mK_=h$0[2],
       _mL_=h[2],
       _mM_=0;
      insert_all_buckets
       (function(_mN_){return key_index(h$0,_mN_)},_mM_,_mL_,_mK_);
      return h$0}
    var
     Stdlib_Hashtbl=
      [0,
       create$3,
       clear$2,
       reset$0,
       copy$6,
       add$0,
       find$0,
       find_opt$1,
       find_all$0,
       mem$2,
       remove,
       replace,
       iter$10,
       filter_map_inplace,
       fold$4,
       length$4,
       randomize,
       is_randomized,
       rebuild,
       stats,
       to_seq$9,
       to_seq_keys,
       to_seq_values,
       add_seq$2,
       replace_seq,
       of_seq$7,
       Make$0,
       MakeSeeded,
       hash$1,
       seeded_hash,
       hash_param,
       caml_hash];
    caml_register_global(800,Stdlib_Hashtbl,"Stdlib__Hashtbl");
    function weak_create(l)
     {var _mF_=0 <= l?1:0,_mG_=_mF_?l <= _t_[15]?1:0:_mF_;
      if(1 - _mG_)invalid_arg(cst_Weak_create);
      return runtime.caml_weak_create(l)}
    function length$5(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset$0(e,o,msg)
     {var _mC_=0 <= o?1:0,_mD_=_mC_?o < length$5(e)?1:0:_mC_,_mE_=1 - _mD_;
      return _mE_?invalid_arg(msg):_mE_}
    function set$0(e,o,x)
     {raise_if_invalid_offset$0(e,o,cst_Weak_set);
      if(x){var x$0=x[1];return caml_ephe_set_key(e,o,x$0)}
      return caml_ephe_unset_key(e,o)}
    function get$1(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get);
      return runtime.caml_weak_get(e,o)}
    function get_copy(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get_copy);
      return runtime.caml_weak_get_copy(e,o)}
    function check$0(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_check);
      return runtime.caml_weak_check(e,o)}
    function blit$4(e1,o1,e2,o2,l)
     {if
       (0
        <=
        l
        &&
        0
        <=
        o1
        &&
        !
        ((length$5(e1) - l | 0) < o1)
        &&
        0
        <=
        o2
        &&
        !
        ((length$5(e2) - l | 0) < o2))
       {var
         _mA_=0 !== l?1:0,
         _mB_=_mA_?runtime.caml_weak_blit(e1,o1,e2,o2,l):_mA_;
        return _mB_}
      return invalid_arg(cst_Weak_blit)}
    function fill$2(ar,ofs,len,x)
     {if(0 <= ofs && 0 <= len && ! ((length$5(ar) - len | 0) < ofs))
       {var _my_=(ofs + len | 0) - 1 | 0;
        if(! (_my_ < ofs))
         {var i=ofs;
          for(;;)
           {set$0(ar,i,x);
            var _mz_=i + 1 | 0;
            if(_my_ !== i){var i=_mz_;continue}
            break}}
        return 0}
      throw [0,Invalid_argument,cst_Weak_fill]}
    function Make$1(H)
     {var emptybucket=weak_create(0);
      function get_index(t,h){return caml_mod(h & 2147483647,t[1].length - 1)}
      var limit=7;
      function create(sz)
       {var
         sz$0=7 <= sz?sz:7,
         sz$1=max_array_length < sz$0?max_array_length:sz$0;
        return [0,
                caml_make_vect(sz$1,emptybucket),
                caml_make_vect(sz$1,[0]),
                limit,
                0,
                0]}
      function clear(t)
       {var _mw_=t[1].length - 1 - 1 | 0,_mv_=0;
        if(! (_mw_ < 0))
         {var i=_mv_;
          for(;;)
           {caml_check_bound(t[1],i)[1 + i] = emptybucket;
            caml_check_bound(t[2],i)[1 + i] = [0];
            var _mx_=i + 1 | 0;
            if(_mw_ !== i){var i=_mx_;continue}
            break}}
        t[3] = limit;
        t[4] = 0;
        return 0}
      function fold(f,t,init)
       {var _mu_=t[1],i=0;
        return fold_right$2
                (function(b,accu$1)
                  {var i$0=i,accu=accu$1;
                   for(;;)
                    {if(length$5(b) <= i$0)return accu;
                     var match=get$1(b,i$0);
                     if(match)
                      {var
                        v=match[1],
                        accu$0=caml_call2(f,v,accu),
                        i$1=i$0 + 1 | 0,
                        i$0=i$1,
                        accu=accu$0;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _mu_,
                 init)}
      function iter(f,t)
       {var _mt_=t[1],i=0;
        return iter$5
                (function(b)
                  {var i$0=i;
                   for(;;)
                    {if(length$5(b) <= i$0)return 0;
                     var match=get$1(b,i$0);
                     if(match)
                      {var v=match[1];
                       caml_call1(f,v);
                       var i$1=i$0 + 1 | 0,i$0=i$1;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _mt_)}
      function count_bucket(i,b,accu)
       {var i$0=i,accu$0=accu;
        for(;;)
         {if(length$5(b) <= i$0)return accu$0;
          var
           _ms_=check$0(b,i$0)?1:0,
           accu$1=accu$0 + _ms_ | 0,
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           accu$0=accu$1;
          continue}}
      function count(t)
       {var _mn_=0,_mo_=t[1],_mp_=0;
        return fold_right$2
                (function(_mq_,_mr_){return count_bucket(_mp_,_mq_,_mr_)},
                 _mo_,
                 _mn_)}
      function add_aux(t,setter,d,h,index)
       {var
         bucket$0=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket$0),
         i$3=0;
        for(;;)
         {if(sz <= i$3)
           {var
             newsz=
              min$1(((3 * sz | 0) / 2 | 0) + 3 | 0,max_array_length - 2 | 0);
            if(newsz <= sz)failwith(cst_Weak_Make_hash_bucket_cann);
            var
             newbucket$0=weak_create(newsz),
             newhashes=caml_make_vect(newsz,0);
            blit$4(bucket$0,0,newbucket$0,0,sz);
            blit$1(hashes,0,newhashes,0,sz);
            caml_call3(setter,newbucket$0,sz,d);
            caml_check_bound(newhashes,sz)[1 + sz] = h;
            caml_check_bound(t[1],index)[1 + index] = newbucket$0;
            caml_check_bound(t[2],index)[1 + index] = newhashes;
            var _mj_=sz <= t[3]?1:0,_mk_=_mj_?t[3] < newsz?1:0:_mj_;
            if(_mk_)
             {t[4] = t[4] + 1 | 0;
              var i$4=0;
              for(;;)
               {var
                 _l$_=t[5],
                 bucket=caml_check_bound(t[1],_l$_)[1 + _l$_],
                 _ma_=t[5],
                 hbucket=caml_check_bound(t[2],_ma_)[1 + _ma_],
                 n=length$5(bucket),
                 prev_len=(((n - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
                 live=count_bucket(0,bucket,0);
                if(live <= prev_len)
                 {var j$2=length$5(bucket) - 1 | 0,i$0=0,j=j$2;
                  for(;;)
                   {if(prev_len <= j)
                     {if(check$0(bucket,i$0))
                       {var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      if(check$0(bucket,j))
                       {blit$4(bucket,j,bucket,i$0,1);
                        var _mb_=caml_check_bound(hbucket,j)[1 + j];
                        caml_check_bound(hbucket,i$0)[1 + i$0] = _mb_;
                        var j$0=j - 1 | 0,i$2=i$0 + 1 | 0,i$0=i$2,j=j$0;
                        continue}
                      var j$1=j - 1 | 0,j=j$1;
                      continue}
                    if(0 === prev_len)
                     {var _mc_=t[5];
                      caml_check_bound(t[1],_mc_)[1 + _mc_] = emptybucket;
                      var _md_=t[5];
                      caml_check_bound(t[2],_md_)[1 + _md_] = [0]}
                    else
                     {var newbucket=weak_create(prev_len);
                      blit$4(bucket,0,newbucket,0,prev_len);
                      var _mg_=t[5];
                      caml_check_bound(t[1],_mg_)[1 + _mg_] = newbucket;
                      var _mh_=sub$1(hbucket,0,prev_len),_mi_=t[5];
                      caml_check_bound(t[2],_mi_)[1 + _mi_] = _mh_}
                    var _me_=t[3] < n?1:0,_mf_=_me_?prev_len <= t[3]?1:0:_me_;
                    if(_mf_)t[4] = t[4] - 1 | 0;
                    break}}
                t[5] = caml_mod(t[5] + 1 | 0,t[1].length - 1);
                var _mm_=i$4 + 1 | 0;
                if(2 !== i$4){var i$4=_mm_;continue}
                break}}
            var _ml_=((t[1].length - 1) / 2 | 0) < t[4]?1:0;
            if(_ml_)
             {var
               n$0=t[1].length - 1,
               newlen=min$1(((3 * n$0 | 0) / 2 | 0) + 3 | 0,max_array_length);
              if(n$0 < newlen)
               {var newt=create(newlen),_l__=t[1],i=0;
                iteri$2
                 (function(j,ob)
                   {var i$0=i;
                    for(;;)
                     {if(length$5(ob) <= i$0)return 0;
                      var match=check$0(ob,i$0);
                      if(match)
                       {var
                         oh=caml_check_bound(t[2],j)[1 + j],
                         setter$0=
                          function(i)
                           {function setter(nb,ni,param){return blit$4(ob,i,nb,ni,1)}
                            return setter},
                         setter=setter$0(i$0),
                         h=caml_check_bound(oh,i$0)[1 + i$0];
                        add_aux(newt,setter,0,h,get_index(newt,h));
                        var i$1=i$0 + 1 | 0,i$0=i$1;
                        continue}
                      var i$2=i$0 + 1 | 0,i$0=i$2;
                      continue}},
                  _l__);
                t[1] = newt[1];
                t[2] = newt[2];
                t[3] = newt[3];
                t[4] = newt[4];
                t[5] = caml_mod(t[5],newt[1].length - 1);
                return 0}
              t[3] = max_int;
              t[4] = 0;
              return 0}
            return _ml_}
          if(check$0(bucket$0,i$3)){var i$5=i$3 + 1 | 0,i$3=i$5;continue}
          caml_call3(setter,bucket$0,i$3,d);
          caml_check_bound(hashes,i$3)[1 + i$3] = h;
          return 0}}
      function add(t,d)
       {var h=caml_call1(H[2],d);
        return add_aux(t,set$0,[0,d],h,get_index(t,h))}
      function find_or(t,d,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return caml_call2(ifnotfound,h,index);
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$1(bucket,i);
                if(match$0){var v$0=match$0[1];return v$0}
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function merge(t,d)
       {return find_or
                (t,
                 d,
                 function(h,index){add_aux(t,set$0,[0,d],h,index);return d})}
      function find(t,d)
       {return find_or(t,d,function(h,index){throw Not_found})}
      function find_opt(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return 0;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var v$0=get$1(bucket,i);
                if(v$0)return v$0;
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function find_shadow(t,d,iffound,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return ifnotfound;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))return caml_call2(iffound,bucket,i)}
            var i$0=i + 1 | 0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}}
      function remove(t,d)
       {var _l9_=0;
        return find_shadow(t,d,function(w,i){return set$0(w,i,0)},_l9_)}
      function mem(t,d)
       {var _l8_=0;return find_shadow(t,d,function(w,i){return 1},_l8_)}
      function find_all(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0,
         accu=0;
        for(;;)
         {if(sz <= i)return accu;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$1(bucket,i);
                if(match$0)
                 {var
                   v$0=match$0[1],
                   accu$0=[0,v$0,accu],
                   i$0=i + 1 | 0,
                   i=i$0,
                   accu=accu$0;
                  continue}
                var i$1=i + 1 | 0,i=i$1;
                continue}}
            var i$2=i + 1 | 0,i=i$2;
            continue}
          var i$3=i + 1 | 0,i=i$3;
          continue}}
      function stats(t)
       {var len=t[1].length - 1,lens=map$6(length$5,t[1]);
        sort(caml_int_compare,lens);
        var
         _l0_=0,
         totlen=
          fold_left$3(function(_l7_,_l6_){return _l7_ + _l6_ | 0},_l0_,lens),
         _l1_=len - 1 | 0,
         _l3_=len / 2 | 0,
         _l2_=caml_check_bound(lens,_l1_)[1 + _l1_],
         _l4_=caml_check_bound(lens,_l3_)[1 + _l3_],
         _l5_=caml_check_bound(lens,0)[1];
        return [0,len,count(t),totlen,_l5_,_l4_,_l2_]}
      return [0,
              create,
              clear,
              merge,
              add,
              remove,
              find,
              find_opt,
              find_all,
              mem,
              iter,
              fold,
              count,
              stats]}
    var
     Stdlib_Weak=
      [0,
       weak_create,
       length$5,
       set$0,
       get$1,
       get_copy,
       check$0,
       fill$2,
       blit$4,
       Make$1];
    caml_register_global(801,Stdlib_Weak,"Stdlib__Weak");
    function id$0(x){return x}
    var
     String_tag=[248,cst_Stdlib_Format_String_tag,caml_fresh_oo_id(0)],
     size=0,
     unknown=-1;
    function pp_enqueue(state,token)
     {state[13] = state[13] + token[3] | 0;return add(token,state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function format_pp_text(state,size,text)
     {state[9] = state[9] - size | 0;
      pp_output_string(state,text);
      state[11] = 0;
      return 0}
    function format_string(state,s)
     {var _lZ_=caml_string_notequal(s,cst$67);
      return _lZ_?format_pp_text(state,caml_ml_string_length(s),s):_lZ_}
    function break_new_line(state,param,width)
     {var after=param[3],offset=param[2],before=param[1];
      format_string(state,before);
      pp_output_newline(state);
      state[11] = 1;
      var
       indent=(state[6] - width | 0) + offset | 0,
       real_indent=min$1(state[8],indent);
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      caml_call1(state[21],state[10]);
      return format_string(state,after)}
    function break_line(state,width){return break_new_line(state,_ce_,width)}
    function break_same_line(state,param)
     {var after=param[3],width=param[2],before=param[1];
      format_string(state,before);
      state[9] = state[9] - width | 0;
      caml_call1(state[20],width);
      return format_string(state,after)}
    function format_pp_token(state,size$0,param)
     {if(typeof param === "number")
       switch(param)
        {case 0:
          var match$3=top_opt(state[3]);
          if(match$3)
           {var
             match$4=match$3[1],
             tabs=match$4[1],
             add_tab=
              function(n,ls)
               {if(ls)
                 {var l=ls[2],x=ls[1];
                  return caml_lessthan(n,x)?[0,n,ls]:[0,x,add_tab(n,l)]}
                return [0,n,0]};
            tabs[1] = add_tab(state[6] - state[9] | 0,tabs[1]);
            return 0}
          return 0;
         case 1:pop_opt(state[2]);return 0;
         case 2:pop_opt(state[3]);return 0;
         case 3:
          var match$5=top_opt(state[2]);
          if(match$5)
           {var match$6=match$5[1],width$0=match$6[2];
            return break_line(state,width$0)}
          return pp_output_newline(state);
         case 4:
          var _lW_=state[10] !== (state[6] - state[9] | 0)?1:0;
          if(_lW_)
           {var match$1=take_opt(state[28]);
            if(match$1)
             {var match$2=match$1[1],size=match$2[1],length=match$2[3];
              state[12] = state[12] - length | 0;
              state[9] = state[9] + size | 0;
              return 0}
            return 0}
          return _lW_;
         default:
          var match$7=pop_opt(state[5]);
          if(match$7)
           {var tag_name=match$7[1],marker=caml_call1(state[25],tag_name);
            return pp_output_string(state,marker)}
          return 0}
      else
       switch(param[0])
        {case 0:var s=param[1];return format_pp_text(state,size$0,s);
         case 1:
          var
           breaks=param[2],
           fits=param[1],
           off=breaks[2],
           before=breaks[1],
           match$8=top_opt(state[2]);
          if(match$8)
           {var match$9=match$8[1],width$1=match$9[2],box_type$0=match$9[1];
            switch(box_type$0)
             {case 0:return break_same_line(state,fits);
              case 1:return break_new_line(state,breaks,width$1);
              case 2:return break_new_line(state,breaks,width$1);
              case 3:
               return state[9] < (size$0 + caml_ml_string_length(before) | 0)
                       ?break_new_line(state,breaks,width$1)
                       :break_same_line(state,fits);
              case 4:
               return state[11]
                       ?break_same_line(state,fits)
                       :state[9] < (size$0 + caml_ml_string_length(before) | 0)
                         ?break_new_line(state,breaks,width$1)
                         :((state[6] - width$1 | 0) + off | 0) < state[10]
                           ?break_new_line(state,breaks,width$1)
                           :break_same_line(state,fits);
              default:return break_same_line(state,fits)}}
          return 0;
         case 2:
          var
           off$0=param[2],
           n=param[1],
           insertion_point=state[6] - state[9] | 0,
           match$10=top_opt(state[3]);
          if(match$10)
           {var match$11=match$10[1],tabs$0=match$11[1],_lX_=tabs$0[1];
            if(_lX_)
             {var first=_lX_[1],param$0=tabs$0[1];
              for(;;)
               {if(param$0)
                 {var tail=param$0[2],head=param$0[1];
                  if(! (insertion_point <= head)){var param$0=tail;continue}
                  var _lY_=head}
                else
                 var _lY_=first;
                var tab=_lY_;
                break}}
            else
             var tab=insertion_point;
            var offset=tab - insertion_point | 0;
            return 0 <= offset
                    ?break_same_line(state,[0,cst$69,offset + n | 0,cst$68])
                    :break_new_line
                      (state,[0,cst$71,tab + off$0 | 0,cst$70],state[6])}
          return 0;
         case 3:
          var
           ty=param[2],
           off$1=param[1],
           insertion_point$0=state[6] - state[9] | 0;
          if(state[8] < insertion_point$0)
           {var match=top_opt(state[2]);
            if(match)
             {var match$0=match[1],width=match$0[2],box_type=match$0[1];
              if(state[9] < width && ! (3 < box_type - 1 >>> 0))
               break_line(state,width)}
            else
             pp_output_newline(state)}
          var
           width$2=state[9] - off$1 | 0,
           box_type$1=1 === ty?1:state[9] < size$0?ty:5;
          return push([0,box_type$1,width$2],state[2]);
         case 4:var tbox=param[1];return push(tbox,state[3]);
         default:
          var tag_name$0=param[1],marker$0=caml_call1(state[24],tag_name$0);
          pp_output_string(state,marker$0);
          return push(tag_name$0,state[5])}}
    function advance_left(state)
     {for(;;)
       {var match=peek_opt(state[28]);
        if(match)
         {var
           match$0=match[1],
           size=match$0[1],
           length=match$0[3],
           token=match$0[2],
           pending_count=state[13] - state[12] | 0,
           _lU_=0 <= size?1:0,
           _lV_=_lU_ || (state[9] <= pending_count?1:0);
          if(_lV_)
           {take(state[28]);
            var size$0=0 <= size?size:pp_infinity;
            format_pp_token(state,size$0,token);
            state[12] = length + state[12] | 0;
            continue}
          return _lV_}
        return 0}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],size])}
    function initialize_scan_stack(stack)
     {clear(stack);
      var queue_elem=[0,unknown,_cf_,0];
      return push([0,-1,queue_elem],stack)}
    function set_size(state,ty)
     {var match=top_opt(state[1]);
      if(match)
       {var
         match$0=match[1],
         queue_elem=match$0[2],
         left_total=match$0[1],
         _lP_=queue_elem[1];
        if(left_total < state[12])return initialize_scan_stack(state[1]);
        var _lQ_=queue_elem[2];
        if(typeof _lQ_ !== "number")
         switch(_lQ_[0])
          {case 3:
            var
             _lS_=1 - ty,
             _lT_=
              _lS_
               ?(queue_elem[1] = state[13] + _lP_ | 0,pop_opt(state[1]),0)
               :_lS_;
            return _lT_;
           case 1:
           case 2:
            var
             _lR_=
              ty?(queue_elem[1] = state[13] + _lP_ | 0,pop_opt(state[1]),0):ty;
            return _lR_
           }
        return 0}
      return 0}
    function scan_push(state,b,token)
     {pp_enqueue(state,token);
      if(b)set_size(state,1);
      var elem=[0,state[13],token];
      return push(elem,state[1])}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var size=- state[13] | 0,elem=[0,size,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _lN_=state[14] === state[15]?1:0;
      if(_lN_)
       {var _lO_=state[16];
        return enqueue_string_as(state,caml_ml_string_length(_lO_),_lO_)}
      return _lN_}
    function pp_close_box(state,param)
     {var _lL_=1 < state[14]?1:0;
      if(_lL_)
       {if(state[14] < state[15])
         {pp_enqueue(state,[0,size,1,0]);set_size(state,1);set_size(state,0)}
        state[14] = state[14] - 1 | 0;
        var _lM_=0}
      else
       var _lM_=_lL_;
      return _lM_}
    function pp_open_stag(state,tag_name)
     {if(state[22]){push(tag_name,state[4]);caml_call1(state[26],tag_name)}
      var _lK_=state[23];
      if(_lK_)
       {var token=[5,tag_name];return pp_enqueue(state,[0,size,token,0])}
      return _lK_}
    function pp_close_stag(state,param)
     {if(state[23])pp_enqueue(state,[0,size,5,0]);
      var _lI_=state[22];
      if(_lI_)
       {var match=pop_opt(state[4]);
        if(match){var tag_name=match[1];return caml_call1(state[27],tag_name)}
        var _lJ_=0}
      else
       var _lJ_=_lI_;
      return _lJ_}
    function pp_open_tag(state,s){return pp_open_stag(state,[0,String_tag,s])}
    function pp_close_tag(state,param){return pp_close_stag(state,0)}
    function pp_set_print_tags(state,b){state[22] = b;return 0}
    function pp_set_mark_tags(state,b){state[23] = b;return 0}
    function pp_get_print_tags(state,param){return state[22]}
    function pp_get_mark_tags(state,param){return state[23]}
    function pp_set_tags(state,b)
     {pp_set_print_tags(state,b);return pp_set_mark_tags(state,b)}
    function pp_get_formatter_stag_function(state,param)
     {return [0,state[24],state[25],state[26],state[27]]}
    function pp_set_formatter_stag_function(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      state[24] = mot;
      state[25] = mct;
      state[26] = pot;
      state[27] = pct;
      return 0}
    function pp_rinit(state)
     {state[12] = 1;
      state[13] = 1;
      clear$0(state[28]);
      initialize_scan_stack(state[1]);
      clear(state[2]);
      clear(state[3]);
      clear(state[4]);
      clear(state[5]);
      state[10] = 0;
      state[14] = 0;
      state[9] = state[6];
      return pp_open_box_gen(state,0,3)}
    function pp_flush_queue(state,b)
     {var _lH_=state[4];
      iter$7(function(param){return pp_close_tag(state,0)},_lH_);
      for(;;)
       {if(1 < state[14]){pp_close_box(state,0);continue}
        state[13] = pp_infinity;
        advance_left(state);
        if(b)pp_output_newline(state);
        return pp_rinit(state)}}
    function pp_print_as_size(state,size,s)
     {var _lG_=state[14] < state[15]?1:0;
      return _lG_?enqueue_string_as(state,size,s):_lG_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,isize,s)}
    function pp_print_string(state,s)
     {return pp_print_as(state,caml_ml_string_length(s),s)}
    function pp_print_bytes(state,s)
     {return pp_print_as(state,caml_ml_bytes_length(s),of_bytes(s))}
    function pp_print_int(state,i)
     {return pp_print_string(state,caml_string_of_jsbytes("" + i))}
    function pp_print_float(state,f)
     {return pp_print_string(state,to_string(f))}
    function pp_print_bool(state,b)
     {return pp_print_string(state,string_of_bool(b))}
    function pp_print_char(state,c){return pp_print_as(state,1,make$1(1,c))}
    function pp_open_hbox(state,param){return pp_open_box_gen(state,0,0)}
    function pp_open_vbox(state,indent)
     {return pp_open_box_gen(state,indent,1)}
    function pp_open_hvbox(state,indent)
     {return pp_open_box_gen(state,indent,2)}
    function pp_open_hovbox(state,indent)
     {return pp_open_box_gen(state,indent,3)}
    function pp_open_box(state,indent){return pp_open_box_gen(state,indent,4)}
    function pp_print_newline(state,param)
     {pp_flush_queue(state,1);return caml_call1(state[18],0)}
    function pp_print_flush(state,param)
     {pp_flush_queue(state,0);return caml_call1(state[18],0)}
    function pp_force_newline(state,param)
     {var _lF_=state[14] < state[15]?1:0;
      return _lF_?enqueue_advance(state,[0,size,3,0]):_lF_}
    function pp_print_if_newline(state,param)
     {var _lE_=state[14] < state[15]?1:0;
      return _lE_?enqueue_advance(state,[0,size,4,0]):_lE_}
    function pp_print_custom_break(state,fits,breaks)
     {var
       after=fits[3],
       width=fits[2],
       before=fits[1],
       _lD_=state[14] < state[15]?1:0;
      if(_lD_)
       {var
         size=- state[13] | 0,
         token=[1,fits,breaks],
         length=
          (caml_ml_string_length(before) + width | 0)
          +
          caml_ml_string_length(after)
          |
          0,
         elem=[0,size,token,length];
        return scan_push(state,1,elem)}
      return _lD_}
    function pp_print_break(state,width,offset)
     {return pp_print_custom_break
              (state,[0,cst$75,width,cst$74],[0,cst$73,offset,cst$72])}
    function pp_print_space(state,param){return pp_print_break(state,1,0)}
    function pp_print_cut(state,param){return pp_print_break(state,0,0)}
    function pp_open_tbox(state,param)
     {state[14] = state[14] + 1 | 0;
      var _lC_=state[14] < state[15]?1:0;
      if(_lC_)
       {var elem=[0,size,[4,[0,[0,0]]],0];return enqueue_advance(state,elem)}
      return _lC_}
    function pp_close_tbox(state,param)
     {var _lz_=1 < state[14]?1:0;
      if(_lz_)
       {var _lA_=state[14] < state[15]?1:0;
        if(_lA_)
         {var elem=[0,size,2,0];
          enqueue_advance(state,elem);
          state[14] = state[14] - 1 | 0;
          var _lB_=0}
        else
         var _lB_=_lA_}
      else
       var _lB_=_lz_;
      return _lB_}
    function pp_print_tbreak(state,width,offset)
     {var _ly_=state[14] < state[15]?1:0;
      if(_ly_)
       {var size=- state[13] | 0,elem=[0,size,[2,width,offset],width];
        return scan_push(state,1,elem)}
      return _ly_}
    function pp_print_tab(state,param){return pp_print_tbreak(state,0,0)}
    function pp_set_tab(state,param)
     {var _lx_=state[14] < state[15]?1:0;
      if(_lx_){var elem=[0,size,0,0];return enqueue_advance(state,elem)}
      return _lx_}
    function pp_set_max_boxes(state,n)
     {var _lv_=1 < n?1:0,_lw_=_lv_?(state[15] = n,0):_lv_;return _lw_}
    function pp_get_max_boxes(state,param){return state[15]}
    function pp_over_max_boxes(state,param)
     {return state[14] === state[15]?1:0}
    function pp_set_ellipsis_text(state,s){state[16] = s;return 0}
    function pp_get_ellipsis_text(state,param){return state[16]}
    function pp_limit(n){return n < 1000000010?n:1000000009}
    function pp_set_max_indent(state,n$0)
     {var _lu_=1 < n$0?1:0;
      if(_lu_)
       {var n$1=state[6] - n$0 | 0,_lt_=1 <= n$1?1:0;
        if(_lt_)
         {var n=pp_limit(n$1);
          state[7] = n;
          state[8] = state[6] - state[7] | 0;
          return pp_rinit(state)}
        return _lt_}
      return _lu_}
    function pp_get_max_indent(state,param){return state[8]}
    function pp_set_margin(state,n)
     {var _ls_=1 <= n?1:0;
      if(_ls_)
       {var n$0=pp_limit(n);
        state[6] = n$0;
        var
         new_max_indent=
          state[8] <= state[6]
           ?state[8]
           :max$1(max$1(state[6] - state[7] | 0,state[6] / 2 | 0),1);
        return pp_set_max_indent(state,new_max_indent)}
      return _ls_}
    function validate_geometry(param)
     {var margin=param[2],max_indent=param[1];
      return 2 <= max_indent?margin <= max_indent?_cg_:_ch_:_ci_}
    function check_geometry(geometry)
     {var match=validate_geometry(geometry);return 0 === match[0]?1:0}
    function pp_get_margin(state,param){return state[6]}
    function pp_set_full_geometry(state,param)
     {var margin=param[2],max_indent=param[1];
      pp_set_margin(state,margin);
      pp_set_max_indent(state,max_indent);
      return 0}
    function pp_set_geometry(state,max_indent,margin)
     {var geometry=[0,max_indent,margin],match=validate_geometry(geometry);
      if(0 === match[0])return pp_set_full_geometry(state,geometry);
      var msg=match[1];
      throw [0,Invalid_argument,cat(cst_Format_pp_set_geometry,msg)]}
    function pp_safe_set_geometry(state,max_indent,margin)
     {var geometry=[0,max_indent,margin],match=validate_geometry(geometry);
      return 0 === match[0]?pp_set_full_geometry(state,geometry):0}
    function pp_get_geometry(state,param){return [0,state[8],state[6]]}
    function pp_update_geometry(state,update)
     {var geometry=pp_get_geometry(state,0);
      return pp_set_full_geometry(state,caml_call1(update,geometry))}
    function pp_set_formatter_out_functions(state,param)
     {var j=param[5],i=param[4],h=param[3],g=param[2],f=param[1];
      state[17] = f;
      state[18] = g;
      state[19] = h;
      state[20] = i;
      state[21] = j;
      return 0}
    function pp_get_formatter_out_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20],state[21]]}
    function pp_set_formatter_output_functi(state,f,g)
     {state[17] = f;state[18] = g;return 0}
    function pp_get_formatter_output_functi(state,param)
     {return [0,state[17],state[18]]}
    function display_newline(state,param)
     {return caml_call3(state[17],cst$76,0,1)}
    var blank_line=make$1(80,32);
    function display_indent(state,n)
     {var n$0=n;
      for(;;)
       {var _lr_=0 < n$0?1:0;
        if(_lr_)
         {if(80 < n$0)
           {caml_call3(state[17],blank_line,0,80);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _lr_}}
    function pp_set_formatter_out_channel(state,oc)
     {state[17]
      =
      function(_lo_,_lp_,_lq_){return output_substring(oc,_lo_,_lp_,_lq_)};
      state[18] = function(param){return caml_ml_flush(oc)};
      state[19] = function(_ln_){return display_newline(state,_ln_)};
      state[20] = function(_lm_){return display_indent(state,_lm_)};
      state[21] = function(_ll_){return display_indent(state,_ll_)};
      return 0}
    function default_pp_mark_open_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return cat(cst$78,cat(s,cst$77))}
      return cst$79}
    function default_pp_mark_close_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return cat(cst$81,cat(s,cst$80))}
      return cst$82}
    function default_pp_print_open_tag(_lk_){return 0}
    function default_pp_print_close_tag(_lj_){return 0}
    function pp_make_formatter(f,g,h,i,j)
     {var pp_queue=create$1(0),sys_tok=[0,unknown,_cj_,0];
      add(sys_tok,pp_queue);
      var scan_stack=create$0(0);
      initialize_scan_stack(scan_stack);
      push([0,1,sys_tok],scan_stack);
      var _lg_=create$0(0),_lh_=create$0(0),_li_=create$0(0);
      return [0,
              scan_stack,
              create$0(0),
              _li_,
              _lh_,
              _lg_,
              78,
              10,
              68,
              78,
              0,
              1,
              1,
              1,
              1,
              max_int,
              cst$83,
              f,
              g,
              h,
              i,
              j,
              0,
              0,
              default_pp_mark_open_tag,
              default_pp_mark_close_tag,
              default_pp_print_open_tag,
              default_pp_print_close_tag,
              pp_queue]}
    function formatter_of_out_functions(out_funs)
     {return pp_make_formatter
              (out_funs[1],out_funs[2],out_funs[3],out_funs[4],out_funs[5])}
    function make_formatter(output,flush)
     {function _k__(_lf_){return 0}
      function _k$_(_le_){return 0}
      var
       ppf=
        pp_make_formatter(output,flush,function(_ld_){return 0},_k$_,_k__);
      ppf[19] = function(_lc_){return display_newline(ppf,_lc_)};
      ppf[20] = function(_lb_){return display_indent(ppf,_lb_)};
      ppf[21] = function(_la_){return display_indent(ppf,_la_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _k6_(param){return caml_ml_flush(oc)}
      return make_formatter
              (function(_k7_,_k8_,_k9_)
                {return output_substring(oc,_k7_,_k8_,_k9_)},
               _k6_)}
    function formatter_of_buffer(b)
     {function _k1_(_k5_){return 0}
      return make_formatter
              (function(_k2_,_k3_,_k4_)
                {return add_substring(b,_k2_,_k3_,_k4_)},
               _k1_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create$2(pp_buffer_size)}
    var
     stdbuf=pp_make_buffer(0),
     std_formatter=formatter_of_out_channel(stdout),
     err_formatter=formatter_of_out_channel(stderr),
     str_formatter=formatter_of_buffer(stdbuf);
    function flush_buffer_formatter(buf,ppf)
     {pp_flush_queue(ppf,0);var s=contents(buf);reset(buf);return s}
    function flush_str_formatter(param)
     {return flush_buffer_formatter(stdbuf,str_formatter)}
    function make_symbolic_output_buffer(param){return [0,0]}
    function clear_symbolic_output_buffer(sob){sob[1] = 0;return 0}
    function get_symbolic_output_buffer(sob){return rev(sob[1])}
    function flush_symbolic_output_buffer(sob)
     {var items=get_symbolic_output_buffer(sob);
      clear_symbolic_output_buffer(sob);
      return items}
    function add_symbolic_output_item(sob,item)
     {sob[1] = [0,item,sob[1]];return 0}
    function formatter_of_symbolic_output_b(sob)
     {function f(s,i,n){return add_symbolic_output_item(sob,[0,sub$0(s,i,n)])}
      function g(_k0_){return add_symbolic_output_item(sob,0)}
      function h(_kZ_){return add_symbolic_output_item(sob,1)}
      function i(n){return add_symbolic_output_item(sob,[1,n])}
      function j(n){return add_symbolic_output_item(sob,[2,n])}
      return pp_make_formatter(f,g,h,i,j)}
    function open_hbox(_kY_){return pp_open_hbox(std_formatter,_kY_)}
    function open_vbox(_kX_){return pp_open_vbox(std_formatter,_kX_)}
    function open_hvbox(_kW_){return pp_open_hvbox(std_formatter,_kW_)}
    function open_hovbox(_kV_){return pp_open_hovbox(std_formatter,_kV_)}
    function open_box(_kU_){return pp_open_box(std_formatter,_kU_)}
    function close_box(_kT_){return pp_close_box(std_formatter,_kT_)}
    function open_tag(_kS_){return pp_open_tag(std_formatter,_kS_)}
    function close_tag(_kR_){return pp_close_tag(std_formatter,_kR_)}
    function open_stag(_kQ_){return pp_open_stag(std_formatter,_kQ_)}
    function close_stag(_kP_){return pp_close_stag(std_formatter,_kP_)}
    function print_as(_kN_,_kO_){return pp_print_as(std_formatter,_kN_,_kO_)}
    function print_string$0(_kM_){return pp_print_string(std_formatter,_kM_)}
    function print_bytes$0(_kL_){return pp_print_bytes(std_formatter,_kL_)}
    function print_int$0(_kK_){return pp_print_int(std_formatter,_kK_)}
    function print_float$0(_kJ_){return pp_print_float(std_formatter,_kJ_)}
    function print_char$0(_kI_){return pp_print_char(std_formatter,_kI_)}
    function print_bool(_kH_){return pp_print_bool(std_formatter,_kH_)}
    function print_break(_kF_,_kG_)
     {return pp_print_break(std_formatter,_kF_,_kG_)}
    function print_cut(_kE_){return pp_print_cut(std_formatter,_kE_)}
    function print_space(_kD_){return pp_print_space(std_formatter,_kD_)}
    function force_newline(_kC_){return pp_force_newline(std_formatter,_kC_)}
    function print_flush(_kB_){return pp_print_flush(std_formatter,_kB_)}
    function print_newline$0(_kA_)
     {return pp_print_newline(std_formatter,_kA_)}
    function print_if_newline(_kz_)
     {return pp_print_if_newline(std_formatter,_kz_)}
    function open_tbox(_ky_){return pp_open_tbox(std_formatter,_ky_)}
    function close_tbox(_kx_){return pp_close_tbox(std_formatter,_kx_)}
    function print_tbreak(_kv_,_kw_)
     {return pp_print_tbreak(std_formatter,_kv_,_kw_)}
    function set_tab(_ku_){return pp_set_tab(std_formatter,_ku_)}
    function print_tab(_kt_){return pp_print_tab(std_formatter,_kt_)}
    function set_margin(_ks_){return pp_set_margin(std_formatter,_ks_)}
    function get_margin(_kr_){return std_formatter[6]}
    function set_max_indent(_kq_)
     {return pp_set_max_indent(std_formatter,_kq_)}
    function get_max_indent(_kp_){return std_formatter[8]}
    function set_geometry(_kn_,_ko_)
     {return pp_set_geometry(std_formatter,_kn_,_ko_)}
    function safe_set_geometry(_kl_,_km_)
     {return pp_safe_set_geometry(std_formatter,_kl_,_km_)}
    function get_geometry(_kk_){return pp_get_geometry(std_formatter,_kk_)}
    function update_geometry(_kj_)
     {return pp_update_geometry(std_formatter,_kj_)}
    function set_max_boxes(_ki_){return pp_set_max_boxes(std_formatter,_ki_)}
    function get_max_boxes(_kh_){return std_formatter[15]}
    function over_max_boxes(_kg_)
     {return pp_over_max_boxes(std_formatter,_kg_)}
    function set_ellipsis_text(_kf_)
     {return pp_set_ellipsis_text(std_formatter,_kf_)}
    function get_ellipsis_text(_ke_){return std_formatter[16]}
    function set_formatter_out_channel(_kd_)
     {return pp_set_formatter_out_channel(std_formatter,_kd_)}
    function set_formatter_out_functions(_kc_)
     {return pp_set_formatter_out_functions(std_formatter,_kc_)}
    function get_formatter_out_functions(_kb_)
     {return pp_get_formatter_out_functions(std_formatter,_kb_)}
    function set_formatter_output_functions(_j$_,_ka_)
     {return pp_set_formatter_output_functi(std_formatter,_j$_,_ka_)}
    function get_formatter_output_functions(_j__)
     {return pp_get_formatter_output_functi(std_formatter,_j__)}
    function set_formatter_stag_functions(_j9_)
     {return pp_set_formatter_stag_function(std_formatter,_j9_)}
    function get_formatter_stag_functions(_j8_)
     {return pp_get_formatter_stag_function(std_formatter,_j8_)}
    function set_print_tags(_j7_)
     {return pp_set_print_tags(std_formatter,_j7_)}
    function get_print_tags(_j6_){return std_formatter[22]}
    function set_mark_tags(_j5_){return pp_set_mark_tags(std_formatter,_j5_)}
    function get_mark_tags(_j4_){return std_formatter[23]}
    function set_tags(_j3_){return pp_set_tags(std_formatter,_j3_)}
    function pp_print_list(opt,pp_v,ppf,param)
     {var opt$0=opt,param$0=param;
      for(;;)
       {if(opt$0)var sth=opt$0[1],pp_sep=sth;else var pp_sep=pp_print_cut;
        if(param$0)
         {var _j2_=param$0[1];
          if(param$0[2])
           {var vs=param$0[2];
            caml_call2(pp_v,ppf,_j2_);
            caml_call2(pp_sep,ppf,0);
            var opt$1=[0,pp_sep],opt$0=opt$1,param$0=vs;
            continue}
          return caml_call2(pp_v,ppf,_j2_)}
        return 0}}
    function pp_print_seq(opt,pp_v,ppf,seq$1)
     {if(opt)var sth=opt[1],pp_sep=sth;else var pp_sep=pp_print_cut;
      var match$0=caml_call1(seq$1,0);
      if(match$0)
       {var seq$2=match$0[2],v$0=match$0[1];
        caml_call2(pp_v,ppf,v$0);
        var seq=seq$2;
        for(;;)
         {var match=caml_call1(seq,0);
          if(match)
           {var seq$0=match[2],v=match[1];
            caml_call2(pp_sep,ppf,0);
            caml_call2(pp_v,ppf,v);
            var seq=seq$0;
            continue}
          return 0}}
      return 0}
    function pp_print_text(ppf,s)
     {var len=caml_ml_string_length(s),left=[0,0],right=[0,0];
      function flush(param)
       {pp_print_string(ppf,sub$0(s,left[1],right[1] - left[1] | 0));
        right[1]++;
        left[1] = right[1];
        return 0}
      for(;;)
       {if(right[1] !== len)
         {var match=caml_string_get(s,right[1]);
          if(10 === match)
           {flush(0);pp_force_newline(ppf,0)}
          else
           if(32 === match){flush(0);pp_print_space(ppf,0)}else right[1]++;
          continue}
        var _j1_=left[1] !== len?1:0;
        return _j1_?flush(0):_j1_}}
    function pp_print_option(opt,pp_v,ppf,param)
     {if(opt)
       var sth=opt[1],none=sth;
      else
       var none=function(param,_j0_){return 0};
      if(param){var v=param[1];return caml_call2(pp_v,ppf,v)}
      return caml_call2(none,ppf,0)}
    function pp_print_result(ok,error,ppf,param)
     {if(0 === param[0]){var v=param[1];return caml_call2(ok,ppf,v)}
      var e=param[1];
      return caml_call2(error,ppf,e)}
    function pp_print_either(left,right,ppf,param)
     {if(0 === param[0]){var l=param[1];return caml_call2(left,ppf,l)}
      var r=param[1];
      return caml_call2(right,ppf,r)}
    function compute_tag(output,tag_acc)
     {var buf=create$2(16),ppf=formatter_of_buffer(buf);
      caml_call2(output,ppf,tag_acc);
      pp_print_flush(ppf,0);
      var len=buf[2];
      return 2 <= len?sub$3(buf,1,len - 2 | 0):contents(buf)}
    function output_formatting_lit(ppf,fmting_lit)
     {if(typeof fmting_lit === "number")
       switch(fmting_lit)
        {case 0:return pp_close_box(ppf,0);
         case 1:return pp_close_tag(ppf,0);
         case 2:return pp_print_flush(ppf,0);
         case 3:return pp_force_newline(ppf,0);
         case 4:return pp_print_newline(ppf,0);
         case 5:return pp_print_char(ppf,64);
         default:return pp_print_char(ppf,37)}
      else
       switch(fmting_lit[0])
        {case 0:
          var offset=fmting_lit[3],width=fmting_lit[2];
          return pp_print_break(ppf,width,offset);
         case 1:return 0;
         default:
          var c=fmting_lit[1];
          pp_print_char(ppf,64);
          return pp_print_char(ppf,c)}}
    function output_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _jQ_=acc[2],_jR_=acc[1];
          if(0 === _jQ_[0])
           {var acc$0=_jQ_[1];
            output_acc$0(ppf,_jR_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(output_acc$0,acc$0)])}
          var acc$1=_jQ_[1];
          output_acc$0(ppf,_jR_);
          var
           match=open_box_of_string(compute_tag(output_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _jS_=acc[1],switch$1=0;
          if(typeof _jS_ !== "number" && 0 === _jS_[0])
           {var _jT_=_jS_[2],switch$2=0;
            if(typeof _jT_ !== "number" && 1 === _jT_[0])
             {var s$0=acc[2],size=_jT_[2],p$1=_jS_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_jS_;switch$0 = 2}
          break;
         case 3:
          var _jU_=acc[1],switch$3=0;
          if(typeof _jU_ !== "number" && 0 === _jU_[0])
           {var _jV_=_jU_[2],switch$4=0;
            if(typeof _jV_ !== "number" && 1 === _jV_[0])
             {var c$0=acc[2],size$0=_jV_[2],p$3=_jU_[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_jU_;switch$0 = 3}
          break;
         case 4:
          var _jW_=acc[1],switch$5=0;
          if(typeof _jW_ !== "number" && 0 === _jW_[0])
           {var _jX_=_jW_[2],switch$6=0;
            if(typeof _jX_ !== "number" && 1 === _jX_[0])
             {var s$0=acc[2],size=_jX_[2],p$1=_jW_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_jW_;switch$0 = 2}
          break;
         case 5:
          var _jY_=acc[1],switch$7=0;
          if(typeof _jY_ === "number" || ! (0 === _jY_[0]))
           switch$7 = 1;
          else
           {var _jZ_=_jY_[2],switch$8=0;
            if(typeof _jZ_ !== "number" && 1 === _jZ_[0])
             {var c$0=acc[2],size$0=_jZ_[2],p$3=_jY_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_jY_;switch$0 = 3}
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc$0(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:output_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         output_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$1(1,c$0));
        case 2:output_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:output_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function strput_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          strput_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _jE_=acc[2],_jF_=acc[1];
          if(0 === _jE_[0])
           {var acc$0=_jE_[1];
            strput_acc$0(ppf,_jF_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(strput_acc$0,acc$0)])}
          var acc$1=_jE_[1];
          strput_acc$0(ppf,_jF_);
          var
           match=open_box_of_string(compute_tag(strput_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _jG_=acc[1],switch$1=0;
          if(typeof _jG_ !== "number" && 0 === _jG_[0])
           {var _jH_=_jG_[2],switch$2=0;
            if(typeof _jH_ !== "number" && 1 === _jH_[0])
             {var s$0=acc[2],size=_jH_[2],p$1=_jG_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_jG_;switch$0 = 2}
          break;
         case 3:
          var _jI_=acc[1],switch$3=0;
          if(typeof _jI_ !== "number" && 0 === _jI_[0])
           {var _jJ_=_jI_[2],switch$4=0;
            if(typeof _jJ_ !== "number" && 1 === _jJ_[0])
             {var c$0=acc[2],size$0=_jJ_[2],p$3=_jI_[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_jI_;switch$0 = 3}
          break;
         case 4:
          var _jK_=acc[1],switch$5=0;
          if(typeof _jK_ !== "number" && 0 === _jK_[0])
           {var _jL_=_jK_[2],switch$6=0;
            if(typeof _jL_ !== "number" && 1 === _jL_[0])
             {var s$0=acc[2],size=_jL_[2],p$1=_jK_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_jK_;switch$0 = 2}
          break;
         case 5:
          var _jM_=acc[1],switch$7=0;
          if(typeof _jM_ === "number" || ! (0 === _jM_[0]))
           switch$7 = 1;
          else
           {var _jN_=_jM_[2],switch$8=0;
            if(typeof _jN_ !== "number" && 1 === _jN_[0])
             {var c$0=acc[2],size$0=_jN_[2],p$3=_jM_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_jM_;switch$0 = 3}
          break;
         case 6:
          var _jO_=acc[1];
          if(typeof _jO_ !== "number" && 0 === _jO_[0])
           {var _jP_=_jO_[2];
            if(typeof _jP_ !== "number" && 1 === _jP_[0])
             {var f$1=acc[2],size$1=_jP_[2],p$4=_jO_[1];
              strput_acc$0(ppf,p$4);
              return pp_print_as_size(ppf,size$1,caml_call1(f$1,0))}}
          var f$0=acc[2];
          strput_acc$0(ppf,_jO_);
          return pp_print_string(ppf,caml_call1(f$0,0));
         case 7:
          var p$5=acc[1];strput_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          strput_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:strput_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         strput_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$1(1,c$0));
        case 2:strput_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:strput_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function kfprintf$0(k,ppf,param)
     {var fmt=param[1],_jD_=0;
      return make_printf
              (function(acc){output_acc$0(ppf,acc);return caml_call1(k,ppf)},
               _jD_,
               fmt)}
    function ikfprintf$0(k,ppf,param)
     {var fmt=param[1];return make_iprintf(k,ppf,fmt)}
    function ifprintf$0(ppf,param)
     {var fmt=param[1],_jB_=0;
      return make_iprintf(function(_jC_){return 0},_jB_,fmt)}
    function fprintf$0(ppf)
     {function _jy_(_jA_){return 0}
      return function(_jz_){return kfprintf$0(_jy_,ppf,_jz_)}}
    function printf$0(fmt){return caml_call1(fprintf$0(std_formatter),fmt)}
    function eprintf$0(fmt){return caml_call1(fprintf$0(err_formatter),fmt)}
    function kdprintf(k,param)
     {var fmt=param[1],_jx_=0;
      return make_printf
              (function(acc)
                {return caml_call1
                         (k,function(ppf){return output_acc$0(ppf,acc)})},
               _jx_,
               fmt)}
    function dprintf(fmt){return kdprintf(function(i){return i},fmt)}
    function kprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {strput_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function sprintf$0(fmt){return kprintf(id$0,fmt)}
    function kasprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {output_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function asprintf(fmt){return kasprintf(id$0,fmt)}
    function flush_standard_formatters(param)
     {pp_print_flush(std_formatter,0);return pp_print_flush(err_formatter,0)}
    at_exit(flush_standard_formatters);
    function pp_set_all_formatter_output_fu(state,f,g,h,i)
     {pp_set_formatter_output_functi(state,f,g);
      state[19] = h;
      state[20] = i;
      return 0}
    function pp_get_all_formatter_output_fu(state,param)
     {return [0,state[17],state[18],state[19],state[20]]}
    function set_all_formatter_output_funct(_jt_,_ju_,_jv_,_jw_)
     {return pp_set_all_formatter_output_fu(std_formatter,_jt_,_ju_,_jv_,_jw_)}
    function get_all_formatter_output_funct(_js_)
     {return pp_get_all_formatter_output_fu(std_formatter,_js_)}
    function bprintf$0(b,param)
     {var fmt=param[1],ppf=formatter_of_buffer(b);
      function k(acc){output_acc$0(ppf,acc);return pp_flush_queue(ppf,0)}
      return make_printf(k,0,fmt)}
    function pp_set_formatter_tag_functions(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      function stringify(f,e,param)
       {if(param[1] === String_tag){var s=param[2];return caml_call1(f,s)}
        return e}
      state[24] = function(_jr_){return stringify(mot,cst$84,_jr_)};
      state[25] = function(_jq_){return stringify(mct,cst$85,_jq_)};
      var _jm_=0;
      state[26] = function(_jp_){return stringify(pot,_jm_,_jp_)};
      var _jn_=0;
      state[27] = function(_jo_){return stringify(pct,_jn_,_jo_)};
      return 0}
    function pp_get_formatter_tag_functions(fmt,param)
     {var funs=pp_get_formatter_stag_function(fmt,0);
      function mark_open_tag(s){return caml_call1(funs[1],[0,String_tag,s])}
      function mark_close_tag(s){return caml_call1(funs[2],[0,String_tag,s])}
      function print_open_tag(s){return caml_call1(funs[3],[0,String_tag,s])}
      function print_close_tag(s){return caml_call1(funs[4],[0,String_tag,s])}
      return [0,mark_open_tag,mark_close_tag,print_open_tag,print_close_tag]}
    function set_formatter_tag_functions(_jl_)
     {return pp_set_formatter_tag_functions(std_formatter,_jl_)}
    function get_formatter_tag_functions(_jk_)
     {return pp_get_formatter_tag_functions(std_formatter,_jk_)}
    var
     Stdlib_Format=
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string$0,
       pp_print_bytes,
       print_bytes$0,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int$0,
       pp_print_float,
       print_float$0,
       pp_print_char,
       print_char$0,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_print_custom_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline$0,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       check_geometry,
       pp_set_geometry,
       set_geometry,
       pp_safe_set_geometry,
       safe_set_geometry,
       pp_update_geometry,
       update_geometry,
       pp_get_geometry,
       get_geometry,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       String_tag,
       pp_open_stag,
       open_stag,
       pp_close_stag,
       close_stag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functi,
       set_formatter_output_functions,
       pp_get_formatter_output_functi,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_stag_function,
       set_formatter_stag_functions,
       pp_get_formatter_stag_function,
       get_formatter_stag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_b,
       pp_print_list,
       pp_print_seq,
       pp_print_text,
       pp_print_option,
       pp_print_result,
       pp_print_either,
       fprintf$0,
       printf$0,
       eprintf$0,
       sprintf$0,
       asprintf,
       dprintf,
       ifprintf$0,
       kfprintf$0,
       kdprintf,
       ikfprintf$0,
       kprintf,
       kasprintf,
       bprintf$0,
       kprintf,
       set_all_formatter_output_funct,
       get_all_formatter_output_funct,
       pp_set_all_formatter_output_fu,
       pp_get_all_formatter_output_fu,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions];
    caml_register_global(802,Stdlib_Format,"Stdlib__Format");
    var null_char=0;
    function next_char(ib)
     {try
       {var c=caml_call1(ib[7],0);
        ib[2] = c;
        ib[3] = 1;
        ib[4] = ib[4] + 1 | 0;
        if(10 === c)ib[5] = ib[5] + 1 | 0;
        return c}
      catch(_jj_)
       {_jj_ = caml_wrap_exception(_jj_);
        if(_jj_ === End_of_file)
         {ib[2] = null_char;ib[3] = 0;ib[1] = 1;return null_char}
        throw _jj_}}
    function peek_char(ib){return ib[3]?ib[2]:next_char(ib)}
    function checked_peek_char(ib)
     {var c=peek_char(ib);if(ib[1])throw End_of_file;return c}
    function end_of_input(ib){peek_char(ib);return ib[1]}
    function beginning_of_input(ib){return 0 === ib[4]?1:0}
    function name_of_input(ib)
     {var _ji_=ib[9];
      if(typeof _ji_ === "number")
       return 0 === _ji_?cst_unnamed_function:cst_unnamed_character_string;
      else
       {if(0 === _ji_[0])return cst_unnamed_Stdlib_input_chann;
        var fname=_ji_[1];
        return fname}}
    function char_count(ib){return ib[3]?ib[4] - 1 | 0:ib[4]}
    function reset_token(ib){return reset(ib[8])}
    function invalidate_current_char(ib){ib[3] = 0;return 0}
    function token_string(ib)
     {var token_buffer=ib[8],tok=contents(token_buffer);
      clear$1(token_buffer);
      ib[6] = ib[6] + 1 | 0;
      return tok}
    function skip_char(width,ib){invalidate_current_char(ib);return width}
    function ignore_char(width,ib){return skip_char(width - 1 | 0,ib)}
    function store_char(width,ib,c)
     {add_char(ib[8],c);return ignore_char(width,ib)}
    var default_token_buffer_size=1024;
    function create$4(iname,next)
     {return [0,
              0,
              null_char,
              0,
              0,
              0,
              0,
              next,
              create$2(default_token_buffer_size),
              iname]}
    function from_string$1(s)
     {var i=[0,0],len=caml_ml_string_length(s);
      function next(param)
       {if(len <= i[1])throw End_of_file;
        var c=caml_string_get(s,i[1]);
        i[1]++;
        return c}
      return create$4(1,next)}
    var _ck_=0;
    function from_function$0(_jh_){return create$4(_ck_,_jh_)}
    var len=1024;
    function scan_close_at_end(ic)
     {caml_ml_close_channel(ic);throw End_of_file}
    function scan_raise_at_end(ic){throw End_of_file}
    function from_ic(scan_close_ic,iname,ic)
     {var buf=caml_create_bytes(1024),i=[0,0],lim=[0,0],eof=[0,0];
      function next(param)
       {if(i[1] < lim[1]){var c=caml_bytes_get(buf,i[1]);i[1]++;return c}
        if(eof[1])throw End_of_file;
        lim[1] = input(ic,buf,0,len);
        return 0 === lim[1]
                ?(eof[1] = 1,caml_call1(scan_close_ic,ic))
                :(i[1] = 1,caml_bytes_get(buf,0))}
      return create$4(iname,next)}
    var stdib=from_ic(scan_raise_at_end,[1,cst$86,stdin],stdin);
    function open_in_file(open_in,fname)
     {if(caml_string_notequal(fname,cst$87))
       {var ic=caml_call1(open_in,fname);
        return from_ic(scan_close_at_end,[1,fname,ic],ic)}
      return stdib}
    function from_file(_jg_){return open_in_file(open_in,_jg_)}
    function from_file_bin(_jf_){return open_in_file(open_in_bin,_jf_)}
    function from_channel$0(ic){return from_ic(scan_raise_at_end,[0,ic],ic)}
    function close_in$0(ib)
     {var _je_=ib[9];
      if(typeof _je_ === "number")
       return 0;
      else
       {if(0 === _je_[0]){var ic=_je_[1];return caml_ml_close_channel(ic)}
        var ic$0=_je_[2];
        return caml_ml_close_channel(ic$0)}}
    var memo=[0,0];
    function memo_from_ic(scan_close_ic,ic)
     {try
       {var _jc_=assq(ic,memo[1]);return _jc_}
      catch(_jd_)
       {_jd_ = caml_wrap_exception(_jd_);
        if(_jd_ === Not_found)
         {var ib=from_ic(scan_close_ic,[0,ic],ic);
          memo[1] = [0,[0,ic,ib],memo[1]];
          return ib}
        throw _jd_}}
    function memo_from_channel(_jb_)
     {return memo_from_ic(scan_raise_at_end,_jb_)}
    var Scan_failure=[248,cst_Stdlib_Scanf_Scan_failure,caml_fresh_oo_id(0)];
    function bad_input(s){throw [0,Scan_failure,s]}
    function bad_input_escape(c)
     {return bad_input(caml_call1(sprintf(_cl_),c))}
    function bad_token_length(message)
     {return bad_input(caml_call1(sprintf(_cm_),message))}
    function bad_float(param)
     {return bad_input(cst_no_dot_or_exponent_part_fo)}
    function bad_hex_float(param)
     {return bad_input(cst_not_a_valid_float_in_hexad)}
    function character_mismatch(c,ci)
     {return bad_input(caml_call2(sprintf(_co_),c,ci))}
    function check_this_char(ib,c)
     {var ci=checked_peek_char(ib);
      return ci === c?invalidate_current_char(ib):character_mismatch(c,ci)}
    function check_char(ib,c$0)
     {if(10 === c$0)
       {var ci=checked_peek_char(ib);
        return 10 === ci
                ?invalidate_current_char(ib)
                :13 === ci
                  ?(invalidate_current_char(ib),check_this_char(ib,10))
                  :character_mismatch(10,ci)}
      if(32 === c$0)
       for(;;)
        {var c=peek_char(ib),_i$_=1 - ib[1];
         if(_i$_)
          {var _ja_=c - 9 | 0,switch$0=0;
           if(4 < _ja_ >>> 0)
            {if(23 === _ja_)switch$0 = 1}
           else
            if(1 < _ja_ - 2 >>> 0)switch$0 = 1;
           if(switch$0){invalidate_current_char(ib);continue}
           return 0}
         return _i$_}
      return check_this_char(ib,c$0)}
    function token_char(ib){return caml_string_get(token_string(ib),0)}
    function token_bool(ib)
     {var s=token_string(ib);
      return caml_string_notequal(s,cst_false$3)
              ?caml_string_notequal(s,cst_true$3)
                ?bad_input(caml_call1(sprintf(_cp_),s))
                :1
              :0}
    function integer_conversion_of_char(param)
     {var switcher=param - 88 | 0;
      if(! (32 < switcher >>> 0))
       switch(switcher)
        {case 10:return 0;
         case 12:return 1;
         case 17:return 2;
         case 23:return 3;
         case 29:return 4;
         case 0:
         case 32:return 5
         }
      throw [0,Assert_failure,_cq_]}
    function token_int_literal(conv,ib)
     {switch(conv)
       {case 0:var tok=cat(cst_0b,token_string(ib));break;
        case 3:var tok=cat(cst_0o,token_string(ib));break;
        case 4:var tok=cat(cst_0u,token_string(ib));break;
        case 5:var tok=cat(cst_0x,token_string(ib));break;
        default:var tok=token_string(ib)}
      var l=caml_ml_string_length(tok);
      if(0 !== l && 43 === caml_string_get(tok,0))
       return sub$0(tok,1,l - 1 | 0);
      return tok}
    function token_float(ib){return caml_float_of_string(token_string(ib))}
    function scan_decimal_digit_star(width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(58 <= c)
         {if(95 === c)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}}
        else
         if(48 <= c)
          {var width$2=store_char(width$0,ib,c),width$0=width$2;continue}
        return width$0}}
    function scan_unsigned_decimal_int(width,ib)
     {if(0 === width)return bad_token_length(cst_decimal_digits);
      var c=checked_peek_char(ib);
      if(9 < c - 48 >>> 0)return bad_input(caml_call1(sprintf(_cr_),c));
      var width$0=store_char(width,ib,c);
      return scan_decimal_digit_star(width$0,ib)}
    function scan_digit_plus(basis,digitp,width$2,ib)
     {if(0 === width$2)return bad_token_length(cst_digits);
      var c$0=checked_peek_char(ib);
      if(caml_call1(digitp,c$0))
       {var width$3=store_char(width$2,ib,c$0),width=width$3;
        for(;;)
         {if(0 === width)return width;
          var c=peek_char(ib);
          if(ib[1])return width;
          if(caml_call1(digitp,c))
           {var width$0=store_char(width,ib,c),width=width$0;continue}
          if(95 === c)
           {var width$1=ignore_char(width,ib),width=width$1;continue}
          return width}}
      return bad_input(caml_call2(sprintf(_cs_),c$0,basis))}
    function is_binary_digit(param){return 1 < param - 48 >>> 0?0:1}
    function scan_binary_int(_i9_,_i__)
     {return scan_digit_plus(cst_binary,is_binary_digit,_i9_,_i__)}
    function is_octal_digit(param){return 7 < param - 48 >>> 0?0:1}
    function scan_octal_int(_i7_,_i8_)
     {return scan_digit_plus(cst_octal,is_octal_digit,_i7_,_i8_)}
    function is_hexa_digit(param)
     {var _i6_=param - 48 | 0,switch$0=0;
      if(22 < _i6_ >>> 0)
       {if(! (5 < _i6_ - 49 >>> 0))switch$0 = 1}
      else
       if(6 < _i6_ - 10 >>> 0)switch$0 = 1;
      return switch$0?1:0}
    function scan_hexadecimal_int(_i4_,_i5_)
     {return scan_digit_plus(cst_hexadecimal,is_hexa_digit,_i4_,_i5_)}
    function scan_sign(width,ib)
     {var c=checked_peek_char(ib),switcher=c - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:return store_char(width,ib,c);
         case 1:break;
         default:return store_char(width,ib,c)}
      return width}
    function scan_optionally_signed_decimal(width,ib)
     {var width$0=scan_sign(width,ib);
      return scan_unsigned_decimal_int(width$0,ib)}
    function scan_int_conversion(conv,width$1,ib)
     {switch(conv)
       {case 0:return scan_binary_int(width$1,ib);
        case 1:return scan_optionally_signed_decimal(width$1,ib);
        case 2:
         var width$0=scan_sign(width$1,ib),c=checked_peek_char(ib);
         if(48 === c)
          {var width=store_char(width$0,ib,c);
           if(0 === width)return width;
           var c$0=peek_char(ib);
           if(ib[1])return width;
           var switch$0=0;
           if(99 <= c$0)
            {if(111 === c$0)
              return scan_octal_int(store_char(width,ib,c$0),ib);
             if(120 === c$0)switch$0 = 1}
           else
            if(88 === c$0)
             switch$0 = 1;
            else
             if(98 <= c$0)return scan_binary_int(store_char(width,ib,c$0),ib);
           return switch$0
                   ?scan_hexadecimal_int(store_char(width,ib,c$0),ib)
                   :scan_decimal_digit_star(width,ib)}
         return scan_unsigned_decimal_int(width$0,ib);
        case 3:return scan_octal_int(width$1,ib);
        case 4:return scan_unsigned_decimal_int(width$1,ib);
        default:return scan_hexadecimal_int(width$1,ib)}}
    function scan_fractional_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      return ib[1]
              ?width
              :9 < c - 48 >>> 0
                ?width
                :scan_decimal_digit_star(store_char(width,ib,c),ib)}
    function scan_exponent_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      if(69 !== c && 101 !== c)return width;
      return scan_optionally_signed_decimal(store_char(width,ib,c),ib)}
    function scan_float(width$1,precision,ib)
     {var
       width=scan_sign(width$1,ib),
       width$0=scan_decimal_digit_star(width,ib);
      if(0 === width$0)return [0,width$0,precision];
      var c=peek_char(ib);
      if(ib[1])return [0,width$0,precision];
      if(46 === c)
       {var
         width$2=store_char(width$0,ib,c),
         precision$0=min$1(width$2,precision),
         width$3=
          width$2
          -
          (precision$0 - scan_fractional_part(precision$0,ib) | 0)
          |
          0;
        return [0,scan_exponent_part(width$3,ib),precision$0]}
      return [0,scan_exponent_part(width$0,ib),precision]}
    function check_case_insensitive_string(width,ib,error,str)
     {function lowercase(c)
       {return 25 < c - 65 >>> 0?c:char_of_int((c - 65 | 0) + 97 | 0)}
      var
       len=caml_ml_string_length(str),
       width$0=[0,width],
       _i1_=len - 1 | 0,
       _i0_=0;
      if(! (_i1_ < 0))
       {var i=_i0_;
        for(;;)
         {var c=peek_char(ib),_i2_=lowercase(caml_string_get(str,i));
          if(lowercase(c) !== _i2_)caml_call1(error,0);
          if(0 === width$0[1])caml_call1(error,0);
          width$0[1] = store_char(width$0[1],ib,c);
          var _i3_=i + 1 | 0;
          if(_i1_ !== i){var i=_i3_;continue}
          break}}
      return width$0[1]}
    function scan_hex_float(width,precision,ib)
     {var _iN_=0 === width?1:0,_iO_=_iN_ || end_of_input(ib);
      if(_iO_)bad_hex_float(0);
      var
       width$0=scan_sign(width,ib),
       _iP_=0 === width$0?1:0,
       _iQ_=_iP_ || end_of_input(ib);
      if(_iQ_)bad_hex_float(0);
      var c=peek_char(ib),switch$0=0;
      if(78 <= c)
       {var switcher=c - 79 | 0;
        if(30 < switcher >>> 0)
         {if(! (32 <= switcher))
           {var
             width$1=store_char(width$0,ib,c),
             _iR_=0 === width$1?1:0,
             _iS_=_iR_ || end_of_input(ib);
            if(_iS_)bad_hex_float(0);
            return check_case_insensitive_string
                    (width$1,ib,bad_hex_float,cst_an)}}
        else
         if(26 === switcher)switch$0 = 1}
      else
       {if(48 === c)
         {var
           width$3=store_char(width$0,ib,c),
           _iV_=0 === width$3?1:0,
           _iW_=_iV_ || end_of_input(ib);
          if(_iW_)bad_hex_float(0);
          var
           width$4=
            check_case_insensitive_string(width$3,ib,bad_hex_float,cst_x$2);
          if(0 !== width$4 && ! end_of_input(ib))
           {var match=peek_char(ib),_iX_=match - 46 | 0,switch$1=0;
            if(34 < _iX_ >>> 0)
             {if(66 === _iX_)switch$1 = 1}
            else
             if(32 < _iX_ - 1 >>> 0)switch$1 = 1;
            var width$5=switch$1?width$4:scan_hexadecimal_int(width$4,ib);
            if(0 !== width$5 && ! end_of_input(ib))
             {var c$0=peek_char(ib);
              if(46 === c$0)
               {var width$6=store_char(width$5,ib,c$0),switch$2=0;
                if(0 !== width$6 && ! end_of_input(ib))
                 {var match$0=peek_char(ib),switch$3=0;
                  if(80 !== match$0 && 112 !== match$0)
                   {var
                     precision$0=min$1(width$6,precision),
                     width$10=
                      width$6
                      -
                      (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                      |
                      0;
                    switch$3 = 1}
                  if(! switch$3)var width$10=width$6;
                  var width$7=width$10;
                  switch$2 = 1}
                if(! switch$2)var width$7=width$6;
                var width$8=width$7}
              else
               var width$8=width$5;
              if(0 !== width$8 && ! end_of_input(ib))
               {var c$1=peek_char(ib);
                if(80 !== c$1 && 112 !== c$1)return width$8;
                var
                 width$9=store_char(width$8,ib,c$1),
                 _iY_=0 === width$9?1:0,
                 _iZ_=_iY_ || end_of_input(ib);
                if(_iZ_)bad_hex_float(0);
                return scan_optionally_signed_decimal(width$9,ib)}
              return width$8}
            return width$5}
          return width$4}
        if(73 === c)switch$0 = 1}
      if(switch$0)
       {var
         width$2=store_char(width$0,ib,c),
         _iT_=0 === width$2?1:0,
         _iU_=_iT_ || end_of_input(ib);
        if(_iU_)bad_hex_float(0);
        return check_case_insensitive_string
                (width$2,ib,bad_hex_float,cst_nfinity)}
      return bad_hex_float(0)}
    function scan_caml_float_rest(width,precision,ib)
     {var _iJ_=0 === width?1:0,_iK_=_iJ_ || end_of_input(ib);
      if(_iK_)bad_float(0);
      var
       width$0=scan_decimal_digit_star(width,ib),
       _iL_=0 === width$0?1:0,
       _iM_=_iL_ || end_of_input(ib);
      if(_iM_)bad_float(0);
      var c=peek_char(ib),switcher=c - 69 | 0;
      if(32 < switcher >>> 0)
       {if(-23 === switcher)
         {var
           width$1=store_char(width$0,ib,c),
           precision$0=min$1(width$1,precision),
           width_precision=scan_fractional_part(precision$0,ib),
           frac_width=precision$0 - width_precision | 0,
           width$2=width$1 - frac_width | 0;
          return scan_exponent_part(width$2,ib)}}
      else
       if(30 < switcher - 1 >>> 0)return scan_exponent_part(width$0,ib);
      return bad_float(0)}
    function scan_caml_float(width,precision,ib)
     {var _iv_=0 === width?1:0,_iw_=_iv_ || end_of_input(ib);
      if(_iw_)bad_float(0);
      var
       width$0=scan_sign(width,ib),
       _ix_=0 === width$0?1:0,
       _iy_=_ix_ || end_of_input(ib);
      if(_iy_)bad_float(0);
      var c=peek_char(ib);
      if(49 <= c)
       {if(! (58 <= c))
         {var
           width$1=store_char(width$0,ib,c),
           _iz_=0 === width$1?1:0,
           _iA_=_iz_ || end_of_input(ib);
          if(_iA_)bad_float(0);
          return scan_caml_float_rest(width$1,precision,ib)}}
      else
       if(48 <= c)
        {var
          width$2=store_char(width$0,ib,c),
          _iB_=0 === width$2?1:0,
          _iC_=_iB_ || end_of_input(ib);
         if(_iC_)bad_float(0);
         var c$0=peek_char(ib);
         if(88 !== c$0 && 120 !== c$0)
          return scan_caml_float_rest(width$2,precision,ib);
         var
          width$3=store_char(width$2,ib,c$0),
          _iD_=0 === width$3?1:0,
          _iE_=_iD_ || end_of_input(ib);
         if(_iE_)bad_float(0);
         var
          width$4=scan_hexadecimal_int(width$3,ib),
          _iF_=0 === width$4?1:0,
          _iG_=_iF_ || end_of_input(ib);
         if(_iG_)bad_float(0);
         var c$1=peek_char(ib),switcher=c$1 - 80 | 0,switch$0=0;
         if(32 < switcher >>> 0)
          if(-34 === switcher)
           {var width$5=store_char(width$4,ib,c$1),switch$1=0;
            if(0 !== width$5 && ! end_of_input(ib))
             {var match=peek_char(ib),switch$2=0;
              if(80 !== match && 112 !== match)
               {var
                 precision$0=min$1(width$5,precision),
                 width$10=
                  width$5
                  -
                  (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                  |
                  0;
                switch$2 = 1}
              if(! switch$2)var width$10=width$5;
              var width$6=width$10;
              switch$1 = 1}
            if(! switch$1)var width$6=width$5;
            var width$7=width$6}
          else
           switch$0 = 1;
         else
          if(30 < switcher - 1 >>> 0)var width$7=width$4;else switch$0 = 1;
         var width$8=switch$0?bad_float(0):width$7;
         if(0 !== width$8 && ! end_of_input(ib))
          {var c$2=peek_char(ib);
           if(80 !== c$2 && 112 !== c$2)return width$8;
           var
            width$9=store_char(width$8,ib,c$2),
            _iH_=0 === width$9?1:0,
            _iI_=_iH_ || end_of_input(ib);
           if(_iI_)bad_hex_float(0);
           return scan_optionally_signed_decimal(width$9,ib)}
         return width$8}
      return bad_float(0)}
    function scan_string(stp,width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(stp)
         {var c$0=stp[1];
          if(c === c$0)return skip_char(width$0,ib);
          var width$1=store_char(width$0,ib,c),width$0=width$1;
          continue}
        var _iu_=c - 9 | 0,switch$0=0;
        if(4 < _iu_ >>> 0)
         {if(23 === _iu_)switch$0 = 1}
        else
         if(1 < _iu_ - 2 >>> 0)switch$0 = 1;
        if(switch$0)return width$0;
        var width$2=store_char(width$0,ib,c),width$0=width$2;
        continue}}
    function scan_char(width,ib)
     {return store_char(width,ib,checked_peek_char(ib))}
    function hexadecimal_value_of_char(d)
     {return 97 <= d?d - 87 | 0:65 <= d?d - 55 | 0:d - 48 | 0}
    function check_next_char(message,width,ib)
     {if(0 === width)return bad_token_length(message);
      var c=peek_char(ib);
      return ib[1]?bad_input(caml_call1(sprintf(_cn_),message)):c}
    function check_next_char_for_char(_is_,_it_)
     {return check_next_char(cst_a_Char,_is_,_it_)}
    function check_next_char_for_string(_iq_,_ir_)
     {return check_next_char(cst_a_String,_iq_,_ir_)}
    function scan_backslash_char(width,ib)
     {var c0=check_next_char_for_char(width,ib),switch$0=0;
      if(40 <= c0)
       {if(58 <= c0)
         {var switcher=c0 - 92 | 0;
          if(! (28 < switcher >>> 0))
           switch(switcher)
            {case 28:
              var
               get_digit=
                function(param)
                 {var c=next_char(ib),_ip_=c - 48 | 0,switch$0=0;
                  if(22 < _ip_ >>> 0)
                   {if(! (5 < _ip_ - 49 >>> 0))switch$0 = 1}
                  else
                   if(6 < _ip_ - 10 >>> 0)switch$0 = 1;
                  return switch$0?c:bad_input_escape(c)},
               c1=get_digit(0),
               c2=get_digit(0),
               _il_=hexadecimal_value_of_char(c2),
               c$0=(16 * hexadecimal_value_of_char(c1) | 0) + _il_ | 0,
               switch$1=0;
              if(0 <= c$0 && ! (255 < c$0))
               {var _in_=char_of_int(c$0);switch$1 = 1}
              if(! switch$1)
               var _in_=bad_input(caml_call2(sprintf(_cu_),c1,c2));
              return store_char(width - 2 | 0,ib,_in_);
             case 0:
             case 6:
             case 18:
             case 22:
             case 24:switch$0 = 1;break
             }}
        else
         if(48 <= c0)
          {var
            get_digit$0=
             function(param)
              {var c=next_char(ib);
               return 9 < c - 48 >>> 0?bad_input_escape(c):c},
            c1$0=get_digit$0(0),
            c2$0=get_digit$0(0),
            c=
             ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
             +
             (c2$0 - 48 | 0)
             |
             0,
            switch$2=0;
           if(0 <= c && ! (255 < c)){var _io_=char_of_int(c);switch$2 = 1}
           if(! switch$2)
            var _io_=bad_input(caml_call3(sprintf(_ct_),c0,c1$0,c2$0));
           return store_char(width - 2 | 0,ib,_io_)}}
      else
       if(34 === c0 || 39 <= c0)switch$0 = 1;
      if(switch$0)
       {var switch$3=0;
        if(110 <= c0)
         if(117 <= c0)
          switch$3 = 1;
         else
          switch(c0 - 110 | 0)
           {case 0:var _im_=10;break;
            case 4:var _im_=13;break;
            case 6:var _im_=9;break;
            default:switch$3 = 1}
        else
         if(98 === c0)var _im_=8;else switch$3 = 1;
        if(switch$3)var _im_=c0;
        return store_char(width,ib,_im_)}
      return bad_input_escape(c0)}
    function scan_caml_char(width,ib)
     {function find_stop(width)
       {var c=check_next_char_for_char(width,ib);
        return 39 === c?ignore_char(width,ib):character_mismatch(39,c)}
      var c=checked_peek_char(ib);
      if(39 === c)
       {var
         width$0=ignore_char(width,ib),
         c$0=check_next_char_for_char(width$0,ib);
        return 92 === c$0
                ?find_stop(scan_backslash_char(ignore_char(width$0,ib),ib))
                :find_stop(store_char(width$0,ib,c$0))}
      return character_mismatch(39,c)}
    function scan_caml_string(width,ib)
     {function find_stop$0(counter,width)
       {var width$0=width;
        for(;;)
         {var c=check_next_char_for_string(width$0,ib);
          if(34 === c)return ignore_char(width$0,ib);
          if(92 === c)
           {var
             width$1=ignore_char(width$0,ib),
             match=check_next_char_for_string(width$1,ib);
            if(10 === match)
             {var _ij_=ignore_char(width$1,ib);
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return skip_spaces(counter$0,_ij_)}
              return caml_trampoline_return(skip_spaces,[0,_ij_])}
            if(13 === match)
             {var
               width$3=ignore_char(width$1,ib),
               match$0=check_next_char_for_string(width$3,ib);
              if(10 === match$0)
               {var _ik_=ignore_char(width$3,ib);
                if(counter < 50)
                 {var counter$1=counter + 1 | 0;
                  return skip_spaces(counter$1,_ik_)}
                return caml_trampoline_return(skip_spaces,[0,_ik_])}
              var width$5=store_char(width$3,ib,13),width$0=width$5;
              continue}
            var width$4=scan_backslash_char(width$1,ib),width$0=width$4;
            continue}
          var width$2=store_char(width$0,ib,c),width$0=width$2;
          continue}}
      function skip_spaces(counter,width)
       {var width$0=width;
        for(;;)
         {var match=check_next_char_for_string(width$0,ib);
          if(32 === match)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return find_stop$0(counter$0,width$0)}
          return caml_trampoline_return(find_stop$0,[0,width$0])}}
      function find_stop(width){return caml_trampoline(find_stop$0(0,width))}
      var c=checked_peek_char(ib);
      return 34 === c
              ?find_stop(ignore_char(width,ib))
              :character_mismatch(34,c)}
    function scan_chars_in_char_set(char_set,scan_indic,width,ib)
     {function scan_chars(i,stp)
       {var i$0=i;
        for(;;)
         {var c=peek_char(ib),_if_=0 < i$0?1:0;
          if(_if_)
           {var _ig_=1 - ib[1];
            if(_ig_)
             var _ih_=is_in_char_set(char_set,c),_ii_=_ih_?c !== stp?1:0:_ih_;
            else
             var _ii_=_ig_}
          else
           var _ii_=_if_;
          if(_ii_)
           {store_char(max_int,ib,c);var i$1=i$0 - 1 | 0,i$0=i$1;continue}
          return _ii_}}
      if(scan_indic)
       {var c=scan_indic[1];
        scan_chars(width,c);
        var _ie_=1 - ib[1];
        if(_ie_)
         {var ci=peek_char(ib);
          return c === ci?invalidate_current_char(ib):character_mismatch(c,ci)}
        return _ie_}
      return scan_chars(width,-1)}
    function scanf_bad_input(ib,x)
     {if(x[1] === Scan_failure)
       var s=x[2];
      else
       {if(x[1] !== Failure)throw x;var s=x[2]}
      var i=char_count(ib);
      return bad_input(caml_call2(sprintf(_cw_),i,s))}
    function get_counter(ib,counter)
     {switch(counter)
       {case 0:return ib[5];case 1:return char_count(ib);default:return ib[6]}}
    function width_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return width}return max_int}
    function stopper_of_formatting_lit(fmting)
     {if(6 === fmting)return _cx_;
      var
       str=string_of_formatting_lit(fmting),
       stp=caml_string_get(str,1),
       sub_str=sub$0(str,2,caml_ml_string_length(str) - 2 | 0);
      return [0,stp,sub_str]}
    function take_format_readers$0(counter,k,fmt)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k,0);
       else
        switch(fmt$0[0])
         {case 0:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 1:var fmt$2=fmt$0[1],fmt$0=fmt$2;continue;
          case 2:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 3:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 4:var fmt$5=fmt$0[4],fmt$0=fmt$5;continue;
          case 5:var fmt$6=fmt$0[4],fmt$0=fmt$6;continue;
          case 6:var fmt$7=fmt$0[4],fmt$0=fmt$7;continue;
          case 7:var fmt$8=fmt$0[4],fmt$0=fmt$8;continue;
          case 8:var fmt$9=fmt$0[4],fmt$0=fmt$9;continue;
          case 9:var fmt$10=fmt$0[2],fmt$0=fmt$10;continue;
          case 10:var fmt$11=fmt$0[1],fmt$0=fmt$11;continue;
          case 11:var fmt$12=fmt$0[2],fmt$0=fmt$12;continue;
          case 12:var fmt$13=fmt$0[2],fmt$0=fmt$13;continue;
          case 13:var fmt$14=fmt$0[3],fmt$0=fmt$14;continue;
          case 14:
           var rest=fmt$0[3],fmtty=fmt$0[2],_ic_=erase_rel(symm(fmtty));
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return take_fmtty_format_readers$0(counter$0,k,_ic_,rest)}
           return caml_trampoline_return
                   (take_fmtty_format_readers$0,[0,k,_ic_,rest]);
          case 15:var fmt$15=fmt$0[1],fmt$0=fmt$15;continue;
          case 16:var fmt$16=fmt$0[1],fmt$0=fmt$16;continue;
          case 17:var fmt$17=fmt$0[2],fmt$0=fmt$17;continue;
          case 18:
           var _id_=fmt$0[1];
           if(0 === _id_[0])
            {var
              rest$0=fmt$0[2],
              match=_id_[1],
              fmt$18=match[1],
              fmt$19=concat_fmt(fmt$18,rest$0),
              fmt$0=fmt$19;
             continue}
           var
            rest$1=fmt$0[2],
            match$0=_id_[1],
            fmt$20=match$0[1],
            fmt$21=concat_fmt(fmt$20,rest$1),
            fmt$0=fmt$21;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_format_readers(new_k,fmt_rest)};
          case 20:var fmt$22=fmt$0[3],fmt$0=fmt$22;continue;
          case 21:var fmt$23=fmt$0[2],fmt$0=fmt$23;continue;
          case 22:var fmt$24=fmt$0[1],fmt$0=fmt$24;continue;
          case 23:
           var rest$2=fmt$0[2],ign=fmt$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:
               return function(reader)
                {function new_k(readers_rest)
                  {return caml_call1(k,[0,reader,readers_rest])}
                 return take_format_readers(new_k,rest$2)};
              default:var fmt$0=rest$2;continue}
           else
            switch(ign[0])
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:var fmt$0=rest$2;continue;
              case 3:var fmt$0=rest$2;continue;
              case 4:var fmt$0=rest$2;continue;
              case 5:var fmt$0=rest$2;continue;
              case 6:var fmt$0=rest$2;continue;
              case 7:var fmt$0=rest$2;continue;
              case 8:var fmt$0=rest$2;continue;
              case 9:
               var fmtty$0=ign[2];
               if(counter < 50)
                {var counter$1=counter + 1 | 0;
                 return take_fmtty_format_readers$0
                         (counter$1,k,fmtty$0,rest$2)}
               return caml_trampoline_return
                       (take_fmtty_format_readers$0,[0,k,fmtty$0,rest$2]);
              case 10:var fmt$0=rest$2;continue;
              default:var fmt$0=rest$2;continue}
          default:var fmt$25=fmt$0[3],fmt$0=fmt$25;continue}}
    function take_fmtty_format_readers$0(counter,k,fmtty,fmt)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        {if(counter < 50)
          {var counter$0=counter + 1 | 0;
           return take_format_readers$0(counter$0,k,fmt)}
         return caml_trampoline_return(take_format_readers$0,[0,k,fmt])}
       else
        switch(fmtty$0[0])
         {case 0:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 1:var fmtty$2=fmtty$0[1],fmtty$0=fmtty$2;continue;
          case 2:var fmtty$3=fmtty$0[1],fmtty$0=fmtty$3;continue;
          case 3:var fmtty$4=fmtty$0[1],fmtty$0=fmtty$4;continue;
          case 4:var fmtty$5=fmtty$0[1],fmtty$0=fmtty$5;continue;
          case 5:var fmtty$6=fmtty$0[1],fmtty$0=fmtty$6;continue;
          case 6:var fmtty$7=fmtty$0[1],fmtty$0=fmtty$7;continue;
          case 7:var fmtty$8=fmtty$0[1],fmtty$0=fmtty$8;continue;
          case 8:var fmtty$9=fmtty$0[2],fmtty$0=fmtty$9;continue;
          case 9:
           var
            rest=fmtty$0[3],
            ty2=fmtty$0[2],
            ty1=fmtty$0[1],
            ty=trans(symm(ty1),ty2),
            fmtty$10=concat_fmtty(ty,rest),
            fmtty$0=fmtty$10;
           continue;
          case 10:var fmtty$11=fmtty$0[1],fmtty$0=fmtty$11;continue;
          case 11:var fmtty$12=fmtty$0[1],fmtty$0=fmtty$12;continue;
          case 12:var fmtty$13=fmtty$0[1],fmtty$0=fmtty$13;continue;
          case 13:
           var fmt_rest=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest,fmt)};
          default:
           var fmt_rest$0=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest$0,fmt)}}}
    function take_format_readers(k,fmt)
     {return caml_trampoline(take_format_readers$0(0,k,fmt))}
    function take_fmtty_format_readers(k,fmtty,fmt)
     {return caml_trampoline(take_fmtty_format_readers$0(0,k,fmtty,fmt))}
    function make_scanf(ib,fmt,readers)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return 0;
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           scan_char(0,ib);
           var c=token_char(ib);
           return [0,c,make_scanf(ib,rest,readers)];
          case 1:
           var rest$0=fmt$0[1];
           scan_caml_char(0,ib);
           var c$0=token_char(ib);
           return [0,c$0,make_scanf(ib,rest$0,readers)];
          case 2:
           var _h1_=fmt$0[1],_h2_=fmt$0[2];
           if(typeof _h2_ !== "number")
            switch(_h2_[0])
             {case 17:
               var
                rest$2=_h2_[2],
                fmting_lit=_h2_[1],
                match=stopper_of_formatting_lit(fmting_lit),
                str=match[2],
                stp=match[1],
                scan$0=
                 function(width,param,ib)
                  {return scan_string([0,stp],width,ib)},
                str_rest=[11,str,rest$2];
               return pad_prec_scanf
                       (ib,str_rest,readers,_h1_,0,scan$0,token_string);
              case 18:
               var _h3_=_h2_[1];
               if(0 === _h3_[0])
                {var
                  rest$3=_h2_[2],
                  match$0=_h3_[1],
                  fmt$1=match$0[1],
                  scan$1=
                   function(width,param,ib){return scan_string(_cy_,width,ib)};
                 return pad_prec_scanf
                         (ib,
                          concat_fmt(fmt$1,rest$3),
                          readers,
                          _h1_,
                          0,
                          scan$1,
                          token_string)}
               var
                rest$4=_h2_[2],
                match$1=_h3_[1],
                fmt$2=match$1[1],
                scan$2=
                 function(width,param,ib){return scan_string(_cz_,width,ib)};
               return pad_prec_scanf
                       (ib,
                        concat_fmt(fmt$2,rest$4),
                        readers,
                        _h1_,
                        0,
                        scan$2,
                        token_string)
              }
           var
            rest$1=fmt$0[2],
            scan=function(width,param,ib){return scan_string(0,width,ib)};
           return pad_prec_scanf(ib,rest$1,readers,_h1_,0,scan,token_string);
          case 3:
           var
            rest$5=fmt$0[2],
            pad=fmt$0[1],
            scan$3=function(width,param,ib){return scan_caml_string(width,ib)};
           return pad_prec_scanf(ib,rest$5,readers,pad,0,scan$3,token_string);
          case 4:
           var
            rest$6=fmt$0[4],
            prec=fmt$0[3],
            pad$0=fmt$0[2],
            iconv=fmt$0[1],
            conv=integer_conversion_of_char(char_of_iconv(iconv)),
            scan$4=
             function(width,param,ib)
              {return scan_int_conversion(conv,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$6,
                    readers,
                    pad$0,
                    prec,
                    scan$4,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv,ib))});
          case 5:
           var
            rest$7=fmt$0[4],
            prec$0=fmt$0[3],
            pad$1=fmt$0[2],
            iconv$0=fmt$0[1],
            conv$0=integer_conversion_of_char(char_of_iconv(iconv$0)),
            scan$5=
             function(width,param,ib)
              {return scan_int_conversion(conv$0,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$7,
                    readers,
                    pad$1,
                    prec$0,
                    scan$5,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$0,ib))});
          case 6:
           var
            rest$8=fmt$0[4],
            prec$1=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$1=fmt$0[1],
            conv$1=integer_conversion_of_char(char_of_iconv(iconv$1)),
            scan$6=
             function(width,param,ib)
              {return scan_int_conversion(conv$1,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$8,
                    readers,
                    pad$2,
                    prec$1,
                    scan$6,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$1,ib))});
          case 7:
           var
            rest$9=fmt$0[4],
            prec$2=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$2=fmt$0[1],
            conv$2=integer_conversion_of_char(char_of_iconv(iconv$2)),
            scan$7=
             function(width,param,ib)
              {return scan_int_conversion(conv$2,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$9,
                    readers,
                    pad$3,
                    prec$2,
                    scan$7,
                    function(ib)
                     {return caml_int64_of_string(token_int_literal(conv$2,ib))});
          case 8:
           switch(fmt$0[1][2])
            {case 5:
             case 8:
              var rest$11=fmt$0[4],prec$4=fmt$0[3],pad$5=fmt$0[2];
              return pad_prec_scanf
                      (ib,
                       rest$11,
                       readers,
                       pad$5,
                       prec$4,
                       scan_caml_float,
                       token_float);
             case 6:
             case 7:
              var rest$12=fmt$0[4],prec$5=fmt$0[3],pad$6=fmt$0[2];
              return pad_prec_scanf
                      (ib,rest$12,readers,pad$6,prec$5,scan_hex_float,token_float);
             default:
              var rest$10=fmt$0[4],prec$3=fmt$0[3],pad$4=fmt$0[2];
              return pad_prec_scanf
                      (ib,rest$10,readers,pad$4,prec$3,scan_float,token_float)}
          case 9:
           var
            rest$13=fmt$0[2],
            pad$7=fmt$0[1],
            scan$8=
             function(param,_ib_,ib)
              {var
                c=checked_peek_char(ib),
                m=
                 102 === c
                  ?5
                  :116 === c?4:bad_input(caml_call1(sprintf(_cv_),c));
               return scan_string(0,m,ib)};
           return pad_prec_scanf(ib,rest$13,readers,pad$7,0,scan$8,token_bool);
          case 10:
           var rest$14=fmt$0[1];
           if(end_of_input(ib)){var fmt$0=rest$14;continue}
           return bad_input(cst_end_of_input_not_found);
          case 11:
           var rest$15=fmt$0[2],str$0=fmt$0[1];
           iter$4(function(_ia_){return check_char(ib,_ia_)},str$0);
           var fmt$0=rest$15;
           continue;
          case 12:
           var rest$16=fmt$0[2],chr=fmt$0[1];
           check_char(ib,chr);
           var fmt$0=rest$16;
           continue;
          case 13:
           var rest$17=fmt$0[3],fmtty=fmt$0[2],pad_opt=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt),ib);
           var s=token_string(ib);
           try
            {var _h4_=format_of_string_fmtty(s,fmtty),fmt$3=_h4_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var msg=exn[2],fmt$3=bad_input(msg)}
           return [0,fmt$3,make_scanf(ib,rest$17,readers)];
          case 14:
           var rest$18=fmt$0[3],fmtty$0=fmt$0[2],pad_opt$0=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt$0),ib);
           var s$0=token_string(ib);
           try
            {var
              match$2=fmt_ebb_of_string(0,s$0),
              fmt$6=match$2[1],
              match$3=fmt_ebb_of_string(0,s$0),
              fmt$7=match$3[1],
              fmt$8=type_format(fmt$7,erase_rel(symm(fmtty$0))),
              _h6_=type_format(fmt$6,erase_rel(fmtty$0)),
              fmt$5=fmt$8,
              fmt$4=_h6_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var
              msg$0=exn[2],
              _h5_=bad_input(msg$0),
              fmt$5=_h5_[2],
              fmt$4=_h5_[1]}
           return [0,
                   [0,fmt$4,s$0],
                   make_scanf(ib,concat_fmt(fmt$5,rest$18),readers)];
          case 15:return invalid_arg(cst_scanf_bad_conversion_a);
          case 16:return invalid_arg(cst_scanf_bad_conversion_t);
          case 17:
           var
            rest$19=fmt$0[2],
            formatting_lit=fmt$0[1],
            _h7_=string_of_formatting_lit(formatting_lit);
           iter$4(function(_h$_){return check_char(ib,_h$_)},_h7_);
           var fmt$0=rest$19;
           continue;
          case 18:
           var _h8_=fmt$0[1];
           if(0 === _h8_[0])
            {var rest$20=fmt$0[2],match$4=_h8_[1],fmt$9=match$4[1];
             check_char(ib,64);
             check_char(ib,123);
             var fmt$10=concat_fmt(fmt$9,rest$20),fmt$0=fmt$10;
             continue}
           var rest$21=fmt$0[2],match$5=_h8_[1],fmt$11=match$5[1];
           check_char(ib,64);
           check_char(ib,91);
           var fmt$12=concat_fmt(fmt$11,rest$21),fmt$0=fmt$12;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           if(readers)
            {var
              readers_rest=readers[2],
              reader=readers[1],
              x=caml_call1(reader,ib);
             return [0,x,make_scanf(ib,fmt_rest,readers_rest)]}
           return invalid_arg(cst_scanf_missing_reader);
          case 20:
           var _h9_=fmt$0[1],_h__=fmt$0[3];
           if(typeof _h__ !== "number" && 17 === _h__[0])
            {var
              rest$23=_h__[2],
              fmting_lit$0=_h__[1],
              char_set$0=fmt$0[2],
              match$6=stopper_of_formatting_lit(fmting_lit$0),
              str$1=match$6[2],
              stp$0=match$6[1],
              width$0=width_of_pad_opt(_h9_);
             scan_chars_in_char_set(char_set$0,[0,stp$0],width$0,ib);
             var s$2=token_string(ib),str_rest$0=[11,str$1,rest$23];
             return [0,s$2,make_scanf(ib,str_rest$0,readers)]}
           var
            rest$22=fmt$0[3],
            char_set=fmt$0[2],
            width=width_of_pad_opt(_h9_);
           scan_chars_in_char_set(char_set,0,width,ib);
           var s$1=token_string(ib);
           return [0,s$1,make_scanf(ib,rest$22,readers)];
          case 21:
           var
            rest$24=fmt$0[2],
            counter=fmt$0[1],
            count=get_counter(ib,counter);
           return [0,count,make_scanf(ib,rest$24,readers)];
          case 22:
           var rest$25=fmt$0[1],c$1=checked_peek_char(ib);
           return [0,c$1,make_scanf(ib,rest$25,readers)];
          case 23:
           var
            rest$26=fmt$0[2],
            ign=fmt$0[1],
            match$7=param_format_of_ignored_format(ign,rest$26),
            fmt$13=match$7[1],
            match$8=make_scanf(ib,fmt$13,readers);
           if(match$8){var arg_rest=match$8[2];return arg_rest}
           throw [0,Assert_failure,_cA_];
          default:return invalid_arg(cst_scanf_bad_conversion_custo)}}
    function pad_prec_scanf(ib,fmt,readers,pad,prec,scan,token)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(prec)return invalid_arg(cst_scanf_bad_conversion);
          caml_call3(scan,max_int,max_int,ib);
          var x=caml_call1(token,ib);
          return [0,x,make_scanf(ib,fmt,readers)]}
        var p=prec[1];
        caml_call3(scan,max_int,p,ib);
        var x$0=caml_call1(token,ib);
        return [0,x$0,make_scanf(ib,fmt,readers)]}
      else
       {if(0 === pad[0])
         {if(pad[1])
           {var _h0_=pad[2];
            if(typeof prec === "number")
             {if(prec)return invalid_arg(cst_scanf_bad_conversion$0);
              caml_call3(scan,_h0_,max_int,ib);
              var x$1=caml_call1(token,ib);
              return [0,x$1,make_scanf(ib,fmt,readers)]}
            var p$0=prec[1];
            caml_call3(scan,_h0_,p$0,ib);
            var x$2=caml_call1(token,ib);
            return [0,x$2,make_scanf(ib,fmt,readers)]}
          return invalid_arg(cst_scanf_bad_conversion$1)}
        return invalid_arg(cst_scanf_bad_conversion$2)}}
    function kscanf(ib,ef,param)
     {var str=param[2],fmt=param[1];
      function apply(f,args)
       {var f$0=f,args$0=args;
        for(;;)
         {if(args$0)
           {var
             r=args$0[2],
             x=args$0[1],
             f$1=caml_call1(f$0,x),
             f$0=f$1,
             args$0=r;
            continue}
          return f$0}}
      function k(readers,f)
       {reset_token(ib);
        try
         {var _hZ_=[0,make_scanf(ib,fmt,readers)],_hY_=_hZ_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          var switch$0=0;
          if
           (exc[1]
            !==
            Scan_failure
            &&
            exc[1]
            !==
            Failure
            &&
            exc
            !==
            End_of_file)
           {if(exc[1] !== Invalid_argument)throw exc;
            var
             msg=exc[2],
             _hX_=
              invalid_arg
               (cat(msg,cat(cst_in_format,cat(escaped$1(str),cst$88))));
            switch$0 = 1}
          if(! switch$0)var _hX_=[1,exc];
          var _hY_=_hX_}
        if(0 === _hY_[0]){var args=_hY_[1];return apply(f,args)}
        var exc=_hY_[1];
        return caml_call2(ef,ib,exc)}
      return take_format_readers(k,fmt)}
    function bscanf(ib,fmt){return kscanf(ib,scanf_bad_input,fmt)}
    function ksscanf(s,ef,fmt){return kscanf(from_string$1(s),ef,fmt)}
    function sscanf(s,fmt)
     {return kscanf(from_string$1(s),scanf_bad_input,fmt)}
    function scanf(fmt){return kscanf(stdib,scanf_bad_input,fmt)}
    function bscanf_format(ib,format,f)
     {scan_caml_string(max_int,ib);
      var str=token_string(ib);
      try
       {var _hW_=format_of_string_format(str,format),fmt=_hW_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Failure)throw exn;
        var msg=exn[2],fmt=bad_input(msg)}
      return caml_call1(f,fmt)}
    function sscanf_format(s,format,f)
     {return bscanf_format(from_string$1(s),format,f)}
    function format_from_string(s,fmt)
     {function _hV_(x){return x}
      return sscanf_format(cat(cst$90,cat(escaped$1(s),cst$89)),fmt,_hV_)}
    function unescaped(s)
     {function _hU_(x){return x}
      return caml_call1(sscanf(cat(cst$92,cat(s,cst$91)),_cB_),_hU_)}
    function kfscanf(ic,ef,fmt){return kscanf(memo_from_channel(ic),ef,fmt)}
    function fscanf(ic,fmt)
     {return kscanf(memo_from_channel(ic),scanf_bad_input,fmt)}
    var
     Stdlib_Scanf=
      [0,
       [0,
        stdib,
        from_file,
        from_file_bin,
        close_in$0,
        from_file,
        from_file_bin,
        from_string$1,
        from_function$0,
        from_channel$0,
        end_of_input,
        beginning_of_input,
        name_of_input,
        stdib],
       Scan_failure,
       bscanf,
       sscanf,
       scanf,
       kscanf,
       ksscanf,
       bscanf_format,
       sscanf_format,
       format_from_string,
       unescaped,
       fscanf,
       kfscanf];
    caml_register_global(803,Stdlib_Scanf,"Stdlib__Scanf");
    function register(name,v){return caml_register_named_value(name,v)}
    function register_exception(name,exn)
     {var slot=caml_obj_tag(exn) === 248?exn:exn[1];
      return caml_register_named_value(name,slot)}
    var Stdlib_Callback=[0,register,register_exception];
    caml_register_global(804,Stdlib_Callback,"Stdlib__Callback");
    function copy$7(o){var o$0=o.slice();return caml_set_oo_id(o$0)}
    var params$0=[0,1,1,1,3,16],initial_object_size=2,dummy_item=0;
    function public_method_label(s)
     {var accu=[0,0],_hR_=caml_ml_string_length(s) - 1 | 0,_hQ_=0;
      if(! (_hR_ < 0))
       {var i=_hQ_;
        for(;;)
         {var _hS_=caml_string_get(s,i);
          accu[1] = (223 * accu[1] | 0) + _hS_ | 0;
          var _hT_=i + 1 | 0;
          if(_hR_ !== i){var i=_hT_;continue}
          break}}
      accu[1] = accu[1] & 2147483647;
      var tag=1073741823 < accu[1]?accu[1] + 2147483648 | 0:accu[1];
      return tag}
    function compare$13(x,y){return caml_string_compare(x,y)}
    var Vars=caml_call1(Stdlib_Map[1],[0,compare$13]);
    function compare$14(x,y){return caml_string_compare(x,y)}
    var
     Meths=caml_call1(Stdlib_Map[1],[0,compare$14]),
     compare$15=caml_int_compare,
     Labs=caml_call1(Stdlib_Map[1],[0,compare$15]),
     dummy_table=[0,0,[0,dummy_item],Meths[1],Labs[1],0,0,Vars[1],0],
     table_count=[0,0],
     dummy_met=caml_obj_block(0,0);
    function fit_size(n){return 2 < n?fit_size((n + 1 | 0) / 2 | 0) * 2 | 0:n}
    function new_table(pub_labels)
     {table_count[1]++;
      var
       len=pub_labels.length - 1,
       methods=caml_make_vect((len * 2 | 0) + 2 | 0,dummy_met);
      caml_check_bound(methods,0)[1] = len;
      var _hK_=((fit_size(len) * 32 | 0) / 8 | 0) - 1 | 0;
      caml_check_bound(methods,1)[2] = _hK_;
      var _hM_=len - 1 | 0,_hL_=0;
      if(! (_hM_ < 0))
       {var i=_hL_;
        for(;;)
         {var
           _hO_=(i * 2 | 0) + 3 | 0,
           _hN_=caml_check_bound(pub_labels,i)[1 + i];
          caml_check_bound(methods,_hO_)[1 + _hO_] = _hN_;
          var _hP_=i + 1 | 0;
          if(_hM_ !== i){var i=_hP_;continue}
          break}}
      return [0,initial_object_size,methods,Meths[1],Labs[1],0,0,Vars[1],0]}
    function resize$1(array,new_size)
     {var old_size=array[2].length - 1,_hI_=old_size < new_size?1:0;
      if(_hI_)
       {var new_buck=caml_make_vect(new_size,dummy_met);
        blit$1(array[2],0,new_buck,0,old_size);
        array[2] = new_buck;
        var _hJ_=0}
      else
       var _hJ_=_hI_;
      return _hJ_}
    var method_count=[0,0],inst_var_count=[0,0];
    function new_method(table)
     {var index=table[2].length - 1;
      resize$1(table,index + 1 | 0);
      return index}
    function get_method_label(table,name)
     {try
       {var _hG_=caml_call2(Meths[28],name,table[3]);return _hG_}
      catch(_hH_)
       {_hH_ = caml_wrap_exception(_hH_);
        if(_hH_ === Not_found)
         {var label=new_method(table);
          table[3] = caml_call3(Meths[4],name,label,table[3]);
          table[4] = caml_call3(Labs[4],label,1,table[4]);
          return label}
        throw _hH_}}
    function get_method_labels(table,names)
     {return map$6(function(_hF_){return get_method_label(table,_hF_)},names)}
    function set_method(table,label,element)
     {method_count[1]++;
      return caml_call2(Labs[28],label,table[4])
              ?(resize$1(table,label + 1 | 0),
                caml_check_bound(table[2],label)[1 + label]
                =
                element,
                0)
              :(table[6] = [0,[0,label,element],table[6]],0)}
    function get_method(table,label)
     {try
       {var _hD_=assoc(label,table[6]);return _hD_}
      catch(_hE_)
       {_hE_ = caml_wrap_exception(_hE_);
        if(_hE_ === Not_found)
         return caml_check_bound(table[2],label)[1 + label];
        throw _hE_}}
    function to_list$3(arr){return 0 === arr?0:to_list$1(arr)}
    function narrow(table,vars,virt_meths,concr_meths)
     {var
       vars$0=to_list$3(vars),
       virt_meths$0=to_list$3(virt_meths),
       concr_meths$0=to_list$3(concr_meths),
       virt_meth_labs=
        map$3
         (function(_hC_){return get_method_label(table,_hC_)},virt_meths$0),
       concr_meth_labs=
        map$3
         (function(_hB_){return get_method_label(table,_hB_)},concr_meths$0);
      table[5]
      =
      [0,
       [0,table[3],table[4],table[6],table[7],virt_meth_labs,vars$0],
       table[5]];
      var _hs_=Vars[1],_ht_=table[7];
      function _hu_(lab,info,tvars)
       {return mem(lab,vars$0)?caml_call3(Vars[4],lab,info,tvars):tvars}
      table[7] = caml_call3(Vars[13],_hu_,_ht_,_hs_);
      var by_name=[0,Meths[1]],by_label=[0,Labs[1]];
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          var _hx_=by_label[1];
          try
           {var _hz_=caml_call2(Labs[28],label,table[4]),_hy_=_hz_}
          catch(_hA_)
           {_hA_ = caml_wrap_exception(_hA_);
            if(_hA_ !== Not_found)throw _hA_;
            var _hy_=1}
          by_label[1] = caml_call3(Labs[4],label,_hy_,_hx_);
          return 0},
        concr_meths$0,
        concr_meth_labs);
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          by_label[1] = caml_call3(Labs[4],label,0,by_label[1]);
          return 0},
        virt_meths$0,
        virt_meth_labs);
      table[3] = by_name[1];
      table[4] = by_label[1];
      var _hv_=0,_hw_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meth_labs)?hm:[0,met,hm]},
        _hw_,
        _hv_);
      return 0}
    function widen(table)
     {var
       match=hd(table[5]),
       vars=match[6],
       virt_meths=match[5],
       saved_vars=match[4],
       saved_hidden_meths=match[3],
       by_label=match[2],
       by_name=match[1];
      table[5] = tl(table[5]);
      table[7]
      =
      fold_left$0
       (function(s,v)
         {var _hr_=caml_call2(Vars[28],v,table[7]);
          return caml_call3(Vars[4],v,_hr_,s)},
        saved_vars,
        vars);
      table[3] = by_name;
      table[4] = by_label;
      var _hq_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meths)?hm:[0,met,hm]},
        _hq_,
        saved_hidden_meths);
      return 0}
    function new_slot(table)
     {var index=table[1];table[1] = index + 1 | 0;return index}
    function new_variable(table,name)
     {try
       {var _ho_=caml_call2(Vars[28],name,table[7]);return _ho_}
      catch(_hp_)
       {_hp_ = caml_wrap_exception(_hp_);
        if(_hp_ === Not_found)
         {var index=new_slot(table);
          if(caml_string_notequal(name,cst$93))
           table[7] = caml_call3(Vars[4],name,index,table[7]);
          return index}
        throw _hp_}}
    function to_array(arr){return caml_equal(arr,0)?[0]:arr}
    function new_methods_variables(table,meths,vals)
     {var
       meths$0=to_array(meths),
       nmeths=meths$0.length - 1,
       nvals=vals.length - 1,
       res=caml_make_vect(nmeths + nvals | 0,0),
       _hg_=nmeths - 1 | 0,
       _hf_=0;
      if(! (_hg_ < 0))
       {var i$0=_hf_;
        for(;;)
         {var
           _hm_=
            get_method_label(table,caml_check_bound(meths$0,i$0)[1 + i$0]);
          caml_check_bound(res,i$0)[1 + i$0] = _hm_;
          var _hn_=i$0 + 1 | 0;
          if(_hg_ !== i$0){var i$0=_hn_;continue}
          break}}
      var _hi_=nvals - 1 | 0,_hh_=0;
      if(! (_hi_ < 0))
       {var i=_hh_;
        for(;;)
         {var
           _hk_=i + nmeths | 0,
           _hj_=new_variable(table,caml_check_bound(vals,i)[1 + i]);
          caml_check_bound(res,_hk_)[1 + _hk_] = _hj_;
          var _hl_=i + 1 | 0;
          if(_hi_ !== i){var i=_hl_;continue}
          break}}
      return res}
    function get_variable(table,name)
     {try
       {var _hd_=caml_call2(Vars[28],name,table[7]);return _hd_}
      catch(_he_)
       {_he_ = caml_wrap_exception(_he_);
        if(_he_ === Not_found)throw [0,Assert_failure,_cC_];
        throw _he_}}
    function get_variables(table,names)
     {return map$6(function(_hc_){return get_variable(table,_hc_)},names)}
    function add_initializer(table,f){table[8] = [0,f,table[8]];return 0}
    function create_table(public_methods)
     {if(0 === public_methods)return new_table([0]);
      var
       tags=map$6(public_method_label,public_methods),
       table=new_table(tags);
      iteri$2
       (function(i,met)
         {var lab=(i * 2 | 0) + 2 | 0;
          table[3] = caml_call3(Meths[4],met,lab,table[3]);
          table[4] = caml_call3(Labs[4],lab,1,table[4]);
          return 0},
        public_methods);
      return table}
    function init_class(table)
     {inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
      table[8] = rev(table[8]);
      return resize$1
              (table,
               3 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0)}
    function inherits(cla,vals,virt_meths,concr_meths,param,top)
     {var env=param[4],super$0=param[2];
      narrow(cla,vals,virt_meths,concr_meths);
      var init=top?caml_call2(super$0,cla,env):caml_call1(super$0,cla);
      widen(cla);
      var
       _g9_=0,
       _g__=to_array(concr_meths),
       _g$_=
        [0,
         map$6
          (function(nm){return get_method(cla,get_method_label(cla,nm))},_g__),
         _g9_],
       _ha_=to_array(vals);
      return caml_array_concat
              ([0,
                [0,init],
                [0,
                 map$6(function(_hb_){return get_variable(cla,_hb_)},_ha_),
                 _g$_]])}
    function make_class(pub_meths,class_init)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      return [0,caml_call1(env_init,0),class_init,env_init,0]}
    function make_class_store(pub_meths,class_init,init_table)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      init_table[2] = class_init;
      init_table[1] = env_init;
      return 0}
    function dummy_class(loc)
     {function undef(param){throw [0,Undefined_recursive_module,loc]}
      return [0,undef,undef,undef,0]}
    function create_object(table)
     {var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function create_object_opt(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function iter_f(obj,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],f=param$0[1];
          caml_call1(f,obj);
          var param$0=l;
          continue}
        return 0}}
    function run_initializers(obj,table)
     {var inits=table[8],_g8_=0 !== inits?1:0;
      return _g8_?iter_f(obj,inits):_g8_}
    function run_initializers_opt(obj_0,obj,table)
     {if(obj_0)return obj;
      var inits=table[8];
      if(0 !== inits)iter_f(obj,inits);
      return obj}
    function create_object_and_run_initiali(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=create_object(table);
      run_initializers(obj,table);
      return obj}
    function get_data$0(param)
     {if(param)return param[2];throw [0,Assert_failure,_cG_]}
    function build_path(n,keys,tables)
     {var res=[0,0,0,0],r=[0,res],_g4_=0;
      if(! (n < 0))
       {var i=_g4_;
        for(;;)
         {var _g6_=r[1];
          r[1] = [0,caml_check_bound(keys,i)[1 + i],_g6_,0];
          var _g7_=i + 1 | 0;
          if(n !== i){var i=_g7_;continue}
          break}}
      var _g5_=r[1];
      if(tables){tables[2] = _g5_;return res}
      throw [0,Assert_failure,_cD_]}
    function lookup_tables(root,keys)
     {var tables$2=get_data$0(root);
      if(tables$2)
       {var i$1=keys.length - 1 - 1 | 0,i=i$1,tables=tables$2;
        a:
        for(;;)
         {if(0 <= i)
           {var key=caml_check_bound(keys,i)[1 + i],tables$0=tables;
            for(;;)
             {if(tables$0)
               {if(tables$0[1] === key)
                 {var tables$1=get_data$0(tables$0);
                  if(tables$1)
                   {var i$0=i - 1 | 0,i=i$0,tables=tables$1;continue a}
                  throw [0,Assert_failure,_cI_]}
                if(tables$0)
                 {var _g3_=tables$0[3];
                  if(_g3_){var tables$0=_g3_;continue}
                  var v=[0,key,0,0];
                  if(tables$0)
                   {tables$0[3] = v;return build_path(i - 1 | 0,keys,v)}
                  throw [0,Assert_failure,_cE_]}
                throw [0,Assert_failure,_cH_]}
              throw [0,Assert_failure,_cF_]}}
          return tables}}
      return build_path(keys.length - 1 - 1 | 0,keys,root)}
    function new_cache(table)
     {var n=new_method(table),switch$0=0;
      if
       (0
        !==
        (n % 2 | 0)
        &&
        !
        ((2 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0) < n))
       {var n$0=new_method(table);switch$0 = 1}
      if(! switch$0)var n$0=n;
      caml_check_bound(table[2],n$0)[1 + n$0] = 0;
      return n$0}
    function set_methods(table,methods)
     {var len=methods.length - 1,i=[0,0];
      for(;;)
       {if(i[1] < len)
         {var
           _gX_=i[1],
           label=caml_check_bound(methods,_gX_)[1 + _gX_],
           next=
            function(param)
             {i[1]++;
              var _g2_=i[1];
              return caml_check_bound(methods,_g2_)[1 + _g2_]},
           clo=next(0);
          if(typeof clo === "number")
           switch(clo)
            {case 0:
              var
               x=next(0),
               clo$0=function(x){return function(obj){return x}}(x);
              break;
             case 1:
              var
               n=next(0),
               clo$0=function(n){return function(obj){return obj[1 + n]}}(n);
              break;
             case 2:
              var
               e=next(0),
               n$0=next(0),
               clo$0=
                function(e,n){return function(obj){return obj[1 + e][1 + n]}}
                 (e,n$0);
              break;
             case 3:
              var
               n$1=next(0),
               clo$0=
                function(n)
                  {return function(obj){return caml_call1(obj[1][1 + n],obj)}}
                 (n$1);
              break;
             case 4:
              var
               n$2=next(0),
               clo$0=
                function(n){return function(obj,x){obj[1 + n] = x;return 0}}
                 (n$2);
              break;
             case 5:
              var
               f=next(0),
               x$0=next(0),
               clo$0=
                function(f,x){return function(obj){return caml_call1(f,x)}}
                 (f,x$0);
              break;
             case 6:
              var
               f$0=next(0),
               n$3=next(0),
               clo$0=
                function(f,n)
                  {return function(obj){return caml_call1(f,obj[1 + n])}}
                 (f$0,n$3);
              break;
             case 7:
              var
               f$1=next(0),
               e$0=next(0),
               n$4=next(0),
               clo$0=
                function(f,e,n)
                  {return function(obj)
                    {return caml_call1(f,obj[1 + e][1 + n])}}
                 (f$1,e$0,n$4);
              break;
             case 8:
              var
               f$2=next(0),
               n$5=next(0),
               clo$0=
                function(f,n)
                  {return function(obj)
                    {return caml_call1(f,caml_call1(obj[1][1 + n],obj))}}
                 (f$2,n$5);
              break;
             case 9:
              var
               f$3=next(0),
               x$1=next(0),
               y=next(0),
               clo$0=
                function(f,x,y)
                  {return function(obj){return caml_call2(f,x,y)}}
                 (f$3,x$1,y);
              break;
             case 10:
              var
               f$4=next(0),
               x$2=next(0),
               n$6=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj){return caml_call2(f,x,obj[1 + n])}}
                 (f$4,x$2,n$6);
              break;
             case 11:
              var
               f$5=next(0),
               x$3=next(0),
               e$1=next(0),
               n$7=next(0),
               clo$0=
                function(f,x,e,n)
                  {return function(obj)
                    {return caml_call2(f,x,obj[1 + e][1 + n])}}
                 (f$5,x$3,e$1,n$7);
              break;
             case 12:
              var
               f$6=next(0),
               x$4=next(0),
               n$8=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj)
                    {return caml_call2(f,x,caml_call1(obj[1][1 + n],obj))}}
                 (f$6,x$4,n$8);
              break;
             case 13:
              var
               f$7=next(0),
               n$9=next(0),
               x$5=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj){return caml_call2(f,obj[1 + n],x)}}
                 (f$7,n$9,x$5);
              break;
             case 14:
              var
               f$8=next(0),
               e$2=next(0),
               n$10=next(0),
               x$6=next(0),
               clo$0=
                function(f,e,n,x)
                  {return function(obj)
                    {return caml_call2(f,obj[1 + e][1 + n],x)}}
                 (f$8,e$2,n$10,x$6);
              break;
             case 15:
              var
               f$9=next(0),
               n$11=next(0),
               x$7=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj)
                    {return caml_call2(f,caml_call1(obj[1][1 + n],obj),x)}}
                 (f$9,n$11,x$7);
              break;
             case 16:
              var
               n$12=next(0),
               x$8=next(0),
               clo$0=
                function(n,x)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,x)}}
                 (n$12,x$8);
              break;
             case 17:
              var
               n$13=next(0),
               m=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + m])}}
                 (n$13,m);
              break;
             case 18:
              var
               n$14=next(0),
               e$3=next(0),
               m$0=next(0),
               clo$0=
                function(n,e,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + e][1 + m])}}
                 (n$14,e$3,m$0);
              break;
             case 19:
              var
               n$15=next(0),
               m$1=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {var _g0_=caml_call1(obj[1][1 + m],obj);
                     return caml_call2(obj[1][1 + n],obj,_g0_)}}
                 (n$15,m$1);
              break;
             case 20:
              var m$2=next(0),x$9=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,x)
                  {return function(obj)
                    {return caml_call1(caml_get_public_method(x,m,0),x)}}
                 (m$2,x$9);
              break;
             case 21:
              var m$3=next(0),n$16=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,n)
                  {return function(obj)
                    {var _gZ_=obj[1 + n];
                     return caml_call1(caml_get_public_method(_gZ_,m,0),_gZ_)}}
                 (m$3,n$16);
              break;
             case 22:
              var m$4=next(0),e$4=next(0),n$17=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,e,n)
                  {return function(obj)
                    {var _gY_=obj[1 + e][1 + n];
                     return caml_call1(caml_get_public_method(_gY_,m,0),_gY_)}}
                 (m$4,e$4,n$17);
              break;
             default:
              var m$5=next(0),n$18=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,n)
                  {return function(obj)
                    {var _g1_=caml_call1(obj[1][1 + n],obj);
                     return caml_call1(caml_get_public_method(_g1_,m,0),_g1_)}}
                 (m$5,n$18)}
          else
           var clo$0=clo;
          set_method(table,label,clo$0);
          i[1]++;
          continue}
        return 0}}
    function stats$0(param)
     {return [0,table_count[1],method_count[1],inst_var_count[1]]}
    var
     CamlinternalOO=
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy$7,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initiali,
       lookup_tables,
       params$0,
       stats$0];
    caml_register_global(805,CamlinternalOO,"CamlinternalOO");
    var Stdlib_Oo=[0,copy$7,public_method_label,public_method_label];
    caml_register_global(806,Stdlib_Oo,"Stdlib__Oo");
    function init_mod_block(loc,comps$0)
     {var
       length=comps$0.length - 1,
       modu=caml_obj_block(0,length),
       _gT_=length - 1 | 0,
       _gS_=0;
      if(! (_gT_ < 0))
       {var i=_gS_;
        for(;;)
         {var shape=caml_check_bound(comps$0,i)[1 + i];
          if(typeof shape === "number")
           switch(shape)
            {case 0:
              var
               fn$0=
                function(i)
                 {function fn(x)
                   {var fn$0=modu[1 + i];
                    if(fn === fn$0)throw [0,Undefined_recursive_module,loc];
                    return caml_call1(fn$0,x)}
                  return fn},
               fn=fn$0(i),
               init=fn;
              break;
             case 1:
              var l=[];
              runtime.caml_update_dummy
               (l,
                [246,
                 function(l,i)
                   {return function(_gV_)
                     {var l$0=modu[1 + i];
                      if(l === l$0)throw [0,Undefined_recursive_module,loc];
                      var _gW_=caml_obj_tag(l$0);
                      return 250 === _gW_
                              ?l$0[1]
                              :246 === _gW_?force_lazy_block(l$0):l$0}}
                  (l,i)]);
              var init=l;
              break;
             default:var init=dummy_class(loc)}
          else
           if(0 === shape[0])
            var comps=shape[1],init=init_mod_block(loc,comps);
           else
            var v=shape[1],init=v;
          modu[1 + i] = init;
          var _gU_=i + 1 | 0;
          if(_gT_ !== i){var i=_gU_;continue}
          break}}
      return modu}
    function init_mod(loc,shape)
     {if(typeof shape !== "number" && 0 === shape[0])
       {var comps=shape[1];return init_mod_block(loc,comps)}
      return failwith(cst_CamlinternalMod_init_mod_n)}
    function update_mod_block(comps$0,o,n)
     {if(0 === caml_obj_tag(n) && comps$0.length - 1 <= n.length - 1)
       {var _gQ_=comps$0.length - 1 - 1 | 0,_gP_=0;
        if(! (_gQ_ < 0))
         {var i=_gP_;
          for(;;)
           {var n$0=n[1 + i],shape=caml_check_bound(comps$0,i)[1 + i];
            if(typeof shape === "number")
             if(2 === shape)
              {var switch$0=0;
               if(0 === caml_obj_tag(n$0) && 4 === n$0.length - 1)
                {var cl=o[1 + i],j=0;
                 for(;;)
                  {cl[1 + j] = n$0[1 + j];
                   var _gO_=j + 1 | 0;
                   if(3 !== j){var j=_gO_;continue}
                   break}}
               else
                switch$0 = 1;
               if(switch$0)throw [0,Assert_failure,_cJ_]}
             else
              o[1 + i] = n$0;
            else
             if(0 === shape[0])
              {var comps=shape[1];update_mod_block(comps,o[1 + i],n$0)}
            var _gR_=i + 1 | 0;
            if(_gQ_ !== i){var i=_gR_;continue}
            break}}
        return 0}
      throw [0,Assert_failure,_cK_]}
    function update_mod(shape,o,n)
     {if(typeof shape !== "number" && 0 === shape[0])
       {var comps=shape[1];return update_mod_block(comps,o,n)}
      return failwith(cst_CamlinternalMod_update_mod)}
    var CamlinternalMod=[0,init_mod,update_mod];
    caml_register_global(807,CamlinternalMod,"CamlinternalMod");
    var
     initial_buffer=caml_create_bytes(32),
     buffer=[0,initial_buffer],
     bufpos=[0,0];
    function reset_buffer(param)
     {buffer[1] = initial_buffer;bufpos[1] = 0;return 0}
    function store(c)
     {if(caml_ml_bytes_length(buffer[1]) <= bufpos[1])
       {var newbuffer=caml_create_bytes(2 * bufpos[1] | 0);
        blit(buffer[1],0,newbuffer,0,bufpos[1]);
        buffer[1] = newbuffer}
      caml_bytes_set(buffer[1],bufpos[1],c);
      bufpos[1]++;
      return 0}
    function get_string(param)
     {var s=sub_string(buffer[1],0,bufpos[1]);
      buffer[1] = initial_buffer;
      return s}
    function make_lexer(keywords)
     {var kwd_table=caml_call2(Stdlib_Hashtbl[1],0,17);
      iter$2
       (function(s){return caml_call3(Stdlib_Hashtbl[5],kwd_table,s,[0,s])},
        keywords);
      function ident_or_keyword(id)
       {try
         {var _gM_=caml_call2(Stdlib_Hashtbl[6],kwd_table,id);return _gM_}
        catch(_gN_)
         {_gN_ = caml_wrap_exception(_gN_);
          if(_gN_ === Not_found)return [1,id];
          throw _gN_}}
      function keyword_or_error(c)
       {var s=make$1(1,c);
        try
         {var _gK_=caml_call2(Stdlib_Hashtbl[6],kwd_table,s);return _gK_}
        catch(_gL_)
         {_gL_ = caml_wrap_exception(_gL_);
          if(_gL_ === Not_found)throw [0,Error,cat(cst_Illegal_character,s)];
          throw _gL_}}
      function comment(strm)
       {a:
        for(;;)
         {var match=peek$0(strm);
          if(match)
           {var switcher=match[1] - 40 | 0;
            if(! (2 < switcher >>> 0))
             switch(switcher)
              {case 0:
                junk(strm);
                var match$0=peek$0(strm);
                if(match$0)
                 {if(42 === match$0[1]){junk(strm);comment(strm);continue}
                  junk(strm);
                  continue}
                throw Failure$0;
               case 1:break;
               default:
                junk(strm);
                for(;;)
                 {var match$1=peek$0(strm);
                  if(match$1)
                   {var _gJ_=match$1[1];
                    if(41 === _gJ_){junk(strm);return 0}
                    if(42 === _gJ_){junk(strm);continue}
                    junk(strm);
                    continue a}
                  throw Failure$0}}
            junk(strm);
            continue}
          throw Failure$0}}
      function escape(strm)
       {var match=peek$0(strm);
        if(match)
         {var _gG_=match[1];
          if(58 <= _gG_)
           {var switcher=_gG_ - 110 | 0;
            if(! (6 < switcher >>> 0))
             switch(switcher)
              {case 0:junk(strm);return 10;
               case 4:junk(strm);return 13;
               case 6:junk(strm);return 9
               }}
          else
           if(48 <= _gG_)
            {junk(strm);
             var match$0=peek$0(strm);
             if(match$0)
              {var _gH_=match$0[1];
               if(! (9 < _gH_ - 48 >>> 0))
                {junk(strm);
                 var match$1=peek$0(strm);
                 if(match$1)
                  {var _gI_=match$1[1];
                   if(! (9 < _gI_ - 48 >>> 0))
                    {junk(strm);
                     return chr
                             ((((_gG_ - 48 | 0) * 100 | 0)
                               +
                               ((_gH_ - 48 | 0) * 10 | 0)
                               |
                               0)
                              +
                              (_gI_ - 48 | 0)
                              |
                              0)}}
                 throw [0,Error,cst$99]}}
             throw [0,Error,cst$98]}
          junk(strm);
          return _gG_}
        throw Failure$0}
      function end_exponent_part(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gF_=match[1];
            if(! (9 < _gF_ - 48 >>> 0)){junk(strm);store(_gF_);continue}}
          return [0,[3,caml_float_of_string(get_string(0))]]}}
      function exponent_part(strm)
       {var match=peek$0(strm);
        if(match)
         {var _gE_=match[1],switch$0=0;
          if(43 !== _gE_ && 45 !== _gE_)switch$0 = 1;
          if(! switch$0)
           {junk(strm);store(_gE_);return end_exponent_part(strm)}}
        return end_exponent_part(strm)}
      function number(s)
       {for(;;)
         {var match=peek$0(s);
          if(match)
           {var _gB_=match[1];
            if(58 <= _gB_)
             {var switch$0=0;
              if(69 === _gB_ || 101 === _gB_)switch$0 = 1;
              if(switch$0){junk(s);store(69);return exponent_part(s)}}
            else
             {if(46 === _gB_)
               {junk(s);
                store(46);
                for(;;)
                 {var match$0=peek$0(s);
                  if(match$0)
                   {var _gC_=match$0[1],_gD_=_gC_ - 69 | 0;
                    if(32 < _gD_ >>> 0)
                     {if(! (9 < _gD_ + 21 >>> 0)){junk(s);store(_gC_);continue}}
                    else
                     if(30 < _gD_ - 1 >>> 0)
                      {junk(s);store(69);return exponent_part(s)}}
                  return [0,[3,caml_float_of_string(get_string(0))]]}}
              if(48 <= _gB_){junk(s);store(_gB_);continue}}}
          return [0,[2,caml_int_of_string(get_string(0))]]}}
      function ident2(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gz_=match[1],switch$0=0;
            if(94 <= _gz_)
             {var _gA_=_gz_ - 95 | 0;
              if(30 < _gA_ >>> 0)
               {if(! (32 <= _gA_))switch$0 = 1}
              else
               if(29 === _gA_)switch$0 = 1}
            else
             if(65 <= _gz_)
              {if(92 === _gz_)switch$0 = 1}
             else
              if(33 <= _gz_)
               switch(_gz_ - 33 | 0)
                {case 0:
                 case 2:
                 case 3:
                 case 4:
                 case 5:
                 case 9:
                 case 10:
                 case 12:
                 case 14:
                 case 25:
                 case 27:
                 case 28:
                 case 29:
                 case 30:
                 case 31:switch$0 = 1;break
                 }
            if(switch$0){junk(strm);store(_gz_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function neg_number(s)
       {var match=peek$0(s);
        if(match)
         {var _gy_=match[1];
          if(! (9 < _gy_ - 48 >>> 0))
           {junk(s);reset_buffer(0);store(45);store(_gy_);return number(s)}}
        reset_buffer(0);
        store(45);
        return ident2(s)}
      function ident(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gw_=match[1],switch$0=0;
            if(91 <= _gw_)
             {var _gx_=_gw_ - 95 | 0;
              if(27 < _gx_ >>> 0)
               {if(97 <= _gx_)switch$0 = 1}
              else
               if(1 !== _gx_)switch$0 = 1}
            else
             if(48 <= _gw_)
              {if(6 < _gw_ - 58 >>> 0)switch$0 = 1}
             else
              if(39 === _gw_)switch$0 = 1;
            if(switch$0){junk(strm);store(_gw_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function next_token$0(counter,strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gm_=match[1],switch$0=0;
            if(124 <= _gm_)
             {if(127 <= _gm_)
               {if(192 <= _gm_)switch$0 = 1}
              else
               if(125 !== _gm_)switch$0 = 2}
            else
             {var _gn_=_gm_ - 65 | 0;
              if(57 < _gn_ >>> 0)
               {if(! (58 <= _gn_))
                 switch(_gn_ + 65 | 0)
                  {case 34:
                    junk(strm);
                    reset_buffer(0);
                    for(;;)
                     {var match$1=peek$0(strm);
                      if(match$1)
                       {var _gp_=match$1[1];
                        if(34 === _gp_){junk(strm);return [0,[4,get_string(0)]]}
                        if(92 === _gp_)
                         {junk(strm);
                          try
                           {var c$0=escape(strm)}
                          catch(_gv_)
                           {_gv_ = caml_wrap_exception(_gv_);
                            if(_gv_ === Failure$0)throw [0,Error,cst$96];
                            throw _gv_;
                            var _gs_=_gv_}
                          store(c$0);
                          continue}
                        junk(strm);
                        store(_gp_);
                        continue}
                      throw Failure$0}
                   case 39:
                    junk(strm);
                    try
                     {var match$2=peek$0(strm);
                      if(! match$2)throw Failure$0;
                      var _gq_=match$2[1];
                      if(92 === _gq_)
                       {junk(strm);
                        try
                         {var _gr_=escape(strm)}
                        catch(_gu_)
                         {_gu_ = caml_wrap_exception(_gu_);
                          if(_gu_ === Failure$0)throw [0,Error,cst$97];
                          throw _gu_}
                        var c=_gr_}
                      else
                       {junk(strm);var c=_gq_}}
                    catch(_gt_)
                     {_gt_ = caml_wrap_exception(_gt_);
                      if(_gt_ === Failure$0)throw [0,Error,cst$94];
                      throw _gt_}
                    var match$0=peek$0(strm);
                    if(match$0 && 39 === match$0[1])
                     {junk(strm);return [0,[5,c]]}
                    throw [0,Error,cst$95];
                   case 40:
                    junk(strm);
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return maybe_comment(counter$0,strm)}
                    return caml_trampoline_return(maybe_comment,[0,strm]);
                   case 45:junk(strm);return neg_number(strm);
                   case 9:
                   case 10:
                   case 12:
                   case 13:
                   case 26:
                   case 32:junk(strm);continue;
                   case 48:
                   case 49:
                   case 50:
                   case 51:
                   case 52:
                   case 53:
                   case 54:
                   case 55:
                   case 56:
                   case 57:
                    junk(strm);reset_buffer(0);store(_gm_);return number(strm);
                   case 33:
                   case 35:
                   case 36:
                   case 37:
                   case 38:
                   case 42:
                   case 43:
                   case 47:
                   case 58:
                   case 60:
                   case 61:
                   case 62:
                   case 63:
                   case 64:switch$0 = 2;break
                   }}
              else
               {var _go_=_gn_ - 26 | 0;
                if(5 < _go_ >>> 0)
                 switch$0 = 1;
                else
                 switch(_go_)
                  {case 4:switch$0 = 1;break;case 1:case 3:switch$0 = 2;break}}}
            switch(switch$0)
             {case 0:junk(strm);return [0,keyword_or_error(_gm_)];
              case 1:
               junk(strm);reset_buffer(0);store(_gm_);return ident(strm);
              default:
               junk(strm);reset_buffer(0);store(_gm_);return ident2(strm)}}
          return 0}}
      function maybe_comment(counter,strm)
       {var match=peek$0(strm);
        if(match && 42 === match[1])
         {junk(strm);
          comment(strm);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return next_token$0(counter$0,strm)}
          return caml_trampoline_return(next_token$0,[0,strm])}
        return [0,keyword_or_error(40)]}
      function next_token(strm){return caml_trampoline(next_token$0(0,strm))}
      return function(input)
       {return from(function(count){return next_token(input)})}}
    var Stdlib_Genlex=[0,make_lexer];
    caml_register_global(808,Stdlib_Genlex,"Stdlib__Genlex");
    function MakeSeeded$0(H)
     {var prng=[246,function(_gl_){return caml_call1(_cb_[2],0)}];
      function create(opt,initial_size)
       {if(opt)
         var sth=opt[1],random=sth;
        else
         var random=caml_call1(Stdlib_Hashtbl[17],0);
        var x=16;
        for(;;)
         {if(! (initial_size <= x) && ! (max_array_length < (x * 2 | 0)))
           {var x$0=x * 2 | 0,x=x$0;continue}
          if(random)
           var
            _gj_=caml_obj_tag(prng),
            _gk_=250 === _gj_?prng[1]:246 === _gj_?force_lazy_block(prng):prng,
            seed=caml_call1(_cb_[4],_gk_);
          else
           var seed=0;
          return [0,0,caml_make_vect(x,0),seed,x]}}
      function clear(h)
       {h[1] = 0;
        var len=h[2].length - 1,_gh_=len - 1 | 0,_gg_=0;
        if(! (_gh_ < 0))
         {var i=_gg_;
          for(;;)
           {caml_check_bound(h[2],i)[1 + i] = 0;
            var _gi_=i + 1 | 0;
            if(_gh_ !== i){var i=_gi_;continue}
            break}}
        return 0}
      function reset(h)
       {var len=h[2].length - 1;
        return len === h[4]
                ?clear(h)
                :(h[1] = 0,h[2] = caml_make_vect(h[4],0),0)}
      function copy(init)
       {var _gd_=init[4],_ge_=init[3],_gf_=copy$1(init[2]);
        return [0,init[1],_gf_,_ge_,_gd_]}
      function key_index(h,hkey){return hkey & (h[2].length - 1 - 1 | 0)}
      function clean(h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hkey=param$0[1],rest=param$0[3],c=param$0[2];
              if(caml_call1(H[7],c))
               {var rest$0=param$0[3],c$0=param$0[2];
                return [0,hkey,c$0,do_bucket(rest$0)]}
              h[1] = h[1] - 1 | 0;
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_ga_=d.length - 1 - 1 | 0,_f$_=0;
        if(! (_ga_ < 0))
         {var i=_f$_;
          for(;;)
           {var _gb_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _gb_;
            var _gc_=i + 1 | 0;
            if(_ga_ !== i){var i=_gc_;continue}
            break}}
        return 0}
      function resize(h)
       {var odata=h[2],osize=odata.length - 1,nsize=osize * 2 | 0;
        clean(h);
        var
         _f4_=nsize < max_array_length?1:0,
         _f5_=_f4_?(osize >>> 1 | 0) <= h[1]?1:0:_f4_;
        if(_f5_)
         {var ndata=caml_make_vect(nsize,0);
          h[2] = ndata;
          var
           insert_bucket=
            function(param)
             {if(param)
               {var rest=param[3],data=param[2],hkey=param[1];
                insert_bucket(rest);
                var
                 nidx=key_index(h,hkey),
                 _f__=[0,hkey,data,caml_check_bound(ndata,nidx)[1 + nidx]];
                caml_check_bound(ndata,nidx)[1 + nidx] = _f__;
                return 0}
              return 0},
           _f7_=osize - 1 | 0,
           _f6_=0;
          if(! (_f7_ < 0))
           {var i=_f6_;
            for(;;)
             {insert_bucket(caml_check_bound(odata,i)[1 + i]);
              var _f9_=i + 1 | 0;
              if(_f7_ !== i){var i=_f9_;continue}
              break}}
          var _f8_=0}
        else
         var _f8_=_f5_;
        return _f8_}
      function add(h,key,info)
       {var
         hkey=caml_call2(H[2],h[3],key),
         i=key_index(h,hkey),
         container=caml_call2(H[1],key,info),
         bucket=[0,hkey,container,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _f3_=h[2].length - 1 << 1 < h[1]?1:0;
        return _f3_?resize(h):_f3_}
      function remove(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function remove_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],next=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:h[1] = h[1] - 1 | 0;return next;
                  case 1:return [0,hk,c,remove_bucket(next)];
                  default:h[1] = h[1] - 1 | 0;var param$0=next;continue}}
              var next$0=param$0[3],c$0=param$0[2];
              return [0,hk,c$0,remove_bucket(next$0)]}
            return 0}}
        var
         i=key_index(h,hkey),
         _f2_=remove_bucket(caml_check_bound(h[2],i)[1 + i]);
        caml_check_bound(h[2],i)[1 + i] = _f2_;
        return 0}
      function find(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _f1_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_f1_)[1 + _f1_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var match$0=caml_call1(H[4],c);
                 if(match$0){var d=match$0[1];return d}
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param$0=param[3],param=param$0;
            continue}
          throw Not_found}}
      function find_opt(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _f0_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_f0_)[1 + _f0_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var d=caml_call1(H[4],c);
                 if(d)return d;
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param$0=param[3],param=param$0;
            continue}
          return 0}}
      function find_all(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],rest=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:
                   var match$0=caml_call1(H[4],c);
                   if(match$0)
                    {var d=match$0[1];return [0,d,find_in_bucket(rest)]}
                   var param$0=rest;
                   continue;
                  case 1:var param$0=rest;continue;
                  default:var param$0=rest;continue}}
              var param$1=param$0[3],param$0=param$1;
              continue}
            return 0}}
        var _fZ_=key_index(h,hkey);
        return find_in_bucket(caml_check_bound(h[2],_fZ_)[1 + _fZ_])}
      function replace(h,key,info)
       {var hkey=caml_call2(H[2],h[3],key);
        function replace_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],next=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                if(match){var param$0=next;continue}
                return caml_call3(H[6],c,key,info)}
              var param$1=param$0[3],param$0=param$1;
              continue}
            throw Not_found}}
        var i=key_index(h,hkey),l=caml_check_bound(h[2],i)[1 + i];
        try
         {var _fX_=replace_bucket(l);return _fX_}
        catch(_fY_)
         {_fY_ = caml_wrap_exception(_fY_);
          if(_fY_ === Not_found)
           {var container=caml_call2(H[1],key,info);
            caml_check_bound(h[2],i)[1 + i] = [0,hkey,container,l];
            h[1] = h[1] + 1 | 0;
            var _fW_=h[2].length - 1 << 1 < h[1]?1:0;
            return _fW_?resize(h):_fW_}
          throw _fY_}}
      function mem(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _fV_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_fV_)[1 + _fV_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hk === hkey)
             {var match=caml_call2(H[3],c,key);
              if(match){var param=rest;continue}
              return 1}
            var param$0=param[3],param=param$0;
            continue}
          return 0}}
      function iter$0(f,h)
       {var d$0=h[2],_fT_=d$0.length - 1 - 1 | 0,_fS_=0;
        if(! (_fT_ < 0))
         {var i=_fS_;
          a:
          for(;;)
           {var param$0=caml_check_bound(d$0,i)[1 + i],param=param$0;
            for(;;)
             {if(param)
               {var
                 rest=param[3],
                 c=param[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c),
                 switch$0=0;
                if(match && match$0)
                 {var d=match$0[1],k=match[1];caml_call2(f,k,d);switch$0 = 1}
                var param=rest;
                continue}
              var _fU_=i + 1 | 0;
              if(_fT_ !== i){var i=_fU_;continue a}
              break}
            break}}
        return 0}
      function fold(f,h,init)
       {var d$0=h[2],accu$1=[0,init],_fP_=d$0.length - 1 - 1 | 0,_fO_=0;
        if(! (_fP_ < 0))
         {var i=_fO_;
          a:
          for(;;)
           {var
             _fQ_=accu$1[1],
             b$0=caml_check_bound(d$0,i)[1 + i],
             b=b$0,
             accu=_fQ_;
            for(;;)
             {if(b)
               {var
                 rest=b[3],
                 c=b[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c),
                 switch$0=0;
                if(match && match$0)
                 {var d=match$0[1],k=match[1],accu$0=caml_call3(f,k,d,accu);
                  switch$0 = 1}
                if(! switch$0)var accu$0=accu;
                var b=rest,accu=accu$0;
                continue}
              accu$1[1] = accu;
              var _fR_=i + 1 | 0;
              if(_fP_ !== i){var i=_fR_;continue a}
              break}
            break}}
        return accu$1[1]}
      function filter_map_inplace(f,h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               rest=param$0[3],
               c=param$0[2],
               hk=param$0[1],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match && match$0)
               {var d=match$0[1],k=match[1],match$1=caml_call2(f,k,d);
                if(match$1)
                 {var new_d=match$1[1];
                  caml_call3(H[6],c,k,new_d);
                  return [0,hk,c,do_bucket(rest)]}
                var param$0=rest;
                continue}
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_fL_=d.length - 1 - 1 | 0,_fK_=0;
        if(! (_fL_ < 0))
         {var i=_fK_;
          for(;;)
           {var _fM_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _fM_;
            var _fN_=i + 1 | 0;
            if(_fL_ !== i){var i=_fN_;continue}
            break}}
        return 0}
      function length(h){return h[1]}
      function bucket_length(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             param$1=param$0[3],
             accu$1=accu$0 + 1 | 0,
             accu$0=accu$1,
             param$0=param$1;
            continue}
          return accu$0}}
      function stats(h)
       {var
         _fG_=h[2],
         _fH_=0,
         mbl=
          fold_left$3
           (function(m,b){return max$1(m,bucket_length(0,b))},_fH_,_fG_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _fI_=h[2];
        iter$5
         (function(b)
           {var
             l=bucket_length(0,b),
             _fJ_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
            caml_check_bound(histo,l)[1 + l] = _fJ_;
            return 0},
          _fI_);
        return [0,h[1],h[2].length - 1,mbl,histo]}
      function bucket_length_alive(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var rest=param$0[3],c=param$0[2];
            if(caml_call1(H[7],c))
             {var accu$1=accu$0 + 1 | 0,accu$0=accu$1,param$0=rest;continue}
            var param$1=param$0[3],param$0=param$1;
            continue}
          return accu$0}}
      function stats_alive(h)
       {var
         size=[0,0],
         _fC_=h[2],
         _fD_=0,
         mbl=
          fold_left$3
           (function(m,b){return max$1(m,bucket_length_alive(0,b))},_fD_,_fC_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _fE_=h[2];
        iter$5
         (function(b)
           {var l=bucket_length_alive(0,b);
            size[1] = size[1] + l | 0;
            var _fF_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
            caml_check_bound(histo,l)[1 + l] = _fF_;
            return 0},
          _fE_);
        return [0,size[1],h[2].length - 1,mbl,histo]}
      function to_seq(tbl)
       {var tbl_data=tbl[2];
        function aux(i,buck,param)
         {var i$0=i,buck$0=buck;
          for(;;)
           {if(buck$0)
             {var
               next=buck$0[3],
               c=buck$0[2],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match && match$0)
               {var data=match$0[1],key=match[1];
                return [0,
                        [0,key,data],
                        function(_fB_){return aux(i$0,next,_fB_)}]}
              var buck$0=next;
              continue}
            if(i$0 === tbl_data.length - 1)return 0;
            var
             buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
             i$1=i$0 + 1 | 0,
             i$0=i$1,
             buck$0=buck$1;
            continue}}
        var _fy_=0,_fz_=0;
        return function(_fA_){return aux(_fz_,_fy_,_fA_)}}
      function to_seq_keys(m)
       {var _fu_=to_seq(m);
        function _fv_(_fx_){return _fx_[1]}
        return function(_fw_){return map(_fv_,_fu_,_fw_)}}
      function to_seq_values(m)
       {var _fq_=to_seq(m);
        function _fr_(_ft_){return _ft_[2]}
        return function(_fs_){return map(_fr_,_fq_,_fs_)}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$0,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$5(param){return caml_call1(_t_[1],1)}
    function get_key$0(t){return caml_call2(_t_[3],t,0)}
    function get_key_copy$0(t){return caml_call2(_t_[4],t,0)}
    function set_key$0(t,k){return caml_call3(_t_[5],t,0,k)}
    function unset_key$0(t){return caml_call2(_t_[6],t,0)}
    function check_key$0(t){return caml_call2(_t_[7],t,0)}
    function blit_key$0(t1,t2){return caml_call5(_t_[8],t1,0,t2,0,1)}
    function get_data$1(t){return caml_call1(_t_[9],t)}
    function get_data_copy(t){return caml_call1(_t_[10],t)}
    function set_data(t,d){return caml_call2(_t_[11],t,d)}
    function unset_data(t){return caml_call1(_t_[12],t)}
    function check_data(t){return caml_call1(_t_[13],t)}
    function blit_data(t1,t2){return caml_call2(_t_[14],t1,t2)}
    function MakeSeeded$1(H)
     {function create(k,d)
       {var c=create$5(0);set_data(c,d);set_key$0(c,k);return c}
      var hash=H[2];
      function equal(c,k)
       {var match=get_key$0(c);
        if(match){var k$0=match[1];return caml_call2(H[1],k,k$0)?0:1}
        return 2}
      function set_key_data(c,k,d)
       {unset_data(c);set_key$0(c,k);return set_data(c,d)}
      return MakeSeeded$0
              ([0,
                create,
                hash,
                equal,
                get_data$1,
                get_key$0,
                set_key_data,
                check_key$0])}
    function Make$2(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$1([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _fp_=include[1];
      function create(sz){return caml_call2(_fp_,_cL_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$6(param){return caml_call1(_t_[1],2)}
    function get_key1(t){return caml_call2(_t_[3],t,0)}
    function get_key1_copy(t){return caml_call2(_t_[4],t,0)}
    function set_key1(t,k){return caml_call3(_t_[5],t,0,k)}
    function unset_key1(t){return caml_call2(_t_[6],t,0)}
    function check_key1(t){return caml_call2(_t_[7],t,0)}
    function get_key2(t){return caml_call2(_t_[3],t,1)}
    function get_key2_copy(t){return caml_call2(_t_[4],t,1)}
    function set_key2(t,k){return caml_call3(_t_[5],t,1,k)}
    function unset_key2(t){return caml_call2(_t_[6],t,1)}
    function check_key2(t){return caml_call2(_t_[7],t,1)}
    function blit_key1(t1,t2){return caml_call5(_t_[8],t1,0,t2,0,1)}
    function blit_key2(t1,t2){return caml_call5(_t_[8],t1,1,t2,1,1)}
    function blit_key12(t1,t2){return caml_call5(_t_[8],t1,0,t2,0,2)}
    function get_data$2(t){return caml_call1(_t_[9],t)}
    function get_data_copy$0(t){return caml_call1(_t_[10],t)}
    function set_data$0(t,d){return caml_call2(_t_[11],t,d)}
    function unset_data$0(t){return caml_call1(_t_[12],t)}
    function check_data$0(t){return caml_call1(_t_[13],t)}
    function blit_data$0(t1,t2){return caml_call2(_t_[14],t1,t2)}
    function MakeSeeded$2(H1,H2)
     {function create(param,d)
       {var k2=param[2],k1=param[1],c=create$6(0);
        set_data$0(c,d);
        set_key1(c,k1);
        set_key2(c,k2);
        return c}
      function hash(seed,param)
       {var
         k2=param[2],
         k1=param[1],
         _fo_=caml_call2(H2[2],seed,k2) * 65599 | 0;
        return caml_call2(H1[2],seed,k1) + _fo_ | 0}
      function equal(c,param)
       {var k2=param[2],k1=param[1],match=get_key1(c),match$0=get_key2(c);
        if(match && match$0)
         {var k2$0=match$0[1],k1$0=match[1];
          if(caml_call2(H1[1],k1,k1$0) && caml_call2(H2[1],k2,k2$0))return 0;
          return 1}
        return 2}
      function get_key(c)
       {var match=get_key1(c),match$0=get_key2(c);
        if(match && match$0)
         {var k2=match$0[1],k1=match[1];return [0,[0,k1,k2]]}
        return 0}
      function set_key_data(c,param,d)
       {var k2=param[2],k1=param[1];
        unset_data$0(c);
        set_key1(c,k1);
        set_key2(c,k2);
        return set_data$0(c,d)}
      function check_key(c)
       {var _fn_=check_key1(c);return _fn_?check_key2(c):_fn_}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$2,get_key,set_key_data,check_key])}
    function Make$3(H1,H2)
     {var equal=H2[1];
      function hash(seed,x){return caml_call1(H2[2],x)}
      var equal$0=H1[1],_fl_=[0,equal,hash];
      function hash$0(seed,x){return caml_call1(H1[2],x)}
      var
       include=MakeSeeded$2([0,equal$0,hash$0],_fl_),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _fm_=include[1];
      function create(sz){return caml_call2(_fm_,_cM_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$7(n){return caml_call1(_t_[1],n)}
    function length$6(k){return caml_call1(_t_[2],k)}
    function get_key$1(t,n){return caml_call2(_t_[3],t,n)}
    function get_key_copy$1(t,n){return caml_call2(_t_[4],t,n)}
    function set_key$1(t,n,k){return caml_call3(_t_[5],t,n,k)}
    function unset_key$1(t,n){return caml_call2(_t_[6],t,n)}
    function check_key$1(t,n){return caml_call2(_t_[7],t,n)}
    function blit_key$1(t1,o1,t2,o2,l)
     {return caml_call5(_t_[8],t1,o1,t2,o2,l)}
    function get_data$3(t){return caml_call1(_t_[9],t)}
    function get_data_copy$1(t){return caml_call1(_t_[10],t)}
    function set_data$1(t,d){return caml_call2(_t_[11],t,d)}
    function unset_data$1(t){return caml_call1(_t_[12],t)}
    function check_data$1(t){return caml_call1(_t_[13],t)}
    function blit_data$1(t1,t2){return caml_call2(_t_[14],t1,t2)}
    function MakeSeeded$3(H)
     {function create(k,d)
       {var c=create$7(k.length - 1);
        set_data$1(c,d);
        var _fj_=k.length - 1 - 1 | 0,_fi_=0;
        if(! (_fj_ < 0))
         {var i=_fi_;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[1 + i]);
            var _fk_=i + 1 | 0;
            if(_fj_ !== i){var i=_fk_;continue}
            break}}
        return c}
      function hash(seed,k)
       {var h=[0,0],_fe_=k.length - 1 - 1 | 0,_fd_=0;
        if(! (_fe_ < 0))
         {var i=_fd_;
          for(;;)
           {var _ff_=h[1],_fg_=caml_check_bound(k,i)[1 + i];
            h[1] = (caml_call2(H[2],seed,_fg_) * 65599 | 0) + _ff_ | 0;
            var _fh_=i + 1 | 0;
            if(_fe_ !== i){var i=_fh_;continue}
            break}}
        return h[1]}
      function equal(c,k)
       {var len=k.length - 1,len$0=length$6(c);
        if(len !== len$0)return 1;
        var i$1=len - 1 | 0,i=i$1;
        for(;;)
         {if(0 <= i)
           {var match=get_key$1(c,i);
            if(match)
             {var ki=match[1],_fc_=caml_check_bound(k,i)[1 + i];
              if(caml_call2(H[1],_fc_,ki)){var i$0=i - 1 | 0,i=i$0;continue}
              return 1}
            return 2}
          return 0}}
      function get_key(c)
       {var len=length$6(c);
        if(0 === len)return [0,[0]];
        var match=get_key$1(c,0);
        if(match)
         {var k0=match[1],a=caml_make_vect(len,k0),i$1=len - 1 | 0,i=i$1;
          for(;;)
           {if(1 <= i)
             {var match$0=get_key$1(c,i);
              if(match$0)
               {var ki=match$0[1];
                caml_check_bound(a,i)[1 + i] = ki;
                var i$0=i - 1 | 0,i=i$0;
                continue}
              return 0}
            return [0,a]}}
        return 0}
      function set_key_data(c,k,d)
       {unset_data$1(c);
        var _fa_=k.length - 1 - 1 | 0,_e$_=0;
        if(! (_fa_ < 0))
         {var i=_e$_;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[1 + i]);
            var _fb_=i + 1 | 0;
            if(_fa_ !== i){var i=_fb_;continue}
            break}}
        return set_data$1(c,d)}
      function check_key(c)
       {var i$1=length$6(c) - 1 | 0,i=i$1;
        for(;;)
         {var _e8_=i < 0?1:0;
          if(_e8_)
           var _e9_=_e8_;
          else
           {var _e__=check_key$1(c,i);
            if(_e__){var i$0=i - 1 | 0,i=i$0;continue}
            var _e9_=_e__}
          return _e9_}}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$3,get_key,set_key_data,check_key])}
    function Make$4(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$3([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _e7_=include[1];
      function create(sz){return caml_call2(_e7_,_cN_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    var
     Stdlib_Ephemeron=
      [0,
       [0,
        create$5,
        get_key$0,
        get_key_copy$0,
        set_key$0,
        unset_key$0,
        check_key$0,
        blit_key$0,
        get_data$1,
        get_data_copy,
        set_data,
        unset_data,
        check_data,
        blit_data,
        Make$2,
        MakeSeeded$1],
       [0,
        create$6,
        get_key1,
        get_key1_copy,
        set_key1,
        unset_key1,
        check_key1,
        get_key2,
        get_key2_copy,
        set_key2,
        unset_key2,
        check_key2,
        blit_key1,
        blit_key2,
        blit_key12,
        get_data$2,
        get_data_copy$0,
        set_data$0,
        unset_data$0,
        check_data$0,
        blit_data$0,
        Make$3,
        MakeSeeded$2],
       [0,
        create$7,
        get_key$1,
        get_key_copy$1,
        set_key$1,
        unset_key$1,
        check_key$1,
        blit_key$1,
        get_data$3,
        get_data_copy$1,
        set_data$1,
        unset_data$1,
        check_data$1,
        blit_data$1,
        Make$4,
        MakeSeeded$3],
       [0,
        function(_e6_)
         {return MakeSeeded$0
                  ([0,_e6_[3],_e6_[1],_e6_[2],_e6_[5],_e6_[4],_e6_[6],_e6_[7]])}]];
    caml_register_global(809,Stdlib_Ephemeron,"Stdlib__Ephemeron");
    function generic_basename(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$100))return current_dir_name;
      var n$3=caml_ml_string_length(name) - 1 | 0,n=n$3;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var p=n + 1 | 0,n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               return sub$0(name,n$1 + 1 | 0,(p - n$1 | 0) - 1 | 0);
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return sub$0(name,0,p)}}
        return sub$0(name,0,1)}}
    function generic_dirname(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$101))return current_dir_name;
      var n$5=caml_ml_string_length(name) - 1 | 0,n=n$5;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               {var n$3=n$1;
                for(;;)
                 {if(0 <= n$3)
                   {if(caml_call2(is_dir_sep,name,n$3))
                     {var n$4=n$3 - 1 | 0,n$3=n$4;continue}
                    return sub$0(name,0,n$3 + 1 | 0)}
                  return sub$0(name,0,1)}}
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return current_dir_name}}
        return sub$0(name,0,1)}}
    function is_dir_sep(s,i){return 47 === caml_string_get(s,i)?1:0}
    function is_relative(n)
     {var
       _e4_=caml_ml_string_length(n) < 1?1:0,
       _e5_=_e4_ || (47 !== caml_string_get(n,0)?1:0);
      return _e5_}
    function is_implicit(n)
     {var _eZ_=is_relative(n);
      if(_eZ_)
       {var
         _e0_=caml_ml_string_length(n) < 2?1:0,
         _e1_=_e0_ || caml_string_notequal(sub$0(n,0,2),cst$103);
        if(_e1_)
         var
          _e2_=caml_ml_string_length(n) < 3?1:0,
          _e3_=_e2_ || caml_string_notequal(sub$0(n,0,3),cst$102);
        else
         var _e3_=_e1_}
      else
       var _e3_=_eZ_;
      return _e3_}
    function check_suffix(name,suff){return ends_with$0(suff,name)}
    function chop_suffix_opt(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var r=sub$0(filename,len_f - len_s | 0,len_s);
        return caml_string_equal(r,suffix)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cV_=caml_sys_getenv(cst_TMPDIR),_cO_=_cV_}
    catch(_eY_)
     {_eY_ = caml_wrap_exception(_eY_);
      if(_eY_ !== Not_found)throw _eY_;
      var _cO_=cst_tmp}
    function quote(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,39);
      var _eW_=l - 1 | 0,_eV_=0;
      if(! (_eW_ < 0))
       {var i=_eV_;
        for(;;)
         {if(39 === caml_string_get(s,i))
           add_string(b,quotequote);
          else
           add_char(b,caml_string_get(s,i));
          var _eX_=i + 1 | 0;
          if(_eW_ !== i){var i=_eX_;continue}
          break}}
      add_char(b,39);
      return contents(b)}
    function quote_command(cmd,stdin,stdout,stderr,args)
     {if(stderr)
       var
        f=stderr[1],
        _eP_=caml_equal(stderr,stdout)?cst_2_1:cat(cst_2,quote(f)),
        _eQ_=_eP_;
      else
       var _eQ_=cst$109;
      if(stdout)
       var f$0=stdout[1],_eR_=cat(cst$104,quote(f$0));
      else
       var _eR_=cst$108;
      var _eS_=cat(_eR_,_eQ_);
      if(stdin)
       var f$1=stdin[1],_eT_=cat(cst$105,quote(f$1));
      else
       var _eT_=cst$107;
      var _eU_=cat(_eT_,_eS_);
      return cat(concat$1(cst$106,map$3(quote,[0,cmd,args])),_eU_)}
    function basename(_eO_)
     {return generic_basename(is_dir_sep,current_dir_name,_eO_)}
    function dirname(_eN_)
     {return generic_dirname(is_dir_sep,current_dir_name,_eN_)}
    var
     Unix=
      [0,
       null$0,
       current_dir_name,
       parent_dir_name,
       dir_sep,
       is_dir_sep,
       is_relative,
       is_implicit,
       check_suffix,
       chop_suffix_opt,
       _cO_,
       quote,
       quote_command,
       basename,
       dirname];
    function is_dir_sep$0(s,i)
     {var c=caml_string_get(s,i),_eK_=47 === c?1:0;
      if(_eK_)
       var _eL_=_eK_;
      else
       var _eM_=92 === c?1:0,_eL_=_eM_ || (58 === c?1:0);
      return _eL_}
    function is_relative$0(n)
     {var
       _eE_=caml_ml_string_length(n) < 1?1:0,
       _eF_=_eE_ || (47 !== caml_string_get(n,0)?1:0);
      if(_eF_)
       {var
         _eG_=caml_ml_string_length(n) < 1?1:0,
         _eH_=_eG_ || (92 !== caml_string_get(n,0)?1:0);
        if(_eH_)
         var
          _eI_=caml_ml_string_length(n) < 2?1:0,
          _eJ_=_eI_ || (58 !== caml_string_get(n,1)?1:0);
        else
         var _eJ_=_eH_}
      else
       var _eJ_=_eF_;
      return _eJ_}
    function is_implicit$0(n)
     {var _ev_=is_relative$0(n);
      if(_ev_)
       {var
         _ew_=caml_ml_string_length(n) < 2?1:0,
         _ex_=_ew_ || caml_string_notequal(sub$0(n,0,2),cst$113);
        if(_ex_)
         {var
           _ey_=caml_ml_string_length(n) < 2?1:0,
           _ez_=_ey_ || caml_string_notequal(sub$0(n,0,2),cst$112);
          if(_ez_)
           {var
             _eA_=caml_ml_string_length(n) < 3?1:0,
             _eB_=_eA_ || caml_string_notequal(sub$0(n,0,3),cst$111);
            if(_eB_)
             var
              _eC_=caml_ml_string_length(n) < 3?1:0,
              _eD_=_eC_ || caml_string_notequal(sub$0(n,0,3),cst$110);
            else
             var _eD_=_eB_}
          else
           var _eD_=_ez_}
        else
         var _eD_=_ex_}
      else
       var _eD_=_ev_;
      return _eD_}
    function check_suffix$0(name,suff)
     {var _es_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0;
      if(_es_)
       var
        s=
         sub$0
          (name,
           caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
           caml_ml_string_length(suff)),
        _et_=lowercase_ascii$1(suff),
        _eu_=caml_string_equal(lowercase_ascii$1(s),_et_);
      else
       var _eu_=_es_;
      return _eu_}
    function chop_suffix_opt$0(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var
         r=sub$0(filename,len_f - len_s | 0,len_s),
         _er_=lowercase_ascii$1(suffix);
        return caml_string_equal(lowercase_ascii$1(r),_er_)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cU_=caml_sys_getenv(cst_TEMP),temp_dir_name=_cU_}
    catch(_eq_)
     {_eq_ = caml_wrap_exception(_eq_);
      if(_eq_ !== Not_found)throw _eq_;
      var temp_dir_name=cst$114}
    function quote$0(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,34);
      function add_bs(n)
       {var _eo_=1;
        if(! (n < 1))
         {var j=_eo_;
          for(;;)
           {add_char(b,92);
            var _ep_=j + 1 | 0;
            if(n !== j){var j=_ep_;continue}
            break}}
        return 0}
      function loop$0(counter,i)
       {var i$0=i;
        for(;;)
         {if(i$0 === l)return add_char(b,34);
          var c=caml_string_get(s,i$0);
          if(34 === c)
           {var _em_=0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;
              return loop_bs(counter$1,_em_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_em_,i$0])}
          if(92 === c)
           {var _en_=0;
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return loop_bs(counter$0,_en_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_en_,i$0])}
          add_char(b,c);
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function loop_bs(counter,n,i)
       {var n$0=n,i$0=i;
        for(;;)
         {if(i$0 === l){add_char(b,34);return add_bs(n$0)}
          var match=caml_string_get(s,i$0);
          if(34 === match)
           {add_bs((2 * n$0 | 0) + 1 | 0);
            add_char(b,34);
            var _el_=i$0 + 1 | 0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;return loop$0(counter$1,_el_)}
            return caml_trampoline_return(loop$0,[0,_el_])}
          if(92 === match)
           {var i$1=i$0 + 1 | 0,n$1=n$0 + 1 | 0,n$0=n$1,i$0=i$1;continue}
          add_bs(n$0);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return loop$0(counter$0,i$0)}
          return caml_trampoline_return(loop$0,[0,i$0])}}
      function loop(i){return caml_trampoline(loop$0(0,i))}
      loop(0);
      return contents(b)}
    function quote_cmd_filename(f)
     {if(! contains$0(f,34) && ! contains$0(f,37))
       return contains$0(f,32)?cat(cst$116,cat(f,cst$115)):f;
      return failwith(cat(cst_Filename_quote_command_bad,f))}
    function quote_command$0(cmd,stdin,stdout,stderr,args)
     {if(stderr)
       var
        f=stderr[1],
        _ec_=
         caml_equal(stderr,stdout)
          ?cst_2_1$0
          :cat(cst_2$0,quote_cmd_filename(f)),
        _ed_=_ec_;
      else
       var _ed_=cst$125;
      var _ee_=[0,_ed_,_cP_];
      if(stdout)
       var f$0=stdout[1],_ef_=cat(cst$117,quote_cmd_filename(f$0));
      else
       var _ef_=cst$124;
      var _eg_=[0,_ef_,_ee_];
      if(stdin)
       var f$1=stdin[1],_eh_=cat(cst$118,quote_cmd_filename(f$1));
      else
       var _eh_=cst$123;
      var
       s=concat$1(cst$119,map$3(quote$0,args)),
       b=create$2(caml_ml_string_length(s) + 20 | 0),
       _ei_=[0,_eh_,_eg_];
      iter$4
       (function(c)
         {var switch$0=0;
          if(62 <= c)
           {var _ek_=c - 63 | 0;
            if(60 < _ek_ >>> 0)
             {if(! (62 <= _ek_))switch$0 = 1}
            else
             if(31 === _ek_)switch$0 = 1}
          else
           if(42 <= c)
            {if(60 === c)switch$0 = 1}
           else
            if(33 <= c)
             switch(c - 33 | 0)
              {case 2:case 3:case 6:break;default:switch$0 = 1}
          return switch$0?(add_char(b,94),add_char(b,c)):add_char(b,c)},
        s);
      var _ej_=[0,cst$120,[0,contents(b),_ei_]];
      return concat$1(cst$122,[0,cst$121,[0,quote_cmd_filename(cmd),_ej_]])}
    function drive_and_path(s)
     {var _d__=2 <= caml_ml_string_length(s)?1:0;
      if(_d__)
       {var param=caml_string_get(s,0),switch$0=0;
        if(91 <= param)
         {if(! (25 < param - 97 >>> 0))switch$0 = 1}
        else
         if(65 <= param)switch$0 = 1;
        var _d$_=switch$0?1:0,_ea_=_d$_?58 === caml_string_get(s,1)?1:0:_d$_}
      else
       var _ea_=_d__;
      if(_ea_)
       {var _eb_=sub$0(s,2,caml_ml_string_length(s) - 2 | 0);
        return [0,sub$0(s,0,2),_eb_]}
      return [0,cst$126,s]}
    function dirname$0(s)
     {var
       match=drive_and_path(s),
       path=match[2],
       drive=match[1],
       dir=generic_dirname(is_dir_sep$0,current_dir_name$0,path);
      return cat(drive,dir)}
    function basename$0(s)
     {var match=drive_and_path(s),path=match[2];
      return generic_basename(is_dir_sep$0,current_dir_name$0,path)}
    var
     Win32=
      [0,
       null$1,
       current_dir_name$0,
       parent_dir_name$0,
       dir_sep$0,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       temp_dir_name,
       quote$0,
       quote_command$0,
       basename$0,
       dirname$0];
    function basename$1(_d9_)
     {return generic_basename(is_dir_sep$0,current_dir_name$1,_d9_)}
    function dirname$1(_d8_)
     {return generic_dirname(is_dir_sep$0,current_dir_name$1,_d8_)}
    var
     Cygwin=
      [0,
       null$2,
       current_dir_name$1,
       parent_dir_name$1,
       dir_sep$1,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       _cO_,
       quote,
       quote_command,
       basename$1,
       dirname$1],
     Sysdeps=
      caml_string_notequal(os_type,cst_Cygwin)
       ?caml_string_notequal(os_type,cst_Win32)?Unix:Win32
       :Cygwin,
     null$3=Sysdeps[1],
     current_dir_name$2=Sysdeps[2],
     parent_dir_name$2=Sysdeps[3],
     dir_sep$2=Sysdeps[4],
     is_dir_sep$1=Sysdeps[5],
     is_relative$1=Sysdeps[6],
     is_implicit$1=Sysdeps[7],
     check_suffix$1=Sysdeps[8],
     chop_suffix_opt$1=Sysdeps[9],
     temp_dir_name$0=Sysdeps[10],
     quote$1=Sysdeps[11],
     quote_command$1=Sysdeps[12],
     basename$2=Sysdeps[13],
     dirname$2=Sysdeps[14];
    function concat$4(dirname,filename)
     {var l=caml_ml_string_length(dirname);
      if(0 !== l && ! is_dir_sep$1(dirname,l - 1 | 0))
       return cat(dirname,cat(dir_sep$2,filename));
      return cat(dirname,filename)}
    function chop_suffix(name,suff)
     {var n=caml_ml_string_length(name) - caml_ml_string_length(suff) | 0;
      return 0 <= n?sub$0(name,0,n):invalid_arg(cst_Filename_chop_suffix)}
    function extension_len(name)
     {var i$4=caml_ml_string_length(name) - 1 | 0,i$1=i$4;
      for(;;)
       {if(0 <= i$1 && ! is_dir_sep$1(name,i$1))
         {if(46 === caml_string_get(name,i$1))
           {var i$2=i$1 - 1 | 0,i=i$2;
            for(;;)
             {if(0 <= i && ! is_dir_sep$1(name,i))
               {if(46 === caml_string_get(name,i))
                 {var i$0=i - 1 | 0,i=i$0;continue}
                return caml_ml_string_length(name) - i$1 | 0}
              return 0}}
          var i$3=i$1 - 1 | 0,i$1=i$3;
          continue}
        return 0}}
    function extension(name)
     {var l=extension_len(name);
      return 0 === l?cst$127:sub$0(name,caml_ml_string_length(name) - l | 0,l)}
    function chop_extension(name)
     {var l=extension_len(name);
      return 0 === l
              ?invalid_arg(cst_Filename_chop_extension)
              :sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    function remove_extension(name)
     {var l=extension_len(name);
      return 0 === l?name:sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    var prng$0=[246,function(_d7_){return caml_call1(_cb_[2],0)}];
    function temp_file_name(temp_dir,prefix,suffix)
     {var
       _d5_=caml_obj_tag(prng$0),
       _d6_=
        250 === _d5_?prng$0[1]:246 === _d5_?force_lazy_block(prng$0):prng$0,
       rnd=caml_call1(_cb_[4],_d6_) & 16777215;
      return concat$4(temp_dir,caml_call3(sprintf(_cQ_),prefix,rnd,suffix))}
    var current_temp_dir_name=[0,temp_dir_name$0];
    function set_temp_dir_name(s){current_temp_dir_name[1] = s;return 0}
    function get_temp_dir_name(param){return current_temp_dir_name[1]}
    function temp_file(opt,prefix,suffix)
     {if(opt)
       var sth=opt[1],temp_dir=sth;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {runtime.caml_sys_close(caml_sys_open(name,_cR_,384));return name}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    function open_temp_file(opt,_d3_,_d2_,prefix,suffix)
     {if(opt)var sth=opt[1],mode=sth;else var mode=_cS_;
      if(_d3_)var sth$0=_d3_[1],perms=sth$0;else var perms=384;
      if(_d2_)
       var sth$1=_d2_[1],temp_dir=sth$1;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {var _d4_=[0,name,open_out_gen([0,1,[0,3,[0,5,mode]]],perms,name)];
            return _d4_}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    var
     Stdlib_Filename=
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat$4,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       chop_suffix_opt$1,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       null$3,
       temp_file,
       open_temp_file,
       get_temp_dir_name,
       set_temp_dir_name,
       temp_dir_name$0,
       quote$1,
       quote_command$1];
    caml_register_global(810,Stdlib_Filename,"Stdlib__Filename");
    function add$1(x,y){return [254,x[1] + y[1],x[2] + y[2]]}
    function sub$4(x,y){return [254,x[1] - y[1],x[2] - y[2]]}
    function neg(x){return [254,- x[1],- x[2]]}
    function conj(x){return [254,x[1],- x[2]]}
    function mul(x,y)
     {return [254,x[1] * y[1] - x[2] * y[2],x[1] * y[2] + x[2] * y[1]]}
    function div(x,y)
     {if(Math.abs(y[2]) <= Math.abs(y[1]))
       {var r=y[2] / y[1],d=y[1] + r * y[2];
        return [254,(x[1] + r * x[2]) / d,(x[2] - r * x[1]) / d]}
      var r$0=y[1] / y[2],d$0=y[2] + r$0 * y[1];
      return [254,(r$0 * x[1] + x[2]) / d$0,(r$0 * x[2] - x[1]) / d$0]}
    function inv(x){return div(one$4,x)}
    function norm2(x){return x[1] * x[1] + x[2] * x[2]}
    function norm(x)
     {var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(r == 0.)return i;
      if(i == 0.)return r;
      if(i <= r){var q=i / r;return r * Math.sqrt(1. + q * q)}
      var q$0=r / i;
      return i * Math.sqrt(1. + q$0 * q$0)}
    function arg(x){return Math.atan2(x[2],x[1])}
    function polar(n,a){return [254,Math.cos(a) * n,Math.sin(a) * n]}
    function sqrt(x)
     {if(x[1] == 0. && x[2] == 0.)return _cT_;
      var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(i <= r)
       var
        q=i / r,
        w=Math.sqrt(r) * Math.sqrt(0.5 * (1. + Math.sqrt(1. + q * q)));
      else
       var
        q$0=r / i,
        w=Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1. + q$0 * q$0)));
      if(0. <= x[1])return [254,w,0.5 * x[2] / w];
      var w$0=0. <= x[2]?w:- w;
      return [254,0.5 * i / w,w$0]}
    function exp(x)
     {var e=Math.exp(x[1]);return [254,e * Math.cos(x[2]),e * Math.sin(x[2])]}
    function log(x)
     {var _d1_=Math.atan2(x[2],x[1]);return [254,Math.log(norm(x)),_d1_]}
    function pow(x,y){return exp(mul(y,log(x)))}
    var
     Stdlib_Complex=
      [0,
       zero$4,
       one$4,
       i,
       neg,
       conj,
       add$1,
       sub$4,
       mul,
       inv,
       div,
       sqrt,
       norm2,
       norm,
       arg,
       polar,
       exp,
       log,
       pow];
    caml_register_global(811,Stdlib_Complex,"Stdlib__Complex");
    var
     Stdlib_ArrayLabels=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$1,
       concat$2,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       iteri$2,
       map$6,
       mapi$2,
       fold_left$3,
       fold_left_map$0,
       fold_right$2,
       iter2$0,
       map2$0,
       for_all$2,
       exists$2,
       for_all2$0,
       exists2$0,
       mem$0,
       memq$0,
       find_opt$0,
       find_map$0,
       split$0,
       combine$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(812,Stdlib_ArrayLabels,"Stdlib__ArrayLabels");
    var
     Stdlib_ListLabels=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons$0,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal$5,
       compare$5,
       iter$2,
       iteri,
       map$3,
       mapi,
       rev_map,
       filter_map$0,
       concat_map,
       fold_left_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(813,Stdlib_ListLabels,"Stdlib__ListLabels");
    var
     Stdlib_BytesLabels=
      [0,
       make$0,
       init$0,
       empty$0,
       copy,
       to_bytes,
       of_bytes,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat$0,
       cat$0,
       iter$3,
       iteri$0,
       map$4,
       mapi$0,
       fold_left$1,
       fold_right$0,
       for_all$0,
       exists$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$7,
       equal$7,
       starts_with,
       ends_with,
       unsafe_to_string,
       unsafe_of_string,
       split_on_char,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le];
    caml_register_global(814,Stdlib_BytesLabels,"Stdlib__BytesLabels");
    var
     Stdlib_StringLabels=
      [0,
       make$1,
       init$1,
       empty$1,
       of_bytes,
       to_bytes,
       concat$1,
       cat,
       equal$8,
       compare$8,
       starts_with$0,
       ends_with$0,
       contains_from$0,
       rcontains_from$0,
       contains$0,
       sub$0,
       split_on_char$0,
       map$5,
       mapi$1,
       fold_left$2,
       fold_right$1,
       for_all$1,
       exists$1,
       trim$0,
       escaped$1,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       iter$4,
       iteri$1,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       to_seq$3,
       to_seqi$0,
       of_seq$1,
       blit$0,
       copy$0,
       fill,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       get_uint8$0,
       get_int8$0,
       get_uint16_ne$0,
       get_uint16_be$0,
       get_uint16_le$0,
       get_int16_ne$0,
       get_int16_be$0,
       get_int16_le$0,
       get_int32_ne$0,
       get_int32_be$0,
       get_int32_le$0,
       get_int64_ne$0,
       get_int64_be$0,
       get_int64_le$0];
    caml_register_global(815,Stdlib_StringLabels,"Stdlib__StringLabels");
    var Stdlib_MoreLabels=[0,Stdlib_Hashtbl,Stdlib_Map,Stdlib_Set];
    caml_register_global(816,Stdlib_MoreLabels,"Stdlib__MoreLabels");
    var Stdlib_StdLabels=[0];
    caml_register_global(817,Stdlib_StdLabels,"Stdlib__StdLabels");
    var
     float32=0,
     float64=1,
     int8_signed=2,
     int8_unsigned=3,
     int16_signed=4,
     int16_unsigned=5,
     int32$1=6,
     int64$1=7,
     int$2=8,
     nativeint$1=9,
     complex32=10,
     complex64=11,
     char$0=12;
    function kind_size_in_bytes(param)
     {switch(param)
       {case 0:return 4;
        case 1:return 8;
        case 2:return 1;
        case 3:return 1;
        case 4:return 2;
        case 5:return 2;
        case 6:return 4;
        case 7:return 8;
        case 8:return 4;
        case 9:return 4;
        case 10:return 8;
        case 11:return 16;
        default:return 1}}
    var c_layout=0,fortran_layout=1;
    function cloop(arr,idx,f,col,max)
     {if(col === idx.length - 1)
       return caml_ba_set_generic(arr,idx,caml_call1(f,idx));
      var _dZ_=caml_check_bound(max,col)[1 + col] - 1 | 0,_dY_=0;
      if(! (_dZ_ < 0))
       {var j=_dY_;
        for(;;)
         {caml_check_bound(idx,col)[1 + col] = j;
          cloop(arr,idx,f,col + 1 | 0,max);
          var _d0_=j + 1 | 0;
          if(_dZ_ !== j){var j=_d0_;continue}
          break}}
      return 0}
    function floop(arr,idx,f,col,max)
     {if(0 <= col)
       {var _dW_=caml_check_bound(max,col)[1 + col],_dV_=1;
        if(! (_dW_ < 1))
         {var j=_dV_;
          for(;;)
           {caml_check_bound(idx,col)[1 + col] = j;
            floop(arr,idx,f,col - 1 | 0,max);
            var _dX_=j + 1 | 0;
            if(_dW_ !== j){var j=_dX_;continue}
            break}}
        return 0}
      return caml_ba_set_generic(arr,idx,caml_call1(f,idx))}
    function init$5(kind,layout,dims,f)
     {var arr=caml_ba_create(kind,layout,dims),dlen=dims.length - 1;
      return 0 === dlen
              ?arr
              :layout
                ?(floop(arr,caml_make_vect(dlen,1),f,dlen - 1 | 0,dims),arr)
                :(cloop(arr,caml_make_vect(dlen,0),f,0,dims),arr)}
    function dims(a)
     {var n=caml_ba_num_dims(a),d=caml_make_vect(n,0),_dS_=n - 1 | 0,_dR_=0;
      if(! (_dS_ < 0))
       {var i=_dR_;
        for(;;)
         {var _dT_=runtime.caml_ba_dim(a,i);
          caml_check_bound(d,i)[1 + i] = _dT_;
          var _dU_=i + 1 | 0;
          if(_dS_ !== i){var i=_dU_;continue}
          break}}
      return d}
    function size_in_bytes(arr)
     {var _dQ_=fold_left$3(caml_mul,1,dims(arr));
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dQ_)}
    function create$8(kind,layout){return caml_ba_create(kind,layout,[0])}
    function get$2(arr){return runtime.caml_ba_get_generic(arr,[0])}
    function set$1(arr)
     {var _dO_=[0];
      return function(_dP_){return caml_ba_set_generic(arr,_dO_,_dP_)}}
    function size_in_bytes$0(arr)
     {return kind_size_in_bytes(caml_ba_kind(arr))}
    function of_value(kind,layout,v)
     {var a=create$8(kind,layout);caml_call1(set$1(a),v);return a}
    function create$9(kind,layout,dim)
     {return caml_ba_create(kind,layout,[0,dim])}
    function size_in_bytes$1(arr)
     {var _dN_=caml_ba_dim_1(arr);
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dN_)}
    function slice(a,n)
     {var match=runtime.caml_ba_layout(a);
      return match?caml_ba_slice(a,[0,n]):caml_ba_slice(a,[0,n])}
    function init$6(kind,layout,dim,f)
     {var arr=create$9(kind,layout,dim);
      if(layout)
       {var _dL_=1;
        if(! (dim < 1))
         {var i$0=_dL_;
          for(;;)
           {caml_ba_set_1(arr,i$0,caml_call1(f,i$0));
            var _dM_=i$0 + 1 | 0;
            if(dim !== i$0){var i$0=_dM_;continue}
            break}}
        return arr}
      var _dJ_=dim - 1 | 0,_dI_=0;
      if(! (_dJ_ < 0))
       {var i=_dI_;
        for(;;)
         {caml_ba_set_1(arr,i,caml_call1(f,i));
          var _dK_=i + 1 | 0;
          if(_dJ_ !== i){var i=_dK_;continue}
          break}}
      return arr}
    function of_array(kind,layout,data)
     {var
       ba=create$9(kind,layout,data.length - 1),
       ofs=layout?1:0,
       _dG_=data.length - 1 - 1 | 0,
       _dF_=0;
      if(! (_dG_ < 0))
       {var i=_dF_;
        for(;;)
         {caml_ba_set_1(ba,i + ofs | 0,caml_check_bound(data,i)[1 + i]);
          var _dH_=i + 1 | 0;
          if(_dG_ !== i){var i=_dH_;continue}
          break}}
      return ba}
    function create$10(kind,layout,dim1,dim2)
     {return caml_ba_create(kind,layout,[0,dim1,dim2])}
    function size_in_bytes$2(arr)
     {var _dD_=caml_ba_dim_2(arr),_dE_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dE_),_dD_)}
    function slice_left(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right(a,n){return caml_ba_slice(a,[0,n])}
    function init$7(kind,layout,dim1,dim2,f)
     {var arr=create$10(kind,layout,dim1,dim2);
      if(layout)
       {var _dz_=1;
        if(! (dim2 < 1))
         {var j$0=_dz_;
          for(;;)
           {var _dA_=1;
            if(! (dim1 < 1))
             {var i$0=_dA_;
              for(;;)
               {caml_ba_set_2(arr,i$0,j$0,caml_call2(f,i$0,j$0));
                var _dC_=i$0 + 1 | 0;
                if(dim1 !== i$0){var i$0=_dC_;continue}
                break}}
            var _dB_=j$0 + 1 | 0;
            if(dim2 !== j$0){var j$0=_dB_;continue}
            break}}
        return arr}
      var _du_=dim1 - 1 | 0,_dt_=0;
      if(! (_du_ < 0))
       {var i=_dt_;
        for(;;)
         {var _dw_=dim2 - 1 | 0,_dv_=0;
          if(! (_dw_ < 0))
           {var j=_dv_;
            for(;;)
             {caml_ba_set_2(arr,i,j,caml_call2(f,i,j));
              var _dy_=j + 1 | 0;
              if(_dw_ !== j){var j=_dy_;continue}
              break}}
          var _dx_=i + 1 | 0;
          if(_du_ !== i){var i=_dx_;continue}
          break}}
      return arr}
    function of_array$0(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       ba=create$10(kind,layout,dim1,dim2),
       ofs=layout?1:0,
       _do_=dim1 - 1 | 0,
       _dn_=0;
      if(! (_do_ < 0))
       {var i=_dn_;
        for(;;)
         {var row=caml_check_bound(data,i)[1 + i];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array2_of_array_n);
          var _dq_=dim2 - 1 | 0,_dp_=0;
          if(! (_dq_ < 0))
           {var j=_dp_;
            for(;;)
             {caml_ba_set_2
               (ba,i + ofs | 0,j + ofs | 0,caml_check_bound(row,j)[1 + j]);
              var _ds_=j + 1 | 0;
              if(_dq_ !== j){var j=_ds_;continue}
              break}}
          var _dr_=i + 1 | 0;
          if(_do_ !== i){var i=_dr_;continue}
          break}}
      return ba}
    function create$11(kind,layout,dim1,dim2,dim3)
     {return caml_ba_create(kind,layout,[0,dim1,dim2,dim3])}
    function size_in_bytes$3(arr)
     {var
       _dk_=runtime.caml_ba_dim_3(arr),
       _dl_=caml_ba_dim_2(arr),
       _dm_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul
                (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dm_),_dl_),
               _dk_)}
    function slice_left_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_right_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_left_2(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right_2(a,n){return caml_ba_slice(a,[0,n])}
    function init$8(kind,layout,dim1,dim2,dim3,f)
     {var arr=create$11(kind,layout,dim1,dim2,dim3);
      if(layout)
       {var _de_=1;
        if(! (dim3 < 1))
         {var k$0=_de_;
          for(;;)
           {var _df_=1;
            if(! (dim2 < 1))
             {var j$0=_df_;
              for(;;)
               {var _dh_=1;
                if(! (dim1 < 1))
                 {var i$0=_dh_;
                  for(;;)
                   {caml_ba_set_3(arr,i$0,j$0,k$0,caml_call3(f,i$0,j$0,k$0));
                    var _dj_=i$0 + 1 | 0;
                    if(dim1 !== i$0){var i$0=_dj_;continue}
                    break}}
                var _di_=j$0 + 1 | 0;
                if(dim2 !== j$0){var j$0=_di_;continue}
                break}}
            var _dg_=k$0 + 1 | 0;
            if(dim3 !== k$0){var k$0=_dg_;continue}
            break}}
        return arr}
      var _c8_=dim1 - 1 | 0,_c7_=0;
      if(! (_c8_ < 0))
       {var i=_c7_;
        for(;;)
         {var _c__=dim2 - 1 | 0,_c9_=0;
          if(! (_c__ < 0))
           {var j=_c9_;
            for(;;)
             {var _db_=dim3 - 1 | 0,_da_=0;
              if(! (_db_ < 0))
               {var k=_da_;
                for(;;)
                 {caml_ba_set_3(arr,i,j,k,caml_call3(f,i,j,k));
                  var _dd_=k + 1 | 0;
                  if(_db_ !== k){var k=_dd_;continue}
                  break}}
              var _dc_=j + 1 | 0;
              if(_c__ !== j){var j=_dc_;continue}
              break}}
          var _c$_=i + 1 | 0;
          if(_c8_ !== i){var i=_c$_;continue}
          break}}
      return arr}
    function of_array$1(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       dim3=
        0 === dim2
         ?0
         :caml_check_bound(caml_check_bound(data,0)[1],0)[1].length - 1,
       ba=create$11(kind,layout,dim1,dim2,dim3),
       ofs=layout?1:0,
       _cZ_=dim1 - 1 | 0,
       _cY_=0;
      if(! (_cZ_ < 0))
       {var i=_cY_;
        for(;;)
         {var row=caml_check_bound(data,i)[1 + i];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array3_of_array_n);
          var _c1_=dim2 - 1 | 0,_c0_=0;
          if(! (_c1_ < 0))
           {var j=_c0_;
            for(;;)
             {var col=caml_check_bound(row,j)[1 + j];
              if(col.length - 1 !== dim3)
               invalid_arg(cst_Bigarray_Array3_of_array_n$0);
              var _c4_=dim3 - 1 | 0,_c3_=0;
              if(! (_c4_ < 0))
               {var k=_c3_;
                for(;;)
                 {caml_ba_set_3
                   (ba,
                    i + ofs | 0,
                    j + ofs | 0,
                    k + ofs | 0,
                    caml_check_bound(col,k)[1 + k]);
                  var _c6_=k + 1 | 0;
                  if(_c4_ !== k){var k=_c6_;continue}
                  break}}
              var _c5_=j + 1 | 0;
              if(_c1_ !== j){var j=_c5_;continue}
              break}}
          var _c2_=i + 1 | 0;
          if(_cZ_ !== i){var i=_c2_;continue}
          break}}
      return ba}
    function array0_of_genarray(a)
     {return 0 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array0_of_genarra)}
    function array1_of_genarray(a)
     {return 1 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array1_of_genarra)}
    function array2_of_genarray(a)
     {return 2 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array2_of_genarra)}
    function array3_of_genarray(a)
     {return 3 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array3_of_genarra)}
    function reshape_0(a){return caml_ba_reshape(a,[0])}
    function reshape_1(a,dim1){return caml_ba_reshape(a,[0,dim1])}
    function reshape_2(a,dim1,dim2){return caml_ba_reshape(a,[0,dim1,dim2])}
    function reshape_3(a,dim1,dim2,dim3)
     {return caml_ba_reshape(a,[0,dim1,dim2,dim3])}
    var
     Stdlib_Bigarray=
      [0,
       float32,
       float64,
       complex32,
       complex64,
       int8_signed,
       int8_unsigned,
       int16_signed,
       int16_unsigned,
       int$2,
       int32$1,
       int64$1,
       nativeint$1,
       char$0,
       kind_size_in_bytes,
       c_layout,
       fortran_layout,
       [0,init$5,dims,size_in_bytes],
       [0,
        create$8,
        of_value,
        caml_ba_change_layout,
        size_in_bytes$0,
        get$2,
        set$1,
        of_value],
       [0,
        create$9,
        init$6,
        caml_ba_change_layout,
        size_in_bytes$1,
        slice,
        of_array],
       [0,
        create$10,
        init$7,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$11,
        init$8,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
    caml_register_global(818,Stdlib_Bigarray,"Stdlib__Bigarray");
    return}
  (globalThis));


//# 1 "../../src/.alg.objs/alg.cma.js"
(function(globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_check_bound=runtime.caml_check_bound,
     caml_equal=runtime.caml_equal,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_compare=runtime.caml_int_compare,
     caml_make_vect=runtime.caml_make_vect,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_register_global=runtime.caml_register_global,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    function caml_call8(f,a0,a1,a2,a3,a4,a5,a6,a7)
     {return f.length == 8
              ?f(a0,a1,a2,a3,a4,a5,a6,a7)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7])}
    function caml_call10(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
     {return f.length == 10
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9])}
    function caml_call12(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)
     {return f.length == 12
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)
              :runtime.caml_call_gen
                (f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11])}
    function caml_call14(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13)
     {return f.length == 14
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13)
              :runtime.caml_call_gen
                (f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13])}
    function caml_call16
     (f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15)
     {return f.length == 16
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15)
              :runtime.caml_call_gen
                (f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15])}
    function caml_call22
     (f,
      a0,
      a1,
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14,
      a15,
      a16,
      a17,
      a18,
      a19,
      a20,
      a21)
     {return f.length == 22
              ?f
                (a0,
                 a1,
                 a2,
                 a3,
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 a9,
                 a10,
                 a11,
                 a12,
                 a13,
                 a14,
                 a15,
                 a16,
                 a17,
                 a18,
                 a19,
                 a20,
                 a21)
              :runtime.caml_call_gen
                (f,
                 [a0,
                  a1,
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  a9,
                  a10,
                  a11,
                  a12,
                  a13,
                  a14,
                  a15,
                  a16,
                  a17,
                  a18,
                  a19,
                  a20,
                  a21])}
    function caml_call24
     (f,
      a0,
      a1,
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14,
      a15,
      a16,
      a17,
      a18,
      a19,
      a20,
      a21,
      a22,
      a23)
     {return f.length == 24
              ?f
                (a0,
                 a1,
                 a2,
                 a3,
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 a9,
                 a10,
                 a11,
                 a12,
                 a13,
                 a14,
                 a15,
                 a16,
                 a17,
                 a18,
                 a19,
                 a20,
                 a21,
                 a22,
                 a23)
              :runtime.caml_call_gen
                (f,
                 [a0,
                  a1,
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  a9,
                  a10,
                  a11,
                  a12,
                  a13,
                  a14,
                  a15,
                  a16,
                  a17,
                  a18,
                  a19,
                  a20,
                  a21,
                  a22,
                  a23])}
    function caml_call26
     (f,
      a0,
      a1,
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14,
      a15,
      a16,
      a17,
      a18,
      a19,
      a20,
      a21,
      a22,
      a23,
      a24,
      a25)
     {return f.length == 26
              ?f
                (a0,
                 a1,
                 a2,
                 a3,
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 a9,
                 a10,
                 a11,
                 a12,
                 a13,
                 a14,
                 a15,
                 a16,
                 a17,
                 a18,
                 a19,
                 a20,
                 a21,
                 a22,
                 a23,
                 a24,
                 a25)
              :runtime.caml_call_gen
                (f,
                 [a0,
                  a1,
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  a9,
                  a10,
                  a11,
                  a12,
                  a13,
                  a14,
                  a15,
                  a16,
                  a17,
                  a18,
                  a19,
                  a20,
                  a21,
                  a22,
                  a23,
                  a24,
                  a25])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_List_sub=caml_string_of_jsbytes("List.sub"),
     cst_tex=caml_string_of_jsbytes(".tex"),
     cst_ocaml_alg=caml_string_of_jsbytes("ocaml-alg"),
     partial=[2,0,0],
     partial$0=
      [2,
       0,
       [11,
        caml_string_of_jsbytes("\\ar[d,"),
        [2,0,[11,caml_string_of_jsbytes("]\\\\\n&&"),[2,0,0]]]]],
     partial$1=
      [2,
       0,
       [11,
        caml_string_of_jsbytes("\\ar[d,"),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("]\\\\\n&&"),
          [2,
           0,
           [11,
            caml_string_of_jsbytes("\\ar[d,"),
            [2,0,[11,caml_string_of_jsbytes("]\\\\\n&&"),[2,0,0]]]]]]]]],
     partial$2=[11,caml_string_of_jsbytes("]\\\\\n&&"),[2,0,0]],
     partial$3=
      [2,
       0,
       [11,
        caml_string_of_jsbytes("\\ar[d,"),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("]\\\\\n&&"),
          [2,
           0,
           [11,
            caml_string_of_jsbytes("\\ar[d,"),
            [2,
             0,
             [11,
              caml_string_of_jsbytes("]\\\\\n&&"),
              [2,0,[11,caml_string_of_jsbytes("\\ar[d,"),[2,0,partial$2]]]]]]]]]]],
     partial$4=
      [11,
       caml_string_of_jsbytes("]\\\\\n&&"),
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[d,"),
         [2,0,[11,caml_string_of_jsbytes("]\\\\\n&&"),[2,0,0]]]]]],
     partial$5=
      [2,
       0,
       [11,
        caml_string_of_jsbytes("\\ar[d,"),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("]\\\\\n&&"),
          [2,
           0,
           [11,
            caml_string_of_jsbytes("\\ar[d,"),
            [2,
             0,
             [11,
              caml_string_of_jsbytes("]\\\\\n&&"),
              [2,0,[11,caml_string_of_jsbytes("\\ar[d,"),[2,0,partial$4]]]]]]]]]]],
     partial$6=
      [2,
       0,
       [11,
        caml_string_of_jsbytes("\\ar[r,"),
        [2,0,[11,caml_string_of_jsbytes("']&"),[2,0,0]]]]],
     partial$7=
      [2,
       0,
       [11,
        caml_string_of_jsbytes("\\ar[d,"),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("]\\\\\n"),
          [2,
           0,
           [11,
            caml_string_of_jsbytes("\\ar[rr,"),
            [2,0,[11,caml_string_of_jsbytes("']&&"),[2,0,0]]]]]]]]],
     partial$8=[11,caml_string_of_jsbytes("']&&&"),[2,0,0]],
     partial$9=
      [2,
       0,
       [11,
        caml_string_of_jsbytes("\\ar[r,"),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("]&"),
          [2,
           0,
           [11,
            caml_string_of_jsbytes("\\ar[d,"),
            [2,
             0,
             [11,
              caml_string_of_jsbytes("]\\\\\n"),
              [2,0,[11,caml_string_of_jsbytes("\\ar[rrr,"),[2,0,partial$8]]]]]]]]]]],
     partial$10=
      [11,
       caml_string_of_jsbytes("]\\\\\n"),
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[r,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']&"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("\\ar[r,"),
             [2,0,[11,caml_string_of_jsbytes("']&"),[2,0,0]]]]]]]]]],
     partial$11=
      [2,
       0,
       [11,
        caml_string_of_jsbytes("\\ar[d,"),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("]\\\\\n&&"),
          [2,
           0,
           [11,
            caml_string_of_jsbytes("\\ar[d,"),
            [2,
             0,
             [11,
              caml_string_of_jsbytes("]\\\\\n&&"),
              [2,0,[11,caml_string_of_jsbytes("\\ar[d,"),[2,0,partial$10]]]]]]]]]]],
     partial$12=
      [2,
       0,
       [11,
        caml_string_of_jsbytes("]\\\\\n"),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("\\ar[r,"),
          [2,
           0,
           [11,
            caml_string_of_jsbytes("']&"),
            [2,
             0,
             [11,
              caml_string_of_jsbytes("\\ar[r,"),
              [2,0,[11,caml_string_of_jsbytes("']&"),[2,0,0]]]]]]]]]]],
     partial$13=
      [11,
       caml_string_of_jsbytes("]\\\\\n&&"),
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[d,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("]\\\\\n&&"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("\\ar[d,"),
             [2,
              0,
              [11,
               caml_string_of_jsbytes("]\\\\\n&&"),
               [2,0,[11,caml_string_of_jsbytes("\\ar[d,"),partial$12]]]]]]]]]]],
     partial$14=
      [2,
       0,
       [11,
        caml_string_of_jsbytes("\\ar[d,"),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("]\\\\\n&&"),
          [2,
           0,
           [11,
            caml_string_of_jsbytes("\\ar[d,"),
            [2,
             0,
             [11,
              caml_string_of_jsbytes("]\\\\\n&&"),
              [2,0,[11,caml_string_of_jsbytes("\\ar[d,"),[2,0,partial$13]]]]]]]]]]],
     partial$15=
      [11,
       caml_string_of_jsbytes("\\ar[r,"),
       [2,0,[11,caml_string_of_jsbytes("']&"),[2,0,0]]]],
     partial$16=
      [2,
       0,
       [11,
        caml_string_of_jsbytes("]\\\\\n&&"),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("\\ar[d,"),
          [2,
           0,
           [11,
            caml_string_of_jsbytes("]\\\\\n"),
            [2,
             0,
             [11,
              caml_string_of_jsbytes("\\ar[r,"),
              [2,0,[11,caml_string_of_jsbytes("']&"),[2,0,partial$15]]]]]]]]]]],
     partial$17=
      [11,
       caml_string_of_jsbytes("]\\\\\n&&"),
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[d,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("]\\\\\n&&"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("\\ar[d,"),
             [2,
              0,
              [11,
               caml_string_of_jsbytes("]\\\\\n&&"),
               [2,0,[11,caml_string_of_jsbytes("\\ar[d,"),partial$16]]]]]]]]]]],
     partial$18=
      [2,
       0,
       [11,
        caml_string_of_jsbytes("\\ar[d,"),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("]\\\\\n&&"),
          [2,
           0,
           [11,
            caml_string_of_jsbytes("\\ar[d,"),
            [2,
             0,
             [11,
              caml_string_of_jsbytes("]\\\\\n&&"),
              [2,0,[11,caml_string_of_jsbytes("\\ar[d,"),[2,0,partial$17]]]]]]]]]]],
     partial$19=
      [11,
       caml_string_of_jsbytes("\\ar[r,"),
       [2,
        0,
        [11,
         caml_string_of_jsbytes("']&"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("\\ar[r,"),
           [2,0,[11,caml_string_of_jsbytes("']&"),[2,0,0]]]]]]]],
     partial$20=
      [2,
       0,
       [11,
        caml_string_of_jsbytes("]\\\\\n&&"),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("\\ar[d,"),
          [2,
           0,
           [11,
            caml_string_of_jsbytes("]\\\\\n&&"),
            [2,
             0,
             [11,
              caml_string_of_jsbytes("\\ar[d,"),
              [2,0,[11,caml_string_of_jsbytes("]\\\\\n"),[2,0,partial$19]]]]]]]]]]],
     partial$21=
      [11,
       caml_string_of_jsbytes("]\\\\\n&&"),
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[d,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("]\\\\\n&&"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("\\ar[d,"),
             [2,
              0,
              [11,
               caml_string_of_jsbytes("]\\\\\n&&"),
               [2,0,[11,caml_string_of_jsbytes("\\ar[d,"),partial$20]]]]]]]]]]],
     partial$22=
      [2,
       0,
       [11,
        caml_string_of_jsbytes("\\ar[d,"),
        [2,
         0,
         [11,
          caml_string_of_jsbytes("]\\\\\n&&"),
          [2,
           0,
           [11,
            caml_string_of_jsbytes("\\ar[d,"),
            [2,
             0,
             [11,
              caml_string_of_jsbytes("]\\\\\n&&"),
              [2,0,[11,caml_string_of_jsbytes("\\ar[d,"),[2,0,partial$21]]]]]]]]]]],
     partial$23=
      [2,
       0,
       [11,
        caml_string_of_jsbytes("\\ar[d,"),
        [2,0,[11,caml_string_of_jsbytes("]\\\\\n"),0]]]],
     partial$24=
      [2,
       0,
       [11,
        caml_string_of_jsbytes("\\ar[d,"),
        [2,0,[11,caml_string_of_jsbytes("]\\\\\n"),0]]]],
     cst$24=caml_string_of_jsbytes(""),
     cst$27=caml_string_of_jsbytes("<-,"),
     cst$25=caml_string_of_jsbytes('}"'),
     cst$26=caml_string_of_jsbytes('"{'),
     cst$22=caml_string_of_jsbytes(""),
     cst$23=caml_string_of_jsbytes("\n"),
     cst$21=caml_string_of_jsbytes("\n"),
     cst$17=caml_string_of_jsbytes("."),
     cst$18=caml_string_of_jsbytes(")"),
     cst$19=caml_string_of_jsbytes("("),
     cst$20=caml_string_of_jsbytes("-"),
     cst_K=caml_string_of_jsbytes("K"),
     cst$15=caml_string_of_jsbytes("-> "),
     cst$16=caml_string_of_jsbytes(" -"),
     cst$10=caml_string_of_jsbytes(","),
     cst$11=caml_string_of_jsbytes(")"),
     cst$12=caml_string_of_jsbytes("("),
     cst$13=caml_string_of_jsbytes("-> "),
     cst$14=caml_string_of_jsbytes(" -"),
     cst$9=caml_string_of_jsbytes("\n"),
     cst$7=caml_string_of_jsbytes(" -> "),
     cst$8=caml_string_of_jsbytes(" : "),
     cst_Not_inversible=caml_string_of_jsbytes("Not inversible."),
     cst$4=caml_string_of_jsbytes("/"),
     cst$3=caml_string_of_jsbytes("]"),
     cst$5=caml_string_of_jsbytes(","),
     cst$6=caml_string_of_jsbytes("["),
     cst$2=caml_string_of_jsbytes(""),
     cst_x=caml_string_of_jsbytes("x"),
     cst=caml_string_of_jsbytes(")"),
     cst$0=caml_string_of_jsbytes(","),
     cst$1=caml_string_of_jsbytes("("),
     cst_Alg_Term_Not_unifiable=
      caml_string_of_jsbytes("Alg.Term.Not_unifiable"),
     cst_Alg_Term_RS_Not_confluent=
      caml_string_of_jsbytes("Alg.Term.RS.Not_confluent"),
     cst$41=caml_string_of_jsbytes(""),
     cst$37=caml_string_of_jsbytes(""),
     cst$38=caml_string_of_jsbytes(","),
     cst$36=caml_string_of_jsbytes(""),
     cst$39=caml_string_of_jsbytes("}"),
     cst$40=caml_string_of_jsbytes("{"),
     cst$32=caml_string_of_jsbytes(")"),
     cst$33=caml_string_of_jsbytes(","),
     cst$34=caml_string_of_jsbytes(","),
     cst$35=caml_string_of_jsbytes("("),
     cst$29=caml_string_of_jsbytes(")"),
     cst$30=caml_string_of_jsbytes(","),
     cst$31=caml_string_of_jsbytes("("),
     cst$28=caml_string_of_jsbytes("*"),
     cst$42=caml_string_of_jsbytes(""),
     cst$43=caml_string_of_jsbytes(""),
     cst$46=caml_string_of_jsbytes(""),
     cst_X=caml_string_of_jsbytes("X^"),
     cst$45=caml_string_of_jsbytes("+"),
     cst$44=caml_string_of_jsbytes(""),
     cst_T=caml_string_of_jsbytes("T"),
     cst_F=caml_string_of_jsbytes("F"),
     cst$48=caml_string_of_jsbytes(")"),
     cst$49=caml_string_of_jsbytes(")/("),
     cst$50=caml_string_of_jsbytes("("),
     cst$47=caml_string_of_jsbytes("."),
     cst_Cannot_invert=caml_string_of_jsbytes("Cannot invert "),
     cst_z=caml_string_of_jsbytes("z"),
     cst_z$0=caml_string_of_jsbytes("z^"),
     cst$52=caml_string_of_jsbytes(""),
     cst$53=caml_string_of_jsbytes("+"),
     cst$51=caml_string_of_jsbytes("+..."),
     cst_Cannot_implement_this=
      caml_string_of_jsbytes("Cannot implement this."),
     cst_TODO=caml_string_of_jsbytes("TODO"),
     cst$54=caml_string_of_jsbytes("]"),
     cst$55=caml_string_of_jsbytes("|"),
     cst$56=caml_string_of_jsbytes("["),
     cst$57=caml_string_of_jsbytes("]"),
     cst$58=caml_string_of_jsbytes("["),
     cst$61=caml_string_of_jsbytes("]"),
     cst$62=caml_string_of_jsbytes("|"),
     cst$63=caml_string_of_jsbytes("["),
     cst$59=caml_string_of_jsbytes("\xce\xb5"),
     cst$60=caml_string_of_jsbytes(""),
     cst$64=caml_string_of_jsbytes(""),
     cst$66=caml_string_of_jsbytes(" "),
     cst$65=caml_string_of_jsbytes("\n"),
     cst$85=caml_string_of_jsbytes(""),
     cst$86=caml_string_of_jsbytes("+"),
     cst$87=caml_string_of_jsbytes(""),
     cst$88=caml_string_of_jsbytes(")"),
     cst$89=caml_string_of_jsbytes("("),
     cst$90=caml_string_of_jsbytes("*"),
     cst$84=caml_string_of_jsbytes(""),
     cst$81=caml_string_of_jsbytes(""),
     cst$82=caml_string_of_jsbytes("\n"),
     cst$83=caml_string_of_jsbytes(":\n"),
     cst_d=caml_string_of_jsbytes("d"),
     cst$78=caml_string_of_jsbytes(""),
     cst$79=caml_string_of_jsbytes(""),
     cst$80=caml_string_of_jsbytes(" "),
     cst$77=caml_string_of_jsbytes(""),
     cst$75=caml_string_of_jsbytes("\n"),
     cst$76=caml_string_of_jsbytes(" -> "),
     cst$74=caml_string_of_jsbytes(""),
     cst$68=caml_string_of_jsbytes(""),
     cst$69=caml_string_of_jsbytes("+"),
     cst$70=caml_string_of_jsbytes(""),
     cst$71=caml_string_of_jsbytes("*"),
     cst$72=caml_string_of_jsbytes(")"),
     cst$73=caml_string_of_jsbytes("("),
     cst_0=caml_string_of_jsbytes("0"),
     cst$67=caml_string_of_jsbytes(""),
     empty$3=[0,0,0],
     cst$91=caml_string_of_jsbytes(" -> "),
     cst$92=caml_string_of_jsbytes(" : "),
     cst$94=caml_string_of_jsbytes("->"),
     cst$95=caml_string_of_jsbytes(":"),
     cst$93=caml_string_of_jsbytes(" , "),
     cst$96=caml_string_of_jsbytes(" , "),
     cst$97=caml_string_of_jsbytes("\n"),
     empty$4=[0,0,0],
     cst_f=caml_string_of_jsbytes("f"),
     cst_x$0=caml_string_of_jsbytes("x"),
     cst$98=caml_string_of_jsbytes("="),
     cst$99=caml_string_of_jsbytes(" , "),
     cst$100=caml_string_of_jsbytes("\n"),
     cst_id=caml_string_of_jsbytes("id"),
     cst$101=caml_string_of_jsbytes(")"),
     cst$102=caml_string_of_jsbytes("("),
     cst_0$0=caml_string_of_jsbytes("0"),
     cst_1=caml_string_of_jsbytes("1"),
     cst$103=caml_string_of_jsbytes("+"),
     cst$104=caml_string_of_jsbytes("."),
     cst$105=caml_string_of_jsbytes("*"),
     cst_not_in_the_kernel=caml_string_of_jsbytes(" not in the kernel.\n%!"),
     cst$107=caml_string_of_jsbytes(" -> "),
     cst$106=caml_string_of_jsbytes(" >"),
     cst$108=caml_string_of_jsbytes(" , "),
     cst$109=caml_string_of_jsbytes(" | "),
     cst$110=caml_string_of_jsbytes(" "),
     cst$111=caml_string_of_jsbytes("< "),
     cst_Alg_Algebra_Pres_K_X_Augme=
      caml_string_of_jsbytes("Alg.Algebra.Pres(K)(X).Augmentation.Invalid"),
     Stdlib_List=global_data.Stdlib__List,
     Stdlib_String=global_data.Stdlib__String,
     Stdlib=global_data.Stdlib,
     Stdlib_Printf=global_data.Stdlib__Printf,
     Assert_failure=global_data.Assert_failure,
     Stdlib_Filename=global_data.Stdlib__Filename,
     Stdlib_Map=global_data.Stdlib__Map,
     Stdlib_Set=global_data.Stdlib__Set,
     Stdlib_Array=global_data.Stdlib__Array,
     Stdlib_Weak=global_data.Stdlib__Weak,
     Stdlib_Queue=global_data.Stdlib__Queue,
     Alg=[0];
    caml_register_global(260,Alg,"Alg");
    var
     _aw_=
      [0,
       [11,
        caml_string_of_jsbytes("\nelim rule: ["),
        [2,0,[11,caml_string_of_jsbytes("] => "),[2,0,[12,10,[10,0]]]]]],
       caml_string_of_jsbytes("\nelim rule: [%s] => %s\n%!")],
     _av_=[0,caml_string_of_jsbytes("src/term.ml"),1353,6],
     _at_=
      [0,
       [11,
        caml_string_of_jsbytes("cd "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" && pdflatex "),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(" && evince `basename "),
            [2,0,[11,caml_string_of_jsbytes(" .tex`.pdf"),0]]]]]]],
       caml_string_of_jsbytes
        ("cd %s && pdflatex %s && evince `basename %s .tex`.pdf")],
     _au_=[0,caml_string_of_jsbytes("src/term.ml"),1339,6],
     _ac_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[d,bend right,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']\\ar[d,bend left,"),
           [2,0,[11,caml_string_of_jsbytes("]\\\\\n"),[2,0,0]]]]]]],
       caml_string_of_jsbytes
        ("%s\\ar[d,bend right,%s']\\ar[d,bend left,%s]\\\\\n%s")],
     _ad_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[dr,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']\\ar[r,"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("]&"),
             [2,
              0,
              [11,
               caml_string_of_jsbytes("\\ar[d,"),
               [2,0,[11,caml_string_of_jsbytes("]\\\\\n&"),partial]]]]]]]]]],
       caml_string_of_jsbytes
        ("%s\\ar[dr,%s']\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&%s")],
     _ae_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[drr,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']\\ar[r,"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("]&"),
             [2,
              0,
              [11,
               caml_string_of_jsbytes("\\ar[r,"),
               [2,0,[11,caml_string_of_jsbytes("]&"),partial$0]]]]]]]]]],
       caml_string_of_jsbytes
        ("%s\\ar[drr,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&&%s")],
     _af_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[ddrr,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']\\ar[r,"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("]&"),
             [2,
              0,
              [11,
               caml_string_of_jsbytes("\\ar[r,"),
               [2,0,[11,caml_string_of_jsbytes("]&"),partial$1]]]]]]]]]],
       caml_string_of_jsbytes
        ("%s\\ar[ddrr,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s")],
     _ag_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[dddrr,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']\\ar[r,"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("]&"),
             [2,
              0,
              [11,
               caml_string_of_jsbytes("\\ar[r,"),
               [2,0,[11,caml_string_of_jsbytes("]&"),partial$3]]]]]]]]]],
       caml_string_of_jsbytes
        ("%s\\ar[dddrr,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s")],
     _ah_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[ddddrr,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']\\ar[r,"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("]&"),
             [2,
              0,
              [11,
               caml_string_of_jsbytes("\\ar[r,"),
               [2,0,[11,caml_string_of_jsbytes("]&"),partial$5]]]]]]]]]],
       caml_string_of_jsbytes
        ("%s\\ar[ddddrr,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s")],
     _ai_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[d,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']\\ar[r,"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("]&"),
             [2,
              0,
              [11,
               caml_string_of_jsbytes("\\ar[d,"),
               [2,0,[11,caml_string_of_jsbytes("]\\\\\n"),partial$6]]]]]]]]]],
       caml_string_of_jsbytes
        ("%s\\ar[d,%s']\\ar[r,%s]&%s\\ar[d,%s]\\\\\n%s\\ar[r,%s']&%s")],
     _aj_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[d,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']\\ar[r,"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("]&"),
             [2,
              0,
              [11,
               caml_string_of_jsbytes("\\ar[r,"),
               [2,0,[11,caml_string_of_jsbytes("]&"),partial$7]]]]]]]]]],
       caml_string_of_jsbytes
        ("%s\\ar[d,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n%s\\ar[rr,%s']&&%s")],
     _ak_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[d,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']\\ar[r,"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("]&"),
             [2,
              0,
              [11,
               caml_string_of_jsbytes("\\ar[r,"),
               [2,0,[11,caml_string_of_jsbytes("]&"),partial$9]]]]]]]]]],
       caml_string_of_jsbytes
        ("%s\\ar[d,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n%s\\ar[rrr,%s']&&&%s")],
     _al_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[ddd,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']\\ar[r,"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("]&"),
             [2,
              0,
              [11,
               caml_string_of_jsbytes("\\ar[r,"),
               [2,0,[11,caml_string_of_jsbytes("]&"),partial$11]]]]]]]]]],
       caml_string_of_jsbytes
        ("%s\\ar[ddd,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n%s\\ar[r,%s']&%s\\ar[r,%s']&%s")],
     _am_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[dddddd,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']\\ar[r,"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("]&"),
             [2,
              0,
              [11,
               caml_string_of_jsbytes("\\ar[r,"),
               [2,0,[11,caml_string_of_jsbytes("]&"),partial$14]]]]]]]]]],
       caml_string_of_jsbytes
        ("%s\\ar[dddddd,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n%s\\ar[r,%s']&%s\\ar[r,%s']&%s")],
     _an_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[ddddddd,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']\\ar[r,"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("]&"),
             [2,
              0,
              [11,
               caml_string_of_jsbytes("\\ar[r,"),
               [2,0,[11,caml_string_of_jsbytes("]&"),partial$18]]]]]]]]]],
       caml_string_of_jsbytes
        ("%s\\ar[ddddddd,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n%s\\ar[r,%s']&%s\\ar[r,%s']&%s")],
     _ao_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[dddddddd,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']\\ar[r,"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("]&"),
             [2,
              0,
              [11,
               caml_string_of_jsbytes("\\ar[r,"),
               [2,0,[11,caml_string_of_jsbytes("]&"),partial$22]]]]]]]]]],
       caml_string_of_jsbytes
        ("%s\\ar[dddddddd,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n%s\\ar[r,%s']&%s\\ar[r,%s']&%s")],
     _S_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[d,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']\\ar[r,"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("]&"),
             [2,
              0,
              [11,
               caml_string_of_jsbytes("\\ar[r,"),
               [2,0,[11,caml_string_of_jsbytes("]&"),partial$23]]]]]]]]]],
       caml_string_of_jsbytes
        ("%s\\ar[d,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n")],
     _U_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[d,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']&&"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("\\ar[d,"),
             [2,0,[11,caml_string_of_jsbytes("]\\\\\n"),0]]]]]]]],
       caml_string_of_jsbytes("%s\\ar[d,%s']&&%s\\ar[d,%s]\\\\\n")],
     _T_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[rr,"),
         [2,0,[11,caml_string_of_jsbytes("']&&"),[2,0,0]]]]],
       caml_string_of_jsbytes("%s\\ar[rr,%s']&&%s")],
     _V_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[d,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']\\ar[r,"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("]&"),
             [2,
              0,
              [11,
               caml_string_of_jsbytes("\\ar[r,"),
               [2,0,[11,caml_string_of_jsbytes("]&"),partial$24]]]]]]]]]],
       caml_string_of_jsbytes
        ("%s\\ar[d,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n")],
     _X_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[d,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']&&"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("\\ar[d,"),
             [2,0,[11,caml_string_of_jsbytes("]\\\\\n"),0]]]]]]]],
       caml_string_of_jsbytes("%s\\ar[d,%s']&&%s\\ar[d,%s]\\\\\n")],
     _W_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("\\ar[r,"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("']&"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("\\ar[r,"),
             [2,0,[11,caml_string_of_jsbytes("']&"),[2,0,0]]]]]]]]],
       caml_string_of_jsbytes("%s\\ar[r,%s']&%s\\ar[r,%s']&%s")],
     _Y_=
      [0,
       [11,
        caml_string_of_jsbytes("TODO: "),
        [4,0,0,0,[11,caml_string_of_jsbytes(", "),[4,0,0,0,[12,10,0]]]]],
       caml_string_of_jsbytes("TODO: %d, %d\n")],
     _Z_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     ___=
      [0,
       [11,caml_string_of_jsbytes("zzlen: "),[4,0,0,0,[12,10,[10,0]]]],
       caml_string_of_jsbytes("zzlen: %d\n%!")],
     _$_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _ab_=
      [0,
       [11,
        caml_string_of_jsbytes("\\ar[r,"),
        [2,0,[11,caml_string_of_jsbytes("]&"),[2,0,0]]]],
       caml_string_of_jsbytes("\\ar[r,%s]&%s")],
     _aa_=
      [0,[11,caml_string_of_jsbytes("\\\\"),0],caml_string_of_jsbytes("\\\\")],
     _Q_=
      [0,
       [11,
        caml_string_of_jsbytes("print "),
        [2,0,[11,caml_string_of_jsbytes(": "),[2,0,[12,10,[10,0]]]]]],
       caml_string_of_jsbytes("print %s: %s\n%!")],
     _R_=
      [0,
       [11,
        caml_string_of_jsbytes("split: "),
        [2,0,[11,caml_string_of_jsbytes(" / "),[2,0,[12,10,[10,0]]]]]],
       caml_string_of_jsbytes("split: %s / %s\n%!")],
     _ap_=
      [0,
       [11,
        caml_string_of_jsbytes("\\noindent\n\\subsection*{"),
        [2,0,[11,caml_string_of_jsbytes("}\n"),0]]],
       caml_string_of_jsbytes("\\noindent\n\\subsection*{%s}\n")],
     _aq_=
      [0,
       [11,caml_string_of_jsbytes("\\[\n\\begin{tikzcd}\n"),0],
       caml_string_of_jsbytes("\\[\n\\begin{tikzcd}\n")],
     _ar_=
      [0,
       [11,caml_string_of_jsbytes("\n\\end{tikzcd}\n\\]\n\n"),0],
       caml_string_of_jsbytes("\n\\end{tikzcd}\n\\]\n\n")],
     _N_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(" &: "),
         [2,
          0,
          [11,
           caml_string_of_jsbytes(" \\to "),
           [2,0,[11,caml_string_of_jsbytes("\\\\"),0]]]]]],
       caml_string_of_jsbytes("%s &: %s \\to %s\\\\")],
     _M_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("\\documentclass[a4paper,9pt]{extarticle}\n\\usepackage[utf8x]{inputenc}\n\\usepackage{amsmath}\n\\usepackage{tikz-cd}\n\\usepackage[margin=1cm,includefoot]{geometry}\n\\title{Coherent presentation}\n\\author{ocaml-alg}\n\n\\begin{document}\n\\maketitle\n\n"),
        0],
       caml_string_of_jsbytes
        ("\\documentclass[a4paper,9pt]{extarticle}\n\\usepackage[utf8x]{inputenc}\n\\usepackage{amsmath}\n\\usepackage{tikz-cd}\n\\usepackage[margin=1cm,includefoot]{geometry}\n\\title{Coherent presentation}\n\\author{ocaml-alg}\n\n\\begin{document}\n\\maketitle\n\n")],
     _O_=
      [0,
       [11,
        caml_string_of_jsbytes("\\section{Rules}\n\n\\begin{align*}\n"),
        [2,0,[11,caml_string_of_jsbytes("\n\\end{align*}\n\n"),0]]],
       caml_string_of_jsbytes
        ("\\section{Rules}\n\n\\begin{align*}\n%s\n\\end{align*}\n\n")],
     _P_=
      [0,
       [11,caml_string_of_jsbytes("\\section{Coherence}\n\n"),0],
       caml_string_of_jsbytes("\\section{Coherence}\n\n")],
     _as_=
      [0,
       [11,caml_string_of_jsbytes("\\end{document}\n"),0],
       caml_string_of_jsbytes("\\end{document}\n")],
     _L_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(": "),[2,0,[12,10,0]]]],
       caml_string_of_jsbytes("%s: %s\n")],
     _K_=[0,caml_string_of_jsbytes("src/term.ml"),1052,6],
     _J_=[0,caml_string_of_jsbytes("src/term.ml"),1053,6],
     _I_=[0,caml_string_of_jsbytes("src/term.ml"),1042,6],
     _s_=[0,1],
     _t_=[0,1],
     _v_=[0,caml_string_of_jsbytes("src/term.ml"),830,14],
     _D_=[0,caml_string_of_jsbytes("src/term.ml"),975,13],
     _F_=[0,caml_string_of_jsbytes("src/term.ml"),985,13],
     _E_=[0,caml_string_of_jsbytes("src/term.ml"),982,13],
     _H_=[0,caml_string_of_jsbytes("src/term.ml"),1012,84],
     _G_=[0,caml_string_of_jsbytes("src/term.ml"),997,15],
     _w_=[0,caml_string_of_jsbytes("src/term.ml"),937,10],
     _x_=[0,caml_string_of_jsbytes("src/term.ml"),938,10],
     _z_=[0,caml_string_of_jsbytes("src/term.ml"),943,18],
     _y_=[0,caml_string_of_jsbytes("src/term.ml"),944,15],
     _C_=[0,caml_string_of_jsbytes("src/term.ml"),933,6],
     _B_=[0,caml_string_of_jsbytes("src/term.ml"),947,6],
     _A_=[0,caml_string_of_jsbytes("src/term.ml"),948,6],
     _u_=[0,caml_string_of_jsbytes("src/term.ml"),821,6],
     _r_=
      [0,
       [11,
        caml_string_of_jsbytes("not confluent:\n"),
        [2,0,[12,10,[2,0,[12,10,[10,0]]]]]],
       caml_string_of_jsbytes("not confluent:\n%s\n%s\n%!")],
     _q_=
      [0,
       [11,
        caml_string_of_jsbytes("add "),
        [2,
         0,
         [12,
          10,
          [2,0,[12,10,[2,0,[11,caml_string_of_jsbytes("\n\n"),[10,0]]]]]]]],
       caml_string_of_jsbytes("add %s\n%s\n%s\n\n%!")],
     _p_=[0,caml_string_of_jsbytes("src/term.ml"),678,12],
     _m_=[0,caml_string_of_jsbytes("src/term.ml"),606,9],
     _o_=[0,caml_string_of_jsbytes("src/term.ml"),649,31],
     _n_=[0,caml_string_of_jsbytes("src/term.ml"),639,21],
     _l_=[0,caml_string_of_jsbytes("src/term.ml"),592,6],
     _k_=[0,caml_string_of_jsbytes("src/term.ml"),483,6],
     _j_=[0,caml_string_of_jsbytes("src/term.ml"),484,6],
     _i_=[0,caml_string_of_jsbytes("src/term.ml"),476,6],
     _h_=[0,caml_string_of_jsbytes("src/term.ml"),473,20],
     _g_=[0,caml_string_of_jsbytes("src/term.ml"),381,14],
     _f_=[0,caml_string_of_jsbytes("src/term.ml"),316,2],
     _d_=[0,caml_string_of_jsbytes("src/term.ml"),130,16],
     _e_=[0,caml_string_of_jsbytes("src/term.ml"),131,16],
     _c_=[0,caml_string_of_jsbytes("src/term.ml"),88,6],
     _b_=[0,caml_string_of_jsbytes("src/term.ml"),78,2],
     _a_=
      [0,
       caml_string_of_jsbytes("x"),
       caml_string_of_jsbytes("y"),
       caml_string_of_jsbytes("z"),
       caml_string_of_jsbytes("t"),
       caml_string_of_jsbytes("u"),
       caml_string_of_jsbytes("v"),
       caml_string_of_jsbytes("w")],
     _ax_=[0,caml_string_of_jsbytes("src/field.ml"),83,6],
     _ay_=[0,caml_string_of_jsbytes("src/series.ml"),74,4],
     _az_=[0,caml_string_of_jsbytes("src/series.ml"),90,4],
     _aA_=[0,caml_string_of_jsbytes("src/precategory.ml"),59,22],
     _aB_=[0,caml_string_of_jsbytes("src/precategory.ml"),98,6],
     _aD_=[0,caml_string_of_jsbytes("src/monoid.ml"),232,24],
     _aC_=[0,caml_string_of_jsbytes("src/monoid.ml"),122,57],
     _aF_=[0,caml_string_of_jsbytes("src/matrix.ml"),60,6],
     _aE_=[0,caml_string_of_jsbytes("src/matrix.ml"),54,6],
     _aH_=
      [0,
       [11,caml_string_of_jsbytes("invalid: "),[4,0,0,0,[12,10,[10,0]]]],
       caml_string_of_jsbytes("invalid: %d\n%!")],
     _aI_=
      [0,
       [11,
        caml_string_of_jsbytes("d("),
        [2,0,[11,caml_string_of_jsbytes(") = "),[2,0,[12,10,[10,0]]]]]],
       caml_string_of_jsbytes("d(%s) = %s\n%!")],
     _aJ_=
      [0,
       [11,
        caml_string_of_jsbytes("d^2("),
        [2,0,[11,caml_string_of_jsbytes(") = "),[2,0,[12,10,[10,0]]]]]],
       caml_string_of_jsbytes("d^2(%s) = %s\n%!")],
     _aG_=[0,caml_string_of_jsbytes("src/module.ml"),233,8],
     _aL_=[0,caml_string_of_jsbytes("src/hypergraph.ml"),82,4],
     _aK_=[0,caml_string_of_jsbytes("src/hypergraph.ml"),78,4],
     _aT_=[0,caml_string_of_jsbytes("src/globular.ml"),77,4],
     _aS_=[0,caml_string_of_jsbytes("src/globular.ml"),78,4],
     _aR_=[0,caml_string_of_jsbytes("src/globular.ml"),80,4],
     _aQ_=[0,caml_string_of_jsbytes("src/globular.ml"),68,4],
     _aP_=[0,caml_string_of_jsbytes("src/globular.ml"),60,4],
     _aO_=[0,caml_string_of_jsbytes("src/globular.ml"),62,4],
     _aN_=[0,caml_string_of_jsbytes("src/globular.ml"),34,4],
     _aM_=[0,caml_string_of_jsbytes("src/globular.ml"),30,4],
     _aW_=[0,caml_string_of_jsbytes("src/category.ml"),52,4],
     _aV_=[0,caml_string_of_jsbytes("src/category.ml"),53,4],
     _aU_=[0,caml_string_of_jsbytes("src/category.ml"),27,4],
     _aZ_=[0,caml_string_of_jsbytes("src/algebra.ml"),322,16],
     _aY_=[0,caml_string_of_jsbytes("src/algebra.ml"),287,30],
     _a3_=[0,caml_string_of_jsbytes("src/algebra.ml"),288,8],
     _a0_=
      [0,
       [11,
        caml_string_of_jsbytes("failed (non-reducible): "),
        [2,0,[12,10,[10,0]]]],
       caml_string_of_jsbytes("failed (non-reducible): %s\n%!")],
     _a1_=
      [0,
       [11,caml_string_of_jsbytes("leading: "),[2,0,[12,10,[10,0]]]],
       caml_string_of_jsbytes("leading: %s\n%!")],
     _a2_=[0,caml_string_of_jsbytes("src/algebra.ml"),353,14],
     _aX_=[0,caml_string_of_jsbytes("src/algebra.ml"),191,6];
    function namer(eq)
     {var n=[0,0],names=[0,0];
      return function(e)
       {var _uv_=names[1];
        function _uw_(param){var e$0=param[1];return caml_call2(eq,e,e$0)}
        if(1 - caml_call2(Stdlib_List[33],_uw_,_uv_))
         {names[1] = [0,[0,e,n[1]],names[1]];n[1]++}
        var _ux_=names[1];
        function _uy_(param){var e$0=param[1];return caml_call2(eq,e,e$0)}
        return caml_call2(Stdlib_List[38],_uy_,_ux_)[2]}}
    var Alg_Utils=[0,namer];
    caml_register_global(262,Alg_Utils,"Alg__Utils");
    function tm_ctx(x){return x}
    function pair(x,y){return [0,x,y]}
    function unpair(f,param)
     {var y=param[2],x=param[1];return caml_call2(f,x,y)}
    function symbol(x,f){return caml_call1(f,x)}
    function modulo(x,y)
     {var ans=runtime.caml_mod(x,y);return 0 <= ans?ans:ans + y | 0}
    var
     Int=[0,modulo],
     length=Stdlib_List[1],
     compare_lengths=Stdlib_List[2],
     compare_length_with=Stdlib_List[3],
     cons=Stdlib_List[4],
     hd=Stdlib_List[5],
     tl=Stdlib_List[6],
     nth=Stdlib_List[7],
     nth_opt=Stdlib_List[8],
     rev=Stdlib_List[9],
     init=Stdlib_List[10],
     append=Stdlib_List[11],
     rev_append=Stdlib_List[12],
     concat=Stdlib_List[13],
     flatten=Stdlib_List[14],
     equal=Stdlib_List[15],
     compare=Stdlib_List[16],
     iter=Stdlib_List[17],
     iteri=Stdlib_List[18],
     map=Stdlib_List[19],
     mapi=Stdlib_List[20],
     rev_map=Stdlib_List[21],
     filter_map=Stdlib_List[22],
     concat_map=Stdlib_List[23],
     fold_left_map=Stdlib_List[24],
     fold_left=Stdlib_List[25],
     fold_right=Stdlib_List[26],
     iter2=Stdlib_List[27],
     map2=Stdlib_List[28],
     rev_map2=Stdlib_List[29],
     fold_left2=Stdlib_List[30],
     fold_right2=Stdlib_List[31],
     for_all=Stdlib_List[32],
     exists=Stdlib_List[33],
     for_all2=Stdlib_List[34],
     exists2=Stdlib_List[35],
     mem=Stdlib_List[36],
     memq=Stdlib_List[37],
     find=Stdlib_List[38],
     find_opt=Stdlib_List[39],
     find_map=Stdlib_List[40],
     filter=Stdlib_List[41],
     find_all=Stdlib_List[42],
     filteri=Stdlib_List[43],
     partition=Stdlib_List[44],
     partition_map=Stdlib_List[45],
     assoc=Stdlib_List[46],
     assoc_opt=Stdlib_List[47],
     assq=Stdlib_List[48],
     assq_opt=Stdlib_List[49],
     mem_assoc=Stdlib_List[50],
     mem_assq=Stdlib_List[51],
     remove_assoc=Stdlib_List[52],
     remove_assq=Stdlib_List[53],
     split=Stdlib_List[54],
     combine=Stdlib_List[55],
     sort=Stdlib_List[56],
     stable_sort=Stdlib_List[57],
     fast_sort=Stdlib_List[58],
     sort_uniq=Stdlib_List[59],
     merge=Stdlib_List[60],
     to_seq=Stdlib_List[61],
     of_seq=Stdlib_List[62];
    function index(p,param)
     {var n=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return n;
          var n$0=n + 1 | 0,n=n$0,param$0=l;
          continue}
        throw Stdlib[8]}}
    function replace_nth(param,n,x)
     {var n$0=n,k=tm_ctx,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],y=param$0[1];
          if(0 === n$0)return k([0,x,l]);
          var
           k$1=function(k,y){function k$0(l){return k([0,y,l])}return k$0},
           k$0=k$1(k,y),
           n$1=n$0 - 1 | 0,
           n$0=n$1,
           k=k$0,
           param$0=l;
          continue}
        throw Stdlib[8]}}
    function replace_assoc(k,v,l)
     {function _uu_(param)
       {var v$0=param[2],k$0=param[1];
        return caml_equal(k,k$0)?[0,k,v]:[0,k$0,v$0]}
      return caml_call2(Stdlib_List[19],_uu_,l)}
    function sub(l,ofs,len)
     {var l$0=l,ofs$0=ofs;
      for(;;)
       {if(0 === ofs$0 && 0 === len)return 0;
        if(l$0)
         {var l$1=l$0[2],x=l$0[1];
          if(0 === ofs$0)return [0,x,sub(l$1,ofs$0,len - 1 | 0)];
          var ofs$1=ofs$0 - 1 | 0,l$0=l$1,ofs$0=ofs$1;
          continue}
        return caml_call1(Stdlib[1],cst_List_sub)}}
    var
     List=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       concat,
       flatten,
       equal,
       compare,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       filter_map,
       concat_map,
       fold_left_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       filter,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       sort,
       stable_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq,
       index,
       replace_nth,
       replace_assoc,
       sub],
     make=Stdlib_String[1],
     init$0=Stdlib_String[2],
     empty=Stdlib_String[3],
     of_bytes=Stdlib_String[4],
     to_bytes=Stdlib_String[5],
     concat$0=Stdlib_String[6],
     cat=Stdlib_String[7],
     equal$0=Stdlib_String[8],
     compare$0=Stdlib_String[9],
     starts_with=Stdlib_String[10],
     ends_with=Stdlib_String[11],
     contains_from=Stdlib_String[12],
     rcontains_from=Stdlib_String[13],
     contains=Stdlib_String[14],
     sub$0=Stdlib_String[15],
     split_on_char=Stdlib_String[16],
     map$0=Stdlib_String[17],
     mapi$0=Stdlib_String[18],
     fold_left$0=Stdlib_String[19],
     fold_right$0=Stdlib_String[20],
     for_all$0=Stdlib_String[21],
     exists$0=Stdlib_String[22],
     trim=Stdlib_String[23],
     escaped=Stdlib_String[24],
     uppercase_ascii=Stdlib_String[25],
     lowercase_ascii=Stdlib_String[26],
     capitalize_ascii=Stdlib_String[27],
     uncapitalize_ascii=Stdlib_String[28],
     iter$0=Stdlib_String[29],
     iteri$0=Stdlib_String[30],
     index_from=Stdlib_String[31],
     index_from_opt=Stdlib_String[32],
     rindex_from=Stdlib_String[33],
     rindex_from_opt=Stdlib_String[34],
     index$0=Stdlib_String[35],
     index_opt=Stdlib_String[36],
     rindex=Stdlib_String[37],
     rindex_opt=Stdlib_String[38],
     to_seq$0=Stdlib_String[39],
     to_seqi=Stdlib_String[40],
     of_seq$0=Stdlib_String[41],
     blit=Stdlib_String[42],
     copy=Stdlib_String[43],
     fill=Stdlib_String[44],
     uppercase=Stdlib_String[45],
     lowercase=Stdlib_String[46],
     capitalize=Stdlib_String[47],
     uncapitalize=Stdlib_String[48],
     get_uint8=Stdlib_String[49],
     get_int8=Stdlib_String[50],
     get_uint16_ne=Stdlib_String[51],
     get_uint16_be=Stdlib_String[52],
     get_uint16_le=Stdlib_String[53],
     get_int16_ne=Stdlib_String[54],
     get_int16_be=Stdlib_String[55],
     get_int16_le=Stdlib_String[56],
     get_int32_ne=Stdlib_String[57],
     get_int32_be=Stdlib_String[58],
     get_int32_le=Stdlib_String[59],
     get_int64_ne=Stdlib_String[60],
     get_int64_be=Stdlib_String[61],
     get_int64_le=Stdlib_String[62];
    function find$0(p,s)
     {var ans=[0,-1];
      try
       {var _ur_=caml_ml_string_length(s) - 1 | 0,_uq_=0;
        if(! (_ur_ < 0))
         {var i=_uq_;
          for(;;)
           {if(caml_call1(p,caml_string_get(s,i))){ans[1] = i;throw Stdlib[3]}
            var _us_=i + 1 | 0;
            if(_ur_ !== i){var i=_us_;continue}
            break}}
        throw Stdlib[8]}
      catch(_ut_)
       {_ut_ = caml_wrap_exception(_ut_);
        if(_ut_ === Stdlib[3])return ans[1];
        throw _ut_}}
    function split_on_predicate(p,s)
     {try
       {var
         n=find$0(p,s),
         _un_=
          split_on_predicate
           (p,
            caml_call3
             (Stdlib_String[15],
              s,
              n + 1 | 0,
              caml_ml_string_length(s) - (n + 1 | 0) | 0)),
         _uo_=[0,caml_call3(Stdlib_String[15],s,0,n),_un_];
        return _uo_}
      catch(_up_)
       {_up_ = caml_wrap_exception(_up_);
        if(_up_ === Stdlib[8])return [0,s,0];
        throw _up_}}
    var
     String=
      [0,
       make,
       init$0,
       empty,
       of_bytes,
       to_bytes,
       concat$0,
       cat,
       equal$0,
       compare$0,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub$0,
       split_on_char,
       map$0,
       mapi$0,
       fold_left$0,
       fold_right$0,
       for_all$0,
       exists$0,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter$0,
       iteri$0,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index$0,
       index_opt,
       rindex,
       rindex_opt,
       to_seq$0,
       to_seqi,
       of_seq$0,
       blit,
       copy,
       fill,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       find$0,
       split_on_predicate],
     Alg_Extlib=[0,tm_ctx,pair,unpair,symbol,Int,List,String];
    caml_register_global(265,Alg_Extlib,"Alg__Extlib");
    function name(f){return f[2]}
    function weight(f){return f[1]}
    function arity(f){return f[3]}
    function make$0(to_string,opt,name,arity)
     {if(opt)var sth=opt[1],weight=sth;else var weight=0;
      if(to_string)
       var to_string$0=to_string[1],to_string$1=to_string$0;
      else
       var
        to_string$1=
         function(a)
          {var
            _uk_=caml_call2(String[6],cst$0,a),
            _ul_=caml_call2(Stdlib[28],_uk_,cst),
            _um_=caml_call2(Stdlib[28],cst$1,_ul_);
           return caml_call2(Stdlib[28],name,_um_)};
      return [0,weight,name,arity,to_string$1]}
    function eq(f1,f2)
     {var _uh_=caml_string_equal(f1[2],f2[2]);
      if(_uh_)
       var _ui_=f1[3] === f2[3]?1:0,_uj_=_ui_?f1[1] === f2[1]?1:0:_ui_;
      else
       var _uj_=_uh_;
      return _uj_}
    function to_string(f,a){return caml_call1(f[4],a)}
    var Op=[0,name,weight,arity,make$0,eq,to_string];
    function fresh(param){return [0,0]}
    function eq$0(x,y){return x === y?1:0}
    function namer$0(param)
     {var f=namer(eq$0);
      return function(x)
       {var _uf_=caml_call1(f,x),_ug_=caml_call1(Stdlib[33],_uf_);
        return caml_call2(Stdlib[28],cst_x,_ug_)}}
    function namer_natural(param)
     {var f=namer(eq$0),name=_a_.slice();
      return function(x)
       {var _ue_=caml_call1(f,x);return caml_check_bound(name,_ue_)[1 + _ue_]}}
    var
     to_string$0=namer$0(0),
     Var=[0,fresh,eq$0,namer$0,namer_natural,to_string$0];
    function var$0(param){return [1,caml_call1(Var[1],0)]}
    function app(f,a)
     {var _ud_=caml_call1(Op[3],f);
      if(caml_call1(List[1],a) === _ud_)return [0,f,a];
      throw [0,Assert_failure,_b_]}
    function parser(s)
     {function term(s)
       {var s$0=caml_call1(String[23],s);
        try
         {var
           n=caml_call2(String[35],s$0,40),
           f=caml_call3(String[15],s$0,0,n);
          if(41 === caml_string_get(s$0,caml_ml_string_length(s$0) - 1 | 0))
           {var
             a=
              caml_call3
               (String[15],
                s$0,
                n + 1 | 0,
                (caml_ml_string_length(s$0) - (n + 1 | 0) | 0) - 1 | 0);
            if(caml_string_equal(a,cst$2))
             var a$0=0;
            else
             var
              k=[0,0],
              p=
               function(param)
                {var switcher=param - 40 | 0;
                 if(! (4 < switcher >>> 0))
                  switch(switcher)
                   {case 0:k[1]++;return 0;
                    case 1:k[1] += -1;return 0;
                    case 4:return 0 === k[1]?1:0
                    }
                 return 0},
              a$0=caml_call2(String[64],p,a);
            var a$1=caml_call2(List[19],term,a$0),_ub_=[0,3257473,[0,f,a$1]];
            return _ub_}
          throw [0,Assert_failure,_c_]}
        catch(_uc_)
         {_uc_ = caml_wrap_exception(_uc_);
          if(_uc_ === Stdlib[8])return [0,4298439,s$0];
          throw _uc_}}
      function step(s)
       {var s$0=caml_call1(String[23],s);
        return 45 === caml_string_get(s$0,caml_ml_string_length(s$0) - 1 | 0)
                ?[0,
                  3654865,
                  term
                   (caml_call3
                     (String[15],s$0,0,caml_ml_string_length(s$0) - 1 | 0))]
                :term(s$0)}
      var l=caml_call2(String[16],46,s);
      return 1 === caml_call1(List[1],l)
              ?step(caml_call1(List[5],l))
              :[0,4150143,caml_call2(List[19],step,l)]}
    var vars=[0,0];
    function parse_var(x)
     {if(1 - caml_call2(List[50],x,vars[1]))
       {var _ua_=vars[1];vars[1] = [0,[0,x,caml_call1(Var[1],0)],_ua_]}
      return caml_call2(List[46],x,vars[1])}
    function parse(ops,s)
     {function aux(param)
       {var _t__=param[1];
        if(4150143 <= _t__)
         {if(4298439 <= _t__){var x=param[2];return [1,parse_var(x)]}
          throw [0,Assert_failure,_d_]}
        if(3654865 <= _t__)throw [0,Assert_failure,_e_];
        var match=param[2],a=match[2],f=match[1];
        function _t$_(o){return caml_string_equal(caml_call1(Op[1],o),f)}
        var f$0=caml_call2(List[38],_t$_,ops),a$0=caml_call2(List[19],aux,a);
        return app(f$0,a$0)}
      return aux(parser(s))}
    function eq$1(t1,t2)
     {if(0 === t1[0])
       {var _t3_=t1[2],_t4_=t1[1];
        if(0 === t2[0])
         {var a2=t2[2],f2=t2[1],_t5_=caml_call2(Op[5],_t4_,f2);
          if(_t5_)
           {var
             _t6_=caml_call1(List[1],a2),
             _t7_=caml_call1(List[1],_t3_) === _t6_?1:0;
            if(_t7_)return caml_call3(List[34],eq$1,_t3_,a2);
            var _t8_=_t7_}
          else
           var _t8_=_t5_;
          return _t8_}}
      else
       {var _t9_=t1[1];
        if(0 !== t2[0]){var y=t2[1];return caml_call2(Var[2],_t9_,y)}}
      return 0}
    function to_string$1(opt,param)
     {if(opt)var sth=opt[1],var$0=sth;else var var$0=Var[5];
      if(0 === param[0])
       {var
         a=param[2],
         f=param[1],
         _tZ_=[0,var$0],
         _t0_=function(_t2_){return to_string$1(_tZ_,_t2_)},
         _t1_=caml_call2(List[19],_t0_,a);
        return caml_call2(Op[6],f,_t1_)}
      var x=param[1];
      return caml_call1(var$0,x)}
    function string_of_term(var$0)
     {return function(_tY_){return to_string$1(var$0,_tY_)}}
    function is_var(param){return 0 === param[0]?0:1}
    function get_var(param)
     {if(0 === param[0])throw Stdlib[8];var x=param[1];return x}
    function vars$0(t)
     {function aux(vars,param)
       {if(0 === param[0])
         {var a=param[2],_tW_=function(vars,t){return aux(vars,t)};
          return caml_call3(List[25],_tW_,vars,a)}
        var x=param[1],_tX_=caml_call1(Var[2],x);
        return caml_call2(List[33],_tX_,vars)?vars:[0,x,vars]}
      var _tV_=aux(0,t);
      return caml_call1(List[9],_tV_)}
    function occurs(x,param)
     {if(0 === param[0])
       {var a=param[2],_tT_=function(_tU_){return occurs(x,_tU_)};
        return caml_call2(List[33],_tT_,a)}
      var y=param[1];
      return caml_call2(Var[2],x,y)}
    function ge(ge_op,t,u){var _tS_=eq$1(t,u);return _tS_?_tS_:gt(ge_op,t,u)}
    function gt(ge_op,t,u)
     {if(0 === u[0])
       {if(0 === t[0])
         {var
           b=u[2],
           g=u[1],
           a=t[2],
           f=t[1],
           _tN_=function(t){return ge(ge_op,t,u)};
          if(caml_call2(List[33],_tN_,a))return 1;
          if(caml_call2(Op[5],f,g))
           {var
             _tO_=function(u){return gt(ge_op,t,u)},
             _tP_=caml_call2(List[32],_tO_,b);
            if(_tP_)
             {var l1=a,l2=b;
              for(;;)
               {if(l1 && l2)
                 {var x2=l2[1],l1$0=l1[2],x1=l1[1],l2$0=l2[2];
                  if(eq$1(x1,x2)){var l1=l1$0,l2=l2$0;continue}
                  if(gt(ge_op,x1,x2))return 1}
                return 0}}
            return _tP_}
          if(caml_call2(ge_op,f,g))
           {var _tQ_=function(u){return gt(ge_op,t,u)};
            return caml_call2(List[32],_tQ_,b)}
          return 0}
        return 0}
      var x=u[1],_tR_=1 - eq$1(t,u);
      return _tR_?occurs(x,t):_tR_}
    var LPO=[0,gt,ge];
    function to_string$2(var$0,s)
     {function _tG_(param)
       {var
         t=param[2],
         x=param[1],
         _tK_=to_string$1(var$0,[1,x]),
         _tL_=caml_call2(Stdlib[28],cst$4,_tK_),
         _tM_=to_string$1(var$0,t);
        return caml_call2(Stdlib[28],_tM_,_tL_)}
      var
       _tH_=caml_call2(List[19],_tG_,s),
       _tI_=caml_call2(String[6],cst$5,_tH_),
       _tJ_=caml_call2(Stdlib[28],_tI_,cst$3);
      return caml_call2(Stdlib[28],cst$6,_tJ_)}
    var empty$0=0;
    function id(vars)
     {function _tF_(x){return [0,x,[1,x]]}
      return caml_call2(List[19],_tF_,vars)}
    function rename(vars)
     {function _tE_(x){return [0,x,[1,caml_call1(Var[1],0)]]}
      return caml_call2(List[19],_tE_,vars)}
    function simple(x,t){return [0,[0,x,t],0]}
    function add(s,x,t){return [0,[0,x,t],s]}
    function find$1(s,x)
     {var s$0=s;
      for(;;)
       {if(s$0)
         {var s$1=s$0[2],match=s$0[1],t=match[2],y=match[1];
          if(caml_call2(Var[2],x,y))return t;
          var s$0=s$1;
          continue}
        throw Stdlib[8]}}
    function app$0(s,param)
     {if(0 === param[0])
       {var a=param[2],g=param[1],_tA_=function(_tD_){return app$0(s,_tD_)};
        return [0,g,caml_call2(List[19],_tA_,a)]}
      var x=param[1];
      try
       {var _tB_=find$1(s,x);return _tB_}
      catch(_tC_)
       {_tC_ = caml_wrap_exception(_tC_);
        if(_tC_ === Stdlib[8])return [1,x];
        throw _tC_}}
    function compose(s$0,s)
     {function _tz_(param){var t=param[2],x=param[1];return [0,x,app$0(s,t)]}
      return caml_call2(List[19],_tz_,s$0)}
    function eq$2(s1,s2)
     {function included(s1,s2)
       {function _ty_(param)
         {var t=param[2],x=param[1];return eq$1(t,app$0(s2,[1,x]))}
        return caml_call2(List[32],_ty_,s1)}
      var _tx_=included(s1,s2);
      return _tx_?included(s2,s1):_tx_}
    function is_renaming(s)
     {function _tw_(param){var t=param[2];return is_var(t)}
      return caml_call2(List[32],_tw_,s)}
    function is_injective_renaming(param)
     {var vars=0,param$0=param;
      for(;;)
       {if(param$0)
         {var s=param$0[2],match=param$0[1],t=match[2];
          if(is_var(t))
           {var x=get_var(t),_tv_=caml_call1(Var[2],x);
            if(caml_call2(List[33],_tv_,vars))return 0;
            var vars$0=[0,x,vars],vars=vars$0,param$0=s;
            continue}
          return 0}
        return 1}}
    function inv(s)
     {function _tu_(param)
       {var t=param[2],x=param[1];
        if(0 === t[0])return caml_call1(Stdlib[2],cst_Not_inversible);
        var y=t[1];
        return [0,y,[1,x]]}
      return caml_call2(List[19],_tu_,s)}
    function domain(s)
     {function _ts_(_tt_){return _tt_[1]}return caml_call2(List[19],_ts_,s)}
    function in_dom(s,x)
     {function _tr_(param){var y=param[1];return caml_call2(Var[2],y,x)}
      return caml_call2(List[33],_tr_,s)}
    function restrict(vars,s)
     {function _tp_(param)
       {var x=param[1],_tq_=caml_call1(Var[2],x);
        return caml_call2(List[33],_tq_,vars)}
      return caml_call2(List[41],_tp_,s)}
    var
     Substitution=
      [0,
       to_string$2,
       empty$0,
       id,
       rename,
       simple,
       add,
       find$1,
       app$0,
       compose,
       eq$2,
       is_renaming,
       is_injective_renaming,
       inv,
       domain,
       in_dom,
       restrict],
     Not_unifiable=[248,cst_Alg_Term_Not_unifiable,caml_fresh_oo_id(0)];
    function unify(t1,t2)
     {var q$4=[0,[0,t1,t2],0],q=q$4,s=Substitution[2];
      for(;;)
       {if(q)
         {var q$0=q[2],p=q[1],_th_=p[1];
          if(0 === _th_[0])
           {var _ti_=p[2],_tj_=_th_[2],_tk_=_th_[1];
            if(0 === _ti_[0])
             {var a2=_ti_[2],f2=_ti_[1];
              if(1 - caml_call2(Op[5],_tk_,f2))throw Not_unifiable;
              var
               _tl_=caml_call3(List[28],pair,_tj_,a2),
               q$1=caml_call2(Stdlib[37],_tl_,q$0),
               q=q$1;
              continue}
            var match=p[2],x=match[1],q$2=[0,[0,[1,x],_th_],q$0],q=q$2;
            continue}
          var t=p[2],x$0=_th_[1];
          if(occurs(x$0,t))throw Not_unifiable;
          var
           s$0=caml_call2(Substitution[5],x$0,t),
           f=caml_call1(Substitution[8],s$0),
           _tm_=
            function(f)
              {return function(param)
                {var t2=param[2],t1=param[1],_to_=caml_call1(f,t2);
                 return [0,caml_call1(f,t1),_to_]}}
             (f),
           q$3=caml_call2(List[19],_tm_,q$0),
           s$1=caml_call2(Substitution[9],s,s$0),
           s$2=caml_call3(Substitution[6],s$1,x$0,t),
           q=q$3,
           s=s$2;
          continue}
        var _tn_=caml_call2(Substitution[8],s,t2);
        if(eq$1(caml_call2(Substitution[8],s,t1),_tn_))return s;
        throw [0,Assert_failure,_f_]}}
    function matches(t1,t2)
     {var q$2=[0,[0,t1,t2],0],q=q$2,s=Substitution[2];
      for(;;)
       {if(q)
         {var q$0=q[2],p=q[1],_tc_=p[1];
          if(0 === _tc_[0])
           {var _td_=p[2],_te_=_tc_[2],_tf_=_tc_[1];
            if(0 === _td_[0])
             {var a2=_td_[2],f2=_td_[1];
              if(1 - caml_call2(Op[5],_tf_,f2))throw Not_unifiable;
              var
               _tg_=caml_call3(List[28],pair,_te_,a2),
               q$1=caml_call2(Stdlib[37],_tg_,q$0),
               q=q$1;
              continue}
            throw Not_unifiable}
          var t=p[2],x=_tc_[1];
          if(caml_call2(Substitution[15],s,x))
           {if(eq$1(caml_call2(Substitution[8],s,[1,x]),t))
             {var q=q$0;continue}
            throw Not_unifiable}
          var s$0=caml_call3(Substitution[6],s,x,t),q=q$0,s=s$0;
          continue}
        return s}}
    function equivalent(opt,t1)
     {if(opt)var sth=opt[1],s=sth;else var s=Substitution[2];
      return function(t2)
       {function aux(q,s)
         {var q$0=q,s$0=s;
          for(;;)
           {if(q$0)
             {var q$1=q$0[2],p=q$0[1],_s7_=p[1];
              if(0 === _s7_[0])
               {var _s8_=p[2],_s9_=_s7_[2],_s__=_s7_[1];
                if(0 === _s8_[0])
                 {var a2=_s8_[2],f2=_s8_[1];
                  if(1 - caml_call2(Op[5],_s__,f2))throw Not_unifiable;
                  var
                   _s$_=caml_call3(List[28],pair,_s9_,a2),
                   q$2=caml_call2(Stdlib[37],_s$_,q$1),
                   q$0=q$2;
                  continue}}
              else
               {var _ta_=_s7_[1],_tb_=p[2];
                if(0 !== _tb_[0])
                 {var y=_tb_[1];
                  if(caml_call2(Substitution[15],s$0,_ta_))
                   {if(eq$1(caml_call2(Substitution[8],s$0,[1,_ta_]),[1,y]))
                     {var q$0=q$1;continue}
                    throw Not_unifiable}
                  var
                   s$1=caml_call3(Substitution[6],s$0,_ta_,[1,y]),
                   q$0=q$1,
                   s$0=s$1;
                  continue}}
              throw Not_unifiable}
            return s$0}}
        try
         {aux([0,[0,t1,t2],0],s);var _s5_=1;return _s5_}
        catch(_s6_)
         {_s6_ = caml_wrap_exception(_s6_);
          if(_s6_ === Not_unifiable)return 0;
          throw _s6_}}}
    function list_remove_nth(n,param)
     {var n$0=n,p=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(0 === n$0)return [0,caml_call1(List[9],p),l];
          var p$0=[0,x,p],n$1=n$0 - 1 | 0,n$0=n$1,p=p$0,param$0=l;
          continue}
        throw [0,Assert_failure,_g_]}}
    function make$1(r,s,t){return [0,r,s,t]}
    function of_string(ops,r,s,t)
     {var s$0=parse(ops,s),t$0=parse(ops,t);return [0,r,s$0,t$0]}
    function name$0(param){var r=param[1];return r}
    function source(param){var s=param[2];return s}
    function target(param){var t=param[3];return t}
    function vars$1(r){return vars$0(r[2])}
    function arity$0(r){var _s4_=vars$1(r);return caml_call1(List[1],_s4_)}
    function args(r,s)
     {var vars=vars$1(r);
      function _sX_(param,_s0_)
       {var y=_s0_[1],x=param[1];
        function _s1_(z){return caml_call2(Var[2],z,y)}
        var _s2_=caml_call2(List[63],_s1_,vars);
        function _s3_(z){return caml_call2(Var[2],z,x)}
        return caml_call2(List[63],_s3_,vars) - _s2_ | 0}
      var args=caml_call2(List[56],_sX_,s);
      function _sY_(_sZ_){return _sZ_[2]}
      return caml_call2(List[19],_sY_,args)}
    function args_subst(r,a)
     {var _sV_=vars$1(r);
      function _sW_(x,t){return [0,x,t]}
      return caml_call3(List[28],_sW_,_sV_,a)}
    function to_string$3(var$0,r)
     {var
       s=to_string$1(var$0,r[2]),
       t=to_string$1(var$0,r[3]),
       _sS_=caml_call2(Stdlib[28],cst$7,t),
       _sT_=caml_call2(Stdlib[28],s,_sS_),
       _sU_=caml_call2(Stdlib[28],cst$8,_sT_);
      return caml_call2(Stdlib[28],r[1],_sU_)}
    function eq$3(r1,r2){return caml_string_equal(r1[1],r2[1])}
    var
     Rule=
      [0,
       make$1,
       of_string,
       name$0,
       source,
       target,
       vars$1,
       arity$0,
       args,
       args_subst,
       to_string$3,
       eq$3];
    function operations(rs){return rs[1]}
    function rules(rs){return rs[2]}
    function make$2(operations,rules){return [0,operations,rules]}
    function empty$1(ops){return [0,ops,0]}
    function to_string$4(opt,rs)
     {if(opt)var sth=opt[1],var$0=sth;else var var$0=Var[3];
      var _sO_=rs[2];
      function _sP_(r)
       {var _sR_=[0,caml_call1(var$0,0)];return caml_call2(Rule[10],_sR_,r)}
      var _sQ_=caml_call2(List[19],_sP_,_sO_);
      return caml_call2(String[6],cst$9,_sQ_)}
    function find$2(rs,r)
     {var _sM_=rs[2];
      function _sN_(r$0){return caml_string_equal(caml_call1(Rule[3],r$0),r)}
      return caml_call2(List[38],_sN_,_sM_)}
    function of_term(param){throw [0,Assert_failure,_h_]}
    function tapp(f,a1,s,a2)
     {var _sK_=caml_call1(Op[3],f),_sL_=caml_call1(List[1],a2);
      if(((caml_call1(List[1],a1) + 1 | 0) + _sL_ | 0) === _sK_)
       return [0,f,a1,s,a2];
      throw [0,Assert_failure,_i_]}
    function rapp(r,s)
     {var vr=caml_call1(Rule[6],r),vs=caml_call1(Substitution[14],s);
      function _sG_(x)
       {var _sJ_=caml_call1(Var[2],x);return caml_call2(List[33],_sJ_,vs)}
      if(caml_call2(List[32],_sG_,vr))
       {var
         _sH_=
          function(x)
           {var _sI_=caml_call1(Var[2],x);return caml_call2(List[33],_sI_,vr)};
        if(caml_call2(List[32],_sH_,vs))return [1,r,s];
        throw [0,Assert_failure,_j_]}
      throw [0,Assert_failure,_k_]}
    function subst(s,param)
     {if(0 === param[0])
       {var
         a2=param[4],
         st=param[3],
         a1=param[2],
         f=param[1],
         _sC_=caml_call1(Substitution[8],s),
         _sD_=caml_call2(List[19],_sC_,a2),
         _sE_=subst(s,st),
         _sF_=caml_call1(Substitution[8],s);
        return tapp(f,caml_call2(List[19],_sF_,a1),_sE_,_sD_)}
      var s$0=param[2],r=param[1];
      return rapp(r,caml_call2(Substitution[9],s$0,s))}
    function source$0(param)
     {if(0 === param[0])
       {var
         a2=param[4],
         s=param[3],
         a1=param[2],
         f=param[1],
         _sz_=[0,source$0(s),0],
         _sA_=caml_call2(Stdlib[37],_sz_,a2);
        return app(f,caml_call2(Stdlib[37],a1,_sA_))}
      var s$0=param[2],r=param[1],_sB_=caml_call1(Rule[4],r);
      return caml_call2(Substitution[8],s$0,_sB_)}
    function target$0(param)
     {if(0 === param[0])
       {var
         a2=param[4],
         s=param[3],
         a1=param[2],
         f=param[1],
         _sw_=[0,target$0(s),0],
         _sx_=caml_call2(Stdlib[37],_sw_,a2);
        return app(f,caml_call2(Stdlib[37],a1,_sx_))}
      var s$0=param[2],r=param[1],_sy_=caml_call1(Rule[5],r);
      return caml_call2(Substitution[8],s$0,_sy_)}
    function label(opt,param)
     {if(opt)var sth=opt[1],var$0=sth;else var var$0=Var[5];
      if(0 === param[0])
       {var
         a2=param[4],
         s=param[3],
         a1=param[2],
         f=param[1],
         _so_=string_of_term([0,var$0]),
         a1$0=caml_call2(List[19],_so_,a1),
         _sp_=string_of_term([0,var$0]),
         a2$0=caml_call2(List[19],_sp_,a2),
         _sq_=[0,label([0,var$0],s),0],
         _sr_=caml_call2(Stdlib[37],_sq_,a2$0),
         a=caml_call2(Stdlib[37],a1$0,_sr_);
        return caml_call2(Op[6],f,a)}
      var
       s$0=param[2],
       r=param[1],
       a$0=caml_call2(Rule[8],r,s$0),
       _ss_=string_of_term([0,var$0]),
       a$1=caml_call2(List[19],_ss_,a$0),
       a$2=caml_call2(String[6],cst$10,a$1),
       _st_=caml_call2(Stdlib[28],a$2,cst$11),
       _su_=caml_call2(Stdlib[28],cst$12,_st_),
       _sv_=caml_call1(Rule[3],r);
      return caml_call2(Stdlib[28],_sv_,_su_)}
    function to_string$5(var$0,s)
     {var
       _sg_=target$0(s),
       _sh_=caml_call1(string_of_term(var$0),_sg_),
       _si_=caml_call2(Stdlib[28],cst$13,_sh_),
       _sj_=label(var$0,s),
       _sk_=caml_call2(Stdlib[28],_sj_,_si_),
       _sl_=caml_call2(Stdlib[28],cst$14,_sk_),
       _sm_=source$0(s),
       _sn_=caml_call1(string_of_term(var$0),_sm_);
      return caml_call2(Stdlib[28],_sn_,_sl_)}
    function rule(param)
     {var param$0=param;
      for(;;)
       {if(0 === param$0[0]){var param$1=param$0[3],param$0=param$1;continue}
        var r=param$0[1];
        return r}}
    function has_context(param)
     {if(0 === param[0])return 1;
      var s=param[2];
      return 1 - caml_call1(Substitution[12],s)}
    function eq$4(s1,s2)
     {if(0 === s1[0])
       {var _r3_=s1[4],_r5_=s1[2],_r4_=s1[3],_r6_=s1[1];
        if(0 === s2[0])
         {var a2=s2[4],s=s2[3],a1=s2[2],f=s2[1],_r7_=caml_call2(Op[5],_r6_,f);
          if(_r7_)
           {var
             _r8_=caml_call1(List[1],a1),
             _r9_=caml_call1(List[1],_r5_) === _r8_?1:0;
            if(_r9_)
             {var
               _r__=caml_call1(List[1],a2),
               _r$_=caml_call1(List[1],_r3_) === _r__?1:0;
              if(_r$_)
               {var _sa_=caml_call3(List[34],eq$1,_r5_,a1);
                if(_sa_)
                 {var _sb_=eq$4(_r4_,s);
                  if(_sb_)return caml_call3(List[34],eq$1,_r3_,a2);
                  var _sc_=_sb_}
                else
                 var _sc_=_sa_}
              else
               var _sc_=_r$_}
            else
             var _sc_=_r9_}
          else
           var _sc_=_r7_;
          return _sc_}}
      else
       {var _sd_=s1[2],_se_=s1[1];
        if(0 !== s2[0])
         {var s$0=s2[2],r=s2[1],_sf_=caml_call2(Rule[11],_se_,r);
          return _sf_?caml_call2(Substitution[10],_sd_,s$0):_sf_}}
      return 0}
    function has_rule(r,param)
     {var param$0=param;
      for(;;)
       {if(0 === param$0[0]){var param$1=param$0[3],param$0=param$1;continue}
        var r$0=param$0[1];
        return caml_call2(Rule[11],r,r$0)}}
    var
     Step=
      [0,
       of_term,
       tapp,
       rapp,
       subst,
       source$0,
       target$0,
       label,
       to_string$5,
       rule,
       has_context,
       eq$4,
       has_rule];
    function steps(rs,t)
     {function aux(r,ctx,t)
       {if(0 === t[0])
         {var a=t[2],f=t[1];
          try
           {var
             s$2=matches(caml_call1(Rule[4],r),t),
             _r1_=[0,caml_call1(ctx,caml_call2(Step[3],r,s$2)),0],
             s=_r1_}
          catch(_r2_)
           {_r2_ = caml_wrap_exception(_r2_);
            if(_r2_ !== Not_unifiable)throw _r2_;
            var s=0}
          var
           _r0_=
            function(i,t)
             {var match=list_remove_nth(i,a),a2=match[2],a1=match[1];
              function ctx$0(t)
               {return caml_call1(ctx,caml_call4(Step[2],f,a1,t,a2))}
              return aux(r,ctx$0,t)},
           s$0=caml_call2(List[20],_r0_,a),
           s$1=caml_call1(List[14],s$0);
          return caml_call2(Stdlib[37],s$1,s)}
        return 0}
      var _rX_=rs[2];
      function _rY_(r){return aux(r,tm_ctx,t)}
      var _rZ_=caml_call2(List[19],_rY_,_rX_);
      return caml_call1(List[14],_rZ_)}
    function empty$2(t){return [0,t]}
    function source$1(param)
     {var param$0=param;
      for(;;)
       {if(0 === param$0[0]){var t=param$0[1];return t}
        var param$1=param$0[1],param$0=param$1;
        continue}}
    function target$1(param)
     {if(0 === param[0]){var t=param[1];return t}
      var s=param[2];
      return caml_call1(Step[6],s)}
    function step(s){return [1,[0,caml_call1(Step[5],s)],s]}
    function append_step(p,s)
     {var _rW_=caml_call1(Step[5],s);
      if(eq$1(target$1(p),_rW_))return [1,p,s];
      throw [0,Assert_failure,_l_]}
    function to_string$6(var$0,param)
     {if(0 === param[0])
       {var t=param[1];return caml_call1(string_of_term(var$0),t)}
      var
       s=param[2],
       p=param[1],
       src=to_string$6(var$0,p),
       lbl=caml_call2(Step[7],var$0,s),
       _rS_=caml_call1(Step[6],s),
       tgt=caml_call1(string_of_term(var$0),_rS_),
       _rT_=caml_call2(Stdlib[28],cst$15,tgt),
       _rU_=caml_call2(Stdlib[28],lbl,_rT_),
       _rV_=caml_call2(Stdlib[28],cst$16,_rU_);
      return caml_call2(Stdlib[28],src,_rV_)}
    function append$0(p,param)
     {if(0 === param[0])
       {var t=param[1];
        if(eq$1(target$1(p),t))return p;
        throw [0,Assert_failure,_m_]}
      var s=param[2],q=param[1];
      return [1,append$0(p,q),s]}
    function toplevel_rules(param)
     {if(0 === param[0])return 0;
      var
       s=param[2],
       p=param[1],
       _rQ_=caml_call1(Step[10],s)?0:[0,caml_call1(Step[9],s),0],
       _rR_=toplevel_rules(p);
      return caml_call2(Stdlib[37],_rR_,_rQ_)}
    function eq$5(p$0,p)
     {if(0 === p$0[0])
       {var _rM_=p$0[1];if(0 === p[0]){var t=p[1];return eq$1(_rM_,t)}}
      else
       {var _rN_=p$0[2],_rO_=p$0[1];
        if(0 !== p[0])
         {var s=p[2],p$1=p[1],_rP_=eq$5(_rO_,p$1);
          return _rP_?caml_call2(Step[11],_rN_,s):_rP_}}
      return 0}
    function rules$0(param)
     {if(0 === param[0])return 0;
      var
       s=param[2],
       p=param[1],
       r=caml_call1(Step[9],s),
       rr=rules$0(p),
       _rL_=caml_call1(Rule[11],r);
      return caml_call2(List[33],_rL_,rr)?rr:[0,r,rr]}
    function length$0(param)
     {if(0 === param[0])return 0;var p=param[1];return 1 + length$0(p) | 0}
    function nth_step(n,p)
     {var n$2=(length$0(p) - 1 | 0) - n | 0,n$0=n$2,param=p;
      for(;;)
       {if(0 === param[0])throw [0,Assert_failure,_n_];
        var s=param[2],p$0=param[1];
        if(0 === n$0)return s;
        var n$1=n$0 - 1 | 0,n$0=n$1,param=p$0;
        continue}}
    function nth_term(n,p)
     {var n$2=length$0(p) - n | 0,n$0=n$2,param=p;
      for(;;)
       {if(0 === param[0])
         {var t=param[1];if(0 === n$0)return t;throw [0,Assert_failure,_o_]}
        var s=param[2],p$0=param[1];
        if(0 === n$0)return caml_call1(Step[6],s);
        var n$1=n$0 - 1 | 0,n$0=n$1,param=p$0;
        continue}}
    var
     Path=
      [0,
       empty$2,
       source$1,
       target$1,
       step,
       append_step,
       to_string$6,
       append$0,
       toplevel_rules,
       eq$5,
       rules$0,
       length$0,
       nth_step,
       nth_term];
    function normalize(rs,t)
     {var p$1=caml_call1(Path[1],t),p=p$1;
      for(;;)
       {var s=steps(rs,caml_call1(Path[3],p));
        if(0 === s)return p;
        var _rK_=caml_call1(List[5],s),p$0=caml_call2(Path[5],p,_rK_),p=p$0;
        continue}}
    function critical_rules(r1,r2)
     {function aux(ctx,t)
       {if(0 === t[0])
         {var a=t[2],f=t[1];
          try
           {var
             t2=caml_call1(Rule[4],r2),
             _rC_=caml_call1(Rule[6],r2),
             n2=caml_call1(Substitution[4],_rC_),
             s$2=unify(t,caml_call2(Substitution[8],n2,t2)),
             _rD_=caml_call1(Rule[6],r1),
             _rE_=caml_call1(Substitution[3],_rD_),
             _rF_=caml_call2(Substitution[9],_rE_,s$2),
             step1=caml_call2(Step[3],r1,_rF_),
             _rG_=caml_call1(ctx,caml_call2(Step[3],r2,n2)),
             step2=caml_call2(Step[4],s$2,_rG_),
             _rH_=caml_call1(Step[5],step2);
            if(! caml_call1(equivalent(0,caml_call1(Step[5],step1)),_rH_))
             throw [0,Assert_failure,_p_];
            var switch$0=0;
            if
             (caml_call2(Rule[11],r1,r2)
              &&
              !
              caml_call1(Step[10],step1)
              &&
              !
              caml_call1(Step[10],step2))
             {var _rI_=0;switch$0 = 1}
            if(! switch$0)var _rI_=[0,[0,step1,step2],0];
            var s=_rI_}
          catch(_rJ_)
           {_rJ_ = caml_wrap_exception(_rJ_);
            if(_rJ_ !== Not_unifiable)throw _rJ_;
            var s=0}
          var
           _rB_=
            function(i,t)
             {var match=list_remove_nth(i,a),a2=match[2],a1=match[1];
              function ctx$0(t)
               {return caml_call1(ctx,caml_call4(Step[2],f,a1,t,a2))}
              return aux(ctx$0,t)},
           s$0=caml_call2(List[20],_rB_,a),
           s$1=caml_call1(List[14],s$0);
          return caml_call2(Stdlib[37],s,s$1)}
        return 0}
      return aux(tm_ctx,caml_call1(Rule[4],r1))}
    function critical(rs)
     {var _rs_=rs[2];
      function _rt_(r1)
       {var _rz_=rs[2];
        function _rA_(r2){return critical_rules(r1,r2)}
        return caml_call2(List[19],_rA_,_rz_)}
      var
       _ru_=caml_call2(List[19],_rt_,_rs_),
       _rv_=caml_call1(List[14],_ru_),
       steps=caml_call1(List[14],_rv_);
      function sym(param)
       {if(param)
         {var
           steps=param[2],
           match=param[1],
           s2=match[2],
           s1=match[1],
           _rw_=
            function(param)
             {var
               s1$0=param[2],
               s2$0=param[1],
               _rx_=caml_call2(Step[11],s1,s1$0),
               _ry_=_rx_?caml_call2(Step[11],s2,s2$0):_rx_;
              return 1 - _ry_},
           steps$0=caml_call2(List[41],_rw_,steps);
          return [0,[0,s1,s2],sym(steps$0)]}
        return 0}
      return sym(steps)}
    function orient(gt,rs)
     {var _rq_=rs[2];
      function _rr_(param)
       {var u=param[3],t=param[2],n=param[1];
        return caml_call2(gt,t,u)?[0,n,t,u]:[0,n,u,t]}
      var rules=caml_call2(List[19],_rr_,_rq_);
      return [0,rs[1],rules]}
    function knuth_bendix(opt,namer,_q3_,rs)
     {if(opt)
       var sth=opt[1],gt=sth;
      else
       var gt=caml_call1(LPO[1],runtime.caml_greaterequal);
      if(_q3_)
       var sth$0=_q3_[1],callback=sth$0;
      else
       var callback=function(param){return 0};
      var rs$0=orient(gt,rs);
      if(namer)
       var namer$0=namer[1],namer$1=namer$0;
      else
       var
        n=[0,-1],
        namer$1=
         function(param)
          {n[1]++;
           var _rp_=caml_call1(Stdlib[33],n[1]);
           return caml_call2(Stdlib[28],cst_K,_rp_)};
      var queue=[0,rs$0[2]],rules=[0,rs$0[2]];
      for(;;)
       {if(0 === queue[1])return [0,rs$0[1],rules[1]];
        var r=caml_call1(List[5],queue[1]);
        queue[1] = caml_call1(List[6],queue[1]);
        var
         _q4_=rules[1],
         _q5_=
          function(r)
            {return function(s)
              {var _rn_=critical_rules(s,r),_ro_=critical_rules(r,s);
               return caml_call2(Stdlib[37],_ro_,_rn_)}}
           (r),
         _q6_=caml_call2(List[19],_q5_,_q4_),
         cp=caml_call1(List[14],_q6_),
         _q7_=
          function(param)
           {var
             s2=param[2],
             s1=param[1],
             rs=[0,rs$0[1],rules[1]],
             _ra_=normalize(rs,caml_call1(Step[6],s1)),
             _rb_=caml_call1(Path[4],s1),
             p1=caml_call2(Path[7],_rb_,_ra_),
             _rc_=normalize(rs,caml_call1(Step[6],s2)),
             _rd_=caml_call1(Path[4],s2),
             p2=caml_call2(Path[7],_rd_,_rc_),
             t1=caml_call1(Path[3],p1),
             t2=caml_call1(Path[3],p2),
             _re_=1 - eq$1(t1,t2);
            if(_re_)
             {if(caml_call2(gt,t1,t2))
               var t2$0=t2,t1$0=t1;
              else
               var t2$0=t1,t1$0=t2;
              var
               r=[0,caml_call1(namer$1,0),t1$0,t2$0],
               _rf_=caml_call2(Path[6],0,p2),
               _rg_=caml_call2(Path[6],0,p1),
               _rh_=caml_call2(Rule[10],0,r);
              caml_call4(Stdlib_Printf[2],_q_,_rh_,_rg_,_rf_);
              rules[1] = [0,r,rules[1]];
              var
               _q8_=rules[1],
               _q9_=
                function(r)
                 {var t=r[3],s=r[2],n=r[1],_ri_=rules[1];
                  function _rj_(r$0){return 1 - caml_call2(Rule[11],r,r$0)}
                  var
                   rules$0=caml_call2(List[41],_rj_,_ri_),
                   rs=[0,rs$0[1],rules$0],
                   _rk_=normalize(rs,t),
                   _rl_=caml_call1(Path[3],_rk_),
                   _rm_=normalize(rs,s);
                  return [0,n,caml_call1(Path[3],_rm_),_rl_]};
              rules[1] = caml_call2(List[19],_q9_,_q8_);
              var
               _q__=rules[1],
               _q$_=
                function(param)
                 {var t=param[3],s=param[2];return 1 - eq$1(s,t)};
              rules[1] = caml_call2(List[41],_q$_,_q__);
              queue[1] = caml_call2(Stdlib[37],queue[1],[0,r,0]);
              return 0}
            return _re_};
        caml_call2(List[17],_q7_,cp);
        caml_call1(callback,[0,rs$0[1],rules[1]]);
        continue}}
    var Not_confluent=[248,cst_Alg_Term_RS_Not_confluent,caml_fresh_oo_id(0)];
    function squier(rs)
     {var _qU_=critical(rs);
      function _qV_(param)
       {var
         s2=param[2],
         s1=param[1],
         _qW_=normalize(rs,caml_call1(Step[6],s1)),
         _qX_=caml_call1(Path[4],s1),
         p1=caml_call2(Path[7],_qX_,_qW_),
         _qY_=normalize(rs,caml_call1(Step[6],s2)),
         _qZ_=caml_call1(Path[4],s2),
         p2=caml_call2(Path[7],_qZ_,_qY_),
         _q0_=caml_call1(Path[3],p2);
        if(1 - eq$1(caml_call1(Path[3],p1),_q0_))
         {var _q1_=caml_call2(Path[6],0,p2),_q2_=caml_call2(Path[6],0,p1);
          caml_call3(Stdlib_Printf[2],_r_,_q2_,_q1_);
          throw Not_confluent}
        return [0,p1,p2]}
      return caml_call2(List[19],_qV_,_qU_)}
    function to_string$7(opt,var$0,param)
     {if(opt)var sth=opt[1],pa=sth;else var pa=0;
      switch(param[0])
       {case 0:var s=param[1];return caml_call2(Step[7],var$0,s);
        case 1:
         var
          p2=param[2],
          p1=param[1],
          _qP_=to_string$7(0,var$0,p2),
          _qQ_=caml_call2(Stdlib[28],cst$17,_qP_),
          _qR_=to_string$7(_s_,var$0,p1),
          s$0=caml_call2(Stdlib[28],_qR_,_qQ_);
         if(pa)
          {var _qS_=caml_call2(Stdlib[28],s$0,cst$18);
           return caml_call2(Stdlib[28],cst$19,_qS_)}
         return s$0;
        case 2:var t=param[1];return caml_call1(string_of_term(var$0),t);
        default:
         var p=param[1],_qT_=to_string$7(_t_,var$0,p);
         return caml_call2(Stdlib[28],_qT_,cst$20)}}
    function source$3(counter,param)
     {var param$0=param;
      for(;;)
       switch(param$0[0])
        {case 0:var s=param$0[1];return caml_call1(Step[5],s);
         case 1:var param$1=param$0[1],param$0=param$1;continue;
         case 2:var t=param$0[1];return t;
         default:
          var p=param$0[1];
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return target$3(counter$0,p)}
          return caml_trampoline_return(target$3,[0,p])}}
    function target$3(counter,param)
     {var param$0=param;
      for(;;)
       switch(param$0[0])
        {case 0:var s=param$0[1];return caml_call1(Step[6],s);
         case 1:var param$1=param$0[2],param$0=param$1;continue;
         case 2:var t=param$0[1];return t;
         default:
          var p=param$0[1];
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return source$3(counter$0,p)}
          return caml_trampoline_return(source$3,[0,p])}}
    function source$2(param){return caml_trampoline(source$3(0,param))}
    function target$2(param){return caml_trampoline(target$3(0,param))}
    function step$0(s){return [0,s]}
    function comp(p1,p2)
     {var _qO_=source$2(p2);
      if(eq$1(target$2(p1),_qO_))return [1,p1,p2];
      throw [0,Assert_failure,_u_]}
    function append$1(p1,p2){return comp(p1,p2)}
    function concat$1(param)
     {if(param)
       {var _qN_=param[1];
        if(param[2]){var l=param[2];return append$1(_qN_,concat$1(l))}
        return _qN_}
      throw [0,Assert_failure,_v_]}
    function inv$0(p){return [3,p]}
    function eq$6(p$0,p)
     {var p$2=p$0,p$1=p;
      for(;;)
       {switch(p$2[0])
         {case 0:
           if(0 === p$1[0])
            {var s=p$1[1],s$0=p$2[1];return caml_call2(Step[11],s$0,s)}
           break;
          case 1:
           if(1 === p$1[0])
            {var q=p$1[2],p$3=p$1[1],q$0=p$2[2],p$4=p$2[1],_qM_=eq$6(p$4,p$3);
             if(_qM_){var p$2=q$0,p$1=q;continue}
             return _qM_}
           break;
          case 2:
           if(2 === p$1[0]){var t=p$1[1],t$0=p$2[1];return eq$1(t$0,t)}break;
          default:
           if(3 === p$1[0])
            {var p$5=p$1[1],p$6=p$2[1],p$2=p$6,p$1=p$5;continue}}
        return 0}}
    function length$1(param)
     {var param$0=param;
      for(;;)
       switch(param$0[0])
        {case 0:return 1;
         case 1:
          var q=param$0[2],p=param$0[1],_qL_=length$1(q);
          return length$1(p) + _qL_ | 0;
         case 2:return 0;
         default:var param$1=param$0[1],param$0=param$1;continue}}
    function of_path(p)
     {if(0 === p[0]){var t=p[1];return [2,t]}
      var s=p[2],p$0=p[1];
      return comp(of_path(p$0),[0,s])}
    function map$1(tm,rs,param)
     {switch(param[0])
       {case 0:var s=param[1];return [0,caml_call1(rs,s)];
        case 1:
         var q=param[2],p=param[1],_qK_=map$1(tm,rs,q);
         return [1,map$1(tm,rs,p),_qK_];
        case 2:var t=param[1];return [2,caml_call1(tm,t)];
        default:var p$0=param[1];return [3,map$1(tm,rs,p$0)]}}
    function subst$0(s,param)
     {switch(param[0])
       {case 0:var t=param[1];return [0,caml_call2(Step[4],s,t)];
        case 1:
         var p2=param[2],p1=param[1],_qJ_=subst$0(s,p2);
         return [1,subst$0(s,p1),_qJ_];
        case 2:var t$0=param[1];return [2,caml_call2(Substitution[8],s,t$0)];
        default:var p=param[1];return [3,subst$0(s,p)]}}
    function rule_occurences(r,param)
     {var param$0=param;
      for(;;)
       switch(param$0[0])
        {case 0:var s=param$0[1];return caml_call2(Step[12],r,s)?1:0;
         case 1:
          var q=param$0[2],p=param$0[1],_qI_=rule_occurences(r,q);
          return rule_occurences(r,p) + _qI_ | 0;
         case 2:return 0;
         default:var param$1=param$0[1],param$0=param$1;continue}}
    function rule_algebraic_occurences(r,param)
     {switch(param[0])
       {case 0:var s=param[1];return caml_call2(Step[12],r,s)?1:0;
        case 1:
         var q=param[2],p=param[1],_qH_=rule_algebraic_occurences(r,q);
         return rule_algebraic_occurences(r,p) + _qH_ | 0;
        case 2:return 0;
        default:var p$0=param[1];return - rule_algebraic_occurences(r,p$0) | 0}}
    function is_id(param){return 2 === param[0]?1:0}
    function is_inv(param){return 3 === param[0]?1:0}
    function has_rule$0(r,p){return 0 < rule_occurences(r,p)?1:0}
    function canonize(p)
     {var p$0=p;
      for(;;)
       switch(p$0[0])
        {case 0:var s=p$0[1];return [0,s];
         case 1:
          var _qA_=p$0[1];
          if(2 === _qA_[0]){var p$10=p$0[2],p$0=p$10;continue}
          if(2 === p$0[2][0]){var p$0=_qA_;continue}
          switch(_qA_[0])
           {case 1:
             var r=p$0[2],q=_qA_[2],p$4=_qA_[1],p$5=[1,p$4,[1,q,r]],p$0=p$5;
             continue;
            case 3:
             var _qE_=_qA_[1];
             if(0 === _qE_[0])
              {var p$6=p$0[2],s$3=_qE_[1],p$7=canonize(p$6);
               switch(p$7[0])
                {case 0:
                  var s$4=p$7[1];
                  if(caml_call2(Step[11],s$3,s$4))
                   return [2,caml_call1(Step[6],s$4)];
                  break;
                 case 1:
                  var _qF_=p$7[1];
                  if(0 === _qF_[0])
                   {var p$8=p$7[2],s$5=_qF_[1];
                    if(caml_call2(Step[11],s$3,s$5))return p$8}
                  break;
                 case 2:return [3,[0,s$3]]
                 }
               return [1,[3,[0,s$3]],p$7]}
             var q$0=p$0[2],p$9=[1,canonize(_qA_),q$0],p$0=p$9;
             continue;
            default:
             var p$1=p$0[2],s$0=_qA_[1],p$2=canonize(p$1);
             switch(p$2[0])
              {case 1:
                var _qB_=p$2[1];
                if(3 === _qB_[0])
                 {var _qC_=_qB_[1];
                  if(0 === _qC_[0])
                   {var p$3=p$2[2],s$1=_qC_[1];
                    if(caml_call2(Step[11],s$0,s$1))return p$3}}
                break;
               case 2:return [0,s$0];
               case 3:
                var _qD_=p$2[1];
                if(0 === _qD_[0])
                 {var s$2=_qD_[1];
                  if(caml_call2(Step[11],s$0,s$2))
                   return [2,caml_call1(Step[5],s$0)]}
                break
               }
             return [1,[0,s$0],p$2]}
         case 2:var t=p$0[1];return [2,t];
         default:
          var _qG_=p$0[1];
          switch(_qG_[0])
           {case 0:var s$6=_qG_[1];return [3,[0,s$6]];
            case 1:
             var q$1=_qG_[2],p$11=_qG_[1],p$12=[1,[3,q$1],[3,p$11]],p$0=p$12;
             continue;
            case 2:var t$0=_qG_[1];return [2,t$0];
            default:var p$13=_qG_[1],p$0=p$13;continue}}}
    function value(r,p)
     {var p$0=canonize(p);
      if(1 === rule_occurences(r,p$0))
       {var
         p$1=-1 === rule_algebraic_occurences(r,p$0)?canonize([3,p$0]):p$0,
         prefix$2=[0,[2,source$2(p$1)],0],
         prefix=prefix$2,
         s=p$1;
        for(;;)
         {var switch$0=0;
          switch(s[0])
           {case 0:switch$0 = 1;break;
            case 1:
             var _qv_=s[1],switch$1=0;
             switch(_qv_[0])
              {case 0:
                var _qw_=_qv_[1];
                if(1 === _qw_[0])
                 {var p$2=s[2],s$2=_qw_[2],r$0=_qw_[1];
                  if(caml_call2(Rule[11],r,r$0))
                   {if(has_rule$0(r,p$2))throw [0,Assert_failure,_w_];
                    if(caml_call1(Substitution[11],s$2))
                     {var
                       prefix$1=concat$1(caml_call1(List[9],prefix)),
                       _qx_=concat$1([0,[3,prefix$1],[0,[3,p$2],0]]),
                       v=canonize(subst$0(caml_call1(Substitution[13],s$2),_qx_)),
                       _qy_=caml_call1(Rule[4],r);
                      if(eq$1(source$2(v),_qy_))
                       {var _qz_=caml_call1(Rule[5],r);
                        if(eq$1(target$2(v),_qz_))return v;
                        throw [0,Assert_failure,_A_]}
                      throw [0,Assert_failure,_B_]}
                    throw [0,Assert_failure,_x_]}}
                var s$1=s[2];
                break;
               case 3:
                if(0 === _qv_[1][0])var s$1=s[2];else switch$1 = 1;break;
               default:switch$1 = 1}
             if(! switch$1)
              {var prefix$0=[0,_qv_,prefix],prefix=prefix$0,s=s$1;continue}
             break;
            case 2:throw [0,Assert_failure,_z_];
            default:if(0 === s[1][0])switch$0 = 1}
          if(switch$0){var s$0=[1,s,[2,target$2(s)]],s=s$0;continue}
          throw [0,Assert_failure,_y_]}}
      throw [0,Assert_failure,_C_]}
    function replace_rule(r,pr,p)
     {switch(p[0])
       {case 0:
         var s$1=p[1],tm_ctx$0=tm_ctx,rs_ctx=tm_ctx,param=s$1;
         for(;;)
          {if(0 === param[0])
            {var
              a2=param[4],
              param$0=param[3],
              a1=param[2],
              f=param[1],
              tm_ctx$2=
               function(tm_ctx,a2,a1,f)
                {function tm_ctx$0(t)
                  {var _qu_=caml_call2(Stdlib[37],[0,t,0],a2);
                   return tm_ctx(app(f,caml_call2(Stdlib[37],a1,_qu_)))}
                 return tm_ctx$0},
              tm_ctx$1=tm_ctx$2(tm_ctx$0,a2,a1,f),
              rs_ctx$1=
               function(rs_ctx,a2,a1,f)
                {function rs_ctx$0(s)
                  {return rs_ctx(caml_call4(Step[2],f,a1,s,a2))}
                 return rs_ctx$0},
              rs_ctx$0=rs_ctx$1(rs_ctx,a2,a1,f),
              tm_ctx$0=tm_ctx$1,
              rs_ctx=rs_ctx$0,
              param=param$0;
             continue}
           var r$0=param[1],s=param[2];
           if(caml_call2(Rule[11],r,r$0))
            return map$1(tm_ctx$0,rs_ctx,subst$0(s,pr));
           var s$0=param[2];
           return [0,rs_ctx(caml_call2(Step[3],r$0,s$0))]}
        case 1:
         var q=p[2],p$0=p[1],_qt_=replace_rule(r,pr,q);
         return comp(replace_rule(r,pr,p$0),_qt_);
        case 2:var t=p[1];return [2,t];
        default:var p$1=p[1];return [3,replace_rule(r,pr,p$1)]}}
    function nth_step$0(n,param)
     {var n$0=n,param$0=param;
      for(;;)
       {switch(param$0[0])
         {case 0:var s=param$0[1];if(0 === n$0)return [0,1,s];break;
          case 1:
           var _qq_=param$0[1];
           switch(_qq_[0])
            {case 0:
              var p=param$0[2],s$0=_qq_[1];
              if(0 === n$0)return [0,1,s$0];
              var n$1=n$0 - 1 | 0,n$0=n$1,param$0=p;
              continue;
             case 3:
              var _qr_=_qq_[1];
              if(0 === _qr_[0])
               {var p$0=param$0[2],s$1=_qr_[1];
                if(0 === n$0)return [0,0,s$1];
                var n$2=n$0 - 1 | 0,n$0=n$2,param$0=p$0;
                continue}
              break
             }
           break;
          case 3:
           var _qs_=param$0[1];
           if(0 === _qs_[0]){var s$2=_qs_[1];if(0 === n$0)return [0,0,s$2]}
           break
          }
        throw [0,Assert_failure,_D_]}}
    function nth_term$0(n,p)
     {var n$0=n,p$0=p;
      for(;;)
       {var switch$0=0;
        switch(p$0[0])
         {case 1:
           var _qp_=p$0[1],switch$1=0;
           switch(_qp_[0])
            {case 0:var q=p$0[2];break;
             case 3:if(0 === _qp_[1][0])var q=p$0[2];else switch$1 = 1;break;
             default:switch$1 = 1}
           if(! switch$1)
            {if(0 === n$0)return source$2(_qp_);
             var n$1=n$0 - 1 | 0,n$0=n$1,p$0=q;
             continue}
           break;
          case 3:if(0 === p$0[1][0])switch$0 = 1;break;
          case 2:break;
          default:switch$0 = 1}
        if(switch$0)
         {if(0 === n$0)return source$2(p$0);
          if(1 === n$0)return target$2(p$0);
          throw [0,Assert_failure,_E_]}
        throw [0,Assert_failure,_F_]}}
    function to_list(param)
     {switch(param[0])
       {case 0:var s=param[1];return [0,[0,s],0];
        case 1:
         var q=param[2],p=param[1],_qk_=to_list(q),_ql_=to_list(p);
         return caml_call2(Stdlib[37],_ql_,_qk_);
        case 2:return 0;
        default:
         var
          p$0=param[1],
          _qm_=to_list(p$0),
          _qn_=caml_call1(List[9],_qm_),
          _qo_=function(p){return [3,p]};
         return caml_call2(List[19],_qo_,_qn_)}}
    function parse$0(rs,s)
     {function unid(param)
       {if(2 === param[0]){var t=param[1];return t}
        throw [0,Assert_failure,_G_]}
      function aux(param)
       {var _qb_=param[1];
        if(4150143 <= _qb_)
         {if(4298439 <= _qb_)
           {var x=param[2],x$0=parse_var(x);return [2,[1,x$0]]}
          var l=param[2];
          return concat$1(caml_call2(List[19],aux,l))}
        if(3654865 <= _qb_){var p=param[2];return [3,aux(p)]}
        var
         match=param[2],
         a=match[2],
         f=match[1],
         a$0=caml_call2(List[19],aux,a);
        try
         {var
           _qd_=rs[1],
           _qe_=function(o){return caml_string_equal(caml_call1(Op[1],o),f)},
           f$0=caml_call2(List[38],_qe_,_qd_);
          if(caml_call2(List[32],is_id,a$0))
           var a$2=caml_call2(List[19],unid,a$0),t=app(f$0,a$2),_qf_=[2,t];
          else
           {try
             {var
               _qg_=function(p){return 1 - is_id(p)},
               n=caml_call2(List[63],_qg_,a$0)}
            catch(_qj_)
             {_qj_ = caml_wrap_exception(_qj_);
              if(_qj_ === Stdlib[8])throw [0,Assert_failure,_H_];
              throw _qj_}
            var
             t$0=caml_call2(List[7],a$0,n),
             match$0=list_remove_nth(n,a$0),
             a2=match$0[2],
             a1=match$0[1],
             a1$0=caml_call2(List[19],unid,a1),
             a2$0=caml_call2(List[19],unid,a2),
             tm_ctx=
              function(t)
               {var _qi_=caml_call2(Stdlib[37],[0,t,0],a2$0);
                return app(f$0,caml_call2(Stdlib[37],a1$0,_qi_))},
             rs_ctx=function(t){return caml_call4(Step[2],f$0,a1$0,t,a2$0)},
             _qf_=map$1(tm_ctx,rs_ctx,t$0)}
          return _qf_}
        catch(_qh_)
         {_qh_ = caml_wrap_exception(_qh_);
          if(_qh_ === Stdlib[8])
           {var
             r=find$2(rs,f),
             a$1=caml_call2(List[19],unid,a$0),
             _qc_=caml_call1(Rule[6],r),
             s=caml_call3(List[28],pair,_qc_,a$1);
            return [0,caml_call2(Step[3],r,s)]}
          throw _qh_}}
      return aux(parser(s))}
    var
     Zigzag=
      [0,
       to_string$7,
       source$2,
       target$2,
       step$0,
       comp,
       append$1,
       concat$1,
       inv$0,
       eq$6,
       length$1,
       of_path,
       map$1,
       subst$0,
       rule_occurences,
       rule_algebraic_occurences,
       is_id,
       is_inv,
       has_rule$0,
       canonize,
       value,
       replace_rule,
       nth_step$0,
       nth_term$0,
       to_list,
       parse$0];
    function make$3(p)
     {var _qa_=caml_call1(Zigzag[3],p);
      if(eq$1(caml_call1(Zigzag[2],p),_qa_))return p;
      throw [0,Assert_failure,_I_]}
    var to_string$8=Zigzag[1],comp$0=Zigzag[5],inv$1=Zigzag[8];
    function of_cell(p1,p2)
     {var _p__=caml_call1(Zigzag[2],p2);
      if(eq$1(caml_call1(Zigzag[2],p1),_p__))
       {var _p$_=caml_call1(Zigzag[3],p2);
        if(eq$1(caml_call1(Zigzag[3],p1),_p$_))
         return caml_call2(comp$0,p1,caml_call1(inv$1,p2));
        throw [0,Assert_failure,_J_]}
      throw [0,Assert_failure,_K_]}
    var
     canonize$0=Zigzag[19],
     value$0=Zigzag[20],
     replace_rule$0=Zigzag[21],
     length$2=Zigzag[10];
    function rotate(k,p)
     {var
       n=caml_call1(length$2,p),
       k$0=caml_call2(Int[1],k,n),
       l=caml_call1(Zigzag[24],p),
       l1=caml_call3(List[66],l,0,k$0),
       l2=caml_call3(List[66],l,k$0,n - k$0 | 0),
       l1$0=caml_call1(Zigzag[7],l1),
       l2$0=caml_call1(Zigzag[7],l2);
      return caml_call2(Zigzag[5],l2$0,l1$0)}
    var
     Loop=
      [0,
       make$3,
       to_string$8,
       comp$0,
       inv$1,
       of_cell,
       canonize$0,
       value$0,
       replace_rule$0,
       length$2,
       rotate];
    function name$1(c){return c[1]}
    function loop(c){return c[2]}
    function make$4(name,loop){return [0,name,loop]}
    function to_string$9(var$0,c)
     {var p=caml_call1(Loop[6],c[2]),_p9_=caml_call3(Loop[2],0,[0,var$0],p);
      return caml_call3(Stdlib_Printf[4],_L_,c[1],_p9_)}
    function rotate$0(n,init)
     {var _p8_=caml_call2(Loop[10],n,init[2]);return [0,init[1],_p8_]}
    function value$1(r,c){return caml_call2(Loop[7],r,c[2])}
    function replace_rule$1(r,v,init)
     {var _p7_=caml_call3(Loop[8],r,v,init[2]);return [0,init[1],_p7_]}
    var
     Path$0=[0],
     Coherence=
      [0,
       name$1,
       loop,
       make$4,
       to_string$9,
       rotate$0,
       value$1,
       replace_rule$1,
       Path$0];
    function rs(crs){return crs[1]}
    function rules$1(crs){return crs[1][2]}
    function coherence(crs){return crs[2]}
    function set_rules(crs,rules){return [0,[0,crs[1][1],rules],crs[2]]}
    function to_string$10(opt,crs)
     {if(opt)var sth=opt[1],var$0=sth;else var var$0=Var[3];
      var _p4_=crs[2];
      function _p5_(c)
       {var _p6_=caml_call1(var$0,0);return caml_call2(Coherence[4],_p6_,c)}
      var
       coherence=caml_call2(List[19],_p5_,_p4_),
       coherence$0=caml_call2(String[6],cst$21,coherence);
      return coherence$0}
    function to_tex(opt,crs)
     {if(opt)var sth=opt[1],var$0=sth;else var var$0=Var[4];
      var ans=[0,cst$22];
      function print(s)
       {function _p3_(s){ans[1] = caml_call2(Stdlib[28],ans[1],s);return 0}
        return caml_call2(Stdlib_Printf[10],_p3_,s)}
      print(_M_);
      var _md_=rules$1(crs);
      function _me_(r)
       {var
         var$1=caml_call1(var$0,0),
         _p0_=caml_call1(Rule[4],r),
         s=caml_call1(string_of_term([0,var$1]),_p0_),
         _p1_=caml_call1(Rule[5],r),
         t=caml_call1(string_of_term([0,var$1]),_p1_),
         _p2_=caml_call1(Rule[3],r);
        return caml_call4(Stdlib_Printf[4],_N_,_p2_,s,t)}
      var
       rules=caml_call2(List[19],_me_,_md_),
       rules$0=caml_call2(String[6],cst$23,rules);
      caml_call1(print(_O_),rules$0);
      print(_P_);
      var _mf_=crs[2];
      function _mg_(c)
       {var
         _mh_=caml_call1(Coherence[2],c),
         p=caml_call1(Loop[6],_mh_),
         _mi_=caml_call3(Loop[2],0,0,p),
         _mj_=caml_call1(Coherence[1],c);
        caml_call3(Stdlib_Printf[2],_Q_,_mj_,_mi_);
        var l=caml_call1(Zigzag[24],p);
        if(0 !== l)caml_call1(Zigzag[7],l);
        var n=caml_call1(List[1],l);
        if(0 === n)
         var p2=p,p1=p;
        else
         try
          {var k=caml_call2(List[63],Zigzag[17],l);
           if(0 === k)throw Stdlib[3];
           var
            l1$0=caml_call3(List[66],l,0,k),
            l2$0=caml_call3(List[66],l,k,n - k | 0);
           if(1 - caml_call2(List[32],Zigzag[17],l2$0))throw Stdlib[3];
           var
            p1$1=caml_call1(Zigzag[7],l1$0),
            _mp_=caml_call1(Zigzag[7],l2$0),
            _mq_=caml_call1(Zigzag[8],_mp_),
            p2$1=caml_call1(Zigzag[19],_mq_),
            _mr_=caml_call1(List[1],l2$0);
           if(_mr_ < caml_call1(List[1],l1$0))
            var p2$2=p1$1,p1$2=p2$1;
           else
            var p2$2=p2$1,p1$2=p1$1;
           var
            p2$3=caml_call1(Zigzag[19],p2$2),
            _ms_=caml_call1(Zigzag[19],p1$2),
            p2=p2$3,
            p1=_ms_}
         catch(_pZ_)
          {_pZ_ = caml_wrap_exception(_pZ_);
           if(_pZ_ !== Stdlib[3] && _pZ_ !== Stdlib[8])throw _pZ_;
           var
            l1=caml_call3(List[66],l,0,n / 2 | 0),
            l2=caml_call3(List[66],l,n / 2 | 0,n - (n / 2 | 0) | 0),
            _mn_=caml_call1(Zigzag[7],l2),
            _mo_=caml_call1(Zigzag[8],_mn_),
            p2$0=caml_call1(Zigzag[19],_mo_),
            p1$0=caml_call1(Zigzag[7],l1),
            p2=p2$0,
            p1=p1$0}
        var
         _mk_=caml_call3(Zigzag[1],0,0,p2),
         _ml_=caml_call3(Zigzag[1],0,0,p1);
        caml_call3(Stdlib_Printf[2],_R_,_ml_,_mk_);
        var var$1=caml_call1(var$0,0);
        function st(n,p)
         {var
           match=caml_call2(Zigzag[22],n,p),
           s=match[2],
           d=match[1],
           d$0=d?cst$24:cst$27,
           s$0=caml_call2(Step[7],[0,var$1],s),
           _pX_=caml_call2(Stdlib[28],s$0,cst$25),
           _pY_=caml_call2(Stdlib[28],cst$26,_pX_);
          return caml_call2(Stdlib[28],d$0,_pY_)}
        function tm(n,p)
         {var _pW_=caml_call2(Zigzag[23],n,p);
          return caml_call1(string_of_term([0,var$1]),_pW_)}
        function cd(param)
         {var
           match=caml_call1(Zigzag[10],p1),
           match$0=caml_call1(Zigzag[10],p2),
           _mt_=match - 1 | 0;
          if(! (2 < _mt_ >>> 0))
           switch(_mt_)
            {case 0:
              var switcher=match$0 - 1 | 0;
              if(! (5 < switcher >>> 0))
               switch(switcher)
                {case 0:
                  var _ne_=tm(1,p1),_nf_=st(0,p2),_ng_=st(0,p1),_nh_=tm(0,p1);
                  return caml_call4(print(_ac_),_nh_,_ng_,_nf_,_ne_);
                 case 1:
                  var
                   _ni_=tm(2,p2),
                   _nj_=st(1,p2),
                   _nk_=tm(1,p2),
                   _nl_=st(0,p2),
                   _nm_=st(0,p1),
                   _nn_=tm(0,p1);
                  return caml_call6(print(_ad_),_nn_,_nm_,_nl_,_nk_,_nj_,_ni_);
                 case 2:
                  var
                   _no_=tm(3,p2),
                   _np_=st(2,p2),
                   _nq_=tm(2,p2),
                   _nr_=st(1,p2),
                   _ns_=tm(1,p2),
                   _nt_=st(0,p2),
                   _nu_=st(0,p1),
                   _nv_=tm(0,p1);
                  return caml_call8
                          (print(_ae_),_nv_,_nu_,_nt_,_ns_,_nr_,_nq_,_np_,_no_);
                 case 3:
                  var
                   _nw_=tm(4,p2),
                   _nx_=st(3,p2),
                   _ny_=tm(3,p2),
                   _nz_=st(2,p2),
                   _nA_=tm(2,p2),
                   _nB_=st(1,p2),
                   _nC_=tm(1,p2),
                   _nD_=st(0,p2),
                   _nE_=st(0,p1),
                   _nF_=tm(0,p1);
                  return caml_call10
                          (print(_af_),
                           _nF_,
                           _nE_,
                           _nD_,
                           _nC_,
                           _nB_,
                           _nA_,
                           _nz_,
                           _ny_,
                           _nx_,
                           _nw_);
                 case 4:
                  var
                   _nG_=tm(5,p2),
                   _nH_=st(4,p2),
                   _nI_=tm(4,p2),
                   _nJ_=st(3,p2),
                   _nK_=tm(3,p2),
                   _nL_=st(2,p2),
                   _nM_=tm(2,p2),
                   _nN_=st(1,p2),
                   _nO_=tm(1,p2),
                   _nP_=st(0,p2),
                   _nQ_=st(0,p1),
                   _nR_=tm(0,p1);
                  return caml_call12
                          (print(_ag_),
                           _nR_,
                           _nQ_,
                           _nP_,
                           _nO_,
                           _nN_,
                           _nM_,
                           _nL_,
                           _nK_,
                           _nJ_,
                           _nI_,
                           _nH_,
                           _nG_);
                 default:
                  var
                   _nS_=tm(6,p2),
                   _nT_=st(5,p2),
                   _nU_=tm(5,p2),
                   _nV_=st(4,p2),
                   _nW_=tm(4,p2),
                   _nX_=st(3,p2),
                   _nY_=tm(3,p2),
                   _nZ_=st(2,p2),
                   _n0_=tm(2,p2),
                   _n1_=st(1,p2),
                   _n2_=tm(1,p2),
                   _n3_=st(0,p2),
                   _n4_=st(0,p1),
                   _n5_=tm(0,p1);
                  return caml_call14
                          (print(_ah_),
                           _n5_,
                           _n4_,
                           _n3_,
                           _n2_,
                           _n1_,
                           _n0_,
                           _nZ_,
                           _nY_,
                           _nX_,
                           _nW_,
                           _nV_,
                           _nU_,
                           _nT_,
                           _nS_)}
              break;
             case 1:
              var switcher$0=match$0 - 2 | 0;
              if(! (2 < switcher$0 >>> 0))
               switch(switcher$0)
                {case 0:
                  var
                   _n6_=tm(2,p1),
                   _n7_=st(1,p1),
                   _n8_=tm(1,p1),
                   _n9_=st(1,p2),
                   _n__=tm(1,p2),
                   _n$_=st(0,p2),
                   _oa_=st(0,p1),
                   _ob_=tm(0,p1);
                  return caml_call8
                          (print(_ai_),_ob_,_oa_,_n$_,_n__,_n9_,_n8_,_n7_,_n6_);
                 case 1:
                  var
                   _oc_=tm(2,p1),
                   _od_=st(1,p1),
                   _oe_=tm(1,p1),
                   _of_=st(2,p2),
                   _og_=tm(2,p2),
                   _oh_=st(1,p2),
                   _oi_=tm(1,p2),
                   _oj_=st(0,p2),
                   _ok_=st(0,p1),
                   _ol_=tm(0,p1);
                  return caml_call10
                          (print(_aj_),
                           _ol_,
                           _ok_,
                           _oj_,
                           _oi_,
                           _oh_,
                           _og_,
                           _of_,
                           _oe_,
                           _od_,
                           _oc_);
                 default:
                  var
                   _om_=tm(2,p1),
                   _on_=st(1,p1),
                   _oo_=tm(1,p1),
                   _op_=st(3,p2),
                   _oq_=tm(3,p2),
                   _or_=st(2,p2),
                   _os_=tm(2,p2),
                   _ot_=st(1,p2),
                   _ou_=tm(1,p2),
                   _ov_=st(0,p2),
                   _ow_=st(0,p1),
                   _ox_=tm(0,p1);
                  return caml_call12
                          (print(_ak_),
                           _ox_,
                           _ow_,
                           _ov_,
                           _ou_,
                           _ot_,
                           _os_,
                           _or_,
                           _oq_,
                           _op_,
                           _oo_,
                           _on_,
                           _om_)}
              break;
             default:
              var switcher$1=match$0 - 5 | 0;
              if(! (5 < switcher$1 >>> 0))
               switch(switcher$1)
                {case 0:
                  var
                   _oy_=tm(3,p1),
                   _oz_=st(2,p1),
                   _oA_=tm(2,p1),
                   _oB_=st(1,p1),
                   _oC_=tm(1,p1),
                   _oD_=st(4,p2),
                   _oE_=tm(4,p2),
                   _oF_=st(3,p2),
                   _oG_=tm(3,p2),
                   _oH_=st(2,p2),
                   _oI_=tm(2,p2),
                   _oJ_=st(1,p2),
                   _oK_=tm(1,p2),
                   _oL_=st(0,p2),
                   _oM_=st(0,p1),
                   _oN_=tm(0,p1);
                  return caml_call16
                          (print(_al_),
                           _oN_,
                           _oM_,
                           _oL_,
                           _oK_,
                           _oJ_,
                           _oI_,
                           _oH_,
                           _oG_,
                           _oF_,
                           _oE_,
                           _oD_,
                           _oC_,
                           _oB_,
                           _oA_,
                           _oz_,
                           _oy_);
                 case 3:
                  var
                   _oO_=tm(3,p1),
                   _oP_=st(2,p1),
                   _oQ_=tm(2,p1),
                   _oR_=st(1,p1),
                   _oS_=tm(1,p1),
                   _oT_=st(7,p2),
                   _oU_=tm(7,p2),
                   _oV_=st(6,p2),
                   _oW_=tm(6,p2),
                   _oX_=st(5,p2),
                   _oY_=tm(5,p2),
                   _oZ_=st(4,p2),
                   _o0_=tm(4,p2),
                   _o1_=st(3,p2),
                   _o2_=tm(3,p2),
                   _o3_=st(2,p2),
                   _o4_=tm(2,p2),
                   _o5_=st(1,p2),
                   _o6_=tm(1,p2),
                   _o7_=st(0,p2),
                   _o8_=st(0,p1),
                   _o9_=tm(0,p1);
                  return caml_call22
                          (print(_am_),
                           _o9_,
                           _o8_,
                           _o7_,
                           _o6_,
                           _o5_,
                           _o4_,
                           _o3_,
                           _o2_,
                           _o1_,
                           _o0_,
                           _oZ_,
                           _oY_,
                           _oX_,
                           _oW_,
                           _oV_,
                           _oU_,
                           _oT_,
                           _oS_,
                           _oR_,
                           _oQ_,
                           _oP_,
                           _oO_);
                 case 4:
                  var
                   _o__=tm(3,p1),
                   _o$_=st(2,p1),
                   _pa_=tm(2,p1),
                   _pb_=st(1,p1),
                   _pc_=tm(1,p1),
                   _pd_=st(8,p2),
                   _pe_=tm(8,p2),
                   _pf_=st(7,p2),
                   _pg_=tm(7,p2),
                   _ph_=st(6,p2),
                   _pi_=tm(6,p2),
                   _pj_=st(5,p2),
                   _pk_=tm(5,p2),
                   _pl_=st(4,p2),
                   _pm_=tm(4,p2),
                   _pn_=st(3,p2),
                   _po_=tm(3,p2),
                   _pp_=st(2,p2),
                   _pq_=tm(2,p2),
                   _pr_=st(1,p2),
                   _ps_=tm(1,p2),
                   _pt_=st(0,p2),
                   _pu_=st(0,p1),
                   _pv_=tm(0,p1);
                  return caml_call24
                          (print(_an_),
                           _pv_,
                           _pu_,
                           _pt_,
                           _ps_,
                           _pr_,
                           _pq_,
                           _pp_,
                           _po_,
                           _pn_,
                           _pm_,
                           _pl_,
                           _pk_,
                           _pj_,
                           _pi_,
                           _ph_,
                           _pg_,
                           _pf_,
                           _pe_,
                           _pd_,
                           _pc_,
                           _pb_,
                           _pa_,
                           _o$_,
                           _o__);
                 case 5:
                  var
                   _pw_=tm(3,p1),
                   _px_=st(2,p1),
                   _py_=tm(2,p1),
                   _pz_=st(1,p1),
                   _pA_=tm(1,p1),
                   _pB_=st(9,p2),
                   _pC_=tm(9,p2),
                   _pD_=st(8,p2),
                   _pE_=tm(8,p2),
                   _pF_=st(7,p2),
                   _pG_=tm(7,p2),
                   _pH_=st(6,p2),
                   _pI_=tm(6,p2),
                   _pJ_=st(5,p2),
                   _pK_=tm(5,p2),
                   _pL_=st(4,p2),
                   _pM_=tm(4,p2),
                   _pN_=st(3,p2),
                   _pO_=tm(3,p2),
                   _pP_=st(2,p2),
                   _pQ_=tm(2,p2),
                   _pR_=st(1,p2),
                   _pS_=tm(1,p2),
                   _pT_=st(0,p2),
                   _pU_=st(0,p1),
                   _pV_=tm(0,p1);
                  return caml_call26
                          (print(_ao_),
                           _pV_,
                           _pU_,
                           _pT_,
                           _pS_,
                           _pR_,
                           _pQ_,
                           _pP_,
                           _pO_,
                           _pN_,
                           _pM_,
                           _pL_,
                           _pK_,
                           _pJ_,
                           _pI_,
                           _pH_,
                           _pG_,
                           _pF_,
                           _pE_,
                           _pD_,
                           _pC_,
                           _pB_,
                           _pA_,
                           _pz_,
                           _py_,
                           _px_,
                           _pw_)
                 }}
          if(2 <= match && match$0 === (match + 1 | 0))
           {var
             _mu_=st(2,p2),
             _mv_=tm(2,p2),
             _mw_=st(1,p2),
             _mx_=tm(1,p2),
             _my_=st(0,p2),
             _mz_=st(0,p1),
             _mA_=tm(0,p1);
            caml_call7(print(_S_),_mA_,_mz_,_my_,_mx_,_mw_,_mv_,_mu_);
            var _mC_=match - 2 | 0,_mB_=1;
            if(! (_mC_ < 1))
             {var i$0=_mB_;
              for(;;)
               {var
                 _mG_=st(i$0 + 2 | 0,p2),
                 _mH_=tm(i$0 + 2 | 0,p2),
                 _mI_=st(i$0,p1),
                 _mJ_=tm(i$0,p1);
                caml_call4(print(_U_),_mJ_,_mI_,_mH_,_mG_);
                var _mK_=i$0 + 1 | 0;
                if(_mC_ !== i$0){var i$0=_mK_;continue}
                break}}
            var
             i=match - 1 | 0,
             _mD_=tm(i + 2 | 0,p2),
             _mE_=st(i,p1),
             _mF_=tm(i,p1);
            return caml_call3(print(_T_),_mF_,_mE_,_mD_)}
          if(3 <= match && match$0 === match)
           {var
             _mL_=st(2,p2),
             _mM_=tm(2,p2),
             _mN_=st(1,p2),
             _mO_=tm(1,p2),
             _mP_=st(0,p2),
             _mQ_=st(0,p1),
             _mR_=tm(0,p1);
            caml_call7(print(_V_),_mR_,_mQ_,_mP_,_mO_,_mN_,_mM_,_mL_);
            var _mT_=match - 3 | 0,_mS_=1;
            if(! (_mT_ < 1))
             {var i$2=_mS_;
              for(;;)
               {var
                 _mZ_=st(i$2 + 2 | 0,p2),
                 _m0_=tm(i$2 + 2 | 0,p2),
                 _m1_=st(i$2,p1),
                 _m2_=tm(i$2,p1);
                caml_call4(print(_X_),_m2_,_m1_,_m0_,_mZ_);
                var _m3_=i$2 + 1 | 0;
                if(_mT_ !== i$2){var i$2=_m3_;continue}
                break}}
            var
             i$1=match - 2 | 0,
             _mU_=tm(i$1 + 2 | 0,p2),
             _mV_=st(i$1 + 1 | 0,p1),
             _mW_=tm(i$1 + 1 | 0,p1),
             _mX_=st(i$1,p1),
             _mY_=tm(i$1,p1);
            return caml_call5(print(_W_),_mY_,_mX_,_mW_,_mV_,_mU_)}
          var
           _m4_=caml_call1(Zigzag[8],p2),
           _m5_=caml_call2(Zigzag[6],p1,_m4_),
           p=caml_call1(Zigzag[19],_m5_);
          caml_call3(Stdlib_Printf[2],_Y_,match,match$0);
          if(caml_call1(Zigzag[16],p))
           {var _m6_=caml_call3(Zigzag[1],0,[0,var$1],p);
            return caml_call1(print(_Z_),_m6_)}
          var l=caml_call1(Zigzag[10],p);
          caml_call2(Stdlib_Printf[2],___,l);
          var _m8_=(l - 1 | 0) / 2 | 0,n=2,_m7_=0;
          if(! (_m8_ < 0))
           {var i$3=_m7_;
            for(;;)
             {var _m9_=tm(i$3 * 2 | 0,p);
              caml_call1(print(_$_),_m9_);
              var
               _m$_=caml_call2(Stdlib[16],n,l - (i$3 * 2 | 0) | 0) - 1 | 0,
               _m__=0;
              if(! (_m$_ < 0))
               {var j=_m__;
                for(;;)
                 {var
                   _nb_=tm(((i$3 * 2 | 0) + j | 0) + 1 | 0,p),
                   _nc_=st((i$3 * 2 | 0) + j | 0,p);
                  caml_call2(print(_ab_),_nc_,_nb_);
                  var _nd_=j + 1 | 0;
                  if(_m$_ !== j){var j=_nd_;continue}
                  break}}
              print(_aa_);
              var _na_=i$3 + 1 | 0;
              if(_m8_ !== i$3){var i$3=_na_;continue}
              break}}
          return 0}
        var _mm_=caml_call1(Coherence[1],c);
        caml_call1(print(_ap_),_mm_);
        print(_aq_);
        cd(0);
        return print(_ar_)}
      caml_call2(List[17],_mg_,_mf_);
      print(_as_);
      return ans[1]}
    function view_pdf(var$0,rs)
     {var
       match=caml_call5(Stdlib_Filename[17],0,0,0,cst_ocaml_alg,cst_tex),
       oc=match[2],
       fname=match[1],
       _mb_=to_tex(var$0,rs);
      caml_call2(Stdlib[66],oc,_mb_);
      caml_call1(Stdlib[76],oc);
      var
       _mc_=caml_call1(Stdlib_Filename[18],0),
       cmd=caml_call4(Stdlib_Printf[4],_at_,_mc_,fname,fname);
      if(0 === runtime.caml_sys_system_command(cmd))return 0;
      throw [0,Assert_failure,_au_]}
    function make$5(rs,coherence){return [0,rs,coherence]}
    function find_rule(crs,r){return find$2(crs[1],r)}
    function find$3(rs,crs)
     {var _l$_=rs[2];
      function _ma_(c)
       {return caml_string_equal(caml_call1(Coherence[1],c),crs)}
      return caml_call2(List[38],_ma_,_l$_)}
    function add_coherence(crs,c,p)
     {var _l9_=caml_call1(Zigzag[3],p);
      if(eq$1(caml_call1(Zigzag[2],p),_l9_))
       {var
         _l__=[0,caml_call2(Coherence[3],c,p),0],
         coherence=caml_call2(Stdlib[37],crs[2],_l__);
        return [0,crs[1],coherence]}
      throw [0,Assert_failure,_av_]}
    function rotate$1(crs,cname,n)
     {var _l7_=crs[2];
      function _l8_(c)
       {return caml_string_equal(caml_call1(Coherence[1],c),cname)
                ?caml_call2(Coherence[5],n,c)
                :c}
      var coherence=caml_call2(List[19],_l8_,_l7_);
      return [0,crs[1],coherence]}
    function elim_rule(crs,r,c)
     {var
       r$0=find_rule(crs,r),
       c$0=find$3(crs,c),
       v=caml_call2(Coherence[6],r$0,c$0),
       var$0=caml_call1(Var[4],0),
       _l1_=caml_call3(Zigzag[1],0,[0,var$0],v),
       _l2_=caml_call2(Rule[10],[0,var$0],r$0);
      caml_call3(Stdlib_Printf[2],_aw_,_l2_,_l1_);
      var _l3_=rules$1(crs);
      function _l4_(r){return 1 - caml_call2(Rule[11],r$0,r)}
      var rules=caml_call2(List[41],_l4_,_l3_),_l5_=crs[2];
      function _l6_(c){return caml_call3(Coherence[7],r$0,v,c)}
      var coherence=caml_call2(List[19],_l6_,_l5_);
      return [0,[0,crs[1][1],rules],coherence]}
    var
     Morphism=[0],
     Coherent=
      [0,
       rs,
       rules$1,
       coherence,
       set_rules,
       to_string$10,
       to_tex,
       view_pdf,
       make$5,
       find_rule,
       find$3,
       add_coherence,
       rotate$1,
       elim_rule,
       Morphism],
     RS=
      [0,
       list_remove_nth,
       Rule,
       operations,
       rules,
       make$2,
       empty$1,
       to_string$4,
       find$2,
       Step,
       steps,
       Path,
       normalize,
       critical_rules,
       critical,
       orient,
       knuth_bendix,
       Not_confluent,
       squier,
       Zigzag,
       Loop,
       Coherence,
       Coherent],
     Alg_Term=
      [0,
       Op,
       Var,
       var$0,
       app,
       parser,
       parse_var,
       parse,
       eq$1,
       eq$1,
       to_string$1,
       string_of_term,
       is_var,
       get_var,
       vars$0,
       occurs,
       LPO,
       Substitution,
       Not_unifiable,
       unify,
       matches,
       equivalent,
       RS];
    caml_register_global(269,Alg_Term,"Alg__Term");
    function eq$7(c,d){return c === d?1:0}
    function to_string$11(c){return caml_call2(Stdlib_String[1],1,c)}
    var compare$1=caml_int_compare;
    function leq(c,d){return c <= d?1:0}
    function geq(c,d){return d <= c?1:0}
    var
     Char=[0,eq$7,to_string$11,compare$1,leq,geq],
     CharAlphabet=[0,Char[1],Char[2],Char[3]];
    function eq$8(s,t){return caml_string_equal(s,t)}
    function to_string$12(s){return s}
    function compare$2(s,t){return runtime.caml_string_compare(s,t)}
    var String$0=[0,eq$8,to_string$12,compare$2];
    function eq$9(i,j){return i === j?1:0}
    var to_string$13=Stdlib[33],compare$3=caml_int_compare;
    function leq$0(i,j){return i <= j?1:0}
    function geq$0(i,j){return j <= i?1:0}
    var
     Int$0=[0,eq$9,to_string$13,compare$3,leq$0,geq$0],
     IntAlphabet=[0,Int$0[1],Int$0[2],Int$0[3]];
    function eq$10(param,_l0_){return 1}
    function compare$4(param,_lZ_){return 0}
    function to_string$14(param){return cst$28}
    var Unit=[0,eq$10,to_string$14,compare$4];
    function Prod(A,B)
     {function eq(param,_lX_)
       {var
         b=_lX_[2],
         a=_lX_[1],
         b$0=param[2],
         a$0=param[1],
         _lY_=caml_call2(A[1],a$0,a);
        return _lY_?caml_call2(B[1],b$0,b):_lY_}
      function compare(param,_lW_)
       {var
         b=_lW_[2],
         a=_lW_[1],
         b$0=param[2],
         a$0=param[1],
         c=caml_call2(A[3],a$0,a);
        return 0 === c?caml_call2(B[3],b$0,b):c}
      function to_string(param)
       {var
         b=param[2],
         a=param[1],
         _lR_=caml_call1(B[2],b),
         _lS_=caml_call2(Stdlib[28],_lR_,cst$29),
         _lT_=caml_call2(Stdlib[28],cst$30,_lS_),
         _lU_=caml_call1(A[2],a),
         _lV_=caml_call2(Stdlib[28],_lU_,_lT_);
        return caml_call2(Stdlib[28],cst$31,_lV_)}
      return [0,eq,to_string,compare]}
    function Prod3(A,B,C)
     {function eq(param,_lN_)
       {var
         c=_lN_[3],
         b=_lN_[2],
         a=_lN_[1],
         c$0=param[3],
         b$0=param[2],
         a$0=param[1],
         _lO_=caml_call2(A[1],a$0,a);
        if(_lO_)
         {var _lP_=caml_call2(B[1],b$0,b);
          if(_lP_)return caml_call2(C[1],c$0,c);
          var _lQ_=_lP_}
        else
         var _lQ_=_lO_;
        return _lQ_}
      function compare(param,_lM_)
       {var
         c=_lM_[3],
         b=_lM_[2],
         a=_lM_[1],
         c$0=param[3],
         b$0=param[2],
         a$0=param[1],
         comp=caml_call2(A[3],a$0,a);
        if(0 === comp)
         {var comp$0=caml_call2(B[3],b$0,b);
          return 0 === comp$0?caml_call2(C[3],c$0,c):comp$0}
        return comp}
      function to_string(param)
       {var
         c=param[3],
         b=param[2],
         a=param[1],
         _lE_=caml_call1(C[2],c),
         _lF_=caml_call2(Stdlib[28],_lE_,cst$32),
         _lG_=caml_call2(Stdlib[28],cst$33,_lF_),
         _lH_=caml_call1(B[2],b),
         _lI_=caml_call2(Stdlib[28],_lH_,_lG_),
         _lJ_=caml_call2(Stdlib[28],cst$34,_lI_),
         _lK_=caml_call1(A[2],a),
         _lL_=caml_call2(Stdlib[28],_lK_,_lJ_);
        return caml_call2(Stdlib[28],cst$35,_lL_)}
      return [0,eq,to_string,compare]}
    function Pow(A)
     {var S=caml_call1(Stdlib_Set[1],[0,A[3]]);
      function eq(u,v){return caml_call2(S[12],u,v)}
      function compare(u,v){return caml_call2(S[11],u,v)}
      function to_string(u)
       {function _lA_(x,s)
         {if(caml_string_equal(s,cst$37))return caml_call1(A[2],x);
          var _lC_=caml_call1(A[2],x),_lD_=caml_call2(Stdlib[28],cst$38,_lC_);
          return caml_call2(Stdlib[28],s,_lD_)}
        var
         s=caml_call3(S[16],_lA_,u,cst$36),
         _lB_=caml_call2(Stdlib[28],s,cst$39);
        return caml_call2(Stdlib[28],cst$40,_lB_)}
      var empty=S[1];
      function of_list(l){return caml_call1(S[37],l)}
      function add(u,x){return caml_call2(S[4],x,u)}
      function mem(u,x){return caml_call2(S[3],x,u)}
      function iter(f,u){return caml_call2(S[14],f,u)}
      return [0,S,eq,compare,to_string,empty,of_list,add,mem,iter]}
    function PowAlphabet(_ly_)
     {var _lz_=Pow(_ly_);return [0,_lz_[2],_lz_[4],_lz_[3]]}
    function List$0(A)
     {function eq(u,v)
       {try
         {var
           _lv_=function(x,y){return caml_call2(A[1],x,y)},
           _lw_=caml_call3(Stdlib_List[34],_lv_,u,v);
          return _lw_}
        catch(_lx_)
         {_lx_ = caml_wrap_exception(_lx_);
          if(_lx_[1] === Stdlib[6])return 0;
          throw _lx_}}
      function to_string(u)
       {var _lu_=caml_call2(Stdlib_List[19],A[2],u);
        return caml_call2(Stdlib_String[6],cst$41,_lu_)}
      function compare(u,v)
       {var u$0=u,v$0=v;
        for(;;)
         {if(u$0)
           {if(v$0)
             {var
               v$1=v$0[2],
               y=v$0[1],
               u$1=u$0[2],
               x=u$0[1],
               c=caml_call2(A[3],x,y);
              if(0 === c){var u$0=u$1,v$0=v$1;continue}
              return c}
            return 1}
          return v$0?-1:0}}
      return [0,eq,to_string,compare]}
    function ListAlphabet(_lt_){return List$0(_lt_)}
    function Map(A,B)
     {var M=caml_call1(Stdlib_Map[1],[0,A[3]]),empty=M[1];
      function app(f,x){return caml_call2(M[28],x,f)}
      function add(f,x,v){return caml_call3(M[4],x,v,f)}
      function mem(f,x){return caml_call2(M[3],x,f)}
      var iter=M[12];
      return [0,M,empty,app,add,mem,iter]}
    var
     Alg_Alphabet=
      [0,
       Char,
       CharAlphabet,
       String$0,
       Int$0,
       IntAlphabet,
       Unit,
       Prod,
       Prod3,
       Pow,
       PowAlphabet,
       List$0,
       ListAlphabet,
       Map];
    caml_register_global(272,Alg_Alphabet,"Alg__Alphabet");
    function Pres(X){return [0]}
    var Alg_Simplicial=[0,Pres];
    caml_register_global(273,Alg_Simplicial,"Alg__Simplicial");
    function eq$11(x,y){return x === y?1:0}
    function add$0(x,y)
     {var x$0=x || y;
      if(x$0)var y$0=x?y:x,_ls_=1 - y$0;else var _ls_=x$0;
      return _ls_}
    var zero=0;
    function neg(x){return x}
    function mul(x,y){var y$0=x?y:x;return y$0}
    var one=1;
    function to_string$15(x){return x?cst_T:cst_F}
    var include=[0,eq$11,add$0,zero,neg,mul,one,to_string$15];
    function eq$12(x,y){return x === y?1:0}
    function add$1(_lr_,_lq_){return _lr_ + _lq_ | 0}
    var zero$0=0;
    function neg$0(x){return - x | 0}
    var
     mul$0=runtime.caml_mul,
     to_string$16=Stdlib[33],
     include$0=[0,eq$12,add$1,zero$0,neg$0,mul$0,1,to_string$16];
    function eq$13(x,y){return x == y?1:0}
    function add$2(_lp_,_lo_){return _lp_ + _lo_}
    var zero$1=0.;
    function neg$1(x){return - x}
    function mul$1(_ln_,_lm_){return _ln_ * _lm_}
    var
     to_string$17=Stdlib[35],
     include$1=[0,eq$13,add$2,zero$1,neg$1,mul$1,1.,to_string$17];
    function Polynomial(R)
     {function length(p){return p.length - 1}
      function degree(p)
       {var ans=[0,0];
        try
         {var _lh_=p.length - 1 - 1 | 0;
          if(! (_lh_ < 0))
           {var i=_lh_;
            for(;;)
             {var _lj_=caml_check_bound(p,i)[1 + i];
              if(1 - caml_call2(R[1],R[3],_lj_)){ans[1] = i;throw Stdlib[3]}
              var _lk_=i - 1 | 0;
              if(0 !== i){var i=_lk_;continue}
              break}}
          var _li_=Stdlib[20];
          return _li_}
        catch(_ll_)
         {_ll_ = caml_wrap_exception(_ll_);
          if(_ll_ === Stdlib[3])return ans[1];
          throw _ll_}}
      function eq(p,q)
       {var dp=degree(p),dq=degree(q);
        try
         {if(dp !== dq)throw Stdlib[3];
          var _lb_=dp - 1 | 0,_la_=0;
          if(! (_lb_ < 0))
           {var i=_la_;
            for(;;)
             {var
               _ld_=caml_check_bound(q,i)[1 + i],
               _le_=caml_check_bound(p,i)[1 + i];
              if(1 - caml_call2(R[1],_le_,_ld_))throw Stdlib[3];
              var _lf_=i + 1 | 0;
              if(_lb_ !== i){var i=_lf_;continue}
              break}}
          var _lc_=1;
          return _lc_}
        catch(_lg_)
         {_lg_ = caml_wrap_exception(_lg_);
          if(_lg_ === Stdlib[3])return 0;
          throw _lg_}}
      function compact(p)
       {function _k__(i){return caml_check_bound(p,i)[1 + i]}
        var _k$_=degree(p);
        return caml_call2(Stdlib_Array[2],_k$_,_k__)}
      function coeff(p,i)
       {return i < p.length - 1?caml_check_bound(p,i)[1 + i]:R[3]}
      function init(n,f){return caml_call2(Stdlib_Array[2],n,f)}
      function add(p,q)
       {var p$0=p,q$0=q;
        for(;;)
         {var pl=p$0.length - 1,ql=q$0.length - 1;
          if(ql < pl){var _k7_=q$0,q$0=p$0,p$0=_k7_;continue}
          return init
                  (ql,
                   function(i)
                    {if(i < pl)
                      {var
                        _k8_=caml_check_bound(q$0,i)[1 + i],
                        _k9_=caml_check_bound(p$0,i)[1 + i];
                       return caml_call2(R[2],_k9_,_k8_)}
                     return caml_check_bound(q$0,i)[1 + i]})}}
      var zero=[0];
      function cmul(a,p)
       {var _k6_=caml_call1(R[5],a);
        return caml_call2(Stdlib_Array[15],_k6_,p)}
      function neg(p){return cmul(caml_call1(R[4],R[6]),p)}
      function sub(p,q){return add(p,neg(q))}
      function mul(p,q)
       {function _kZ_(n)
         {var ans=[0,R[3]],_k1_=0;
          if(! (n < 0))
           {var i=_k1_;
            for(;;)
             {var
               _k2_=coeff(q,n - i | 0),
               _k3_=coeff(p,i),
               _k4_=caml_call2(R[5],_k3_,_k2_);
              ans[1] = caml_call2(R[2],ans[1],_k4_);
              var _k5_=i + 1 | 0;
              if(n !== i){var i=_k5_;continue}
              break}}
          return ans[1]}
        var _k0_=degree(q);
        return init(degree(p) + _k0_ | 0,_kZ_)}
      var one=[0,R[6]];
      function to_string(p)
       {var ans=[0,cst$42],_kP_=p.length - 1 - 1 | 0,_kO_=0;
        if(! (_kP_ < 0))
         {var i=_kO_;
          for(;;)
           {var _kQ_=caml_check_bound(p,i)[1 + i];
            if(caml_call2(R[1],R[3],_kQ_))
             var _kR_=cst$43;
            else
             {if(0 === i)
               var _kV_=cst$46;
              else
               var
                _kY_=caml_call1(Stdlib[33],i),
                _kV_=caml_call2(Stdlib[28],cst_X,_kY_);
              var
               _kW_=caml_check_bound(p,i)[1 + i],
               _kX_=caml_call1(R[7],_kW_),
               _kR_=caml_call2(Stdlib[28],_kX_,_kV_)}
            var
             _kS_=0 === i?cst$44:cst$45,
             _kT_=caml_call2(Stdlib[28],_kS_,_kR_);
            ans[1] = caml_call2(Stdlib[28],ans[1],_kT_);
            var _kU_=i + 1 | 0;
            if(_kP_ !== i){var i=_kU_;continue}
            break}}
        return ans[1]}
      function monomial(c,n)
       {var ans=caml_make_vect(n + 1 | 0,R[3]);
        caml_check_bound(ans,n)[1 + n] = c;
        return ans}
      return [0,
              length,
              degree,
              eq,
              compact,
              coeff,
              init,
              add,
              zero,
              cmul,
              neg,
              sub,
              mul,
              one,
              to_string,
              monomial]}
    function PolynomialRing(_kM_)
     {var _kN_=Polynomial(_kM_);
      return [0,_kN_[3],_kN_[7],_kN_[8],_kN_[10],_kN_[12],_kN_[13],_kN_[14]]}
    function Op$0(R)
     {var
       eq=R[1],
       add=R[2],
       zero=R[3],
       neg=R[4],
       one=R[6],
       to_string=R[7],
       _kL_=R[5];
      function mul(x,y){return caml_call2(_kL_,y,x)}
      return [0,eq,add,zero,neg,mul,one,to_string]}
    var
     Alg_Ring=
      [0,include,include$0,include$1,Polynomial,PolynomialRing,Op$0];
    caml_register_global(275,Alg_Ring,"Alg__Ring");
    var
     eq$14=include[1],
     add$3=include[2],
     zero$2=include[3],
     neg$2=include[4],
     mul$2=include[5],
     one$0=include[6],
     to_string$18=include[7];
    function inv$2(x){return x}
    var
     Bool=[0,eq$14,add$3,zero$2,neg$2,mul$2,one$0,to_string$18,inv$2],
     eq$15=include$1[1],
     add$4=include$1[2],
     zero$3=include$1[3],
     neg$3=include$1[4],
     mul$3=include$1[5],
     one$1=include$1[6],
     to_string$19=include$1[7];
    function inv$3(x){return 1. / x}
    var
     Float=[0,eq$15,add$4,zero$3,neg$3,mul$3,one$1,to_string$19,inv$3],
     eq$16=include$0[1],
     add$5=include$0[2],
     zero$4=include$0[3],
     neg$4=include$0[4],
     mul$4=include$0[5],
     one$2=include$0[6],
     to_string$20=include$0[7];
    function inv$4(x)
     {if(caml_call2(eq$16,one$2,x))return one$2;
      if(caml_call2(eq$16,caml_call1(neg$4,one$2),x))
       return caml_call1(neg$4,one$2);
      var
       _kI_=caml_call1(Stdlib[33],x),
       _kJ_=caml_call2(Stdlib[28],_kI_,cst$47),
       _kK_=caml_call2(Stdlib[28],cst_Cannot_invert,_kJ_);
      return caml_call1(Stdlib[2],_kK_)}
    var Int$1=[0,eq$16,add$5,zero$4,neg$4,mul$4,one$2,to_string$20,inv$4];
    function Fractions(R)
     {function gcd(a,b)
       {var a$0=a,b$0=b;
        for(;;)
         {if(caml_call2(R[1],R[3],b$0))return a$0;
          var _kH_=caml_call2(R[8],a$0,b$0)[2],a$0=b$0,b$0=_kH_;
          continue}}
      function canonize(param)
       {var
         b=param[2],
         a=param[1],
         d=gcd(a,b),
         match=caml_call2(R[8],a,d),
         a$0=match[1],
         match$0=caml_call2(R[8],a$0,d),
         b$0=match$0[1];
        return [0,a$0,b$0]}
      function eq(param,_kA_)
       {var
         d=_kA_[2],
         c=_kA_[1],
         b=param[2],
         a=param[1],
         match=canonize([0,a,b]),
         b$0=match[2],
         a$0=match[1],
         match$0=canonize([0,c,d]),
         d$0=match$0[2],
         c$0=match$0[1],
         _kB_=caml_call2(R[1],a$0,c$0),
         _kC_=_kB_?caml_call2(R[1],b$0,d$0):_kB_;
        if(_kC_)
         var _kD_=_kC_;
        else
         {var _kE_=caml_call1(R[4],a$0),_kF_=caml_call2(R[1],_kE_,c$0);
          if(_kF_)
           {var _kG_=caml_call1(R[4],b$0);return caml_call2(R[1],_kG_,d$0)}
          var _kD_=_kF_}
        return _kD_}
      function add(param,_kw_)
       {var
         d=_kw_[2],
         c=_kw_[1],
         b=param[2],
         a=param[1],
         _kx_=caml_call2(R[5],c,d),
         _ky_=caml_call2(R[5],b,c),
         _kz_=caml_call2(R[5],a,d);
        return [0,caml_call2(R[2],_kz_,_ky_),_kx_]}
      var zero=[0,R[3],R[6]];
      function neg(param)
       {var b=param[2],a=param[1];return [0,caml_call1(R[4],a),b]}
      function mul(param,_ku_)
       {var d=_ku_[2],c=_ku_[1],a=param[1],_kv_=caml_call2(R[5],c,d);
        return [0,caml_call2(R[5],a,c),_kv_]}
      var one=[0,R[6],R[6]];
      function inv(param){var b=param[2],a=param[1];return [0,b,a]}
      function to_string(param)
       {var
         b=param[2],
         a=param[1],
         _kp_=caml_call1(R[7],b),
         _kq_=caml_call2(Stdlib[28],_kp_,cst$48),
         _kr_=caml_call2(Stdlib[28],cst$49,_kq_),
         _ks_=caml_call1(R[7],a),
         _kt_=caml_call2(Stdlib[28],_ks_,_kr_);
        return caml_call2(Stdlib[28],cst$50,_kt_)}
      return [0,gcd,canonize,eq,add,zero,neg,mul,one,inv,to_string]}
    function FractionsField(_kn_)
     {var _ko_=Fractions(_kn_);
      return [0,
              _ko_[3],
              _ko_[4],
              _ko_[5],
              _ko_[6],
              _ko_[7],
              _ko_[8],
              _ko_[10],
              _ko_[9]]}
    function RationalFractions(F)
     {function Polynomial$0(F)
       {var
         include=Polynomial([0,F[1],F[2],F[3],F[4],F[5],F[6],F[7]]),
         degree=include[2],
         eq=include[3],
         add=include[7],
         zero=include[8],
         neg=include[10],
         sub=include[11],
         mul=include[12],
         one=include[13],
         to_string=include[14],
         monomial=include[15];
        function div(a,b)
         {var db=caml_call1(degree,b);
          if(0 <= db)
           {var q=[0,zero],r=[0,a],dr=[0,caml_call1(degree,r[1])];
            for(;;)
             {if(db <= dr[1])
               {var
                 _kh_=dr[1] - db | 0,
                 _ki_=caml_check_bound(b,db)[1 + db],
                 _kj_=caml_call1(F[8],_ki_),
                 _kk_=dr[1],
                 _kl_=caml_check_bound(r[1],_kk_)[1 + _kk_],
                 t=caml_call2(monomial,caml_call2(F[5],_kl_,_kj_),_kh_);
                q[1] = caml_call2(add,q[1],t);
                var _km_=caml_call2(mul,t,b);
                r[1] = caml_call2(sub,r[1],_km_);
                dr[1] = caml_call1(degree,r[1]);
                continue}
              return [0,q[1],r[1]]}}
          throw [0,Assert_failure,_ax_]}
        return [0,eq,add,zero,neg,mul,one,to_string,div]}
      var
       include=Fractions(Polynomial$0(F)),
       gcd=include[1],
       canonize=include[2],
       eq=include[3],
       add=include[4],
       zero=include[5],
       neg=include[6],
       mul=include[7],
       one=include[8],
       inv=include[9],
       to_string=include[10];
      return [0,
              Polynomial$0,
              gcd,
              canonize,
              eq,
              add,
              zero,
              neg,
              mul,
              one,
              inv,
              to_string]}
    function RationalFractionsField(_kf_)
     {var _kg_=RationalFractions(_kf_);
      return [0,
              _kg_[4],
              _kg_[5],
              _kg_[6],
              _kg_[7],
              _kg_[8],
              _kg_[9],
              _kg_[11],
              _kg_[10]]}
    function Ring(F)
     {var
       eq=F[1],
       add=F[2],
       zero=F[3],
       neg=F[4],
       mul=F[5],
       one=F[6],
       to_string=F[7];
      return [0,eq,add,zero,neg,mul,one,to_string]}
    var
     Alg_Field=
      [0,
       Bool,
       Float,
       Int$1,
       Fractions,
       FractionsField,
       RationalFractions,
       RationalFractionsField,
       Ring];
    caml_register_global(276,Alg_Field,"Alg__Field");
    function Make(K)
     {function eq(a,b){return caml_call1(Stdlib[2],cst_Cannot_implement_this)}
      function get(a,n)
       {var
         af=a[2],
         aw=a[1],
         awl=caml_call1(Stdlib_Weak[2],aw[1]),
         x=n < awl?caml_call2(Stdlib_Weak[4],aw[1],n):0;
        if(x){var x$0=x[1];return x$0}
        var x$1=caml_call1(af,n);
        if(awl <= n)
         {var aw$0=caml_call1(Stdlib_Weak[1],n + 1 | 0);
          caml_call5(Stdlib_Weak[8],aw$0,0,aw[1],0,awl);
          aw[1] = aw$0}
        caml_call3(Stdlib_Weak[3],aw[1],n,[0,x$1]);
        return x$1}
      function to_string(a)
       {var _j__=get(a,0),ans=[0,caml_call1(K[7],_j__)],i=1;
        for(;;)
         {var ai=get(a,i);
          if(1 - caml_call2(K[1],ai,K[3]))
           {if(1 === i)
             var _j$_=cst_z;
            else
             var
              _ke_=caml_call1(Stdlib[33],i),
              _j$_=caml_call2(Stdlib[28],cst_z$0,_ke_);
            var
             _ka_=caml_call2(K[1],ai,K[6])?cst$52:caml_call1(K[7],ai),
             _kb_=caml_call2(Stdlib[28],_ka_,_j$_),
             _kc_=caml_call2(Stdlib[28],cst$53,_kb_);
            ans[1] = caml_call2(Stdlib[28],ans[1],_kc_)}
          var _kd_=i + 1 | 0;
          if(8 !== i){var i=_kd_;continue}
          ans[1] = caml_call2(Stdlib[28],ans[1],cst$51);
          return ans[1]}}
      function make(f){return [0,[0,caml_call1(Stdlib_Weak[1],0)],f]}
      var
       zero=make(function(param){return K[3]}),
       one=make(function(n){return 0 === n?K[6]:K[3]}),
       var$0=make(function(n){return 1 === n?K[6]:K[3]});
      function add(a,b)
       {return make
                (function(n)
                  {var _j8_=get(b,n),_j9_=get(a,n);
                   return caml_call2(K[2],_j9_,_j8_)})}
      function sub(a,b)
       {return make
                (function(n)
                  {var
                    _j4_=get(b,n),
                    _j5_=caml_call1(K[4],K[6]),
                    _j6_=caml_call2(K[5],_j5_,_j4_),
                    _j7_=get(a,n);
                   return caml_call2(K[2],_j7_,_j6_)})}
      function mul(a,b)
       {function f(n)
         {var ans=[0,K[3]],_jZ_=0;
          if(! (n < 0))
           {var i=_jZ_;
            for(;;)
             {var
               _j0_=get(b,n - i | 0),
               _j1_=get(a,i),
               _j2_=caml_call2(K[5],_j1_,_j0_);
              ans[1] = caml_call2(K[2],ans[1],_j2_);
              var _j3_=i + 1 | 0;
              if(n !== i){var i=_j3_;continue}
              break}}
          return ans[1]}
        return make(f)}
      function expn(a,n)
       {if(0 <= n)return 0 === n?one:1 === n?a:mul(a,expn(a,n - 1 | 0));
        throw [0,Assert_failure,_ay_]}
      function hadamard(a,b)
       {return make
                (function(n)
                  {var _jX_=get(b,n),_jY_=get(a,n);
                   return caml_call2(K[5],_jY_,_jX_)})}
      function cmul(a,b)
       {return make
                (function(n){var _jW_=get(b,n);return caml_call2(K[5],a,_jW_)})}
      function neg(a)
       {return make
                (function(n){var _jV_=get(a,n);return caml_call1(K[4],_jV_)})}
      function star(a)
       {var _jS_=K[3],_jT_=get(a,0);
        if(caml_call2(K[1],_jT_,_jS_))
         {var
           aux=
            function(n)
             {if(0 === n)return expn(a,0);
              var _jU_=aux(n - 1 | 0);
              return add(expn(a,n),_jU_)};
          return make(function(n){return get(aux(n),n)})}
        throw [0,Assert_failure,_az_]}
      function inv(a){return star(sub(one,a))}
      var Polynomial$0=Polynomial([0,K[1],K[2],K[3],K[4],K[5],K[6],K[7]]);
      function polynomial(p)
       {return make(function(n){return caml_call2(Polynomial$0[5],p,n)})}
      var RationalFractions$0=RationalFractions(K);
      function rational(r)
       {var q=r[2],p=r[1],p$0=polynomial(p),q$0=polynomial(q);
        return mul(p$0,inv(q$0))}
      return [0,
              eq,
              get,
              get,
              to_string,
              make,
              zero,
              one,
              var$0,
              add,
              sub,
              mul,
              expn,
              hadamard,
              cmul,
              neg,
              star,
              inv,
              Polynomial$0,
              polynomial,
              RationalFractions$0,
              rational]}
    function Field(_jQ_)
     {var _jR_=Make(_jQ_);
      return [0,_jR_[1],_jR_[9],_jR_[6],_jR_[15],_jR_[11],_jR_[7],_jR_[4]]}
    var Alg_Series=[0,Make,Field];
    caml_register_global(278,Alg_Series,"Alg__Series");
    function Make$0(X)
     {function to_string(c)
       {function list(param)
         {if(0 === param[0]){var c=param[2],w=param[1];return [0,w,list(c)]}
          return 0}
        function cell(c)
         {if(0 === c[0])
           {var
             _jK_=list(c),
             _jL_=caml_call2(Stdlib_List[19],whisker,_jK_),
             _jM_=caml_call2(Stdlib_String[6],cst$55,_jL_),
             _jN_=caml_call2(Stdlib[28],_jM_,cst$54);
            return caml_call2(Stdlib[28],cst$56,_jN_)}
          var c$0=c[1],_jO_=cell(c$0),_jP_=caml_call2(Stdlib[28],_jO_,cst$57);
          return caml_call2(Stdlib[28],cst$58,_jP_)}
        function whisker(param)
         {if(0 === param[0]){var g=param[1];return caml_call1(X[2],g)}
          var
           c2=param[3],
           w=param[2],
           c1=param[1],
           _jG_=cell(c2),
           _jH_=whisker(w),
           _jI_=caml_call2(Stdlib[28],_jH_,_jG_),
           _jJ_=cell(c1);
          return caml_call2(Stdlib[28],_jJ_,_jI_)}
        return cell(c)}
      function dim(c)
       {function whisker(param)
         {if(0 === param[0])return 0;var w=param[2];return whisker(w) + 1 | 0}
        function cell(param)
         {if(0 === param[0]){var w=param[1];return whisker(w)}
          var c=param[1];
          return cell(c) + 1 | 0}
        return cell(c)}
      function compose(c,d)
       {var _jE_=dim(d);
        if(dim(c) === _jE_)
         {var
           aux=
            function(param)
             {if(0 === param[0])
               {var c=param[2],w=param[1];return [0,w,aux(c)]}
              return d};
          return aux(c)}
        var _jF_=dim(d);
        if(_jF_ < dim(c))
         {var
           aux$0=
            function(param)
             {if(0 === param[0])
               {var c=param[2],w=param[1];
                if(0 === w[0])throw [0,Assert_failure,_aA_];
                var
                 c2=w[3],
                 w$0=w[2],
                 c1=w[1],
                 w$1=[1,c1,w$0,compose(c2,d)],
                 c$0=aux$0(c);
                return [0,w$1,c$0]}
              var c$1=param[1];
              return [1,compose(c$1,d)]};
          return aux$0(c)}
        return caml_call1(Stdlib[2],cst_TODO)}
      var E=caml_call1(Stdlib_Map[1],[0,X[3]]),empty=E[1];
      function mem(s,g){return caml_call2(E[3],g,s)}
      function boundary(s,g)
       {var match=caml_call2(E[28],g,s),y=match[2],x=match[1];
        if(x !== g && y !== g)return [0,x,y];
        throw [0,Assert_failure,_aB_]}
      function source(s,g){return boundary(s,g)[1]}
      function target(s,g){return boundary(s,g)[2]}
      function mem$0(s,c)
       {function whisker(param)
         {if(0 === param[0]){var g=param[1];return mem(s,g)}
          var c2=param[3],w=param[2],c1=param[1],_jB_=cell(c1);
          if(_jB_)
           {var _jC_=whisker(w);if(_jC_)return cell(c2);var _jD_=_jC_}
          else
           var _jD_=_jB_;
          return _jD_}
        function cell(param)
         {var param$0=param;
          for(;;)
           {if(0 === param$0[0])
             {var c=param$0[2],w=param$0[1],_jA_=whisker(w);
              if(_jA_){var param$0=c;continue}
              return _jA_}
            var param$1=param$0[1],param$0=param$1;
            continue}}
        return cell(c)}
      function dim$0(s,c){return dim(c)}
      var
       Cell=[0,mem$0,dim$0],
       Pres=[0,E,empty,mem,boundary,source,target,Cell];
      return [0,to_string,dim,compose,Pres]}
    var Alg_Precategory=[0,Make$0];
    caml_register_global(279,Alg_Precategory,"Alg__Precategory");
    function Free(X)
     {function mul(u,v){return caml_call2(Stdlib_Array[5],u,v)}
      var one=[0];
      function inj(a){return [0,a]}
      function length(u){return u.length - 1}
      function sub(u,o,l){return caml_call3(Stdlib_Array[7],u,o,l)}
      function weq(u,v)
       {var ul=u.length - 1,vl=v.length - 1;
        if(ul !== vl)return 0;
        try
         {var _ju_=ul - 1 | 0,_jt_=0;
          if(! (_ju_ < 0))
           {var i=_jt_;
            for(;;)
             {var
               _jw_=caml_check_bound(v,i)[1 + i],
               _jx_=caml_check_bound(u,i)[1 + i];
              if(1 - caml_call2(X[1],_jx_,_jw_))throw Stdlib[3];
              var _jy_=i + 1 | 0;
              if(_ju_ !== i){var i=_jy_;continue}
              break}}
          var _jv_=1;
          return _jv_}
        catch(_jz_)
         {_jz_ = caml_wrap_exception(_jz_);
          if(_jz_ === Stdlib[3])return 0;
          throw _jz_}}
      function wc(u,v)
       {var ul=u.length - 1,vl=v.length - 1,ans=[0,0];
        try
         {var _jn_=caml_call2(Stdlib[16],ul,vl) - 1 | 0,_jm_=0;
          if(! (_jn_ < 0))
           {var i=_jm_;
            for(;;)
             {var
               _jp_=caml_check_bound(v,i)[1 + i],
               _jq_=caml_check_bound(u,i)[1 + i],
               c=caml_call2(X[3],_jq_,_jp_);
              if(0 !== c){ans[1] = c;throw Stdlib[3]}
              var _jr_=i + 1 | 0;
              if(_jn_ !== i){var i=_jr_;continue}
              break}}
          var _jo_=ul - vl | 0;
          return _jo_}
        catch(_js_)
         {_js_ = caml_wrap_exception(_js_);
          if(_js_ === Stdlib[3])return ans[1];
          throw _js_}}
      function peq(u,uoff,v,voff,len)
       {try
         {var _je_=len - 1 | 0,_jd_=0;
          if(! (_je_ < 0))
           {var i=_jd_;
            for(;;)
             {var
               _jg_=voff + i | 0,
               _ji_=uoff + i | 0,
               _jh_=caml_check_bound(v,_jg_)[1 + _jg_],
               _jj_=caml_check_bound(u,_ji_)[1 + _ji_];
              if(1 - caml_call2(X[1],_jj_,_jh_))throw Stdlib[3];
              var _jk_=i + 1 | 0;
              if(_je_ !== i){var i=_jk_;continue}
              break}}
          var _jf_=1;
          return _jf_}
        catch(_jl_)
         {_jl_ = caml_wrap_exception(_jl_);
          if(_jl_ === Stdlib[3])return 0;
          throw _jl_}}
      function to_string(u)
       {if(weq(one,u))return cst$59;
        var
         u$0=caml_call1(Stdlib_Array[11],u),
         u$1=caml_call2(Stdlib_List[19],X[2],u$0);
        return caml_call2(Stdlib_String[6],cst$60,u$1)}
      function included(u,v)
       {var ul=u.length - 1,vl=v.length - 1;
        try
         {var _i$_=vl - ul | 0,_i__=0;
          if(! (_i$_ < 0))
           {var i=_i__;
            for(;;)
             {if(peq(u,0,v,i,ul))throw Stdlib[3];
              var _jb_=i + 1 | 0;
              if(_i$_ !== i){var i=_jb_;continue}
              break}}
          var _ja_=0;
          return _ja_}
        catch(_jc_)
         {_jc_ = caml_wrap_exception(_jc_);
          if(_jc_ === Stdlib[3])return 1;
          throw _jc_}}
      function unifier(opt,u,v)
       {if(opt)var sth=opt[1],i=sth;else var i=0;
        var ul=u.length - 1,vl=v.length - 1,ans=[0,0];
        try
         {var _i7_=ul - 1 | 0;
          if(! (_i7_ < i))
           {var i$0=i;
            for(;;)
             {if(peq(u,i$0,v,0,caml_call2(Stdlib[16],ul - i$0 | 0,vl)))
               {ans[1] = [0,i$0];throw Stdlib[3]}
              var _i8_=i$0 + 1 | 0;
              if(_i7_ !== i$0){var i$0=_i8_;continue}
              break}}
          throw Stdlib[8]}
        catch(_i9_)
         {_i9_ = caml_wrap_exception(_i9_);
          if(_i9_ === Stdlib[3])
           {var _i6_=ans[1];
            if(_i6_){var ans$0=_i6_[1];return ans$0}
            throw [0,Assert_failure,_aC_]}
          throw _i9_}}
      function ordered_unifiers(u,v)
       {var ans=[0,0],i=[0,0];
        try
         {for(;;)
           {var j=unifier([0,i[1]],u,v);
            ans[1] = [0,j,ans[1]];
            i[1] = j + 1 | 0;
            continue}}
        catch(_i5_)
         {_i5_ = caml_wrap_exception(_i5_);
          if(_i5_ === Stdlib[8])return ans[1];
          throw _i5_}}
      function ordered_unifiers_bicontext(u,v)
       {var lu=u.length - 1,lv=v.length - 1,l=ordered_unifiers(u,v);
        function _i2_(i)
         {if((i + lv | 0) <= lu)
           {var _i3_=sub(u,i + lv | 0,lu - (i + lv | 0) | 0);
            return [0,[0,one,one],[0,sub(u,0,i),_i3_]]}
          var _i4_=[0,sub(u,0,i),one];
          return [0,[0,one,sub(v,lu - i | 0,lv - (lu - i | 0) | 0)],_i4_]}
        return caml_call2(Stdlib_List[19],_i2_,l)}
      function unifiers_bicontext(u,v)
       {var
         l=ordered_unifiers_bicontext(u,v),
         l$0=ordered_unifiers_bicontext(v,u);
        function _i1_(param){var d=param[2],c=param[1];return [0,d,c]}
        var l$1=caml_call2(Stdlib_List[19],_i1_,l$0);
        return caml_call2(Stdlib[37],l,l$1)}
      function lexicographic(leq,u,v)
       {var ul=u.length - 1,vl=v.length - 1,ans=[0,1];
        try
         {var _iU_=caml_call2(Stdlib[16],ul,vl) - 1 | 0,_iT_=0;
          if(! (_iU_ < 0))
           {var i=_iT_;
            for(;;)
             {var _iW_=caml_check_bound(v,i)[1 + i];
              if(! caml_call2(leq,caml_check_bound(u,i)[1 + i],_iW_))
               {ans[1] = 0;throw Stdlib[3]}
              var
               _iX_=caml_check_bound(v,i)[1 + i],
               _iY_=caml_check_bound(u,i)[1 + i];
              if(1 - caml_call2(X[1],_iY_,_iX_))throw Stdlib[3];
              var _iZ_=i + 1 | 0;
              if(_iU_ !== i){var i=_iZ_;continue}
              break}}
          var _iV_=ul <= vl?1:0;
          return _iV_}
        catch(_i0_)
         {_i0_ = caml_wrap_exception(_i0_);
          if(_i0_ === Stdlib[3])return ans[1];
          throw _i0_}}
      function deglex(leq,u,v)
       {var ul=u.length - 1,vl=v.length - 1;
        return ul < vl?1:vl < ul?0:lexicographic(leq,u,v)}
      var Order=[0,lexicographic,deglex],empty=0;
      function singleton(a){return [0,[0,a],0]}
      function singletons(l){return caml_call2(Stdlib_List[19],singleton,l)}
      function hd(l){return caml_call1(Stdlib_List[5],l)}
      function tl(l){return caml_call1(Stdlib_List[6],l)}
      function eq(c,d)
       {var c$0=c,d$0=d;
        for(;;)
         {if(c$0)
           {if(d$0)
             {var d$1=d$0[2],v=d$0[1],c$1=c$0[2],u=c$0[1],_iS_=weq(u,v);
              if(_iS_){var c$0=c$1,d$0=d$1;continue}
              return _iS_}
            return 0}
          return d$0?0:1}}
      function compare(c,d)
       {var c$0=c,d$0=d;
        for(;;)
         {if(c$0)
           {if(d$0)
             {var d$1=d$0[2],v=d$0[1],c$1=c$0[2],u=c$0[1],cmp=wc(u,v);
              if(0 === cmp){var c$0=c$1,d$0=d$1;continue}
              return cmp}
            return 1}
          return d$0?-1:0}}
      function extend(l,cc)
       {function _iJ_(c$0)
         {if(c$0)
           {var _iL_=c$0[1],len=_iL_.length - 1;
            if(len)
             {var
               c=c$0[2],
               ul=_iL_.length - 1,
               ans=[0,0],
               f=
                function(l1,v,l2)
                 {var
                   vl=v.length - 1,
                   _iM_=caml_call2(Stdlib[17],ul - vl | 0,0),
                   _iN_=ul - 1 | 0;
                  if(! (_iN_ < _iM_))
                   {var i=_iM_;
                    for(;;)
                     {try
                       {if(1 - peq(_iL_,i,v,0,ul - i | 0))throw Stdlib[3];
                        var
                         i$0=ul - i | 0,
                         v$0=sub(v,i$0,vl - i$0 | 0),
                         w=mul(_iL_,v$0),
                         f$0=
                          function(w)
                           {function f(u)
                             {var _iR_=included(u,w);if(_iR_)throw Stdlib[3];return _iR_}
                            return f},
                         f=f$0(w);
                        caml_call2(Stdlib_List[17],f,l1);
                        caml_call2(Stdlib_List[17],f,l2);
                        if(included(v,sub(w,0,w.length - 1 - 1 | 0)))
                         throw Stdlib[3];
                        ans[1] = [0,[0,v$0,[0,_iL_,c]],ans[1]]}
                      catch(_iQ_)
                       {_iQ_ = caml_wrap_exception(_iQ_);
                        if(_iQ_ !== Stdlib[3])throw _iQ_;
                        var _iP_=_iQ_}
                      var _iO_=i + 1 | 0;
                      if(_iN_ !== i){var i=_iO_;continue}
                      break}}
                  return 0},
               h=0,
               param=l;
              for(;;)
               {if(param)
                 {var t=param[2],x=param[1];
                  f(h,x,t);
                  var h$0=[0,x,h],h=h$0,param=t;
                  continue}
                return ans[1]}}}
          throw [0,Assert_failure,_aD_]}
        var _iK_=caml_call2(Stdlib_List[19],_iJ_,cc);
        return caml_call1(Stdlib_List[13],_iK_)}
      function eval$0(l)
       {var _iI_=caml_call1(Stdlib_List[9],l);
        return caml_call3(Stdlib_List[25],mul,one,_iI_)}
      function length$0(l){return caml_call1(Stdlib_List[1],l)}
      function to_string$0(c)
       {var
         _iE_=caml_call1(Stdlib_List[9],c),
         _iF_=caml_call2(Stdlib_List[19],to_string,_iE_),
         _iG_=caml_call2(Stdlib_String[6],cst$62,_iF_),
         _iH_=caml_call2(Stdlib[28],_iG_,cst$61);
        return caml_call2(Stdlib[28],cst$63,_iH_)}
      var
       Anick=
        [0,
         empty,
         singleton,
         singletons,
         hd,
         tl,
         weq,
         eq,
         compare,
         extend,
         eval$0,
         length$0,
         to_string$0];
      return [0,
              mul,
              one,
              inj,
              length,
              sub,
              weq,
              wc,
              peq,
              to_string,
              included,
              unifier,
              ordered_unifiers,
              ordered_unifiers_bicontext,
              unifiers_bicontext,
              Order,
              Anick]}
    function FreeMonoid(_iC_)
     {var _iD_=Free(_iC_);return [0,_iD_[6],_iD_[1],_iD_[2],_iD_[9],_iD_[7]]}
    function Pres$0(X)
     {var W=Free(X);
      function make(generators,rules){return [0,generators,rules]}
      function orient(leq,pres)
       {var _iA_=pres[2];
        function _iB_(param)
         {var v=param[2],u=param[1];
          return caml_call2(leq,v,u)?[0,u,v]:[0,v,u]}
        var rules=caml_call2(Stdlib_List[19],_iB_,_iA_);
        return [0,pres[1],rules]}
      function normalize(pres,u)
       {try
         {var
           _is_=pres[2],
           _it_=function(param){var v=param[1];return caml_call2(W[10],v,u)},
           match=caml_call2(Stdlib_List[38],_it_,_is_),
           v=match[1],
           i=caml_call3(W[11],0,u,v),
           v1=caml_call3(W[5],u,0,i),
           _iu_=i + caml_call1(W[4],v) | 0,
           _iv_=caml_call1(W[4],u) - _iu_ | 0,
           _iw_=i + caml_call1(W[4],v) | 0,
           v2=caml_call3(W[5],u,_iw_,_iv_),
           _ix_=caml_call2(W[1],v,v2),
           _iy_=normalize(pres,caml_call2(W[1],v1,_ix_));
          return _iy_}
        catch(_iz_)
         {_iz_ = caml_wrap_exception(_iz_);
          if(_iz_ === Stdlib[8])return u;
          throw _iz_}}
      function add_rule(pres,param)
       {var v=param[2],u=param[1];return [0,pres[1],[0,[0,u,v],pres[2]]]}
      function reduce(pres)
       {var _ip_=pres[2];
        function _iq_(param)
         {var v=param[2],u=param[1];return [0,u,normalize(pres,v)]}
        var param=caml_call2(Stdlib_List[19],_iq_,_ip_),h=0,param$0=param;
        for(;;)
         {if(param$0)
           {var
             t=param$0[2],
             match=param$0[1],
             v=match[2],
             u=match[1],
             f$0=
              function(u)
               {function f(l)
                 {function _ir_(param)
                   {var u$0=param[1];return caml_call2(W[10],u$0,u)}
                  return caml_call2(Stdlib_List[33],_ir_,l)}
                return f},
             f=f$0(u);
            if(! f(h) && ! f(t))
             {var h$0=[0,[0,u,v],h],h=h$0,param$0=t;continue}
            var param$0=t;
            continue}
          var rules=caml_call1(Stdlib_List[9],h);
          return [0,pres[1],rules]}}
      function complete(leq,pres)
       {var
         pres$0=orient(leq,pres),
         pres$1=reduce(pres$0),
         todo=caml_call1(Stdlib_Queue[2],0),
         _ig_=pres$1[2];
        function _ih_(r){return caml_call2(Stdlib_Queue[3],r,todo)}
        caml_call2(Stdlib_List[17],_ih_,_ig_);
        var pres$2=[0,pres$1];
        for(;;)
         {if(caml_call1(Stdlib_Queue[13],todo))return pres$2[1];
          var
           match=caml_call1(Stdlib_Queue[7],todo),
           u=match[2],
           u$0=match[1],
           _ii_=pres$2[1][2],
           _ij_=
            function(u,u$0)
              {return function(param)
                {var v=param[2],v$0=param[1],_ik_=caml_call2(W[14],u$0,v$0);
                 function _il_(param)
                  {var
                    _im_=param[2],
                    v2=_im_[2],
                    v1=_im_[1],
                    match=param[1],
                    u2=match[2],
                    u1=match[1],
                    _in_=caml_call2(W[1],u,u2),
                    v$1=caml_call2(W[1],u1,_in_),
                    _io_=caml_call2(W[1],v,v2),
                    u$1=caml_call2(W[1],v1,_io_);
                   if(caml_call2(leq,u$1,v$1))
                    var v$0=u$1,u$0=v$1;
                   else
                    var v$0=v$1,u$0=u$1;
                   pres$2[1] = add_rule(pres$2[1],[0,u$0,v$0]);
                   return caml_call2(Stdlib_Queue[4],[0,u$0,v$0],todo)}
                 return caml_call2(Stdlib_List[17],_il_,_ik_)}}
             (u,u$0);
          caml_call2(Stdlib_List[17],_ij_,_ii_);
          continue}}
      function Make(_h$_)
       {var _ia_=_h$_[1];
        function nf(_if_){return normalize(_ia_,_if_)}
        var mul=W[1],one=W[2],to_string=W[9];
        function compare(u,v)
         {var _id_=nf(v),_ie_=nf(u);return caml_call2(W[7],_ie_,_id_)}
        function eq(u,v)
         {var _ib_=nf(v),_ic_=nf(u);return caml_call2(W[6],_ic_,_ib_)}
        return [0,eq,mul,one,to_string,compare]}
      return [0,W,make,orient,normalize,add_rule,reduce,complete,Make]}
    function Generate(X)
     {var Pres=Pres$0(X);
      function intset(n)
       {function aux(k){return n <= k?0:[0,k,aux(k + 1 | 0)]}return aux(0)}
      return [0,Pres,intset]}
    function Alphabet(M)
     {var eq=M[1],to_string=M[4],compare=M[5];return [0,eq,to_string,compare]}
    var Alg_Monoid=[0,Free,FreeMonoid,Pres$0,Generate,Alphabet];
    caml_register_global(281,Alg_Monoid,"Alg__Monoid");
    var Alg_Group=[0];
    caml_register_global(282,Alg_Group,"Alg__Group");
    function Make$1(R)
     {function zero(r,c)
       {function _h__(param){return caml_make_vect(c,R[3])}
        return caml_call2(Stdlib_Array[2],r,_h__)}
      function init(r,c,f)
       {function _h8_(i)
         {function _h9_(j){return caml_call2(f,i,j)}
          return caml_call2(Stdlib_Array[2],c,_h9_)}
        return caml_call2(Stdlib_Array[2],r,_h8_)}
      function rows(m){return m.length - 1}
      function cols(m){return caml_check_bound(m,0)[1].length - 1}
      function get(m,i,j)
       {return caml_check_bound(caml_check_bound(m,i)[1 + i],j)[1 + j]}
      function to_string(m)
       {var ans=[0,cst$64],_h1_=m.length - 1 - 1 | 0,_h0_=0;
        if(! (_h1_ < 0))
         {var i=_h0_;
          for(;;)
           {var _h3_=cols(m) - 1 | 0,_h2_=0;
            if(! (_h3_ < 0))
             {var j=_h2_;
              for(;;)
               {if(0 !== j)ans[1] = caml_call2(Stdlib[28],ans[1],cst$66);
                var
                 _h5_=caml_check_bound(caml_check_bound(m,i)[1 + i],j)[1 + j],
                 _h6_=caml_call1(R[7],_h5_);
                ans[1] = caml_call2(Stdlib[28],ans[1],_h6_);
                var _h7_=j + 1 | 0;
                if(_h3_ !== j){var j=_h7_;continue}
                break}}
            ans[1] = caml_call2(Stdlib[28],ans[1],cst$65);
            var _h4_=i + 1 | 0;
            if(_h1_ !== i){var i=_h4_;continue}
            break}}
        return ans[1]}
      function is_zero(m,i)
       {var _hY_=caml_check_bound(m,i)[1 + i],_hZ_=caml_call1(R[1],R[3]);
        return caml_call2(Stdlib_Array[22],_hZ_,_hY_)}
      function replace(m,i,mi)
       {function _hX_(k){return k === i?mi:caml_check_bound(m,k)[1 + k]}
        return caml_call2(Stdlib_Array[2],m.length - 1,_hX_)}
      function exchange(m,i,j)
       {function _hW_(k)
         {return k === i
                  ?caml_check_bound(m,j)[1 + j]
                  :k === j
                    ?caml_check_bound(m,i)[1 + i]
                    :caml_check_bound(m,k)[1 + k]}
        return caml_call2(Stdlib_Array[2],m.length - 1,_hW_)}
      function mult(m,q,i)
       {if(caml_call2(R[1],R[3],q))throw [0,Assert_failure,_aE_];
        function _hT_(k)
         {var _hV_=caml_check_bound(caml_check_bound(m,i)[1 + i],k)[1 + k];
          return caml_call2(R[5],q,_hV_)}
        var _hU_=cols(m),mi=caml_call2(Stdlib_Array[2],_hU_,_hT_);
        return replace(m,i,mi)}
      function madd(m,i,q,j)
       {if(i !== j)
         {var
           _hO_=
            function(k)
             {var
               _hQ_=caml_check_bound(caml_check_bound(m,j)[1 + j],k)[1 + k],
               _hR_=caml_call2(R[5],q,_hQ_),
               _hS_=caml_check_bound(caml_check_bound(m,i)[1 + i],k)[1 + k];
              return caml_call2(R[2],_hS_,_hR_)},
           _hP_=cols(m),
           mi=caml_call2(Stdlib_Array[2],_hP_,_hO_);
          return replace(m,i,mi)}
        throw [0,Assert_failure,_aF_]}
      var Row=[0,is_zero,replace,exchange,mult,madd];
      function row_echelon(m)
       {var m$0=[0,m],ip=[0,0],cols$0=0 === m$0[1].length - 1?0:cols(m$0[1]);
        try
         {var _hx_=cols$0 - 1 | 0,_hw_=0;
          if(! (_hx_ < 0))
           {var j=_hw_;
            for(;;)
             {if(m$0[1].length - 1 <= ip[1])throw Stdlib[3];
              var
               _hz_=ip[1],
               _hA_=
                caml_check_bound(caml_check_bound(m$0[1],_hz_)[1 + _hz_],j)
                 [1 + j];
              if(caml_call2(R[1],R[3],_hA_))
               try
                {var _hH_=ip[1] + 1 | 0,_hI_=m$0[1].length - 1 - 1 | 0;
                 if(! (_hI_ < _hH_))
                  {var i$0=_hH_;
                   for(;;)
                    {var
                      _hJ_=
                       caml_check_bound(caml_check_bound(m$0[1],i$0)[1 + i$0],j)
                        [1 + j];
                     if(1 - caml_call2(R[1],R[3],_hJ_))
                      {m$0[1] = caml_call3(Row[3],m$0[1],ip[1],i$0);
                       throw Stdlib[3]}
                     var _hK_=i$0 + 1 | 0;
                     if(_hI_ !== i$0){var i$0=_hK_;continue}
                     break}}}
               catch(_hN_)
                {_hN_ = caml_wrap_exception(_hN_);
                 if(_hN_ !== Stdlib[3])throw _hN_;
                 var _hL_=_hN_}
              var
               _hB_=ip[1],
               a=
                caml_check_bound(caml_check_bound(m$0[1],_hB_)[1 + _hB_],j)
                 [1 + j];
              if(1 - caml_call2(R[1],R[3],a))
               {var _hC_=ip[1] + 1 | 0,_hD_=m$0[1].length - 1 - 1 | 0;
                if(! (_hD_ < _hC_))
                 {var i=_hC_;
                  for(;;)
                   {var
                     b=
                      caml_check_bound(caml_check_bound(m$0[1],i)[1 + i],j)[1 + j];
                    if(1 - caml_call2(R[1],R[3],b))
                     {var _hF_=caml_call1(R[4],a);
                      m$0[1] = caml_call3(Row[4],m$0[1],_hF_,i);
                      m$0[1] = caml_call4(Row[5],m$0[1],i,b,ip[1])}
                    var _hG_=i + 1 | 0;
                    if(_hD_ !== i){var i=_hG_;continue}
                    break}}
                ip[1]++}
              var _hE_=j + 1 | 0;
              if(_hx_ !== j){var j=_hE_;continue}
              break}}
          var _hy_=m$0[1];
          return _hy_}
        catch(_hM_)
         {_hM_ = caml_wrap_exception(_hM_);
          if(_hM_ === Stdlib[3])return m$0[1];
          throw _hM_}}
      function rank(m)
       {var m$0=row_echelon(m),n=[0,0];
        try
         {var _hs_=m$0.length - 1 - 1 | 0,_hr_=0;
          if(! (_hs_ < 0))
           {var i=_hr_;
            for(;;)
             {if(caml_call2(Row[1],m$0,i))throw Stdlib[3];
              n[1]++;
              var _hu_=i + 1 | 0;
              if(_hs_ !== i){var i=_hu_;continue}
              break}}
          var _ht_=n[1];
          return _ht_}
        catch(_hv_)
         {_hv_ = caml_wrap_exception(_hv_);
          if(_hv_ === Stdlib[3])return n[1];
          throw _hv_}}
      function nullity(m){return m.length - 1 - rank(m) | 0}
      function Labeled(X)
       {var
         include=caml_call1(Stdlib_Map[1],[0,X[3]]),
         empty=include[1],
         is_empty=include[2],
         mem=include[3],
         add=include[4],
         update=include[5],
         singleton=include[6],
         remove=include[7],
         merge=include[8],
         union=include[9],
         compare=include[10],
         equal=include[11],
         iter=include[12],
         fold=include[13],
         for_all=include[14],
         exists=include[15],
         filter=include[16],
         filter_map=include[17],
         partition=include[18],
         cardinal=include[19],
         bindings=include[20],
         min_binding=include[21],
         min_binding_opt=include[22],
         max_binding=include[23],
         max_binding_opt=include[24],
         choose=include[25],
         choose_opt=include[26],
         split=include[27],
         find=include[28],
         find_opt=include[29],
         find_first=include[30],
         find_first_opt=include[31],
         find_last=include[32],
         find_last_opt=include[33],
         map=include[34],
         mapi=include[35],
         to_seq=include[36],
         to_rev_seq=include[37],
         to_seq_from=include[38],
         add_seq=include[39],
         of_seq=include[40];
        function of_array(a)
         {var ans=[0,empty],_ho_=a.length - 1 - 1 | 0,_hn_=0;
          if(! (_ho_ < 0))
           {var i=_hn_;
            for(;;)
             {var _hp_=ans[1];
              ans[1] = caml_call3(add,caml_check_bound(a,i)[1 + i],i,_hp_);
              var _hq_=i + 1 | 0;
              if(_ho_ !== i){var i=_hq_;continue}
              break}}
          return ans[1]}
        var
         L=
          [0,
           empty,
           is_empty,
           mem,
           add,
           update,
           singleton,
           remove,
           merge,
           union,
           compare,
           equal,
           fold,
           for_all,
           exists,
           filter,
           filter_map,
           partition,
           cardinal,
           bindings,
           min_binding,
           min_binding_opt,
           max_binding,
           max_binding_opt,
           choose,
           choose_opt,
           split,
           find_opt,
           find_first,
           find_first_opt,
           find_last,
           find_last_opt,
           map,
           mapi,
           to_seq,
           to_rev_seq,
           to_seq_from,
           add_seq,
           of_seq,
           find,
           iter,
           of_array];
        function matrix(param){var m=param[3];return m}
        function zero$0(rows,cols)
         {var
           m=zero(rows.length - 1,cols.length - 1),
           _hm_=caml_call1(L[41],cols);
          return [0,caml_call1(L[41],rows),_hm_,m]}
        function set(param,i,j,x)
         {var
           m=param[3],
           c=param[2],
           r=param[1],
           i$0=caml_call2(L[39],i,r),
           j$0=caml_call2(L[39],j,c);
          caml_check_bound(caml_check_bound(m,i$0)[1 + i$0],j$0)[1 + j$0] = x;
          return 0}
        function get(param,i,j)
         {var
           m=param[3],
           c=param[2],
           r=param[1],
           i$0=caml_call2(L[39],i,r),
           j$0=caml_call2(L[39],j,c);
          return caml_check_bound(caml_check_bound(m,i$0)[1 + i$0],j$0)
                  [1 + j$0]}
        function rank$0(param){var m=param[3];return rank(m)}
        function nullity$0(param){var m=param[3];return nullity(m)}
        function iter_src(f,param)
         {var r=param[1];
          function _hl_(x,param){return caml_call1(f,x)}
          return caml_call2(L[40],_hl_,r)}
        function iter_tgt(f,param)
         {var c=param[2];
          function _hk_(x,param){return caml_call1(f,x)}
          return caml_call2(L[40],_hk_,c)}
        function iter$0(f,m)
         {return iter_src
                  (function(x)
                    {return iter_tgt(function(y){return caml_call2(f,x,y)},m)},
                   m)}
        return [0,
                L,
                matrix,
                zero$0,
                set,
                get,
                rank$0,
                nullity$0,
                iter_src,
                iter_tgt,
                iter$0]}
      return [0,
              zero,
              init,
              rows,
              cols,
              get,
              to_string,
              Row,
              row_echelon,
              rank,
              nullity,
              Labeled]}
    function Functor(R$0,R)
     {var M=Make$1(R$0),M$0=Make$1(R);
      function map(f,m)
       {var r=caml_call1(M[3],m),c=0 === r?0:caml_call1(M[4],m);
        function _hj_(i,j){return caml_call1(f,caml_call3(M[5],m,i,j))}
        return caml_call3(M$0[2],r,c,_hj_)}
      function Labeled(X$0,X)
       {var L=caml_call1(M[11],X$0),L$0=caml_call1(M$0[11],X);
        function map$0(s,t,f,m)
         {var m$0=m[3],c=m[2],r=m[1];
          function lmap(f,l)
           {var _hg_=L$0[1][1];
            function _hh_(x,i,l)
             {var _hi_=caml_call1(f,x);return caml_call3(L$0[1][4],_hi_,i,l)}
            return caml_call3(L[1][12],_hh_,l,_hg_)}
          var r$0=lmap(s,r),c$0=lmap(t,c),m$1=map(f,m$0);
          return [0,r$0,c$0,m$1]}
        return [0,L,L$0,map$0]}
      return [0,M,M$0,map,Labeled]}
    var Alg_Matrix=[0,Make$1,Functor];
    caml_register_global(283,Alg_Matrix,"Alg__Matrix");
    function FreeLeft(R,X)
     {var
       include=caml_call1(Stdlib_Map[1],[0,X[3]]),
       empty=include[1],
       is_empty=include[2],
       mem=include[3],
       update=include[5],
       singleton=include[6],
       remove=include[7],
       merge=include[8],
       union=include[9],
       compare=include[10],
       equal=include[11],
       iter=include[12],
       fold=include[13],
       for_all=include[14],
       exists=include[15],
       filter=include[16],
       filter_map=include[17],
       partition=include[18],
       cardinal=include[19],
       bindings=include[20],
       min_binding=include[21],
       min_binding_opt=include[22],
       max_binding=include[23],
       max_binding_opt=include[24],
       choose=include[25],
       choose_opt=include[26],
       split=include[27],
       find=include[28],
       find_opt=include[29],
       find_first=include[30],
       find_first_opt=include[31],
       find_last=include[32],
       find_last_opt=include[33],
       map=include[34],
       mapi=include[35],
       to_seq=include[36],
       to_rev_seq=include[37],
       to_seq_from=include[38],
       add_seq=include[39],
       of_seq=include[40],
       _f6_=include[4];
      function add(x,a,p)
       {return caml_call2(R[1],R[3],a)
                ?caml_call2(remove,x,p)
                :caml_call3(_f6_,x,a,p)}
      var
       E=
        [0,
         empty,
         is_empty,
         mem,
         update,
         singleton,
         remove,
         merge,
         union,
         compare,
         equal,
         iter,
         fold,
         for_all,
         exists,
         filter,
         filter_map,
         partition,
         cardinal,
         bindings,
         min_binding,
         min_binding_opt,
         max_binding,
         max_binding_opt,
         choose,
         choose_opt,
         split,
         find,
         find_opt,
         find_first,
         find_first_opt,
         find_last,
         find_last_opt,
         map,
         mapi,
         to_seq,
         to_rev_seq,
         to_seq_from,
         add_seq,
         of_seq,
         add],
       zero=E[1];
      function cinj(a,x){return caml_call3(E[40],x,a,zero)}
      function inj(x){return cinj(R[6],x)}
      function coeff(p,x)
       {try
         {var _he_=caml_call2(E[27],x,p);return _he_}
        catch(_hf_)
         {_hf_ = caml_wrap_exception(_hf_);
          if(_hf_ === Stdlib[8])return R[3];
          throw _hf_}}
      function included(x,y)
       {function _hd_(u,a){return caml_equal(coeff(y,u),a)}
        return caml_call2(E[13],_hd_,x)}
      function eq(x,y){var _hc_=included(x,y);return _hc_?included(y,x):_hc_}
      function add_monomial(p,a,x)
       {var _hb_=coeff(p,x),a$0=caml_call2(R[2],a,_hb_);
        return caml_call3(E[40],x,a$0,p)}
      function add$0(p,q)
       {function _ha_(x,a,p){return add_monomial(p,a,x)}
        return caml_call3(E[12],_ha_,q,p)}
      function cmul(a,x)
       {var _g$_=caml_call1(R[5],a);return caml_call2(E[33],_g$_,x)}
      function neg(x){return cmul(caml_call1(R[4],R[6]),x)}
      function sub(x,y){return add$0(x,neg(y))}
      function to_string(x)
       {if(eq(zero,x))return cst_0;
        var ans=[0,cst$67];
        function _g5_(u,a)
         {if(caml_string_notequal(ans[1],cst$68))
           ans[1] = caml_call2(Stdlib[28],ans[1],cst$69);
          if(caml_call2(R[1],a,R[6]))
           var a$0=cst$70;
          else
           var
            _g8_=caml_call2(Stdlib[28],cst$72,cst$71),
            _g9_=caml_call1(R[7],a),
            _g__=caml_call2(Stdlib[28],_g9_,_g8_),
            a$0=caml_call2(Stdlib[28],cst$73,_g__);
          var _g6_=caml_call1(X[2],u),_g7_=caml_call2(Stdlib[28],a$0,_g6_);
          ans[1] = caml_call2(Stdlib[28],ans[1],_g7_);
          return 0}
        caml_call2(E[11],_g5_,x);
        return ans[1]}
      function map$0(f,p)
       {function _g4_(x,a,q){return add$0(q,cmul(a,caml_call1(f,x)))}
        return caml_call3(E[12],_g4_,p,zero)}
      function iter$0(f,p)
       {function _g3_(x,a){return caml_call2(f,a,x)}
        return caml_call2(E[11],_g3_,p)}
      var E$0=caml_call1(Stdlib_Map[1],[0,X[3]]);
      function set(f,x,p){return caml_call3(E$0[4],x,p,f)}
      function app(f,x)
       {try
         {var _g1_=caml_call2(E$0[28],x,f);return _g1_}
        catch(_g2_)
         {_g2_ = caml_wrap_exception(_g2_);
          if(_g2_ === Stdlib[8])return zero;
          throw _g2_}}
      function bind(f,p)
       {function _g0_(x,a,q){return add$0(q,cmul(a,app(f,x)))}
        return caml_call3(E$0[13],_g0_,p,zero)}
      var zero$0=E$0[1];
      function to_string$0(f)
       {function _gU_(x,p,s)
         {var
           _gV_=to_string(p),
           _gW_=caml_call2(Stdlib[28],_gV_,cst$75),
           _gX_=caml_call2(Stdlib[28],cst$76,_gW_),
           _gY_=caml_call1(X[2],x),
           _gZ_=caml_call2(Stdlib[28],_gY_,_gX_);
          return caml_call2(Stdlib[28],s,_gZ_)}
        return caml_call3(E$0[13],_gU_,f,cst$74)}
      var Map=[0,E$0,set,app,bind,zero$0,to_string$0];
      function make(gen){return gen}
      function dim(pres){return pres.length - 1}
      function presentation_to_string(pres)
       {var ans=[0,cst$77];
        function _gQ_(x)
         {var
           _gR_=caml_call1(X[2],x),
           _gS_=caml_string_equal(ans[1],cst$78)?cst$79:cst$80,
           _gT_=caml_call2(Stdlib[28],_gS_,_gR_);
          ans[1] = caml_call2(Stdlib[28],ans[1],_gT_);
          return 0}
        caml_call2(Stdlib_Array[13],_gQ_,pres);
        return ans[1]}
      var M=Make$1(R),L=caml_call1(M[11],X);
      function app$0(f,p)
       {return map$0
                (function(x)
                  {var ans=[0,zero];
                   function _gO_(y)
                    {var _gP_=cinj(caml_call3(L[5],f,x,y),y);
                     ans[1] = add$0(ans[1],_gP_);
                     return 0}
                   caml_call2(L[9],_gO_,f);
                   return ans[1]},
                 p)}
      function zero$1(src,tgt){return caml_call2(L[3],src,tgt)}
      function of_map(f,src,tgt)
       {var ans=zero$1(src,tgt);
        function _gL_(x)
         {var p=caml_call2(Map[3],f,x);
          return iter$0
                  (function(a,y)
                    {var
                      _gM_=caml_call3(L[5],ans,x,y),
                      _gN_=caml_call2(R[2],_gM_,a);
                     return caml_call4(L[4],ans,x,y,_gN_)},
                   p)}
        caml_call2(Stdlib_Array[13],_gL_,src);
        return ans}
      function to_map(f)
       {var ans=[0,Map[5]];
        function _gI_(x,y)
         {var
           _gJ_=cinj(caml_call3(L[5],f,x,y),y),
           _gK_=add$0(caml_call2(Map[3],ans[1],x),_gJ_);
          ans[1] = caml_call3(Map[2],ans[1],x,_gK_);
          return 0}
        caml_call2(L[10],_gI_,f);
        return ans[1]}
      var rank=L[6],nullity=L[7];
      function to_string$1(f)
       {var _gH_=to_map(f);return caml_call1(Map[6],_gH_)}
      var Map$0=[0,M,L,app$0,zero$1,of_map,to_map,rank,nullity,to_string$1];
      function iter$1(f,pres){return caml_call2(Stdlib_Array[13],f,pres)}
      function modules(c){return c[1]}
      function maps(c){return c[2]}
      function length(c){return c[2].length - 1}
      function make$0(modules,d)
       {if(modules.length - 1 === (d.length - 1 + 1 | 0))return [0,modules,d];
        throw [0,Assert_failure,_aG_]}
      function valid(c)
       {try
         {var _gk_=length(c) - 1 | 0,_gj_=1;
          if(! (_gk_ < 1))
           {var i=_gj_;
            for(;;)
             {var _gm_=i + 1 | 0,_gn_=caml_check_bound(c[1],_gm_)[1 + _gm_];
              iter$1
               (function(i)
                  {return function(x)
                    {var
                      _gq_=inj(x),
                      _gr_=caml_check_bound(c[2],i)[1 + i],
                      _gt_=i - 1 | 0,
                      _gs_=caml_call2(Map$0[3],_gr_,_gq_),
                      _gu_=caml_check_bound(c[2],_gt_)[1 + _gt_],
                      y=caml_call2(Map$0[3],_gu_,_gs_),
                      _gv_=1 - eq(zero,y);
                     if(_gv_)
                      {caml_call2(Stdlib_Printf[2],_aH_,i);
                       var
                        _gw_=inj(x),
                        _gx_=caml_check_bound(c[2],i)[1 + i],
                        _gy_=to_string(caml_call2(Map$0[3],_gx_,_gw_)),
                        _gz_=caml_call1(X[2],x);
                       caml_call3(Stdlib_Printf[2],_aI_,_gz_,_gy_);
                       var
                        _gA_=inj(x),
                        _gB_=caml_check_bound(c[2],i)[1 + i],
                        _gD_=i - 1 | 0,
                        _gC_=caml_call2(Map$0[3],_gB_,_gA_),
                        _gE_=caml_check_bound(c[2],_gD_)[1 + _gD_],
                        _gF_=to_string(caml_call2(Map$0[3],_gE_,_gC_)),
                        _gG_=caml_call1(X[2],x);
                       caml_call3(Stdlib_Printf[2],_aJ_,_gG_,_gF_);
                       throw Stdlib[3]}
                     return _gv_}}
                 (i),
                _gn_);
              var _go_=i + 1 | 0;
              if(_gk_ !== i){var i=_go_;continue}
              break}}
          var _gl_=1;
          return _gl_}
        catch(_gp_)
         {_gp_ = caml_wrap_exception(_gp_);
          if(_gp_ === Stdlib[3])return 0;
          throw _gp_}}
      function to_string$2(c)
       {var ans=[0,cst$81],_ga_=length(c) - 1 | 0;
        if(! (_ga_ < 0))
         {var i=_ga_;
          for(;;)
           {var
             _gb_=caml_check_bound(c[2],i)[1 + i],
             _gc_=caml_call1(Map$0[9],_gb_),
             _gd_=caml_call2(Stdlib[28],_gc_,cst$82),
             _ge_=caml_call2(Stdlib[28],cst$83,_gd_),
             _gf_=caml_call1(Stdlib[33],i),
             _gg_=caml_call2(Stdlib[28],_gf_,_ge_),
             _gh_=caml_call2(Stdlib[28],cst_d,_gg_);
            ans[1] = caml_call2(Stdlib[28],ans[1],_gh_);
            var _gi_=i - 1 | 0;
            if(0 !== i){var i=_gi_;continue}
            break}}
        return ans[1]}
      function betti(c)
       {function _f7_(i)
         {if(0 === i)
           var ker=caml_check_bound(c[1],0)[1].length - 1;
          else
           var
            _f__=i - 1 | 0,
            _f$_=caml_check_bound(c[2],_f__)[1 + _f__],
            ker=caml_call1(Map$0[8],_f$_);
          var
           _f9_=caml_check_bound(c[2],i)[1 + i],
           im=caml_call1(Map$0[7],_f9_);
          return ker - im | 0}
        var _f8_=length(c);
        return caml_call2(Stdlib_Array[2],_f8_,_f7_)}
      var
       Complex=[0,modules,maps,length,make$0,valid,to_string$2,betti],
       Pres=
        [0,
         make,
         dim,
         presentation_to_string,
         Map$0,
         iter$1,
         Complex,
         presentation_to_string];
      return [0,
              R,
              E,
              zero,
              cinj,
              inj,
              coeff,
              included,
              eq,
              add_monomial,
              add$0,
              cmul,
              neg,
              sub,
              to_string,
              map$0,
              iter$0,
              Map,
              Pres]}
    function FreeLeftModule(_f4_,_f3_)
     {var _f5_=FreeLeft(_f4_,_f3_);
      return [0,_f5_[1],_f5_[8],_f5_[10],_f5_[3],_f5_[14],_f5_[12],_f5_[11]]}
    function Free$0(_f2_,_f1_){return FreeLeft(_f2_,_f1_)}
    function FreeRight(R,X)
     {var
       include=FreeLeft(Op$0(R),X),
       Ring=include[1],
       E=include[2],
       zero=include[3],
       inj=include[5],
       coeff=include[6],
       included=include[7],
       eq=include[8],
       add_monomial=include[9],
       add=include[10],
       neg=include[12],
       sub=include[13],
       map=include[15],
       iter=include[16],
       Map=include[17],
       Pres=include[18],
       _fR_=include[4],
       _fS_=include[11];
      function cinj(x,a){return caml_call2(_fR_,a,x)}
      function cmul(x,a){return caml_call2(_fS_,a,x)}
      function to_string(x)
       {var ans=[0,cst$84];
        function _fT_(u,a)
         {var _fU_=1 - caml_call2(R[1],a,R[3]);
          if(_fU_)
           {if(caml_string_notequal(ans[1],cst$85))
             ans[1] = caml_call2(Stdlib[28],ans[1],cst$86);
            if(caml_call2(R[1],a,R[6]))
             var a$0=cst$87;
            else
             var
              _fY_=caml_call1(R[7],a),
              _fZ_=caml_call2(Stdlib[28],_fY_,cst$88),
              _f0_=caml_call2(Stdlib[28],cst$89,_fZ_),
              a$0=caml_call2(Stdlib[28],cst$90,_f0_);
            var _fV_=caml_call1(X[2],u),_fW_=caml_call2(Stdlib[28],_fV_,a$0);
            ans[1] = caml_call2(Stdlib[28],ans[1],_fW_);
            var _fX_=0}
          else
           var _fX_=_fU_;
          return _fX_}
        caml_call2(E[11],_fT_,x);
        return ans[1]}
      return [0,
              Ring,
              E,
              zero,
              inj,
              coeff,
              included,
              eq,
              add_monomial,
              add,
              neg,
              sub,
              map,
              iter,
              Map,
              Pres,
              cinj,
              cmul,
              to_string]}
    function FreeRightModule(_fP_,_fO_)
     {var _fQ_=FreeRight(_fP_,_fO_);
      return [0,_fQ_[1],_fQ_[7],_fQ_[9],_fQ_[3],_fQ_[18],_fQ_[10],_fQ_[17]]}
    var
     Alg_Module=
      [0,FreeLeft,FreeLeftModule,Free$0,FreeRight,FreeRightModule];
    caml_register_global(284,Alg_Module,"Alg__Module");
    function Full(V,E)
     {function label(x){return x[1]}
      function eq(x,y){return x === y?1:0}
      function compare(x,y){return caml_call2(V[3],x[1],y[1])}
      function to_string(x){return caml_call1(V[2],x[1])}
      var
       V$0=[0,label,eq,compare,to_string],
       VL=List$0([0,V$0[2],V$0[4],V$0[3]]);
      function eq$0(f,g){return f === g?1:0}
      function compare$0(f,g){return runtime.caml_compare(f,g)}
      function to_string$0(f)
       {var
         _fI_=caml_call1(VL[2],f[3]),
         _fJ_=caml_call2(Stdlib[28],cst$91,_fI_),
         _fK_=caml_call1(VL[2],f[2]),
         _fL_=caml_call2(Stdlib[28],_fK_,_fJ_),
         _fM_=caml_call2(Stdlib[28],cst$92,_fL_),
         _fN_=caml_call1(E[2],f[1]);
        return caml_call2(Stdlib[28],_fN_,_fM_)}
      function label$0(f){return f[1]}
      function src(f){return f[2]}
      function tgt(f){return f[3]}
      function make(l,s,t){return [0,l,s,t]}
      var
       E$0=[0,eq$0,compare$0,to_string$0,label$0,src,tgt,make],
       src$0=E$0[5],
       tgt$0=E$0[6];
      return [0,V$0,VL,E$0,src$0,tgt$0]}
    function Pres$1(_fB_,_fA_)
     {var
       include=Full(_fB_,_fA_),
       V=include[1],
       VL=include[2],
       E=include[3],
       src=include[4],
       tgt=include[5];
      function vertices(g){return g[1]}
      function edges(g){return g[2]}
      function add_vertex(g,x){return [0,[0,x,g[1]],g[2]]}
      function add_edge(g,e){return [0,g[1],[0,e,g[2]]]}
      function vertex_pred(g,v)
       {if(caml_call2(Stdlib_List[37],v,g[1]))
         {var
           _fF_=g[2],
           _fG_=
            function(e)
             {var _fH_=caml_call1(tgt,e);
              return caml_call2(Stdlib_List[37],v,_fH_)};
          return caml_call2(Stdlib_List[41],_fG_,_fF_)}
        throw [0,Assert_failure,_aK_]}
      function vertex_succ(g,v)
       {if(caml_call2(Stdlib_List[37],v,g[1]))
         {var
           _fC_=g[2],
           _fD_=
            function(e)
             {var _fE_=caml_call1(src,e);
              return caml_call2(Stdlib_List[37],v,_fE_)};
          return caml_call2(Stdlib_List[41],_fD_,_fC_)}
        throw [0,Assert_failure,_aL_]}
      function edge_pred(g,e){return caml_call1(src,e)}
      function edge_succ(g,e){return caml_call1(tgt,e)}
      return [0,
              V,
              VL,
              E,
              src,
              tgt,
              vertices,
              edges,
              empty$3,
              add_vertex,
              add_edge,
              vertex_pred,
              vertex_succ,
              edge_pred,
              edge_succ]}
    function Map$0(V,E)
     {var
       MV=caml_call1(Stdlib_Map[1],[0,V[3]]),
       ME=caml_call1(Stdlib_Map[1],[0,E[3]]);
      return [0,MV,ME]}
    var Alg_Hypergraph=[0,Full,Pres$1,Map$0];
    caml_register_global(285,Alg_Hypergraph,"Alg__Hypergraph");
    function src(param){return 0}
    function tgt(param){return 0}
    var Terminal=[0,Unit,Unit,src,tgt];
    function Full$0(V,E)
     {var include=Prod(E,Prod(V,V)),eq=include[1],compare=include[3];
      function to_string(param){var f=param[1];return caml_call1(E[2],f)}
      var E$0=[0,eq,compare,to_string];
      function src(param){var match=param[2],x=match[1];return x}
      function tgt(param){var match=param[2],y=match[2];return y}
      return [0,V,E$0,src,tgt]}
    function Pres$2(V,E)
     {var Graph=Full$0(V,E);
      function add_vertex(p,x){return [0,[0,x,p[1]],p[2]]}
      function add_edge(p,f,param)
       {var y=param[2],x=param[1];return [0,p[1],[0,[0,f,[0,x,y]],p[2]]]}
      function edge(p,f)
       {var match=caml_call2(Stdlib_List[46],f,p[2]),y=match[2],x=match[1];
        return [0,f,[0,x,y]]}
      function has_vertex(p,x)
       {var _fy_=p[1];
        function _fz_(y){return caml_call2(V[1],x,y)}
        return caml_call2(Stdlib_List[33],_fz_,_fy_)}
      function to_string(g)
       {var
         vertices=caml_call2(Stdlib_List[19],V[2],g[1]),
         vertices$0=caml_call2(Stdlib_String[6],cst$93,vertices),
         _fp_=g[2];
        function _fq_(param)
         {var
           match=param[2],
           y=match[2],
           x=match[1],
           f=param[1],
           _fs_=caml_call1(V[2],y),
           _ft_=caml_call2(Stdlib[28],cst$94,_fs_),
           _fu_=caml_call1(V[2],x),
           _fv_=caml_call2(Stdlib[28],_fu_,_ft_),
           _fw_=caml_call2(Stdlib[28],cst$95,_fv_),
           _fx_=caml_call1(E[2],f);
          return caml_call2(Stdlib[28],_fx_,_fw_)}
        var
         edges=caml_call2(Stdlib_List[19],_fq_,_fp_),
         edges$0=caml_call2(Stdlib_String[6],cst$96,edges),
         _fr_=caml_call2(Stdlib[28],cst$97,edges$0);
        return caml_call2(Stdlib[28],vertices$0,_fr_)}
      return [0,Graph,empty$4,add_vertex,add_edge,edge,has_vertex,to_string]}
    var Alg_Graph=[0,Terminal,Full$0,Pres$2];
    caml_register_global(286,Alg_Graph,"Alg__Graph");
    var to_string$21=Stdlib[33];
    function dim(n){return n}
    function src$0(n){if(0 < n)return n - 1 | 0;throw [0,Assert_failure,_aM_]}
    function tgt$0(n){if(0 < n)return n - 1 | 0;throw [0,Assert_failure,_aN_]}
    var Terminal$0=[0,to_string$21,dim,src$0,tgt$0];
    function Pres$3(X)
     {var
       Cell=Prod3([0,Int$0[1],Int$0[2],Int$0[3]],X,X),
       E=Map(X,Cell),
       empty=E[2];
      function mem(s,g){return caml_call2(E[5],s,g)}
      function dim(s,g){var match=caml_call2(E[3],s,g),n=match[1];return n}
      function src(s,g)
       {if(0 < dim(s,g))
         {var match=caml_call2(E[3],s,g),src=match[2],n=match[1];
          if(0 < n)return src;
          throw [0,Assert_failure,_aO_]}
        throw [0,Assert_failure,_aP_]}
      function tgt(s,g)
       {var match=caml_call2(E[3],s,g),tgt=match[3],n=match[1];
        if(0 < n)return tgt;
        throw [0,Assert_failure,_aQ_]}
      function add0(s,g){return caml_call3(E[4],s,g,[0,0,g,g])}
      function add(s,g,src,tgt)
       {if(mem(s,src))
         {if(mem(s,tgt))
           {var n=dim(s,src) + 1 | 0;
            if((dim(s,tgt) + 1 | 0) === n)
             return caml_call3(E[4],s,g,[0,n,src,tgt]);
            throw [0,Assert_failure,_aR_]}
          throw [0,Assert_failure,_aS_]}
        throw [0,Assert_failure,_aT_]}
      function Make(P)
       {var _fi_=X[2],_fj_=P[1];
        function dim$0(_fo_){return dim(_fj_,_fo_)}
        var _fk_=P[1];
        function src$0(_fn_){return src(_fk_,_fn_)}
        var _fl_=P[1];
        function tgt$0(_fm_){return tgt(_fl_,_fm_)}
        return [0,_fi_,dim$0,src$0,tgt$0]}
      return [0,Cell,E,empty,mem,dim,src,tgt,add0,add,Make]}
    var n=[0,-1];
    function fresh$0(param){n[1]++;return n[1]}
    function to_string$22(x)
     {var _fh_=caml_call1(Stdlib[33],x);
      return caml_call2(Stdlib[28],cst_x$0,_fh_)}
    var Var$0=[0,fresh$0,to_string$22],n$0=[0,-1];
    function fresh$1(param){n$0[1]++;return n$0[1]}
    function to_string$23(x)
     {var _fg_=caml_call1(Stdlib[33],x);
      return caml_call2(Stdlib[28],cst_f,_fg_)}
    var
     Cons=[0,fresh$1,to_string$23],
     Theory=[0,Var$0,Cons],
     Alg_Globular=[0,Terminal$0,Pres$3,Theory];
    caml_register_global(287,Alg_Globular,"Alg__Globular");
    function Free$1(G)
     {var
       V=G[1],
       M=Free(G[2]),
       include=Prod3(V,[0,M[6],M[9],M[7]],V),
       eq=include[1],
       compare=include[3];
      function to_string(param)
       {var f=param[2],x=param[1];
        if(caml_call2(M[6],M[2],f))
         {var _ff_=caml_call1(V[2],x);
          return caml_call2(Stdlib[28],cst_id,_ff_)}
        return caml_call1(M[9],f)}
      var E=[0,eq,compare,to_string];
      function src(param){var x=param[1];return x}
      function tgt(param){var y=param[3];return y}
      function id(x){return [0,x,M[2],x]}
      function comp(param,_fe_)
       {var z=_fe_[3],g=_fe_[2],y=_fe_[1],y$0=param[3],f=param[2],x=param[1];
        if(caml_call2(V[1],y$0,y))return [0,x,caml_call2(M[1],f,g),z];
        throw [0,Assert_failure,_aU_]}
      function inj(f)
       {var _fc_=caml_call1(G[4],f),_fd_=caml_call1(M[3],f);
        return [0,caml_call1(G[3],f),_fd_,_fc_]}
      return [0,V,M,E,src,tgt,id,comp,inj]}
    function FreeCategory(_e$_)
     {var _fa_=Free$1(_e$_),_fb_=_fa_[3];
      return [0,
              _fa_[1],
              [0,_fb_[1],_fb_[3],_fb_[2]],
              _fa_[4],
              _fa_[5],
              _fa_[7],
              _fa_[6]]}
    function Pres$4(V,E)
     {var
       GP=Pres$2(V,E),
       _e1_=GP[1],
       _e2_=_e1_[2],
       Free=Free$1([0,_e1_[1],[0,_e2_[1],_e2_[3],_e2_[2]],_e1_[3],_e1_[4]]),
       empty=[0,GP[2],0];
      function add_object(p,x)
       {var _e__=p[2];return [0,caml_call2(GP[3],p[1],x),_e__]}
      function add_morphism(p,f,x,y)
       {if(caml_call2(GP[6],p[1],x))
         {if(caml_call2(GP[6],p[1],y))
           {var _e9_=p[2];return [0,caml_call3(GP[4],p[1],f,[0,x,y]),_e9_]}
          throw [0,Assert_failure,_aV_]}
        throw [0,Assert_failure,_aW_]}
      function morphism(p,f)
       {var _e8_=caml_call2(GP[5],p[1],f);return caml_call1(Free[8],_e8_)}
      function add_relation(p,f,g){return [0,p[1],[0,[0,f,g],p[2]]]}
      function to_string(p)
       {var graph=caml_call1(GP[7],p[1]),relations=p[2];
        function _e3_(param)
         {var
           g=param[2],
           f=param[1],
           _e5_=caml_call1(Free[3][3],g),
           _e6_=caml_call2(Stdlib[28],cst$98,_e5_),
           _e7_=caml_call1(Free[3][3],f);
          return caml_call2(Stdlib[28],_e7_,_e6_)}
        var
         relations$0=caml_call2(Stdlib_List[19],_e3_,relations),
         relations$1=caml_call2(Stdlib_String[6],cst$99,relations$0),
         _e4_=caml_call2(Stdlib[28],cst$100,relations$1);
        return caml_call2(Stdlib[28],graph,_e4_)}
      return [0,
              GP,
              Free,
              empty,
              add_object,
              add_morphism,
              morphism,
              add_relation,
              to_string]}
    function Monoid(M)
     {function src(param){return 0}
      function tgt(param){return 0}
      var comp=M[2];
      function id(param){return M[3]}
      return [0,Unit,[0,M[1],M[4],M[5]],src,tgt,comp,id]}
    function Graph(C)
     {var V=C[1],E=C[2],src=C[3],tgt=C[4];return [0,V,E,src,tgt]}
    var Alg_Category=[0,Free$1,FreeCategory,Pres$4,Monoid,Graph];
    caml_register_global(288,Alg_Category,"Alg__Category");
    function Regexp(X)
     {function letter(a){return [0,a]}
      function union(r,s){return [1,r,s]}
      var empty=0;
      function concat(r,s){return [2,r,s]}
      function star(r){return [3,r]}
      function unions(param)
       {if(param)
         {var _e0_=param[1];
          if(param[2]){var l=param[2];return [1,_e0_,unions(l)]}
          return _e0_}
        return 0}
      function to_string(r)
       {function aux(l,r)
         {function pa(l$0,s)
           {if(l$0 < l)
             {var _eZ_=caml_call2(Stdlib[28],s,cst$101);
              return caml_call2(Stdlib[28],cst$102,_eZ_)}
            return s}
          if(typeof r === "number")
           return 0 === r?cst_0$0:cst_1;
          else
           switch(r[0])
            {case 0:var a=r[1];return caml_call1(X[2],a);
             case 1:
              var
               s=r[2],
               r$0=r[1],
               _eS_=aux(0,s),
               _eT_=caml_call2(Stdlib[28],cst$103,_eS_),
               _eU_=aux(0,r$0);
              return pa(0,caml_call2(Stdlib[28],_eU_,_eT_));
             case 2:
              var
               s$0=r[2],
               r$1=r[1],
               _eV_=aux(1,s$0),
               _eW_=caml_call2(Stdlib[28],cst$104,_eV_),
               _eX_=aux(1,r$1);
              return pa(1,caml_call2(Stdlib[28],_eX_,_eW_));
             default:
              var r$2=r[1],_eY_=aux(2,r$2);
              return caml_call2(Stdlib[28],_eY_,cst$105)}}
        return aux(-1,r)}
      function f(r)
       {var r$0=r;
        for(;;)
         {if(typeof r$0 !== "number")
           switch(r$0[0])
            {case 1:
              var _eL_=r$0[1];
              if(typeof _eL_ === "number" && ! _eL_)
               {var r$1=r$0[2],r$0=r$1;continue}
              var _eM_=r$0[2];
              if(typeof _eM_ === "number" && ! _eM_){var r$0=_eL_;continue}
              var s=r$0[2],_eN_=f(s);
              return [1,f(_eL_),_eN_];
             case 2:
              var _eO_=r$0[1];
              if(typeof _eO_ === "number" && ! _eO_)return 0;
              var _eP_=r$0[2];
              if(typeof _eP_ === "number" && ! _eP_)return 0;
              if(typeof _eO_ === "number"){var r$2=r$0[2],r$0=r$2;continue}
              if(typeof r$0[2] === "number"){var r$0=_eO_;continue}
              var s$0=r$0[2],_eQ_=f(s$0);
              return [2,f(_eO_),_eQ_];
             case 3:
              var _eR_=r$0[1];
              if(typeof _eR_ === "number" && ! _eR_)return 0;
              return [3,f(_eR_)]
             }
          return r$0}}
      function simpl(x)
       {var x$0=x;
        for(;;)
         {var x$1=f(x$0);
          if(caml_equal(x$1,x$0))return x$0;
          var x$0=x$1;
          continue}}
      var Series=Make(Int$1);
      function series(param)
       {if(typeof param === "number")
         return 0 === param?Series[6]:Series[7];
        else
         switch(param[0])
          {case 0:return Series[8];
           case 1:
            var b=param[2],a=param[1],_eG_=series(b),_eH_=series(a);
            return caml_call2(Series[9],_eH_,_eG_);
           case 2:
            var b$0=param[2],a$0=param[1],_eI_=series(b$0),_eJ_=series(a$0);
            return caml_call2(Series[11],_eJ_,_eI_);
           default:
            var a$1=param[1],_eK_=series(a$1);
            return caml_call1(Series[16],_eK_)}}
      return [0,
              letter,
              union,
              empty,
              concat,
              star,
              unions,
              to_string,
              simpl,
              Series,
              series]}
    function Make$2(X)
     {var
       States=Pow([0,Int$0[1],Int$0[2],Int$0[3]]),
       _eh_=[0,States[2],States[4],States[3]],
       T=Map(Prod([0,Int$0[1],Int$0[2],Int$0[3]],X),_eh_),
       Regexp$0=Regexp(X);
      function states(aut){return aut[1]}
      function trans(aut,a,x)
       {try
         {var _eE_=caml_call2(T[3],aut[4],[0,a,x]);return _eE_}
        catch(_eF_)
         {_eF_ = caml_wrap_exception(_eF_);
          if(_eF_ === Stdlib[8])return States[5];
          throw _eF_}}
      function add_transition(aut,a,x,b)
       {var
         bb=trans(aut,a,x),
         bb$0=caml_call2(States[7],bb,b),
         transitions=caml_call3(T[4],aut[4],[0,a,x],bb$0);
        return [0,aut[1],aut[2],aut[3],transitions]}
      function create(states,initial,terminal,transitions)
       {var
         terminal$0=caml_call1(States[6],terminal),
         ans=[0,states,initial,terminal$0,T[2]];
        function _eD_(ans,param)
         {var b=param[3],x=param[2],a=param[1];
          return add_transition(ans,a,x,b)}
        return caml_call3(Stdlib_List[25],_eD_,ans,transitions)}
      function kleene(aut)
       {var n=aut[1];
        function init(f)
         {function _eB_(i)
           {function _eC_(j){return caml_call2(f,i,j)}
            return caml_call2(Stdlib_Array[2],n,_eC_)}
          return caml_call2(Stdlib_Array[2],n,_eB_)}
        var
         rr=
          init
           (function(i,j)
             {var r=[0,Regexp$0[3]],_ev_=aut[4];
              function _ew_(param,jj)
               {var
                 a=param[2],
                 i$0=param[1],
                 _ex_=caml_call2(Int$0[1],i,i$0),
                 _ey_=_ex_?caml_call2(States[8],jj,j):_ex_;
                if(_ey_)
                 {var _ez_=caml_call1(Regexp$0[1],a);
                  r[1] = caml_call2(Regexp$0[2],r[1],_ez_);
                  var _eA_=0}
                else
                 var _eA_=_ey_;
                return _eA_}
              caml_call2(T[6],_ew_,_ev_);
              if(i === j)r[1] = caml_call2(Regexp$0[2],Regexp$0[3],r[1]);
              return r[1]}),
         rr$0=[0,rr],
         _ej_=n - 1 | 0,
         _ei_=0;
        if(! (_ej_ < 0))
         {var k=_ei_;
          for(;;)
           {var
             rr$2=rr$0[1],
             ss=
              init
               (function(k,rr)
                  {return function(i,j)
                    {var
                      _eo_=
                       caml_check_bound(caml_check_bound(rr,k)[1 + k],j)[1 + j],
                      _ep_=
                       caml_check_bound(caml_check_bound(rr,k)[1 + k],k)[1 + k],
                      _eq_=caml_call1(Regexp$0[5],_ep_),
                      _er_=caml_call2(Regexp$0[4],_eq_,_eo_),
                      _es_=
                       caml_check_bound(caml_check_bound(rr,i)[1 + i],k)[1 + k],
                      _et_=caml_call2(Regexp$0[4],_es_,_er_),
                      _eu_=
                       caml_check_bound(caml_check_bound(rr,i)[1 + i],j)[1 + j];
                     return caml_call2(Regexp$0[2],_eu_,_et_)}}
                 (k,rr$2));
            rr$0[1] = ss;
            var _em_=k + 1 | 0;
            if(_ej_ !== k){var k=_em_;continue}
            break}}
        var rr$1=rr$0[1],r=[0,Regexp$0[3]],i=aut[2],_ek_=aut[3];
        function _el_(j)
         {var _en_=caml_check_bound(caml_check_bound(rr$1,i)[1 + i],j)[1 + j];
          r[1] = caml_call2(Regexp$0[2],r[1],_en_);
          return 0}
        caml_call2(States[9],_el_,_ek_);
        return r[1]}
      return [0,States,T,Regexp$0,states,trans,add_transition,create,kleene]}
    var Alg_Automaton=[0,Regexp,Make$2];
    caml_register_global(289,Alg_Automaton,"Alg__Automaton");
    function Free$2(Field,M)
     {var
       include=
        FreeLeft
         ([0,Field[1],Field[2],Field[3],Field[4],Field[5],Field[6],Field[7]],
          [0,M[1],M[4],M[5]]),
       _d3_=include[5],
       _eb_=include[15],
       _ec_=include[16],
       _dZ_=include[1],
       _d0_=include[2],
       _d1_=include[3],
       _d2_=include[4],
       _d4_=include[6],
       _d5_=include[7],
       _d6_=include[8],
       _d7_=include[9],
       _d8_=include[10],
       _d9_=include[11],
       _d__=include[12],
       _d$_=include[13],
       _ea_=include[14],
       _ed_=include[17],
       _ee_=include[18],
       one=caml_call1(_d3_,M[3]);
      function mul_monomial(p,v)
       {return caml_call2
                (_eb_,
                 function(u){return caml_call1(_d3_,caml_call2(M[2],u,v))},
                 p)}
      function mul(p,q)
       {return caml_call2(_eb_,function(v){return mul_monomial(p,v)},q)}
      function leading(leq,p)
       {var a=[0,Field[3]],u=[0,M[3]];
        caml_call2
         (_ec_,
          function(b,v)
           {var
             _ef_=caml_call2(leq,u[1],v),
             _eg_=_ef_?(a[1] = b,u[1] = v,0):_ef_;
            return _eg_},
          p);
        return [0,a[1],u[1]]}
      return [0,
              _dZ_,
              _d0_,
              _d1_,
              _d2_,
              _d3_,
              _d4_,
              _d5_,
              _d6_,
              _d7_,
              _d8_,
              _d9_,
              _d__,
              _d$_,
              _ea_,
              _eb_,
              _ec_,
              _ed_,
              _ee_,
              Field,
              one,
              mul_monomial,
              mul,
              leading]}
    function FreeAlgebra(_dX_,_dW_)
     {var _dY_=Free$2(_dX_,_dW_);
      return [0,
              _dY_[8],
              _dY_[10],
              _dY_[3],
              _dY_[12],
              _dY_[22],
              _dY_[20],
              _dY_[14],
              _dY_[19],
              _dY_[11]]}
    function Pres$5(K,X)
     {var M=Free(X),include$0=Free$2(K,[0,M[6],M[1],M[2],M[9],M[7]]);
      function free(leq,generators){return [0,leq,generators,0]}
      function orient(pres,p)
       {var
         match=caml_call2(include$0[23],pres[1],p),
         u=match[2],
         a=match[1],
         _dU_=caml_call1(K[8],a),
         p$0=caml_call2(include$0[11],_dU_,p),
         _dV_=caml_call1(include$0[5],u),
         p$1=caml_call2(include$0[13],_dV_,p$0);
        return [0,u,p$1]}
      function add_rule(pres,r)
       {var rules=[0,r,pres[3]];return [0,pres[1],pres[2],rules]}
      function add_relation(pres,p){return add_rule(pres,orient(pres,p))}
      function make(leq,generators,pp)
       {var _dT_=free(leq,generators);
        return caml_call3(Stdlib_List[25],add_relation,_dT_,pp)}
      function heads(pres)
       {var _dR_=pres[3];
        function _dS_(param){var u=param[1];return u}
        return caml_call2(Stdlib_List[19],_dS_,_dR_)}
      function to_string(pres)
       {var _dF_=pres[3];
        function _dG_(param)
         {var
           p=param[2],
           u=param[1],
           _dO_=caml_call1(include$0[14],p),
           _dP_=caml_call2(Stdlib[28],cst$107,_dO_),
           _dQ_=caml_call1(M[9],u);
          return caml_call2(Stdlib[28],_dQ_,_dP_)}
        var
         _dH_=caml_call2(Stdlib_List[19],_dG_,_dF_),
         _dI_=caml_call2(Stdlib_String[6],cst$108,_dH_),
         _dJ_=caml_call2(Stdlib[28],_dI_,cst$106),
         _dK_=caml_call2(Stdlib[28],cst$109,_dJ_),
         _dL_=caml_call2(Stdlib_List[19],X[2],pres[2]),
         _dM_=caml_call2(Stdlib_String[6],cst$110,_dL_),
         _dN_=caml_call2(Stdlib[28],_dM_,_dK_);
        return caml_call2(Stdlib[28],cst$111,_dN_)}
      function normalize(pres,p)
       {var p$0=[0,p],loop=[0,1];
        for(;;)
         {if(loop[1])
           {loop[1] = 0;
            var
             _dv_=p$0[1],
             _dw_=
              function(u)
               {try
                 {var
                   _dx_=pres[3],
                   _dy_=
                    function(param){var v=param[1];return caml_call2(M[10],v,u)},
                   match=caml_call2(Stdlib_List[38],_dy_,_dx_),
                   v=match[2],
                   v$0=match[1];
                  loop[1] = 1;
                  var
                   i=caml_call3(M[11],0,u,v$0),
                   v1=caml_call3(M[5],u,0,i),
                   _dz_=i + caml_call1(M[4],v$0) | 0,
                   _dA_=caml_call1(M[4],u) - _dz_ | 0,
                   _dB_=i + caml_call1(M[4],v$0) | 0,
                   v2=caml_call3(M[5],u,_dB_,_dA_),
                   v1$0=caml_call1(include$0[5],v1),
                   v2$0=caml_call1(include$0[5],v2),
                   _dC_=caml_call2(include$0[22],v,v2$0),
                   _dD_=caml_call2(include$0[22],v1$0,_dC_);
                  return _dD_}
                catch(_dE_)
                 {_dE_ = caml_wrap_exception(_dE_);
                  if(_dE_ === Stdlib[8])return caml_call1(include$0[5],u);
                  throw _dE_}};
            p$0[1] = caml_call2(include$0[15],_dw_,_dv_);
            continue}
          return p$0[1]}}
      function buchberger(pres)
       {var todo=caml_call1(Stdlib_Queue[2],0),_dl_=pres[3];
        function _dm_(r){return caml_call2(Stdlib_Queue[3],r,todo)}
        caml_call2(Stdlib_List[17],_dm_,_dl_);
        var pres$0=[0,pres];
        for(;;)
         {if(caml_call1(Stdlib_Queue[13],todo))return pres$0[1];
          var
           match=caml_call1(Stdlib_Queue[7],todo),
           p=match[2],
           u=match[1],
           _dn_=pres$0[1][3],
           _do_=
            function(p,u)
              {return function(param)
                {var q=param[2],v=param[1],_dp_=caml_call2(M[14],u,v);
                 function _dq_(param)
                  {var
                    _ds_=param[2],
                    v2=_ds_[2],
                    v1=_ds_[1],
                    match=param[1],
                    u2=match[2],
                    u1=match[1],
                    u1$0=caml_call1(include$0[5],u1),
                    u2$0=caml_call1(include$0[5],u2),
                    v1$0=caml_call1(include$0[5],v1),
                    v2$0=caml_call1(include$0[5],v2),
                    _dt_=caml_call2(include$0[22],p,u2$0),
                    s1=caml_call2(include$0[22],u1$0,_dt_),
                    _du_=caml_call2(include$0[22],q,v2$0),
                    s2=caml_call2(include$0[22],v1$0,_du_),
                    s=caml_call2(include$0[13],s1,s2),
                    p$0=normalize(pres$0[1],s),
                    _dr_=1 - caml_call2(include$0[8],include$0[3],p$0);
                   if(_dr_)
                    {var r=orient(pres$0[1],p$0);
                     pres$0[1] = add_rule(pres$0[1],r);
                     return caml_call2(Stdlib_Queue[4],r,todo)}
                   return _dr_}
                 return caml_call2(Stdlib_List[17],_dq_,_dp_)}}
             (p,u);
          caml_call2(Stdlib_List[17],_do_,_dn_);
          continue}}
      function reduce(pres)
       {var rules=pres[3];
        function _dj_(param)
         {var p=param[2],u=param[1];return [0,u,normalize(pres,p)]}
        var param=caml_call2(Stdlib_List[19],_dj_,rules),acc=0,param$0=param;
        for(;;)
         {if(param$0)
           {var
             rules$0=param$0[2],
             match=param$0[1],
             p=match[2],
             u=match[1],
             f$0=
              function(u)
               {function f(l)
                 {function _dk_(param)
                   {var v=param[1];return caml_call2(M[10],v,u)}
                  return caml_call2(Stdlib_List[33],_dk_,l)}
                return f},
             f=f$0(u);
            if(! f(acc) && ! f(rules$0))
             {var acc$0=[0,[0,u,p],acc],acc=acc$0,param$0=rules$0;continue}
            var param$0=rules$0;
            continue}
          var rules$1=caml_call1(Stdlib_List[9],acc);
          return [0,pres[1],pres[2],rules$1]}}
      function Algebra(_c__)
       {var
         _c$_=include$0[3],
         _da_=include$0[8],
         _db_=include$0[10],
         _dc_=include$0[11],
         _dd_=include$0[12],
         _de_=include$0[14],
         _df_=include$0[19],
         _dg_=include$0[20],
         _dh_=include$0[22],
         _di_=_c__[1];
        function mul(p,q){return normalize(_di_,caml_call2(_dh_,p,q))}
        return [0,_da_,_db_,_c$_,_dd_,mul,_dg_,_de_,_df_,_dc_]}
      var Invalid=[248,cst_Alg_Algebra_Pres_K_X_Augme,caml_fresh_oo_id(0)];
      function make$0(pres,eps)
       {function eps$0(p)
         {var ans=[0,K[3]];
          function _c7_(a,u)
           {var _c8_=caml_call1(eps,u),_c9_=caml_call2(K[5],a,_c8_);
            ans[1] = caml_call2(K[2],ans[1],_c9_);
            return 0}
          caml_call2(include$0[16],_c7_,p);
          return ans[1]}
        var _c1_=eps$0(caml_call1(include$0[5],M[2]));
        if(caml_call2(K[1],K[6],_c1_))
         {var
           _c2_=pres[3],
           _c3_=
            function(param)
             {var
               p=param[2],
               u=param[1],
               _c4_=eps$0(p),
               _c5_=eps$0(caml_call1(include$0[5],u)),
               _c6_=1 - caml_call2(K[1],_c5_,_c4_);
              if(_c6_)throw Invalid;
              return _c6_};
          caml_call2(Stdlib_List[17],_c3_,_c2_);
          return eps$0}
        throw [0,Assert_failure,_aX_]}
      function graded(pres)
       {return make$0
                (pres,function(u){return caml_call2(M[6],M[2],u)?K[6]:K[3]})}
      function monoid(pres){return make$0(pres,function(u){return K[6]})}
      var
       Augmentation=[0,Invalid,make$0,graded,monoid],
       _bE_=M[16],
       Mod=
        FreeRight
         ([0,
           include$0[8],
           include$0[10],
           include$0[3],
           include$0[12],
           include$0[22],
           include$0[20],
           include$0[14]],
          [0,_bE_[7],_bE_[12],_bE_[8]]),
       to_string$0=Mod[18],
       cmul=Mod[17],
       cinj=Mod[16],
       Pres=Mod[15],
       iter=Mod[13],
       map=Mod[12],
       sub=Mod[11],
       neg=Mod[10],
       add=Mod[9],
       add_monomial=Mod[8],
       eq=Mod[7],
       included=Mod[6],
       coeff=Mod[5],
       inj=Mod[4],
       zero=Mod[3],
       E=Mod[2],
       Ring=Mod[1];
      function normalize$0(pres,p)
       {var ans=[0,zero];
        caml_call2
         (iter,
          function(u,c)
           {var u$0=normalize(pres,u),_c0_=caml_call2(cinj,c,u$0);
            ans[1] = caml_call2(add,ans[1],_c0_);
            return 0},
          p);
        return ans[1]}
      var
       include=Mod[14],
       E$0=include[1],
       set=include[2],
       app=include[3],
       zero$0=include[5],
       to_string$1=include[6],
       _bF_=include[4];
      function bind(pres,f,p){return normalize$0(pres,caml_call2(_bF_,f,p))}
      var
       Map=[0,E$0,set,app,zero$0,to_string$1,bind],
       AMod=
        [0,
         Mod,
         Ring,
         E,
         zero,
         inj,
         coeff,
         included,
         eq,
         add_monomial,
         add,
         neg,
         sub,
         map,
         iter,
         Pres,
         cinj,
         cmul,
         to_string$0,
         normalize$0,
         Map];
      function cinj$0(a,c,u)
       {var _cZ_=caml_call2(include$0[4],a,u);
        return caml_call2(AMod[16],c,_cZ_)}
      function cmul$0(a,cu)
       {var _cY_=caml_call2(include$0[11],a,include$0[20]);
        return caml_call2(AMod[17],cu,_cY_)}
      function iter$0(f,p)
       {function _cW_(u,c)
         {function _cX_(a,u){return caml_call3(f,a,c,u)}
          return caml_call2(include$0[16],_cX_,u)}
        return caml_call2(AMod[14],_cW_,p)}
      function map$0(f,p)
       {var ans=[0,AMod[4]];
        iter$0
         (function(a,c,u)
           {var _cV_=cmul$0(a,caml_call2(f,c,u));
            ans[1] = caml_call2(AMod[10],ans[1],_cV_);
            return 0},
          p);
        return ans[1]}
      var AKMod=[0,cinj$0,cmul$0,iter$0,map$0];
      function chains(pres,n)
       {var cc=caml_make_vect(n + 1 | 0,[0,M[16][1],0]);
        if(1 <= n)
         {var _cL_=caml_call1(M[16][3],pres[2]);
          caml_check_bound(cc,1)[2] = _cL_}
        var _cM_=pres[3];
        function _cN_(_cU_){return _cU_[1]}
        var left=caml_call2(Stdlib_List[19],_cN_,_cM_),_cP_=n - 1 | 0,_cO_=1;
        if(! (_cP_ < 1))
         {var i=_cO_;
          for(;;)
           {var
             _cQ_=caml_check_bound(cc,i)[1 + i],
             _cS_=i + 1 | 0,
             _cR_=caml_call2(M[16][9],left,_cQ_);
            caml_check_bound(cc,_cS_)[1 + _cS_] = _cR_;
            var _cT_=i + 1 | 0;
            if(_cP_ !== i){var i=_cT_;continue}
            break}}
        return cc}
      function resolution(augmentation,pres,n)
       {var debug=0;
        if(augmentation)
         var augmentation$0=augmentation[1],augmentation$1=augmentation$0;
        else
         var augmentation$1=caml_call1(Augmentation[3],pres);
        var cc=chains(pres,n);
        function _bM_(param){return AMod[20][4]}
        var d=caml_call2(Stdlib_Array[2],n,_bM_),_bN_=pres[2];
        function _bO_(x)
         {var
           _cF_=caml_call1(M[3],x),
           x$0=caml_call1(include$0[5],_cF_),
           a=caml_call1(augmentation$1,x$0),
           _cE_=caml_call2(include$0[4],a,M[2]),
           _cG_=caml_call2(include$0[13],x$0,_cE_),
           _cH_=caml_call2(AMod[16],M[16][1],_cG_),
           _cI_=caml_call1(M[16][2],x),
           _cJ_=caml_check_bound(d,0)[1],
           _cK_=caml_call3(AMod[20][2],_cJ_,_cI_,_cH_);
          caml_check_bound(d,0)[1] = _cK_;
          return debug}
        caml_call2(Stdlib_List[17],_bO_,_bN_);
        function ch(n,p)
         {function _b7_(u,c)
           {if(caml_call1(M[16][11],c) === n)return 0;
            throw [0,Assert_failure,_aY_]}
          caml_call2(AMod[14],_b7_,p);
          if(0 !== n)
           {var
             _co_=n - 1 | 0,
             _cp_=caml_check_bound(d,_co_)[1 + _co_],
             _cq_=caml_call3(AMod[20][6],pres,_cp_,p);
            if(! caml_call2(AMod[8],AMod[4],_cq_))
             throw [0,Assert_failure,_a3_]}
          if(caml_call2(AMod[8],AMod[4],p))return AMod[4];
          if(0 === n)
           {var
             ans=[0,AMod[4]],
             _b8_=
              function(a,c,u)
               {if(0 === caml_call1(M[4],u))return 0;
                var _cy_=caml_call1(M[4],u) - 1 | 0,_cx_=0;
                if(! (_cy_ < 0))
                 {var i=_cx_;
                  for(;;)
                   {var
                     v=caml_call3(M[5],u,0,i),
                     _cz_=caml_check_bound(u,i)[1 + i],
                     c$0=caml_call1(M[16][2],_cz_),
                     _cA_=caml_call1(M[4],u) - (i + 1 | 0) | 0,
                     u$0=caml_call3(M[5],u,i + 1 | 0,_cA_),
                     _cB_=caml_call1(augmentation$1,caml_call1(include$0[5],v)),
                     a$0=caml_call2(K[5],a,_cB_),
                     _cC_=caml_call3(AKMod[1],a$0,c$0,u$0);
                    ans[1] = caml_call2(AMod[10],ans[1],_cC_);
                    var _cD_=i + 1 | 0;
                    if(_cy_ !== i){var i=_cD_;continue}
                    break}}
                return 0};
            caml_call2(AKMod[3],_b8_,p);
            return ans[1]}
          var
           a=[0,K[3]],
           c=[0,M[16][1]],
           u=[0,M[2]],
           cu=[0,M[2]],
           _b9_=n - 1 | 0,
           _b__=caml_check_bound(d,_b9_)[1 + _b9_],
           _b$_=caml_call3(AMod[20][6],pres,_b__,p);
          if(1 - caml_call2(AMod[8],AMod[4],_b$_))
           {var
             _ca_=caml_call1(AMod[18],p),
             _cb_=caml_call2(Stdlib[28],_ca_,cst_not_in_the_kernel);
            caml_call1(Stdlib[2],_cb_)}
          function _cc_(a$0,c$0,u$0)
           {var
             _cu_=caml_call1(M[16][10],c$0),
             cu$0=caml_call2(M[1],_cu_,u$0),
             _cv_=caml_call2(pres[1],cu[1],cu$0);
            if(_cv_)
             {if(caml_call2(K[1],a$0,K[3]))throw [0,Assert_failure,_aZ_];
              a[1] = a$0;
              c[1] = c$0;
              u[1] = u$0;
              cu[1] = cu$0;
              var _cw_=0}
            else
             var _cw_=_cv_;
            return _cw_}
          caml_call2(AKMod[3],_cc_,p);
          var
           a$0=a[1],
           c$0=c[1],
           u$0=u[1],
           cn=caml_call1(M[16][4],c$0),
           cnl=caml_call1(M[4],cn),
           cnu=caml_call2(M[1],cn,u$0),
           cnul=caml_call1(M[4],cnu),
           ans$0=[0,-1];
          try
           {var _ci_=cnul - 1 | 0,_ch_=0;
            if(! (_ci_ < 0))
             {var i=_ch_;
              for(;;)
               {var
                 _cl_=pres[3],
                 _cm_=
                  function(i)
                    {return function(param)
                      {var
                        v=param[1],
                        vl=caml_call1(M[4],v),
                        _cs_=(i + vl | 0) <= cnul?1:0,
                        _ct_=_cs_?caml_call5(M[8],cnu,i,v,0,vl):_cs_;
                       if(_ct_){ans$0[1] = (i + vl | 0) - cnl | 0;throw Stdlib[3]}
                       return _ct_}}
                   (i);
                caml_call2(Stdlib_List[17],_cm_,_cl_);
                var _cn_=i + 1 | 0;
                if(_ci_ !== i){var i=_cn_;continue}
                break}}
            var _cj_=caml_call1(AMod[18],p);
            caml_call2(Stdlib_Printf[2],_a0_,_cj_);
            var
             leading=caml_call3(AKMod[1],a$0,c$0,u$0),
             _ck_=caml_call1(AMod[18],leading);
            caml_call2(Stdlib_Printf[2],_a1_,_ck_);
            throw [0,Assert_failure,_a2_]}
          catch(_cr_)
           {_cr_ = caml_wrap_exception(_cr_);
            if(_cr_ === Stdlib[3])
             {var
               _cd_=ans$0[1],
               u$1=caml_call3(M[5],u$0,0,_cd_),
               _ce_=caml_call1(M[4],u$0) - _cd_ | 0,
               u$2=caml_call3(M[5],u$0,_cd_,_ce_),
               c$1=[0,u$1,c$0],
               ans$1=caml_call3(AKMod[1],a$0,c$1,u$2),
               ans$2=caml_call2(AMod[19],pres,ans$1),
               _cf_=caml_check_bound(d,n)[1 + n],
               ans$3=caml_call3(AMod[20][6],pres,_cf_,ans$2),
               p$0=caml_call2(AMod[12],p,ans$3),
               p$1=caml_call2(AMod[19],pres,p$0),
               ans$4=ch(n,p$1),
               _cg_=caml_call2(AMod[10],ans$2,ans$4),
               ans$5=caml_call2(AMod[19],pres,_cg_);
              return ans$5}
            throw _cr_}}
        var _bQ_=n - 1 | 0,_bP_=1;
        if(! (_bQ_ < 1))
         {var i=_bP_;
          for(;;)
           {var
             _bT_=i + 1 | 0,
             _bU_=caml_check_bound(cc,_bT_)[1 + _bT_],
             _bV_=
              function(i)
                {return function(c)
                  {var
                    u=caml_call1(M[16][4],c),
                    c$0=caml_call1(M[16][5],c),
                    _b1_=caml_call1(include$0[5],u),
                    _b2_=caml_call1(AMod[5],c$0),
                    p=caml_call2(AMod[17],_b2_,_b1_),
                    _b3_=i - 1 | 0,
                    _b4_=caml_check_bound(d,_b3_)[1 + _b3_],
                    p$0=caml_call3(AMod[20][6],pres,_b4_,p),
                    p$1=ch(i - 1 | 0,p$0),
                    p$2=caml_call2(AMod[12],p,p$1),
                    p$3=caml_call2(AMod[19],pres,p$2),
                    _b5_=caml_check_bound(d,i)[1 + i],
                    _b6_=caml_call3(AMod[20][2],_b5_,c,p$3);
                   caml_check_bound(d,i)[1 + i] = _b6_;
                   return 0}}
               (i);
            caml_call2(Stdlib_List[17],_bV_,_bU_);
            var _bW_=i + 1 | 0;
            if(_bQ_ !== i){var i=_bW_;continue}
            break}}
        function _bR_(l)
         {var _b0_=caml_call1(Stdlib_Array[12],l);
          return caml_call1(AMod[15][1],_b0_)}
        var cc$0=caml_call2(Stdlib_Array[15],_bR_,cc);
        function _bS_(i,d)
         {var
           _bY_=i + 1 | 0,
           _bX_=caml_check_bound(cc$0,i)[1 + i],
           _bZ_=caml_check_bound(cc$0,_bY_)[1 + _bY_];
          return caml_call3(AMod[15][4][5],d,_bZ_,_bX_)}
        var d$0=caml_call2(Stdlib_Array[16],_bS_,d);
        return caml_call2(AMod[15][6][4],cc$0,d$0)}
      var
       _bG_=M[16],
       KMod=
        Free$0
         ([0,K[1],K[2],K[3],K[4],K[5],K[6],K[7]],[0,_bG_[7],_bG_[12],_bG_[8]]),
       MF=
        Functor
         ([0,
           include$0[8],
           include$0[10],
           include$0[3],
           include$0[12],
           include$0[22],
           include$0[20],
           include$0[14]],
          [0,K[1],K[2],K[3],K[4],K[5],K[6],K[7]]),
       _bH_=M[16],
       _bJ_=M[16],
       _bI_=[0,_bH_[7],_bH_[12],_bH_[8]],
       MFL=caml_call1(caml_call1(MF[4],[0,_bJ_[7],_bJ_[12],_bJ_[8]]),_bI_);
      function complex(augmentation,pres,n)
       {if(augmentation)
         var augmentation$0=augmentation[1],augmentation$1=augmentation$0;
        else
         var augmentation$1=caml_call1(Augmentation[3],pres);
        var
         r=resolution([0,augmentation$1],pres,n),
         cc=caml_call1(AMod[15][6][1],r),
         d=caml_call1(AMod[15][6][2],r);
        function id(x){return x}
        function _bK_(d)
         {function _bL_(p)
           {var p$0=normalize(pres,p);return caml_call1(augmentation$1,p$0)}
          return caml_call4(MFL[3],id,id,_bL_,d)}
        var d$0=caml_call2(Stdlib_Array[15],_bK_,d);
        return caml_call2(KMod[18][6][4],cc,d$0)}
      function betti(augmentation,pres,n)
       {var c=complex(augmentation,pres,n + 1 | 0);
        return caml_call1(KMod[18][6][7],c)}
      var Anick=[0,AMod,AKMod,chains,resolution,KMod,MF,MFL,complex,betti];
      return [0,
              M,
              include$0,
              free,
              orient,
              add_rule,
              add_relation,
              make,
              heads,
              to_string,
              normalize,
              buchberger,
              reduce,
              Algebra,
              Augmentation,
              Anick]}
    function Generate$0(K,X)
     {var Pres=Pres$5(K,X);
      function intset(n)
       {function aux(k){return n <= k?0:[0,k,aux(k + 1 | 0)]}return aux(0)}
      function braid(leq,n)
       {var generators=intset(n),relations=[0,0],_bq_=n - 2 | 0,_bp_=0;
        if(! (_bq_ < 0))
         {var i$0=_bp_;
          for(;;)
           {var
             _bA_=relations[1],
             _bB_=caml_call1(Pres[2][5],[0,i$0 + 1 | 0,i$0,i$0 + 1 | 0]),
             _bC_=caml_call1(Pres[2][5],[0,i$0,i$0 + 1 | 0,i$0]);
            relations[1] = [0,caml_call2(Pres[2][13],_bC_,_bB_),_bA_];
            var _bD_=i$0 + 1 | 0;
            if(_bq_ !== i$0){var i$0=_bD_;continue}
            break}}
        var _bs_=n - 1 | 0,_br_=0;
        if(! (_bs_ < 0))
         {var i=_br_;
          for(;;)
           {var _bt_=i + 2 | 0,_bu_=n - 1 | 0;
            if(! (_bu_ < _bt_))
             {var j=_bt_;
              for(;;)
               {var
                 _bw_=relations[1],
                 _bx_=caml_call1(Pres[2][5],[0,j,i]),
                 _by_=caml_call1(Pres[2][5],[0,i,j]);
                relations[1] = [0,caml_call2(Pres[2][13],_by_,_bx_),_bw_];
                var _bz_=j + 1 | 0;
                if(_bu_ !== j){var j=_bz_;continue}
                break}}
            var _bv_=i + 1 | 0;
            if(_bs_ !== i){var i=_bv_;continue}
            break}}
        var relations$0=caml_call1(Stdlib_List[9],relations[1]);
        return caml_call3(Pres[7],leq,generators,relations$0)}
      function symmetric(leq,n)
       {var generators=intset(n),relations=[0,0],_bh_=n - 1 | 0,_bg_=0;
        if(! (_bh_ < 0))
         {var i=_bg_;
          for(;;)
           {var _bi_=i + 1 | 0,_bj_=n - 1 | 0;
            if(! (_bj_ < _bi_))
             {var j=_bi_;
              for(;;)
               {var
                 _bl_=relations[1],
                 _bm_=caml_call1(Pres[2][5],[0,j,i]),
                 _bn_=caml_call1(Pres[2][5],[0,i,j]);
                relations[1] = [0,caml_call2(Pres[2][13],_bn_,_bm_),_bl_];
                var _bo_=j + 1 | 0;
                if(_bj_ !== j){var j=_bo_;continue}
                break}}
            var _bk_=i + 1 | 0;
            if(_bh_ !== i){var i=_bk_;continue}
            break}}
        var relations$0=caml_call1(Stdlib_List[9],relations[1]);
        return caml_call3(Pres[7],leq,generators,relations$0)}
      function exterior(leq,n)
       {var generators=intset(n),relations=[0,0],_a5_=n - 1 | 0,_a4_=0;
        if(! (_a5_ < 0))
         {var i$0=_a4_;
          for(;;)
           {var _a__=i$0 + 1 | 0,_a$_=n - 1 | 0;
            if(! (_a$_ < _a__))
             {var j=_a__;
              for(;;)
               {var
                 _bb_=relations[1],
                 _bc_=caml_call1(K[4],K[6]),
                 _bd_=caml_call2(Pres[2][4],_bc_,[0,j,i$0]),
                 _be_=caml_call1(Pres[2][5],[0,i$0,j]);
                relations[1] = [0,caml_call2(Pres[2][13],_be_,_bd_),_bb_];
                var _bf_=j + 1 | 0;
                if(_a$_ !== j){var j=_bf_;continue}
                break}}
            var _ba_=i$0 + 1 | 0;
            if(_a5_ !== i$0){var i$0=_ba_;continue}
            break}}
        var _a7_=n - 1 | 0,_a6_=0;
        if(! (_a7_ < 0))
         {var i=_a6_;
          for(;;)
           {var _a8_=relations[1];
            relations[1] = [0,caml_call1(Pres[2][5],[0,i,i]),_a8_];
            var _a9_=i + 1 | 0;
            if(_a7_ !== i){var i=_a9_;continue}
            break}}
        var relations$0=caml_call1(Stdlib_List[9],relations[1]);
        return caml_call3(Pres[7],leq,generators,relations$0)}
      return [0,Pres,intset,braid,symmetric,exterior]}
    var Alg_Algebra=[0,Free$2,FreeAlgebra,Pres$5,Generate$0];
    caml_register_global(290,Alg_Algebra,"Alg__Algebra");
    return}
  (globalThis));


//# 1 "../../.js/js_of_ocaml-compiler.runtime/jsoo_runtime.cma.js"
(function(globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_exn_with_js_backtrace=runtime.caml_exn_with_js_backtrace,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Jsoo_runtime_Error_Exn=
      caml_string_of_jsbytes("Jsoo_runtime.Error.Exn"),
     cst_jsError=caml_string_of_jsbytes("jsError"),
     Stdlib_Callback=global_data.Stdlib__Callback,
     Js=[0],
     Sys=[0],
     Exn=[248,cst_Jsoo_runtime_Error_Exn,runtime.caml_fresh_oo_id(0)];
    caml_call2(Stdlib_Callback[2],cst_jsError,[0,Exn,[0]]);
    function raise(exn){throw exn}
    var
     Error=
      [0,
       raise,
       caml_exn_with_js_backtrace,
       runtime.caml_js_error_option_of_exception,
       Exn],
     For_compatibility_only=[0],
     Bigstring=[0],
     Typed_array=[0,Bigstring],
     Int64=[0],
     Jsoo_runtime=[0,Js,Sys,Error,For_compatibility_only,Typed_array,Int64];
    runtime.caml_register_global(4,Jsoo_runtime,"Jsoo_runtime");
    return}
  (globalThis));


//# 1 "../../.js/js_of_ocaml/js_of_ocaml.cma.js"
(function(globalThis)
   {"use strict";
    var
     jsoo_exports=typeof module === "object" && module.exports || globalThis,
     runtime=globalThis.jsoo_runtime,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_js_from_array=runtime.caml_js_from_array,
     caml_js_get=runtime.caml_js_get,
     caml_js_html_escape=runtime.caml_js_html_escape,
     caml_js_set=runtime.caml_js_set,
     caml_js_wrap_callback=runtime.caml_js_wrap_callback,
     caml_js_wrap_meth_callback=runtime.caml_js_wrap_meth_callback,
     caml_jsbytes_of_string=runtime.caml_jsbytes_of_string,
     caml_jsstring_of_string=runtime.caml_jsstring_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_array=runtime.caml_string_of_array,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_parseFloat=caml_string_of_jsbytes("parseFloat"),
     cst_parseInt=caml_string_of_jsbytes("parseInt"),
     cst_can_t_retrieve_file_name_n=
      caml_string_of_jsbytes("can't retrieve file name: not implemented"),
     cst_endings=caml_string_of_jsbytes("endings"),
     cst_type=caml_string_of_jsbytes("type"),
     cst_loadstart=caml_string_of_jsbytes("loadstart"),
     cst_progress=caml_string_of_jsbytes("progress"),
     cst_abort=caml_string_of_jsbytes("abort"),
     cst_error=caml_string_of_jsbytes("error"),
     cst_load=caml_string_of_jsbytes("load"),
     cst_loadend=caml_string_of_jsbytes("loadend"),
     cst_a$1=caml_string_of_jsbytes("a"),
     cst_area$1=caml_string_of_jsbytes("area"),
     cst_audio$1=caml_string_of_jsbytes("audio"),
     cst_base$1=caml_string_of_jsbytes("base"),
     cst_blockquote$1=caml_string_of_jsbytes("blockquote"),
     cst_body$1=caml_string_of_jsbytes("body"),
     cst_br$1=caml_string_of_jsbytes("br"),
     cst_button$1=caml_string_of_jsbytes("button"),
     cst_canvas$1=caml_string_of_jsbytes("canvas"),
     cst_caption$1=caml_string_of_jsbytes("caption"),
     cst_col$1=caml_string_of_jsbytes("col"),
     cst_colgroup$1=caml_string_of_jsbytes("colgroup"),
     cst_del$1=caml_string_of_jsbytes("del"),
     cst_div$1=caml_string_of_jsbytes("div"),
     cst_dl$1=caml_string_of_jsbytes("dl"),
     cst_embed$1=caml_string_of_jsbytes("embed"),
     cst_fieldset$1=caml_string_of_jsbytes("fieldset"),
     cst_form$1=caml_string_of_jsbytes("form"),
     cst_frame$1=caml_string_of_jsbytes("frame"),
     cst_frameset$1=caml_string_of_jsbytes("frameset"),
     cst_h1$1=caml_string_of_jsbytes("h1"),
     cst_h2$1=caml_string_of_jsbytes("h2"),
     cst_h3$1=caml_string_of_jsbytes("h3"),
     cst_h4$1=caml_string_of_jsbytes("h4"),
     cst_h5$1=caml_string_of_jsbytes("h5"),
     cst_h6$1=caml_string_of_jsbytes("h6"),
     cst_head$1=caml_string_of_jsbytes("head"),
     cst_hr$1=caml_string_of_jsbytes("hr"),
     cst_html$1=caml_string_of_jsbytes("html"),
     cst_iframe$1=caml_string_of_jsbytes("iframe"),
     cst_img$1=caml_string_of_jsbytes("img"),
     cst_input$2=caml_string_of_jsbytes("input"),
     cst_ins$1=caml_string_of_jsbytes("ins"),
     cst_label$1=caml_string_of_jsbytes("label"),
     cst_legend$1=caml_string_of_jsbytes("legend"),
     cst_li$1=caml_string_of_jsbytes("li"),
     cst_link$1=caml_string_of_jsbytes("link"),
     cst_map$1=caml_string_of_jsbytes("map"),
     cst_meta$1=caml_string_of_jsbytes("meta"),
     cst_object$1=caml_string_of_jsbytes("object"),
     cst_ol$1=caml_string_of_jsbytes("ol"),
     cst_optgroup$1=caml_string_of_jsbytes("optgroup"),
     cst_option$1=caml_string_of_jsbytes("option"),
     cst_p$1=caml_string_of_jsbytes("p"),
     cst_param$1=caml_string_of_jsbytes("param"),
     cst_pre$1=caml_string_of_jsbytes("pre"),
     cst_q$1=caml_string_of_jsbytes("q"),
     cst_script$1=caml_string_of_jsbytes("script"),
     cst_select$2=caml_string_of_jsbytes("select"),
     cst_style$1=caml_string_of_jsbytes("style"),
     cst_table$1=caml_string_of_jsbytes("table"),
     cst_tbody$1=caml_string_of_jsbytes("tbody"),
     cst_td$1=caml_string_of_jsbytes("td"),
     cst_textarea$1=caml_string_of_jsbytes("textarea"),
     cst_tfoot$1=caml_string_of_jsbytes("tfoot"),
     cst_th$1=caml_string_of_jsbytes("th"),
     cst_thead$1=caml_string_of_jsbytes("thead"),
     cst_title$1=caml_string_of_jsbytes("title"),
     cst_tr$1=caml_string_of_jsbytes("tr"),
     cst_ul$1=caml_string_of_jsbytes("ul"),
     cst_video$1=caml_string_of_jsbytes("video"),
     cst_KeyH=caml_string_of_jsbytes("KeyH"),
     cst_Digit6=caml_string_of_jsbytes("Digit6"),
     cst_BrowserRefresh=caml_string_of_jsbytes("BrowserRefresh"),
     cst_Backslash=caml_string_of_jsbytes("Backslash"),
     cst_AltLeft=caml_string_of_jsbytes("AltLeft"),
     cst_AltRight=caml_string_of_jsbytes("AltRight"),
     cst_ArrowDown=caml_string_of_jsbytes("ArrowDown"),
     cst_ArrowLeft=caml_string_of_jsbytes("ArrowLeft"),
     cst_ArrowRight=caml_string_of_jsbytes("ArrowRight"),
     cst_ArrowUp=caml_string_of_jsbytes("ArrowUp"),
     cst_Backquote=caml_string_of_jsbytes("Backquote"),
     cst_Backspace=caml_string_of_jsbytes("Backspace"),
     cst_BracketLeft=caml_string_of_jsbytes("BracketLeft"),
     cst_BracketRight=caml_string_of_jsbytes("BracketRight"),
     cst_BrowserBack=caml_string_of_jsbytes("BrowserBack"),
     cst_BrowserFavorites=caml_string_of_jsbytes("BrowserFavorites"),
     cst_BrowserForward=caml_string_of_jsbytes("BrowserForward"),
     cst_BrowserHome=caml_string_of_jsbytes("BrowserHome"),
     cst_Delete=caml_string_of_jsbytes("Delete"),
     cst_BrowserSearch=caml_string_of_jsbytes("BrowserSearch"),
     cst_BrowserStop=caml_string_of_jsbytes("BrowserStop"),
     cst_CapsLock=caml_string_of_jsbytes("CapsLock"),
     cst_Comma=caml_string_of_jsbytes("Comma"),
     cst_ContextMenu=caml_string_of_jsbytes("ContextMenu"),
     cst_ControlLeft=caml_string_of_jsbytes("ControlLeft"),
     cst_ControlRight=caml_string_of_jsbytes("ControlRight"),
     cst_Digit0=caml_string_of_jsbytes("Digit0"),
     cst_Digit1=caml_string_of_jsbytes("Digit1"),
     cst_Digit2=caml_string_of_jsbytes("Digit2"),
     cst_Digit3=caml_string_of_jsbytes("Digit3"),
     cst_Digit4=caml_string_of_jsbytes("Digit4"),
     cst_Digit5=caml_string_of_jsbytes("Digit5"),
     cst_F6=caml_string_of_jsbytes("F6"),
     cst_F1=caml_string_of_jsbytes("F1"),
     cst_Digit7=caml_string_of_jsbytes("Digit7"),
     cst_Digit8=caml_string_of_jsbytes("Digit8"),
     cst_Digit9=caml_string_of_jsbytes("Digit9"),
     cst_End=caml_string_of_jsbytes("End"),
     cst_Enter=caml_string_of_jsbytes("Enter"),
     cst_Equal=caml_string_of_jsbytes("Equal"),
     cst_Escape=caml_string_of_jsbytes("Escape"),
     cst_F10=caml_string_of_jsbytes("F10"),
     cst_F11=caml_string_of_jsbytes("F11"),
     cst_F12=caml_string_of_jsbytes("F12"),
     cst_F2=caml_string_of_jsbytes("F2"),
     cst_F3=caml_string_of_jsbytes("F3"),
     cst_F4=caml_string_of_jsbytes("F4"),
     cst_F5=caml_string_of_jsbytes("F5"),
     cst_KeyA=caml_string_of_jsbytes("KeyA"),
     cst_F7=caml_string_of_jsbytes("F7"),
     cst_F8=caml_string_of_jsbytes("F8"),
     cst_F9=caml_string_of_jsbytes("F9"),
     cst_Home=caml_string_of_jsbytes("Home"),
     cst_Insert=caml_string_of_jsbytes("Insert"),
     cst_IntlBackslash=caml_string_of_jsbytes("IntlBackslash"),
     cst_IntlYen=caml_string_of_jsbytes("IntlYen"),
     cst_KeyB=caml_string_of_jsbytes("KeyB"),
     cst_KeyC=caml_string_of_jsbytes("KeyC"),
     cst_KeyD=caml_string_of_jsbytes("KeyD"),
     cst_KeyE=caml_string_of_jsbytes("KeyE"),
     cst_KeyF=caml_string_of_jsbytes("KeyF"),
     cst_KeyG=caml_string_of_jsbytes("KeyG"),
     cst_Numpad4=caml_string_of_jsbytes("Numpad4"),
     cst_KeyX=caml_string_of_jsbytes("KeyX"),
     cst_KeyP=caml_string_of_jsbytes("KeyP"),
     cst_KeyI=caml_string_of_jsbytes("KeyI"),
     cst_KeyJ=caml_string_of_jsbytes("KeyJ"),
     cst_KeyK=caml_string_of_jsbytes("KeyK"),
     cst_KeyL=caml_string_of_jsbytes("KeyL"),
     cst_KeyM=caml_string_of_jsbytes("KeyM"),
     cst_KeyN=caml_string_of_jsbytes("KeyN"),
     cst_KeyO=caml_string_of_jsbytes("KeyO"),
     cst_KeyQ=caml_string_of_jsbytes("KeyQ"),
     cst_KeyR=caml_string_of_jsbytes("KeyR"),
     cst_KeyS=caml_string_of_jsbytes("KeyS"),
     cst_KeyT=caml_string_of_jsbytes("KeyT"),
     cst_KeyU=caml_string_of_jsbytes("KeyU"),
     cst_KeyV=caml_string_of_jsbytes("KeyV"),
     cst_KeyW=caml_string_of_jsbytes("KeyW"),
     cst_MetaRight=caml_string_of_jsbytes("MetaRight"),
     cst_KeyY=caml_string_of_jsbytes("KeyY"),
     cst_KeyZ=caml_string_of_jsbytes("KeyZ"),
     cst_MediaPlayPause=caml_string_of_jsbytes("MediaPlayPause"),
     cst_MediaStop=caml_string_of_jsbytes("MediaStop"),
     cst_MediaTrackNext=caml_string_of_jsbytes("MediaTrackNext"),
     cst_MediaTrackPrevious=caml_string_of_jsbytes("MediaTrackPrevious"),
     cst_MetaLeft=caml_string_of_jsbytes("MetaLeft"),
     cst_Minus=caml_string_of_jsbytes("Minus"),
     cst_NumLock=caml_string_of_jsbytes("NumLock"),
     cst_Numpad0=caml_string_of_jsbytes("Numpad0"),
     cst_Numpad1=caml_string_of_jsbytes("Numpad1"),
     cst_Numpad2=caml_string_of_jsbytes("Numpad2"),
     cst_Numpad3=caml_string_of_jsbytes("Numpad3"),
     cst_PageUp=caml_string_of_jsbytes("PageUp"),
     cst_NumpadDivide=caml_string_of_jsbytes("NumpadDivide"),
     cst_Numpad5=caml_string_of_jsbytes("Numpad5"),
     cst_Numpad6=caml_string_of_jsbytes("Numpad6"),
     cst_Numpad7=caml_string_of_jsbytes("Numpad7"),
     cst_Numpad8=caml_string_of_jsbytes("Numpad8"),
     cst_Numpad9=caml_string_of_jsbytes("Numpad9"),
     cst_NumpadAdd=caml_string_of_jsbytes("NumpadAdd"),
     cst_NumpadDecimal=caml_string_of_jsbytes("NumpadDecimal"),
     cst_NumpadEnter=caml_string_of_jsbytes("NumpadEnter"),
     cst_NumpadEqual=caml_string_of_jsbytes("NumpadEqual"),
     cst_NumpadMultiply=caml_string_of_jsbytes("NumpadMultiply"),
     cst_NumpadSubtract=caml_string_of_jsbytes("NumpadSubtract"),
     cst_OSLeft=caml_string_of_jsbytes("OSLeft"),
     cst_OSRight=caml_string_of_jsbytes("OSRight"),
     cst_PageDown=caml_string_of_jsbytes("PageDown"),
     cst_ShiftRight=caml_string_of_jsbytes("ShiftRight"),
     cst_Pause=caml_string_of_jsbytes("Pause"),
     cst_Period=caml_string_of_jsbytes("Period"),
     cst_PrintScreen=caml_string_of_jsbytes("PrintScreen"),
     cst_Quote=caml_string_of_jsbytes("Quote"),
     cst_ScrollLock=caml_string_of_jsbytes("ScrollLock"),
     cst_Semicolon=caml_string_of_jsbytes("Semicolon"),
     cst_ShiftLeft=caml_string_of_jsbytes("ShiftLeft"),
     cst_Slash=caml_string_of_jsbytes("Slash"),
     cst_Space=caml_string_of_jsbytes("Space"),
     cst_Tab=caml_string_of_jsbytes("Tab"),
     cst_VolumeDown=caml_string_of_jsbytes("VolumeDown"),
     cst_VolumeMute=caml_string_of_jsbytes("VolumeMute"),
     cst_VolumeUp=caml_string_of_jsbytes("VolumeUp"),
     cst_mouseout$0=caml_string_of_jsbytes("mouseout"),
     cst_mouseover$0=caml_string_of_jsbytes("mouseover"),
     cst_video$0=caml_string_of_jsbytes("video"),
     cst_audio$0=caml_string_of_jsbytes("audio"),
     cst_ul$0=caml_string_of_jsbytes("ul"),
     cst_tr$0=caml_string_of_jsbytes("tr"),
     cst_title$0=caml_string_of_jsbytes("title"),
     cst_thead$0=caml_string_of_jsbytes("thead"),
     cst_th$0=caml_string_of_jsbytes("th"),
     cst_tfoot$0=caml_string_of_jsbytes("tfoot"),
     cst_textarea$0=caml_string_of_jsbytes("textarea"),
     cst_td$0=caml_string_of_jsbytes("td"),
     cst_tbody$0=caml_string_of_jsbytes("tbody"),
     cst_table$0=caml_string_of_jsbytes("table"),
     cst_style$0=caml_string_of_jsbytes("style"),
     cst_select$1=caml_string_of_jsbytes("select"),
     cst_script$0=caml_string_of_jsbytes("script"),
     cst_q$0=caml_string_of_jsbytes("q"),
     cst_pre$0=caml_string_of_jsbytes("pre"),
     cst_param$0=caml_string_of_jsbytes("param"),
     cst_p$0=caml_string_of_jsbytes("p"),
     cst_option$0=caml_string_of_jsbytes("option"),
     cst_optgroup$0=caml_string_of_jsbytes("optgroup"),
     cst_ol$0=caml_string_of_jsbytes("ol"),
     cst_object$0=caml_string_of_jsbytes("object"),
     cst_meta$0=caml_string_of_jsbytes("meta"),
     cst_map$0=caml_string_of_jsbytes("map"),
     cst_link$0=caml_string_of_jsbytes("link"),
     cst_li$0=caml_string_of_jsbytes("li"),
     cst_legend$0=caml_string_of_jsbytes("legend"),
     cst_label$0=caml_string_of_jsbytes("label"),
     cst_ins$0=caml_string_of_jsbytes("ins"),
     cst_input$1=caml_string_of_jsbytes("input"),
     cst_img$0=caml_string_of_jsbytes("img"),
     cst_iframe$0=caml_string_of_jsbytes("iframe"),
     cst_html$0=caml_string_of_jsbytes("html"),
     cst_hr$0=caml_string_of_jsbytes("hr"),
     cst_head$0=caml_string_of_jsbytes("head"),
     cst_h6$0=caml_string_of_jsbytes("h6"),
     cst_h5$0=caml_string_of_jsbytes("h5"),
     cst_h4$0=caml_string_of_jsbytes("h4"),
     cst_h3$0=caml_string_of_jsbytes("h3"),
     cst_h2$0=caml_string_of_jsbytes("h2"),
     cst_h1$0=caml_string_of_jsbytes("h1"),
     cst_frame$0=caml_string_of_jsbytes("frame"),
     cst_frameset$0=caml_string_of_jsbytes("frameset"),
     cst_form$0=caml_string_of_jsbytes("form"),
     cst_embed$0=caml_string_of_jsbytes("embed"),
     cst_fieldset$0=caml_string_of_jsbytes("fieldset"),
     cst_dl$0=caml_string_of_jsbytes("dl"),
     cst_div$0=caml_string_of_jsbytes("div"),
     cst_del$0=caml_string_of_jsbytes("del"),
     cst_colgroup$0=caml_string_of_jsbytes("colgroup"),
     cst_col$0=caml_string_of_jsbytes("col"),
     cst_caption$0=caml_string_of_jsbytes("caption"),
     cst_canvas$0=caml_string_of_jsbytes("canvas"),
     cst_button$0=caml_string_of_jsbytes("button"),
     cst_br$0=caml_string_of_jsbytes("br"),
     cst_body$0=caml_string_of_jsbytes("body"),
     cst_blockquote$0=caml_string_of_jsbytes("blockquote"),
     cst_base$0=caml_string_of_jsbytes("base"),
     cst_area$0=caml_string_of_jsbytes("area"),
     cst_a$0=caml_string_of_jsbytes("a"),
     cst_canvas=caml_string_of_jsbytes("canvas"),
     cst_video=caml_string_of_jsbytes("video"),
     cst_audio=caml_string_of_jsbytes("audio"),
     cst_iframe=caml_string_of_jsbytes("iframe"),
     cst_frame=caml_string_of_jsbytes("frame"),
     cst_frameset=caml_string_of_jsbytes("frameset"),
     cst_address=caml_string_of_jsbytes("address"),
     cst_noscript=caml_string_of_jsbytes("noscript"),
     cst_dt=caml_string_of_jsbytes("dt"),
     cst_dd=caml_string_of_jsbytes("dd"),
     cst_abbr=caml_string_of_jsbytes("abbr"),
     cst_var=caml_string_of_jsbytes("var"),
     cst_kbd=caml_string_of_jsbytes("kbd"),
     cst_samp=caml_string_of_jsbytes("samp"),
     cst_code=caml_string_of_jsbytes("code"),
     cst_dfn=caml_string_of_jsbytes("dfn"),
     cst_cite=caml_string_of_jsbytes("cite"),
     cst_strong=caml_string_of_jsbytes("strong"),
     cst_em=caml_string_of_jsbytes("em"),
     cst_small=caml_string_of_jsbytes("small"),
     cst_big=caml_string_of_jsbytes("big"),
     cst_b=caml_string_of_jsbytes("b"),
     cst_i=caml_string_of_jsbytes("i"),
     cst_tt=caml_string_of_jsbytes("tt"),
     cst_span=caml_string_of_jsbytes("span"),
     cst_sup=caml_string_of_jsbytes("sup"),
     cst_sub=caml_string_of_jsbytes("sub"),
     cst_td=caml_string_of_jsbytes("td"),
     cst_th=caml_string_of_jsbytes("th"),
     cst_tr=caml_string_of_jsbytes("tr"),
     cst_tbody=caml_string_of_jsbytes("tbody"),
     cst_tfoot=caml_string_of_jsbytes("tfoot"),
     cst_thead=caml_string_of_jsbytes("thead"),
     cst_colgroup=caml_string_of_jsbytes("colgroup"),
     cst_col=caml_string_of_jsbytes("col"),
     cst_caption=caml_string_of_jsbytes("caption"),
     cst_table=caml_string_of_jsbytes("table"),
     cst_script=caml_string_of_jsbytes("script"),
     cst_area=caml_string_of_jsbytes("area"),
     cst_map=caml_string_of_jsbytes("map"),
     cst_param=caml_string_of_jsbytes("param"),
     cst_object=caml_string_of_jsbytes("object"),
     cst_img=caml_string_of_jsbytes("img"),
     cst_a=caml_string_of_jsbytes("a"),
     cst_del=caml_string_of_jsbytes("del"),
     cst_ins=caml_string_of_jsbytes("ins"),
     cst_hr=caml_string_of_jsbytes("hr"),
     cst_br=caml_string_of_jsbytes("br"),
     cst_pre=caml_string_of_jsbytes("pre"),
     cst_blockquote=caml_string_of_jsbytes("blockquote"),
     cst_q=caml_string_of_jsbytes("q"),
     cst_h6=caml_string_of_jsbytes("h6"),
     cst_h5=caml_string_of_jsbytes("h5"),
     cst_h4=caml_string_of_jsbytes("h4"),
     cst_h3=caml_string_of_jsbytes("h3"),
     cst_h2=caml_string_of_jsbytes("h2"),
     cst_h1=caml_string_of_jsbytes("h1"),
     cst_p=caml_string_of_jsbytes("p"),
     cst_embed=caml_string_of_jsbytes("embed"),
     cst_div=caml_string_of_jsbytes("div"),
     cst_li=caml_string_of_jsbytes("li"),
     cst_dl=caml_string_of_jsbytes("dl"),
     cst_ol=caml_string_of_jsbytes("ol"),
     cst_ul=caml_string_of_jsbytes("ul"),
     cst_legend=caml_string_of_jsbytes("legend"),
     cst_fieldset=caml_string_of_jsbytes("fieldset"),
     cst_label=caml_string_of_jsbytes("label"),
     cst_button=caml_string_of_jsbytes("button"),
     cst_textarea=caml_string_of_jsbytes("textarea"),
     cst_input$0=caml_string_of_jsbytes("input"),
     cst_select$0=caml_string_of_jsbytes("select"),
     cst_option=caml_string_of_jsbytes("option"),
     cst_optgroup=caml_string_of_jsbytes("optgroup"),
     cst_form=caml_string_of_jsbytes("form"),
     cst_body=caml_string_of_jsbytes("body"),
     cst_style=caml_string_of_jsbytes("style"),
     cst_base=caml_string_of_jsbytes("base"),
     cst_meta=caml_string_of_jsbytes("meta"),
     cst_title=caml_string_of_jsbytes("title"),
     cst_link=caml_string_of_jsbytes("link"),
     cst_head=caml_string_of_jsbytes("head"),
     cst_html=caml_string_of_jsbytes("html"),
     cst_click=caml_string_of_jsbytes("click"),
     cst_copy=caml_string_of_jsbytes("copy"),
     cst_cut=caml_string_of_jsbytes("cut"),
     cst_paste=caml_string_of_jsbytes("paste"),
     cst_dblclick=caml_string_of_jsbytes("dblclick"),
     cst_mousedown=caml_string_of_jsbytes("mousedown"),
     cst_mouseup=caml_string_of_jsbytes("mouseup"),
     cst_mouseover=caml_string_of_jsbytes("mouseover"),
     cst_mousemove=caml_string_of_jsbytes("mousemove"),
     cst_mouseout=caml_string_of_jsbytes("mouseout"),
     cst_keypress=caml_string_of_jsbytes("keypress"),
     cst_keydown=caml_string_of_jsbytes("keydown"),
     cst_keyup=caml_string_of_jsbytes("keyup"),
     cst_mousewheel=caml_string_of_jsbytes("mousewheel"),
     cst_DOMMouseScroll=caml_string_of_jsbytes("DOMMouseScroll"),
     cst_touchstart=caml_string_of_jsbytes("touchstart"),
     cst_touchmove=caml_string_of_jsbytes("touchmove"),
     cst_touchend=caml_string_of_jsbytes("touchend"),
     cst_touchcancel=caml_string_of_jsbytes("touchcancel"),
     cst_dragstart=caml_string_of_jsbytes("dragstart"),
     cst_dragend=caml_string_of_jsbytes("dragend"),
     cst_dragenter=caml_string_of_jsbytes("dragenter"),
     cst_dragover=caml_string_of_jsbytes("dragover"),
     cst_dragleave=caml_string_of_jsbytes("dragleave"),
     cst_drag=caml_string_of_jsbytes("drag"),
     cst_drop=caml_string_of_jsbytes("drop"),
     cst_hashchange=caml_string_of_jsbytes("hashchange"),
     cst_change=caml_string_of_jsbytes("change"),
     cst_input=caml_string_of_jsbytes("input"),
     cst_timeupdate=caml_string_of_jsbytes("timeupdate"),
     cst_submit=caml_string_of_jsbytes("submit"),
     cst_scroll=caml_string_of_jsbytes("scroll"),
     cst_focus=caml_string_of_jsbytes("focus"),
     cst_blur=caml_string_of_jsbytes("blur"),
     cst_load$0=caml_string_of_jsbytes("load"),
     cst_unload=caml_string_of_jsbytes("unload"),
     cst_beforeunload=caml_string_of_jsbytes("beforeunload"),
     cst_resize=caml_string_of_jsbytes("resize"),
     cst_orientationchange=caml_string_of_jsbytes("orientationchange"),
     cst_popstate=caml_string_of_jsbytes("popstate"),
     cst_error$0=caml_string_of_jsbytes("error"),
     cst_abort$0=caml_string_of_jsbytes("abort"),
     cst_select=caml_string_of_jsbytes("select"),
     cst_online=caml_string_of_jsbytes("online"),
     cst_offline=caml_string_of_jsbytes("offline"),
     cst_checking=caml_string_of_jsbytes("checking"),
     cst_noupdate=caml_string_of_jsbytes("noupdate"),
     cst_downloading=caml_string_of_jsbytes("downloading"),
     cst_progress$0=caml_string_of_jsbytes("progress"),
     cst_updateready=caml_string_of_jsbytes("updateready"),
     cst_cached=caml_string_of_jsbytes("cached"),
     cst_obsolete=caml_string_of_jsbytes("obsolete"),
     cst_DOMContentLoaded=caml_string_of_jsbytes("DOMContentLoaded"),
     cst_animationstart=caml_string_of_jsbytes("animationstart"),
     cst_animationend=caml_string_of_jsbytes("animationend"),
     cst_animationiteration=caml_string_of_jsbytes("animationiteration"),
     cst_animationcancel=caml_string_of_jsbytes("animationcancel"),
     cst_canplay=caml_string_of_jsbytes("canplay"),
     cst_canplaythrough=caml_string_of_jsbytes("canplaythrough"),
     cst_durationchange=caml_string_of_jsbytes("durationchange"),
     cst_emptied=caml_string_of_jsbytes("emptied"),
     cst_ended=caml_string_of_jsbytes("ended"),
     cst_gotpointercapture=caml_string_of_jsbytes("gotpointercapture"),
     cst_loadeddata=caml_string_of_jsbytes("loadeddata"),
     cst_loadedmetadata=caml_string_of_jsbytes("loadedmetadata"),
     cst_loadstart$0=caml_string_of_jsbytes("loadstart"),
     cst_lostpointercapture=caml_string_of_jsbytes("lostpointercapture"),
     cst_message=caml_string_of_jsbytes("message"),
     cst_pause=caml_string_of_jsbytes("pause"),
     cst_play=caml_string_of_jsbytes("play"),
     cst_playing=caml_string_of_jsbytes("playing"),
     cst_pointerenter=caml_string_of_jsbytes("pointerenter"),
     cst_pointercancel=caml_string_of_jsbytes("pointercancel"),
     cst_pointerdown=caml_string_of_jsbytes("pointerdown"),
     cst_pointerleave=caml_string_of_jsbytes("pointerleave"),
     cst_pointermove=caml_string_of_jsbytes("pointermove"),
     cst_pointerout=caml_string_of_jsbytes("pointerout"),
     cst_pointerover=caml_string_of_jsbytes("pointerover"),
     cst_pointerup=caml_string_of_jsbytes("pointerup"),
     cst_ratechange=caml_string_of_jsbytes("ratechange"),
     cst_seeked=caml_string_of_jsbytes("seeked"),
     cst_seeking=caml_string_of_jsbytes("seeking"),
     cst_stalled=caml_string_of_jsbytes("stalled"),
     cst_suspend=caml_string_of_jsbytes("suspend"),
     cst_volumechange=caml_string_of_jsbytes("volumechange"),
     cst_waiting=caml_string_of_jsbytes("waiting"),
     cst_Js_of_ocaml_Dom_html_Canva=
      caml_string_of_jsbytes("Js_of_ocaml__Dom_html.Canvas_not_available"),
     cst_checkbox=caml_string_of_jsbytes("checkbox"),
     cst_file=caml_string_of_jsbytes("file"),
     cst_password=caml_string_of_jsbytes("password"),
     cst_radio=caml_string_of_jsbytes("radio"),
     cst_reset=caml_string_of_jsbytes("reset"),
     cst_submit$0=caml_string_of_jsbytes("submit"),
     cst_text=caml_string_of_jsbytes("text"),
     cst_readystatechange=caml_string_of_jsbytes("readystatechange"),
     cst_loadstart$1=caml_string_of_jsbytes("loadstart"),
     cst_progress$1=caml_string_of_jsbytes("progress"),
     cst_abort$1=caml_string_of_jsbytes("abort"),
     cst_error$1=caml_string_of_jsbytes("error"),
     cst_load$1=caml_string_of_jsbytes("load"),
     cst_timeout=caml_string_of_jsbytes("timeout"),
     cst_loadend$0=caml_string_of_jsbytes("loadend"),
     cst_Worker_onmessage_is_undefi$0=
      caml_string_of_jsbytes("Worker.onmessage is undefined"),
     cst_Worker_onmessage_is_undefi=
      caml_string_of_jsbytes("Worker.onmessage is undefined"),
     cst_Worker_import_scripts_is_u=
      caml_string_of_jsbytes("Worker.import_scripts is undefined"),
     cst_webglcontextlost=caml_string_of_jsbytes("webglcontextlost"),
     cst_webglcontextrestored=caml_string_of_jsbytes("webglcontextrestored"),
     cst_webglcontextcreationerror=
      caml_string_of_jsbytes("webglcontextcreationerror"),
     cst_g=caml_string_of_jsbytes("g"),
     cst=caml_string_of_jsbytes("[\\][()\\\\|+*.?{}^$]"),
     cst$37=caml_string_of_jsbytes(""),
     cst$13=caml_string_of_jsbytes(""),
     cst$21=caml_string_of_jsbytes(""),
     cst$14=caml_string_of_jsbytes("#"),
     cst$15=caml_string_of_jsbytes("?"),
     cst$20=caml_string_of_jsbytes(""),
     cst$16=caml_string_of_jsbytes("/"),
     cst$17=caml_string_of_jsbytes("/"),
     cst$19=caml_string_of_jsbytes(":"),
     cst$18=caml_string_of_jsbytes(""),
     cst_http$1=caml_string_of_jsbytes("http://"),
     cst$22=caml_string_of_jsbytes(""),
     cst$30=caml_string_of_jsbytes(""),
     cst$23=caml_string_of_jsbytes("#"),
     cst$24=caml_string_of_jsbytes("?"),
     cst$29=caml_string_of_jsbytes(""),
     cst$25=caml_string_of_jsbytes("/"),
     cst$26=caml_string_of_jsbytes("/"),
     cst$28=caml_string_of_jsbytes(":"),
     cst$27=caml_string_of_jsbytes(""),
     cst_https$1=caml_string_of_jsbytes("https://"),
     cst$31=caml_string_of_jsbytes(""),
     cst$36=caml_string_of_jsbytes(""),
     cst$32=caml_string_of_jsbytes("#"),
     cst$33=caml_string_of_jsbytes("?"),
     cst$35=caml_string_of_jsbytes(""),
     cst$34=caml_string_of_jsbytes("/"),
     cst_file$2=caml_string_of_jsbytes("file://"),
     cst$12=caml_string_of_jsbytes(""),
     cst$11=caml_string_of_jsbytes(""),
     cst$10=caml_string_of_jsbytes(""),
     cst$9=caml_string_of_jsbytes(""),
     cst$8=caml_string_of_jsbytes(""),
     cst$7=caml_string_of_jsbytes(""),
     cst$6=caml_string_of_jsbytes(""),
     cst$4=caml_string_of_jsbytes("="),
     cst$5=caml_string_of_jsbytes("&"),
     cst$2=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_file$0=caml_string_of_jsbytes("file"),
     cst_file$1=caml_string_of_jsbytes("file:"),
     cst_http=caml_string_of_jsbytes("http"),
     cst_http$0=caml_string_of_jsbytes("http:"),
     cst_https=caml_string_of_jsbytes("https"),
     cst_https$0=caml_string_of_jsbytes("https:"),
     cst$1=caml_string_of_jsbytes(" "),
     cst_2B=caml_string_of_jsbytes("%2B"),
     cst_Js_of_ocaml_Url_Local_exn=
      caml_string_of_jsbytes("Js_of_ocaml__Url.Local_exn"),
     cst$0=caml_string_of_jsbytes("+"),
     cst_Js_of_ocaml_Url_Not_an_htt=
      caml_string_of_jsbytes("Js_of_ocaml__Url.Not_an_http_protocol"),
     cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0=
      caml_string_of_jsbytes
       ("^([Hh][Tt][Tt][Pp][Ss]?)://([0-9a-zA-Z.-]+|\\[[0-9a-zA-Z.-]+\\]|\\[[0-9A-Fa-f:.]+\\])?(:([0-9]+))?(/([^\\?#]*)(\\?([^#]*))?(#(.*))?)?$"),
     cst_Ff_Ii_Ll_Ee=
      caml_string_of_jsbytes
       ("^([Ff][Ii][Ll][Ee])://([^\\?#]*)(\\?([^#]*))?(#(.*))?$"),
     s=caml_string_of_jsbytes("4.0.0"),
     git_version=caml_string_of_jsbytes(""),
     cst$38=caml_string_of_jsbytes(""),
     cst$41=caml_string_of_jsbytes("+"),
     cst_Jstable_keys=caml_string_of_jsbytes("Jstable.keys"),
     t5=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     cst_is_not_a_valid_length$0=
      caml_string_of_jsbytes(" is not a valid length"),
     cst_d_d_deg_grad_rad_turns=
      caml_string_of_jsbytes("^(\\d*(?:\\.\\d*))(deg|grad|rad|turns)$"),
     cst_length_conversion_error$0=
      caml_string_of_jsbytes("length conversion error: "),
     cst_deg$0=caml_string_of_jsbytes("deg"),
     cst_grad$0=caml_string_of_jsbytes("grad"),
     cst_rad$0=caml_string_of_jsbytes("rad"),
     cst_turns$0=caml_string_of_jsbytes("turns"),
     cst_deg=caml_string_of_jsbytes("deg"),
     cst_grad=caml_string_of_jsbytes("grad"),
     cst_rad=caml_string_of_jsbytes("rad"),
     cst_turns=caml_string_of_jsbytes("turns"),
     cst_is_not_a_valid_length=
      caml_string_of_jsbytes(" is not a valid length"),
     cst_0$0=caml_string_of_jsbytes("0"),
     cst_d_d_s_S=caml_string_of_jsbytes("^(\\d*(?:\\.\\d*)?)\\s*(\\S*)$"),
     cst_length_conversion_error=
      caml_string_of_jsbytes("length conversion error: "),
     cst_pc$0=caml_string_of_jsbytes("pc"),
     cst_ch$0=caml_string_of_jsbytes("ch"),
     cst_cm$0=caml_string_of_jsbytes("cm"),
     cst_em$1=caml_string_of_jsbytes("em"),
     cst_ex$0=caml_string_of_jsbytes("ex"),
     cst_gd$0=caml_string_of_jsbytes("gd"),
     cst_in$0=caml_string_of_jsbytes("in"),
     cst_mm$0=caml_string_of_jsbytes("mm"),
     cst_pt$0=caml_string_of_jsbytes("pt"),
     cst_px$0=caml_string_of_jsbytes("px"),
     cst_rem$0=caml_string_of_jsbytes("rem"),
     cst_vh$0=caml_string_of_jsbytes("vh"),
     cst_vm$0=caml_string_of_jsbytes("vm"),
     cst_vw$0=caml_string_of_jsbytes("vw"),
     cst_0=caml_string_of_jsbytes("0"),
     cst_em$0=caml_string_of_jsbytes("em"),
     cst_ex=caml_string_of_jsbytes("ex"),
     cst_px=caml_string_of_jsbytes("px"),
     cst_gd=caml_string_of_jsbytes("gd"),
     cst_rem=caml_string_of_jsbytes("rem"),
     cst_vw=caml_string_of_jsbytes("vw"),
     cst_vh=caml_string_of_jsbytes("vh"),
     cst_vm=caml_string_of_jsbytes("vm"),
     cst_ch=caml_string_of_jsbytes("ch"),
     cst_mm=caml_string_of_jsbytes("mm"),
     cst_cm=caml_string_of_jsbytes("cm"),
     cst_in=caml_string_of_jsbytes("in"),
     cst_pt=caml_string_of_jsbytes("pt"),
     cst_pc=caml_string_of_jsbytes("pc"),
     cst$40=caml_string_of_jsbytes("): "),
     cst_color_conversion_error$0=
      caml_string_of_jsbytes("color conversion error ("),
     cst$39=caml_string_of_jsbytes("): "),
     cst_color_conversion_error=
      caml_string_of_jsbytes("color conversion error ("),
     cst_is_not_a_valid_color$0=
      caml_string_of_jsbytes(" is not a valid color"),
     cst_rgba_d_d_d_d_d=
      caml_string_of_jsbytes
       ("(rgba?)\\((?:(\\d*),(\\d*),(\\d*)(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgba_d_d_d_d_d$0=
      caml_string_of_jsbytes
       ("(rgba?)\\((?:(\\d*)%,(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_hsla_d_d_d_d_d=
      caml_string_of_jsbytes
       ("(hsla?)\\((?:(\\d*),(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgb=caml_string_of_jsbytes("rgb"),
     cst_rgba=caml_string_of_jsbytes("rgba"),
     cst_rgb$0=caml_string_of_jsbytes("rgb"),
     cst_rgba$0=caml_string_of_jsbytes("rgba"),
     cst_hsl=caml_string_of_jsbytes("hsl"),
     cst_hsla=caml_string_of_jsbytes("hsla"),
     cst_rgb_s_d_s_d_s_d=
      caml_string_of_jsbytes("^rgb\\(\\s*\\d*,\\s*\\d*,\\s*\\d*\\)$"),
     cst_rgb_s_d_s_d_s_d$0=
      caml_string_of_jsbytes("^rgb\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d=
      caml_string_of_jsbytes
       ("^rgba\\(\\s*\\d*,\\s*\\d*,\\s*\\d*,\\d*\\.?\\d*\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d$0=
      caml_string_of_jsbytes
       ("^rgba\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_hsl_s_d_s_d_s_d=
      caml_string_of_jsbytes("^hsl\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_hsla_s_d_s_d_s_d_d_d=
      caml_string_of_jsbytes
       ("^hsla\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_is_not_a_valid_color=caml_string_of_jsbytes(" is not a valid color"),
     cst_is_out_of_valid_range=
      caml_string_of_jsbytes(" is out of valid range"),
     partial=[8,[0,0,0],0,0,[12,41,0]],
     partial$0=[12,41,0],
     partial$1=[0,0,0],
     cst_lightgrey$0=caml_string_of_jsbytes("lightgrey"),
     cst_darkslategray$0=caml_string_of_jsbytes("darkslategray"),
     cst_cornsilk$0=caml_string_of_jsbytes("cornsilk"),
     cst_blue$0=caml_string_of_jsbytes("blue"),
     cst_aliceblue$0=caml_string_of_jsbytes("aliceblue"),
     cst_antiquewhite$0=caml_string_of_jsbytes("antiquewhite"),
     cst_aqua$0=caml_string_of_jsbytes("aqua"),
     cst_aquamarine$0=caml_string_of_jsbytes("aquamarine"),
     cst_azure$0=caml_string_of_jsbytes("azure"),
     cst_beige$0=caml_string_of_jsbytes("beige"),
     cst_bisque$0=caml_string_of_jsbytes("bisque"),
     cst_black$0=caml_string_of_jsbytes("black"),
     cst_blanchedalmond$0=caml_string_of_jsbytes("blanchedalmond"),
     cst_blueviolet$0=caml_string_of_jsbytes("blueviolet"),
     cst_brown$0=caml_string_of_jsbytes("brown"),
     cst_burlywood$0=caml_string_of_jsbytes("burlywood"),
     cst_cadetblue$0=caml_string_of_jsbytes("cadetblue"),
     cst_chartreuse$0=caml_string_of_jsbytes("chartreuse"),
     cst_chocolate$0=caml_string_of_jsbytes("chocolate"),
     cst_coral$0=caml_string_of_jsbytes("coral"),
     cst_cornflowerblue$0=caml_string_of_jsbytes("cornflowerblue"),
     cst_darkkhaki$0=caml_string_of_jsbytes("darkkhaki"),
     cst_crimson$0=caml_string_of_jsbytes("crimson"),
     cst_cyan$0=caml_string_of_jsbytes("cyan"),
     cst_darkblue$0=caml_string_of_jsbytes("darkblue"),
     cst_darkcyan$0=caml_string_of_jsbytes("darkcyan"),
     cst_darkgoldenrod$0=caml_string_of_jsbytes("darkgoldenrod"),
     cst_darkgray$0=caml_string_of_jsbytes("darkgray"),
     cst_darkgreen$0=caml_string_of_jsbytes("darkgreen"),
     cst_darkgrey$0=caml_string_of_jsbytes("darkgrey"),
     cst_darkmagenta$0=caml_string_of_jsbytes("darkmagenta"),
     cst_darkolivegreen$0=caml_string_of_jsbytes("darkolivegreen"),
     cst_darkorange$0=caml_string_of_jsbytes("darkorange"),
     cst_darkorchid$0=caml_string_of_jsbytes("darkorchid"),
     cst_darkred$0=caml_string_of_jsbytes("darkred"),
     cst_darksalmon$0=caml_string_of_jsbytes("darksalmon"),
     cst_darkseagreen$0=caml_string_of_jsbytes("darkseagreen"),
     cst_darkslateblue$0=caml_string_of_jsbytes("darkslateblue"),
     cst_greenyellow$0=caml_string_of_jsbytes("greenyellow"),
     cst_floralwhite$0=caml_string_of_jsbytes("floralwhite"),
     cst_darkslategrey$0=caml_string_of_jsbytes("darkslategrey"),
     cst_darkturquoise$0=caml_string_of_jsbytes("darkturquoise"),
     cst_darkviolet$0=caml_string_of_jsbytes("darkviolet"),
     cst_deeppink$0=caml_string_of_jsbytes("deeppink"),
     cst_deepskyblue$0=caml_string_of_jsbytes("deepskyblue"),
     cst_dimgray$0=caml_string_of_jsbytes("dimgray"),
     cst_dimgrey$0=caml_string_of_jsbytes("dimgrey"),
     cst_dodgerblue$0=caml_string_of_jsbytes("dodgerblue"),
     cst_firebrick$0=caml_string_of_jsbytes("firebrick"),
     cst_forestgreen$0=caml_string_of_jsbytes("forestgreen"),
     cst_fuchsia$0=caml_string_of_jsbytes("fuchsia"),
     cst_gainsboro$0=caml_string_of_jsbytes("gainsboro"),
     cst_ghostwhite$0=caml_string_of_jsbytes("ghostwhite"),
     cst_gold$0=caml_string_of_jsbytes("gold"),
     cst_goldenrod$0=caml_string_of_jsbytes("goldenrod"),
     cst_gray$0=caml_string_of_jsbytes("gray"),
     cst_green$0=caml_string_of_jsbytes("green"),
     cst_lavenderblush$0=caml_string_of_jsbytes("lavenderblush"),
     cst_grey$0=caml_string_of_jsbytes("grey"),
     cst_honeydew$0=caml_string_of_jsbytes("honeydew"),
     cst_hotpink$0=caml_string_of_jsbytes("hotpink"),
     cst_indianred$0=caml_string_of_jsbytes("indianred"),
     cst_indigo$0=caml_string_of_jsbytes("indigo"),
     cst_ivory$0=caml_string_of_jsbytes("ivory"),
     cst_khaki$0=caml_string_of_jsbytes("khaki"),
     cst_lavender$0=caml_string_of_jsbytes("lavender"),
     cst_lawngreen$0=caml_string_of_jsbytes("lawngreen"),
     cst_lemonchiffon$0=caml_string_of_jsbytes("lemonchiffon"),
     cst_lightblue$0=caml_string_of_jsbytes("lightblue"),
     cst_lightcoral$0=caml_string_of_jsbytes("lightcoral"),
     cst_lightcyan$0=caml_string_of_jsbytes("lightcyan"),
     cst_lightgoldenrodyellow$0=caml_string_of_jsbytes("lightgoldenrodyellow"),
     cst_lightgray$0=caml_string_of_jsbytes("lightgray"),
     cst_lightgreen$0=caml_string_of_jsbytes("lightgreen"),
     cst_paleturquoise$0=caml_string_of_jsbytes("paleturquoise"),
     cst_mediumslateblue$0=caml_string_of_jsbytes("mediumslateblue"),
     cst_limegreen$0=caml_string_of_jsbytes("limegreen"),
     cst_lightpink$0=caml_string_of_jsbytes("lightpink"),
     cst_lightsalmon$0=caml_string_of_jsbytes("lightsalmon"),
     cst_lightseagreen$0=caml_string_of_jsbytes("lightseagreen"),
     cst_lightskyblue$0=caml_string_of_jsbytes("lightskyblue"),
     cst_lightslategray$0=caml_string_of_jsbytes("lightslategray"),
     cst_lightslategrey$0=caml_string_of_jsbytes("lightslategrey"),
     cst_lightsteelblue$0=caml_string_of_jsbytes("lightsteelblue"),
     cst_lightyellow$0=caml_string_of_jsbytes("lightyellow"),
     cst_lime$0=caml_string_of_jsbytes("lime"),
     cst_linen$0=caml_string_of_jsbytes("linen"),
     cst_magenta$0=caml_string_of_jsbytes("magenta"),
     cst_maroon$0=caml_string_of_jsbytes("maroon"),
     cst_mediumaquamarine$0=caml_string_of_jsbytes("mediumaquamarine"),
     cst_mediumblue$0=caml_string_of_jsbytes("mediumblue"),
     cst_mediumorchid$0=caml_string_of_jsbytes("mediumorchid"),
     cst_mediumpurple$0=caml_string_of_jsbytes("mediumpurple"),
     cst_mediumseagreen$0=caml_string_of_jsbytes("mediumseagreen"),
     cst_navy$0=caml_string_of_jsbytes("navy"),
     cst_mediumspringgreen$0=caml_string_of_jsbytes("mediumspringgreen"),
     cst_mediumturquoise$0=caml_string_of_jsbytes("mediumturquoise"),
     cst_mediumvioletred$0=caml_string_of_jsbytes("mediumvioletred"),
     cst_midnightblue$0=caml_string_of_jsbytes("midnightblue"),
     cst_mintcream$0=caml_string_of_jsbytes("mintcream"),
     cst_mistyrose$0=caml_string_of_jsbytes("mistyrose"),
     cst_moccasin$0=caml_string_of_jsbytes("moccasin"),
     cst_navajowhite$0=caml_string_of_jsbytes("navajowhite"),
     cst_oldlace$0=caml_string_of_jsbytes("oldlace"),
     cst_olive$0=caml_string_of_jsbytes("olive"),
     cst_olivedrab$0=caml_string_of_jsbytes("olivedrab"),
     cst_orange$0=caml_string_of_jsbytes("orange"),
     cst_orangered$0=caml_string_of_jsbytes("orangered"),
     cst_orchid$0=caml_string_of_jsbytes("orchid"),
     cst_palegoldenrod$0=caml_string_of_jsbytes("palegoldenrod"),
     cst_palegreen$0=caml_string_of_jsbytes("palegreen"),
     cst_skyblue$0=caml_string_of_jsbytes("skyblue"),
     cst_rosybrown$0=caml_string_of_jsbytes("rosybrown"),
     cst_palevioletred$0=caml_string_of_jsbytes("palevioletred"),
     cst_papayawhip$0=caml_string_of_jsbytes("papayawhip"),
     cst_peachpuff$0=caml_string_of_jsbytes("peachpuff"),
     cst_peru$0=caml_string_of_jsbytes("peru"),
     cst_pink$0=caml_string_of_jsbytes("pink"),
     cst_plum$0=caml_string_of_jsbytes("plum"),
     cst_powderblue$0=caml_string_of_jsbytes("powderblue"),
     cst_purple$0=caml_string_of_jsbytes("purple"),
     cst_red$0=caml_string_of_jsbytes("red"),
     cst_royalblue$0=caml_string_of_jsbytes("royalblue"),
     cst_saddlebrown$0=caml_string_of_jsbytes("saddlebrown"),
     cst_salmon$0=caml_string_of_jsbytes("salmon"),
     cst_sandybrown$0=caml_string_of_jsbytes("sandybrown"),
     cst_seagreen$0=caml_string_of_jsbytes("seagreen"),
     cst_seashell$0=caml_string_of_jsbytes("seashell"),
     cst_sienna$0=caml_string_of_jsbytes("sienna"),
     cst_silver$0=caml_string_of_jsbytes("silver"),
     cst_thistle$0=caml_string_of_jsbytes("thistle"),
     cst_slateblue$0=caml_string_of_jsbytes("slateblue"),
     cst_slategray$0=caml_string_of_jsbytes("slategray"),
     cst_slategrey$0=caml_string_of_jsbytes("slategrey"),
     cst_snow$0=caml_string_of_jsbytes("snow"),
     cst_springgreen$0=caml_string_of_jsbytes("springgreen"),
     cst_steelblue$0=caml_string_of_jsbytes("steelblue"),
     cst_tan$0=caml_string_of_jsbytes("tan"),
     cst_teal$0=caml_string_of_jsbytes("teal"),
     cst_tomato$0=caml_string_of_jsbytes("tomato"),
     cst_turquoise$0=caml_string_of_jsbytes("turquoise"),
     cst_violet$0=caml_string_of_jsbytes("violet"),
     cst_wheat$0=caml_string_of_jsbytes("wheat"),
     cst_white$0=caml_string_of_jsbytes("white"),
     cst_whitesmoke$0=caml_string_of_jsbytes("whitesmoke"),
     cst_yellow$0=caml_string_of_jsbytes("yellow"),
     cst_yellowgreen$0=caml_string_of_jsbytes("yellowgreen"),
     cst_is_not_a_valid_color_name=
      caml_string_of_jsbytes(" is not a valid color name"),
     cst_aliceblue=caml_string_of_jsbytes("aliceblue"),
     cst_antiquewhite=caml_string_of_jsbytes("antiquewhite"),
     cst_aqua=caml_string_of_jsbytes("aqua"),
     cst_aquamarine=caml_string_of_jsbytes("aquamarine"),
     cst_azure=caml_string_of_jsbytes("azure"),
     cst_beige=caml_string_of_jsbytes("beige"),
     cst_bisque=caml_string_of_jsbytes("bisque"),
     cst_black=caml_string_of_jsbytes("black"),
     cst_blanchedalmond=caml_string_of_jsbytes("blanchedalmond"),
     cst_blue=caml_string_of_jsbytes("blue"),
     cst_blueviolet=caml_string_of_jsbytes("blueviolet"),
     cst_brown=caml_string_of_jsbytes("brown"),
     cst_burlywood=caml_string_of_jsbytes("burlywood"),
     cst_cadetblue=caml_string_of_jsbytes("cadetblue"),
     cst_chartreuse=caml_string_of_jsbytes("chartreuse"),
     cst_chocolate=caml_string_of_jsbytes("chocolate"),
     cst_coral=caml_string_of_jsbytes("coral"),
     cst_cornflowerblue=caml_string_of_jsbytes("cornflowerblue"),
     cst_cornsilk=caml_string_of_jsbytes("cornsilk"),
     cst_crimson=caml_string_of_jsbytes("crimson"),
     cst_cyan=caml_string_of_jsbytes("cyan"),
     cst_darkblue=caml_string_of_jsbytes("darkblue"),
     cst_darkcyan=caml_string_of_jsbytes("darkcyan"),
     cst_darkgoldenrod=caml_string_of_jsbytes("darkgoldenrod"),
     cst_darkgray=caml_string_of_jsbytes("darkgray"),
     cst_darkgreen=caml_string_of_jsbytes("darkgreen"),
     cst_darkgrey=caml_string_of_jsbytes("darkgrey"),
     cst_darkkhaki=caml_string_of_jsbytes("darkkhaki"),
     cst_darkmagenta=caml_string_of_jsbytes("darkmagenta"),
     cst_darkolivegreen=caml_string_of_jsbytes("darkolivegreen"),
     cst_darkorange=caml_string_of_jsbytes("darkorange"),
     cst_darkorchid=caml_string_of_jsbytes("darkorchid"),
     cst_darkred=caml_string_of_jsbytes("darkred"),
     cst_darksalmon=caml_string_of_jsbytes("darksalmon"),
     cst_darkseagreen=caml_string_of_jsbytes("darkseagreen"),
     cst_darkslateblue=caml_string_of_jsbytes("darkslateblue"),
     cst_darkslategray=caml_string_of_jsbytes("darkslategray"),
     cst_darkslategrey=caml_string_of_jsbytes("darkslategrey"),
     cst_darkturquoise=caml_string_of_jsbytes("darkturquoise"),
     cst_darkviolet=caml_string_of_jsbytes("darkviolet"),
     cst_deeppink=caml_string_of_jsbytes("deeppink"),
     cst_deepskyblue=caml_string_of_jsbytes("deepskyblue"),
     cst_dimgray=caml_string_of_jsbytes("dimgray"),
     cst_dimgrey=caml_string_of_jsbytes("dimgrey"),
     cst_dodgerblue=caml_string_of_jsbytes("dodgerblue"),
     cst_firebrick=caml_string_of_jsbytes("firebrick"),
     cst_floralwhite=caml_string_of_jsbytes("floralwhite"),
     cst_forestgreen=caml_string_of_jsbytes("forestgreen"),
     cst_fuchsia=caml_string_of_jsbytes("fuchsia"),
     cst_gainsboro=caml_string_of_jsbytes("gainsboro"),
     cst_ghostwhite=caml_string_of_jsbytes("ghostwhite"),
     cst_gold=caml_string_of_jsbytes("gold"),
     cst_goldenrod=caml_string_of_jsbytes("goldenrod"),
     cst_gray=caml_string_of_jsbytes("gray"),
     cst_grey=caml_string_of_jsbytes("grey"),
     cst_green=caml_string_of_jsbytes("green"),
     cst_greenyellow=caml_string_of_jsbytes("greenyellow"),
     cst_honeydew=caml_string_of_jsbytes("honeydew"),
     cst_hotpink=caml_string_of_jsbytes("hotpink"),
     cst_indianred=caml_string_of_jsbytes("indianred"),
     cst_indigo=caml_string_of_jsbytes("indigo"),
     cst_ivory=caml_string_of_jsbytes("ivory"),
     cst_khaki=caml_string_of_jsbytes("khaki"),
     cst_lavender=caml_string_of_jsbytes("lavender"),
     cst_lavenderblush=caml_string_of_jsbytes("lavenderblush"),
     cst_lawngreen=caml_string_of_jsbytes("lawngreen"),
     cst_lemonchiffon=caml_string_of_jsbytes("lemonchiffon"),
     cst_lightblue=caml_string_of_jsbytes("lightblue"),
     cst_lightcoral=caml_string_of_jsbytes("lightcoral"),
     cst_lightcyan=caml_string_of_jsbytes("lightcyan"),
     cst_lightgoldenrodyellow=caml_string_of_jsbytes("lightgoldenrodyellow"),
     cst_lightgray=caml_string_of_jsbytes("lightgray"),
     cst_lightgreen=caml_string_of_jsbytes("lightgreen"),
     cst_lightgrey=caml_string_of_jsbytes("lightgrey"),
     cst_lightpink=caml_string_of_jsbytes("lightpink"),
     cst_lightsalmon=caml_string_of_jsbytes("lightsalmon"),
     cst_lightseagreen=caml_string_of_jsbytes("lightseagreen"),
     cst_lightskyblue=caml_string_of_jsbytes("lightskyblue"),
     cst_lightslategray=caml_string_of_jsbytes("lightslategray"),
     cst_lightslategrey=caml_string_of_jsbytes("lightslategrey"),
     cst_lightsteelblue=caml_string_of_jsbytes("lightsteelblue"),
     cst_lightyellow=caml_string_of_jsbytes("lightyellow"),
     cst_lime=caml_string_of_jsbytes("lime"),
     cst_limegreen=caml_string_of_jsbytes("limegreen"),
     cst_linen=caml_string_of_jsbytes("linen"),
     cst_magenta=caml_string_of_jsbytes("magenta"),
     cst_maroon=caml_string_of_jsbytes("maroon"),
     cst_mediumaquamarine=caml_string_of_jsbytes("mediumaquamarine"),
     cst_mediumblue=caml_string_of_jsbytes("mediumblue"),
     cst_mediumorchid=caml_string_of_jsbytes("mediumorchid"),
     cst_mediumpurple=caml_string_of_jsbytes("mediumpurple"),
     cst_mediumseagreen=caml_string_of_jsbytes("mediumseagreen"),
     cst_mediumslateblue=caml_string_of_jsbytes("mediumslateblue"),
     cst_mediumspringgreen=caml_string_of_jsbytes("mediumspringgreen"),
     cst_mediumturquoise=caml_string_of_jsbytes("mediumturquoise"),
     cst_mediumvioletred=caml_string_of_jsbytes("mediumvioletred"),
     cst_midnightblue=caml_string_of_jsbytes("midnightblue"),
     cst_mintcream=caml_string_of_jsbytes("mintcream"),
     cst_mistyrose=caml_string_of_jsbytes("mistyrose"),
     cst_moccasin=caml_string_of_jsbytes("moccasin"),
     cst_navajowhite=caml_string_of_jsbytes("navajowhite"),
     cst_navy=caml_string_of_jsbytes("navy"),
     cst_oldlace=caml_string_of_jsbytes("oldlace"),
     cst_olive=caml_string_of_jsbytes("olive"),
     cst_olivedrab=caml_string_of_jsbytes("olivedrab"),
     cst_orange=caml_string_of_jsbytes("orange"),
     cst_orangered=caml_string_of_jsbytes("orangered"),
     cst_orchid=caml_string_of_jsbytes("orchid"),
     cst_palegoldenrod=caml_string_of_jsbytes("palegoldenrod"),
     cst_palegreen=caml_string_of_jsbytes("palegreen"),
     cst_paleturquoise=caml_string_of_jsbytes("paleturquoise"),
     cst_palevioletred=caml_string_of_jsbytes("palevioletred"),
     cst_papayawhip=caml_string_of_jsbytes("papayawhip"),
     cst_peachpuff=caml_string_of_jsbytes("peachpuff"),
     cst_peru=caml_string_of_jsbytes("peru"),
     cst_pink=caml_string_of_jsbytes("pink"),
     cst_plum=caml_string_of_jsbytes("plum"),
     cst_powderblue=caml_string_of_jsbytes("powderblue"),
     cst_purple=caml_string_of_jsbytes("purple"),
     cst_red=caml_string_of_jsbytes("red"),
     cst_rosybrown=caml_string_of_jsbytes("rosybrown"),
     cst_royalblue=caml_string_of_jsbytes("royalblue"),
     cst_saddlebrown=caml_string_of_jsbytes("saddlebrown"),
     cst_salmon=caml_string_of_jsbytes("salmon"),
     cst_sandybrown=caml_string_of_jsbytes("sandybrown"),
     cst_seagreen=caml_string_of_jsbytes("seagreen"),
     cst_seashell=caml_string_of_jsbytes("seashell"),
     cst_sienna=caml_string_of_jsbytes("sienna"),
     cst_silver=caml_string_of_jsbytes("silver"),
     cst_skyblue=caml_string_of_jsbytes("skyblue"),
     cst_slateblue=caml_string_of_jsbytes("slateblue"),
     cst_slategray=caml_string_of_jsbytes("slategray"),
     cst_slategrey=caml_string_of_jsbytes("slategrey"),
     cst_snow=caml_string_of_jsbytes("snow"),
     cst_springgreen=caml_string_of_jsbytes("springgreen"),
     cst_steelblue=caml_string_of_jsbytes("steelblue"),
     cst_tan=caml_string_of_jsbytes("tan"),
     cst_teal=caml_string_of_jsbytes("teal"),
     cst_thistle=caml_string_of_jsbytes("thistle"),
     cst_tomato=caml_string_of_jsbytes("tomato"),
     cst_turquoise=caml_string_of_jsbytes("turquoise"),
     cst_violet=caml_string_of_jsbytes("violet"),
     cst_wheat=caml_string_of_jsbytes("wheat"),
     cst_white=caml_string_of_jsbytes("white"),
     cst_whitesmoke=caml_string_of_jsbytes("whitesmoke"),
     cst_yellow=caml_string_of_jsbytes("yellow"),
     cst_yellowgreen=caml_string_of_jsbytes("yellowgreen"),
     cst_vkern$0=caml_string_of_jsbytes("vkern"),
     cst_view$0=caml_string_of_jsbytes("view"),
     cst_use$0=caml_string_of_jsbytes("use"),
     cst_tspan$0=caml_string_of_jsbytes("tspan"),
     cst_tref$0=caml_string_of_jsbytes("tref"),
     cst_title$3=caml_string_of_jsbytes("title"),
     cst_textpath$0=caml_string_of_jsbytes("textpath"),
     cst_text$1=caml_string_of_jsbytes("text"),
     cst_symbol$0=caml_string_of_jsbytes("symbol"),
     cst_switch$0=caml_string_of_jsbytes("switch"),
     cst_svg$0=caml_string_of_jsbytes("svg"),
     cst_style$3=caml_string_of_jsbytes("style"),
     cst_stop$0=caml_string_of_jsbytes("stop"),
     cst_set$0=caml_string_of_jsbytes("set"),
     cst_script$3=caml_string_of_jsbytes("script"),
     cst_rect$0=caml_string_of_jsbytes("rect"),
     cst_radialgradient$0=caml_string_of_jsbytes("radialgradient"),
     cst_polyline$0=caml_string_of_jsbytes("polyline"),
     cst_polygon$0=caml_string_of_jsbytes("polygon"),
     cst_pattern$0=caml_string_of_jsbytes("pattern"),
     cst_path$0=caml_string_of_jsbytes("path"),
     cst_mpath$0=caml_string_of_jsbytes("mpath"),
     cst_missing_glyph$0=caml_string_of_jsbytes("missing-glyph"),
     cst_metadata$0=caml_string_of_jsbytes("metadata"),
     cst_mask$0=caml_string_of_jsbytes("mask"),
     cst_lineargradient$0=caml_string_of_jsbytes("lineargradient"),
     cst_line$0=caml_string_of_jsbytes("line"),
     cst_image$0=caml_string_of_jsbytes("image"),
     cst_hkern$0=caml_string_of_jsbytes("hkern"),
     cst_glyphref$0=caml_string_of_jsbytes("glyphref"),
     cst_glyph$0=caml_string_of_jsbytes("glyph"),
     cst_g$1=caml_string_of_jsbytes("g"),
     cst_foreignobject=caml_string_of_jsbytes("foreignobject"),
     cst_font_face_uri$0=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_src$0=caml_string_of_jsbytes("font-face-src"),
     cst_font_face_name$0=caml_string_of_jsbytes("font-face-name"),
     cst_font_face_format$0=caml_string_of_jsbytes("font-face-format"),
     cst_font_face$0=caml_string_of_jsbytes("font-face"),
     cst_font$0=caml_string_of_jsbytes("font"),
     cst_filter$0=caml_string_of_jsbytes("filter"),
     cst_ellipse$0=caml_string_of_jsbytes("ellipse"),
     cst_desc$0=caml_string_of_jsbytes("desc"),
     cst_defs$0=caml_string_of_jsbytes("defs"),
     cst_cursor$0=caml_string_of_jsbytes("cursor"),
     cst_clippath$0=caml_string_of_jsbytes("clippath"),
     cst_circle$0=caml_string_of_jsbytes("circle"),
     cst_animatetransform$0=caml_string_of_jsbytes("animatetransform"),
     cst_animatemotion$0=caml_string_of_jsbytes("animatemotion"),
     cst_animatecolor$0=caml_string_of_jsbytes("animatecolor"),
     cst_animate$0=caml_string_of_jsbytes("animate"),
     cst_altglyphitem$0=caml_string_of_jsbytes("altglyphitem"),
     cst_altglyphdef$0=caml_string_of_jsbytes("altglyphdef"),
     cst_altglyph$0=caml_string_of_jsbytes("altglyph"),
     cst_a$3=caml_string_of_jsbytes("a"),
     cst_vkern=caml_string_of_jsbytes("vkern"),
     cst_view=caml_string_of_jsbytes("view"),
     cst_use=caml_string_of_jsbytes("use"),
     cst_tspan=caml_string_of_jsbytes("tspan"),
     cst_tref=caml_string_of_jsbytes("tref"),
     cst_title$2=caml_string_of_jsbytes("title"),
     cst_textpath=caml_string_of_jsbytes("textpath"),
     cst_text$0=caml_string_of_jsbytes("text"),
     cst_symbol=caml_string_of_jsbytes("symbol"),
     cst_switch=caml_string_of_jsbytes("switch"),
     cst_svg=caml_string_of_jsbytes("svg"),
     cst_style$2=caml_string_of_jsbytes("style"),
     cst_stop=caml_string_of_jsbytes("stop"),
     cst_set=caml_string_of_jsbytes("set"),
     cst_script$2=caml_string_of_jsbytes("script"),
     cst_rect=caml_string_of_jsbytes("rect"),
     cst_radialgradient=caml_string_of_jsbytes("radialgradient"),
     cst_polyline=caml_string_of_jsbytes("polyline"),
     cst_polygon=caml_string_of_jsbytes("polygon"),
     cst_pattern=caml_string_of_jsbytes("pattern"),
     cst_path=caml_string_of_jsbytes("path"),
     cst_mpath=caml_string_of_jsbytes("mpath"),
     cst_missing_glyph=caml_string_of_jsbytes("missing-glyph"),
     cst_metadata=caml_string_of_jsbytes("metadata"),
     cst_mask=caml_string_of_jsbytes("mask"),
     cst_lineargradient=caml_string_of_jsbytes("lineargradient"),
     cst_line=caml_string_of_jsbytes("line"),
     cst_image=caml_string_of_jsbytes("image"),
     cst_hkern=caml_string_of_jsbytes("hkern"),
     cst_glyphref=caml_string_of_jsbytes("glyphref"),
     cst_glyph=caml_string_of_jsbytes("glyph"),
     cst_g$0=caml_string_of_jsbytes("g"),
     cst_foreignObject=caml_string_of_jsbytes("foreignObject"),
     cst_font_face_uri=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_src=caml_string_of_jsbytes("font-face-src"),
     cst_font_face_name=caml_string_of_jsbytes("font-face-name"),
     cst_font_face_format=caml_string_of_jsbytes("font-face-format"),
     cst_font_face=caml_string_of_jsbytes("font-face"),
     cst_font=caml_string_of_jsbytes("font"),
     cst_filter=caml_string_of_jsbytes("filter"),
     cst_ellipse=caml_string_of_jsbytes("ellipse"),
     cst_desc=caml_string_of_jsbytes("desc"),
     cst_defs=caml_string_of_jsbytes("defs"),
     cst_cursor=caml_string_of_jsbytes("cursor"),
     cst_clippath=caml_string_of_jsbytes("clippath"),
     cst_circle=caml_string_of_jsbytes("circle"),
     cst_animatetransform=caml_string_of_jsbytes("animatetransform"),
     cst_animatemotion=caml_string_of_jsbytes("animatemotion"),
     cst_animatecolor=caml_string_of_jsbytes("animatecolor"),
     cst_animate=caml_string_of_jsbytes("animate"),
     cst_altglyphitem=caml_string_of_jsbytes("altglyphitem"),
     cst_altglyphdef=caml_string_of_jsbytes("altglyphdef"),
     cst_altglyph=caml_string_of_jsbytes("altglyph"),
     cst_a$2=caml_string_of_jsbytes("a"),
     cst_Js_of_ocaml_Dom_svg_SVGErr=
      caml_string_of_jsbytes("Js_of_ocaml__Dom_svg.SVGError"),
     Stdlib_String=global_data.Stdlib__String,
     Stdlib_Char=global_data.Stdlib__Char,
     Stdlib=global_data.Stdlib,
     Jsoo_runtime=global_data.Jsoo_runtime,
     Stdlib_Printexc=global_data.Stdlib__Printexc,
     Assert_failure=global_data.Assert_failure,
     Stdlib_List=global_data.Stdlib__List,
     Stdlib_Array=global_data.Stdlib__Array,
     Stdlib_Uchar=global_data.Stdlib__Uchar,
     Stdlib_Printf=global_data.Stdlib__Printf,
     Stdlib_Obj=global_data.Stdlib__Obj,
     Js_of_ocaml=[0];
    caml_register_global(1635,Js_of_ocaml,"Js_of_ocaml__");
    var
     Poly=[0],
     _g_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom.ml"),351,67],
     _h_=[0,caml_string_of_jsbytes("transparent")],
     _i_=[0,caml_string_of_jsbytes("native")],
     _m_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom_html.ml"),2850,58],
     _l_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom_html.ml"),2849,61],
     _k_=
      [0,
       [11,
        caml_string_of_jsbytes("getElementById_exn: "),
        [3,0,[11,caml_string_of_jsbytes(" not found"),0]]],
       caml_string_of_jsbytes("getElementById_exn: %S not found")],
     _o_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/form.ml"),178,13],
     _n_=[0,1],
     _p_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/regexp.ml"),34,64],
     _q_=[0,caml_string_of_jsbytes(""),0],
     _ck_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cl_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cm_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cn_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b8_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b9_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b__=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b$_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ca_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cb_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cc_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cd_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ce_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cf_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cg_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ch_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ci_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cj_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b7_=
      caml_list_of_js_array
       ([caml_string_of_jsbytes("aliceblue"),
         caml_string_of_jsbytes("antiquewhite"),
         caml_string_of_jsbytes("aqua"),
         caml_string_of_jsbytes("aquamarine"),
         caml_string_of_jsbytes("azure"),
         caml_string_of_jsbytes("beige"),
         caml_string_of_jsbytes("bisque"),
         caml_string_of_jsbytes("black"),
         caml_string_of_jsbytes("blanchedalmond"),
         caml_string_of_jsbytes("blue"),
         caml_string_of_jsbytes("blueviolet"),
         caml_string_of_jsbytes("brown"),
         caml_string_of_jsbytes("burlywood"),
         caml_string_of_jsbytes("cadetblue"),
         caml_string_of_jsbytes("chartreuse"),
         caml_string_of_jsbytes("chocolate"),
         caml_string_of_jsbytes("coral"),
         caml_string_of_jsbytes("cornflowerblue"),
         caml_string_of_jsbytes("cornsilk"),
         caml_string_of_jsbytes("crimson"),
         caml_string_of_jsbytes("cyan"),
         caml_string_of_jsbytes("darkblue"),
         caml_string_of_jsbytes("darkcyan"),
         caml_string_of_jsbytes("darkgoldenrod"),
         caml_string_of_jsbytes("darkgray"),
         caml_string_of_jsbytes("darkgreen"),
         caml_string_of_jsbytes("darkgrey"),
         caml_string_of_jsbytes("darkkhaki"),
         caml_string_of_jsbytes("darkmagenta"),
         caml_string_of_jsbytes("darkolivegreen"),
         caml_string_of_jsbytes("darkorange"),
         caml_string_of_jsbytes("darkorchid"),
         caml_string_of_jsbytes("darkred"),
         caml_string_of_jsbytes("darksalmon"),
         caml_string_of_jsbytes("darkseagreen"),
         caml_string_of_jsbytes("darkslateblue"),
         caml_string_of_jsbytes("darkslategray"),
         caml_string_of_jsbytes("darkslategrey"),
         caml_string_of_jsbytes("darkturquoise"),
         caml_string_of_jsbytes("darkviolet"),
         caml_string_of_jsbytes("deeppink"),
         caml_string_of_jsbytes("deepskyblue"),
         caml_string_of_jsbytes("dimgray"),
         caml_string_of_jsbytes("dimgrey"),
         caml_string_of_jsbytes("dodgerblue"),
         caml_string_of_jsbytes("firebrick"),
         caml_string_of_jsbytes("floralwhite"),
         caml_string_of_jsbytes("forestgreen"),
         caml_string_of_jsbytes("fuchsia"),
         caml_string_of_jsbytes("gainsboro"),
         caml_string_of_jsbytes("ghostwhite"),
         caml_string_of_jsbytes("gold"),
         caml_string_of_jsbytes("goldenrod"),
         caml_string_of_jsbytes("gray"),
         caml_string_of_jsbytes("green"),
         caml_string_of_jsbytes("greenyellow"),
         caml_string_of_jsbytes("grey"),
         caml_string_of_jsbytes("honeydew"),
         caml_string_of_jsbytes("hotpink"),
         caml_string_of_jsbytes("indianred"),
         caml_string_of_jsbytes("indigo"),
         caml_string_of_jsbytes("ivory"),
         caml_string_of_jsbytes("khaki"),
         caml_string_of_jsbytes("lavender"),
         caml_string_of_jsbytes("lavenderblush"),
         caml_string_of_jsbytes("lawngreen"),
         caml_string_of_jsbytes("lemonchiffon"),
         caml_string_of_jsbytes("lightblue"),
         caml_string_of_jsbytes("lightcoral"),
         caml_string_of_jsbytes("lightcyan"),
         caml_string_of_jsbytes("lightgoldenrodyellow"),
         caml_string_of_jsbytes("lightgray"),
         caml_string_of_jsbytes("lightgreen"),
         caml_string_of_jsbytes("lightgrey"),
         caml_string_of_jsbytes("lightpink"),
         caml_string_of_jsbytes("lightsalmon"),
         caml_string_of_jsbytes("lightseagreen"),
         caml_string_of_jsbytes("lightskyblue"),
         caml_string_of_jsbytes("lightslategray"),
         caml_string_of_jsbytes("lightslategrey"),
         caml_string_of_jsbytes("lightsteelblue"),
         caml_string_of_jsbytes("lightyellow"),
         caml_string_of_jsbytes("lime"),
         caml_string_of_jsbytes("limegreen"),
         caml_string_of_jsbytes("linen"),
         caml_string_of_jsbytes("magenta"),
         caml_string_of_jsbytes("maroon"),
         caml_string_of_jsbytes("mediumaquamarine"),
         caml_string_of_jsbytes("mediumblue"),
         caml_string_of_jsbytes("mediumorchid"),
         caml_string_of_jsbytes("mediumpurple"),
         caml_string_of_jsbytes("mediumseagreen"),
         caml_string_of_jsbytes("mediumslateblue"),
         caml_string_of_jsbytes("mediumspringgreen"),
         caml_string_of_jsbytes("mediumturquoise"),
         caml_string_of_jsbytes("mediumvioletred"),
         caml_string_of_jsbytes("midnightblue"),
         caml_string_of_jsbytes("mintcream"),
         caml_string_of_jsbytes("mistyrose"),
         caml_string_of_jsbytes("moccasin"),
         caml_string_of_jsbytes("navajowhite"),
         caml_string_of_jsbytes("navy"),
         caml_string_of_jsbytes("oldlace"),
         caml_string_of_jsbytes("olive"),
         caml_string_of_jsbytes("olivedrab"),
         caml_string_of_jsbytes("orange"),
         caml_string_of_jsbytes("orangered"),
         caml_string_of_jsbytes("orchid"),
         caml_string_of_jsbytes("palegoldenrod"),
         caml_string_of_jsbytes("palegreen"),
         caml_string_of_jsbytes("paleturquoise"),
         caml_string_of_jsbytes("palevioletred"),
         caml_string_of_jsbytes("papayawhip"),
         caml_string_of_jsbytes("peachpuff"),
         caml_string_of_jsbytes("peru"),
         caml_string_of_jsbytes("pink"),
         caml_string_of_jsbytes("plum"),
         caml_string_of_jsbytes("powderblue"),
         caml_string_of_jsbytes("purple"),
         caml_string_of_jsbytes("red"),
         caml_string_of_jsbytes("rosybrown"),
         caml_string_of_jsbytes("royalblue"),
         caml_string_of_jsbytes("saddlebrown"),
         caml_string_of_jsbytes("salmon"),
         caml_string_of_jsbytes("sandybrown"),
         caml_string_of_jsbytes("seagreen"),
         caml_string_of_jsbytes("seashell"),
         caml_string_of_jsbytes("sienna"),
         caml_string_of_jsbytes("silver"),
         caml_string_of_jsbytes("skyblue"),
         caml_string_of_jsbytes("slateblue"),
         caml_string_of_jsbytes("slategray"),
         caml_string_of_jsbytes("slategrey"),
         caml_string_of_jsbytes("snow"),
         caml_string_of_jsbytes("springgreen"),
         caml_string_of_jsbytes("steelblue"),
         caml_string_of_jsbytes("tan"),
         caml_string_of_jsbytes("teal"),
         caml_string_of_jsbytes("thistle"),
         caml_string_of_jsbytes("tomato"),
         caml_string_of_jsbytes("turquoise"),
         caml_string_of_jsbytes("violet"),
         caml_string_of_jsbytes("wheat"),
         caml_string_of_jsbytes("white"),
         caml_string_of_jsbytes("whitesmoke"),
         caml_string_of_jsbytes("yellow"),
         caml_string_of_jsbytes("yellowgreen")]),
     _b6_=
      [0,
       [12,35,[4,8,[0,2,2],0,[4,8,[0,2,2],0,[4,8,[0,2,2],0,0]]]],
       caml_string_of_jsbytes("#%02X%02X%02X")],
     _b0_=
      [0,
       [11,
        caml_string_of_jsbytes("rgb("),
        [4,0,0,0,[12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,41,0]]]]]]],
       caml_string_of_jsbytes("rgb(%d,%d,%d)")],
     _b1_=
      [0,
       [11,
        caml_string_of_jsbytes("rgb("),
        [4,
         0,
         0,
         0,
         [12,37,[12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]]],
       caml_string_of_jsbytes("rgb(%d%%,%d%%,%d%%)")],
     _b2_=
      [0,
       [11,
        caml_string_of_jsbytes("rgba("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,44,[8,[0,0,0],0,0,[12,41,0]]]]]]]]],
       caml_string_of_jsbytes("rgba(%d,%d,%d,%f)")],
     _b3_=
      [0,
       [11,
        caml_string_of_jsbytes("rgba("),
        [4,
         0,
         0,
         0,
         [12,
          37,
          [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,44,partial]]]]]]]]]],
       caml_string_of_jsbytes("rgba(%d%%,%d%%,%d%%,%f)")],
     _b4_=
      [0,
       [11,
        caml_string_of_jsbytes("hsl("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]],
       caml_string_of_jsbytes("hsl(%d,%d%%,%d%%)")],
     _b5_=
      [0,
       [11,
        caml_string_of_jsbytes("hsla("),
        [4,
         0,
         0,
         0,
         [12,
          44,
          [4,
           0,
           0,
           0,
           [12,
            37,
            [12,44,[4,0,0,0,[12,37,[12,44,[8,partial$1,0,0,partial$0]]]]]]]]]],
       caml_string_of_jsbytes("hsla(%d,%d%%,%d%%,%f)")],
     _x_=[0,240,248,255],
     _y_=[0,250,235,215],
     _z_=[0,0,255,255],
     _A_=[0,127,255,212],
     _B_=[0,240,255,255],
     _C_=[0,245,245,220],
     _D_=[0,255,228,196],
     _E_=[0,0,0,0],
     _F_=[0,255,235,205],
     _G_=[0,0,0,255],
     _H_=[0,138,43,226],
     _I_=[0,165,42,42],
     _J_=[0,222,184,135],
     _K_=[0,95,158,160],
     _L_=[0,127,255,0],
     _M_=[0,210,105,30],
     _N_=[0,255,127,80],
     _O_=[0,100,149,237],
     _P_=[0,255,248,220],
     _Q_=[0,220,20,60],
     _R_=[0,0,255,255],
     _S_=[0,0,0,139],
     _T_=[0,0,139,139],
     _U_=[0,184,134,11],
     _V_=[0,169,169,169],
     _W_=[0,0,100,0],
     _X_=[0,169,169,169],
     _Y_=[0,189,183,107],
     _Z_=[0,139,0,139],
     ___=[0,85,107,47],
     _$_=[0,255,140,0],
     _aa_=[0,153,50,204],
     _ab_=[0,139,0,0],
     _ac_=[0,233,150,122],
     _ad_=[0,143,188,143],
     _ae_=[0,72,61,139],
     _af_=[0,47,79,79],
     _ag_=[0,47,79,79],
     _ah_=[0,0,206,209],
     _ai_=[0,148,0,211],
     _aj_=[0,255,20,147],
     _ak_=[0,0,191,255],
     _al_=[0,105,105,105],
     _am_=[0,105,105,105],
     _an_=[0,30,144,255],
     _ao_=[0,178,34,34],
     _ap_=[0,255,250,240],
     _aq_=[0,34,139,34],
     _ar_=[0,255,0,255],
     _as_=[0,220,220,220],
     _at_=[0,248,248,255],
     _au_=[0,255,215,0],
     _av_=[0,218,165,32],
     _aw_=[0,128,128,128],
     _ax_=[0,128,128,128],
     _ay_=[0,0,128,0],
     _az_=[0,173,255,47],
     _aA_=[0,240,255,240],
     _aB_=[0,255,105,180],
     _aC_=[0,205,92,92],
     _aD_=[0,75,0,130],
     _aE_=[0,255,255,240],
     _aF_=[0,240,230,140],
     _aG_=[0,230,230,250],
     _aH_=[0,255,240,245],
     _aI_=[0,124,252,0],
     _aJ_=[0,255,250,205],
     _aK_=[0,173,216,230],
     _aL_=[0,240,128,128],
     _aM_=[0,224,255,255],
     _aN_=[0,250,250,210],
     _aO_=[0,211,211,211],
     _aP_=[0,144,238,144],
     _aQ_=[0,211,211,211],
     _aR_=[0,255,182,193],
     _aS_=[0,255,160,122],
     _aT_=[0,32,178,170],
     _aU_=[0,135,206,250],
     _aV_=[0,119,136,153],
     _aW_=[0,119,136,153],
     _aX_=[0,176,196,222],
     _aY_=[0,255,255,224],
     _aZ_=[0,0,255,0],
     _a0_=[0,50,205,50],
     _a1_=[0,250,240,230],
     _a2_=[0,255,0,255],
     _a3_=[0,128,0,0],
     _a4_=[0,102,205,170],
     _a5_=[0,0,0,205],
     _a6_=[0,186,85,211],
     _a7_=[0,147,112,219],
     _a8_=[0,60,179,113],
     _a9_=[0,123,104,238],
     _a__=[0,0,250,154],
     _a$_=[0,72,209,204],
     _ba_=[0,199,21,133],
     _bb_=[0,25,25,112],
     _bc_=[0,245,255,250],
     _bd_=[0,255,228,225],
     _be_=[0,255,228,181],
     _bf_=[0,255,222,173],
     _bg_=[0,0,0,128],
     _bh_=[0,253,245,230],
     _bi_=[0,128,128,0],
     _bj_=[0,107,142,35],
     _bk_=[0,255,165,0],
     _bl_=[0,255,69,0],
     _bm_=[0,218,112,214],
     _bn_=[0,238,232,170],
     _bo_=[0,152,251,152],
     _bp_=[0,175,238,238],
     _bq_=[0,219,112,147],
     _br_=[0,255,239,213],
     _bs_=[0,255,218,185],
     _bt_=[0,205,133,63],
     _bu_=[0,255,192,203],
     _bv_=[0,221,160,221],
     _bw_=[0,176,224,230],
     _bx_=[0,128,0,128],
     _by_=[0,255,0,0],
     _bz_=[0,188,143,143],
     _bA_=[0,65,105,225],
     _bB_=[0,139,69,19],
     _bC_=[0,250,128,114],
     _bD_=[0,244,164,96],
     _bE_=[0,46,139,87],
     _bF_=[0,255,245,238],
     _bG_=[0,160,82,45],
     _bH_=[0,192,192,192],
     _bI_=[0,135,206,235],
     _bJ_=[0,106,90,205],
     _bK_=[0,112,128,144],
     _bL_=[0,112,128,144],
     _bM_=[0,255,250,250],
     _bN_=[0,0,255,127],
     _bO_=[0,70,130,180],
     _bP_=[0,210,180,140],
     _bQ_=[0,0,128,128],
     _bR_=[0,216,191,216],
     _bS_=[0,255,99,71],
     _bT_=[0,64,224,208],
     _bU_=[0,238,130,238],
     _bV_=[0,245,222,179],
     _bW_=[0,255,255,255],
     _bX_=[0,245,245,245],
     _bY_=[0,255,255,0],
     _bZ_=[0,154,205,50];
    function symbol(x,y){return x < y?1:0}
    function symbol$0(x,y){return x <= y?1:0}
    function symbol$1(x,y){return x !== y?1:0}
    function symbol$2(x,y){return x === y?1:0}
    function symbol$3(x,y){return y < x?1:0}
    function symbol$4(x,y){return y <= x?1:0}
    var compare=runtime.caml_int_compare;
    function equal(x,y){return x === y?1:0}
    function max(x,y){return y <= x?x:y}
    function min(x,y){return x <= y?x:y}
    var
     Int_replace_polymorphic_compar=
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       compare,
       equal,
       max,
       min],
     make=Stdlib_String[1],
     init=Stdlib_String[2],
     empty=Stdlib_String[3],
     of_bytes=Stdlib_String[4],
     to_bytes=Stdlib_String[5],
     concat=Stdlib_String[6],
     cat=Stdlib_String[7],
     compare$0=Stdlib_String[9],
     starts_with=Stdlib_String[10],
     ends_with=Stdlib_String[11],
     contains_from=Stdlib_String[12],
     rcontains_from=Stdlib_String[13],
     contains=Stdlib_String[14],
     sub=Stdlib_String[15],
     split_on_char=Stdlib_String[16],
     map=Stdlib_String[17],
     mapi=Stdlib_String[18],
     fold_left=Stdlib_String[19],
     fold_right=Stdlib_String[20],
     for_all=Stdlib_String[21],
     exists=Stdlib_String[22],
     trim=Stdlib_String[23],
     escaped=Stdlib_String[24],
     uppercase_ascii=Stdlib_String[25],
     lowercase_ascii=Stdlib_String[26],
     capitalize_ascii=Stdlib_String[27],
     uncapitalize_ascii=Stdlib_String[28],
     iter=Stdlib_String[29],
     iteri=Stdlib_String[30],
     index_from=Stdlib_String[31],
     index_from_opt=Stdlib_String[32],
     rindex_from=Stdlib_String[33],
     rindex_from_opt=Stdlib_String[34],
     index=Stdlib_String[35],
     index_opt=Stdlib_String[36],
     rindex=Stdlib_String[37],
     rindex_opt=Stdlib_String[38],
     to_seq=Stdlib_String[39],
     to_seqi=Stdlib_String[40],
     of_seq=Stdlib_String[41],
     blit=Stdlib_String[42],
     copy=Stdlib_String[43],
     fill=Stdlib_String[44],
     uppercase=Stdlib_String[45],
     lowercase=Stdlib_String[46],
     capitalize=Stdlib_String[47],
     uncapitalize=Stdlib_String[48],
     get_uint8=Stdlib_String[49],
     get_int8=Stdlib_String[50],
     get_uint16_ne=Stdlib_String[51],
     get_uint16_be=Stdlib_String[52],
     get_uint16_le=Stdlib_String[53],
     get_int16_ne=Stdlib_String[54],
     get_int16_be=Stdlib_String[55],
     get_int16_le=Stdlib_String[56],
     get_int32_ne=Stdlib_String[57],
     get_int32_be=Stdlib_String[58],
     get_int32_le=Stdlib_String[59],
     get_int64_ne=Stdlib_String[60],
     get_int64_be=Stdlib_String[61],
     get_int64_le=Stdlib_String[62];
    function equal$0(x,y){return runtime.caml_string_equal(x,y)}
    var
     String=
      [0,
       make,
       init,
       empty,
       of_bytes,
       to_bytes,
       concat,
       cat,
       compare$0,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       blit,
       copy,
       fill,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       equal$0],
     chr=Stdlib_Char[1],
     escaped$0=Stdlib_Char[2],
     lowercase$0=Stdlib_Char[3],
     uppercase$0=Stdlib_Char[4],
     lowercase_ascii$0=Stdlib_Char[5],
     uppercase_ascii$0=Stdlib_Char[6],
     compare$1=Stdlib_Char[7];
    function equal$1(x,y){return x === y?1:0}
    var
     Char=
      [0,
       chr,
       escaped$0,
       lowercase$0,
       uppercase$0,
       lowercase_ascii$0,
       uppercase_ascii$0,
       compare$1,
       equal$1],
     symbol$5=Int_replace_polymorphic_compar[1],
     symbol$6=Int_replace_polymorphic_compar[2],
     symbol$7=Int_replace_polymorphic_compar[3],
     symbol$8=Int_replace_polymorphic_compar[4],
     symbol$9=Int_replace_polymorphic_compar[5],
     symbol$10=Int_replace_polymorphic_compar[6],
     compare$2=Int_replace_polymorphic_compar[7],
     equal$2=Int_replace_polymorphic_compar[8],
     max$0=Int_replace_polymorphic_compar[9],
     min$0=Int_replace_polymorphic_compar[10],
     Js_of_ocaml_Import=
      [0,
       Poly,
       Int_replace_polymorphic_compar,
       String,
       Char,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       compare$2,
       equal$2,
       max$0,
       min$0];
    caml_register_global(1638,Js_of_ocaml_Import,"Js_of_ocaml__Import");
    var global=globalThis,Unsafe=[0,global],no_handler=null,t39=undefined;
    function return$0(_gO_){return _gO_}
    function map$0(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function bind(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function test(x){return 1 - (x == no_handler?1:0)}
    function iter$0(x,f)
     {var _gN_=1 - (x == no_handler?1:0);return _gN_?caml_call1(f,x):_gN_}
    function case$0(x,f,g)
     {return x == no_handler?caml_call1(f,0):caml_call1(g,x)}
    function get(x,f){return x == no_handler?caml_call1(f,0):x}
    function option(x){if(x){var x$0=x[1];return x$0}return no_handler}
    function to_option(x)
     {function _gM_(x){return [0,x]}
      return case$0(x,function(param){return 0},_gM_)}
    var
     Opt=
      [0,
       no_handler,
       return$0,
       map$0,
       bind,
       test,
       iter$0,
       case$0,
       get,
       option,
       to_option];
    function return$1(_gL_){return _gL_}
    function map$1(x,f){return x === t39?t39:caml_call1(f,x)}
    function bind$0(x,f){return x === t39?t39:caml_call1(f,x)}
    function test$0(x){return x !== t39?1:0}
    function iter$1(x,f)
     {var _gK_=x !== t39?1:0;return _gK_?caml_call1(f,x):_gK_}
    function case$1(x,f,g){return x === t39?caml_call1(f,0):caml_call1(g,x)}
    function get$0(x,f){return x === t39?caml_call1(f,0):x}
    function option$0(x){if(x){var x$0=x[1];return x$0}return t39}
    function to_option$0(x)
     {function _gJ_(x){return [0,x]}
      return case$1(x,function(param){return 0},_gJ_)}
    var
     Optdef=
      [0,
       t39,
       return$1,
       map$1,
       bind$0,
       test$0,
       iter$1,
       case$1,
       get$0,
       option$0,
       to_option$0];
    function coerce(x,f,g)
     {function _gH_(param){return caml_call1(g,x)}
      var _gI_=caml_call1(f,x);
      return caml_call2(Opt[8],_gI_,_gH_)}
    function coerce_opt(x,f,g)
     {function _gF_(param){return caml_call1(g,x)}
      var _gG_=caml_call2(Opt[4],x,f);
      return caml_call2(Opt[8],_gG_,_gF_)}
    var
     t25=true,
     t4=false,
     string_constr=Unsafe[1].String,
     t11=Unsafe[1].RegExp,
     t4$0=Unsafe[1].Object;
    function object_keys(t3){return t4$0.keys(t3)}
    var
     array_length=Unsafe[1].Array,
     array_get=caml_js_get,
     array_set=caml_js_set;
    function array_map(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call1(f,x)}))}
    function array_mapi(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call2(f,idx,x)}))}
    function str_array(_gE_){return _gE_}
    function match_result(_gD_){return _gD_}
    var
     t122=Unsafe[1].Date,
     math=Unsafe[1].Math,
     error_constr=Unsafe[1].Error,
     include=Jsoo_runtime[3],
     raise=include[1],
     attach_js_backtrace=include[2],
     of_exn=include[3],
     Error=include[4];
    function name(e){return caml_string_of_jsstring(e.name)}
    function message(e){return caml_string_of_jsstring(e.message)}
    function stack(e)
     {var _gC_=caml_call2(Opt[3],e.stack,caml_string_of_jsstring);
      return caml_call1(Opt[10],_gC_)}
    function to_string(e){return caml_string_of_jsstring(e.toString())}
    function raise_js_error(e){return caml_call1(raise,e)}
    function string_of_error(e){return to_string(e)}
    var JSON=Unsafe[1].JSON;
    function decodeURI(s){return Unsafe[1].decodeURI(s)}
    function decodeURIComponent(s){return Unsafe[1].decodeURIComponent(s)}
    function encodeURI(s){return Unsafe[1].encodeURI(s)}
    function encodeURIComponent(s){return Unsafe[1].encodeURIComponent(s)}
    function escape(s){return Unsafe[1].escape(s)}
    function unescape(s){return Unsafe[1].unescape(s)}
    function isNaN(i){return Unsafe[1].isNaN(i) | 0}
    function parseInt(s)
     {var s$0=Unsafe[1].parseInt(s);
      return isNaN(s$0)?caml_call1(Stdlib[2],cst_parseInt):s$0}
    function parseFloat(s)
     {var s$0=Unsafe[1].parseFloat(s);
      return isNaN(s$0)?caml_call1(Stdlib[2],cst_parseFloat):s$0}
    function _a_(param)
     {if(param[1] === Error){var e=param[2];return [0,to_string(e)]}return 0}
    caml_call1(Stdlib_Printexc[9],_a_);
    function _b_(e)
     {return e instanceof array_length
              ?0
              :[0,caml_string_of_jsstring(e.toString())]}
    caml_call1(Stdlib_Printexc[9],_b_);
    function export_js(field,x){return jsoo_exports[field] = x}
    function export$0(field,x)
     {return export_js(caml_jsstring_of_string(field),x)}
    function export_all(obj)
     {var
       t27=object_keys(obj),
       t26=
        caml_js_wrap_callback
         (function(key,param,_gB_){return export_js(key,obj[key])});
      return t27.forEach(t26)}
    var _c_=runtime.caml_js_error_of_exception;
    function _d_(_gA_){return _gA_}
    var
     _e_=
      [0,
       to_string,
       name,
       message,
       stack,
       raise,
       attach_js_backtrace,
       of_exn,
       Error,
       function(_gz_){return _gz_},
       _d_];
    function _f_(_gy_){return _gy_}
    var
     Js_of_ocaml_Js=
      [0,
       no_handler,
       function(_gx_){return _gx_},
       t39,
       _f_,
       Opt,
       Optdef,
       t25,
       t4,
       string_constr,
       t11,
       t11,
       t11,
       object_keys,
       array_length,
       array_length,
       array_get,
       array_set,
       array_map,
       array_mapi,
       str_array,
       match_result,
       t122,
       t122,
       t122,
       t122,
       t122,
       t122,
       t122,
       t122,
       t122,
       math,
       error_constr,
       _e_,
       JSON,
       decodeURI,
       decodeURIComponent,
       encodeURI,
       encodeURIComponent,
       escape,
       unescape,
       isNaN,
       parseInt,
       parseFloat,
       coerce,
       coerce_opt,
       export$0,
       export_all,
       Unsafe,
       string_of_error,
       raise_js_error,
       attach_js_backtrace,
       _c_,
       Error];
    caml_register_global(1642,Js_of_ocaml_Js,"Js_of_ocaml__Js");
    function list_of_nodeList(nodeList)
     {var length=nodeList.length,acc=0,i=0;
      for(;;)
       {if(caml_call2(symbol$5,i,length))
         {var _gw_=nodeList.item(i),match=caml_call1(Opt[10],_gw_);
          if(match)
           {var e=match[1],i$0=i + 1 | 0,acc$0=[0,e,acc],acc=acc$0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}
        return caml_call1(Stdlib_List[9],acc)}}
    var
     disconnected=1,
     preceding=2,
     following=4,
     contains$0=8,
     contained_by=16,
     implementation_specific=32;
    function has(t,mask){return caml_call2(symbol$8,t & mask,mask)}
    function add(x,y){return x | y}
    var
     DocumentPosition=
      [0,
       disconnected,
       preceding,
       following,
       contains$0,
       contained_by,
       implementation_specific,
       has,
       add,
       add];
    function appendChild(p,n){p.appendChild(n);return 0}
    function removeChild(p,n){p.removeChild(n);return 0}
    function replaceChild(p,n,o){p.replaceChild(n,o);return 0}
    function insertBefore(p,n,o){p.insertBefore(n,o);return 0}
    function nodeType(e)
     {var match=e.nodeType;
      if(match)
       switch(match - 1 | 0)
        {case 0:return [0,e];case 1:return [1,e];case 2:case 3:return [2,e]}
      return [3,e]}
    function cast(e,t){return e.nodeType === t?e:no_handler}
    function element(e){return cast(e,1)}
    function text(e)
     {if(3 !== e.nodeType && 4 !== e.nodeType)return no_handler;return e}
    function attr(e){return cast(e,2)}
    function handler(f)
     {return function(e)
       {if(caml_call1(Opt[5],e))
         {var res=caml_call1(f,e);
          if(1 - (res | 0))e.preventDefault();
          return res}
        var t18=event,t17=caml_call1(f,t18);
        if(1 - (t17 | 0))t18.returnValue = t17;
        return t17}}
    function full_handler(f)
     {return runtime.caml_js_wrap_meth_callback_unsafe
              (function(this$0,e)
                {if(caml_call1(Opt[5],e))
                  {var res=caml_call2(f,this$0,e);
                   if(1 - (res | 0))e.preventDefault();
                   return res}
                 var t21=event,t20=caml_call2(f,this$0,t21);
                 if(1 - (t20 | 0))t21.returnValue = t20;
                 return t20})}
    function invoke_handler(f,this$0,event){return f.call(this$0,event)}
    function eventTarget(e)
     {function _gt_(param)
       {function _gv_(param){throw Stdlib[8]}
        return caml_call2(Opt[8],e.srcElement,_gv_)}
      var t27=caml_call2(Opt[8],e.target,_gt_);
      if(t27 instanceof Unsafe[1].Node)
       {if(3 === t27.nodeType)
         {var _gu_=function(param){throw [0,Assert_failure,_g_]};
          return caml_call2(Opt[8],t27.parentNode,_gu_)}
        return t27}
      return t27}
    function make$0(s){return caml_jsstring_of_string(s)}
    var Event=[0,make$0];
    function addEventListenerWithOptions(t50,t47,capture,once,passive,t48)
     {if(t50.addEventListener === t39)
       {var
         t34="on".concat(t47),
         t35=
          function(e)
           {var _gq_=[0,t48,e,[0]];
            return function(_gr_,_gs_)
             {return runtime.caml_js_call(_gq_,_gr_,_gs_)}};
        t50.attachEvent(t34,t35);
        return function(param){return t50.detachEvent(t34,t35)}}
      var t49={};
      function iter(t,f){if(t){var b=t[1];return caml_call1(f,b)}return 0}
      iter(capture,function(t37){return t49.capture = t37});
      iter(once,function(t39){return t49.once = t39});
      iter(passive,function(t41){return t49.passive = t41});
      t50.addEventListener(t47,t48,t49);
      return function(param){return t50.removeEventListener(t47,t48,t49)}}
    function addEventListener(e,typ,h,capt)
     {return addEventListenerWithOptions(e,typ,[0,capt],0,0,h)}
    function removeEventListener(id){return caml_call1(id,0)}
    function preventDefault(t54)
     {if(caml_call1(Optdef[5],t54.preventDefault))return t54.preventDefault();
      var t53=! ! 0;
      return t54.returnValue = t53}
    function createCustomEvent(bubbles,cancelable,detail,t62)
     {function opt_iter(f,param)
       {if(param){var x=param[1];return caml_call1(f,x)}return 0}
      var t63={};
      opt_iter(function(x){var t55=! ! x;return t63.bubbles = t55},bubbles);
      opt_iter
       (function(x){var t57=! ! x;return t63.cancelable = t57},cancelable);
      opt_iter(function(t59){return t63.detail = t59},detail);
      var t64=Unsafe[1].CustomEvent;
      return new t64(t62,t63)}
    var
     Js_of_ocaml_Dom=
      [0,
       DocumentPosition,
       insertBefore,
       replaceChild,
       removeChild,
       appendChild,
       list_of_nodeList,
       nodeType,
       [0,element,text,attr],
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       Event,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       preventDefault,
       createCustomEvent];
    caml_register_global(1645,Js_of_ocaml_Dom,"Js_of_ocaml__Dom");
    var
     arrayBuffer=Unsafe[1].ArrayBuffer,
     int8Array_inBuffer=Unsafe[1].Int8Array,
     t11$0=Unsafe[1].Uint8Array,
     int16Array_inBuffer=Unsafe[1].Int16Array,
     uint16Array_inBuffer=Unsafe[1].Uint16Array,
     int32Array_inBuffer=Unsafe[1].Int32Array,
     uint32Array_inBuffer=Unsafe[1].Uint32Array,
     float32Array_inBuffer=Unsafe[1].Float32Array,
     float64Array_inBuffer=Unsafe[1].Float64Array,
     set=caml_js_set;
    function get$1(a,i){return a[i]}
    function unsafe_get(a,i){return a[i]}
    var dataView=Unsafe[1].DataView;
    function of_arrayBuffer(ab)
     {var uint8=new t11$0(ab);return caml_string_of_array(uint8)}
    var
     Js_of_ocaml_Typed_array=
      [0,
       arrayBuffer,
       runtime.caml_ba_kind_of_typed_array,
       runtime.caml_ba_to_typed_array,
       runtime.caml_ba_from_typed_array,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       t11$0,
       t11$0,
       t11$0,
       t11$0,
       t11$0,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       set,
       get$1,
       unsafe_get,
       dataView,
       dataView,
       [0,
        runtime.bigstring_to_array_buffer,
        runtime.bigstring_to_typed_array,
        runtime.bigstring_of_array_buffer,
        runtime.bigstring_of_typed_array],
       [0,of_arrayBuffer,caml_string_of_array]];
    caml_register_global
     (1646,Js_of_ocaml_Typed_array,"Js_of_ocaml__Typed_array");
    var t3=Unsafe[1].Blob;
    function filter_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function blob_raw(contentType,endings,a)
     {var _gm_=0;
      if(endings)
       var _gn_=116179762 <= endings[1]?_h_:_i_,_go_=_gn_;
      else
       var _go_=0;
      var
       _gp_=[0,[0,cst_type,contentType],[0,[0,cst_endings,_go_],_gm_]],
       options=
        filter_map
         (function(param)
           {var v=param[2],name=param[1];
            if(v)
             {var v$0=v[1];return [0,[0,name,caml_jsstring_of_string(v$0)]]}
            return 0},
          _gp_),
       options$0=
        options
         ?runtime.caml_js_object(caml_call1(Stdlib_Array[12],options))
         :t39,
       t1=caml_js_from_array(a);
      return new t3(t1,options$0)}
    function blob_from_string(contentType,endings,s)
     {return blob_raw(contentType,endings,[0,caml_jsstring_of_string(s)])}
    function blob_from_any(contentType,endings,l)
     {function _gk_(param)
       {var _gl_=param[1];
        if(155580615 === _gl_){var s=param[2];return s}
        if(486041214 <= _gl_)
         {if(1037850489 <= _gl_){var a=param[2];return a}
          var a$0=param[2];
          return a$0}
        if(288368849 <= _gl_)
         {var s$0=param[2];return caml_jsstring_of_string(s$0)}
        var b=param[2];
        return b}
      var l$0=caml_call2(Stdlib_List[19],_gk_,l);
      return blob_raw(contentType,endings,caml_call1(Stdlib_Array[12],l$0))}
    function filename(file)
     {var match=caml_call1(Optdef[10],file.name);
      if(match){var name=match[1];return name}
      var match$0=caml_call1(Optdef[10],file.fileName);
      if(match$0){var name$0=match$0[1];return name$0}
      return caml_call1(Stdlib[2],cst_can_t_retrieve_file_name_n)}
    var doc_constr=Unsafe[1].Document;
    function document(e){return e instanceof doc_constr?e:no_handler}
    function blob(e){return e instanceof t3?e:no_handler}
    function string(e){return typeof e === "string"?e:no_handler}
    function arrayBuffer$0(e){return e instanceof arrayBuffer?e:no_handler}
    var
     loadstart=caml_call1(Event[1],cst_loadstart),
     progress=caml_call1(Event[1],cst_progress),
     abort=caml_call1(Event[1],cst_abort),
     error=caml_call1(Event[1],cst_error),
     load=caml_call1(Event[1],cst_load),
     loadend=caml_call1(Event[1],cst_loadend),
     ReaderEvent=[0,loadstart,progress,abort,error,load,loadend],
     fileReader=Unsafe[1].FileReader,
     Js_of_ocaml_File=
      [0,
       blob_from_string,
       blob_from_any,
       [0,document,blob,function(_gj_){return _gj_},string,arrayBuffer$0],
       ReaderEvent,
       filename,
       fileReader,
       addEventListener];
    caml_register_global(1648,Js_of_ocaml_File,"Js_of_ocaml__File");
    var
     onIE=runtime.caml_js_on_ie(0) | 0,
     click=caml_call1(Event[1],cst_click),
     copy$0=caml_call1(Event[1],cst_copy),
     cut=caml_call1(Event[1],cst_cut),
     paste=caml_call1(Event[1],cst_paste),
     dblclick=caml_call1(Event[1],cst_dblclick),
     mousedown=caml_call1(Event[1],cst_mousedown),
     mouseup=caml_call1(Event[1],cst_mouseup),
     mouseover=caml_call1(Event[1],cst_mouseover),
     mousemove=caml_call1(Event[1],cst_mousemove),
     mouseout=caml_call1(Event[1],cst_mouseout),
     keypress=caml_call1(Event[1],cst_keypress),
     keydown=caml_call1(Event[1],cst_keydown),
     keyup=caml_call1(Event[1],cst_keyup),
     mousewheel=caml_call1(Event[1],cst_mousewheel),
     DOMMouseScroll=caml_call1(Event[1],cst_DOMMouseScroll),
     touchstart=caml_call1(Event[1],cst_touchstart),
     touchmove=caml_call1(Event[1],cst_touchmove),
     touchend=caml_call1(Event[1],cst_touchend),
     touchcancel=caml_call1(Event[1],cst_touchcancel),
     dragstart=caml_call1(Event[1],cst_dragstart),
     dragend=caml_call1(Event[1],cst_dragend),
     dragenter=caml_call1(Event[1],cst_dragenter),
     dragover=caml_call1(Event[1],cst_dragover),
     dragleave=caml_call1(Event[1],cst_dragleave),
     drag=caml_call1(Event[1],cst_drag),
     drop=caml_call1(Event[1],cst_drop),
     hashchange=caml_call1(Event[1],cst_hashchange),
     change=caml_call1(Event[1],cst_change),
     input=caml_call1(Event[1],cst_input),
     timeupdate=caml_call1(Event[1],cst_timeupdate),
     submit=caml_call1(Event[1],cst_submit),
     scroll=caml_call1(Event[1],cst_scroll),
     focus=caml_call1(Event[1],cst_focus),
     blur=caml_call1(Event[1],cst_blur),
     load$0=caml_call1(Event[1],cst_load$0),
     unload=caml_call1(Event[1],cst_unload),
     beforeunload=caml_call1(Event[1],cst_beforeunload),
     resize=caml_call1(Event[1],cst_resize),
     orientationchange=caml_call1(Event[1],cst_orientationchange),
     popstate=caml_call1(Event[1],cst_popstate),
     error$0=caml_call1(Event[1],cst_error$0),
     abort$0=caml_call1(Event[1],cst_abort$0),
     select=caml_call1(Event[1],cst_select),
     online=caml_call1(Event[1],cst_online),
     offline=caml_call1(Event[1],cst_offline),
     checking=caml_call1(Event[1],cst_checking),
     noupdate=caml_call1(Event[1],cst_noupdate),
     downloading=caml_call1(Event[1],cst_downloading),
     progress$0=caml_call1(Event[1],cst_progress$0),
     updateready=caml_call1(Event[1],cst_updateready),
     cached=caml_call1(Event[1],cst_cached),
     obsolete=caml_call1(Event[1],cst_obsolete),
     domContentLoaded=caml_call1(Event[1],cst_DOMContentLoaded),
     animationstart=caml_call1(Event[1],cst_animationstart),
     animationend=caml_call1(Event[1],cst_animationend),
     animationiteration=caml_call1(Event[1],cst_animationiteration),
     animationcancel=caml_call1(Event[1],cst_animationcancel),
     canplay=caml_call1(Event[1],cst_canplay),
     canplaythrough=caml_call1(Event[1],cst_canplaythrough),
     durationchange=caml_call1(Event[1],cst_durationchange),
     emptied=caml_call1(Event[1],cst_emptied),
     ended=caml_call1(Event[1],cst_ended),
     gotpointercapture=caml_call1(Event[1],cst_gotpointercapture),
     loadeddata=caml_call1(Event[1],cst_loadeddata),
     loadedmetadata=caml_call1(Event[1],cst_loadedmetadata),
     loadstart$0=caml_call1(Event[1],cst_loadstart$0),
     lostpointercapture=caml_call1(Event[1],cst_lostpointercapture),
     message$0=caml_call1(Event[1],cst_message),
     pause=caml_call1(Event[1],cst_pause),
     play=caml_call1(Event[1],cst_play),
     playing=caml_call1(Event[1],cst_playing),
     pointerenter=caml_call1(Event[1],cst_pointerenter),
     pointercancel=caml_call1(Event[1],cst_pointercancel),
     pointerdown=caml_call1(Event[1],cst_pointerdown),
     pointerleave=caml_call1(Event[1],cst_pointerleave),
     pointermove=caml_call1(Event[1],cst_pointermove),
     pointerout=caml_call1(Event[1],cst_pointerout),
     pointerover=caml_call1(Event[1],cst_pointerover),
     pointerup=caml_call1(Event[1],cst_pointerup),
     ratechange=caml_call1(Event[1],cst_ratechange),
     seeked=caml_call1(Event[1],cst_seeked),
     seeking=caml_call1(Event[1],cst_seeking),
     stalled=caml_call1(Event[1],cst_stalled),
     suspend=caml_call1(Event[1],cst_suspend),
     volumechange=caml_call1(Event[1],cst_volumechange),
     waiting=caml_call1(Event[1],cst_waiting),
     make$1=Event[1],
     Event$0=
      [0,
       click,
       copy$0,
       cut,
       paste,
       dblclick,
       mousedown,
       mouseup,
       mouseover,
       mousemove,
       mouseout,
       keypress,
       keydown,
       keyup,
       mousewheel,
       DOMMouseScroll,
       touchstart,
       touchmove,
       touchend,
       touchcancel,
       dragstart,
       dragend,
       dragenter,
       dragover,
       dragleave,
       drag,
       drop,
       hashchange,
       change,
       input,
       timeupdate,
       submit,
       scroll,
       focus,
       blur,
       load$0,
       unload,
       beforeunload,
       resize,
       orientationchange,
       popstate,
       error$0,
       abort$0,
       select,
       online,
       offline,
       checking,
       noupdate,
       downloading,
       progress$0,
       updateready,
       cached,
       obsolete,
       domContentLoaded,
       animationstart,
       animationend,
       animationiteration,
       animationcancel,
       canplay,
       canplaythrough,
       durationchange,
       emptied,
       ended,
       gotpointercapture,
       loadeddata,
       loadedmetadata,
       loadstart$0,
       lostpointercapture,
       message$0,
       pause,
       play,
       playing,
       pointerenter,
       pointercancel,
       pointerdown,
       pointerleave,
       pointermove,
       pointerout,
       pointerover,
       pointerup,
       ratechange,
       seeked,
       seeking,
       stalled,
       suspend,
       volumechange,
       waiting,
       make$1],
     d="2d";
    function location_origin(loc)
     {function _gh_(o){return o}
      function _gi_(param)
       {var t8=loc.protocol,t7=loc.hostname,t9=loc.port;
        if
         (caml_call2(symbol$8,t8.length,0)
          &&
          caml_call2(symbol$8,t7.length,0))
         return "";
        var t13=t8.concat("//",t7);
        if(caml_call2(symbol$9,t9.length,0))
         {var t12=loc.port;return t13.concat(":",t12)}
        return t13}
      return caml_call3(Optdef[7],loc.origin,_gi_,_gh_)}
    var _j_=Unsafe[1],t87=_j_.document;
    function getElementById(id)
     {function _ge_(pnode){return pnode}
      function _gf_(param){throw Stdlib[8]}
      var t15=caml_jsstring_of_string(id),_gg_=t87.getElementById(t15);
      return caml_call3(Opt[7],_gg_,_gf_,_ge_)}
    function getElementById_exn(id)
     {function _ga_(pnode){return pnode}
      function _gb_(param)
       {var _gd_=caml_call2(Stdlib_Printf[4],_k_,id);
        return caml_call1(Stdlib[2],_gd_)}
      var t17=caml_jsstring_of_string(id),_gc_=t87.getElementById(t17);
      return caml_call3(Opt[7],_gc_,_gb_,_ga_)}
    function getElementById_opt(id)
     {var t19=caml_jsstring_of_string(id),_f$_=t87.getElementById(t19);
      return caml_call1(Opt[10],_f$_)}
    function getElementById_coerce(id,coerce)
     {function _f7_(e)
       {var _f__=caml_call1(coerce,e);return caml_call1(Opt[10],_f__)}
      function _f8_(param){return 0}
      var t21=caml_jsstring_of_string(id),_f9_=t87.getElementById(t21);
      return caml_call3(Opt[7],_f9_,_f8_,_f7_)}
    function opt_iter(x,f){if(x){var v=x[1];return caml_call1(f,v)}return 0}
    function createElement(t24,name)
     {var t23=caml_jsstring_of_string(name);return t24.createElement(t23)}
    function unsafeCreateElement(doc,name){return createElement(doc,name)}
    var createElementSyntax=[0,785140586];
    function unsafeCreateElementEx(type,name,doc,elt)
     {for(;;)
       {if(0 === type && 0 === name)return createElement(doc,elt);
        var _f1_=createElementSyntax[1];
        if(785140586 === _f1_)
         {try
           {var
             el=t87.createElement('<input name="x">'),
             _f4_=el.tagName.toLowerCase() === "input"?1:0,
             _f5_=_f4_?el.name === "x"?1:0:_f4_,
             _f2_=_f5_}
          catch(_f6_){var _f2_=0}
          var _f3_=_f2_?982028505:-1003883683;
          createElementSyntax[1] = _f3_;
          continue}
        if(982028505 <= _f1_)
         {var t40=new array_length();
          t40.push("<",caml_jsstring_of_string(elt));
          opt_iter
           (type,
            function(t)
             {var t34=caml_js_html_escape(t);
              t40.push(' type="',t34,'"');
              return 0});
          opt_iter
           (name,
            function(n)
             {var t38=caml_js_html_escape(n);
              t40.push(' name="',t38,'"');
              return 0});
          t40.push(">");
          return doc.createElement(t40.join(""))}
        var t28=createElement(doc,elt);
        opt_iter(type,function(t25){return t28.type = t25});
        opt_iter(name,function(t27){return t28.name = t27});
        return t28}}
    function createHtml(doc){return unsafeCreateElement(doc,cst_html)}
    function createHead(doc){return unsafeCreateElement(doc,cst_head)}
    function createLink(doc){return unsafeCreateElement(doc,cst_link)}
    function createTitle(doc){return unsafeCreateElement(doc,cst_title)}
    function createMeta(doc){return unsafeCreateElement(doc,cst_meta)}
    function createBase(doc){return unsafeCreateElement(doc,cst_base)}
    function createStyle(doc){return unsafeCreateElement(doc,cst_style)}
    function createBody(doc){return unsafeCreateElement(doc,cst_body)}
    function createForm(doc){return unsafeCreateElement(doc,cst_form)}
    function createOptgroup(doc){return unsafeCreateElement(doc,cst_optgroup)}
    function createOption(doc){return unsafeCreateElement(doc,cst_option)}
    function createSelect(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_select$0)}
    function createInput(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_input$0)}
    function createTextarea(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_textarea)}
    function createButton(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_button)}
    function createLabel(doc){return unsafeCreateElement(doc,cst_label)}
    function createFieldset(doc){return unsafeCreateElement(doc,cst_fieldset)}
    function createLegend(doc){return unsafeCreateElement(doc,cst_legend)}
    function createUl(doc){return unsafeCreateElement(doc,cst_ul)}
    function createOl(doc){return unsafeCreateElement(doc,cst_ol)}
    function createDl(doc){return unsafeCreateElement(doc,cst_dl)}
    function createLi(doc){return unsafeCreateElement(doc,cst_li)}
    function createDiv(doc){return unsafeCreateElement(doc,cst_div)}
    function createEmbed(doc){return unsafeCreateElement(doc,cst_embed)}
    function createP(doc){return unsafeCreateElement(doc,cst_p)}
    function createH1(doc){return unsafeCreateElement(doc,cst_h1)}
    function createH2(doc){return unsafeCreateElement(doc,cst_h2)}
    function createH3(doc){return unsafeCreateElement(doc,cst_h3)}
    function createH4(doc){return unsafeCreateElement(doc,cst_h4)}
    function createH5(doc){return unsafeCreateElement(doc,cst_h5)}
    function createH6(doc){return unsafeCreateElement(doc,cst_h6)}
    function createQ(doc){return unsafeCreateElement(doc,cst_q)}
    function createBlockquote(doc)
     {return unsafeCreateElement(doc,cst_blockquote)}
    function createPre(doc){return unsafeCreateElement(doc,cst_pre)}
    function createBr(doc){return unsafeCreateElement(doc,cst_br)}
    function createHr(doc){return unsafeCreateElement(doc,cst_hr)}
    function createIns(doc){return unsafeCreateElement(doc,cst_ins)}
    function createDel(doc){return unsafeCreateElement(doc,cst_del)}
    function createA(doc){return unsafeCreateElement(doc,cst_a)}
    function createImg(doc){return unsafeCreateElement(doc,cst_img)}
    function createObject(doc){return unsafeCreateElement(doc,cst_object)}
    function createParam(doc){return unsafeCreateElement(doc,cst_param)}
    function createMap(doc){return unsafeCreateElement(doc,cst_map)}
    function createArea(doc){return unsafeCreateElement(doc,cst_area)}
    function createScript(doc){return unsafeCreateElement(doc,cst_script)}
    function createTable(doc){return unsafeCreateElement(doc,cst_table)}
    function createCaption(doc){return unsafeCreateElement(doc,cst_caption)}
    function createCol(doc){return unsafeCreateElement(doc,cst_col)}
    function createColgroup(doc){return unsafeCreateElement(doc,cst_colgroup)}
    function createThead(doc){return unsafeCreateElement(doc,cst_thead)}
    function createTfoot(doc){return unsafeCreateElement(doc,cst_tfoot)}
    function createTbody(doc){return unsafeCreateElement(doc,cst_tbody)}
    function createTr(doc){return unsafeCreateElement(doc,cst_tr)}
    function createTh(doc){return unsafeCreateElement(doc,cst_th)}
    function createTd(doc){return unsafeCreateElement(doc,cst_td)}
    function createSub(doc){return createElement(doc,cst_sub)}
    function createSup(doc){return createElement(doc,cst_sup)}
    function createSpan(doc){return createElement(doc,cst_span)}
    function createTt(doc){return createElement(doc,cst_tt)}
    function createI(doc){return createElement(doc,cst_i)}
    function createB(doc){return createElement(doc,cst_b)}
    function createBig(doc){return createElement(doc,cst_big)}
    function createSmall(doc){return createElement(doc,cst_small)}
    function createEm(doc){return createElement(doc,cst_em)}
    function createStrong(doc){return createElement(doc,cst_strong)}
    function createCite(doc){return createElement(doc,cst_cite)}
    function createDfn(doc){return createElement(doc,cst_dfn)}
    function createCode(doc){return createElement(doc,cst_code)}
    function createSamp(doc){return createElement(doc,cst_samp)}
    function createKbd(doc){return createElement(doc,cst_kbd)}
    function createVar(doc){return createElement(doc,cst_var)}
    function createAbbr(doc){return createElement(doc,cst_abbr)}
    function createDd(doc){return createElement(doc,cst_dd)}
    function createDt(doc){return createElement(doc,cst_dt)}
    function createNoscript(doc){return createElement(doc,cst_noscript)}
    function createAddress(doc){return createElement(doc,cst_address)}
    function createFrameset(doc){return unsafeCreateElement(doc,cst_frameset)}
    function createFrame(doc){return unsafeCreateElement(doc,cst_frame)}
    function createIframe(doc){return unsafeCreateElement(doc,cst_iframe)}
    function createAudio(doc){return unsafeCreateElement(doc,cst_audio)}
    function createVideo(doc){return unsafeCreateElement(doc,cst_video)}
    var
     Canvas_not_available=
      [248,cst_Js_of_ocaml_Dom_html_Canva,caml_fresh_oo_id(0)];
    function createCanvas(doc)
     {var t52=unsafeCreateElement(doc,cst_canvas);
      if(1 - caml_call1(Opt[5],t52.getContext))throw Canvas_not_available;
      return t52}
    var
     html_element=Unsafe[1].HTMLElement,
     element$0=
      html_element === t39
       ?function(e){return e.innerHTML === t39?no_handler:e}
       :function(e){return e instanceof html_element?e:no_handler};
    function unsafeCoerce(tag,e)
     {var t56=e.tagName,_f0_=caml_jsstring_of_string(tag);
      return t56.toLowerCase() === _f0_?e:no_handler}
    function a(e){return unsafeCoerce(cst_a$0,e)}
    function area(e){return unsafeCoerce(cst_area$0,e)}
    function base(e){return unsafeCoerce(cst_base$0,e)}
    function blockquote(e){return unsafeCoerce(cst_blockquote$0,e)}
    function body(e){return unsafeCoerce(cst_body$0,e)}
    function br(e){return unsafeCoerce(cst_br$0,e)}
    function button(e){return unsafeCoerce(cst_button$0,e)}
    function canvas(e){return unsafeCoerce(cst_canvas$0,e)}
    function caption(e){return unsafeCoerce(cst_caption$0,e)}
    function col(e){return unsafeCoerce(cst_col$0,e)}
    function colgroup(e){return unsafeCoerce(cst_colgroup$0,e)}
    function del(e){return unsafeCoerce(cst_del$0,e)}
    function div(e){return unsafeCoerce(cst_div$0,e)}
    function dl(e){return unsafeCoerce(cst_dl$0,e)}
    function fieldset(e){return unsafeCoerce(cst_fieldset$0,e)}
    function embed(e){return unsafeCoerce(cst_embed$0,e)}
    function form(e){return unsafeCoerce(cst_form$0,e)}
    function frameset(e){return unsafeCoerce(cst_frameset$0,e)}
    function frame(e){return unsafeCoerce(cst_frame$0,e)}
    function h1(e){return unsafeCoerce(cst_h1$0,e)}
    function h2(e){return unsafeCoerce(cst_h2$0,e)}
    function h3(e){return unsafeCoerce(cst_h3$0,e)}
    function h4(e){return unsafeCoerce(cst_h4$0,e)}
    function h5(e){return unsafeCoerce(cst_h5$0,e)}
    function h6(e){return unsafeCoerce(cst_h6$0,e)}
    function head(e){return unsafeCoerce(cst_head$0,e)}
    function hr(e){return unsafeCoerce(cst_hr$0,e)}
    function html(e){return unsafeCoerce(cst_html$0,e)}
    function iframe(e){return unsafeCoerce(cst_iframe$0,e)}
    function img(e){return unsafeCoerce(cst_img$0,e)}
    function input$0(e){return unsafeCoerce(cst_input$1,e)}
    function ins(e){return unsafeCoerce(cst_ins$0,e)}
    function label(e){return unsafeCoerce(cst_label$0,e)}
    function legend(e){return unsafeCoerce(cst_legend$0,e)}
    function li(e){return unsafeCoerce(cst_li$0,e)}
    function link(e){return unsafeCoerce(cst_link$0,e)}
    function map$2(e){return unsafeCoerce(cst_map$0,e)}
    function meta(e){return unsafeCoerce(cst_meta$0,e)}
    function object(e){return unsafeCoerce(cst_object$0,e)}
    function ol(e){return unsafeCoerce(cst_ol$0,e)}
    function optgroup(e){return unsafeCoerce(cst_optgroup$0,e)}
    function option$1(e){return unsafeCoerce(cst_option$0,e)}
    function p(e){return unsafeCoerce(cst_p$0,e)}
    function param(e){return unsafeCoerce(cst_param$0,e)}
    function pre(e){return unsafeCoerce(cst_pre$0,e)}
    function q(e){return unsafeCoerce(cst_q$0,e)}
    function script(e){return unsafeCoerce(cst_script$0,e)}
    function select$0(e){return unsafeCoerce(cst_select$1,e)}
    function style(e){return unsafeCoerce(cst_style$0,e)}
    function table(e){return unsafeCoerce(cst_table$0,e)}
    function tbody(e){return unsafeCoerce(cst_tbody$0,e)}
    function td(e){return unsafeCoerce(cst_td$0,e)}
    function textarea(e){return unsafeCoerce(cst_textarea$0,e)}
    function tfoot(e){return unsafeCoerce(cst_tfoot$0,e)}
    function th(e){return unsafeCoerce(cst_th$0,e)}
    function thead(e){return unsafeCoerce(cst_thead$0,e)}
    function title(e){return unsafeCoerce(cst_title$0,e)}
    function tr(e){return unsafeCoerce(cst_tr$0,e)}
    function ul(e){return unsafeCoerce(cst_ul$0,e)}
    function audio(e){return unsafeCoerce(cst_audio$0,e)}
    function video(e){return unsafeCoerce(cst_video$0,e)}
    function unsafeCoerceEvent(constr,ev)
     {if(constr !== t39 && ev instanceof constr)return ev;return no_handler}
    function mouseEvent(ev){return unsafeCoerceEvent(Unsafe[1].MouseEvent,ev)}
    function keyboardEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].KeyboardEvent,ev)}
    function wheelEvent(ev){return unsafeCoerceEvent(Unsafe[1].WheelEvent,ev)}
    function mouseScrollEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].MouseScrollEvent,ev)}
    function popStateEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].PopStateEvent,ev)}
    function messageEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].MessageEvent,ev)}
    function eventRelatedTarget(e)
     {function _fX_(param)
       {var match=caml_string_of_jsstring(e.type);
        if(caml_string_notequal(match,cst_mouseout$0))
         {if(caml_string_notequal(match,cst_mouseover$0))return no_handler;
          var _fY_=function(param){throw [0,Assert_failure,_l_]};
          return caml_call2(Optdef[8],e.fromElement,_fY_)}
        function _fZ_(param){throw [0,Assert_failure,_m_]}
        return caml_call2(Optdef[8],e.toElement,_fZ_)}
      return caml_call2(Optdef[8],e.relatedTarget,_fX_)}
    function eventAbsolutePosition(e)
     {var t70=t87.body,t71=t87.documentElement;
      return [0,
              (e.clientX + t70.scrollLeft | 0) + t71.scrollLeft | 0,
              (e.clientY + t70.scrollTop | 0) + t71.scrollTop | 0]}
    function eventAbsolutePosition$0(e)
     {function _fT_(x)
       {function _fV_(y){return [0,x,y]}
        function _fW_(param){return eventAbsolutePosition(e)}
        return caml_call3(Optdef[7],e.pageY,_fW_,_fV_)}
      function _fU_(param){return eventAbsolutePosition(e)}
      return caml_call3(Optdef[7],e.pageX,_fU_,_fT_)}
    function elementClientPosition(e)
     {var t80=e.getBoundingClientRect(),t81=t87.body,t82=t87.documentElement;
      return [0,
              ((t80.left | 0) - t81.clientLeft | 0) - t82.clientLeft | 0,
              ((t80.top | 0) - t81.clientTop | 0) - t82.clientTop | 0]}
    function getDocumentScroll(param)
     {var t88=t87.body,t89=t87.documentElement;
      return [0,
              t88.scrollLeft + t89.scrollLeft | 0,
              t88.scrollTop + t89.scrollTop | 0]}
    function buttonPressed(ev)
     {function _fR_(x){return x}
      function _fS_(param)
       {var match=ev.button,switcher=match - 1 | 0;
        if(! (3 < switcher >>> 0))
         switch(switcher)
          {case 0:return 1;case 1:return 3;case 2:break;default:return 2}
        return 0}
      return caml_call3(Optdef[7],ev.which,_fS_,_fR_)}
    function addMousewheelEventListenerWith(e,capture,once,passive,h)
     {var t96=createDiv(t87);
      t96.setAttribute("onmousewheel","return;");
      if(typeof t96.onmousewheel === "function")
       {var
         _fN_=
          handler
           (function(e)
             {function _fP_(param){return 0}
              var
               dx=
                (- caml_call2(Optdef[8],e.wheelDeltaX,_fP_) | 0) / 40 | 0;
              function _fQ_(param){return e.wheelDelta}
              var
               dy=
                (- caml_call2(Optdef[8],e.wheelDeltaY,_fQ_) | 0) / 40 | 0;
              return caml_call3(h,e,dx,dy)});
        return addEventListenerWithOptions
                (e,Event$0[14],capture,once,passive,_fN_)}
      var
       _fO_=
        handler
         (function(e)
           {var d=e.detail;
            return e.axis === e.HORIZONTAL
                    ?caml_call3(h,e,d,0)
                    :caml_call3(h,e,0,d)});
      return addEventListenerWithOptions
              (e,Event$0[15],capture,once,passive,_fO_)}
    function addMousewheelEventListener(e,h,capt)
     {return addMousewheelEventListenerWith(e,[0,capt],0,0,h)}
    function f(v)
     {var
       match=caml_string_of_jsstring(v),
       switch$0=caml_string_compare(match,cst_KeyH);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 8;
        var switch$1=caml_string_compare(match,cst_Numpad4);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 72;
          var switch$2=caml_string_compare(match,cst_PageUp);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 98;
            var switch$3=caml_string_compare(match,cst_ShiftRight);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 91;
              if(! caml_string_notequal(match,cst_Slash))return 55;
              if(! caml_string_notequal(match,cst_Space))return 41;
              if(! caml_string_notequal(match,cst_Tab))return 39;
              if(! caml_string_notequal(match,cst_VolumeDown))return 103;
              if(! caml_string_notequal(match,cst_VolumeMute))return 102;
              if(! caml_string_notequal(match,cst_VolumeUp))return 104}
            else
             {if(! caml_string_notequal(match,cst_Pause))return 123;
              if(! caml_string_notequal(match,cst_Period))return 54;
              if(! caml_string_notequal(match,cst_PrintScreen))return 120;
              if(! caml_string_notequal(match,cst_Quote))return 50;
              if(! caml_string_notequal(match,cst_ScrollLock))return 119;
              if(! caml_string_notequal(match,cst_Semicolon))return 49;
              if(! caml_string_notequal(match,cst_ShiftLeft))return 90}}
          else
           {var switch$4=caml_string_compare(match,cst_NumpadDivide);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 84;
              if(! caml_string_notequal(match,cst_NumpadEnter))return 83;
              if(! caml_string_notequal(match,cst_NumpadEqual))return 82;
              if(! caml_string_notequal(match,cst_NumpadMultiply))return 78;
              if(! caml_string_notequal(match,cst_NumpadSubtract))return 79;
              if(! caml_string_notequal(match,cst_OSLeft))return 117;
              if(! caml_string_notequal(match,cst_OSRight))return 118;
              if(! caml_string_notequal(match,cst_PageDown))return 99}
            else
             {if(! caml_string_notequal(match,cst_Numpad5))return 73;
              if(! caml_string_notequal(match,cst_Numpad6))return 74;
              if(! caml_string_notequal(match,cst_Numpad7))return 75;
              if(! caml_string_notequal(match,cst_Numpad8))return 76;
              if(! caml_string_notequal(match,cst_Numpad9))return 77;
              if(! caml_string_notequal(match,cst_NumpadAdd))return 80;
              if(! caml_string_notequal(match,cst_NumpadDecimal))return 81}}}
        else
         {var switch$5=caml_string_compare(match,cst_KeyX);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 24;
            var switch$6=caml_string_compare(match,cst_MetaRight);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 89;
              if(! caml_string_notequal(match,cst_Minus))return 37;
              if(! caml_string_notequal(match,cst_NumLock))return 85;
              if(! caml_string_notequal(match,cst_Numpad0))return 68;
              if(! caml_string_notequal(match,cst_Numpad1))return 69;
              if(! caml_string_notequal(match,cst_Numpad2))return 70;
              if(! caml_string_notequal(match,cst_Numpad3))return 71}
            else
             {if(! caml_string_notequal(match,cst_KeyY))return 25;
              if(! caml_string_notequal(match,cst_KeyZ))return 26;
              if(! caml_string_notequal(match,cst_MediaPlayPause))return 107;
              if(! caml_string_notequal(match,cst_MediaStop))return 108;
              if(! caml_string_notequal(match,cst_MediaTrackNext))return 106;
              if(! caml_string_notequal(match,cst_MediaTrackPrevious))
               return 105;
              if(! caml_string_notequal(match,cst_MetaLeft))return 88}}
          else
           {var switch$7=caml_string_compare(match,cst_KeyP);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 16;
              if(! caml_string_notequal(match,cst_KeyQ))return 17;
              if(! caml_string_notequal(match,cst_KeyR))return 18;
              if(! caml_string_notequal(match,cst_KeyS))return 19;
              if(! caml_string_notequal(match,cst_KeyT))return 20;
              if(! caml_string_notequal(match,cst_KeyU))return 21;
              if(! caml_string_notequal(match,cst_KeyV))return 22;
              if(! caml_string_notequal(match,cst_KeyW))return 23}
            else
             {if(! caml_string_notequal(match,cst_KeyI))return 9;
              if(! caml_string_notequal(match,cst_KeyJ))return 10;
              if(! caml_string_notequal(match,cst_KeyK))return 11;
              if(! caml_string_notequal(match,cst_KeyL))return 12;
              if(! caml_string_notequal(match,cst_KeyM))return 13;
              if(! caml_string_notequal(match,cst_KeyN))return 14;
              if(! caml_string_notequal(match,cst_KeyO))return 15}}}}
      else
       {var switch$8=caml_string_compare(match,cst_Digit6);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 33;
          var switch$9=caml_string_compare(match,cst_F6);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 61;
            var switch$10=caml_string_compare(match,cst_KeyA);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 1;
              if(! caml_string_notequal(match,cst_KeyB))return 2;
              if(! caml_string_notequal(match,cst_KeyC))return 3;
              if(! caml_string_notequal(match,cst_KeyD))return 4;
              if(! caml_string_notequal(match,cst_KeyE))return 5;
              if(! caml_string_notequal(match,cst_KeyF))return 6;
              if(! caml_string_notequal(match,cst_KeyG))return 7}
            else
             {if(! caml_string_notequal(match,cst_F7))return 62;
              if(! caml_string_notequal(match,cst_F8))return 63;
              if(! caml_string_notequal(match,cst_F9))return 64;
              if(! caml_string_notequal(match,cst_Home))return 100;
              if(! caml_string_notequal(match,cst_Insert))return 44;
              if(! caml_string_notequal(match,cst_IntlBackslash))return 121;
              if(! caml_string_notequal(match,cst_IntlYen))return 122}}
          else
           {var switch$11=caml_string_compare(match,cst_F1);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 56;
              if(! caml_string_notequal(match,cst_F10))return 65;
              if(! caml_string_notequal(match,cst_F11))return 66;
              if(! caml_string_notequal(match,cst_F12))return 67;
              if(! caml_string_notequal(match,cst_F2))return 57;
              if(! caml_string_notequal(match,cst_F3))return 58;
              if(! caml_string_notequal(match,cst_F4))return 59;
              if(! caml_string_notequal(match,cst_F5))return 60}
            else
             {if(! caml_string_notequal(match,cst_Digit7))return 34;
              if(! caml_string_notequal(match,cst_Digit8))return 35;
              if(! caml_string_notequal(match,cst_Digit9))return 36;
              if(! caml_string_notequal(match,cst_End))return 101;
              if(! caml_string_notequal(match,cst_Enter))return 40;
              if(! caml_string_notequal(match,cst_Equal))return 38;
              if(! caml_string_notequal(match,cst_Escape))return 42}}}
        else
         {var switch$12=caml_string_compare(match,cst_BrowserRefresh);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 113;
            var switch$13=caml_string_compare(match,cst_Delete);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 45;
              if(! caml_string_notequal(match,cst_Digit0))return 27;
              if(! caml_string_notequal(match,cst_Digit1))return 28;
              if(! caml_string_notequal(match,cst_Digit2))return 29;
              if(! caml_string_notequal(match,cst_Digit3))return 30;
              if(! caml_string_notequal(match,cst_Digit4))return 31;
              if(! caml_string_notequal(match,cst_Digit5))return 32}
            else
             {if(! caml_string_notequal(match,cst_BrowserSearch))return 110;
              if(! caml_string_notequal(match,cst_BrowserStop))return 114;
              if(! caml_string_notequal(match,cst_CapsLock))return 46;
              if(! caml_string_notequal(match,cst_Comma))return 53;
              if(! caml_string_notequal(match,cst_ContextMenu))return 109;
              if(! caml_string_notequal(match,cst_ControlLeft))return 86;
              if(! caml_string_notequal(match,cst_ControlRight))return 87}}
          else
           {var switch$14=caml_string_compare(match,cst_Backslash);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 52;
              if(! caml_string_notequal(match,cst_Backspace))return 43;
              if(! caml_string_notequal(match,cst_BracketLeft))return 47;
              if(! caml_string_notequal(match,cst_BracketRight))return 48;
              if(! caml_string_notequal(match,cst_BrowserBack))return 116;
              if(! caml_string_notequal(match,cst_BrowserFavorites))
               return 112;
              if(! caml_string_notequal(match,cst_BrowserForward))return 115;
              if(! caml_string_notequal(match,cst_BrowserHome))return 111}
            else
             {if(! caml_string_notequal(match,cst_AltLeft))return 92;
              if(! caml_string_notequal(match,cst_AltRight))return 93;
              if(! caml_string_notequal(match,cst_ArrowDown))return 97;
              if(! caml_string_notequal(match,cst_ArrowLeft))return 94;
              if(! caml_string_notequal(match,cst_ArrowRight))return 95;
              if(! caml_string_notequal(match,cst_ArrowUp))return 96;
              if(! caml_string_notequal(match,cst_Backquote))return 51}}}}
      return 0}
    function try_key_code_left(param)
     {if(19 <= param)
       {if(91 === param)return 88}
      else
       if(16 <= param)
        switch(param - 16 | 0)
         {case 0:return 90;case 1:return 86;default:return 92}
      return 0}
    function try_key_code_right(param)
     {if(19 <= param)
       {if(91 === param)return 89}
      else
       if(16 <= param)
        switch(param - 16 | 0)
         {case 0:return 91;case 1:return 87;default:return 93}
      return 0}
    function try_key_code_numpad(param)
     {if(47 <= param)
       {var switcher=param - 96 | 0;
        if(! (15 < switcher >>> 0))
         switch(switcher)
          {case 0:return 68;
           case 1:return 69;
           case 2:return 70;
           case 3:return 71;
           case 4:return 72;
           case 5:return 73;
           case 6:return 74;
           case 7:return 75;
           case 8:return 76;
           case 9:return 77;
           case 10:return 78;
           case 11:return 80;
           case 12:break;
           case 13:return 79;
           case 14:return 81;
           default:return 84}}
      else
       if(12 <= param)
        switch(param - 12 | 0)
         {case 0:return 73;
          case 1:return 83;
          case 21:return 77;
          case 22:return 71;
          case 23:return 69;
          case 24:return 75;
          case 25:return 72;
          case 26:return 76;
          case 27:return 74;
          case 28:return 70;
          case 33:return 68;
          case 34:return 81
          }
      return 0}
    function try_key_code_normal(param)
     {var switcher=param - 8 | 0;
      if(! (214 < switcher >>> 0))
       {var _fM_=switcher;
        if(67 <= _fM_)
         switch(_fM_)
          {case 67:return 11;
           case 68:return 12;
           case 69:return 13;
           case 70:return 14;
           case 71:return 15;
           case 72:return 16;
           case 73:return 17;
           case 74:return 18;
           case 75:return 19;
           case 76:return 20;
           case 77:return 21;
           case 78:return 22;
           case 79:return 23;
           case 80:return 24;
           case 81:return 25;
           case 82:return 26;
           case 85:return 109;
           case 104:return 56;
           case 105:return 57;
           case 106:return 58;
           case 107:return 59;
           case 108:return 60;
           case 109:return 61;
           case 110:return 62;
           case 111:return 63;
           case 112:return 64;
           case 113:return 65;
           case 114:return 66;
           case 115:return 67;
           case 137:return 119;
           case 178:return 49;
           case 179:return 38;
           case 180:return 53;
           case 181:return 37;
           case 182:return 54;
           case 183:return 55;
           case 184:return 51;
           case 211:return 47;
           case 212:return 52;
           case 213:return 48;
           case 214:return 50
           }
        else
         switch(_fM_)
          {case 0:return 43;
           case 1:return 39;
           case 5:return 40;
           case 11:return 123;
           case 12:return 46;
           case 19:return 42;
           case 24:return 41;
           case 25:return 98;
           case 26:return 99;
           case 27:return 101;
           case 28:return 100;
           case 29:return 94;
           case 30:return 96;
           case 31:return 95;
           case 32:return 97;
           case 34:return 120;
           case 37:return 44;
           case 38:return 45;
           case 40:return 27;
           case 41:return 28;
           case 42:return 29;
           case 43:return 30;
           case 44:return 31;
           case 45:return 32;
           case 46:return 33;
           case 47:return 34;
           case 48:return 35;
           case 49:return 36;
           case 57:return 1;
           case 58:return 2;
           case 59:return 3;
           case 60:return 4;
           case 61:return 5;
           case 62:return 6;
           case 63:return 7;
           case 64:return 8;
           case 65:return 9;
           case 66:return 10
           }}
      return 0}
    function make_unidentified(param){return 0}
    function run_next(value,f,v){return v?v:caml_call1(f,value)}
    function symbol$11(x,f){return caml_call1(f,x)}
    function of_event(evt)
     {var _fF_=evt.keyCode;
      function _fG_(_fL_){return run_next(_fF_,try_key_code_normal,_fL_)}
      var match=evt.location,switcher=match - 1 | 0;
      if(2 < switcher >>> 0)
       var _fH_=make_unidentified;
      else
       switch(switcher)
        {case 0:
          var
           _fC_=evt.keyCode,
           _fH_=function(_fJ_){return run_next(_fC_,try_key_code_left,_fJ_)};
          break;
         case 1:
          var
           _fD_=evt.keyCode,
           _fH_=function(_fI_){return run_next(_fD_,try_key_code_right,_fI_)};
          break;
         default:
          var
           _fE_=evt.keyCode,
           _fH_=function(_fK_){return run_next(_fE_,try_key_code_numpad,_fK_)}}
      var value=evt.code;
      return symbol$11
              (symbol$11
                (symbol$11
                  (0,
                   function(v)
                    {return v?v:caml_call3(Optdef[7],value,make_unidentified,f)}),
                 _fH_),
               _fG_)}
    function char_of_int(value)
     {if(caml_call2(symbol$5,0,value))
       try
        {var _fA_=[0,caml_call1(Stdlib_Uchar[8],value)];return _fA_}
       catch(_fB_){return 0}
      return 0}
    function empty_string(param){return ""}
    function none(param){return 0}
    function of_event$0(evt)
     {var t110=caml_call2(Optdef[8],evt.key,empty_string),match=t110.length;
      return 0 === match
              ?caml_call3(Optdef[7],evt.charCode,none,char_of_int)
              :1 === match?char_of_int(t110.charCodeAt(0) | 0):0}
    function element$1(_fz_){return _fz_}
    function tagged(e)
     {var t112=e.tagName,tag=caml_string_of_jsbytes(t112.toLowerCase());
      if(caml_call2(symbol$8,caml_ml_string_length(tag),0))return [61,e];
      var match=runtime.caml_string_unsafe_get(tag,0),switcher=match - 97 | 0;
      if(! (21 < switcher >>> 0))
       switch(switcher)
        {case 0:
          return caml_string_notequal(tag,cst_a$1)
                  ?caml_string_notequal(tag,cst_area$1)
                    ?caml_string_notequal(tag,cst_audio$1)?[61,e]:[2,e]
                    :[1,e]
                  :[0,e];
         case 1:
          return caml_string_notequal(tag,cst_base$1)
                  ?caml_string_notequal(tag,cst_blockquote$1)
                    ?caml_string_notequal(tag,cst_body$1)
                      ?caml_string_notequal(tag,cst_br$1)
                        ?caml_string_notequal(tag,cst_button$1)?[61,e]:[7,e]
                        :[6,e]
                      :[5,e]
                    :[4,e]
                  :[3,e];
         case 2:
          return caml_string_notequal(tag,cst_canvas$1)
                  ?caml_string_notequal(tag,cst_caption$1)
                    ?caml_string_notequal(tag,cst_col$1)
                      ?caml_string_notequal(tag,cst_colgroup$1)?[61,e]:[11,e]
                      :[10,e]
                    :[9,e]
                  :[8,e];
         case 3:
          return caml_string_notequal(tag,cst_del$1)
                  ?caml_string_notequal(tag,cst_div$1)
                    ?caml_string_notequal(tag,cst_dl$1)?[61,e]:[14,e]
                    :[13,e]
                  :[12,e];
         case 4:return caml_string_notequal(tag,cst_embed$1)?[61,e]:[15,e];
         case 5:
          return caml_string_notequal(tag,cst_fieldset$1)
                  ?caml_string_notequal(tag,cst_form$1)
                    ?caml_string_notequal(tag,cst_frame$1)
                      ?caml_string_notequal(tag,cst_frameset$1)?[61,e]:[18,e]
                      :[19,e]
                    :[17,e]
                  :[16,e];
         case 7:
          return caml_string_notequal(tag,cst_h1$1)
                  ?caml_string_notequal(tag,cst_h2$1)
                    ?caml_string_notequal(tag,cst_h3$1)
                      ?caml_string_notequal(tag,cst_h4$1)
                        ?caml_string_notequal(tag,cst_h5$1)
                          ?caml_string_notequal(tag,cst_h6$1)
                            ?caml_string_notequal(tag,cst_head$1)
                              ?caml_string_notequal(tag,cst_hr$1)
                                ?caml_string_notequal(tag,cst_html$1)?[61,e]:[28,e]
                                :[27,e]
                              :[26,e]
                            :[25,e]
                          :[24,e]
                        :[23,e]
                      :[22,e]
                    :[21,e]
                  :[20,e];
         case 8:
          return caml_string_notequal(tag,cst_iframe$1)
                  ?caml_string_notequal(tag,cst_img$1)
                    ?caml_string_notequal(tag,cst_input$2)
                      ?caml_string_notequal(tag,cst_ins$1)?[61,e]:[32,e]
                      :[31,e]
                    :[30,e]
                  :[29,e];
         case 11:
          return caml_string_notequal(tag,cst_label$1)
                  ?caml_string_notequal(tag,cst_legend$1)
                    ?caml_string_notequal(tag,cst_li$1)
                      ?caml_string_notequal(tag,cst_link$1)?[61,e]:[36,e]
                      :[35,e]
                    :[34,e]
                  :[33,e];
         case 12:
          return caml_string_notequal(tag,cst_map$1)
                  ?caml_string_notequal(tag,cst_meta$1)?[61,e]:[38,e]
                  :[37,e];
         case 14:
          return caml_string_notequal(tag,cst_object$1)
                  ?caml_string_notequal(tag,cst_ol$1)
                    ?caml_string_notequal(tag,cst_optgroup$1)
                      ?caml_string_notequal(tag,cst_option$1)?[61,e]:[42,e]
                      :[41,e]
                    :[40,e]
                  :[39,e];
         case 15:
          return caml_string_notequal(tag,cst_p$1)
                  ?caml_string_notequal(tag,cst_param$1)
                    ?caml_string_notequal(tag,cst_pre$1)?[61,e]:[45,e]
                    :[44,e]
                  :[43,e];
         case 16:return caml_string_notequal(tag,cst_q$1)?[61,e]:[46,e];
         case 18:
          return caml_string_notequal(tag,cst_script$1)
                  ?caml_string_notequal(tag,cst_select$2)
                    ?caml_string_notequal(tag,cst_style$1)?[61,e]:[49,e]
                    :[48,e]
                  :[47,e];
         case 19:
          return caml_string_notequal(tag,cst_table$1)
                  ?caml_string_notequal(tag,cst_tbody$1)
                    ?caml_string_notequal(tag,cst_td$1)
                      ?caml_string_notequal(tag,cst_textarea$1)
                        ?caml_string_notequal(tag,cst_tfoot$1)
                          ?caml_string_notequal(tag,cst_th$1)
                            ?caml_string_notequal(tag,cst_thead$1)
                              ?caml_string_notequal(tag,cst_title$1)
                                ?caml_string_notequal(tag,cst_tr$1)?[61,e]:[58,e]
                                :[57,e]
                              :[56,e]
                            :[55,e]
                          :[54,e]
                        :[53,e]
                      :[52,e]
                    :[51,e]
                  :[50,e];
         case 20:return caml_string_notequal(tag,cst_ul$1)?[61,e]:[59,e];
         case 21:return caml_string_notequal(tag,cst_video$1)?[61,e]:[60,e]
         }
      return [61,e]}
    function opt_tagged(e)
     {function _fx_(e){return [0,tagged(e)]}
      function _fy_(param){return 0}
      return caml_call3(Opt[7],e,_fy_,_fx_)}
    function taggedEvent(ev)
     {function _ff_(ev){return [0,ev]}
      function _fg_(param)
       {function _fi_(ev){return [1,ev]}
        function _fj_(param)
         {function _fl_(ev){return [3,ev]}
          function _fm_(param)
           {function _fo_(ev){return [4,ev]}
            function _fp_(param)
             {function _fr_(ev){return [5,ev]}
              function _fs_(param)
               {function _fu_(ev){return [2,ev]}
                function _fv_(param){return [6,ev]}
                var _fw_=messageEvent(ev);
                return caml_call3(Opt[7],_fw_,_fv_,_fu_)}
              var _ft_=popStateEvent(ev);
              return caml_call3(Opt[7],_ft_,_fs_,_fr_)}
            var _fq_=mouseScrollEvent(ev);
            return caml_call3(Opt[7],_fq_,_fp_,_fo_)}
          var _fn_=wheelEvent(ev);
          return caml_call3(Opt[7],_fn_,_fm_,_fl_)}
        var _fk_=keyboardEvent(ev);
        return caml_call3(Opt[7],_fk_,_fj_,_fi_)}
      var _fh_=mouseEvent(ev);
      return caml_call3(Opt[7],_fh_,_fg_,_ff_)}
    function opt_taggedEvent(ev)
     {function _fd_(ev){return [0,taggedEvent(ev)]}
      function _fe_(param){return 0}
      return caml_call3(Opt[7],ev,_fe_,_fd_)}
    function stopPropagation(ev)
     {function _fb_(param){return ev.stopPropagation()}
      function _fc_(param){return ev.cancelBubble = t25}
      return caml_call3(Optdef[7],ev.stopPropagation,_fc_,_fb_)}
    var
     requestAnimationFrame=
      runtime.caml_js_pure_expr
       (function(param)
         {var
           l=
            [0,
             _j_.requestAnimationFrame,
             [0,
              _j_.mozRequestAnimationFrame,
              [0,
               _j_.webkitRequestAnimationFrame,
               [0,
                _j_.oRequestAnimationFrame,
                [0,_j_.msRequestAnimationFrame,0]]]]];
          try
           {var
             _e__=function(c){return caml_call1(Optdef[5],c)},
             req=caml_call2(Stdlib_List[38],_e__,l),
             _e$_=function(callback){return req(callback)};
            return _e$_}
          catch(_fa_)
           {_fa_ = caml_wrap_exception(_fa_);
            if(_fa_ === Stdlib[8])
             {var
               now=function(param){var t123=new t122();return t123.getTime()},
               last=[0,now(0)];
              return function(callback)
               {var
                 t=now(0),
                 dt=last[1] + 16.6666666666666679 - t,
                 dt$0=dt < 0.?0.:dt;
                last[1] = t;
                _j_.setTimeout(callback,dt$0);
                return 0}}
            throw _fa_}});
    function hasPushState(param)
     {var t128=_j_.history;return caml_call1(Optdef[5],t128.pushState)}
    function hasPlaceholder(param)
     {var t129=createInput(0,0,t87);
      return caml_call1(Optdef[5],t129.placeholder)}
    function hasRequired(param)
     {var t130=createInput(0,0,t87);
      return caml_call1(Optdef[5],t130.required)}
    var overflow_limit=2147483000.;
    function setTimeout(callback,d)
     {var id=[0,0];
      function loop(step,param)
       {if(2147483000. < step)
         var remain=step - 2147483000.,step$0=overflow_limit;
        else
         var remain=0.,step$0=step;
        var
         cb=remain == 0.?callback:function(_e9_){return loop(remain,_e9_)},
         t131=caml_js_wrap_callback(cb);
        id[1] = [0,_j_.setTimeout(t131,step$0)];
        return 0}
      loop(d,0);
      return id}
    function clearTimeout(id)
     {var _e8_=id[1];
      if(_e8_){var x=_e8_[1];id[1] = 0;return _j_.clearTimeout(x)}
      return 0}
    function js_array_of_collection(c){return [].slice.call(c)}
    var
     Js_of_ocaml_Dom_html=
      [0,
       d,
       t87,
       getElementById_opt,
       getElementById_exn,
       getElementById_coerce,
       getElementById,
       location_origin,
       _j_,
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       eventRelatedTarget,
       Event$0,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       addMousewheelEventListenerWith,
       addMousewheelEventListener,
       createCustomEvent,
       buttonPressed,
       eventAbsolutePosition$0,
       elementClientPosition,
       getDocumentScroll,
       [0,of_event,try_key_code_normal],
       [0,of_event$0],
       createHtml,
       createHead,
       createLink,
       createTitle,
       createMeta,
       createBase,
       createStyle,
       createBody,
       createForm,
       createOptgroup,
       createOption,
       createSelect,
       createInput,
       createTextarea,
       createButton,
       createLabel,
       createFieldset,
       createLegend,
       createUl,
       createOl,
       createDl,
       createLi,
       createDiv,
       createEmbed,
       createP,
       createH1,
       createH2,
       createH3,
       createH4,
       createH5,
       createH6,
       createQ,
       createBlockquote,
       createPre,
       createBr,
       createHr,
       createIns,
       createDel,
       createA,
       createImg,
       createObject,
       createParam,
       createMap,
       createArea,
       createScript,
       createTable,
       createCaption,
       createCol,
       createColgroup,
       createThead,
       createTfoot,
       createTbody,
       createTr,
       createTh,
       createTd,
       createSub,
       createSup,
       createSpan,
       createTt,
       createI,
       createB,
       createBig,
       createSmall,
       createEm,
       createStrong,
       createCite,
       createDfn,
       createCode,
       createSamp,
       createKbd,
       createVar,
       createAbbr,
       createDd,
       createDt,
       createNoscript,
       createAddress,
       createFrameset,
       createFrame,
       createIframe,
       createAudio,
       createVideo,
       Canvas_not_available,
       createCanvas,
       element$1,
       tagged,
       opt_tagged,
       taggedEvent,
       opt_taggedEvent,
       stopPropagation,
       [0,
        element$0,
        a,
        area,
        audio,
        base,
        blockquote,
        body,
        br,
        button,
        canvas,
        caption,
        col,
        colgroup,
        del,
        div,
        embed,
        dl,
        fieldset,
        form,
        frameset,
        frame,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        head,
        hr,
        html,
        iframe,
        img,
        input$0,
        ins,
        label,
        legend,
        li,
        link,
        map$2,
        meta,
        object,
        ol,
        optgroup,
        option$1,
        p,
        param,
        pre,
        q,
        script,
        select$0,
        style,
        table,
        tbody,
        td,
        textarea,
        tfoot,
        th,
        thead,
        title,
        tr,
        ul,
        video,
        mouseEvent,
        keyboardEvent,
        wheelEvent,
        mouseScrollEvent,
        popStateEvent,
        messageEvent],
       setTimeout,
       clearTimeout,
       js_array_of_collection,
       requestAnimationFrame,
       runtime.caml_js_html_entities,
       onIE,
       hasPushState,
       hasPlaceholder,
       hasRequired];
    caml_register_global(1651,Js_of_ocaml_Dom_html,"Js_of_ocaml__Dom_html");
    var formData=Unsafe[1].FormData,formData_form=Unsafe[1].FormData;
    function filter_map$0(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map$0(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function have_content(elt)
     {var
       t3=elt.name,
       _e6_=caml_call2(symbol$9,t3.length,0),
       _e7_=_e6_?1 - (elt.disabled | 0):_e6_;
      return _e7_}
    function form_elements(get,form)
     {var t34=form.elements,i$2=t34.length - 1 | 0,acc=0,i=i$2;
      for(;;)
       {if(caml_call2(symbol$5,i,0))
         {var
           _eX_=
            function(v$2)
             {var match$3=tagged(v$2);
              switch(match$3[0])
               {case 31:
                 var v=match$3[1];
                 if(get)var sth=get[1],get$0=sth;else var get$0=0;
                 if(have_content(v))
                  {var
                    name$1=caml_string_of_jsstring(v.name),
                    value=v.value,
                    t20=v.type,
                    match=caml_string_of_jsbytes(t20.toLowerCase());
                   if(caml_string_notequal(match,cst_checkbox))
                    {if(! caml_string_notequal(match,cst_file))
                      {if(get$0)return [0,[0,name$1,[0,-976970511,value]],0];
                       var match$0=caml_call1(Optdef[10],v.files);
                       if(match$0)
                        {var list=match$0[1];
                         if(caml_call2(symbol$8,list.length,0))
                          return [0,[0,name$1,[0,-976970511,""]],0];
                         var match$1=caml_call1(Optdef[10],v.multiple);
                         if(match$1 && match$1[1])
                          {var
                            _e1_=function(t28){return list.item(t28)},
                            _e2_=caml_call2(Stdlib_Array[2],list.length,_e1_),
                            _e3_=caml_call1(Stdlib_Array[11],_e2_);
                           return filter_map$0
                                   (function(f)
                                     {var match=caml_call1(Opt[10],f);
                                      if(match)
                                       {var file=match[1];return [0,[0,name$1,[0,781515420,file]]]}
                                      return 0},
                                    _e3_)}
                         var _e4_=list.item(0),match$2=caml_call1(Opt[10],_e4_);
                         if(match$2)
                          {var file=match$2[1];
                           return [0,[0,name$1,[0,781515420,file]],0]}
                         return 0}
                       return 0}
                     var switch$0=0;
                     if(caml_string_notequal(match,cst_password))
                      {if(caml_string_notequal(match,cst_radio))
                        {var switch$1=0;
                         if
                          (caml_string_notequal(match,cst_reset)
                           &&
                           caml_string_notequal(match,cst_submit$0))
                          {if(caml_string_notequal(match,cst_text))
                            return [0,[0,name$1,[0,-976970511,value]],0];
                           switch$0 = 1;
                           switch$1 = 1}
                         if(! switch$1)return 0}}
                     else
                      switch$0 = 1;
                     if(switch$0)return [0,[0,name$1,[0,-976970511,value]],0]}
                   return v.checked | 0?[0,[0,name$1,[0,-976970511,value]],0]:0}
                 return 0;
                case 48:
                 var v$0=match$3[1];
                 if(have_content(v$0))
                  {var name$0=caml_string_of_jsstring(v$0.name);
                   if(v$0.multiple | 0)
                    {var
                      _eZ_=
                       function(i)
                        {var t13=v$0.options,_e5_=t13.item(i);
                         return caml_call1(Opt[10],_e5_)},
                      t10=v$0.options,
                      options=caml_call2(Stdlib_Array[2],t10.length,_eZ_),
                      _e0_=caml_call1(Stdlib_Array[11],options);
                     return filter_map$0
                             (function(param)
                               {if(param)
                                 {var e=param[1];
                                  return e.selected | 0
                                          ?[0,[0,name$0,[0,-976970511,e.value]]]
                                          :0}
                                return 0},
                              _e0_)}
                   return [0,[0,name$0,[0,-976970511,v$0.value]],0]}
                 return 0;
                case 53:
                 var v$1=match$3[1];
                 if(have_content(v$1))
                  {var name=caml_string_of_jsstring(v$1.name);
                   return [0,[0,name,[0,-976970511,v$1.value]],0]}
                 return 0;
                default:return 0}},
           _eY_=caml_call2(Stdlib_List[19],_eX_,acc);
          return caml_call1(Stdlib_List[14],_eY_)}
        var t32=form.elements,_eW_=t32.item(i),match=caml_call1(Opt[10],_eW_);
        if(match)
         {var x=match[1],i$0=i - 1 | 0,acc$0=[0,x,acc],acc=acc$0,i=i$0;
          continue}
        var i$1=i - i | 0,i=i$1;
        continue}}
    function append(form_contents,form_elt)
     {if(891486873 <= form_contents[1])
       {var list=form_contents[2];list[1] = [0,form_elt,list[1]];return 0}
      var f=form_contents[2],_eU_=form_elt[2],_eV_=form_elt[1];
      if(781515420 <= _eU_[1])
       {var file=_eU_[2],t38=caml_jsstring_of_string(_eV_);
        return f.append(t38,file)}
      var s=_eU_[2],t35=caml_jsstring_of_string(_eV_);
      return f.append(t35,s)}
    function empty_form_contents(param)
     {var match=caml_call1(Optdef[10],formData);
      if(match){var constr=match[1];return [0,808620462,new constr()]}
      return [0,891486873,[0,0]]}
    function post_form_contents(form)
     {var contents=empty_form_contents(0),_eR_=form_elements(0,form);
      function _eS_(_eT_){return append(contents,_eT_)}
      caml_call2(Stdlib_List[17],_eS_,_eR_);
      return contents}
    function get_form_contents(form)
     {var _eO_=form_elements(_n_,form);
      function _eP_(param)
       {var _eQ_=param[2];
        if(typeof _eQ_ !== "number" && -976970511 === _eQ_[1])
         {var s=_eQ_[2],name=param[1];
          return [0,name,caml_string_of_jsstring(s)]}
        throw [0,Assert_failure,_o_]}
      return caml_call2(Stdlib_List[19],_eP_,_eO_)}
    var
     Js_of_ocaml_Form=
      [0,
       formData,
       formData_form,
       append,
       post_form_contents,
       get_form_contents,
       empty_form_contents,
       form_elements];
    caml_register_global(1652,Js_of_ocaml_Form,"Js_of_ocaml__Form");
    var
     readystatechange=caml_call1(Event[1],cst_readystatechange),
     loadstart$1=caml_call1(Event[1],cst_loadstart$1),
     progress$1=caml_call1(Event[1],cst_progress$1),
     abort$1=caml_call1(Event[1],cst_abort$1),
     error$1=caml_call1(Event[1],cst_error$1),
     load$1=caml_call1(Event[1],cst_load$1),
     timeout=caml_call1(Event[1],cst_timeout),
     loadend$0=caml_call1(Event[1],cst_loadend$0),
     Event$1=
      [0,
       readystatechange,
       loadstart$1,
       progress$1,
       abort$1,
       error$1,
       load$1,
       timeout,
       loadend$0],
     Js_of_ocaml_XmlHttpRequest=[0,runtime.caml_xmlhttprequest_create,Event$1];
    caml_register_global
     (1653,Js_of_ocaml_XmlHttpRequest,"Js_of_ocaml__XmlHttpRequest");
    var t2=Unsafe[1].Worker;
    function create(script)
     {var t1=caml_jsstring_of_string(script);return new t2(t1)}
    function import_scripts(scripts)
     {if(Unsafe[1].importScripts === t39)
       caml_call1(Stdlib[1],cst_Worker_import_scripts_is_u);
      var _eL_=caml_call1(Stdlib_Array[12],scripts);
      function _eM_(s){return caml_jsstring_of_string(s)}
      var _eN_=caml_call2(Stdlib_Array[15],_eM_,_eL_);
      return runtime.caml_js_fun_call(Unsafe[1].importScripts,_eN_)}
    function set_onmessage(handler)
     {if(Unsafe[1].onmessage === t39)
       caml_call1(Stdlib[1],cst_Worker_onmessage_is_undefi);
      function js_handler(ev){return caml_call1(handler,ev.data)}
      var t7=caml_js_wrap_callback(js_handler);
      return Unsafe[1].onmessage = t7}
    function post_message(t10)
     {if(Unsafe[1].postMessage === t39)
       caml_call1(Stdlib[1],cst_Worker_onmessage_is_undefi$0);
      return Unsafe[1].postMessage(t10)}
    var
     Js_of_ocaml_Worker=
      [0,create,import_scripts,set_onmessage,post_message];
    caml_register_global(1654,Js_of_ocaml_Worker,"Js_of_ocaml__Worker");
    var webSocket=Unsafe[1].WebSocket;
    function is_supported(param){return caml_call1(Optdef[5],webSocket)}
    var Js_of_ocaml_WebSockets=[0,webSocket,webSocket,webSocket,is_supported];
    caml_register_global
     (1655,Js_of_ocaml_WebSockets,"Js_of_ocaml__WebSockets");
    var
     defaultContextAttributes=
      {"alpha":t25,
       "depth":t25,
       "stencil":t4,
       "antialias":t25,
       "premultipliedAlpha":t4,
       "preserveDrawingBuffer":t4,
       "preferLowPowerToHighPerformance":t4,
       "failIfMajorPerformanceCaveat":t4},
     webglcontextlost=caml_call1(Event$0[87],cst_webglcontextlost),
     webglcontextrestored=caml_call1(Event$0[87],cst_webglcontextrestored),
     webglcontextcreationerror=
      caml_call1(Event$0[87],cst_webglcontextcreationerror),
     Event$2=
      [0,webglcontextlost,webglcontextrestored,webglcontextcreationerror];
    function getContext(t3)
     {var ctx=t3.getContext("webgl");
      return caml_call1(Opt[5],ctx)?ctx:t3.getContext("experimental-webgl")}
    function getContextWithAttributes(t9,t8)
     {var ctx=t9.getContext("webgl",t8);
      return caml_call1(Opt[5],ctx)?ctx:t9.getContext("experimental-webgl",t8)}
    var
     Js_of_ocaml_WebGL=
      [0,defaultContextAttributes,Event$2,getContext,getContextWithAttributes];
    caml_register_global(1656,Js_of_ocaml_WebGL,"Js_of_ocaml__WebGL");
    function regexp(s)
     {var t0=caml_jsbytes_of_string(s);return new t11(t0,"g")}
    function regexp_case_fold(s)
     {var t3=caml_jsbytes_of_string(s);return new t11(t3,"gi")}
    function regexp_with_flag(s,f)
     {var
       t7=caml_jsstring_of_string(caml_call2(Stdlib[28],cst_g,f)),
       t6=caml_jsbytes_of_string(s);
      return new t11(t6,t7)}
    function blunt_str_array_get(a,i)
     {function _eK_(param){throw [0,Assert_failure,_p_]}
      return caml_string_of_jsbytes(caml_call2(Optdef[8],a[i],_eK_))}
    function string_match(r,s,i)
     {r.lastIndex = i;
      var
       t11=caml_jsbytes_of_string(s),
       _eI_=r.exec(t11),
       _eJ_=caml_call2(Opt[3],_eI_,match_result);
      return caml_call1(Opt[10],_eJ_)}
    function search_forward(r,s,i)
     {r.lastIndex = i;
      var t15=caml_jsbytes_of_string(s);
      function _eF_(t17){return [0,t17.index,t17]}
      var _eG_=r.exec(t15),_eH_=caml_call2(Opt[3],_eG_,_eF_);
      return caml_call1(Opt[10],_eH_)}
    function matched_string(r){return blunt_str_array_get(r,0)}
    function matched_group(r,i)
     {var _eE_=caml_call2(Optdef[3],r[i],caml_string_of_jsbytes);
      return caml_call1(Optdef[10],_eE_)}
    var t21=new t11("[$]","g");
    function quote_repl(s)
     {var t23=caml_jsbytes_of_string(s);return t23.replace(t21,"$$$$")}
    function global_replace(r,s,s_by)
     {r.lastIndex = 0;
      var t27=quote_repl(s_by),t28=caml_jsbytes_of_string(s);
      return caml_string_of_jsbytes(t28.replace(r,t27))}
    function replace_first(r,s,s_by)
     {var
       match=r.ignoreCase | 0,
       match$0=r.multiline | 0,
       flags=match?match$0?"mi":"i":match$0?"m":"",
       t32=r.source,
       t35=new t11(t32,flags),
       t36=quote_repl(s_by),
       t37=caml_jsbytes_of_string(s);
      return caml_string_of_jsbytes(t37.replace(t35,t36))}
    function list_of_js_array(a)
     {var idx$1=a.length - 1 | 0,accu=0,idx=idx$1;
      for(;;)
       {if(caml_call2(symbol$5,idx,0))return accu;
        var
         idx$0=idx - 1 | 0,
         accu$0=[0,blunt_str_array_get(a,idx),accu],
         accu=accu$0,
         idx=idx$0;
        continue}}
    function split(r,s)
     {r.lastIndex = 0;
      var t42=caml_jsbytes_of_string(s);
      return list_of_js_array(t42.split(r))}
    function bounded_split(r,s,i)
     {r.lastIndex = 0;
      var t47=caml_jsbytes_of_string(s);
      return list_of_js_array(t47.split(r,i))}
    var t48=regexp(cst);
    function quote(s)
     {var t50=caml_jsbytes_of_string(s);
      return caml_string_of_jsbytes(t50.replace(t48,"\\$&"))}
    function regexp_string(s){return regexp(quote(s))}
    function regexp_string_case_fold(s){return regexp_case_fold(quote(s))}
    var
     Js_of_ocaml_Regexp=
      [0,
       regexp,
       regexp_case_fold,
       regexp_with_flag,
       quote,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_forward,
       matched_string,
       matched_group,
       global_replace,
       replace_first,
       split,
       bounded_split];
    caml_register_global(1657,Js_of_ocaml_Regexp,"Js_of_ocaml__Regexp");
    var Local_exn=[248,cst_Js_of_ocaml_Url_Local_exn,caml_fresh_oo_id(0)];
    function interrupt(param){throw Local_exn}
    var plus_re=regexp_string(cst$0),t14=new t11("\\+","g");
    function urldecode_js_string_string(s)
     {t14.lastIndex = 0;
      return caml_string_of_jsbytes(unescape(s.replace(t14," ")))}
    function urldecode(s)
     {return caml_string_of_jsbytes
              (unescape
                (caml_jsbytes_of_string(global_replace(plus_re,s,cst$1))))}
    function urlencode(opt,s)
     {if(opt)var sth=opt[1],with_plus=sth;else var with_plus=1;
      if(with_plus)
       {var s$0=caml_string_of_jsbytes(escape(caml_jsbytes_of_string(s)));
        return global_replace(plus_re,s$0,cst_2B)}
      return caml_string_of_jsbytes(escape(caml_jsbytes_of_string(s)))}
    var
     Not_an_http_protocol=
      [248,cst_Js_of_ocaml_Url_Not_an_htt,caml_fresh_oo_id(0)],
     default_http_port=80,
     default_https_port=443;
    function path_of_path_string(s)
     {var l=caml_ml_string_length(s);
      function aux(i)
       {try
         {var _eC_=caml_call3(String[30],s,i,47),j=_eC_}
        catch(_eD_)
         {_eD_ = caml_wrap_exception(_eD_);
          if(_eD_ !== Stdlib[8])throw _eD_;
          var j=l}
        var word=caml_call3(String[14],s,i,j - i | 0);
        return caml_call2(symbol$10,j,l)?[0,word,0]:[0,word,aux(j + 1 | 0)]}
      var a=aux(0);
      if(a && ! caml_string_notequal(a[1],cst$2))
       {var _eB_=a[2];
        if(! _eB_)return 0;
        if(! caml_string_notequal(_eB_[1],cst$3) && ! _eB_[2])return _q_}
      return a}
    function encode_arguments(l)
     {function _ew_(param)
       {var
         v=param[2],
         n=param[1],
         _ey_=urlencode(0,v),
         _ez_=caml_call2(Stdlib[28],cst$4,_ey_),
         _eA_=urlencode(0,n);
        return caml_call2(Stdlib[28],_eA_,_ez_)}
      var _ex_=caml_call2(Stdlib_List[19],_ew_,l);
      return caml_call2(String[6],cst$5,_ex_)}
    function decode_arguments_js_string(s)
     {var
       t0=caml_jsstring_of_string(caml_call2(String[1],1,38)),
       t18=s.split(t0),
       len=t18.length;
      function aux(acc,idx)
       {var idx$0=idx;
        for(;;)
         {if(caml_call2(symbol$5,idx$0,0))return acc;
          try
           {var
             _eo_=idx$0 - 1 | 0,
             _ep_=
              function(s)
               {function _eu_(param)
                 {var
                   y=param[2],
                   x=param[1],
                   _ev_=urldecode_js_string_string(y);
                  return [0,urldecode_js_string_string(x),_ev_]}
                var
                 t2=caml_jsstring_of_string(caml_call2(String[1],1,61)),
                 t5=s.indexOf(t2);
                if(caml_call2(symbol$5,t5,0))
                 var _et_=t39;
                else
                 var
                  t7=t5 + 1 | 0,
                  _es_=s.slice(t7),
                  _et_=[0,s.slice(0,t5),_es_];
                return caml_call3(Optdef[7],_et_,interrupt,_eu_)},
             _eq_=
              aux
               ([0,caml_call3(Optdef[7],t18[idx$0],interrupt,_ep_),acc],_eo_);
            return _eq_}
          catch(_er_)
           {_er_ = caml_wrap_exception(_er_);
            if(_er_ === Local_exn)
             {var idx$1=idx$0 - 1 | 0,idx$0=idx$1;continue}
            throw _er_}}}
      return aux(0,len - 1 | 0)}
    function decode_arguments(s)
     {return decode_arguments_js_string(caml_jsbytes_of_string(s))}
    var
     t19=caml_jsbytes_of_string(cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0),
     t24=new t11(t19),
     t21$0=caml_jsbytes_of_string(cst_Ff_Ii_Ll_Ee),
     t26=new t11(t21$0);
    function url_of_js_string(s)
     {function _d7_(res)
       {var
         prot_string=caml_call2(Optdef[8],res[1],interrupt),
         match=caml_string_of_jsbytes(prot_string.toLowerCase());
        if
         (caml_string_notequal(match,cst_file$0)
          &&
          caml_string_notequal(match,cst_file$1))
         {var switch$0=0;
          if
           (caml_string_notequal(match,cst_http)
            &&
            caml_string_notequal(match,cst_http$0))
           {var switch$1=0;
            if
             (caml_string_notequal(match,cst_https)
              &&
              caml_string_notequal(match,cst_https$0))
             switch$1 = 1;
            if(! switch$1){var ssl=1;switch$0 = 2}}
          else
           switch$0 = 1;
          var switch$2=0;
          switch(switch$0)
           {case 1:var ssl=0;switch$2 = 1;break;
            case 0:break;
            default:switch$2 = 1}
          if(switch$2)
           {var
             _ef_=function(param){return caml_jsbytes_of_string(cst$7)},
             path_str=
              urldecode_js_string_string(caml_call2(Optdef[8],res[6],_ef_)),
             _eg_=function(param){return caml_jsbytes_of_string(cst$8)},
             _eh_=
              urldecode_js_string_string(caml_call2(Optdef[8],res[10],_eg_)),
             _ei_=function(param){return caml_jsbytes_of_string(cst$9)},
             _ej_=
              decode_arguments_js_string(caml_call2(Optdef[8],res[8],_ei_)),
             _ek_=path_of_path_string(path_str),
             _el_=function(param){return caml_jsbytes_of_string(cst$10)},
             s=caml_string_of_jsbytes(caml_call2(Optdef[8],res[4],_el_)),
             _em_=
              caml_string_notequal(s,cst$6)?caml_int_of_string(s):ssl?443:80,
             url=
              [0,
               urldecode_js_string_string
                (caml_call2(Optdef[8],res[2],interrupt)),
               _em_,
               _ek_,
               path_str,
               _ej_,
               _eh_],
             _en_=ssl?[1,url]:[0,url];
            return [0,_en_]}}
        throw Not_an_http_protocol}
      function _d8_(param)
       {function _d__(res)
         {var
           path_str=
            urldecode_js_string_string(caml_call2(Optdef[8],res[2],interrupt));
          function _eb_(param){return caml_jsbytes_of_string(cst$11)}
          var _ec_=caml_string_of_jsbytes(caml_call2(Optdef[8],res[6],_eb_));
          function _ed_(param){return caml_jsbytes_of_string(cst$12)}
          var
           _ee_=
            decode_arguments_js_string(caml_call2(Optdef[8],res[4],_ed_));
          return [0,[2,[0,path_of_path_string(path_str),path_str,_ee_,_ec_]]]}
        function _d$_(param){return 0}
        var _ea_=t26.exec(s);
        return caml_call3(Opt[7],_ea_,_d$_,_d__)}
      var _d9_=t24.exec(s);
      return caml_call3(Opt[7],_d9_,_d8_,_d7_)}
    function url_of_string(s)
     {return url_of_js_string(caml_jsbytes_of_string(s))}
    function string_of_url(param)
     {switch(param[0])
       {case 0:
         var
          match=param[1],
          frag=match[6],
          args=match[5],
          path=match[3],
          port=match[2],
          host=match[1];
         if(caml_string_notequal(frag,cst$13))
          var _du_=urlencode(0,frag),_dv_=caml_call2(Stdlib[28],cst$14,_du_);
         else
          var _dv_=cst$21;
         if(args)
          var
           _dw_=encode_arguments(args),
           _dx_=caml_call2(Stdlib[28],cst$15,_dw_);
         else
          var _dx_=cst$20;
         var
          _dy_=caml_call2(Stdlib[28],_dx_,_dv_),
          _dz_=function(x){return urlencode(0,x)},
          _dA_=caml_call2(Stdlib_List[19],_dz_,path),
          _dB_=caml_call2(String[6],cst$16,_dA_),
          _dC_=caml_call2(Stdlib[28],_dB_,_dy_),
          _dD_=caml_call2(Stdlib[28],cst$17,_dC_);
         if(80 === port)
          var _dE_=cst$18;
         else
          var
           _dI_=caml_call1(Stdlib[33],port),
           _dE_=caml_call2(Stdlib[28],cst$19,_dI_);
         var
          _dF_=caml_call2(Stdlib[28],_dE_,_dD_),
          _dG_=urlencode(0,host),
          _dH_=caml_call2(Stdlib[28],_dG_,_dF_);
         return caml_call2(Stdlib[28],cst_http$1,_dH_);
        case 1:
         var
          match$0=param[1],
          frag$0=match$0[6],
          args$0=match$0[5],
          path$0=match$0[3],
          port$0=match$0[2],
          host$0=match$0[1];
         if(caml_string_notequal(frag$0,cst$22))
          var
           _dJ_=urlencode(0,frag$0),
           _dK_=caml_call2(Stdlib[28],cst$23,_dJ_);
         else
          var _dK_=cst$30;
         if(args$0)
          var
           _dL_=encode_arguments(args$0),
           _dM_=caml_call2(Stdlib[28],cst$24,_dL_);
         else
          var _dM_=cst$29;
         var
          _dN_=caml_call2(Stdlib[28],_dM_,_dK_),
          _dO_=function(x){return urlencode(0,x)},
          _dP_=caml_call2(Stdlib_List[19],_dO_,path$0),
          _dQ_=caml_call2(String[6],cst$25,_dP_),
          _dR_=caml_call2(Stdlib[28],_dQ_,_dN_),
          _dS_=caml_call2(Stdlib[28],cst$26,_dR_);
         if(443 === port$0)
          var _dT_=cst$27;
         else
          var
           _dX_=caml_call1(Stdlib[33],port$0),
           _dT_=caml_call2(Stdlib[28],cst$28,_dX_);
         var
          _dU_=caml_call2(Stdlib[28],_dT_,_dS_),
          _dV_=urlencode(0,host$0),
          _dW_=caml_call2(Stdlib[28],_dV_,_dU_);
         return caml_call2(Stdlib[28],cst_https$1,_dW_);
        default:
         var
          match$1=param[1],
          frag$1=match$1[4],
          args$1=match$1[3],
          path$1=match$1[1];
         if(caml_string_notequal(frag$1,cst$31))
          var
           _dY_=urlencode(0,frag$1),
           _dZ_=caml_call2(Stdlib[28],cst$32,_dY_);
         else
          var _dZ_=cst$36;
         if(args$1)
          var
           _d0_=encode_arguments(args$1),
           _d1_=caml_call2(Stdlib[28],cst$33,_d0_);
         else
          var _d1_=cst$35;
         var
          _d2_=caml_call2(Stdlib[28],_d1_,_dZ_),
          _d3_=function(x){return urlencode(0,x)},
          _d4_=caml_call2(Stdlib_List[19],_d3_,path$1),
          _d5_=caml_call2(String[6],cst$34,_d4_),
          _d6_=caml_call2(Stdlib[28],_d5_,_d2_);
         return caml_call2(Stdlib[28],cst_file$2,_d6_)}}
    var _r_=caml_call1(Optdef[2],_j_.location);
    if(caml_call1(Optdef[5],_r_))
     var _s_=_j_.location;
    else
     var
      t42=function(param,_dt_){return 0},
      t41$0=function(param,_ds_){return 0},
      t40=function(param){return 0},
      _s_=
       {"href":"",
        "protocol":"",
        "host":"",
        "hostname":"",
        "port":"",
        "pathname":"",
        "search":"",
        "hash":"",
        "origin":t39,
        "reload":caml_js_wrap_meth_callback(t40),
        "replace":caml_js_wrap_meth_callback(t41$0),
        "assign":caml_js_wrap_meth_callback(t42)};
    var
     host=urldecode_js_string_string(_s_.hostname),
     protocol=urldecode_js_string_string(_s_.protocol),
     _t_=0,
     port=
      function(param)
        {try
          {var _dq_=[0,caml_int_of_string(caml_string_of_jsbytes(_s_.port))];
           return _dq_}
         catch(_dr_)
          {_dr_ = caml_wrap_exception(_dr_);
           if(_dr_[1] === Stdlib[7])return 0;
           throw _dr_}}
       (_t_),
     path_string=urldecode_js_string_string(_s_.pathname),
     path=path_of_path_string(path_string),
     t49=_s_.search;
    if(t49.charAt(0) === "?")
     var t52=_s_.search,_u_=t52.slice(1);
    else
     var _u_=_s_.search;
    var arguments$0=decode_arguments_js_string(_u_);
    function get_fragment(param)
     {function _dn_(res){return caml_string_of_jsstring(res[1])}
      function _do_(param){return cst$37}
      var t57=new t11("#(.*)"),t58=_s_.href,_dp_=t58.match(t57);
      return caml_call3(Opt[7],_dp_,_do_,_dn_)}
    function set_fragment(s)
     {var t59=caml_jsbytes_of_string(urlencode(0,s));return _s_.hash = t59}
    function get$2(param){return url_of_js_string(_s_.href)}
    function set$0(u)
     {var t62=caml_jsbytes_of_string(string_of_url(u));return _s_.href = t62}
    var
     as_string=urldecode_js_string_string(_s_.href),
     Js_of_ocaml_Url=
      [0,
       urldecode,
       urlencode,
       default_http_port,
       default_https_port,
       path_of_path_string,
       encode_arguments,
       decode_arguments,
       url_of_string,
       string_of_url,
       [0,
        host,
        port,
        protocol,
        path_string,
        path,
        arguments$0,
        get_fragment,
        set_fragment,
        get$2,
        set$0,
        as_string]];
    caml_register_global(1659,Js_of_ocaml_Url,"Js_of_ocaml__Url");
    var Js_of_ocaml_Lib_version=[0,s,git_version];
    caml_register_global
     (1660,Js_of_ocaml_Lib_version,"Js_of_ocaml__Lib_version");
    function update_file(name,content)
     {var oc=caml_call1(Stdlib[60],name);
      caml_call2(Stdlib[66],oc,content);
      return caml_call1(Stdlib[76],oc)}
    function set_channel_flusher(out_channel,f)
     {var
       f$0=
        caml_js_wrap_callback
         (function(s){return caml_call1(f,caml_string_of_jsbytes(s))});
      return runtime.caml_ml_set_channel_output(out_channel,f$0)}
    function set_channel_filler(in_channel,f)
     {var f$0=caml_js_wrap_callback(f);
      return runtime.caml_ml_set_channel_refill(in_channel,f$0)}
    function mount(path,f)
     {return runtime.caml_mount_autoload
              (path,
               caml_js_wrap_callback
                (function(prefix,path){return caml_call2(f,prefix,path)}))}
    function unmount(path){return runtime.caml_unmount(path)}
    if(caml_call2(String[62],git_version,cst$38))
     var js_of_ocaml_version=s;
    else
     var
      _co_=caml_call2(Stdlib[28],cst$41,git_version),
      js_of_ocaml_version=caml_call2(Stdlib[28],s,_co_);
    var
     _v_=runtime.caml_create_file,
     _w_=runtime.caml_read_file_content,
     Js_of_ocaml_Sys_js=
      [0,
       set_channel_flusher,
       set_channel_filler,
       function(_dm_){return runtime.caml_list_mount_point(_dm_)},
       unmount,
       mount,
       _w_,
       _v_,
       update_file,
       js_of_ocaml_version];
    caml_register_global(1661,Js_of_ocaml_Sys_js,"Js_of_ocaml__Sys_js");
    function empty_resize_observer_options(param){return {}}
    var t2$0=Unsafe[1].ResizeObserver;
    function is_supported$0(param){return caml_call1(Optdef[5],t2$0)}
    function observe(node,f,box,param)
     {var t1=caml_js_wrap_callback(f),t4=new t2$0(t1);
      if(box)
       {var box$0=box[1],t8={};t8.box = box$0;t4.observe(node,t8)}
      else
       t4.observe(node);
      return t4}
    var
     Js_of_ocaml_ResizeObserver=
      [0,empty_resize_observer_options,t2$0,is_supported$0,observe];
    caml_register_global
     (1662,Js_of_ocaml_ResizeObserver,"Js_of_ocaml__ResizeObserver");
    var t4$1=Unsafe[1].PerformanceObserver;
    function is_supported$1(param){return caml_call1(Optdef[5],t4$1)}
    function observe$0(entry_types,f)
     {var
       _dl_=
        caml_call1
         (caml_call1(Stdlib_List[19],caml_jsstring_of_string),entry_types),
       t1=caml_js_from_array(caml_call1(Stdlib_Array[12],_dl_)),
       t5={};
      t5.entryTypes = t1;
      var t3=caml_js_wrap_callback(f),t6=new t4$1(t3);
      t6.observe(t5);
      return t6}
    var Js_of_ocaml_PerformanceObserve=[0,t4$1,is_supported$1,observe$0];
    caml_register_global
     (1663,Js_of_ocaml_PerformanceObserve,"Js_of_ocaml__PerformanceObserver");
    function empty_mutation_observer_init(param){return {}}
    var t2$1=Unsafe[1].MutationObserver;
    function is_supported$2(param){return caml_call1(Optdef[5],t2$1)}
    function observe$1
     (node,
      f,
      child_list,
      attributes,
      character_data,
      subtree,
      attribute_old_value,
      character_data_old_value,
      attribute_filter,
      param)
     {function opt_iter(x,f)
       {if(x){var x$0=x[1];return caml_call1(f,x$0)}return 0}
      var t1=caml_js_wrap_callback(f),t19=new t2$1(t1),t18={};
      opt_iter(child_list,function(t3){return t18.childList = t3});
      opt_iter(attributes,function(t5){return t18.attributes = t5});
      opt_iter(character_data,function(t7){return t18.characterData = t7});
      opt_iter(subtree,function(t9){return t18.subtree = t9});
      opt_iter
       (attribute_old_value,function(t11){return t18.attributeOldValue = t11});
      opt_iter
       (character_data_old_value,
        function(t13){return t18.characterDataOldValue = t13});
      opt_iter
       (attribute_filter,
        function(l)
         {var t15=caml_js_from_array(caml_call1(Stdlib_Array[12],l));
          return t18.attributeFilter = t15});
      t19.observe(node,t18);
      return t19}
    var
     Js_of_ocaml_MutationObserver=
      [0,empty_mutation_observer_init,t2$1,is_supported$2,observe$1];
    caml_register_global
     (1664,Js_of_ocaml_MutationObserver,"Js_of_ocaml__MutationObserver");
    var t1=Unsafe[1].Object;
    function create$0(param){return new t1()}
    function add$0(t,k,v){return t[k.concat("_")] = v}
    function remove(t,k){return delete t[k.concat("_")]}
    function find(t,k){return t[k.concat("_")]}
    function keys(t)
     {var
       t10=Unsafe[1].Object,
       t11=t10.keys(t),
       res=[0,0],
       _dh_=t11.length - 1 | 0,
       _dg_=0;
      if(! (_dh_ < 0))
       {var i=_dg_;
        for(;;)
         {var
           _di_=function(param){return caml_call1(Stdlib[2],cst_Jstable_keys)},
           t15=caml_call2(Optdef[8],t11[i],_di_),
           t14=t15.length - 1 | 0,
           _dj_=res[1];
          res[1] = [0,t15.substring(0,t14),_dj_];
          var _dk_=i + 1 | 0;
          if(_dh_ !== i){var i=_dk_;continue}
          break}}
      return caml_call1(Stdlib_List[9],res[1])}
    var Js_of_ocaml_Jstable=[0,create$0,add$0,remove,find,keys];
    caml_register_global(1665,Js_of_ocaml_Jstable,"Js_of_ocaml__Jstable");
    var t11$1=Unsafe[1].JSON;
    function reviver(this$0,key,value)
     {if(typeof value === "string")return caml_string_of_jsbytes(value);
      if
       (value instanceof array_length
        &&
        4
        ===
        value.length
        &&
        255
        ===
        value[0])
       return runtime.caml_int64_create_lo_mi_hi(value[1],value[2],value[3]);
      return value}
    var t3$0=caml_js_wrap_meth_callback(reviver);
    function unsafe_input(t2){return t11$1.parse(t2,t3$0)}
    var mlInt64_constr=t5.constructor;
    function t10(key,value)
     {var _df_=Stdlib_Obj[13];
      return caml_call2(symbol$8,runtime.caml_obj_tag(value),_df_)
              ?caml_jsbytes_of_string(value)
              :value instanceof mlInt64_constr
                ?caml_js_from_array([0,255,value.lo,value.mi,value.hi])
                :value}
    function output(t9){return t11$1.stringify(t9,t10)}
    var Js_of_ocaml_Json=[0,output,unsafe_input];
    caml_register_global(1667,Js_of_ocaml_Json,"Js_of_ocaml__Json");
    function string_of_name(param)
     {var _de_=param;
      if(74 <= _de_)
       {if(111 <= _de_)
         switch(_de_)
          {case 111:return cst_palevioletred;
           case 112:return cst_papayawhip;
           case 113:return cst_peachpuff;
           case 114:return cst_peru;
           case 115:return cst_pink;
           case 116:return cst_plum;
           case 117:return cst_powderblue;
           case 118:return cst_purple;
           case 119:return cst_red;
           case 120:return cst_rosybrown;
           case 121:return cst_royalblue;
           case 122:return cst_saddlebrown;
           case 123:return cst_salmon;
           case 124:return cst_sandybrown;
           case 125:return cst_seagreen;
           case 126:return cst_seashell;
           case 127:return cst_sienna;
           case 128:return cst_silver;
           case 129:return cst_skyblue;
           case 130:return cst_slateblue;
           case 131:return cst_slategray;
           case 132:return cst_slategrey;
           case 133:return cst_snow;
           case 134:return cst_springgreen;
           case 135:return cst_steelblue;
           case 136:return cst_tan;
           case 137:return cst_teal;
           case 138:return cst_thistle;
           case 139:return cst_tomato;
           case 140:return cst_turquoise;
           case 141:return cst_violet;
           case 142:return cst_wheat;
           case 143:return cst_white;
           case 144:return cst_whitesmoke;
           case 145:return cst_yellow;
           default:return cst_yellowgreen}
        switch(_de_)
         {case 74:return cst_lightpink;
          case 75:return cst_lightsalmon;
          case 76:return cst_lightseagreen;
          case 77:return cst_lightskyblue;
          case 78:return cst_lightslategray;
          case 79:return cst_lightslategrey;
          case 80:return cst_lightsteelblue;
          case 81:return cst_lightyellow;
          case 82:return cst_lime;
          case 83:return cst_limegreen;
          case 84:return cst_linen;
          case 85:return cst_magenta;
          case 86:return cst_maroon;
          case 87:return cst_mediumaquamarine;
          case 88:return cst_mediumblue;
          case 89:return cst_mediumorchid;
          case 90:return cst_mediumpurple;
          case 91:return cst_mediumseagreen;
          case 92:return cst_mediumslateblue;
          case 93:return cst_mediumspringgreen;
          case 94:return cst_mediumturquoise;
          case 95:return cst_mediumvioletred;
          case 96:return cst_midnightblue;
          case 97:return cst_mintcream;
          case 98:return cst_mistyrose;
          case 99:return cst_moccasin;
          case 100:return cst_navajowhite;
          case 101:return cst_navy;
          case 102:return cst_oldlace;
          case 103:return cst_olive;
          case 104:return cst_olivedrab;
          case 105:return cst_orange;
          case 106:return cst_orangered;
          case 107:return cst_orchid;
          case 108:return cst_palegoldenrod;
          case 109:return cst_palegreen;
          default:return cst_paleturquoise}}
      if(37 <= _de_)
       switch(_de_)
        {case 37:return cst_darkslategrey;
         case 38:return cst_darkturquoise;
         case 39:return cst_darkviolet;
         case 40:return cst_deeppink;
         case 41:return cst_deepskyblue;
         case 42:return cst_dimgray;
         case 43:return cst_dimgrey;
         case 44:return cst_dodgerblue;
         case 45:return cst_firebrick;
         case 46:return cst_floralwhite;
         case 47:return cst_forestgreen;
         case 48:return cst_fuchsia;
         case 49:return cst_gainsboro;
         case 50:return cst_ghostwhite;
         case 51:return cst_gold;
         case 52:return cst_goldenrod;
         case 53:return cst_gray;
         case 54:return cst_grey;
         case 55:return cst_green;
         case 56:return cst_greenyellow;
         case 57:return cst_honeydew;
         case 58:return cst_hotpink;
         case 59:return cst_indianred;
         case 60:return cst_indigo;
         case 61:return cst_ivory;
         case 62:return cst_khaki;
         case 63:return cst_lavender;
         case 64:return cst_lavenderblush;
         case 65:return cst_lawngreen;
         case 66:return cst_lemonchiffon;
         case 67:return cst_lightblue;
         case 68:return cst_lightcoral;
         case 69:return cst_lightcyan;
         case 70:return cst_lightgoldenrodyellow;
         case 71:return cst_lightgray;
         case 72:return cst_lightgreen;
         default:return cst_lightgrey}
      switch(_de_)
       {case 0:return cst_aliceblue;
        case 1:return cst_antiquewhite;
        case 2:return cst_aqua;
        case 3:return cst_aquamarine;
        case 4:return cst_azure;
        case 5:return cst_beige;
        case 6:return cst_bisque;
        case 7:return cst_black;
        case 8:return cst_blanchedalmond;
        case 9:return cst_blue;
        case 10:return cst_blueviolet;
        case 11:return cst_brown;
        case 12:return cst_burlywood;
        case 13:return cst_cadetblue;
        case 14:return cst_chartreuse;
        case 15:return cst_chocolate;
        case 16:return cst_coral;
        case 17:return cst_cornflowerblue;
        case 18:return cst_cornsilk;
        case 19:return cst_crimson;
        case 20:return cst_cyan;
        case 21:return cst_darkblue;
        case 22:return cst_darkcyan;
        case 23:return cst_darkgoldenrod;
        case 24:return cst_darkgray;
        case 25:return cst_darkgreen;
        case 26:return cst_darkgrey;
        case 27:return cst_darkkhaki;
        case 28:return cst_darkmagenta;
        case 29:return cst_darkolivegreen;
        case 30:return cst_darkorange;
        case 31:return cst_darkorchid;
        case 32:return cst_darkred;
        case 33:return cst_darksalmon;
        case 34:return cst_darkseagreen;
        case 35:return cst_darkslateblue;
        default:return cst_darkslategray}}
    function name_of_string(s)
     {var switch$0=caml_string_compare(s,cst_lightgrey$0);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 73;
        var switch$1=caml_string_compare(s,cst_paleturquoise$0);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 110;
          var switch$2=caml_string_compare(s,cst_skyblue$0);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 129;
            var switch$3=caml_string_compare(s,cst_thistle$0);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 138;
              if(! caml_string_notequal(s,cst_tomato$0))return 139;
              if(! caml_string_notequal(s,cst_turquoise$0))return 140;
              if(! caml_string_notequal(s,cst_violet$0))return 141;
              if(! caml_string_notequal(s,cst_wheat$0))return 142;
              if(! caml_string_notequal(s,cst_white$0))return 143;
              if(! caml_string_notequal(s,cst_whitesmoke$0))return 144;
              if(! caml_string_notequal(s,cst_yellow$0))return 145;
              if(! caml_string_notequal(s,cst_yellowgreen$0))return 146}
            else
             {if(! caml_string_notequal(s,cst_slateblue$0))return 130;
              if(! caml_string_notequal(s,cst_slategray$0))return 131;
              if(! caml_string_notequal(s,cst_slategrey$0))return 132;
              if(! caml_string_notequal(s,cst_snow$0))return 133;
              if(! caml_string_notequal(s,cst_springgreen$0))return 134;
              if(! caml_string_notequal(s,cst_steelblue$0))return 135;
              if(! caml_string_notequal(s,cst_tan$0))return 136;
              if(! caml_string_notequal(s,cst_teal$0))return 137}}
          else
           {var switch$4=caml_string_compare(s,cst_rosybrown$0);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 120;
              if(! caml_string_notequal(s,cst_royalblue$0))return 121;
              if(! caml_string_notequal(s,cst_saddlebrown$0))return 122;
              if(! caml_string_notequal(s,cst_salmon$0))return 123;
              if(! caml_string_notequal(s,cst_sandybrown$0))return 124;
              if(! caml_string_notequal(s,cst_seagreen$0))return 125;
              if(! caml_string_notequal(s,cst_seashell$0))return 126;
              if(! caml_string_notequal(s,cst_sienna$0))return 127;
              if(! caml_string_notequal(s,cst_silver$0))return 128}
            else
             {if(! caml_string_notequal(s,cst_palevioletred$0))return 111;
              if(! caml_string_notequal(s,cst_papayawhip$0))return 112;
              if(! caml_string_notequal(s,cst_peachpuff$0))return 113;
              if(! caml_string_notequal(s,cst_peru$0))return 114;
              if(! caml_string_notequal(s,cst_pink$0))return 115;
              if(! caml_string_notequal(s,cst_plum$0))return 116;
              if(! caml_string_notequal(s,cst_powderblue$0))return 117;
              if(! caml_string_notequal(s,cst_purple$0))return 118;
              if(! caml_string_notequal(s,cst_red$0))return 119}}}
        else
         {var switch$5=caml_string_compare(s,cst_mediumslateblue$0);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 92;
            var switch$6=caml_string_compare(s,cst_navy$0);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 101;
              if(! caml_string_notequal(s,cst_oldlace$0))return 102;
              if(! caml_string_notequal(s,cst_olive$0))return 103;
              if(! caml_string_notequal(s,cst_olivedrab$0))return 104;
              if(! caml_string_notequal(s,cst_orange$0))return 105;
              if(! caml_string_notequal(s,cst_orangered$0))return 106;
              if(! caml_string_notequal(s,cst_orchid$0))return 107;
              if(! caml_string_notequal(s,cst_palegoldenrod$0))return 108;
              if(! caml_string_notequal(s,cst_palegreen$0))return 109}
            else
             {if(! caml_string_notequal(s,cst_mediumspringgreen$0))return 93;
              if(! caml_string_notequal(s,cst_mediumturquoise$0))return 94;
              if(! caml_string_notequal(s,cst_mediumvioletred$0))return 95;
              if(! caml_string_notequal(s,cst_midnightblue$0))return 96;
              if(! caml_string_notequal(s,cst_mintcream$0))return 97;
              if(! caml_string_notequal(s,cst_mistyrose$0))return 98;
              if(! caml_string_notequal(s,cst_moccasin$0))return 99;
              if(! caml_string_notequal(s,cst_navajowhite$0))return 100}}
          else
           {var switch$7=caml_string_compare(s,cst_limegreen$0);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 83;
              if(! caml_string_notequal(s,cst_linen$0))return 84;
              if(! caml_string_notequal(s,cst_magenta$0))return 85;
              if(! caml_string_notequal(s,cst_maroon$0))return 86;
              if(! caml_string_notequal(s,cst_mediumaquamarine$0))return 87;
              if(! caml_string_notequal(s,cst_mediumblue$0))return 88;
              if(! caml_string_notequal(s,cst_mediumorchid$0))return 89;
              if(! caml_string_notequal(s,cst_mediumpurple$0))return 90;
              if(! caml_string_notequal(s,cst_mediumseagreen$0))return 91}
            else
             {if(! caml_string_notequal(s,cst_lightpink$0))return 74;
              if(! caml_string_notequal(s,cst_lightsalmon$0))return 75;
              if(! caml_string_notequal(s,cst_lightseagreen$0))return 76;
              if(! caml_string_notequal(s,cst_lightskyblue$0))return 77;
              if(! caml_string_notequal(s,cst_lightslategray$0))return 78;
              if(! caml_string_notequal(s,cst_lightslategrey$0))return 79;
              if(! caml_string_notequal(s,cst_lightsteelblue$0))return 80;
              if(! caml_string_notequal(s,cst_lightyellow$0))return 81;
              if(! caml_string_notequal(s,cst_lime$0))return 82}}}}
      else
       {var switch$8=caml_string_compare(s,cst_darkslategray$0);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 36;
          var switch$9=caml_string_compare(s,cst_greenyellow$0);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 56;
            var switch$10=caml_string_compare(s,cst_lavenderblush$0);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 64;
              if(! caml_string_notequal(s,cst_lawngreen$0))return 65;
              if(! caml_string_notequal(s,cst_lemonchiffon$0))return 66;
              if(! caml_string_notequal(s,cst_lightblue$0))return 67;
              if(! caml_string_notequal(s,cst_lightcoral$0))return 68;
              if(! caml_string_notequal(s,cst_lightcyan$0))return 69;
              if(! caml_string_notequal(s,cst_lightgoldenrodyellow$0))
               return 70;
              if(! caml_string_notequal(s,cst_lightgray$0))return 71;
              if(! caml_string_notequal(s,cst_lightgreen$0))return 72}
            else
             {if(! caml_string_notequal(s,cst_grey$0))return 54;
              if(! caml_string_notequal(s,cst_honeydew$0))return 57;
              if(! caml_string_notequal(s,cst_hotpink$0))return 58;
              if(! caml_string_notequal(s,cst_indianred$0))return 59;
              if(! caml_string_notequal(s,cst_indigo$0))return 60;
              if(! caml_string_notequal(s,cst_ivory$0))return 61;
              if(! caml_string_notequal(s,cst_khaki$0))return 62;
              if(! caml_string_notequal(s,cst_lavender$0))return 63}}
          else
           {var switch$11=caml_string_compare(s,cst_floralwhite$0);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 46;
              if(! caml_string_notequal(s,cst_forestgreen$0))return 47;
              if(! caml_string_notequal(s,cst_fuchsia$0))return 48;
              if(! caml_string_notequal(s,cst_gainsboro$0))return 49;
              if(! caml_string_notequal(s,cst_ghostwhite$0))return 50;
              if(! caml_string_notequal(s,cst_gold$0))return 51;
              if(! caml_string_notequal(s,cst_goldenrod$0))return 52;
              if(! caml_string_notequal(s,cst_gray$0))return 53;
              if(! caml_string_notequal(s,cst_green$0))return 55}
            else
             {if(! caml_string_notequal(s,cst_darkslategrey$0))return 37;
              if(! caml_string_notequal(s,cst_darkturquoise$0))return 38;
              if(! caml_string_notequal(s,cst_darkviolet$0))return 39;
              if(! caml_string_notequal(s,cst_deeppink$0))return 40;
              if(! caml_string_notequal(s,cst_deepskyblue$0))return 41;
              if(! caml_string_notequal(s,cst_dimgray$0))return 42;
              if(! caml_string_notequal(s,cst_dimgrey$0))return 43;
              if(! caml_string_notequal(s,cst_dodgerblue$0))return 44;
              if(! caml_string_notequal(s,cst_firebrick$0))return 45}}}
        else
         {var switch$12=caml_string_compare(s,cst_cornsilk$0);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 18;
            var switch$13=caml_string_compare(s,cst_darkkhaki$0);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 27;
              if(! caml_string_notequal(s,cst_darkmagenta$0))return 28;
              if(! caml_string_notequal(s,cst_darkolivegreen$0))return 29;
              if(! caml_string_notequal(s,cst_darkorange$0))return 30;
              if(! caml_string_notequal(s,cst_darkorchid$0))return 31;
              if(! caml_string_notequal(s,cst_darkred$0))return 32;
              if(! caml_string_notequal(s,cst_darksalmon$0))return 33;
              if(! caml_string_notequal(s,cst_darkseagreen$0))return 34;
              if(! caml_string_notequal(s,cst_darkslateblue$0))return 35}
            else
             {if(! caml_string_notequal(s,cst_crimson$0))return 19;
              if(! caml_string_notequal(s,cst_cyan$0))return 20;
              if(! caml_string_notequal(s,cst_darkblue$0))return 21;
              if(! caml_string_notequal(s,cst_darkcyan$0))return 22;
              if(! caml_string_notequal(s,cst_darkgoldenrod$0))return 23;
              if(! caml_string_notequal(s,cst_darkgray$0))return 24;
              if(! caml_string_notequal(s,cst_darkgreen$0))return 25;
              if(! caml_string_notequal(s,cst_darkgrey$0))return 26}}
          else
           {var switch$14=caml_string_compare(s,cst_blue$0);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 9;
              if(! caml_string_notequal(s,cst_blueviolet$0))return 10;
              if(! caml_string_notequal(s,cst_brown$0))return 11;
              if(! caml_string_notequal(s,cst_burlywood$0))return 12;
              if(! caml_string_notequal(s,cst_cadetblue$0))return 13;
              if(! caml_string_notequal(s,cst_chartreuse$0))return 14;
              if(! caml_string_notequal(s,cst_chocolate$0))return 15;
              if(! caml_string_notequal(s,cst_coral$0))return 16;
              if(! caml_string_notequal(s,cst_cornflowerblue$0))return 17}
            else
             {if(! caml_string_notequal(s,cst_aliceblue$0))return 0;
              if(! caml_string_notequal(s,cst_antiquewhite$0))return 1;
              if(! caml_string_notequal(s,cst_aqua$0))return 2;
              if(! caml_string_notequal(s,cst_aquamarine$0))return 3;
              if(! caml_string_notequal(s,cst_azure$0))return 4;
              if(! caml_string_notequal(s,cst_beige$0))return 5;
              if(! caml_string_notequal(s,cst_bisque$0))return 6;
              if(! caml_string_notequal(s,cst_black$0))return 7;
              if(! caml_string_notequal(s,cst_blanchedalmond$0))return 8}}}}
      var _dd_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_color_name);
      throw [0,Stdlib[6],_dd_]}
    function rgb_of_name(param)
     {var _dc_=param;
      if(74 <= _dc_)
       {if(111 <= _dc_)
         switch(_dc_)
          {case 111:return _bq_;
           case 112:return _br_;
           case 113:return _bs_;
           case 114:return _bt_;
           case 115:return _bu_;
           case 116:return _bv_;
           case 117:return _bw_;
           case 118:return _bx_;
           case 119:return _by_;
           case 120:return _bz_;
           case 121:return _bA_;
           case 122:return _bB_;
           case 123:return _bC_;
           case 124:return _bD_;
           case 125:return _bE_;
           case 126:return _bF_;
           case 127:return _bG_;
           case 128:return _bH_;
           case 129:return _bI_;
           case 130:return _bJ_;
           case 131:return _bK_;
           case 132:return _bL_;
           case 133:return _bM_;
           case 134:return _bN_;
           case 135:return _bO_;
           case 136:return _bP_;
           case 137:return _bQ_;
           case 138:return _bR_;
           case 139:return _bS_;
           case 140:return _bT_;
           case 141:return _bU_;
           case 142:return _bV_;
           case 143:return _bW_;
           case 144:return _bX_;
           case 145:return _bY_;
           default:return _bZ_}
        switch(_dc_)
         {case 74:return _aR_;
          case 75:return _aS_;
          case 76:return _aT_;
          case 77:return _aU_;
          case 78:return _aV_;
          case 79:return _aW_;
          case 80:return _aX_;
          case 81:return _aY_;
          case 82:return _aZ_;
          case 83:return _a0_;
          case 84:return _a1_;
          case 85:return _a2_;
          case 86:return _a3_;
          case 87:return _a4_;
          case 88:return _a5_;
          case 89:return _a6_;
          case 90:return _a7_;
          case 91:return _a8_;
          case 92:return _a9_;
          case 93:return _a__;
          case 94:return _a$_;
          case 95:return _ba_;
          case 96:return _bb_;
          case 97:return _bc_;
          case 98:return _bd_;
          case 99:return _be_;
          case 100:return _bf_;
          case 101:return _bg_;
          case 102:return _bh_;
          case 103:return _bi_;
          case 104:return _bj_;
          case 105:return _bk_;
          case 106:return _bl_;
          case 107:return _bm_;
          case 108:return _bn_;
          case 109:return _bo_;
          default:return _bp_}}
      if(37 <= _dc_)
       switch(_dc_)
        {case 37:return _ag_;
         case 38:return _ah_;
         case 39:return _ai_;
         case 40:return _aj_;
         case 41:return _ak_;
         case 42:return _al_;
         case 43:return _am_;
         case 44:return _an_;
         case 45:return _ao_;
         case 46:return _ap_;
         case 47:return _aq_;
         case 48:return _ar_;
         case 49:return _as_;
         case 50:return _at_;
         case 51:return _au_;
         case 52:return _av_;
         case 53:return _aw_;
         case 54:return _ax_;
         case 55:return _ay_;
         case 56:return _az_;
         case 57:return _aA_;
         case 58:return _aB_;
         case 59:return _aC_;
         case 60:return _aD_;
         case 61:return _aE_;
         case 62:return _aF_;
         case 63:return _aG_;
         case 64:return _aH_;
         case 65:return _aI_;
         case 66:return _aJ_;
         case 67:return _aK_;
         case 68:return _aL_;
         case 69:return _aM_;
         case 70:return _aN_;
         case 71:return _aO_;
         case 72:return _aP_;
         default:return _aQ_}
      switch(_dc_)
       {case 0:return _x_;
        case 1:return _y_;
        case 2:return _z_;
        case 3:return _A_;
        case 4:return _B_;
        case 5:return _C_;
        case 6:return _D_;
        case 7:return _E_;
        case 8:return _F_;
        case 9:return _G_;
        case 10:return _H_;
        case 11:return _I_;
        case 12:return _J_;
        case 13:return _K_;
        case 14:return _L_;
        case 15:return _M_;
        case 16:return _N_;
        case 17:return _O_;
        case 18:return _P_;
        case 19:return _Q_;
        case 20:return _R_;
        case 21:return _S_;
        case 22:return _T_;
        case 23:return _U_;
        case 24:return _V_;
        case 25:return _W_;
        case 26:return _X_;
        case 27:return _Y_;
        case 28:return _Z_;
        case 29:return ___;
        case 30:return _$_;
        case 31:return _aa_;
        case 32:return _ab_;
        case 33:return _ac_;
        case 34:return _ad_;
        case 35:return _ae_;
        default:return _af_}}
    function rgb(a,r,g,b)
     {if(a){var a$0=a[1];return [3,[0,r,g,b,a$0]]}return [1,[0,r,g,b]]}
    function hsl(a,h,s,l)
     {if(a){var a$0=a[1];return [6,[0,h,s,l,a$0]]}return [5,[0,h,s,l]]}
    function string_of_t(param)
     {switch(param[0])
       {case 0:var n=param[1];return string_of_name(n);
        case 1:
         var match=param[1],b=match[3],g=match[2],r=match[1];
         return caml_call4(Stdlib_Printf[4],_b0_,r,g,b);
        case 2:
         var match$0=param[1],b$0=match$0[3],g$0=match$0[2],r$0=match$0[1];
         return caml_call4(Stdlib_Printf[4],_b1_,r$0,g$0,b$0);
        case 3:
         var
          match$1=param[1],
          a=match$1[4],
          b$1=match$1[3],
          g$1=match$1[2],
          r$1=match$1[1];
         return caml_call5(Stdlib_Printf[4],_b2_,r$1,g$1,b$1,a);
        case 4:
         var
          match$2=param[1],
          a$0=match$2[4],
          b$2=match$2[3],
          g$2=match$2[2],
          r$2=match$2[1];
         return caml_call5(Stdlib_Printf[4],_b3_,r$2,g$2,b$2,a$0);
        case 5:
         var match$3=param[1],l=match$3[3],s=match$3[2],h=match$3[1];
         return caml_call4(Stdlib_Printf[4],_b4_,h,s,l);
        default:
         var
          match$4=param[1],
          a$1=match$4[4],
          l$0=match$4[3],
          s$0=match$4[2],
          h$0=match$4[1];
         return caml_call5(Stdlib_Printf[4],_b5_,h$0,s$0,l$0,a$1)}}
    function hex_of_rgb(param)
     {var blue=param[3],green=param[2],red=param[1];
      function in_range(i)
       {var
         _c__=caml_call2(symbol$5,i,0),
         _c$_=_c__ || caml_call2(symbol$9,i,255);
        if(_c$_)
         {var
           _da_=caml_call1(Stdlib[33],i),
           _db_=caml_call2(Stdlib[28],_da_,cst_is_out_of_valid_range);
          throw [0,Stdlib[6],_db_]}
        return _c$_}
      in_range(red);
      in_range(green);
      in_range(blue);
      return caml_call4(Stdlib_Printf[4],_b6_,red,green,blue)}
    function js_t_of_js_string(s)
     {var
       t0=caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d),
       t13=new t11(t0),
       t2=caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d$0),
       t17=new t11(t2),
       t4=caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d),
       t15=new t11(t4),
       t6=caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d$0),
       t19=new t11(t6),
       t8=caml_jsbytes_of_string(cst_hsl_s_d_s_d_s_d),
       t21=new t11(t8),
       t10=caml_jsbytes_of_string(cst_hsla_s_d_s_d_s_d_d_d),
       t23=new t11(t10);
      if
       (!
        (t13.test(s) | 0)
        &&
        !
        (t15.test(s) | 0)
        &&
        !
        (t17.test(s) | 0)
        &&
        !
        (t19.test(s) | 0)
        &&
        !
        (t21.test(s) | 0)
        &&
        !
        (t23.test(s) | 0))
       {var _c7_=caml_string_of_jsstring(s);
        if(caml_call2(Stdlib_List[36],_c7_,_b7_))return s;
        var
         _c8_=caml_string_of_jsstring(s),
         _c9_=caml_call2(Stdlib[28],_c8_,cst_is_not_a_valid_color);
        throw [0,Stdlib[6],_c9_]}
      return s}
    function js(c)
     {if(0 === c[0])
       {var n=c[1];return caml_jsstring_of_string(string_of_name(n))}
      return caml_jsstring_of_string(string_of_t(c))}
    function ml(c)
     {var s=caml_string_of_jsstring(c);
      try
       {var _cU_=[0,name_of_string(s)];return _cU_}
      catch(_cV_)
       {_cV_ = caml_wrap_exception(_cV_);
        if(_cV_[1] === Stdlib[6])
         {var
           fail=
            function(param)
             {var _c6_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_color$0);
              throw [0,Stdlib[6],_c6_]},
           re_rgb=regexp(cst_rgba_d_d_d_d_d),
           re_rgb_pct=regexp(cst_rgba_d_d_d_d_d$0),
           re_hsl=regexp(cst_hsla_d_d_d_d_d),
           i_of_s_o=
            function(param)
             {if(param)
               {var i=param[1];
                try
                 {var _c4_=caml_int_of_string(i);return _c4_}
                catch(_c5_)
                 {_c5_ = caml_wrap_exception(_c5_);
                  if(_c5_[1] === Stdlib[6])
                   var s=_c5_[2];
                  else
                   {if(_c5_[1] !== Stdlib[7])throw _c5_;var s=_c5_[2]}
                  var
                   _c1_=caml_call2(Stdlib[28],cst$39,s),
                   _c2_=caml_call2(Stdlib[28],i,_c1_),
                   _c3_=caml_call2(Stdlib[28],cst_color_conversion_error,_c2_);
                  throw [0,Stdlib[6],_c3_]}}
              return fail(0)},
           f_of_s=
            function(f)
             {try
               {var _cZ_=caml_float_of_string(f);return _cZ_}
              catch(_c0_)
               {_c0_ = caml_wrap_exception(_c0_);
                if(_c0_[1] === Stdlib[6])
                 var s=_c0_[2];
                else
                 {if(_c0_[1] !== Stdlib[7])throw _c0_;var s=_c0_[2]}
                var
                 _cW_=caml_call2(Stdlib[28],cst$40,s),
                 _cX_=caml_call2(Stdlib[28],f,_cW_),
                 _cY_=caml_call2(Stdlib[28],cst_color_conversion_error$0,_cX_);
                throw [0,Stdlib[6],_cY_]}},
           match=string_match(re_rgb,s,0);
          if(match)
           {var
             r=match[1],
             red=matched_group(r,2),
             green=matched_group(r,3),
             blue=matched_group(r,4),
             alpha=matched_group(r,5),
             match$0=matched_group(r,1);
            if(match$0)
             {var _cC_=match$0[1];
              if(! caml_string_notequal(_cC_,cst_rgb))
               {if(alpha)return fail(0);
                var _cG_=i_of_s_o(blue),_cH_=i_of_s_o(green);
                return [1,[0,i_of_s_o(red),_cH_,_cG_]]}
              if(! caml_string_notequal(_cC_,cst_rgba))
               {if(alpha)
                 {var
                   a=alpha[1],
                   _cD_=f_of_s(a),
                   _cE_=i_of_s_o(blue),
                   _cF_=i_of_s_o(green);
                  return [3,[0,i_of_s_o(red),_cF_,_cE_,_cD_]]}
                return fail(0)}}
            return fail(0)}
          var match$1=string_match(re_rgb_pct,s,0);
          if(match$1)
           {var
             r$0=match$1[1],
             red$0=matched_group(r$0,2),
             green$0=matched_group(r$0,3),
             blue$0=matched_group(r$0,4),
             alpha$0=matched_group(r$0,5),
             match$2=matched_group(r$0,1);
            if(match$2)
             {var _cI_=match$2[1];
              if(! caml_string_notequal(_cI_,cst_rgb$0))
               {if(alpha$0)return fail(0);
                var _cM_=i_of_s_o(blue$0),_cN_=i_of_s_o(green$0);
                return [2,[0,i_of_s_o(red$0),_cN_,_cM_]]}
              if(! caml_string_notequal(_cI_,cst_rgba$0))
               {if(alpha$0)
                 {var
                   a$0=alpha$0[1],
                   _cJ_=f_of_s(a$0),
                   _cK_=i_of_s_o(blue$0),
                   _cL_=i_of_s_o(green$0);
                  return [4,[0,i_of_s_o(red$0),_cL_,_cK_,_cJ_]]}
                return fail(0)}}
            return fail(0)}
          var match$3=string_match(re_hsl,s,0);
          if(match$3)
           {var
             r$1=match$3[1],
             red$1=matched_group(r$1,2),
             green$1=matched_group(r$1,3),
             blue$1=matched_group(r$1,4),
             alpha$1=matched_group(r$1,5),
             match$4=matched_group(r$1,1);
            if(match$4)
             {var _cO_=match$4[1];
              if(! caml_string_notequal(_cO_,cst_hsl))
               {if(alpha$1)return fail(0);
                var _cS_=i_of_s_o(blue$1),_cT_=i_of_s_o(green$1);
                return [5,[0,i_of_s_o(red$1),_cT_,_cS_]]}
              if(! caml_string_notequal(_cO_,cst_hsla))
               {if(alpha$1)
                 {var
                   a$1=alpha$1[1],
                   _cP_=f_of_s(a$1),
                   _cQ_=i_of_s_o(blue$1),
                   _cR_=i_of_s_o(green$1);
                  return [6,[0,i_of_s_o(red$1),_cR_,_cQ_,_cP_]]}
                return fail(0)}}
            return fail(0)}
          return fail(0)}
        throw _cV_}}
    function string_of_t$0(param)
     {if(typeof param === "number")
       return cst_0;
      else
       switch(param[0])
        {case 0:
          var f=param[1];return caml_call3(Stdlib_Printf[4],_b8_,f,cst_em$0);
         case 1:
          var f$0=param[1];
          return caml_call3(Stdlib_Printf[4],_b9_,f$0,cst_ex);
         case 2:
          var f$1=param[1];
          return caml_call3(Stdlib_Printf[4],_b__,f$1,cst_px);
         case 3:
          var f$2=param[1];
          return caml_call3(Stdlib_Printf[4],_b$_,f$2,cst_gd);
         case 4:
          var f$3=param[1];
          return caml_call3(Stdlib_Printf[4],_ca_,f$3,cst_rem);
         case 5:
          var f$4=param[1];
          return caml_call3(Stdlib_Printf[4],_cb_,f$4,cst_vw);
         case 6:
          var f$5=param[1];
          return caml_call3(Stdlib_Printf[4],_cc_,f$5,cst_vh);
         case 7:
          var f$6=param[1];
          return caml_call3(Stdlib_Printf[4],_cd_,f$6,cst_vm);
         case 8:
          var f$7=param[1];
          return caml_call3(Stdlib_Printf[4],_ce_,f$7,cst_ch);
         case 9:
          var f$8=param[1];
          return caml_call3(Stdlib_Printf[4],_cf_,f$8,cst_mm);
         case 10:
          var f$9=param[1];
          return caml_call3(Stdlib_Printf[4],_cg_,f$9,cst_cm);
         case 11:
          var f$10=param[1];
          return caml_call3(Stdlib_Printf[4],_ch_,f$10,cst_in);
         case 12:
          var f$11=param[1];
          return caml_call3(Stdlib_Printf[4],_ci_,f$11,cst_pt);
         default:
          var f$12=param[1];
          return caml_call3(Stdlib_Printf[4],_cj_,f$12,cst_pc)}}
    function js$0(t){return caml_jsstring_of_string(string_of_t$0(t))}
    function ml$0(t)
     {var s=caml_string_of_jsstring(t);
      if(caml_call2(String[62],s,cst_0$0))return 0;
      function fail(param)
       {var _cB_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_length);
        throw [0,Stdlib[6],_cB_]}
      var re=regexp(cst_d_d_s_S),match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cz_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Stdlib[6])
             {var
               s$0=exn[2],
               _cy_=caml_call2(Stdlib[28],cst_length_conversion_error,s$0);
              throw [0,Stdlib[6],_cy_]}
            throw exn}
          var f$0=_cz_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cA_=match$1[1],switch$0=caml_string_compare(_cA_,cst_pc$0);
          if(0 <= switch$0)
           {if(! (0 < switch$0))return [13,f$0];
            if(! caml_string_notequal(_cA_,cst_pt$0))return [12,f$0];
            if(! caml_string_notequal(_cA_,cst_px$0))return [2,f$0];
            if(! caml_string_notequal(_cA_,cst_rem$0))return [4,f$0];
            if(! caml_string_notequal(_cA_,cst_vh$0))return [6,f$0];
            if(! caml_string_notequal(_cA_,cst_vm$0))return [7,f$0];
            if(! caml_string_notequal(_cA_,cst_vw$0))return [5,f$0]}
          else
           {if(! caml_string_notequal(_cA_,cst_ch$0))return [8,f$0];
            if(! caml_string_notequal(_cA_,cst_cm$0))return [10,f$0];
            if(! caml_string_notequal(_cA_,cst_em$1))return [0,f$0];
            if(! caml_string_notequal(_cA_,cst_ex$0))return [1,f$0];
            if(! caml_string_notequal(_cA_,cst_gd$0))return [3,f$0];
            if(! caml_string_notequal(_cA_,cst_in$0))return [11,f$0];
            if(! caml_string_notequal(_cA_,cst_mm$0))return [9,f$0]}
          return fail(0)}
        return fail(0)}
      return fail(0)}
    var Length=[0,string_of_t$0,js$0,ml$0];
    function string_of_t$1(param)
     {switch(param[0])
       {case 0:
         var f=param[1];return caml_call3(Stdlib_Printf[4],_ck_,f,cst_deg);
        case 1:
         var f$0=param[1];
         return caml_call3(Stdlib_Printf[4],_cl_,f$0,cst_grad);
        case 2:
         var f$1=param[1];
         return caml_call3(Stdlib_Printf[4],_cm_,f$1,cst_rad);
        default:
         var f$2=param[1];
         return caml_call3(Stdlib_Printf[4],_cn_,f$2,cst_turns)}}
    function js$1(t){return caml_jsstring_of_string(string_of_t$1(t))}
    function ml$1(j)
     {var s=caml_string_of_jsstring(j),re=regexp(cst_d_d_deg_grad_rad_turns);
      function fail(param)
       {var _cx_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_length$0);
        throw [0,Stdlib[6],_cx_]}
      var match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cv_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Stdlib[6])
             {var
               s$0=exn[2],
               _cu_=caml_call2(Stdlib[28],cst_length_conversion_error$0,s$0);
              throw [0,Stdlib[6],_cu_]}
            throw exn}
          var f$0=_cv_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cw_=match$1[1];
          if(! caml_string_notequal(_cw_,cst_deg$0))return [0,f$0];
          if(! caml_string_notequal(_cw_,cst_grad$0))return [1,f$0];
          if(! caml_string_notequal(_cw_,cst_rad$0))return [2,f$0];
          if(! caml_string_notequal(_cw_,cst_turns$0))return [3,f$0]}
        return fail(0)}
      return fail(0)}
    var
     Angle=[0,string_of_t$1,js$1,ml$1],
     Js_of_ocaml_CSS=
      [0,
       [0,
        string_of_name,
        rgb_of_name,
        hex_of_rgb,
        rgb,
        hsl,
        string_of_t,
        js,
        ml,
        js_t_of_js_string],
       Length,
       Angle];
    caml_register_global(1668,Js_of_ocaml_CSS,"Js_of_ocaml__CSS");
    function listen(opt,target,typ,cb)
     {if(opt)var sth=opt[1],capture=sth;else var capture=0;
      var _ct_=! ! capture;
      return addEventListener
              (target,
               typ,
               full_handler(function(n,e){return ! ! caml_call2(cb,n,e)}),
               _ct_)}
    var Js_of_ocaml_Dom_events=[0,Event$0,listen,removeEventListener];
    caml_register_global
     (1669,Js_of_ocaml_Dom_events,"Js_of_ocaml__Dom_events");
    var
     t0="http://www.w3.org/2000/svg",
     SVGError=[248,cst_Js_of_ocaml_Dom_svg_SVGErr,caml_fresh_oo_id(0)];
    function createElement$0(t2,name)
     {var t1=caml_jsstring_of_string(name);
      return t2.createElementNS("http://www.w3.org/2000/svg",t1)}
    function unsafeCreateElement$0(doc,name){return createElement$0(doc,name)}
    function createA$0(doc){return unsafeCreateElement$0(doc,cst_a$2)}
    function createAltGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_altglyph)}
    function createAltGlyphDef(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphdef)}
    function createAltGlyphItem(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphitem)}
    function createAnimate(doc){return unsafeCreateElement$0(doc,cst_animate)}
    function createAnimateColor(doc)
     {return unsafeCreateElement$0(doc,cst_animatecolor)}
    function createAnimateMotion(doc)
     {return unsafeCreateElement$0(doc,cst_animatemotion)}
    function createAnimateTransform(doc)
     {return unsafeCreateElement$0(doc,cst_animatetransform)}
    function createCircle(doc){return unsafeCreateElement$0(doc,cst_circle)}
    function createClipPath(doc)
     {return unsafeCreateElement$0(doc,cst_clippath)}
    function createCursor(doc){return unsafeCreateElement$0(doc,cst_cursor)}
    function createDefs(doc){return unsafeCreateElement$0(doc,cst_defs)}
    function createDesc(doc){return unsafeCreateElement$0(doc,cst_desc)}
    function createEllipse(doc){return unsafeCreateElement$0(doc,cst_ellipse)}
    function createFilter(doc){return unsafeCreateElement$0(doc,cst_filter)}
    function createFont(doc){return unsafeCreateElement$0(doc,cst_font)}
    function createFontFace(doc)
     {return unsafeCreateElement$0(doc,cst_font_face)}
    function createFontFaceFormat(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_format)}
    function createFontFaceName(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_name)}
    function createFontFaceSrc(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_src)}
    function createFontFaceUri(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_uri)}
    function createForeignObject(doc)
     {return unsafeCreateElement$0(doc,cst_foreignObject)}
    function createG(doc){return unsafeCreateElement$0(doc,cst_g$0)}
    function createGlyph(doc){return unsafeCreateElement$0(doc,cst_glyph)}
    function createGlyphRef(doc)
     {return unsafeCreateElement$0(doc,cst_glyphref)}
    function createhkern(doc){return unsafeCreateElement$0(doc,cst_hkern)}
    function createImage(doc){return unsafeCreateElement$0(doc,cst_image)}
    function createLineElement(doc)
     {return unsafeCreateElement$0(doc,cst_line)}
    function createLinearElement(doc)
     {return unsafeCreateElement$0(doc,cst_lineargradient)}
    function createMask(doc){return unsafeCreateElement$0(doc,cst_mask)}
    function createMetaData(doc)
     {return unsafeCreateElement$0(doc,cst_metadata)}
    function createMissingGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_missing_glyph)}
    function createMPath(doc){return unsafeCreateElement$0(doc,cst_mpath)}
    function createPath(doc){return unsafeCreateElement$0(doc,cst_path)}
    function createPattern(doc){return unsafeCreateElement$0(doc,cst_pattern)}
    function createPolygon(doc){return unsafeCreateElement$0(doc,cst_polygon)}
    function createPolyline(doc)
     {return unsafeCreateElement$0(doc,cst_polyline)}
    function createRadialgradient(doc)
     {return unsafeCreateElement$0(doc,cst_radialgradient)}
    function createRect(doc){return unsafeCreateElement$0(doc,cst_rect)}
    function createScript$0(doc)
     {return unsafeCreateElement$0(doc,cst_script$2)}
    function createSet(doc){return unsafeCreateElement$0(doc,cst_set)}
    function createStop(doc){return unsafeCreateElement$0(doc,cst_stop)}
    function createStyle$0(doc){return unsafeCreateElement$0(doc,cst_style$2)}
    function createSvg(doc){return unsafeCreateElement$0(doc,cst_svg)}
    function createSwitch(doc){return unsafeCreateElement$0(doc,cst_switch)}
    function createSymbol(doc){return unsafeCreateElement$0(doc,cst_symbol)}
    function createTextElement(doc)
     {return unsafeCreateElement$0(doc,cst_text$0)}
    function createTextpath(doc)
     {return unsafeCreateElement$0(doc,cst_textpath)}
    function createTitle$0(doc){return unsafeCreateElement$0(doc,cst_title$2)}
    function createTref(doc){return unsafeCreateElement$0(doc,cst_tref)}
    function createTspan(doc){return unsafeCreateElement$0(doc,cst_tspan)}
    function createUse(doc){return unsafeCreateElement$0(doc,cst_use)}
    function createView(doc){return unsafeCreateElement$0(doc,cst_view)}
    function createvkern(doc){return unsafeCreateElement$0(doc,cst_vkern)}
    var svg_element=Unsafe[1].SVGElement,document$0=Unsafe[1].document;
    function getElementById$0(id)
     {function _cq_(e){if(e instanceof svg_element)return e;throw Stdlib[8]}
      function _cr_(param){throw Stdlib[8]}
      var
       t6=caml_jsstring_of_string(id),
       t7=Unsafe[1].document,
       _cs_=t7.getElementById(t6);
      return caml_call3(Opt[7],_cs_,_cr_,_cq_)}
    function element$2(e){return e instanceof svg_element?e:no_handler}
    function unsafeCoerce$0(e,tag)
     {var t9=e.tagName,_cp_=caml_jsstring_of_string(tag);
      return t9.toLowerCase() === _cp_?e:no_handler}
    function a$0(e){return unsafeCoerce$0(e,cst_a$3)}
    function altGlyph(e){return unsafeCoerce$0(e,cst_altglyph$0)}
    function altGlyphDef(e){return unsafeCoerce$0(e,cst_altglyphdef$0)}
    function altGlyphItem(e){return unsafeCoerce$0(e,cst_altglyphitem$0)}
    function animate(e){return unsafeCoerce$0(e,cst_animate$0)}
    function animateColor(e){return unsafeCoerce$0(e,cst_animatecolor$0)}
    function animateMotion(e){return unsafeCoerce$0(e,cst_animatemotion$0)}
    function animateTransform(e)
     {return unsafeCoerce$0(e,cst_animatetransform$0)}
    function circle(e){return unsafeCoerce$0(e,cst_circle$0)}
    function clipPath(e){return unsafeCoerce$0(e,cst_clippath$0)}
    function cursor(e){return unsafeCoerce$0(e,cst_cursor$0)}
    function defs(e){return unsafeCoerce$0(e,cst_defs$0)}
    function desc(e){return unsafeCoerce$0(e,cst_desc$0)}
    function ellipse(e){return unsafeCoerce$0(e,cst_ellipse$0)}
    function filter(e){return unsafeCoerce$0(e,cst_filter$0)}
    function font(e){return unsafeCoerce$0(e,cst_font$0)}
    function fontFace(e){return unsafeCoerce$0(e,cst_font_face$0)}
    function fontFaceFormat(e)
     {return unsafeCoerce$0(e,cst_font_face_format$0)}
    function fontFaceName(e){return unsafeCoerce$0(e,cst_font_face_name$0)}
    function fontFaceSrc(e){return unsafeCoerce$0(e,cst_font_face_src$0)}
    function fontFaceUri(e){return unsafeCoerce$0(e,cst_font_face_uri$0)}
    function foreignObject(e){return unsafeCoerce$0(e,cst_foreignobject)}
    function g(e){return unsafeCoerce$0(e,cst_g$1)}
    function glyph(e){return unsafeCoerce$0(e,cst_glyph$0)}
    function glyphRef(e){return unsafeCoerce$0(e,cst_glyphref$0)}
    function hkern(e){return unsafeCoerce$0(e,cst_hkern$0)}
    function image(e){return unsafeCoerce$0(e,cst_image$0)}
    function lineElement(e){return unsafeCoerce$0(e,cst_line$0)}
    function linearElement(e){return unsafeCoerce$0(e,cst_lineargradient$0)}
    function mask(e){return unsafeCoerce$0(e,cst_mask$0)}
    function metaData(e){return unsafeCoerce$0(e,cst_metadata$0)}
    function missingGlyph(e){return unsafeCoerce$0(e,cst_missing_glyph$0)}
    function mPath(e){return unsafeCoerce$0(e,cst_mpath$0)}
    function path$0(e){return unsafeCoerce$0(e,cst_path$0)}
    function pattern(e){return unsafeCoerce$0(e,cst_pattern$0)}
    function polygon(e){return unsafeCoerce$0(e,cst_polygon$0)}
    function polyline(e){return unsafeCoerce$0(e,cst_polyline$0)}
    function radialgradient(e){return unsafeCoerce$0(e,cst_radialgradient$0)}
    function rect(e){return unsafeCoerce$0(e,cst_rect$0)}
    function script$0(e){return unsafeCoerce$0(e,cst_script$3)}
    function set$1(e){return unsafeCoerce$0(e,cst_set$0)}
    function stop(e){return unsafeCoerce$0(e,cst_stop$0)}
    function style$0(e){return unsafeCoerce$0(e,cst_style$3)}
    function svg(e){return unsafeCoerce$0(e,cst_svg$0)}
    function switch$0(e){return unsafeCoerce$0(e,cst_switch$0)}
    function symbol$12(e){return unsafeCoerce$0(e,cst_symbol$0)}
    function textElement(e){return unsafeCoerce$0(e,cst_text$1)}
    function textpath(e){return unsafeCoerce$0(e,cst_textpath$0)}
    function title$0(e){return unsafeCoerce$0(e,cst_title$3)}
    function tref(e){return unsafeCoerce$0(e,cst_tref$0)}
    function tspan(e){return unsafeCoerce$0(e,cst_tspan$0)}
    function use(e){return unsafeCoerce$0(e,cst_use$0)}
    function view(e){return unsafeCoerce$0(e,cst_view$0)}
    function vkern(e){return unsafeCoerce$0(e,cst_vkern$0)}
    var
     Js_of_ocaml_Dom_svg=
      [0,
       t0,
       SVGError,
       createElement$0,
       createA$0,
       createAltGlyph,
       createAltGlyphDef,
       createAltGlyphItem,
       createAnimate,
       createAnimateColor,
       createAnimateMotion,
       createAnimateTransform,
       createCircle,
       createClipPath,
       createCursor,
       createDefs,
       createDesc,
       createEllipse,
       createFilter,
       createFont,
       createFontFace,
       createFontFaceFormat,
       createFontFaceName,
       createFontFaceSrc,
       createFontFaceUri,
       createForeignObject,
       createG,
       createGlyph,
       createGlyphRef,
       createhkern,
       createImage,
       createLineElement,
       createLinearElement,
       createMask,
       createMetaData,
       createMissingGlyph,
       createMPath,
       createPath,
       createPattern,
       createPolygon,
       createPolyline,
       createRadialgradient,
       createRect,
       createScript$0,
       createSet,
       createStop,
       createStyle$0,
       createSvg,
       createSwitch,
       createSymbol,
       createTextElement,
       createTextpath,
       createTitle$0,
       createTref,
       createTspan,
       createUse,
       createView,
       createvkern,
       svg_element,
       document$0,
       getElementById$0,
       [0,
        element$2,
        a$0,
        altGlyph,
        altGlyphDef,
        altGlyphItem,
        animate,
        animateColor,
        animateMotion,
        animateTransform,
        circle,
        clipPath,
        cursor,
        defs,
        desc,
        ellipse,
        filter,
        font,
        fontFace,
        fontFaceFormat,
        fontFaceName,
        fontFaceSrc,
        fontFaceUri,
        foreignObject,
        g,
        glyph,
        glyphRef,
        hkern,
        image,
        lineElement,
        linearElement,
        mask,
        metaData,
        missingGlyph,
        mPath,
        path$0,
        pattern,
        polygon,
        polyline,
        radialgradient,
        rect,
        script$0,
        set$1,
        stop,
        style$0,
        svg,
        switch$0,
        symbol$12,
        textElement,
        textpath,
        title$0,
        tref,
        tspan,
        use,
        view,
        vkern]];
    caml_register_global(1670,Js_of_ocaml_Dom_svg,"Js_of_ocaml__Dom_svg");
    function withCredentials(b)
     {var t1={},t0=! ! b;t1.withCredentials = t0;return t1}
    var
     eventSource=Unsafe[1].EventSource,
     eventSource_options=Unsafe[1].EventSource,
     Js_of_ocaml_EventSource=
      [0,withCredentials,eventSource,eventSource_options,addEventListener];
    caml_register_global
     (1671,Js_of_ocaml_EventSource,"Js_of_ocaml__EventSource");
    var
     console=runtime.caml_js_get_console(0),
     Js_of_ocaml_Firebug=[0,console];
    caml_register_global(1672,Js_of_ocaml_Firebug,"Js_of_ocaml__Firebug");
    function empty_position_options(param){return {}}
    var
     t1$0=Unsafe[1].navigator,
     geolocation=caml_call1(Optdef[5],t1$0)?t1$0.geolocation:t1$0;
    function is_supported$3(param){return caml_call1(Optdef[5],geolocation)}
    var
     Js_of_ocaml_Geolocation=
      [0,empty_position_options,geolocation,is_supported$3];
    caml_register_global
     (1673,Js_of_ocaml_Geolocation,"Js_of_ocaml__Geolocation");
    function empty_intersection_observer_op(param){return {}}
    var intersectionObserver_unsafe=Unsafe[1].IntersectionObserver;
    function is_supported$4(param)
     {return caml_call1(Optdef[5],intersectionObserver_unsafe)}
    var
     Js_of_ocaml_IntersectionObserv=
      [0,
       empty_intersection_observer_op,
       is_supported$4,
       intersectionObserver_unsafe];
    caml_register_global
     (1674,Js_of_ocaml_IntersectionObserv,"Js_of_ocaml__IntersectionObserver");
    function object_options(param){return {"localeMatcher":"best fit"}}
    function options(param)
     {return {"localeMatcher":"best fit",
              "usage":"sort",
              "sensitivity":"variant",
              "ignorePunctuation":t4,
              "numeric":t4,
              "caseFirst":"false"}}
    var Collator=[0,object_options,options];
    function options$0(param)
     {return {"localeMatcher":"best fit",
              "timeZone":t39,
              "hour12":t39,
              "hourCycle":t39,
              "formatMatcher":"best fit",
              "weekday":t39,
              "era":t39,
              "year":t39,
              "month":t39,
              "day":t39,
              "hour":t39,
              "minute":t39,
              "second":t39,
              "timeZoneName":t39}}
    var DateTimeFormat=[0,object_options,options$0];
    function options$1(param)
     {return {"localeMatcher":"best fit",
              "style":"decimal",
              "currency":t39,
              "currencyDisplay":t39,
              "useGrouping":t25,
              "minimumIntegerDigits":t39,
              "minimumFractionDigits":t39,
              "maximumFractionDigits":t39,
              "minimumSignificantDigits":t39,
              "maximumSignificantDigits":t39}}
    var NumberFormat=[0,object_options,options$1];
    function options$2(param)
     {return {"localeMatcher":"best fit","type":"cardinal"}}
    var
     PluralRules=[0,object_options,options$2],
     intl=Unsafe[1].Intl,
     t35=Unsafe[1].Intl,
     collator_constr=t35.Collator,
     t37=Unsafe[1].Intl,
     dateTimeFormat_constr=t37.DateTimeFormat,
     t39$0=Unsafe[1].Intl,
     numberFormat_constr=t39$0.NumberFormat,
     t41=Unsafe[1].Intl,
     pluralRules_constr=t41.PluralRules;
    function is_supported$5(param){return caml_call1(Optdef[5],intl)}
    var
     Js_of_ocaml_Intl=
      [0,
       Collator,
       DateTimeFormat,
       NumberFormat,
       PluralRules,
       intl,
       collator_constr,
       dateTimeFormat_constr,
       numberFormat_constr,
       pluralRules_constr,
       is_supported$5];
    caml_register_global(1675,Js_of_ocaml_Intl,"Js_of_ocaml__Intl");
    var Js_of_ocaml$0=[0];
    caml_register_global(1676,Js_of_ocaml$0,"Js_of_ocaml");
    return}
  (globalThis));


//# 1 ".bergman.eobjs/byte/dune__exe.cmo.js"
(function(globalThis)
   {"use strict";
    var runtime=globalThis.jsoo_runtime,Dune_exe=[0];
    runtime.caml_register_global(0,Dune_exe,"Dune__exe");
    return}
  (globalThis));


//# 1 ".bergman.eobjs/byte/dune__exe__Pol.cmo.js"
(function(globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_1=caml_string_of_jsbytes("1"),
     cst_0=caml_string_of_jsbytes("0"),
     cst=caml_string_of_jsbytes("*"),
     cst$0=caml_string_of_jsbytes("+"),
     cst$1=caml_string_of_jsbytes("-"),
     cst$2=caml_string_of_jsbytes("-"),
     Stdlib=global_data.Stdlib,
     Stdlib_String=global_data.Stdlib__String;
    function to_string(p)
     {function aux(param)
       {if(typeof param === "number")
         return 0 === param?cst_1:cst_0;
        else
         switch(param[0])
          {case 0:
            var
             q=param[2],
             p=param[1],
             _a_=aux(q),
             _b_=caml_call2(Stdlib[28],cst,_a_),
             _c_=aux(p);
            return caml_call2(Stdlib[28],_c_,_b_);
           case 1:var c=param[1];return caml_call2(Stdlib_String[1],1,c);
           case 2:
            var
             q$0=param[2],
             p$0=param[1],
             _d_=aux(q$0),
             _e_=caml_call2(Stdlib[28],cst$0,_d_),
             _f_=aux(p$0);
            return caml_call2(Stdlib[28],_f_,_e_);
           case 3:
            var
             q$1=param[2],
             p$1=param[1],
             _g_=aux(q$1),
             _h_=caml_call2(Stdlib[28],cst$1,_g_),
             _i_=aux(p$1);
            return caml_call2(Stdlib[28],_i_,_h_);
           default:
            var p$2=param[1],_j_=aux(p$2);
            return caml_call2(Stdlib[28],cst$2,_j_)}}
      return aux(p)}
    var Dune_exe_Pol=[0,to_string];
    runtime.caml_register_global(8,Dune_exe_Pol,"Dune__exe__Pol");
    return}
  (globalThis));


//# 1 ".bergman.eobjs/byte/dune__exe__Parser.cmo.js"
(function(globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_parser=caml_string_of_jsbytes("parser"),
     cst_unexpected_number=caml_string_of_jsbytes("unexpected number"),
     yylhs=
      caml_string_of_jsbytes
       ("\xff\xff\x01\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x03\0\x03\0\0\0"),
     yylen=
      caml_string_of_jsbytes
       ("\x02\0\x02\0\x03\0\x03\0\x03\0\x03\0\x01\0\x01\0\x02\0\x03\0\x02\0\x01\0\x02\0"),
     yydefred=
      caml_string_of_jsbytes
       ("\0\0\0\0\0\0\x07\0\0\0\0\0\0\0\f\0\0\0\x06\0\b\0\0\0\n\0\0\0\0\0\0\0\0\0\x01\0\t\0\0\0\0\0\0\0\x05\0"),
     yydgoto=caml_string_of_jsbytes("\x02\0\x07\0\b\0\t\0"),
     yysindex=
      caml_string_of_jsbytes
       ("\xff\xff\x03\xff\0\0\0\0\x03\xff\x03\xff\xfd\xfe\0\0\x13\0\0\0\0\0\x19\xff\0\0\x03\xff\x03\xff\x03\xff\x07\xff\0\0\0\0\xfe\xfe\xfe\xfe\t\xff\0\0"),
     yyrindex=
      caml_string_of_jsbytes
       ("\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0\r\0\x07\0\0\0"),
     yygindex=caml_string_of_jsbytes("\0\0\0\0\x0b\0\x06\0"),
     yytable=
      caml_string_of_jsbytes
       ("\x01\0\x0b\0\x0f\0\x10\0\x03\0\x06\0\x04\0\x03\0\x16\0\x05\0\x02\0\x06\0\f\0\x04\0\x10\0\n\0\x0b\0\0\0\0\0\x11\0\0\0\0\0\0\0\0\0\x13\0\x14\0\x15\0\r\0\x0e\0\x0f\0\x10\0\0\0\x12\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0b\0\x0b\0\x0b\0\x0b\0\0\0\x0b\0\x03\0\x03\0\x03\0\x02\0\x02\0\x03\0\x04\0\x04\0\x02\0\0\0\0\0\x04\0\r\0\x0e\0\x0f\0\x10\0"),
     yycheck=
      caml_string_of_jsbytes
       ("\x01\0\0\0\x04\x01\x05\x01\x01\x01\b\x01\x03\x01\0\0\x01\x01\x06\x01\0\0\b\x01\x06\0\0\0\x05\x01\x04\0\x05\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\r\0\x0e\0\x0f\0\x02\x01\x03\x01\x04\x01\x05\x01\xff\xff\x07\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x02\x01\x03\x01\x04\x01\x05\x01\xff\xff\x07\x01\x02\x01\x03\x01\x04\x01\x02\x01\x03\x01\x07\x01\x02\x01\x03\x01\x07\x01\xff\xff\xff\xff\x07\x01\x02\x01\x03\x01\x04\x01\x05\x01"),
     yynames_const=
      caml_string_of_jsbytes("ADD\0SUB\0MUL\0POW\0LPAR\0RPAR\0EOF\0"),
     yynames_block=caml_string_of_jsbytes("INT\0CHAR\0"),
     Stdlib_Parsing=global_data.Stdlib__Parsing,
     Stdlib=global_data.Stdlib,
     _a_=[0,258,259,260,261,262,263,0,0];
    function muls(param)
     {if(param)
       {var _o_=param[1];
        if(param[2]){var l=param[2];return [0,_o_,muls(l)]}
        return _o_}
      return 0}
    function pow(p,n){return 0 === n?0:1 === n?p:[0,p,pow(p,n - 1 | 0)]}
    var
     yytransl_const=_a_.slice(),
     yytransl_block=[0,257,264,0],
     yytablesize=280;
    function _b_(caml_parser_env)
     {var _n_=caml_call2(Stdlib_Parsing[14],caml_parser_env,0);
      throw [0,Stdlib_Parsing[12],_n_]}
    function _c_(caml_parser_env)
     {var _1=caml_call2(Stdlib_Parsing[14],caml_parser_env,0);
      return [0,[1,_1],0]}
    function _d_(caml_parser_env)
     {var
       _1=caml_call2(Stdlib_Parsing[14],caml_parser_env,1),
       _2=caml_call2(Stdlib_Parsing[14],caml_parser_env,0);
      return [0,[1,_1],_2]}
    function _e_(caml_parser_env)
     {var _2=caml_call2(Stdlib_Parsing[14],caml_parser_env,1);return _2}
    function _f_(caml_parser_env)
     {var _2=caml_call2(Stdlib_Parsing[14],caml_parser_env,0);return [4,_2]}
    function _g_(caml_parser_env)
     {var _1=caml_call2(Stdlib_Parsing[14],caml_parser_env,0);
      return 0 === _1?1:1 === _1?0:caml_call1(Stdlib[2],cst_unexpected_number)}
    function _h_(caml_parser_env)
     {var _1=caml_call2(Stdlib_Parsing[14],caml_parser_env,0);return muls(_1)}
    function _i_(caml_parser_env)
     {var
       _1=caml_call2(Stdlib_Parsing[14],caml_parser_env,2),
       _3=caml_call2(Stdlib_Parsing[14],caml_parser_env,0);
      return pow(_1,_3)}
    function _j_(caml_parser_env)
     {var
       _1=caml_call2(Stdlib_Parsing[14],caml_parser_env,2),
       _3=caml_call2(Stdlib_Parsing[14],caml_parser_env,0);
      return [3,_1,_3]}
    function _k_(caml_parser_env)
     {var
       _1=caml_call2(Stdlib_Parsing[14],caml_parser_env,2),
       _3=caml_call2(Stdlib_Parsing[14],caml_parser_env,0);
      return [0,_1,_3]}
    function _l_(caml_parser_env)
     {var
       _1=caml_call2(Stdlib_Parsing[14],caml_parser_env,2),
       _3=caml_call2(Stdlib_Parsing[14],caml_parser_env,0);
      return [2,_1,_3]}
    function _m_(caml_parser_env)
     {var _1=caml_call2(Stdlib_Parsing[14],caml_parser_env,1);return _1}
    var
     yyact=
      [0,
       function(param){return caml_call1(Stdlib[2],cst_parser)},
       _m_,
       _l_,
       _k_,
       _j_,
       _i_,
       _h_,
       _g_,
       _f_,
       _e_,
       _d_,
       _c_,
       _b_],
     yytables=
      [0,
       yyact,
       yytransl_const,
       yytransl_block,
       yylhs,
       yylen,
       yydefred,
       yydgoto,
       yysindex,
       yyrindex,
       yygindex,
       yytablesize,
       yytable,
       yycheck,
       Stdlib_Parsing[16],
       yynames_const,
       yynames_block];
    function main(lexfun,lexbuf)
     {return caml_call4(Stdlib_Parsing[13],yytables,1,lexfun,lexbuf)}
    var Dune_exe_Parser=[0,main];
    runtime.caml_register_global(16,Dune_exe_Parser,"Dune__exe__Parser");
    return}
  (globalThis));


//# 1 ".bergman.eobjs/byte/dune__exe__Lexer.cmo.js"
(function(globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    var
     global_data=runtime.caml_get_global_data(),
     ocaml_lex_tables=
      [0,
       caml_string_of_jsbytes
        ("\0\0\xf6\xff\x01\0\xf8\xffK\0\xfa\xff\xfb\xff\xfc\xff\xfd\xff\xfe\xff\xff\xff"),
       caml_string_of_jsbytes
        ("\xff\xff\xff\xff\b\0\xff\xff\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),
       caml_string_of_jsbytes
        ("\xff\xff\0\0\xff\xff\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0"),
       caml_string_of_jsbytes
        ("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\0\0\0\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\x05\0\b\0\n\0\0\0\t\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\x07\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
       caml_string_of_jsbytes
        ("\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\x02\0\xff\xff\xff\xff\0\0\x02\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\x02\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes("")],
     Stdlib_Lexing=global_data.Stdlib__Lexing;
    function token$0(counter,lexbuf)
     {var _a_=0;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return ocaml_lex_token_rec$0(counter$0,lexbuf,_a_)}
      return caml_trampoline_return(ocaml_lex_token_rec$0,[0,lexbuf,_a_])}
    function ocaml_lex_token_rec$0(counter,lexbuf,ocaml_lex_state)
     {var ocaml_lex_state$0=ocaml_lex_state;
      for(;;)
       {var
         ocaml_lex_state$1=
          caml_call3
           (Stdlib_Lexing[20],ocaml_lex_tables,ocaml_lex_state$0,lexbuf);
        if(9 < ocaml_lex_state$1 >>> 0)
         {caml_call1(lexbuf[1],lexbuf);
          var ocaml_lex_state$0=ocaml_lex_state$1;
          continue}
        switch(ocaml_lex_state$1)
         {case 0:return 0;
          case 1:return 1;
          case 2:return 2;
          case 3:return 3;
          case 4:return 4;
          case 5:return 5;
          case 6:
           var n=caml_call3(Stdlib_Lexing[16],lexbuf,lexbuf[5],lexbuf[6]);
           return [0,runtime.caml_int_of_string(n)];
          case 7:
           var c=caml_call2(Stdlib_Lexing[18],lexbuf,lexbuf[5]);return [1,c];
          case 8:
           if(counter < 50)
            {var counter$0=counter + 1 | 0;return token$0(counter$0,lexbuf)}
           return caml_trampoline_return(token$0,[0,lexbuf]);
          default:return 6}}}
    function token(lexbuf){return caml_trampoline(token$0(0,lexbuf))}
    function ocaml_lex_token_rec(lexbuf,ocaml_lex_state)
     {return caml_trampoline(ocaml_lex_token_rec$0(0,lexbuf,ocaml_lex_state))}
    var Dune_exe_Lexer=[0,ocaml_lex_tables,token,ocaml_lex_token_rec];
    runtime.caml_register_global(2,Dune_exe_Lexer,"Dune__exe__Lexer");
    return}
  (globalThis));


//# 1 ".bergman.eobjs/byte/dune__exe__Bergman.cmo.js"
(function(globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_jsstring_of_string=runtime.caml_jsstring_of_string,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$22=caml_string_of_jsbytes(","),
     cst$25=caml_string_of_jsbytes("-"),
     cst$24=caml_string_of_jsbytes("-"),
     cst$23=caml_string_of_jsbytes(","),
     v=caml_string_of_jsbytes("x,y"),
     cst_x=caml_string_of_jsbytes("x"),
     cst_y=caml_string_of_jsbytes("y"),
     cst_x$0=caml_string_of_jsbytes("x"),
     cst$21=caml_string_of_jsbytes(","),
     cst$14=caml_string_of_jsbytes(","),
     cst$15=caml_string_of_jsbytes(""),
     cst$17=caml_string_of_jsbytes("^"),
     cst$18=caml_string_of_jsbytes(""),
     cst$19=caml_string_of_jsbytes(""),
     cst$20=caml_string_of_jsbytes("+"),
     cst$16=caml_string_of_jsbytes("+"),
     cst$10=caml_string_of_jsbytes(","),
     cst_1=caml_string_of_jsbytes("-1"),
     cst$13=caml_string_of_jsbytes("-"),
     cst$12=caml_string_of_jsbytes("-"),
     cst$11=caml_string_of_jsbytes(","),
     cst$7=caml_string_of_jsbytes(","),
     cst$9=caml_string_of_jsbytes("+"),
     cst$8=caml_string_of_jsbytes(","),
     cst$4=caml_string_of_jsbytes(","),
     cst$6=caml_string_of_jsbytes("-"),
     cst$5=caml_string_of_jsbytes(","),
     cst_ext=caml_string_of_jsbytes("ext"),
     cst_plactic=caml_string_of_jsbytes("plactic"),
     cst_pow=caml_string_of_jsbytes("pow"),
     cst_sklyanin=caml_string_of_jsbytes("sklyanin"),
     cst_sym=caml_string_of_jsbytes("sym"),
     cst_symg=caml_string_of_jsbytes("symg"),
     cst_br$0=caml_string_of_jsbytes("<br/>"),
     cst$2=caml_string_of_jsbytes(" = "),
     cst_H=caml_string_of_jsbytes("H"),
     cst_Parsing_variables=caml_string_of_jsbytes("Parsing variables..."),
     cst_Parsing_relations=caml_string_of_jsbytes("Parsing relations..."),
     cst_Parsing_error=caml_string_of_jsbytes("Parsing error: "),
     cst=caml_string_of_jsbytes(" , "),
     cst_Relations=caml_string_of_jsbytes("Relations: "),
     cst_deglex=caml_string_of_jsbytes("deglex"),
     cst_revdeglex=caml_string_of_jsbytes("revdeglex"),
     cst_algebra=caml_string_of_jsbytes("algebra"),
     cst_monoid=caml_string_of_jsbytes("monoid"),
     cst_Invalid_augmentation=caml_string_of_jsbytes("Invalid augmentation!"),
     cst_Computing_Gr_bner_basis=
      caml_string_of_jsbytes("Computing Gr\xc3\xb6bner basis..."),
     cst_Computing_Anick_chains=
      caml_string_of_jsbytes("Computing Anick chains..."),
     cst$0=caml_string_of_jsbytes(""),
     cst_br$1=caml_string_of_jsbytes("<br/>"),
     cst$3=caml_string_of_jsbytes(" "),
     cst_chains=caml_string_of_jsbytes(" chains: "),
     cst_Computing_resolution=
      caml_string_of_jsbytes("Computing resolution..."),
     cst_br=caml_string_of_jsbytes("<br/>"),
     cst_Computing_Betti_numbers=
      caml_string_of_jsbytes("Computing Betti numbers..."),
     cst$1=caml_string_of_jsbytes(""),
     cst_Done=caml_string_of_jsbytes("Done."),
     cst_Error=caml_string_of_jsbytes("Error: "),
     cst_Not_found=caml_string_of_jsbytes("Not_found..."),
     cst_em=caml_string_of_jsbytes("<\/em>"),
     cst_em_style_color_red=caml_string_of_jsbytes('<em style="color:red">'),
     cst_Dune_exe_Bergman_Parsing=
      caml_string_of_jsbytes("Dune__exe__Bergman.Parsing"),
     Stdlib_String=global_data.Stdlib__String,
     Stdlib=global_data.Stdlib,
     Stdlib_List=global_data.Stdlib__List,
     Assert_failure=global_data.Assert_failure,
     Js_of_ocaml_Js=global_data.Js_of_ocaml__Js,
     Stdlib_Printexc=global_data.Stdlib__Printexc,
     Dune_exe_Pol=global_data.Dune__exe__Pol,
     Alg_Alphabet=global_data.Alg__Alphabet,
     Stdlib_Array=global_data.Stdlib__Array,
     Js_of_ocaml_Dom_html=global_data.Js_of_ocaml__Dom_html,
     Stdlib_Lexing=global_data.Stdlib__Lexing,
     Dune_exe_Lexer=global_data.Dune__exe__Lexer,
     Dune_exe_Parser=global_data.Dune__exe__Parser,
     Js_of_ocaml_Firebug=global_data.Js_of_ocaml__Firebug,
     Alg_Monoid=global_data.Alg__Monoid,
     Alg_Field=global_data.Alg__Field,
     Alg_Algebra=global_data.Alg__Algebra,
     doc=Js_of_ocaml_Dom_html[2],
     _h_=[0,caml_string_of_jsbytes("tools/bergman/bergman.ml"),327,13],
     _f_=[0,caml_string_of_jsbytes("tools/bergman/bergman.ml"),162,15],
     _g_=[0,caml_string_of_jsbytes("tools/bergman/bergman.ml"),170,17],
     _b_=[0,caml_string_of_jsbytes("tools/bergman/bergman.ml"),82,2],
     _a_=[0,caml_string_of_jsbytes("tools/bergman/bergman.ml"),17,38];
    function button(txt,action)
     {var
       button_type="button",
       t3=caml_call3(Js_of_ocaml_Dom_html[40],[0,button_type],0,doc),
       t0=caml_jsstring_of_string(txt);
      t3.value = t0;
      function _b6_(param){caml_call1(action,0);return Js_of_ocaml_Js[7]}
      var t2=caml_call1(Js_of_ocaml_Dom_html[10],_b6_);
      t3.onclick = t2;
      return t3}
    function debug(s)
     {var t4=caml_jsstring_of_string(s);
      return Js_of_ocaml_Firebug[1].debug(t4)}
    function jsget(x)
     {function _b5_(param){throw [0,Assert_failure,_a_]}
      return caml_call2(Js_of_ocaml_Js[5][8],x,_b5_)}
    var
     Parsing=
      [248,cst_Dune_exe_Bergman_Parsing,runtime.caml_fresh_oo_id(0)];
    function parse_pol(s)
     {var _b4_=caml_call2(Stdlib_Lexing[3],0,s);
      return caml_call2(Dune_exe_Parser[1],Dune_exe_Lexer[2],_b4_)}
    function char_of_string(s)
     {if(1 === caml_ml_string_length(s))return caml_string_get(s,0);
      throw [0,Assert_failure,_b_]}
    var
     _c_=Alg_Alphabet[1],
     include=caml_call1(Alg_Monoid[1],[0,_c_[1],_c_[2],_c_[3]]),
     mul=include[1],
     one=include[2],
     inj=include[3],
     length=include[4],
     sub=include[5],
     eq=include[6],
     compare=include[7],
     peq=include[8],
     to_string=include[9],
     included=include[10],
     unifier=include[11],
     ordered_unifiers=include[12],
     ordered_unifiers_bicontext=include[13],
     unifiers_bicontext=include[14],
     Order=include[15],
     Anick=include[16];
    function s(s)
     {function _b3_(i){return caml_string_get(s,i)}
      return caml_call2(Stdlib_Array[2],caml_ml_string_length(s),_b3_)}
    var
     M=
      [0,
       mul,
       one,
       inj,
       length,
       sub,
       eq,
       compare,
       peq,
       to_string,
       included,
       unifier,
       ordered_unifiers,
       ordered_unifiers_bicontext,
       unifiers_bicontext,
       Order,
       Anick,
       s],
     _d_=Alg_Alphabet[1],
     _e_=[0,_d_[1],_d_[2],_d_[3]],
     P=caml_call1(caml_call1(Alg_Algebra[3],Alg_Field[3]),_e_);
    function eval_pol(p)
     {function aux(param)
       {if(typeof param === "number")
         return 0 === param?P[2][20]:P[2][3];
        else
         switch(param[0])
          {case 0:
            var q=param[2],p=param[1],_bV_=aux(q),_bW_=aux(p);
            return caml_call2(P[2][22],_bW_,_bV_);
           case 1:
            var c=param[1],_bX_=caml_call1(M[3],c);
            return caml_call1(P[2][5],_bX_);
           case 2:
            var q$0=param[2],p$0=param[1],_bY_=aux(q$0),_bZ_=aux(p$0);
            return caml_call2(P[2][10],_bZ_,_bY_);
           case 3:
            var q$1=param[2],p$1=param[1],_b0_=aux(q$1),_b1_=aux(p$1);
            return caml_call2(P[2][13],_b1_,_b0_);
           default:
            var p$2=param[1],_b2_=aux(p$2);return caml_call1(P[2][12],_b2_)}}
      return aux(p)}
    function replace(c,t,s)
     {try
       {var
         n=caml_call2(Stdlib_String[35],s,c),
         _bQ_=
          caml_call3
           (Stdlib_String[15],
            s,
            n + 1 | 0,
            caml_ml_string_length(s) - (n + 1 | 0) | 0),
         _bR_=caml_call2(Stdlib[28],t,_bQ_),
         _bS_=caml_call3(Stdlib_String[15],s,0,n),
         _bT_=replace(c,t,caml_call2(Stdlib[28],_bS_,_bR_));
        return _bT_}
      catch(_bU_)
       {_bU_ = caml_wrap_exception(_bU_);
        if(_bU_ === Stdlib[8])return s;
        throw _bU_}}
    function run(param)
     {var
       _i_=jsget(doc.getElementById("vars")),
       t60=jsget(caml_call1(Js_of_ocaml_Dom_html[117][55],_i_)),
       _j_=jsget(doc.getElementById("relations")),
       t62=jsget(caml_call1(Js_of_ocaml_Dom_html[117][55],_j_)),
       _k_=jsget(doc.getElementById("order")),
       order=jsget(caml_call1(Js_of_ocaml_Dom_html[117][50],_k_)),
       _l_=jsget(doc.getElementById("generate")),
       t66=jsget(caml_call1(Js_of_ocaml_Dom_html[117][50],_l_)),
       _m_=jsget(doc.getElementById("generaten")),
       t68=jsget(caml_call1(Js_of_ocaml_Dom_html[117][33],_m_)),
       _n_=jsget(doc.getElementById("augmentation")),
       augmentation=jsget(caml_call1(Js_of_ocaml_Dom_html[117][50],_n_)),
       _o_=jsget(doc.getElementById("maxdeg")),
       maxdeg=jsget(caml_call1(Js_of_ocaml_Dom_html[117][33],_o_)),
       grobner=jsget(doc.getElementById("grobner")),
       chains=jsget(doc.getElementById("chains")),
       resolution=jsget(doc.getElementById("resolution")),
       betti=jsget(doc.getElementById("betti")),
       t58=jsget(doc.getElementById("go")),
       t33=jsget(doc.getElementById("status"));
      function status(s)
       {var t32=caml_jsstring_of_string(s);return t33.innerHTML = t32}
      function error(s)
       {var _bP_=caml_call2(Stdlib[28],s,cst_em);
        return status(caml_call2(Stdlib[28],cst_em_style_color_red,_bP_))}
      function _p_(param)
       {try
         {var
           vars=caml_string_of_jsstring(t60.value),
           relations=caml_string_of_jsstring(t62.value);
          grobner.innerHTML = "";
          chains.innerHTML = "";
          resolution.innerHTML = "";
          betti.innerHTML = "";
          status(cst_Parsing_variables);
          var
           vars$0=caml_call2(Stdlib_String[16],44,vars),
           vars$1=caml_call2(Stdlib_List[19],Stdlib_String[23],vars$0),
           vars$2=caml_call2(Stdlib_List[19],char_of_string,vars$1);
          status(cst_Parsing_relations);
          var
           relations$0=caml_call2(Stdlib_String[16],44,relations),
           relations$1=
            caml_call2(Stdlib_List[19],Stdlib_String[23],relations$0);
          try
           {var relations$2=caml_call2(Stdlib_List[19],parse_pol,relations$1)}
          catch(e)
           {e = caml_wrap_exception(e);
            var _bu_=caml_call1(Stdlib_Printexc[1],e);
            error(caml_call2(Stdlib[28],cst_Parsing_error,_bu_));
            throw Stdlib[3]}
          var
           _bv_=caml_call2(Stdlib_List[19],Dune_exe_Pol[1],relations$2),
           _bw_=caml_call2(Stdlib_String[6],cst,_bv_);
          grobner.innerHTML
          =
          caml_jsstring_of_string(caml_call2(Stdlib[28],cst_Relations,_bw_));
          var
           relations$3=caml_call2(Stdlib_List[19],eval_pol,relations$2),
           match=caml_string_of_jsstring(order.value);
          if(caml_string_notequal(match,cst_deglex))
           {if(caml_string_notequal(match,cst_revdeglex))
             throw [0,Assert_failure,_f_];
            var order$0=caml_call1(M[15][2],Alg_Alphabet[1][5])}
          else
           var order$0=caml_call1(M[15][2],Alg_Alphabet[1][4]);
          var pres=caml_call3(P[7],order$0,vars$2,relations$3);
          try
           {var match$0=caml_string_of_jsstring(augmentation.value);
            if(caml_string_notequal(match$0,cst_algebra))
             {if(caml_string_notequal(match$0,cst_monoid))
               throw [0,Assert_failure,_g_];
              var _bx_=caml_call1(P[14][4],pres)}
            else
             var _bx_=caml_call1(P[14][3],pres)}
          catch(_bO_)
           {_bO_ = caml_wrap_exception(_bO_);
            if(_bO_ === P[14][1])
             {error(cst_Invalid_augmentation);throw Stdlib[3]}
            throw _bO_}
          status(cst_Computing_Gr_bner_basis);
          var _by_=caml_call1(P[11],pres),pres$0=caml_call1(P[12],_by_);
          grobner.innerHTML
          =
          caml_jsstring_of_string(caml_call1(P[9],pres$0));
          status(cst_Computing_Anick_chains);
          var
           heads=caml_call1(P[8],pres$0),
           cc=caml_call1(M[16][3],vars$2),
           cc$0=[0,cc],
           s$0=[0,cst$0],
           i=0;
          for(;;)
           {var
             _bB_=caml_call2(Stdlib_List[19],M[16][12],cc$0[1]),
             _bC_=caml_call2(Stdlib_String[6],cst$3,_bB_),
             _bD_=caml_call2(Stdlib[28],_bC_,cst_br$1),
             _bE_=caml_call2(Stdlib[28],cst_chains,_bD_),
             _bF_=caml_call1(Stdlib[33],i),
             _bG_=caml_call2(Stdlib[28],_bF_,_bE_);
            s$0[1] = caml_call2(Stdlib[28],s$0[1],_bG_);
            chains.innerHTML = caml_jsstring_of_string(s$0[1]);
            cc$0[1] = caml_call2(M[16][9],heads,cc$0[1]);
            var _bH_=i + 1 | 0;
            if(6 !== i){var i=_bH_;continue}
            status(cst_Computing_resolution);
            var
             maxdeg$0=
              caml_int_of_string(caml_string_of_jsstring(maxdeg.value)),
             d=caml_call3(P[15][4],[0,_bx_],pres$0,maxdeg$0 + 1 | 0);
            resolution.innerHTML
            =
            caml_jsstring_of_string
             (replace(10,cst_br,caml_call1(P[15][1][15][6][6],d)));
            status(cst_Computing_Betti_numbers);
            var
             s$1=[0,cst$1],
             h=caml_call3(P[15][9],[0,_bx_],pres$0,maxdeg$0),
             _bz_=
              function(i,n)
               {var
                 _bI_=caml_call1(Stdlib[33],n),
                 _bJ_=caml_call2(Stdlib[28],_bI_,cst_br$0),
                 _bK_=caml_call2(Stdlib[28],cst$2,_bJ_),
                 _bL_=caml_call1(Stdlib[33],i),
                 _bM_=caml_call2(Stdlib[28],_bL_,_bK_),
                 _bN_=caml_call2(Stdlib[28],cst_H,_bM_);
                s$1[1] = caml_call2(Stdlib[28],s$1[1],_bN_);
                return 0};
            caml_call2(Stdlib_Array[14],_bz_,h);
            betti.innerHTML = caml_jsstring_of_string(s$1[1]);
            status(cst_Done);
            var _bA_=Js_of_ocaml_Js[7];
            return _bA_}}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn === Stdlib[3])return Js_of_ocaml_Js[8];
          if(exn[1] === Stdlib[7])
           {var s=exn[2];
            error(caml_call2(Stdlib[28],cst_Error,s));
            return Js_of_ocaml_Js[8]}
          if(exn === Stdlib[8]){error(cst_Not_found);return Js_of_ocaml_Js[8]}
          throw exn}}
      var t57=caml_call1(Js_of_ocaml_Dom_html[10],_p_);
      t58.onclick = t57;
      function generate_handler(param)
       {function list_init(n,f)
         {function aux(k)
           {if(n <= k)return 0;
            var _bt_=aux(k + 1 | 0);
            return [0,caml_call1(f,k),_bt_]}
          return aux(0)}
        function set(v,r)
         {var t59=caml_jsstring_of_string(v);
          t60.value = t59;
          var t61=caml_jsstring_of_string(r);
          return t62.value = t61}
        function gen(n)
         {var _bs_=caml_call1(Stdlib[29],n + 97 | 0);
          return caml_call2(Stdlib_String[1],1,_bs_)}
        var
         n=caml_int_of_string(caml_string_of_jsstring(t68.value)),
         match=caml_string_of_jsstring(t66.value);
        if(caml_string_notequal(match,cst_ext))
         if(caml_string_notequal(match,cst_plactic))
          if(caml_string_notequal(match,cst_pow))
           if(caml_string_notequal(match,cst_sklyanin))
            if(caml_string_notequal(match,cst_sym))
             {if(caml_string_notequal(match,cst_symg))
               throw [0,Assert_failure,_h_];
              var
               _Z_=list_init(n,gen),
               v$2=caml_call2(Stdlib_String[6],cst$10,_Z_),
               rel$3=[0,0],
               _$_=n - 2 | 0,
               ___=0;
              if(! (_$_ < 0))
               {var i$2=___;
                for(;;)
                 {var
                   _ap_=rel$3[1],
                   _aq_=gen(i$2),
                   _ar_=caml_call2(Stdlib[28],_aq_,cst_1),
                   _as_=gen(i$2);
                  rel$3[1] = [0,caml_call2(Stdlib[28],_as_,_ar_),_ap_];
                  var
                   _at_=rel$3[1],
                   _au_=gen(i$2 + 1 | 0),
                   _av_=gen(i$2),
                   _aw_=caml_call2(Stdlib[28],_av_,_au_),
                   _ax_=gen(i$2 + 1 | 0),
                   _ay_=caml_call2(Stdlib[28],_ax_,_aw_),
                   _az_=caml_call2(Stdlib[28],cst$13,_ay_),
                   _aA_=gen(i$2),
                   _aB_=caml_call2(Stdlib[28],_aA_,_az_),
                   _aC_=gen(i$2 + 1 | 0),
                   _aD_=caml_call2(Stdlib[28],_aC_,_aB_),
                   _aE_=gen(i$2);
                  rel$3[1] = [0,caml_call2(Stdlib[28],_aE_,_aD_),_at_];
                  var _aF_=i$2 + 1 | 0;
                  if(_$_ !== i$2){var i$2=_aF_;continue}
                  break}}
              var _ab_=n - 1 | 0,_aa_=0;
              if(! (_ab_ < 0))
               {var i$1=_aa_;
                for(;;)
                 {var _ad_=i$1 + 2 | 0,_ae_=n - 1 | 0;
                  if(! (_ae_ < _ad_))
                   {var j$1=_ad_;
                    for(;;)
                     {var
                       _ag_=rel$3[1],
                       _ah_=gen(i$1),
                       _ai_=gen(j$1),
                       _aj_=caml_call2(Stdlib[28],_ai_,_ah_),
                       _ak_=caml_call2(Stdlib[28],cst$12,_aj_),
                       _al_=gen(j$1),
                       _am_=caml_call2(Stdlib[28],_al_,_ak_),
                       _an_=gen(i$1);
                      rel$3[1] = [0,caml_call2(Stdlib[28],_an_,_am_),_ag_];
                      var _ao_=j$1 + 1 | 0;
                      if(_ae_ !== j$1){var j$1=_ao_;continue}
                      break}}
                  var _af_=i$1 + 1 | 0;
                  if(_ab_ !== i$1){var i$1=_af_;continue}
                  break}}
              var
               _ac_=caml_call1(Stdlib_List[9],rel$3[1]),
               rel$4=caml_call2(Stdlib_String[6],cst$11,_ac_);
              set(v$2,rel$4)}
            else
             {var
               _q_=list_init(n,gen),
               v$0=caml_call2(Stdlib_String[6],cst$4,_q_),
               rel=[0,0],
               _s_=n - 1 | 0,
               _r_=0;
              if(! (_s_ < 0))
               {var i=_r_;
                for(;;)
                 {var _u_=i + 1 | 0,_v_=n - 1 | 0;
                  if(! (_v_ < _u_))
                   {var j=_u_;
                    for(;;)
                     {var
                       _x_=rel[1],
                       _y_=gen(i),
                       _z_=gen(j),
                       _A_=caml_call2(Stdlib[28],_z_,_y_),
                       _B_=caml_call2(Stdlib[28],cst$6,_A_),
                       _C_=gen(j),
                       _D_=caml_call2(Stdlib[28],_C_,_B_),
                       _E_=gen(i);
                      rel[1] = [0,caml_call2(Stdlib[28],_E_,_D_),_x_];
                      var _F_=j + 1 | 0;
                      if(_v_ !== j){var j=_F_;continue}
                      break}}
                  var _w_=i + 1 | 0;
                  if(_s_ !== i){var i=_w_;continue}
                  break}}
              var
               _t_=caml_call1(Stdlib_List[9],rel[1]),
               rel$0=caml_call2(Stdlib_String[6],cst$5,_t_);
              set(v$0,rel$0)}
           else
            {var
              _aG_=list_init(n,gen),
              v$3=caml_call2(Stdlib_String[6],cst$14,_aG_),
              rel$5=[0,cst$15],
              _aI_=n - 1 | 0,
              _aH_=0;
             if(! (_aI_ < 0))
              {var i$4=_aH_;
               for(;;)
                {var
                  _aN_=caml_call1(Stdlib[33],n),
                  _aO_=caml_call2(Stdlib[28],cst$17,_aN_),
                  _aP_=gen(i$4),
                  _aQ_=caml_call2(Stdlib[28],_aP_,_aO_),
                  _aR_=
                   runtime.caml_string_equal(rel$5[1],cst$18)?cst$19:cst$20,
                  _aS_=caml_call2(Stdlib[28],_aR_,_aQ_);
                 rel$5[1] = caml_call2(Stdlib[28],rel$5[1],_aS_);
                 var _aT_=i$4 + 1 | 0;
                 if(_aI_ !== i$4){var i$4=_aT_;continue}
                 break}}
             rel$5[1] = caml_call2(Stdlib[28],rel$5[1],cst$16);
             var _aK_=n - 1 | 0,_aJ_=0;
             if(! (_aK_ < 0))
              {var i$3=_aJ_;
               for(;;)
                {var _aL_=gen(i$3);
                 rel$5[1] = caml_call2(Stdlib[28],rel$5[1],_aL_);
                 var _aM_=i$3 + 1 | 0;
                 if(_aK_ !== i$3){var i$3=_aM_;continue}
                 break}}
             set(v$3,rel$5[1])}
          else
           {var rel$6=[0,0],_aV_=n - 1 | 0,_aU_=0;
            if(! (_aV_ < 0))
             {var i$5=_aU_;
              for(;;)
               {var s=[0,cst_x],_aY_=i$5 - 1 | 0,_aX_=0;
                if(! (_aY_ < 0))
                 {var for$0=_aX_;
                  for(;;)
                   {s[1] = caml_call2(Stdlib[28],s[1],cst_y);
                    var _a0_=for$0 + 1 | 0;
                    if(_aY_ !== for$0){var for$0=_a0_;continue}
                    break}}
                s[1] = caml_call2(Stdlib[28],s[1],cst_x$0);
                rel$6[1] = [0,s[1],rel$6[1]];
                var _aZ_=i$5 + 1 | 0;
                if(_aV_ !== i$5){var i$5=_aZ_;continue}
                break}}
            var
             _aW_=caml_call1(Stdlib_List[9],rel$6[1]),
             rel$7=caml_call2(Stdlib_String[6],cst$21,_aW_);
            set(v,rel$7)}
         else
          {var
            v$4=list_init(n,gen),
            v$5=caml_call2(Stdlib_String[6],cst$22,v$4),
            rel$8=[0,0],
            _a2_=n - 1 | 0,
            _a1_=0;
           if(! (_a2_ < 0))
            {var x$1=_a1_;
             for(;;)
              {var _bg_=x$1 + 1 | 0,_bh_=n - 1 | 0;
               if(! (_bh_ < _bg_))
                {var y$1=_bg_;
                 for(;;)
                  {var _bj_=n - 1 | 0;
                   if(! (_bj_ < y$1))
                    {var z$1=y$1;
                     for(;;)
                      {var
                        x$2=gen(x$1),
                        y$2=gen(y$1),
                        z$2=gen(z$1),
                        _bl_=rel$8[1],
                        _bm_=caml_call2(Stdlib[28],x$2,z$2),
                        _bn_=caml_call2(Stdlib[28],y$2,_bm_),
                        _bo_=caml_call2(Stdlib[28],cst$25,_bn_),
                        _bp_=caml_call2(Stdlib[28],x$2,_bo_),
                        _bq_=caml_call2(Stdlib[28],z$2,_bp_);
                       rel$8[1] = [0,caml_call2(Stdlib[28],y$2,_bq_),_bl_];
                       var _br_=z$1 + 1 | 0;
                       if(_bj_ !== z$1){var z$1=_br_;continue}
                       break}}
                   var _bk_=y$1 + 1 | 0;
                   if(_bh_ !== y$1){var y$1=_bk_;continue}
                   break}}
               var _bi_=x$1 + 1 | 0;
               if(_a2_ !== x$1){var x$1=_bi_;continue}
               break}}
           var _a4_=n - 1 | 0,_a3_=0;
           if(! (_a4_ < 0))
            {var x=_a3_;
             for(;;)
              {var _a6_=n - 1 | 0;
               if(! (_a6_ < x))
                {var y=x;
                 for(;;)
                  {var _a8_=y + 1 | 0,_a9_=n - 1 | 0;
                   if(! (_a9_ < _a8_))
                    {var z=_a8_;
                     for(;;)
                      {var
                        x$0=gen(x),
                        y$0=gen(y),
                        z$0=gen(z),
                        _a$_=rel$8[1],
                        _ba_=caml_call2(Stdlib[28],x$0,y$0),
                        _bb_=caml_call2(Stdlib[28],z$0,_ba_),
                        _bc_=caml_call2(Stdlib[28],cst$24,_bb_),
                        _bd_=caml_call2(Stdlib[28],y$0,_bc_),
                        _be_=caml_call2(Stdlib[28],z$0,_bd_);
                       rel$8[1] = [0,caml_call2(Stdlib[28],x$0,_be_),_a$_];
                       var _bf_=z + 1 | 0;
                       if(_a9_ !== z){var z=_bf_;continue}
                       break}}
                   var _a__=y + 1 | 0;
                   if(_a6_ !== y){var y=_a__;continue}
                   break}}
               var _a7_=x + 1 | 0;
               if(_a4_ !== x){var x=_a7_;continue}
               break}}
           var
            _a5_=caml_call1(Stdlib_List[9],rel$8[1]),
            rel$9=caml_call2(Stdlib_String[6],cst$23,_a5_);
           set(v$5,rel$9)}
        else
         {var
           _G_=list_init(n,gen),
           v$1=caml_call2(Stdlib_String[6],cst$7,_G_),
           rel$1=[0,0],
           _I_=n - 1 | 0,
           _H_=0;
          if(! (_I_ < 0))
           {var i$0=_H_;
            for(;;)
             {var _K_=rel$1[1],_L_=gen(i$0),_M_=gen(i$0);
              rel$1[1] = [0,caml_call2(Stdlib[28],_M_,_L_),_K_];
              var _N_=i$0 + 1 | 0,_O_=n - 1 | 0;
              if(! (_O_ < _N_))
               {var j$0=_N_;
                for(;;)
                 {var
                   _Q_=rel$1[1],
                   _R_=gen(i$0),
                   _S_=gen(j$0),
                   _T_=caml_call2(Stdlib[28],_S_,_R_),
                   _U_=caml_call2(Stdlib[28],cst$9,_T_),
                   _V_=gen(j$0),
                   _W_=caml_call2(Stdlib[28],_V_,_U_),
                   _X_=gen(i$0);
                  rel$1[1] = [0,caml_call2(Stdlib[28],_X_,_W_),_Q_];
                  var _Y_=j$0 + 1 | 0;
                  if(_O_ !== j$0){var j$0=_Y_;continue}
                  break}}
              var _P_=i$0 + 1 | 0;
              if(_I_ !== i$0){var i$0=_P_;continue}
              break}}
          var
           _J_=caml_call1(Stdlib_List[9],rel$1[1]),
           rel$2=caml_call2(Stdlib_String[6],cst$8,_J_);
          set(v$1,rel$2)}
        return Js_of_ocaml_Js[7]}
      var t65=caml_call1(Js_of_ocaml_Dom_html[10],generate_handler);
      t66.oninput = t65;
      var t67=caml_call1(Js_of_ocaml_Dom_html[10],generate_handler);
      t68.onchange = t67;
      return Js_of_ocaml_Js[7]}
    var t69=caml_call1(Js_of_ocaml_Dom_html[10],run);
    Js_of_ocaml_Dom_html[8].onload = t69;
    var
     Dune_exe_Bergman=
      [0,
       doc,
       button,
       debug,
       jsget,
       Parsing,
       parse_pol,
       char_of_string,
       M,
       P,
       eval_pol,
       replace,
       run];
    runtime.caml_register_global(141,Dune_exe_Bergman,"Dune__exe__Bergman");
    return}
  (globalThis));


//# 1 "../../.js/stdlib/std_exit.cmo.js"
(function(globalThis)
   {"use strict";
    var runtime=globalThis.jsoo_runtime;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    var global_data=runtime.caml_get_global_data(),Stdlib=global_data.Stdlib;
    caml_call1(Stdlib[103],0);
    var Std_exit=[0];
    runtime.caml_register_global(1,Std_exit,"Std_exit");
    return}
  (globalThis));


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiZXJnbWFuLmJjLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbIk9iamVjdCIsImdsb2JhbFRoaXMiLCJ0aGlzIiwiZ2V0IiwiX1RfIiwiZ2xvYmFsIiwic2VsZiIsImNhbWxfaW50NjRfaXNfemVybyIsIngiLCJjYW1sX3N0cl9yZXBlYXQiLCJuIiwicyIsInIiLCJsIiwiY2FtbF9pbnQ2NF9vZmZzZXQiLCJNYXRoIiwiY2FtbF9yYWlzZV9jb25zdGFudCIsInRhZyIsImNhbWxfZ2xvYmFsX2RhdGEiLCJjYW1sX3JhaXNlX3plcm9fZGl2aWRlIiwiTWxJbnQ2NCIsImxvIiwibWkiLCJoaSIsInhoaSIsImgiLCJzaWduIiwib2Zmc2V0IiwibW9kdWx1cyIsImRpdmlzb3IiLCJxdW90aWVudCIsInkiLCJxIiwiY2FtbF9pbnQ2NF9vZl9pbnQzMiIsImNhbWxfaW50NjRfdG9faW50MzIiLCJjYW1sX2ludDY0X2lzX25lZ2F0aXZlIiwiY2FtbF9pbnQ2NF9uZWciLCJjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMiLCJhIiwiaSIsImxlbiIsImYiLCJTdHJpbmciLCJudWxsIiwiY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyIsImNhbWxfanNieXRlc19vZl9zdHJpbmciLCJjYW1sX3JhaXNlX3dpdGhfYXJnIiwiYXJnIiwianNvb19pc19hc2NpaSIsImNhbWxfdXRmMTZfb2ZfdXRmOCIsImIiLCJ0IiwiYyIsImMxIiwiYzIiLCJ2IiwiaiIsIk1sQnl0ZXMiLCJjb250ZW50cyIsImxlbmd0aCIsImNvbnRlbnQiLCJjYW1sX2J5dGVzX29mX2pzYnl0ZXMiLCJjYW1sX3N0cmluZ19vZl9qc2J5dGVzIiwiY2FtbF9yYWlzZV93aXRoX3N0cmluZyIsIm1zZyIsImNhbWxfaW52YWxpZF9hcmd1bWVudCIsImNhbWxfcGFyc2VfZm9ybWF0IiwiZm10IiwiY2FtbF9maW5pc2hfZm9ybWF0dGluZyIsInJhd2J1ZmZlciIsImJ1ZmZlciIsImNhbWxfaW50NjRfZm9ybWF0Iiwid2Jhc2UiLCJjdnRibCIsInAiLCJjYW1sX2V4cG0xX2Zsb2F0IiwiY2FtbF9qc3N0cmluZ19vZl9zdHJpbmciLCJmc19ub2RlX3N1cHBvcnRlZCIsIm1ha2VfcGF0aF9pc19hYnNvbHV0ZSIsInBvc2l4IiwicGF0aCIsIndpbjMyIiwic3BsaXREZXZpY2VSZSIsInJlc3VsdCIsImRldmljZSIsImlzVW5jIiwiQm9vbGVhbiIsInJvb3QiLCJzZXAiLCJwYXRoX2lzX2Fic29sdXRlIiwiY2FtbF90cmFpbGluZ19zbGFzaCIsIm5hbWUiLCJjYW1sX2N1cnJlbnRfZGlyIiwiY2FtbF9tYWtlX3BhdGgiLCJjb21wMCIsImNvbXAiLCJuY29tcCIsImNhbWxfdXRmOF9vZl91dGYxNiIsImQiLCJjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nIiwiY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmciLCJ1bml4X2Vycm9yIiwibWFrZV91bml4X2Vycl9hcmdzIiwiY29kZSIsInN5c2NhbGwiLCJlcnJubyIsInZhcmlhbnQiLCJhcmdzIiwiY2FtbF9uYW1lZF92YWx1ZXMiLCJjYW1sX25hbWVkX3ZhbHVlIiwibm0iLCJjYW1sX3JhaXNlX3dpdGhfYXJncyIsImNhbWxfaXNfbWxfYnl0ZXMiLCJjYW1sX2lzX21sX3N0cmluZyIsImNhbWxfYnl0ZXNfb2ZfYXJyYXkiLCJjYW1sX2J5dGVzX29mX3N0cmluZyIsImNhbWxfcmFpc2Vfc3lzX2Vycm9yIiwiY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUiLCJjYW1sX2J5dGVzX2JvdW5kX2Vycm9yIiwiY2FtbF9ieXRlc191bnNhZmVfZ2V0IiwiY2FtbF9ieXRlc19nZXQiLCJjYW1sX2NyZWF0ZV9ieXRlcyIsImNhbWxfbWxfYnl0ZXNfbGVuZ3RoIiwiY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IiwiQXJyYXkiLCJjYW1sX2JsaXRfYnl0ZXMiLCJzMSIsImkxIiwiczIiLCJpMiIsImNhbWxfYmxpdF9zdHJpbmciLCJlIiwiTWxGaWxlIiwiTWxGYWtlRmlsZSIsIm9sZCIsImJ1ZiIsInBvcyIsImNsZW4iLCJuZXdfc3RyIiwib2xkX2RhdGEiLCJNbEZha2VEZXZpY2UiLCJyZXMiLCJTeW1ib2wiLCJuYW1lX3NsYXNoIiwibW9kZSIsInJhaXNlX3VuaXgiLCJwYXJlbnQiLCJSZWdFeHAiLCJzZWVuIiwibSIsIm9rIiwiZmlsZSIsImJ5dGVzIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfdW5zYWZlX2dldCIsImNhbWxfYXJyYXlfb2Zfc3RyaW5nIiwiY2FtbF9hcnJheV9vZl9ieXRlcyIsImNhbWxfYnl0ZXNfdW5zYWZlX3NldCIsImNhbWxfYnl0ZXNfc2V0IiwiTWxOb2RlRmlsZSIsImZkIiwicmVxdWlyZSIsImVyciIsImJ1Zl9vZmZzZXQiLCJNbE5vZGVEZXZpY2UiLCJjb25zdHMiLCJrZXkiLCJvIiwianNfc3RhdHMiLCJ0b19kaXIiLCJ0YXJnZXQiLCJsaW5rIiwiZmlsZV9raW5kIiwiY2FtbF9nZXRfcm9vdCIsImNhbWxfZmFpbHdpdGgiLCJjYW1sX3Jvb3QiLCJqc29vX21vdW50X3BvaW50IiwicmVzb2x2ZV9mc19kZXZpY2UiLCJjYW1sX3N5c19pc19kaXJlY3RvcnkiLCJjYW1sX3JhaXNlX25vdF9mb3VuZCIsImNhbWxfc3lzX2dldGVudiIsImciLCJ1bmRlZmluZWQiLCJzaGlmdF9yaWdodF9uYXQiLCJuYXQxIiwib2ZzMSIsImxlbjEiLCJuYXQyIiwib2ZzMiIsIm5iaXRzIiwid3JhcCIsImNhbWxfZ3Jfc3RhdGUiLCJjYW1sX2dyX3N0YXRlX2dldCIsImNhbWxfZ3JfcG9pbnRfY29sb3IiLCJpbSIsIk1sT2JqZWN0VGFibGUiLCJOYWl2ZUxvb2t1cCIsIm9ianMiLCJjYW1sX3N5c19yZW5hbWUiLCJvX3Jvb3QiLCJuX3Jvb3QiLCJjYW1sX2xvZzEwX2Zsb2F0IiwidW5peF91bmxpbmsiLCJjYW1sX3J1bnRpbWVfd2FybmluZ3MiLCJjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzIiwiYm9vbCIsImNhbWxfY2xhc3NpZnlfZmxvYXQiLCJpc0Zpbml0ZSIsImlzTmFOIiwidW5peF9ybWRpciIsImNhbWxfbWxfcmVmaWxsX2lucHV0IiwiY2hhbiIsInN0ciIsInN0cl9sZW4iLCJjYW1sX21sX2NoYW5uZWxzIiwiY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0IiwiY2hhbmlkIiwiY2FtbF9hcnJheV9ib3VuZF9lcnJvciIsImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lIiwiY2FtbF9nY19taW5vciIsImNhbWxfaW50NjRfb2ZfYnl0ZXMiLCJjYW1sX2JhX3VpbnQ4X2dldDY0IiwiYmEiLCJpMCIsIm9mcyIsImIxIiwiYjIiLCJiMyIsImI0IiwiYjUiLCJiNiIsImI3IiwiYjgiLCJjYW1sX2ludDY0X3RvX2J5dGVzIiwiY2FtbF9pbnQ2NF9tYXJzaGFsIiwid3JpdGVyIiwic2l6ZXMiLCJjYW1sX2JhX251bV9kaW1zIiwiY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY3JlYXRlX2ZpbGUiLCJqc29vX2NyZWF0ZV9maWxlIiwiY2FtbF9mc19pbml0IiwidG1wIiwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlIiwiY2FtbF9saXN0X29mX2pzX2FycmF5IiwidW5peF9nZXR0aW1lb2ZkYXkiLCJEYXRlIiwiY2FtbF9tdWwiLCJjYW1sX2hhc2hfbWl4X2ludCIsIm51bV9kaWdpdHNfbmF0IiwibmF0IiwiY2FtbF9oYXNoX25hdCIsImNhbWxfY2FsbF9nZW4iLCJhcmdzTGVuIiwiZXh0cmFfYXJncyIsImFyZ3VtZW50cyIsIm5hcmdzIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfc3lzX2NoZGlyIiwiZGlyIiwiY2FtbF9nY19jb3VudGVycyIsImNhbWxfZ3Jfc3luY2hyb25pemUiLCJ1bml4X2hhc19zeW1saW5rIiwidW5pdCIsImxvZzJfb2siLCJqc29vX2Zsb29yX2xvZzIiLCJJbmZpbml0eSIsImNhbWxfaW50MzJfYml0c19vZl9mbG9hdCIsImZsb2F0MzJhIiwiaW50MzJhIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkiLCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQiLCJleHAiLCJrIiwicjMiLCJyMiIsInIxIiwiY2FtbF9iYV9zZXJpYWxpemUiLCJzeiIsImNvbXBsZXgiLCJjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50Iiwia2luZCIsImNhbWxfYmFfY3JlYXRlX2J1ZmZlciIsInNpemUiLCJ2aWV3IiwiZGF0YSIsImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyIsImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyIsIk5hTiIsImNhbWxfYmFfZ2V0X3NpemUiLCJkaW1zIiwibl9kaW1zIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkiLCJjYW1sX2ludDY0X2hpMzIiLCJjYW1sX2ludDY0X2xvMzIiLCJjYW1sX2JhX2N1c3RvbV9uYW1lIiwiTWxfQmlnYXJyYXkiLCJsYXlvdXQiLCJyZSIsInRvdGFsIiwiazEiLCJrMiIsIk1sX0JpZ2FycmF5X2NfMV8xIiwiY2FtbF9iYV9jcmVhdGVfdW5zYWZlIiwic2l6ZV9wZXJfZWxlbWVudCIsImNhbWxfYmFfZGVzZXJpYWxpemUiLCJyZWFkZXIiLCJudW1fZGltcyIsInNpemVfZGltIiwic2l6ZV9kaW1faGkiLCJzaXplX2RpbV9sbyIsInNpeHR5IiwiaW50NjQiLCJjYW1sX2JhX2NvbXBhcmUiLCJjYW1sX2hhc2hfbWl4X2ludDY0IiwiY2FtbF9oYXNoX21peF9mbG9hdCIsInYwIiwiY2FtbF9iYV9oYXNoIiwibnVtX2VsdHMiLCJ3IiwiY2FtbF9pbnQzMl91bm1hcnNoYWwiLCJjYW1sX25hdGl2ZWludF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X3VubWFyc2hhbCIsImNhbWxfaW50NjRfY29tcGFyZSIsImNhbWxfaW50NjRfaGFzaCIsImNhbWxfY3VzdG9tX29wcyIsImNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSIsImNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbSIsIm51bSIsImN1c3RvbSIsInN3YXAiLCJjYW1sX2NvbXBhcmVfdmFsX3RhZyIsIk51bWJlciIsImNhbWxfaW50X2NvbXBhcmUiLCJjYW1sX2J5dGVzX2NvbXBhcmUiLCJjYW1sX3N0cmluZ19jb21wYXJlIiwiY2FtbF9jb21wYXJlX3ZhbCIsInN0YWNrIiwidGFnX2EiLCJ0YWdfYiIsImNhbWxfZ3JlYXRlcnRoYW4iLCJkaXZfaGVscGVyIiwieiIsImRpdl9kaWdpdF9uYXQiLCJuYXRxIiwib2ZzcSIsIm5hdHIiLCJvZnNyIiwicmVtIiwibnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0Iiwic2hpZnRfbGVmdF9uYXQiLCJNbE5hdCIsImNyZWF0ZV9uYXQiLCJhcnIiLCJzZXRfdG9femVyb19uYXQiLCJpbmNyX25hdCIsImNhcnJ5X2luIiwiY2FycnkiLCJhZGRfbmF0IiwibGVuMiIsIm5hdF9vZl9hcnJheSIsIm11bHRfZGlnaXRfbmF0IiwibmF0MyIsIm9mczMiLCJ4MSIsIngyIiwieDMiLCJkZWNyX25hdCIsImJvcnJvdyIsInN1Yl9uYXQiLCJjb21wYXJlX25hdCIsImRpdl9uYXQiLCJxdW8iLCJjYW1sX2JhX2JsaXQiLCJzcmMiLCJkc3QiLCJpc19kaWdpdF9pbnQiLCJjYW1sX2ludDY0X2RpdiIsImNhbWxfanNfaHRtbF9lbnRpdGllcyIsImVudGl0eSIsInRlbXAiLCJkb2N1bWVudCIsImNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQiLCJjYW1sX2ludDY0X29mX2Zsb2F0IiwiY2FtbF9tbF9jaGFubmVsX3NpemVfNjQiLCJjYW1sX2JhX3NldF8yIiwiY2FtbF9hcmd2IiwibWFpbiIsImFyZ3YiLCJhcmdzMiIsImNhbWxfZXhlY3V0YWJsZV9uYW1lIiwiY2FtbF9qc19ldmFsX3N0cmluZyIsImV2YWwiLCJzZXJpYWxpemVfbmF0IiwiY2FtbF9tZW1wcm9mX3NldCIsIl9jb250cm9sIiwiY2FtbF9zeXNfZXhpdCIsImNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yIiwiY2FtbF9qc19mcm9tX2FycmF5IiwiY2FtbF9iYV9yZXNoYXBlIiwidmluZCIsIm5ld19kaW0iLCJjYW1sX29vX2xhc3RfaWQiLCJjYW1sX3NldF9vb19pZCIsImNhbWxfZ3JfZmlsbF9yZWN0IiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEiLCJzdHIxIiwicG9zMSIsImJhMiIsInBvczIiLCJzbGljZSIsImNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZSIsImpzbmFtZSIsImNhbWxfZ2V0X2dsb2JhbF9kYXRhIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCIsImNhbWxfYmFfdWludDhfZ2V0MTYiLCJjYW1sX2NvbXBhcmUiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9pbnQ2NF90b19mbG9hdCIsImNhbWxfYmFfZ2V0XzEiLCJjYW1sX2JpZ3N0cmluZ19tZW1jbXAiLCJjYW1sX25ld19zdHJpbmciLCJjYW1sX2VyZl9mbG9hdCIsImExIiwiYTIiLCJhMyIsImE0IiwiYTUiLCJjYW1sX2JhX3VpbnQ4X2dldDMyIiwiY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aCIsImNhbWxfb2JqX2Jsb2NrIiwiY2FtbF9ncl9jbGVhcl9ncmFwaCIsImJpZ3N0cmluZ190b19hcnJheV9idWZmZXIiLCJicyIsImNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQiLCJfdW5pdCIsImx4b3JfZGlnaXRfbmF0IiwiY2FtbF9vYmpfYWRkX29mZnNldCIsImNhbWxfZmluYWxfcmVsZWFzZSIsImNhbWxfanNfdG9fYXJyYXkiLCJjYW1sX2dyX3Bsb3QiLCJjb2xvciIsImNhbWxfYnl0ZXNfc2V0MTYiLCJpMTYiLCJjYW1sX3N0cmluZ19zZXQxNiIsImNhbWxfYnl0ZXNfc2V0NjQiLCJpNjQiLCJjYW1sX2ludDY0X2Jzd2FwIiwiY2FtbF9maWxsX2J5dGVzIiwiY2FtbF9maWxsX3N0cmluZyIsImNhbWxfZ2NfbWFqb3IiLCJjYW1sX2xleF9hcnJheSIsImNhbWxfbGV4X2VuZ2luZSIsInRibCIsInN0YXJ0X3N0YXRlIiwibGV4YnVmIiwibGV4X2J1ZmZlciIsImxleF9idWZmZXJfbGVuIiwibGV4X3N0YXJ0X3BvcyIsImxleF9jdXJyX3BvcyIsImxleF9sYXN0X3BvcyIsImxleF9sYXN0X2FjdGlvbiIsImxleF9lb2ZfcmVhY2hlZCIsImxleF9iYXNlIiwibGV4X2JhY2t0cmsiLCJsZXhfZGVmYXVsdCIsImxleF90cmFucyIsImxleF9jaGVjayIsInN0YXRlIiwiYmFzZSIsImJhY2t0cmsiLCJ1bml4X2dldHVpZCIsImNhbWxfc3lzX2ZpbGVfZXhpc3RzIiwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdCIsImNhbWxfYXJyYXlfc3ViIiwiY2FtbF9ieXRlc19lcXVhbCIsImNhbWxfZ3Jfc2l6ZV94IiwiY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1cyIsIm9zX3R5cGUiLCJjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luIiwiY2FtbF9jb3NoX2Zsb2F0IiwiY2FtbF9lcGhlX2tleV9vZmZzZXQiLCJjYW1sX3dlYWtfY2hlY2siLCJjYW1sX2VwaGVfY2hlY2tfa2V5IiwiY2FtbF9oYXNoX21peF9maW5hbCIsImNhbWxfZ3JfdGV4dF9zaXplIiwidHh0IiwiY2FtbF9sZXhfcnVuX21lbSIsIm1lbSIsImN1cnJfcG9zIiwiY2FtbF9sZXhfcnVuX3RhZyIsImNhbWxfbmV3X2xleF9lbmdpbmUiLCJsZXhfbWVtIiwibGV4X2Jhc2VfY29kZSIsImxleF9iYWNrdHJrX2NvZGUiLCJsZXhfZGVmYXVsdF9jb2RlIiwibGV4X3RyYW5zX2NvZGUiLCJsZXhfY2hlY2tfY29kZSIsImxleF9jb2RlIiwicGNfb2ZmIiwicHN0YXRlIiwiYmFzZV9jb2RlIiwiY2FtbF9iYV91aW50OF9zZXQ2NCIsImNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSIsImNhbWxfbGVzc2VxdWFsIiwiY2FtbF9hY29zaF9mbG9hdCIsImNhbWxfbWxfZmx1c2giLCJvdXRwdXQiLCJjYW1sX21sX3NlZWtfb3V0XzY0IiwiY29tcGFyZV9uYXRfcmVhbCIsImNhbWxfZ2Nfc2V0IiwiY2FtbF9qc19nZXQiLCJjYW1sX21sX3NldF9idWZmZXJlZCIsImNhbWxfZ2NfY29tcGFjdGlvbiIsImNhbWxfd2Vha19nZXQiLCJjYW1sX2VwaGVfZ2V0X2tleSIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEiLCJ3aW5fY2xlYW51cCIsImNhbWxfc3lzX2Nsb3NlIiwiY2FtbF9tbF9jbG9zZV9jaGFubmVsIiwiY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UiLCJleG4iLCJmb3JjZSIsImNhbWxfc3lzX2lzYXR0eSIsIl9jaGFuIiwiaXNfZGlnaXRfemVybyIsInVuaXhfaW5ldF9hZGRyX29mX3N0cmluZyIsImNhbWxfanNfc2V0IiwiY2FtbF9hcnJheV9nZXQiLCJhcnJheSIsImluZGV4IiwiY2FtbF9sb2cyX2Zsb2F0IiwiY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50IiwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUiLCJjYW1sX2ludDY0X3N1YiIsImNhbWxfbWxfc2Vla19pbl82NCIsImNhbWxfaW50NjRfc2hpZnRfbGVmdCIsImNhbWxfbm90ZXF1YWwiLCJjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrIiwiY2FtbF9pc19qcyIsImNhbWxfYmFfZGltIiwiY2FtbF9iYV9kaW1fMSIsInVuaXhfbG9jYWx0aW1lIiwiZF9udW0iLCJqYW51YXJ5Zmlyc3QiLCJkb3kiLCJqYW4iLCJqdWwiLCJzdGRUaW1lem9uZU9mZnNldCIsImNhbWxfanNfbWV0aF9jYWxsIiwiY2FtbF93ZWFrX2NyZWF0ZSIsImNhbWxfZXBoZV9jcmVhdGUiLCJjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIiwidW5peF9ta3RpbWUiLCJ0bSIsInRtMiIsImNhbWxfdHJhbXBvbGluZSIsImNhbWxfYnl0ZXNfZ2V0NjQiLCJjYW1sX3dlYWtfc2V0IiwiY2FtbF9zeXNfcmVtb3ZlIiwiY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IiLCJjYW1sX3N0cmluZ19nZXQzMiIsImNhbWxfaHlwb3RfZmxvYXQiLCJjYW1sX2pzX2NhbGwiLCJjYW1sX3N5c19jb25zdF9tYXhfd29zaXplIiwiY2FtbF9lcGhlX3Vuc2V0X2tleSIsImNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyIiwiY2FtbF9oYXNoX21peF9qc2J5dGVzIiwiY2FtbF9tbF9ieXRlc19jb250ZW50IiwiY2FtbF9oYXNoX21peF9ieXRlcyIsImNhbWxfYnl0ZXNfbGVzc3RoYW4iLCJjYW1sX2VyZmNfZmxvYXQiLCJjYW1sX2dyX2ZpbGxfcG9seSIsImFyIiwiY2FtbF9nY19xdWlja19zdGF0IiwiY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSIsImNhbWxfbWxfaW5wdXRfaW50IiwiY2FtbF9ncl9kaXNwbGF5X21vZGUiLCJjYW1sX29ial9yZWFjaGFibGVfd29yZHMiLCJudGhfZGlnaXRfbmF0IiwiY2FtbF9hcnJheV9ibGl0IiwiY2FtbF9mbG9hdF9vZl9zdHJpbmciLCJtMyIsIm1hbnRpc3NhIiwicGFyc2VJbnQiLCJleHBvbmVudCIsImNhbWxfc3lzX2dldGN3ZCIsImNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4iLCJjYW1sX2xpc3RfdG9fanNfYXJyYXkiLCJjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSIsImNhbWxfb3V0cHV0X3ZhbCIsIldyaXRlciIsInZhbHVlIiwiZmxhZ3MiLCJub19zaGFyaW5nIiwiY2xvc3VyZXMiLCJpbnRlcm5fb2JqX3RhYmxlIiwibWVtbyIsImV4aXN0aW5nX29mZnNldCIsImV4dGVybl9yZWMiLCJvcHMiLCJzel8zMl82NCIsImhlYWRlcl9wb3MiLCJvbGRfcG9zIiwidHlwZV9vZl92IiwiY2FtbF9zdHJpbmdfb2ZfYXJyYXkiLCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmciLCJjYW1sX3JhaXNlX25vdF9hX2RpciIsImNhbWxfc3lzX3N5c3RlbV9jb21tYW5kIiwiY21kIiwidW5peF9pc2F0dHkiLCJmaWxlRGVzY3JpcHRvciIsInR0eSIsImNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uIiwiZGVzZXJpYWxpemVfbmF0IiwiaW5pdGlhbGl6ZV9uYXQiLCJjYW1sX2dyX29wZW5fc3Vid2luZG93IiwidW5peF9sc3RhdCIsInVuaXhfbHN0YXRfNjQiLCJqc19wcmludF9zdGRvdXQiLCJjYW1sX2NvcHlzaWduX2Zsb2F0IiwiY2FtbF9ncl9zZXRfdGV4dF9zaXplIiwiY2FtbF9tZDVfYnl0ZXMiLCJhZGQiLCJ4eCIsImZmIiwiZ2ciLCJoaCIsImlpIiwibWQ1IiwiY2FtbF9iYV9zZXRfZ2VuZXJpYyIsImNhbWxfZXBoZV9zZXRfa2V5IiwiY2FtbF9ieXRlc19sZXNzZXF1YWwiLCJjYW1sX3N0cmluZ19sZXNzZXF1YWwiLCJjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWwiLCJjYW1sX2ludDY0X2FkZCIsImNhbWxfbmV4dGFmdGVyX2Zsb2F0IiwiYml0cyIsIm9uZSIsImNhbWxfZ3Jfc2l6ZV95IiwiY2FtbF9tbF9wb3NfaW4iLCJjYW1sX2ludDY0X2FuZCIsImNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSIsImNhbWxfc3RkX291dHB1dCIsInNsZW4iLCJqc19wcmludF9zdGRlcnIiLCJjYW1sX3N5c19vcGVuX2ludGVybmFsIiwiaWR4IiwiaW5mbyIsImNhbWxfc3lzX29wZW4iLCJfcGVybXMiLCJNbFN0cmluZ1JlYWRlciIsImNhbWxfZmxvYXRfb2ZfYnl0ZXMiLCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIiwiX21hZ2ljIiwiX2Jsb2NrX2xlbiIsIm51bV9vYmplY3RzIiwiX3NpemVfMzIiLCJfc2l6ZV82NCIsIm9ial9jb3VudGVyIiwiaW50ZXJuX3JlYyIsImhlYWRlciIsImV4cGVjdGVkX3NpemUiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyIsImNhbWxfc3RyaW5nX2dldCIsInJlX21hdGNoIiwicmVfd29yZF9sZXR0ZXJzIiwib3Bjb2RlcyIsImlzX3dvcmRfbGV0dGVyIiwiaW5fYml0c2V0IiwicmVfbWF0Y2hfaW1wbCIsInBhcnRpYWwiLCJwcm9nIiwiY3Bvb2wiLCJub3JtdGFibGUiLCJudW1ncm91cHMiLCJudW1yZWdpc3RlcnMiLCJzdGFydGNoYXJzIiwicGMiLCJxdWl0IiwiZ3JvdXBzIiwicmVfcmVnaXN0ZXIiLCJiYWNrdHJhY2siLCJpdGVtIiwicHVzaCIsImFjY2VwdCIsInByZWZpeF9tYXRjaCIsIm9wIiwic2FyZyIsInVhcmciLCJncm91cCIsIkVycm9yIiwicmVfc2VhcmNoX2JhY2t3YXJkIiwiY2FtbF9qc19mcm9tX3N0cmluZyIsImNhbWxfYmFfc3ViIiwiY2hhbmdlZF9kaW0iLCJtdWwiLCJuZXdfZGltcyIsIm5ld19kYXRhIiwiY2FtbF9nY19mdWxsX21ham9yIiwiY2FtbF9ieXRlc19zZXQzMiIsImkzMiIsImNhbWxfZ3Jfc2lnaW9fc2lnbmFsIiwiY2FtbF9iYV91aW50OF9zZXQzMiIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IiwiY2FtbF9zaWduYml0X2Zsb2F0IiwiY2FtbF9ncl9zZXRfbGluZV93aWR0aCIsImNhbWxfZ3Jfc2V0X2ZvbnQiLCJjYW1sX2dyX3NldF9jb2xvciIsImNvbnZlcnQiLCJudW1iZXIiLCJjX3N0ciIsImNhbWxfZ3JfbW92ZXRvIiwiY2FtbF9ncl9yZXNpemVfd2luZG93IiwiY2FtbF9ncl9zdGF0ZV9pbml0IiwiY2FtbF9ncl9jdXJyZW50X3giLCJjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkiLCJ0YSIsImNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSIsImNhbWxfbWxfc2Vla19vdXQiLCJjYW1sX2pzX3R5cGVvZiIsImNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlIiwiYnQiLCJjYW1sX2dyX2xpbmV0byIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSIsImNhbWxfYmFfZGltXzMiLCJjYW1sX2lzX3NwZWNpYWxfZXhjZXB0aW9uIiwiY2FtbF9mb3JtYXRfZXhjZXB0aW9uIiwiYnVja2V0Iiwic3RhcnQiLCJjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbiIsImhhbmRsZXIiLCJhdF9leGl0IiwiY2FtbF9lcGhlX2RhdGFfb2Zmc2V0IiwiY2FtbF9lcGhlX2NoZWNrX2RhdGEiLCJjYW1sX2J5dGVzX2dldDE2IiwiY2FtbF9vYmpfbWFrZV9mb3J3YXJkIiwiY2FtbF9qc19mcm9tX2Jvb2wiLCJjYW1sX21sX3NldF9jaGFubmVsX25hbWUiLCJjYW1sX2V4cDJfZmxvYXQiLCJjYW1sX2dyX2Nsb3NlX2dyYXBoIiwiY2FtbF9jcmVhdGVfc3RyaW5nIiwiY2FtbF9tZDVfc3RyaW5nIiwiY2FtbF9tZDVfY2hhbiIsImNoYW5fbGVuIiwiY2FtbF9vYmpfZHVwIiwiY2FtbF93ZWFrX2dldF9jb3B5IiwiY2FtbF9hdGFuaF9mbG9hdCIsImNhbWxfbWxfb3V0cHV0X2J5dGVzIiwic3RyaW5nIiwianNzdHJpbmciLCJpZCIsImNhbWxfbWxfb3V0cHV0IiwiY2FtbF9lcGhlX2dldF9kYXRhIiwiY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGUiLCJjYW1sX3RyYW1wb2xpbmVfcmV0dXJuIiwiY2FtbF9tbF9pc19idWZmZXJlZCIsImNhbWxfYXJyYXlfYXBwZW5kIiwibDEiLCJsMiIsImNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsIiwiY2FtbF9qc19leHByIiwiY2FtbF9pbnQ2NF9tdWwiLCJjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZCIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzIiwiY2FtbF9ldmVudGxvZ19yZXN1bWUiLCJjYW1sX2hhc2hfdW5pdl9wYXJhbSIsImNvdW50IiwibGltaXQiLCJvYmoiLCJoYXNoX2FjY3UiLCJoYXNoX2F1eCIsImpzYnl0ZXMiLCJjYW1sX3N0cmluZ19lcXVhbCIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciIsInJlX3JlcGxhY2VtZW50X3RleHQiLCJyZXBsIiwib3JpZyIsImN1ciIsImVuZCIsImNhbWxfcHVyZV9qc19leHByIiwiYmxpdF9uYXQiLCJjYW1sX2ludDY0X3VsdCIsImNhbWxfaW50NjRfeG9yIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyIsImJhMSIsImJ5dGVzMiIsImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUiLCJqc29vX2NyZWF0ZV9maWxlX2V4dGVybiIsImNhbWxfdG9fanNfc3RyaW5nIiwiY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIiwiY2FtbF9wYXJzZV9kaWdpdCIsImNhbWxfaW50NjRfb2Zfc3RyaW5nIiwiYmFzZTY0IiwidGhyZXNob2xkIiwicmVfc2VhcmNoX2ZvcndhcmQiLCJjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZyIsImNhbWxfbWFrZV92ZWN0IiwiaW5pdCIsImNhbWxfbWxfc2Vla19pbiIsImNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5IiwiY2FtbF9tbF9vdXRwdXRfY2hhciIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiIsImNhbWxfb2JqX2lzX2Jsb2NrIiwiY2FtbF9tbF9pbnB1dF9jaGFyIiwiY2FtbF9vYmpfc2V0X3Jhd19maWVsZCIsImNhbWxfanNfdmFyIiwiY2FtbF90cnVuY19mbG9hdCIsImNhbWxfZXBoZV9ibGl0X2RhdGEiLCJjYW1sX2lzX3ByaW50YWJsZSIsImNhbWxfZXF1YWwiLCJyZV9wYXJ0aWFsX21hdGNoIiwiY2FtbF9zeXNfcmFuZG9tX3NlZWQiLCJidWZmIiwibm93IiwiY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSIsImNhbWxfYmFfZ2V0XzIiLCJ3aW5faGFuZGxlX2ZkIiwiY2FtbF9iYV91aW50OF9zZXQxNiIsIndpbl9maWxlZGVzY3Jfb2ZfY2hhbm5lbCIsImNhbWxfanNfZGVsZXRlIiwiY2FtbF9pbnRfb2Zfc3RyaW5nIiwiY2FtbF9saXN0X21vdW50X3BvaW50IiwicHJldiIsImNhbWxfbWFyc2hhbF9jb25zdGFudHMiLCJjYW1sX29ial9yYXdfZmllbGQiLCJjYW1sX2pzX2VxdWFscyIsImJpZ3N0cmluZ190b190eXBlZF9hcnJheSIsImNhbWxfZ3JfYXJjX2F1eCIsImN0eCIsImN4IiwiY3kiLCJyeSIsInJ4Iiwicm90IiwieFBvcyIsInlQb3MiLCJ4UG9zX3ByZXYiLCJ5UG9zX3ByZXYiLCJzcGFjZSIsImRlbHRhIiwiY2FtbF9ncl9maWxsX2FyYyIsImNhbWxfYmFfc2xpY2UiLCJudW1faW5kcyIsInN1Yl9kaW1zIiwiY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSIsImdldDMyIiwiY2FtbF9pbnB1dF92YWx1ZSIsImNhbWxfYmFfa2luZCIsImNhbWxfanNfZnVuX2NhbGwiLCJjYW1sX2djX21ham9yX3NsaWNlIiwid29yayIsImNhbWxfanNfcHVyZV9leHByIiwiY29tcGFyZV9kaWdpdHNfbmF0IiwiY2FtbF9tbF9pbnB1dCIsImNhbWxfZ3Jfd2FpdF9ldmVudCIsIl9ldmwiLCJjYW1sX2dyX3NpZ2lvX2hhbmRsZXIiLCJjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZyIsImNhbWxfcmVjb3JkX2JhY2t0cmFjZSIsInVuaXhfZ210aW1lIiwiY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIiwiY2FtbF9zeXNfZ2V0X2NvbmZpZyIsInVuaXhfdGltZSIsImNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3QiLCJjYW1sX2FzaW5oX2Zsb2F0IiwiYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlciIsImFiIiwiY2FtbF9tb2QiLCJjYW1sX2JhX2luaXQiLCJyZV9zdHJpbmdfbWF0Y2giLCJCaWdTdHJpbmdSZWFkZXIiLCJjYW1sX2dyX2R1bXBfaW1hZ2UiLCJjYW1sX2JhX2dldF9nZW5lcmljIiwiY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSIsImNhbWxfZm9ybWF0X2Zsb2F0IiwidG9GaXhlZCIsImRwIiwicHJlYyIsImNhbWxfbW91bnRfYXV0b2xvYWQiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhIiwiY2FtbF9ibGl0X2JpZ3N0cmluZ190b19iaWdzdHJpbmciLCJjYW1sX3N0cmluZ19sZXNzdGhhbiIsImNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuIiwiY2FtbF9kaXYiLCJjYW1sX2VwaGVfZ2V0X2RhdGFfY29weSIsImNhbWxfbWVtcHJvZl9zdGFydCIsInJhdGUiLCJzdGFja19zaXplIiwidHJhY2tlciIsImNhbWxfc3lzX2dldF9hcmd2IiwiY2FtbF9qc190b19ib29sIiwiY2FtbF9ncl9jcmVhdGVfaW1hZ2UiLCJjYW1sX2VwaGVfZ2V0X2tleV9jb3B5IiwiY2FtbF9sZXNzdGhhbiIsImNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QiLCJjYW1sX3JlZ2lzdGVyX2dsb2JhbCIsIm5hbWVfb3B0IiwibXVsdF9uYXQiLCJsZW4zIiwic3F1YXJlX25hdCIsImNhbWxfanNfZnJvbV9mbG9hdCIsImNhbWxfZmxvYXRhcnJheV9jcmVhdGUiLCJjYW1sX2djX3N0YXQiLCJjYW1sX2dldF9tYWpvcl9jcmVkaXQiLCJjYW1sX3N5c19tb2RpZnlfYXJndiIsImNhbWxfbWV0aG9kX2NhY2hlIiwiY2FtbF9nZXRfcHVibGljX21ldGhvZCIsImNhY2hlaWQiLCJtZXRocyIsImxpIiwiY2FtbF9qc19nZXRfY29uc29sZSIsImNhbWxfc3lzX3Vuc2FmZV9nZXRlbnYiLCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiIsInJlZmlsbCIsImZzIiwiY2hhbm5lbCIsImJpZ3N0cmluZ19vZl90eXBlZF9hcnJheSIsImNhbWxfcm91bmRfZmxvYXQiLCJ1bml4X3N0YXQiLCJ1bml4X3N0YXRfNjQiLCJjYW1sX29qc19uZXdfYXJyIiwiRiIsImNvbXBsZW1lbnRfbmF0IiwiY2FtbF9qc19yZWdleHBzIiwiY2FtbF9qc19odG1sX2VzY2FwZSIsImNhbWxfYmFfZGltXzIiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMiLCJjYW1sX3NpbmhfZmxvYXQiLCJjYW1sX2xkZXhwX2Zsb2F0IiwiY2FtbF9ncl9zdGF0ZV9zZXQiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0IiwiYXJpdHkiLCJjYW1sX2djX21pbm9yX3dvcmRzIiwiY2FtbF9iYV9zZXRfMSIsImNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIiwibGFuZF9kaWdpdF9uYXQiLCJjYW1sX2ludDY0X21vZCIsInVuaXhfcmVhZGxpbmsiLCJjYW1sX29ial9zZXRfdGFnIiwiY2FtbF9pbnQzMl9ic3dhcCIsIndpbl9zdGFydHVwIiwiY2FtbF9iYV9zZXRfMyIsImNhbWxfanNfaW5zdGFuY2VvZiIsImNhbWxfZ2V0X21ham9yX2J1Y2tldCIsImNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nIiwic2V0X2RpZ2l0X25hdF9uYXRpdmUiLCJkaWdpdCIsIm50aF9kaWdpdF9uYXRfbmF0aXZlIiwiY2FtbF9zdHJpbmdfc2V0NjQiLCJjYW1sX2dyX3N0YXRlX2NyZWF0ZSIsImNhbnZhcyIsImNvbnRleHQiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2siLCJjYW1sX2dyX2RyYXdfYXJjIiwiY2FtbF9iYV9tYXBfZmlsZSIsInZmZCIsInNoYXJlZCIsImNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGUiLCJhcmduIiwidW5peF9zeW1saW5rIiwic3JjX3Jvb3QiLCJkc3Rfcm9vdCIsImNhbWxfYmFfY3JlYXRlX2Zyb20iLCJkYXRhMSIsImRhdGEyIiwianN0eXAiLCJjYW1sX3RhbmhfZmxvYXQiLCJjYW1sX2dyX2RyYXdfc3RyIiwiZHgiLCJjYW1sX2dyX2RyYXdfc3RyaW5nIiwiY2FtbF9ncl9kcmF3X2NoYXIiLCJjYW1sX3VubW91bnQiLCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nIiwiY2FtbF9tbF9wb3NfaW5fNjQiLCJjYW1sX2dyX2RyYXdfaW1hZ2UiLCJpbWFnZSIsImNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lIiwiX2NoYW5uZWwiLCJjYW1sX3N0cmluZ19zZXQiLCJjYW1sX3N5c19ybWRpciIsImNhbWxfbWxfcG9zX291dCIsImNhbWxfc3BhY2V0aW1lX2VuYWJsZWQiLCJjYW1sX2J5dGVzX25vdGVxdWFsIiwiY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMiLCJjYW1sX2pzX29iamVjdCIsImNhbWxfYmFfY3JlYXRlIiwiZGltc19tbCIsImNhbWxfd2Vha19ibGl0IiwiY2FtbF9ncl9yZW1lbWJlcl9tb2RlIiwiY2FtbF9mbWFfZmxvYXQiLCJTUExJVCIsIk1JTl9WQUxVRSIsIkVQU0lMT04iLCJDIiwiQSIsIkIiLCJtdWx0aXBseSIsImF0IiwiYWhpIiwiYWxvIiwiYmhpIiwiYmxvIiwiYWRqdXN0Iiwic2NhbGUiLCJ4cyIsInlzIiwienMiLCJ4eSIsInUiLCJjYW1sX2Jzd2FwMTYiLCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZSIsImNhbWxfZmluYWxfcmVnaXN0ZXIiLCJjYW1sX2dyX2RyYXdfcmVjdCIsImNhbWxfc3RyaW5nX2dldDE2IiwiY2FtbF9lcGhlX3Vuc2V0X2RhdGEiLCJjYW1sX291dHB1dF92YWx1ZSIsImNhbWxfYmFfZ2V0XzMiLCJjYW1sX2VwaGVfYmxpdF9rZXkiLCJjYW1sX2luaXRpYWxfdGltZSIsImNhbWxfc3lzX3RpbWUiLCJjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW4iLCJjYW1sX2NoZWNrX2JvdW5kIiwidW5peF9nZXRwd3VpZCIsImNhbWxfaGFzaF9taXhfc3RyaW5nIiwiY2FtbF9oYXNoIiwic2VlZCIsInF1ZXVlIiwicmQiLCJ3ciIsImNhbWxfb2JqX3RhZyIsIkZ1bmN0aW9uIiwiY2FtbF9iYV90b190eXBlZF9hcnJheSIsImNhbWxfYnl0ZXNfZ2V0MzIiLCJjYW1sX2ZyZXhwX2Zsb2F0IiwibmVnIiwiY2FtbF9zdHJpbmdfZ2V0NjQiLCJjYW1sX2pzX2Vycm9yX29wdGlvbl9vZl9leGNlcHRpb24iLCJjYW1sX21sX3Bvc19vdXRfNjQiLCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyIsImNhbWxfZmxvYXRhcnJheV9ibGl0IiwiY2FtbF9nZXRfbWlub3JfZnJlZSIsImNhbWxfc2V0X3N0YXRpY19lbnYiLCJjYW1sX2JhX2NoYW5nZV9sYXlvdXQiLCJjYW1sX2pzX25ldyIsInVuaXhfbWtkaXIiLCJwZXJtIiwiY2FtbF9ncl9jdXJyZW50X3kiLCJjYW1sX2Zvcm1hdF9pbnQiLCJjYW1sX29ial90cnVuY2F0ZSIsImNhbWxfanNfdG9fc3RyaW5nIiwiaXNfZGlnaXRfb2RkIiwiY2FtbF9ydW50aW1lX3ZhcmlhbnQiLCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQiLCJjYW1sX2FycmF5X2NvbmNhdCIsImNhbWxfZ3Jfb3Blbl9ncmFwaCIsInNwZWNzIiwic3RhdHVzIiwid2luIiwiZG9jIiwidGl0bGUiLCJib2R5IiwiY2FtbF9lcGhlX3NldF9kYXRhIiwiY2FtbF9tYWtlX2Zsb2F0X3ZlY3QiLCJjYW1sX2NicnRfZmxvYXQiLCJjYW1sX21lbXByb2Zfc3RvcCIsImNhbWxfZXZlbnRsb2dfcGF1c2UiLCJjYW1sX2dyZWF0ZXJlcXVhbCIsImNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlIiwiY2FtbF9sb2cxcF9mbG9hdCIsImNhbWxfaW50NjRfb3IiLCJjYW1sX2xhenlfbWFrZV9mb3J3YXJkIiwibG9yX2RpZ2l0X25hdCIsImNhbWxfZ3JfYmxpdF9pbWFnZSIsImltMiIsImNhbWxfZ3Jfd2luZG93X2lkIiwiY2FtbF9qc19vbl9pZSIsInVhIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCIsImNhbWxfYmFfbGF5b3V0IiwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UiLCJjYW1sX2FycmF5X3NldCIsIm5ld3ZhbCIsImNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsIiwic2V0X2RpZ2l0X25hdCIsImNhbWxfZ3JfZG9jX29mX3N0YXRlIiwiY2FtbF9tbF9vdXRwdXRfaW50IiwiY2FtbF9vYmpfd2l0aF90YWciLCJjYW1sX21sX2NoYW5uZWxfc2l6ZSIsImNhbWxfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQiLCJzdHlsZSIsImV4cF9zaWduIiwic2lnbl9zdHIiLCJjc3QiLCJ4X3N0ciIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCIsImNhbWxfYmFja3RyYWNlX3N0YXR1cyIsImNhbWxfc3lzX2FyZ3YiLCJjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIiLCJjYW1sX2JhX2ZpbGwiLCJjYW1sX21vZGZfZmxvYXQiLCJjYW1sX2djX2dldCIsImNhbWxfZmxvYXRfY29tcGFyZSIsImNhbWxfc3RyaW5nX3NldDMyIiwiY2FtbF9wYXJzZV9lbmdpbmUiLCJ0YWJsZXMiLCJlbnYiLCJFUlJDT0RFIiwibG9vcCIsInRlc3RzaGlmdCIsInNoaWZ0Iiwic2hpZnRfcmVjb3ZlciIsInJlZHVjZSIsIlJFQURfVE9LRU4iLCJSQUlTRV9QQVJTRV9FUlJPUiIsIkdST1dfU1RBQ0tTXzEiLCJHUk9XX1NUQUNLU18yIiwiQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04iLCJDQUxMX0VSUk9SX0ZVTkNUSU9OIiwiZW52X3Nfc3RhY2siLCJlbnZfdl9zdGFjayIsImVudl9zeW1iX3N0YXJ0X3N0YWNrIiwiZW52X3N5bWJfZW5kX3N0YWNrIiwiZW52X3N0YWNrc2l6ZSIsImVudl9zdGFja2Jhc2UiLCJlbnZfY3Vycl9jaGFyIiwiZW52X2x2YWwiLCJlbnZfc3ltYl9zdGFydCIsImVudl9zeW1iX2VuZCIsImVudl9hc3AiLCJlbnZfcnVsZV9sZW4iLCJlbnZfcnVsZV9udW1iZXIiLCJlbnZfc3AiLCJlbnZfc3RhdGUiLCJlbnZfZXJyZmxhZyIsInRibF90cmFuc2xfY29uc3QiLCJ0YmxfdHJhbnNsX2Jsb2NrIiwidGJsX2xocyIsInRibF9sZW4iLCJ0YmxfZGVmcmVkIiwidGJsX2Rnb3RvIiwidGJsX3NpbmRleCIsInRibF9yaW5kZXgiLCJ0YmxfZ2luZGV4IiwidGJsX3RhYmxlc2l6ZSIsInRibF90YWJsZSIsInRibF9jaGVjayIsIm4xIiwibjIiLCJzdGF0ZTEiLCJzcCIsImVycmZsYWciLCJhc3AiLCJjYW1sX3VwZGF0ZV9kdW1teSIsImNhbWxfYXJyYXlfZmlsbCIsImNhbWxfc3lzX21rZGlyIiwiY2FtbF9zdHJpbmdfbm90ZXF1YWwiLCJjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuIiwiY2FtbF9ncl9tYWtlX2ltYWdlIiwiY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXQiLCJjYW1sX3JlYWRfZmlsZV9jb250ZW50IiwiY2FtbF9qc190b19mbG9hdCIsImNhbWxfc2V0dXBfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJvcmlnaW4iLCJldmVudCIsImVycl9ub19wcmVkIiwiZXJyX25vX3N1Y2MiLCJ6ZXJvJDIiLCJvbmUkMiIsIm1pbnVzX29uZSQyIiwibWluX2ludCQyIiwibWF4X2ludCQyIiwiZHVtbXlfcG9zIiwiemVyb19wb3MiLCJzdWJfZm9ybWF0IiwiZm9ybWF0dGluZ19saXQiLCJsb2NmbXQiLCJudWxsJDAiLCJjdXJyZW50X2Rpcl9uYW1lIiwicGFyZW50X2Rpcl9uYW1lIiwiZGlyX3NlcCIsInF1b3RlcXVvdGUiLCJudWxsJDEiLCJjdXJyZW50X2Rpcl9uYW1lJDAiLCJwYXJlbnRfZGlyX25hbWUkMCIsImRpcl9zZXAkMCIsIm51bGwkMiIsImN1cnJlbnRfZGlyX25hbWUkMSIsInBhcmVudF9kaXJfbmFtZSQxIiwiZGlyX3NlcCQxIiwiemVybyQ0Iiwib25lJDQiLCJpIiwiZXJhc2VfcmVsIiwicmVzdCIsInJlc3QkMCIsInJlc3QkMSIsInJlc3QkMiIsInJlc3QkMyIsInJlc3QkNCIsInJlc3QkNSIsInJlc3QkNiIsInJlc3QkNyIsInR5IiwicmVzdCQ4IiwidHkxIiwicmVzdCQ5IiwicmVzdCQxMCIsInJlc3QkMTEiLCJyZXN0JDEyIiwicmVzdCQxMyIsImNvbmNhdF9mbXR0eSIsImZtdHR5MSIsImZtdHR5MiIsInR5MiIsImNvbmNhdF9mbXQiLCJmbXQxIiwiZm10MiIsInBhZCIsInBhZCQwIiwicHJlYyIsInBhZCQxIiwiaWNvbnYiLCJwcmVjJDAiLCJwYWQkMiIsImljb252JDAiLCJwcmVjJDEiLCJwYWQkMyIsImljb252JDEiLCJwcmVjJDIiLCJwYWQkNCIsImljb252JDIiLCJwcmVjJDMiLCJwYWQkNSIsImZjb252IiwicGFkJDYiLCJzdHIiLCJjaHIiLCJmbXR0eSIsInBhZCQ3IiwiZm10dHkkMCIsInBhZCQ4IiwicmVzdCQxNCIsInJlc3QkMTUiLCJyZXN0JDE2IiwiZm10aW5nX2xpdCIsInJlc3QkMTciLCJmbXRpbmdfZ2VuIiwicmVzdCQxOCIsInJlc3QkMTkiLCJjaGFyX3NldCIsIndpZHRoX29wdCIsInJlc3QkMjAiLCJjb3VudGVyIiwicmVzdCQyMSIsInJlc3QkMjIiLCJpZ24iLCJyZXN0JDIzIiwiZiIsImFyaXR5IiwidiIsInIiLCJjdXIiLCJzZWVuIiwibiIsImZhaWx3aXRoIiwicyIsImludmFsaWRfYXJnIiwibWluIiwieCIsInkiLCJtYXgiLCJhYnMiLCJsbm90IiwiaW5maW5pdHkiLCJuZWdfaW5maW5pdHkiLCJuYW4iLCJtYXhfZmxvYXQiLCJtaW5fZmxvYXQiLCJlcHNpbG9uIiwibWF4X2ludCIsIm1pbl9pbnQiLCJzMSIsInMyIiwibDEiLCJsMiIsImNoYXJfb2ZfaW50Iiwic3RyaW5nX29mX2Jvb2wiLCJiIiwiYm9vbF9vZl9zdHJpbmciLCJib29sX29mX3N0cmluZ19vcHQiLCJzdHJpbmdfb2ZfaW50IiwiaW50X29mX3N0cmluZ19vcHQiLCJ2YWxpZF9mbG9hdF9sZXhlbSIsImwiLCJpJDAiLCJ0b19zdHJpbmciLCJvZl9zdHJpbmdfb3B0IiwiYXBwZW5kIiwidGwiLCJoZCIsInN0ZGluIiwic3Rkb3V0Iiwic3RkZXJyIiwib3Blbl9vdXRfZ2VuIiwibW9kZSIsInBlcm0iLCJuYW1lIiwiYyIsIm9wZW5fb3V0Iiwib3Blbl9vdXRfYmluIiwiZmx1c2hfYWxsIiwiaXRlciIsImEiLCJvdXRwdXRfYnl0ZXMiLCJvYyIsIm91dHB1dF9zdHJpbmciLCJvdXRwdXQiLCJvZnMiLCJsZW4iLCJvdXRwdXRfc3Vic3RyaW5nIiwib3V0cHV0X3ZhbHVlIiwiY2hhbiIsImNsb3NlX291dCIsImNsb3NlX291dF9ub2VyciIsIm9wZW5faW5fZ2VuIiwib3Blbl9pbiIsIm9wZW5faW5fYmluIiwiaW5wdXQiLCJpYyIsInVuc2FmZV9yZWFsbHlfaW5wdXQiLCJvZnMkMCIsImxlbiQwIiwibGVuJDEiLCJvZnMkMSIsInJlYWxseV9pbnB1dCIsInJlYWxseV9pbnB1dF9zdHJpbmciLCJpbnB1dF9saW5lIiwiYnVpbGRfcmVzdWx0IiwiYnVmIiwiYWNjdSIsImJlZyIsImFjY3UkMCIsInJlcyIsImNsb3NlX2luX25vZXJyIiwicHJpbnRfY2hhciIsInByaW50X3N0cmluZyIsInByaW50X2J5dGVzIiwicHJpbnRfaW50IiwicHJpbnRfZmxvYXQiLCJwcmludF9lbmRsaW5lIiwicHJpbnRfbmV3bGluZSIsInByZXJyX2NoYXIiLCJwcmVycl9zdHJpbmciLCJwcmVycl9ieXRlcyIsInByZXJyX2ludCIsInByZXJyX2Zsb2F0IiwicHJlcnJfZW5kbGluZSIsInByZXJyX25ld2xpbmUiLCJyZWFkX2xpbmUiLCJyZWFkX2ludCIsInJlYWRfaW50X29wdCIsInJlYWRfZmxvYXQiLCJyZWFkX2Zsb2F0X29wdCIsInN0cmluZ19vZl9mb3JtYXQiLCJzeW1ib2wiLCJzdHIyIiwic3RyMSIsImV4aXRfZnVuY3Rpb24iLCJhdF9leGl0IiwiZl95ZXRfdG9fcnVuIiwib2xkX2V4aXQiLCJuZXdfZXhpdCQwIiwibmV3X2V4aXQiLCJzdWNjZXNzIiwiZG9fYXRfZXhpdCIsImV4aXQiLCJyZXRjb2RlIiwic2V0X2JpbmFyeV9tb2RlX2luIiwiY2xvc2VfaW4iLCJpbl9jaGFubmVsX2xlbmd0aCIsInBvc19pbiIsInNlZWtfaW4iLCJpbnB1dF92YWx1ZSIsImlucHV0X2JpbmFyeV9pbnQiLCJpbnB1dF9ieXRlIiwiaW5wdXRfY2hhciIsInNldF9iaW5hcnlfbW9kZV9vdXQiLCJvdXRfY2hhbm5lbF9sZW5ndGgiLCJwb3Nfb3V0Iiwic2Vla19vdXQiLCJvdXRwdXRfYmluYXJ5X2ludCIsIm91dHB1dF9ieXRlIiwib3V0cHV0X2NoYXIiLCJmbHVzaCIsImVtcHR5IiwicmV0dXJuJDAiLCJjb25zIiwibmV4dCIsImFwcGVuZCQwIiwic2VxMSIsInNlcTIiLCJtYXAiLCJzZXEiLCJmaWx0ZXJfbWFwIiwic2VxJDAiLCJmaWx0ZXIiLCJjb25jYXQiLCJmbGF0X21hcCIsImZvbGRfbGVmdCIsImFjYyIsImFjYyQwIiwiYWNjJDEiLCJ1bmZvbGQiLCJ1IiwidSQwIiwibm9uZSIsInNvbWUiLCJ2YWx1ZSIsIm8iLCJkZWZhdWx0JDAiLCJnZXQkMCIsImJpbmQiLCJqb2luIiwibWFwJDAiLCJmb2xkIiwiaXRlciQwIiwiaXNfbm9uZSIsImlzX3NvbWUiLCJlcXVhbCIsImVxIiwibzAiLCJvMSIsInYxIiwidjAiLCJjb21wYXJlIiwiY21wIiwidG9fcmVzdWx0IiwidG9fbGlzdCIsInRvX3NlcSIsImxlZnQiLCJyaWdodCIsImlzX2xlZnQiLCJpc19yaWdodCIsImZpbmRfbGVmdCIsImZpbmRfcmlnaHQiLCJtYXBfbGVmdCIsImUiLCJtYXBfcmlnaHQiLCJtYXAkMSIsInYkMCIsImZvbGQkMCIsImVxdWFsJDAiLCJlMSIsImUyIiwidjIiLCJ2MiQwIiwiY29tcGFyZSQwIiwib2siLCJlcnJvciIsInZhbHVlJDAiLCJnZXRfb2siLCJnZXRfZXJyb3IiLCJiaW5kJDAiLCJqb2luJDAiLCJtYXAkMiIsIm1hcF9lcnJvciIsImZvbGQkMSIsIml0ZXIkMSIsIml0ZXJfZXJyb3IiLCJpc19vayIsImlzX2Vycm9yIiwiZXF1YWwkMSIsInIwIiwicjEiLCJjb21wYXJlJDEiLCJ0b19vcHRpb24iLCJ0b19saXN0JDAiLCJ0b19zZXEkMCIsImVxdWFsJDIiLCJjb21wYXJlJDIiLCJ0b19mbG9hdCIsInRvX3N0cmluZyQwIiwiZXNjYXBlZCIsInMkMCIsImxvd2VyY2FzZSIsInVwcGVyY2FzZSIsImxvd2VyY2FzZV9hc2NpaSIsInVwcGVyY2FzZV9hc2NpaSIsImNvbXBhcmUkMyIsImMxIiwiYzIiLCJlcXVhbCQzIiwibWluJDAiLCJtYXgkMCIsImxvX2JvdW5kIiwiaGlfYm91bmQiLCJib20iLCJyZXAiLCJzdWNjIiwicHJlZCIsImlzX3ZhbGlkIiwib2ZfaW50IiwiaXNfY2hhciIsIm9mX2NoYXIiLCJ0b19jaGFyIiwidW5zYWZlX3RvX2NoYXIiLCJlcXVhbCQ0IiwiY29tcGFyZSQ0IiwiaGFzaCIsIm1hdGNoJDEiLCJsZW5ndGgiLCJwYXJhbSQwIiwiY29ucyQwIiwibnRoIiwibCQwIiwibiQwIiwibCQxIiwibiQxIiwibnRoX29wdCIsInJldl9hcHBlbmQiLCJsMSQwIiwibDIkMCIsImwxJDEiLCJsMiQxIiwicmV2IiwiaW5pdF9hdXgiLCJwYXJhbSIsImFjY3UkMSIsImEyIiwiYTEiLCJwIiwicGFpciIsInJlc3VsdCIsInhzIiwieCQwIiwicnkiLCJyeCIsInQyIiwiaDIiLCJ0MSIsImgxIiwicmV2X3NvcnQiLCJ4MiIsIngxIiwidGwkMSIsIngzIiwieDIkMCIsIngxJDAiLCJuMSIsIm4yIiwic29ydCIsInRsJDAiLCJjJDAiLCJjJDEiLCJjJDIiLCJjJDMiLCJjJDQiLCJjJDUiLCJjJDYiLCJhY2N1JDIiLCJhdXgiLCJ0YWlsIiwiZGlyZWN0IiwiZGVwdGgiLCJ6ZXJvIiwib25lIiwibWludXNfb25lIiwiYWJzJDAiLCJtYXhfaW50JDAiLCJtaW5faW50JDAiLCJsb2dub3QiLCJlcXVhbCQ2IiwiY29tcGFyZSQ2IiwibWluJDEiLCJtYXgkMSIsInRvX3N0cmluZyQxIiwic3ltYm9sJDAiLCJkc3RvZmYiLCJzcmNvZmYiLCJjcHlsZW4iLCJvZnMxIiwib2ZzMiIsInNlcCIsInNlcGxlbiIsImRzdCIsImlzX3NwYWNlIiwiaiIsImFwcGx5MSIsInByZWZpeCIsImxlbl9zIiwibGVuX3ByZSIsInN1ZmZpeCIsImxlbl9zdWYiLCJkaWZmIiwiaW5kZXhfcmVjIiwibGltIiwiaSQxIiwiaW5kZXhfcmVjX29wdCIsInJpbmRleF9yZWMiLCJyaW5kZXhfcmVjX29wdCIsIm5ld19sZW4iLCJuZXdfYnVmIiwiaXNfc3BhY2UkMCIsImluZGV4X3JlYyQwIiwiaW5kZXhfcmVjX29wdCQwIiwicmluZGV4X3JlYyQwIiwicmluZGV4X3JlY19vcHQkMCIsImciLCJlcXVhbCQ5IiwiY29tcGFyZSQ5IiwidG9fc3RyaW5nJDIiLCJ0b19idWZmZXIiLCJidWZmIiwiZmxhZ3MiLCJoZWFkZXJfc2l6ZSIsImRhdGFfc2l6ZSIsInRvdGFsX3NpemUiLCJmcm9tX2J5dGVzIiwiZnJvbV9zdHJpbmciLCJpc19ibG9jayIsImRvdWJsZV9maWVsZCIsInNldF9kb3VibGVfZmllbGQiLCJtYXJzaGFsIiwib2JqIiwidW5tYXJzaGFsIiwicG9zIiwiZmlyc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yIiwibGFzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfIiwibGF6eV90YWciLCJjbG9zdXJlX3RhZyIsIm9iamVjdF90YWciLCJpbmZpeF90YWciLCJmb3J3YXJkX3RhZyIsIm5vX3NjYW5fdGFnIiwiYWJzdHJhY3RfdGFnIiwic3RyaW5nX3RhZyIsImRvdWJsZV90YWciLCJkb3VibGVfYXJyYXlfdGFnIiwiY3VzdG9tX3RhZyIsImludF90YWciLCJvdXRfb2ZfaGVhcF90YWciLCJ1bmFsaWduZWRfdGFnIiwiaW5mbyIsInN0YXJ0X2VudiIsIm9mX3ZhbCIsInNsb3QiLCJpZCIsImV4dGVuc2lvbl9jb25zdHJ1Y3RvciIsImV4dGVuc2lvbl9uYW1lIiwiZXh0ZW5zaW9uX2lkIiwibWF4X2VwaGVfbGVuZ3RoIiwiY3JlYXRlIiwibGVuZ3RoJDAiLCJyYWlzZV9pZl9pbnZhbGlkX29mZnNldCIsIm1zZyIsImdldF9rZXkiLCJnZXRfa2V5X2NvcHkiLCJzZXRfa2V5IiwidW5zZXRfa2V5IiwiY2hlY2tfa2V5IiwiYmxpdF9rZXkiLCJvMiIsInN4Iiwic3kiLCJpbml0IiwibGEiLCJsYiIsInJlcyQwIiwibGlzdF9sZW5ndGgiLCJwYXJhbSQxIiwiaGQkMCIsImlucHV0X2FycmF5IiwiZWx0Iiwib3V0cHV0X2FycmF5IiwiZWx0JDAiLCJhY2MkMiIsImIwIiwiYTAiLCJiaSIsImFpIiwibmEiLCJuYiIsIm1heHNvbiIsImkzMSIsInRyaWNrbGVkb3duIiwidHJpY2tsZSIsImJ1YmJsZWRvd24iLCJidWJibGUiLCJpJDIiLCJlJDAiLCJmYXRoZXIiLCJtZXJnZSIsInNyYzFvZnMiLCJzcmMxbGVuIiwic3JjMiIsInNyYzJvZnMiLCJzcmMybGVuIiwiZHN0b2ZzIiwic3JjMXIiLCJzcmMyciIsInMyJDEiLCJzMSQxIiwiaTEiLCJpMiIsImQiLCJpMiQwIiwiZCQwIiwiczIkMCIsImkxJDAiLCJkJDEiLCJzMSQwIiwiaXNvcnR0byIsInNyY29mcyIsInNvcnR0byIsInQiLCJ6ZXJvJDAiLCJvbmUkMCIsIm1pbnVzX29uZSQwIiwiaXNfZmluaXRlIiwiaXNfaW5maW5pdGUiLCJpc19uYW4iLCJwaSIsImlzX2ludGVnZXIiLCJzdWNjJDAiLCJwcmVkJDAiLCJlcXVhbCQxMCIsIm1pbiQyIiwibWF4JDIiLCJtaW5fbWF4IiwibWluX251bSIsIm1heF9udW0iLCJtaW5fbWF4X251bSIsImhhc2gkMCIsInVuc2FmZV9maWxsIiwiY2hlY2siLCJtYWtlJDIiLCJpbml0JDMiLCJhcHBlbmQkMiIsImNvbmNhdCQzIiwiaGxlbiIsInN1YiQyIiwiY29weSQyIiwiZmlsbCQxIiwiYmxpdCQyIiwic3JjIiwic29mcyIsImRvZnMiLCJ0b19saXN0JDIiLCJvZl9saXN0JDAiLCJoIiwiaXRlciQ2IiwiaXRlcjIkMSIsIm1hcCQ3IiwibWFwMiQxIiwiaXRlcmkkMyIsIm1hcGkkMyIsImZvbGRfbGVmdCQ0IiwiZm9sZF9yaWdodCQzIiwiZXhpc3RzJDMiLCJmb3JfYWxsJDMiLCJtZW0kMSIsIm1lbV9pZWVlIiwic29ydCQwIiwic3RhYmxlX3NvcnQiLCJ0b19zZXEkNSIsInRvX3NlcWkkMiIsIm9mX3NlcSQzIiwibWFwX3RvX2FycmF5IiwibWFwX2Zyb21fYXJyYXkiLCJ6ZXJvJDEiLCJvbmUkMSIsIm1pbnVzX29uZSQxIiwic3VjYyQxIiwicHJlZCQxIiwiYWJzJDEiLCJtaW5faW50JDEiLCJtYXhfaW50JDEiLCJsb2dub3QkMCIsInVuc2lnbmVkX3RvX2ludCIsInRvX3N0cmluZyQzIiwib2Zfc3RyaW5nX29wdCQwIiwiY29tcGFyZSQxMCIsImVxdWFsJDExIiwidW5zaWduZWRfY29tcGFyZSIsIm0iLCJtaW4kMyIsIm1heCQzIiwidW5zaWduZWRfZGl2IiwicSIsInVuc2lnbmVkX3JlbSIsInN1Y2MkMiIsInByZWQkMiIsImFicyQyIiwibG9nbm90JDEiLCJtYXhfaW50JDMiLCJ1bnNpZ25lZF90b19pbnQkMCIsInRvX3N0cmluZyQ0Iiwib2Zfc3RyaW5nX29wdCQxIiwiY29tcGFyZSQxMSIsImVxdWFsJDEyIiwidW5zaWduZWRfY29tcGFyZSQwIiwibWluJDQiLCJtYXgkNCIsInVuc2lnbmVkX2RpdiQwIiwidW5zaWduZWRfcmVtJDAiLCJ6ZXJvJDMiLCJvbmUkMyIsIm1pbnVzX29uZSQzIiwic3VjYyQzIiwicHJlZCQzIiwiYWJzJDMiLCJtaW5faW50JDMiLCJtYXhfaW50JDQiLCJsb2dub3QkMiIsInVuc2lnbmVkX3RvX2ludCQxIiwidG9fc3RyaW5nJDUiLCJvZl9zdHJpbmdfb3B0JDIiLCJjb21wYXJlJDEyIiwiZXF1YWwkMTMiLCJ1bnNpZ25lZF9jb21wYXJlJDEiLCJtaW4kNSIsIm1heCQ1IiwidW5zaWduZWRfZGl2JDEiLCJ1bnNpZ25lZF9yZW0kMSIsImVuZ2luZSIsInRibCIsInN0YXRlIiwibmV3X2VuZ2luZSIsImZyb21fZnVuY3Rpb24iLCJvcHQiLCJzdGgiLCJ3aXRoX3Bvc2l0aW9ucyIsImF1eF9idWZmZXIiLCJsZXhidWYiLCJyZWFkIiwibmV3bGVuIiwibmV3YnVmIiwiZnJvbV9jaGFubmVsIiwiZnJvbV9zdHJpbmckMCIsInNldF9wb3NpdGlvbiIsInBvc2l0aW9uIiwic2V0X2ZpbGVuYW1lIiwiZm5hbWUiLCJsZXhlbWUiLCJzdWJfbGV4ZW1lIiwic3ViX2xleGVtZV9vcHQiLCJzdWJfbGV4ZW1lX2NoYXIiLCJzdWJfbGV4ZW1lX2NoYXJfb3B0IiwibGV4ZW1lX2NoYXIiLCJsZXhlbWVfc3RhcnQiLCJsZXhlbWVfZW5kIiwibGV4ZW1lX3N0YXJ0X3AiLCJsZXhlbWVfZW5kX3AiLCJuZXdfbGluZSIsImxjcCIsImZsdXNoX2lucHV0IiwiZW52IiwiZ3Jvd19zdGFja3MiLCJvbGRzaXplIiwibmV3c2l6ZSIsIm5ld19zIiwibmV3X3YiLCJuZXdfc3RhcnQiLCJuZXdfZW5kIiwiY2xlYXJfcGFyc2VyIiwiY3VycmVudF9sb29rYWhlYWRfZnVuIiwieXlwYXJzZSIsInRhYmxlcyIsInN0YXJ0IiwibGV4ZXIiLCJpbml0X2FzcCIsImluaXRfc3AiLCJpbml0X3N0YWNrYmFzZSIsImluaXRfc3RhdGUiLCJpbml0X2N1cnJfY2hhciIsImluaXRfbHZhbCIsImluaXRfZXJyZmxhZyIsImNtZCIsImFyZyIsImFyZyQwIiwiYXJnJDEiLCJjbWQkMCIsImV4biIsImN1cnJfY2hhciIsInRvayIsInBlZWtfdmFsIiwic3ltYm9sX3N0YXJ0X3BvcyIsInN0IiwiZW4iLCJzeW1ib2xfZW5kX3BvcyIsInJoc19zdGFydF9wb3MiLCJyaHNfZW5kX3BvcyIsInN5bWJvbF9zdGFydCIsInN5bWJvbF9lbmQiLCJyaHNfc3RhcnQiLCJyaHNfZW5kIiwiaXNfY3VycmVudF9sb29rYWhlYWQiLCJwYXJzZV9lcnJvciIsImhlaWdodCIsImhsIiwiaCQwIiwiaHIiLCJiYWwiLCJsciIsImx2IiwibGwiLCJscnIiLCJscnYiLCJscmwiLCJyciIsInJ2IiwicmwiLCJybHIiLCJybHYiLCJybGwiLCJhZGQiLCJzaW5nbGV0b24iLCJhZGRfbWluX2VsZW1lbnQiLCJhZGRfbWF4X2VsZW1lbnQiLCJyaCIsImxoIiwibWluX2VsdCIsIm1pbl9lbHRfb3B0IiwibWF4X2VsdCIsIm1heF9lbHRfb3B0IiwicmVtb3ZlX21pbl9lbHQiLCJyJDAiLCJzcGxpdCIsInByZXMiLCJwcmVzJDAiLCJpc19lbXB0eSIsIm1lbSIsInJlbW92ZSIsInVuaW9uIiwicjIiLCJyMiQwIiwicjEkMCIsImludGVyIiwic3BsaXRfYmlzIiwiZGlzam9pbnQiLCJjb25zX2VudW0iLCJzJDEiLCJlJDEiLCJlMiQyIiwiZTEkMiIsImUyJDAiLCJlMSQwIiwiZTIkMSIsImUxJDEiLCJzdWJzZXQiLCJmb3JfYWxsIiwiZXhpc3RzIiwicHYiLCJwYXJ0aXRpb24iLCJsZiIsImx0IiwicmYiLCJydCIsImNhcmRpbmFsIiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJmaW5kIiwiZmluZF9maXJzdCIsImZpbmRfZmlyc3Rfb3B0IiwiZmluZF9sYXN0IiwiZmluZF9sYXN0X29wdCIsImZpbmRfb3B0IiwidHJ5X2pvaW4iLCJ2JDEiLCJvZl9saXN0Iiwic3ViIiwibCQzIiwieDAiLCJsJDQiLCJ4MCQwIiwibCQ1IiwieDAkMSIsIm5sIiwibWlkIiwibCQyIiwieDQiLCJhZGRfc2VxIiwib2Zfc2VxIiwic2VxX29mX2VudW0iLCJzbm9jX2VudW0iLCJyZXZfc2VxX29mX2VudW0iLCJ0b19yZXZfc2VxIiwidG9fc2VxX2Zyb20iLCJsb3ciLCJsZCIsImxyZCIsInJkIiwicmxkIiwiZGF0YSIsIm1pbl9iaW5kaW5nIiwibWluX2JpbmRpbmdfb3B0IiwibWF4X2JpbmRpbmciLCJtYXhfYmluZGluZ19vcHQiLCJyZW1vdmVfbWluX2JpbmRpbmciLCJ1cGRhdGUiLCJkYXRhJDAiLCJtYXBpIiwibSQwIiwiYWRkX21pbl9iaW5kaW5nIiwiayIsImFkZF9tYXhfYmluZGluZyIsImNvbmNhdF9vcl9qb2luIiwiZDEiLCJkMiIsImQyJDAiLCJkMSQwIiwiZDIkMSIsImQxJDEiLCJwdmQiLCJmdmQiLCJtJDEiLCJtMSIsIm0yIiwiYmluZGluZ3NfYXV4IiwiYmluZGluZ3MiLCJjcmVhdGUkMCIsImNsZWFyIiwiY29weSQzIiwicHVzaCIsInBvcCIsInBvcF9vcHQiLCJ0b3AiLCJ0b3Bfb3B0IiwibGVuZ3RoJDEiLCJpdGVyJDciLCJmb2xkJDIiLCJ0b19zZXEkNiIsIm9mX3NlcSQ0IiwiY3JlYXRlJDEiLCJjbGVhciQwIiwiY2VsbCIsInBlZWsiLCJjb250ZW50IiwicGVla19vcHQiLCJ0YWtlIiwidGFrZV9vcHQiLCJjb3B5JDQiLCJxX3JlcyIsInByZXYiLCJpc19lbXB0eSQwIiwibGVuZ3RoJDIiLCJpdGVyJDgiLCJmb2xkJDMiLCJ0cmFuc2ZlciIsInExIiwicTIiLCJ0b19zZXEkNyIsImFkZF9zZXEkMCIsIm9mX3NlcSQ1IiwicmFpc2VfdW5kZWZpbmVkIiwiZm9yY2VfbGF6eV9ibG9jayIsImJsayIsImNsb3N1cmUiLCJmb3JjZV92YWxfbGF6eV9ibG9jayIsImZvcmNlIiwibHp2IiwiZm9yY2VfdmFsIiwiZnJvbV9mdW4iLCJmcm9tX3ZhbCIsImlzX3ZhbCIsIm1hcCQ4IiwibWFwX3ZhbCIsImNvdW50IiwiZmlsbF9idWZmIiwiZ2V0X2RhdGEiLCJkMTEiLCJhJDAiLCJhJDEiLCJwZWVrX2RhdGEiLCJwZWVrJDAiLCJqdW5rX2RhdGEiLCJqdW5rIiwibmdldF9kYXRhIiwiYWwiLCJucGVlayIsImVtcHR5JDIiLCJpdGVyJDkiLCJzdHJtIiwiZnJvbSIsIm9mX2xpc3QkMSIsIm9mX3N0cmluZyIsIm9mX2J5dGVzJDAiLCJvZl9jaGFubmVsIiwiaWFwcCIsImljb25zIiwiaXNpbmciLCJsYXBwIiwibGNvbnMiLCJsc2luZyIsInNlbXB0eSIsInNsYXp5IiwiZHVtcF9kYXRhIiwiZHVtcCIsImNyZWF0ZSQyIiwiY29udGVudHMiLCJ0b19ieXRlcyQwIiwic3ViJDMiLCJibGl0JDMiLCJudGgkMCIsImxlbmd0aCQzIiwiY2xlYXIkMSIsInJlc2V0IiwicmVzaXplIiwibW9yZSIsIm9sZF9wb3MiLCJvbGRfbGVuIiwibmV3X2J1ZmZlciIsImFkZF9jaGFyIiwiYWRkX3V0Zl84X3VjaGFyIiwicG9zJDAiLCJwb3MkMSIsImFkZF91dGZfMTZiZV91Y2hhciIsImhpIiwibG8iLCJhZGRfdXRmXzE2bGVfdWNoYXIiLCJhZGRfc3Vic3RyaW5nIiwib2Zmc2V0IiwibmV3X3Bvc2l0aW9uIiwiYWRkX3N1YmJ5dGVzIiwiYWRkX3N0cmluZyIsImFkZF9ieXRlcyIsImFkZF9idWZmZXIiLCJicyIsImFkZF9jaGFubmVsIiwiYWxyZWFkeV9yZWFkIiwidG9fcmVhZCIsImFscmVhZHlfcmVhZCQwIiwidG9fcmVhZCQwIiwib3V0cHV0X2J1ZmZlciIsImFkZF9zdWJzdGl0dXRlIiwibGltJDEiLCJwcmV2aW91cyIsImkkNyIsImN1cnJlbnQiLCJpJDgiLCJvcGVuaW5nIiwiaSQ2IiwibGltJDAiLCJpJDMiLCJzdG9wIiwiaSQ0IiwiaSQ1IiwiayQyIiwiayQwIiwiayQxIiwibmV4dF9pIiwiaWRlbnQiLCJpJDkiLCJpJDEwIiwiaSQxMSIsInRydW5jYXRlIiwidG9fc2VxJDgiLCJ0b19zZXFpJDMiLCJhZGRfc2VxJDEiLCJvZl9zZXEkNiIsImFkZF9pbnQ4IiwiYWRkX2ludDE2X25lIiwiYWRkX2ludDMyX25lIiwiYWRkX2ludDY0X25lIiwiYWRkX2ludDE2X2xlIiwiYWRkX2ludDE2X2JlIiwiYWRkX2ludDMyX2xlIiwiYWRkX2ludDMyX2JlIiwiYWRkX2ludDY0X2xlIiwiYWRkX2ludDY0X2JlIiwiY3JlYXRlX2NoYXJfc2V0IiwiYWRkX2luX2NoYXJfc2V0Iiwic3RyX2luZCIsIm1hc2siLCJmcmVlemVfY2hhcl9zZXQiLCJyZXZfY2hhcl9zZXQiLCJjaGFyX3NldCQwIiwiaXNfaW5fY2hhcl9zZXQiLCJwYWRfb2ZfcGFkX29wdCIsInBhZF9vcHQiLCJ3aWR0aCIsInBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCIsImZtdCIsInBhZF9vcHQkMCIsInBhZF9vcHQkMSIsInBhZF9vcHQkMiIsInBhZF9vcHQkMyIsInBhZF9vcHQkNCIsInByZWNfb3B0IiwicGFkX29wdCQ1IiwibmRlYyIsInBhZF9vcHQkNiIsInBhZF9vcHQkNyIsInBhZF9vcHQkOCIsImRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIiwiYnVmZmVyX2NyZWF0ZSIsImluaXRfc2l6ZSIsImJ1ZmZlcl9jaGVja19zaXplIiwib3ZlcmhlYWQiLCJtaW5fbGVuIiwibmV3X3N0ciIsImJ1ZmZlcl9hZGRfY2hhciIsImJ1ZmZlcl9hZGRfc3RyaW5nIiwic3RyX2xlbiIsImJ1ZmZlcl9jb250ZW50cyIsImNoYXJfb2ZfaWNvbnYiLCJjaGFyX29mX2Zjb252IiwiY0YiLCJicHJpbnRfcGFkdHkiLCJwYWR0eSIsImJwcmludF9pZ25vcmVkX2ZsYWciLCJpZ25fZmxhZyIsImJwcmludF9wYWRfb3B0IiwiYnByaW50X3BhZGRpbmciLCJwYWR0eSQwIiwiYnByaW50X3ByZWNpc2lvbiIsImJwcmludF9pY29udl9mbGFnIiwiYnByaW50X2FsdGludF9mbXQiLCJicHJpbnRfZmNvbnZfZmxhZyIsInN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCIsInN0ciQwIiwiYnByaW50X2NoYXJfbGl0ZXJhbCIsImJwcmludF9zdHJpbmdfbGl0ZXJhbCIsImJwcmludF9mbXR0eSIsInN1Yl9mbXR0eSIsInN1Yl9mbXR0eSQwIiwiaW50X29mX2N1c3RvbV9hcml0eSIsInN0cmluZ19vZl9mbXQiLCJmbXRpdGVyIiwiZm10JDAiLCJpZ25fZmxhZyQwIiwiY2hyJDAiLCJzdHIkMSIsImlzX2Fsb25lJDAiLCJpc19hbG9uZSIsImFmdGVyIiwiYmVmb3JlIiwiaiQwIiwiaiQxIiwiZm10JDEiLCJzeW1tIiwidHJhbnMiLCJyZXN0MiIsInJlc3QyJDAiLCJyZXN0MiQxIiwicmVzdDIkMiIsInJlc3QyJDMiLCJyZXN0MiQ0IiwicmVzdDIkNSIsInJlc3QyJDYiLCJyZXN0MiQ3IiwidHkyJDAiLCJyZXN0MiQ4IiwidHkyMiIsInR5MjEiLCJmbXR0eV9yZWxfZGV0IiwiZjQiLCJmMiIsInJlc3QyJDkiLCJyZXN0MiQxMCIsInJlc3QyJDExIiwicmVzdDIkMTIiLCJyZXN0MiQxMyIsImRlIiwiZWQiLCJhZiIsImZhIiwiZGUkMCIsImVkJDAiLCJhZiQwIiwiZmEkMCIsImRlJDEiLCJlZCQxIiwiYWYkMSIsImZhJDEiLCJkZSQyIiwiZWQkMiIsImFmJDIiLCJmYSQyIiwiZGUkMyIsImVkJDMiLCJhZiQzIiwiZmEkMyIsImRlJDQiLCJlZCQ0IiwiYWYkNCIsImZhJDQiLCJkZSQ1IiwiZWQkNSIsImFmJDUiLCJmYSQ1IiwiZGUkNiIsImVkJDYiLCJhZiQ2IiwiZmEkNiIsImRlJDciLCJlZCQ3IiwiYWYkNyIsImZhJDciLCJkZSQ4IiwiZWQkOCIsImFmJDgiLCJmYSQ4IiwiamQiLCJkaiIsImdhIiwiYWciLCJkZSQ5IiwiZWQkOSIsImFmJDkiLCJmYSQ5IiwiZGUkMTAiLCJlZCQxMCIsImFmJDEwIiwiZmEkMTAiLCJkZSQxMSIsImVkJDExIiwiYWYkMTEiLCJmYSQxMSIsImRlJDEyIiwiZWQkMTIiLCJhZiQxMiIsImZhJDEyIiwiZGUkMTMiLCJlZCQxMyIsImFmJDEzIiwiZmEkMTMiLCJmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkiLCJmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IiwiZm10dHlfb2ZfY3VzdG9tIiwiYXJpdHkkMCIsImZtdHR5X29mX2ZtdCIsInR5X3Jlc3QiLCJwcmVjX3R5IiwidHlfcmVzdCQwIiwicHJlY190eSQwIiwidHlfcmVzdCQxIiwicHJlY190eSQxIiwidHlfcmVzdCQyIiwicHJlY190eSQyIiwidHlfcmVzdCQzIiwicHJlY190eSQzIiwiZm10dHkkMSIsImZtdHR5JDIiLCJmbXR0eSQzIiwidHkkMCIsImZtdHR5JDQiLCJmbXR0eSQ1IiwidHlwZV9wYWRkaW5nIiwidyIsInR5cGVfcGFkcHJlYyIsInR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aSIsInR5cGVfZm9ybWF0X2dlbiIsImZtdHR5X3Jlc3QiLCJzdWJfZm10dHlfcmVzdCIsInN1Yl9mbXR0eV9yZXN0JDAiLCJmbXR0eV9yZXN0JDAiLCJzdWJfZm10dHlfcmVzdCQxIiwic3ViX2ZtdHR5X3Jlc3QkMiIsImZtdHR5X3Jlc3QkMSIsInN1Yl9mbXR0eV9yZXN0JDMiLCJmbXQkMiIsInN1Yl9mbXR0eV9yZXN0JDQiLCJmbXR0eV9yZXN0JDIiLCJzdWJfZm10dHlfcmVzdCQ1IiwiZm10JDMiLCJzdWJfZm10dHlfcmVzdCQ2IiwiZm10dHlfcmVzdCQzIiwic3ViX2ZtdHR5X3Jlc3QkNyIsImZtdCQ0Iiwic3ViX2ZtdHR5X3Jlc3QkOCIsImZtdHR5X3Jlc3QkNCIsInN1Yl9mbXR0eV9yZXN0JDkiLCJmbXQkNSIsInN1Yl9mbXR0eV9yZXN0JDEwIiwiZm10dHlfcmVzdCQ1Iiwic3ViX2ZtdHR5X3Jlc3QkMTEiLCJmbXQkNiIsInN1Yl9mbXR0eV9yZXN0JDEyIiwiZm10dHlfcmVzdCQ2Iiwic3ViX2ZtdHR5X3Jlc3QkMTMiLCJmbXQkNyIsInN1Yl9mbXR0eV9yZXN0JDE0IiwiZm10dHlfcmVzdCQ3Iiwic3ViMl9mbXR0eSIsInN1Yl9mbXR0eV9yZXN0JDE1Iiwic3ViMl9mbXR0eSQwIiwiZm10JDgiLCJzdWJfZm10dHlfcmVzdCQxNiIsImZtdHR5X3Jlc3QkOCIsInN1YjJfZm10dHkkMSIsInN1YjFfZm10dHkiLCJzdWJfZm10dHlfcmVzdCQxNyIsInN1YjJfZm10dHkkMiIsInN1YjFfZm10dHkkMCIsImZtdCQ5Iiwic3ViX2ZtdHR5X3Jlc3QkMTgiLCJmbXR0eV9yZXN0JDkiLCJzdWJfZm10dHlfcmVzdCQxOSIsImZtdCQxMCIsInN1Yl9mbXR0eV9yZXN0JDIwIiwiZm10dHlfcmVzdCQxMCIsInN1Yl9mbXR0eV9yZXN0JDIxIiwiZm10JDExIiwic3ViX2ZtdHR5X3Jlc3QkMjIiLCJmbXR0eV9yZXN0JDExIiwic3ViX2ZtdHR5X3Jlc3QkMjMiLCJmbXQkMTIiLCJzdWJfZm10dHlfcmVzdCQyNCIsImZtdHR5X3Jlc3QkMTIiLCJzdWJfZm10dHlfcmVzdCQyNSIsImZtdCQxMyIsInN1Yl9mbXR0eV9yZXN0JDI2IiwiZm10X3Jlc3QiLCJmbXRfcmVzdCQwIiwiZm10X3Jlc3QkMSIsImZtdF9yZXN0JDIiLCJmbXRfcmVzdCQzIiwiZm10X3Jlc3QkNCIsImZtdF9yZXN0JDUiLCJwcmVjJDQiLCJmbXR0eSQ2IiwiZm10X3Jlc3QkNiIsInByZWMkNSIsInByZWMkNiIsImZtdHR5JDciLCJmbXRfcmVzdCQ3IiwicHJlYyQ3IiwicHJlYyQ4IiwiZm10dHkkOCIsImZtdF9yZXN0JDgiLCJmbXR0eSQ5IiwiZm10X3Jlc3QkOSIsImZtdHR5JDEwIiwiZm10X3Jlc3QkMTAiLCJmbXR0eSQxMSIsImZtdF9yZXN0JDExIiwiZm10dHkkMTIiLCJmbXRfcmVzdCQxMiIsImZtdHR5JDEzIiwic3ViX2ZtdHR5MSIsImZtdF9yZXN0JDEzIiwic3ViX2ZtdHR5JDEiLCJmbXR0eSQxNCIsImZtdCQxNCIsImZtdF9yZXN0JDE0IiwiZm10dHkkMTUiLCJmbXQkMTUiLCJmbXRfcmVzdCQxNSIsImZtdHR5JDE2IiwiZm10JDE2IiwiZm10X3Jlc3QkMTYiLCJmbXR0eSQxNyIsImZtdCQxNyIsImZtdF9yZXN0JDE3IiwiZm9ybWF0dGluZ19nZW4iLCJmbXR0eTMiLCJmbXQzIiwiZm10MSQwIiwiZm10dHkyJDAiLCJmbXQyJDAiLCJmbXR0eTMkMCIsImZtdDMkMCIsImZtdHR5X3Jlc3QkMTMiLCJmbXRfcmVzdCQxOCIsImZtdHR5JDE4IiwiZm10JDE4IiwiZm10dHlfcmVzdCQxNCIsImZtdF9yZXN0JDE5IiwiZm10dHkkMTkiLCJmbXQkMTkiLCJmbXR0eV9yZXN0JDE1IiwiZm10X3Jlc3QkMjAiLCJmbXR0eSQyMCIsImZtdCQyMCIsInR5cGVfaWdub3JlZF9wYXJhbV9vbmUiLCJmbXR0eV9yZXN0JDE2IiwiZm10dHkkMjEiLCJmbXQkMjEiLCJzdWJfZm10dHkkMiIsInN1Yl9mbXR0eSQzIiwiZm10dHkkMjIiLCJmbXQkMjIiLCJzdWJfZm10dHkkNCIsInR5cGVfZm9ybWF0IiwicmVjYXN0IiwiZml4X3BhZGRpbmciLCJ3aWR0aCQwIiwiZml4X2ludF9wcmVjaXNpb24iLCJyZXMkMSIsInN0cmluZ190b19jYW1sX3N0cmluZyIsImZvcm1hdF9vZl9mY29udiIsInN5bWIiLCJ0cmFuc2Zvcm1faW50X2FsdCIsImRpZ2l0cyIsInB1dCIsImNvbnZlcnRfaW50IiwiY29udmVydF9pbnQzMiIsImNvbnZlcnRfbmF0aXZlaW50IiwiY29udmVydF9pbnQ2NCIsImNvbnZlcnRfZmxvYXQiLCJoZXgiLCJzaWduIiwiY2FtbF9zcGVjaWFsX3ZhbCIsInN0cmluZ19vZl9mbXR0eSIsIm1ha2VfcHJpbnRmJDAiLCJuZXdfYWNjIiwibWFrZV9wcmludGYiLCJtYWtlX3BhZGRpbmciLCJtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiIsInAkMCIsInAkMSIsImFjYyQzIiwiYWNjJDQiLCJrJDMiLCJrYWNjIiwiayQ0IiwibWFrZV9pZ25vcmVkX3BhcmFtJDAiLCJtYWtlX2N1c3RvbSQwIiwibWFrZV9pbnZhbGlkX2FyZyIsIm1ha2VfZnJvbV9mbXR0eSQwIiwibWFrZV9mcm9tX2ZtdHR5IiwibWFrZV9jdXN0b20iLCJtYWtlX2lnbm9yZWRfcGFyYW0iLCJtYWtlX2lwcmludGYkMCIsIm1ha2VfaXByaW50ZiIsImZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIiwia29jIiwicmVzdCQyNCIsInJlc3QkMjUiLCJmbl9vZl9jdXN0b21fYXJpdHkkMCIsImZuX29mX2N1c3RvbV9hcml0eSIsIm91dHB1dF9hY2MiLCJwJDIiLCJwJDMiLCJwJDQiLCJidWZwdXRfYWNjIiwic3RycHV0X2FjYyIsImZhaWx3aXRoX21lc3NhZ2UiLCJvcGVuX2JveF9vZl9zdHJpbmciLCJpbnZhbGlkX2JveCIsInBhcnNlX3NwYWNlcyIsInBhcnNlX2x3b3JkIiwicGFyc2VfaW50Iiwid3N0YXJ0Iiwid2VuZCIsImJveF9uYW1lIiwibnN0YXJ0IiwibmVuZCIsImluZGVudCIsImV4cF9lbmQiLCJib3hfdHlwZSIsIm1ha2VfcGFkZGluZ19mbXRfZWJiIiwibWFrZV9wYWRwcmVjX2ZtdF9lYmIiLCJmbXRfZWJiX29mX3N0cmluZyIsImxlZ2FjeV9iZWhhdmlvciIsImZsYWciLCJsZWdhY3lfYmVoYXZpb3IkMCIsImludmFsaWRfZm9ybWF0X21lc3NhZ2UiLCJ1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQiLCJlbmRfaW5kIiwiaW52YWxpZF9mb3JtYXRfd2l0aG91dCIsImV4cGVjdGVkX2NoYXJhY3RlciIsImV4cGVjdGVkIiwiYWRkX2xpdGVyYWwiLCJsaXRfc3RhcnQiLCJzaXplIiwicGFyc2VfcG9zaXRpdmUiLCJzdHJfaW5kJDAiLCJzdHJfaW5kJDEiLCJwYXJzZV9pbnRlZ2VyIiwibmV4dF9pbmQiLCJpbmNvbXBhdGlibGVfZmxhZyIsInBjdF9pbmQiLCJvcHRpb24iLCJzdWJmbXQiLCJjb21wdXRlX2ludF9jb252IiwicGx1cyIsInNwYWNlIiwicGx1cyQwIiwic3BhY2UkMCIsInNlYXJjaF9zdWJmb3JtYXRfZW5kIiwic3ViX2VuZCIsInN0cl9pbmQkMiIsInN1Yl9lbmQkMCIsInN0cl9pbmQkMyIsInN1Yl9lbmQkMSIsInN0cl9pbmQkNCIsInN0cl9pbmQkNSIsInN1Yl9lbmQkMiIsInN0cl9pbmQkNiIsInN0cl9pbmQkNyIsInBhcnNlX21hZ2ljX3NpemUiLCJzdHJfaW5kXzEiLCJzdHJfaW5kXzIiLCJzdHJfaW5kXzMiLCJwYXJzZSIsInBhcnNlX2dvb2RfYnJlYWsiLCJmb3JtYXR0aW5nX2xpdCQwIiwic3RyX2luZF80Iiwic3RyX2luZF81IiwicGFyc2VfdGFnIiwiaXNfb3Blbl90YWciLCJpbmQiLCJzdWJfc3RyIiwic3ViX2ZtdCIsInN1Yl9mb3JtYXQkMCIsImZvcm1hdHRpbmckMCIsImZvcm1hdHRpbmciLCJwYXJzZV9mbGFncyIsIm1pbnVzIiwic2V0X2ZsYWciLCJuZXdfaW5kIiwicGFyc2VfYWZ0ZXJfcGFkZGluZyIsInBhcnNlX2xpdGVyYWwiLCJwYXJzZV9hZnRlcl9wcmVjaXNpb24iLCJzeW1iJDAiLCJtaW51cyQwIiwicGFyc2VfY29udmVyc2lvbiIsInBhcnNlX2NvbnYiLCJwYWRwcmVjIiwicGx1c191c2VkIiwiaGFzaF91c2VkIiwic3BhY2VfdXNlZCIsImlnbl91c2VkIiwicGFkX3VzZWQiLCJwcmVjX3VzZWQiLCJnZXRfcGx1cyIsImdldF9oYXNoIiwiZ2V0X3NwYWNlIiwiZ2V0X2lnbiIsImdldF9wYWQiLCJnZXRfcHJlYyIsImdldF9wYWRwcmVjIiwiZ2V0X2ludF9wYWQiLCJjaGVja19ub18wIiwib3B0X29mX3BhZCIsIndpZHRoJDEiLCJnZXRfcGFkX29wdCIsImdldF9wYWRwcmVjX29wdCIsImZtdF9yZXN1bHQiLCJpZ25vcmVkJDIiLCJjb3VudGVyJDAiLCJpZ25vcmVkJDYiLCJpZ25vcmVkJDciLCJhZGRfcmFuZ2UiLCJmYWlsX3NpbmdsZV9wZXJjZW50IiwicGFyc2VfY2hhcl9zZXRfY29udGVudCIsInBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIkMCIsInBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIiLCJyZXZlcnNlIiwiY2hhcl9zZXQkMSIsImlnbm9yZWQkOSIsImNoYXJfZm9ybWF0IiwiZm10X3Jlc3QkMjEiLCJmbXRfcmVzdCQyMiIsInBhZCQ5IiwiZm10X3Jlc3QkMjMiLCJpZ25vcmVkJDEwIiwiZm10X3Jlc3QkMjQiLCJwYWQkMTAiLCJmbXRfcmVzdCQyNSIsInN1Yl9mbXQkMCIsImZtdF9yZXN0JDI2IiwiaWdub3JlZCQxMSIsImlnbm9yZWQkMyIsImlnbm9yZWQkNSIsImlnbm9yZWQkOCIsInNwYWNlJDEiLCJoYXNoJDEiLCJwbHVzJDIiLCJraW5kIiwiaWdub3JlZCQ0IiwiaWdub3JlZCIsImlnbm9yZWQkMCIsImlnbm9yZWQkMSIsInBsdXMkMSIsImlnbiQwIiwiZm9ybWF0X29mX3N0cmluZ19mbXR0eSIsImZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0Iiwia2ZwcmludGYiLCJrYnByaW50ZiIsImlrZnByaW50ZiIsImZwcmludGYiLCJicHJpbnRmIiwiaWZwcmludGYiLCJpYnByaW50ZiIsInByaW50ZiIsImVwcmludGYiLCJrc3ByaW50ZiIsInNwcmludGYiLCJhc3NvYzMiLCJ5MiIsInkxIiwic3BsaXQkMSIsIm1ha2Vfc3ltbGlzdCIsImhlbHBfYWN0aW9uIiwiYWRkX2hlbHAiLCJzcGVjbGlzdCIsImFkZDIiLCJ1c2FnZV9iIiwiZXJybXNnIiwiZG9jIiwic3BlYyIsImtleSIsInVzYWdlX3N0cmluZyIsInVzYWdlIiwiYm9vbF9vZl9zdHJpbmdfb3B0JDAiLCJpbnRfb2Zfc3RyaW5nX29wdCQwIiwiZmxvYXRfb2Zfc3RyaW5nX29wdCIsInBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXyIsImFsbG93X2V4cGFuZCIsImFyZ3YiLCJhbm9uZnVuIiwiaW5pdHBvcyIsImNvbnZlcnRfZXJyb3IiLCJwcm9nbmFtZSIsImZvbGxvdyQwIiwiYWN0aW9uIiwia2V5d29yZCIsIm5vX2FyZyQwIiwiZm9sbG93Iiwibm9fYXJnIiwiZ2V0X2FyZyQwIiwiZ2V0X2FyZyIsImNvbnN1bWVfYXJnJDAiLCJjb25zdW1lX2FyZyIsInRyZWF0X2FjdGlvbiQwIiwidHJlYXRfYWN0aW9uIiwiZiQwIiwiZiQxIiwiciQxIiwiZiQyIiwiciQyIiwiYXJnJDIiLCJmJDMiLCJhcmckMyIsIngkMSIsInIkMyIsImFyZyQ0IiwieCQyIiwic3BlY3MiLCJmJDQiLCJhcmckNSIsImYkNSIsImYkNiIsImYkNyIsImFyZyQ2IiwibmV3YXJnIiwicGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMiLCJwYXJzZV9hcmd2X2R5bmFtaWMiLCJjdXJyZW50JDAiLCJwYXJzZV9hcmd2IiwibXNnJDAiLCJtc2ckMSIsInBhcnNlX2R5bmFtaWMiLCJwYXJzZV9leHBhbmQiLCJzZWNvbmRfd29yZCIsImxvb3AiLCJtYXhfYXJnX2xlbiIsImt3ZCIsInJlcGxhY2VfbGVhZGluZ190YWIiLCJhbGlnbiIsImxpbWl0IiwiY29tcGxldGVkIiwia3NkIiwiY3V0Y29sJDAiLCJzcGFjZXMkMCIsImN1dGNvbCIsImt3ZF9sZW4iLCJzcGFjZXMiLCJyZWFkX2F1eCIsInRyaW0iLCJmaWxlIiwid29yZHMiLCJzdGFzaCIsIndvcmQiLCJyZWFkX2FyZyIsInJlYWRfYXJnMCIsIndyaXRlX2F1eCIsImFyZ3MiLCJ3cml0ZV9hcmciLCJ3cml0ZV9hcmcwIiwicHJpbnRlcnMiLCJmaWVsZCIsIm90aGVyX2ZpZWxkcyIsInVzZV9wcmludGVycyIsImNvbnYiLCJ0b19zdHJpbmdfZGVmYXVsdCIsImNoYXIkMCIsImxpbmUiLCJjaGFyJDEiLCJsaW5lJDAiLCJmaWxlJDAiLCJjaGFyJDIiLCJsaW5lJDEiLCJmaWxlJDEiLCJjb25zdHJ1Y3RvciIsInRvX3N0cmluZyQ2IiwicHJpbnQiLCJmY3QiLCJjYXRjaCQwIiwicmF3X2JhY2t0cmFjZV9lbnRyaWVzIiwiYnQiLCJjb252ZXJ0X3Jhd19iYWNrdHJhY2UiLCJmb3JtYXRfYmFja3RyYWNlX3Nsb3QiLCJpc19yYWlzZSIsInByaW50X3Jhd19iYWNrdHJhY2UiLCJvdXRjaGFuIiwicmF3X2JhY2t0cmFjZSIsImJhY2t0cmFjZSIsInByaW50X2JhY2t0cmFjZSIsInJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIiwiYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2UiLCJiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmUiLCJiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvbiIsImJhY2t0cmFjZV9zbG90X2RlZm5hbWUiLCJiYWNrdHJhY2Vfc2xvdHMiLCJiYWNrdHJhY2Vfc2xvdHNfb2ZfcmF3X2VudHJ5IiwiZW50cnkiLCJyYXdfYmFja3RyYWNlX2xlbmd0aCIsImdldF9iYWNrdHJhY2UiLCJyZWdpc3Rlcl9wcmludGVyIiwiZm4iLCJvbGRfcHJpbnRlcnMiLCJuZXdfcHJpbnRlcnMiLCJleG5fc2xvdCIsImV4bl9zbG90X2lkIiwiZXhuX3Nsb3RfbmFtZSIsImVycm9ycyIsImRlZmF1bHRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbiIsInN0YXR1cyIsInVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIiwic2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIiwiZW1wdHlfYmFja3RyYWNlIiwiaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbiIsImRlYnVnZ2VyX2luX3VzZSIsImV4biQwIiwicmF3X2JhY2t0cmFjZSQwIiwiY29uc3QkMCIsImZsaXAiLCJuZWdhdGUiLCJwcm90ZWN0IiwiZmluYWxseSQwIiwid29yayIsImZpbmFsbHlfbm9fZXhuIiwid29ya19leG4iLCJ3b3JrX2J0IiwicHJpbnRfc3RhdCIsImFsbG9jYXRlZF9ieXRlcyIsIm1hIiwicHJvIiwibWkiLCJjcmVhdGVfYWxhcm0iLCJkZWxldGVfYWxhcm0iLCJudWxsX3RyYWNrZXIiLCJzYW1wbGluZ19yYXRlIiwidHJhY2tlciIsImNhbGxzdGFja19zaXplIiwic3RyaW5nIiwiYnl0ZXMiLCJzdWJzdHJpbmciLCJzdWJieXRlcyIsImZpbGVuYW1lIiwib3V0cHV0JDAiLCJkaWdlc3QiLCJpbnB1dCQwIiwiY2hhcl9oZXgiLCJ0b19oZXgiLCJmcm9tX2hleCIsImRpZ2l0IiwibmV3X3N0YXRlIiwiYXNzaWduIiwic3QxIiwic3QyIiwiZnVsbF9pbml0Iiwic2VlZCIsInNlZWQkMCIsIm1ha2UkMyIsIm1ha2Vfc2VsZl9pbml0IiwiY29weSQ1IiwiYml0cyIsImN1cnZhbCIsIm5ld3ZhbCIsIm5ld3ZhbDMwIiwiaW50YXV4IiwiaW50JDAiLCJib3VuZCIsImZ1bGxfaW50IiwiYjEiLCJiMiIsImJwb3MiLCJiMyIsImJwb3MkMCIsImludDMyIiwiaW50NjQiLCJuYXRpdmVpbnQiLCJmbG9hdCQwIiwiYm9vbCIsImJpdHMkMCIsImludCQxIiwiZnVsbF9pbnQkMCIsImludDMyJDAiLCJuYXRpdmVpbnQkMCIsImludDY0JDAiLCJmbG9hdCQxIiwic2NhbGUiLCJib29sJDAiLCJmdWxsX2luaXQkMCIsImluaXQkNCIsInNlbGZfaW5pdCIsImdldF9zdGF0ZSIsInNldF9zdGF0ZSIsIm9uZ29pbmdfdHJhdmVyc2FsIiwiZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCIsInBhcmFtcyIsInJhbmRvbWl6ZWRfZGVmYXVsdCIsInJhbmRvbWl6ZWQiLCJyYW5kb21pemUiLCJpc19yYW5kb21pemVkIiwicHJuZyIsInBvd2VyXzJfYWJvdmUiLCJjcmVhdGUkMyIsImluaXRpYWxfc2l6ZSIsInJhbmRvbSIsImNsZWFyJDIiLCJyZXNldCQwIiwiY29weV9idWNrZXRsaXN0Iiwia2V5JDAiLCJuZXh0JDAiLCJjb3B5JDYiLCJsZW5ndGgkNCIsImluc2VydF9hbGxfYnVja2V0cyIsImluZGV4ZnVuIiwiaW5wbGFjZSIsIm9kYXRhIiwibmRhdGEiLCJuc2l6ZSIsIm5kYXRhX3RhaWwiLCJjZWxsJDAiLCJuaWR4IiwibWF0Y2giLCJtYXRjaCQwIiwicmVzaXplJDAiLCJvc2l6ZSIsIml0ZXIkMTAiLCJkb19idWNrZXQiLCJvbGRfdHJhdiIsImZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQiLCJmaWx0ZXJfbWFwX2lucGxhY2UiLCJmb2xkJDQiLCJiJDAiLCJidWNrZXRfbGVuZ3RoIiwic3RhdHMiLCJtYmwiLCJoaXN0byIsInRvX3NlcSQ5IiwidGJsX2RhdGEiLCJidWNrIiwiYnVjayQwIiwiYnVjayQxIiwidG9fc2VxX2tleXMiLCJ0b19zZXFfdmFsdWVzIiwia2V5X2luZGV4IiwiYnVja2V0IiwiazEiLCJuZXh0MSIsImsyIiwibmV4dDIiLCJrMyIsImQzIiwibmV4dDMiLCJmaW5kX2FsbCIsImZpbmRfaW5fYnVja2V0IiwicmVwbGFjZSIsInJlcGxhY2Vfc2VxIiwiY29weSIsInN6IiwiaGFzaF9wYXJhbSIsInNlZWRlZF9oYXNoIiwiYWRkJDAiLCJmaW5kJDAiLCJmaW5kX29wdCQxIiwiZmluZF9hbGwkMCIsIm1lbSQyIiwiYWRkX3NlcSQyIiwib2Zfc2VxJDciLCJyZWJ1aWxkIiwid2Vha19jcmVhdGUiLCJsZW5ndGgkNSIsInJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0JDAiLCJzZXQkMCIsImdldCQxIiwiZ2V0X2NvcHkiLCJjaGVjayQwIiwiYmxpdCQ0IiwiZmlsbCQyIiwiYXIiLCJlbXB0eWJ1Y2tldCIsImdldF9pbmRleCIsInN6JDAiLCJzeiQxIiwiY291bnRfYnVja2V0IiwiYWRkX2F1eCIsInNldHRlciIsImluZGV4IiwiYnVja2V0JDAiLCJoYXNoZXMiLCJuZXdzeiIsIm5ld2J1Y2tldCQwIiwibmV3aGFzaGVzIiwiaGJ1Y2tldCIsInByZXZfbGVuIiwibGl2ZSIsImokMiIsIm5ld2J1Y2tldCIsIm5ld3QiLCJvYiIsIm9oIiwic2V0dGVyJDAiLCJuaSIsImZpbmRfb3IiLCJpZm5vdGZvdW5kIiwiZmluZF9zaGFkb3ciLCJpZmZvdW5kIiwibGVucyIsInRvdGxlbiIsImlkJDAiLCJ1bmtub3duIiwicHBfZW5xdWV1ZSIsInRva2VuIiwicHBfaW5maW5pdHkiLCJwcF9vdXRwdXRfc3RyaW5nIiwicHBfb3V0cHV0X25ld2xpbmUiLCJmb3JtYXRfcHBfdGV4dCIsInRleHQiLCJmb3JtYXRfc3RyaW5nIiwiYnJlYWtfbmV3X2xpbmUiLCJyZWFsX2luZGVudCIsImJyZWFrX2xpbmUiLCJicmVha19zYW1lX2xpbmUiLCJmb3JtYXRfcHBfdG9rZW4iLCJzaXplJDAiLCJ0YWJzIiwiYWRkX3RhYiIsImxzIiwidGFnX25hbWUiLCJtYXJrZXIiLCJicmVha3MiLCJmaXRzIiwib2ZmIiwiYm94X3R5cGUkMCIsIm9mZiQwIiwiaW5zZXJ0aW9uX3BvaW50IiwidGFicyQwIiwiZmlyc3QiLCJoZWFkIiwidGFiIiwib2ZmJDEiLCJpbnNlcnRpb25fcG9pbnQkMCIsIndpZHRoJDIiLCJib3hfdHlwZSQxIiwidGJveCIsInRhZ19uYW1lJDAiLCJtYXJrZXIkMCIsImFkdmFuY2VfbGVmdCIsInBlbmRpbmdfY291bnQiLCJlbnF1ZXVlX2FkdmFuY2UiLCJlbnF1ZXVlX3N0cmluZ19hcyIsImluaXRpYWxpemVfc2Nhbl9zdGFjayIsInN0YWNrIiwicXVldWVfZWxlbSIsInNldF9zaXplIiwibGVmdF90b3RhbCIsInNjYW5fcHVzaCIsImVsZW0iLCJwcF9vcGVuX2JveF9nZW4iLCJicl90eSIsInBwX2Nsb3NlX2JveCIsInBwX29wZW5fc3RhZyIsInBwX2Nsb3NlX3N0YWciLCJwcF9vcGVuX3RhZyIsInBwX2Nsb3NlX3RhZyIsInBwX3NldF9wcmludF90YWdzIiwicHBfc2V0X21hcmtfdGFncyIsInBwX2dldF9wcmludF90YWdzIiwicHBfZ2V0X21hcmtfdGFncyIsInBwX3NldF90YWdzIiwicHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9uIiwicHBfc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9uIiwicGN0IiwicG90IiwibWN0IiwibW90IiwicHBfcmluaXQiLCJwcF9mbHVzaF9xdWV1ZSIsInBwX3ByaW50X2FzX3NpemUiLCJwcF9wcmludF9hcyIsImlzaXplIiwicHBfcHJpbnRfc3RyaW5nIiwicHBfcHJpbnRfYnl0ZXMiLCJwcF9wcmludF9pbnQiLCJwcF9wcmludF9mbG9hdCIsInBwX3ByaW50X2Jvb2wiLCJwcF9wcmludF9jaGFyIiwicHBfb3Blbl9oYm94IiwicHBfb3Blbl92Ym94IiwicHBfb3Blbl9odmJveCIsInBwX29wZW5faG92Ym94IiwicHBfb3Blbl9ib3giLCJwcF9wcmludF9uZXdsaW5lIiwicHBfcHJpbnRfZmx1c2giLCJwcF9mb3JjZV9uZXdsaW5lIiwicHBfcHJpbnRfaWZfbmV3bGluZSIsInBwX3ByaW50X2N1c3RvbV9icmVhayIsInBwX3ByaW50X2JyZWFrIiwicHBfcHJpbnRfc3BhY2UiLCJwcF9wcmludF9jdXQiLCJwcF9vcGVuX3Rib3giLCJwcF9jbG9zZV90Ym94IiwicHBfcHJpbnRfdGJyZWFrIiwicHBfcHJpbnRfdGFiIiwicHBfc2V0X3RhYiIsInBwX3NldF9tYXhfYm94ZXMiLCJwcF9nZXRfbWF4X2JveGVzIiwicHBfb3Zlcl9tYXhfYm94ZXMiLCJwcF9zZXRfZWxsaXBzaXNfdGV4dCIsInBwX2dldF9lbGxpcHNpc190ZXh0IiwicHBfbGltaXQiLCJwcF9zZXRfbWF4X2luZGVudCIsInBwX2dldF9tYXhfaW5kZW50IiwicHBfc2V0X21hcmdpbiIsIm5ld19tYXhfaW5kZW50IiwidmFsaWRhdGVfZ2VvbWV0cnkiLCJtYXJnaW4iLCJtYXhfaW5kZW50IiwiY2hlY2tfZ2VvbWV0cnkiLCJnZW9tZXRyeSIsInBwX2dldF9tYXJnaW4iLCJwcF9zZXRfZnVsbF9nZW9tZXRyeSIsInBwX3NldF9nZW9tZXRyeSIsInBwX3NhZmVfc2V0X2dlb21ldHJ5IiwicHBfZ2V0X2dlb21ldHJ5IiwicHBfdXBkYXRlX2dlb21ldHJ5IiwicHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwicHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwicHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3RpIiwicHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3RpIiwiZGlzcGxheV9uZXdsaW5lIiwiYmxhbmtfbGluZSIsImRpc3BsYXlfaW5kZW50IiwicHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCIsImRlZmF1bHRfcHBfbWFya19vcGVuX3RhZyIsImRlZmF1bHRfcHBfbWFya19jbG9zZV90YWciLCJkZWZhdWx0X3BwX3ByaW50X29wZW5fdGFnIiwiZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWciLCJwcF9tYWtlX2Zvcm1hdHRlciIsInBwX3F1ZXVlIiwic3lzX3RvayIsInNjYW5fc3RhY2siLCJmb3JtYXR0ZXJfb2Zfb3V0X2Z1bmN0aW9ucyIsIm91dF9mdW5zIiwibWFrZV9mb3JtYXR0ZXIiLCJwcGYiLCJmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwiLCJmb3JtYXR0ZXJfb2ZfYnVmZmVyIiwicHBfYnVmZmVyX3NpemUiLCJwcF9tYWtlX2J1ZmZlciIsInN0ZGJ1ZiIsInN0ZF9mb3JtYXR0ZXIiLCJlcnJfZm9ybWF0dGVyIiwic3RyX2Zvcm1hdHRlciIsImZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIiLCJmbHVzaF9zdHJfZm9ybWF0dGVyIiwibWFrZV9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsInNvYiIsImdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsIml0ZW1zIiwiYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIiwiaXRlbSIsImZvcm1hdHRlcl9vZl9zeW1ib2xpY19vdXRwdXRfYiIsIm9wZW5faGJveCIsIm9wZW5fdmJveCIsIm9wZW5faHZib3giLCJvcGVuX2hvdmJveCIsIm9wZW5fYm94IiwiY2xvc2VfYm94Iiwib3Blbl90YWciLCJjbG9zZV90YWciLCJvcGVuX3N0YWciLCJjbG9zZV9zdGFnIiwicHJpbnRfYXMiLCJwcmludF9zdHJpbmckMCIsInByaW50X2J5dGVzJDAiLCJwcmludF9pbnQkMCIsInByaW50X2Zsb2F0JDAiLCJwcmludF9jaGFyJDAiLCJwcmludF9ib29sIiwicHJpbnRfYnJlYWsiLCJwcmludF9jdXQiLCJwcmludF9zcGFjZSIsImZvcmNlX25ld2xpbmUiLCJwcmludF9mbHVzaCIsInByaW50X25ld2xpbmUkMCIsInByaW50X2lmX25ld2xpbmUiLCJvcGVuX3Rib3giLCJjbG9zZV90Ym94IiwicHJpbnRfdGJyZWFrIiwic2V0X3RhYiIsInByaW50X3RhYiIsInNldF9tYXJnaW4iLCJnZXRfbWFyZ2luIiwic2V0X21heF9pbmRlbnQiLCJnZXRfbWF4X2luZGVudCIsInNldF9nZW9tZXRyeSIsInNhZmVfc2V0X2dlb21ldHJ5IiwiZ2V0X2dlb21ldHJ5IiwidXBkYXRlX2dlb21ldHJ5Iiwic2V0X21heF9ib3hlcyIsImdldF9tYXhfYm94ZXMiLCJvdmVyX21heF9ib3hlcyIsInNldF9lbGxpcHNpc190ZXh0IiwiZ2V0X2VsbGlwc2lzX3RleHQiLCJzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwic2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMiLCJzZXRfcHJpbnRfdGFncyIsImdldF9wcmludF90YWdzIiwic2V0X21hcmtfdGFncyIsImdldF9tYXJrX3RhZ3MiLCJzZXRfdGFncyIsInBwX3ByaW50X2xpc3QiLCJwcF92Iiwib3B0JDAiLCJwcF9zZXAiLCJ2cyIsIm9wdCQxIiwicHBfcHJpbnRfc2VxIiwic2VxJDEiLCJzZXEkMiIsInBwX3ByaW50X3RleHQiLCJwcF9wcmludF9vcHRpb24iLCJwcF9wcmludF9yZXN1bHQiLCJwcF9wcmludF9laXRoZXIiLCJjb21wdXRlX3RhZyIsInRhZ19hY2MiLCJvdXRwdXRfZm9ybWF0dGluZ19saXQiLCJvdXRwdXRfYWNjJDAiLCJidHkiLCJwJDUiLCJwJDYiLCJzdHJwdXRfYWNjJDAiLCJzaXplJDEiLCJrZnByaW50ZiQwIiwiaWtmcHJpbnRmJDAiLCJpZnByaW50ZiQwIiwiZnByaW50ZiQwIiwicHJpbnRmJDAiLCJlcHJpbnRmJDAiLCJrZHByaW50ZiIsImRwcmludGYiLCJrcHJpbnRmIiwic3ByaW50ZiQwIiwia2FzcHJpbnRmIiwiYXNwcmludGYiLCJmbHVzaF9zdGFuZGFyZF9mb3JtYXR0ZXJzIiwicHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1IiwicHBfZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1Iiwic2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0IiwiZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0IiwiYnByaW50ZiQwIiwicHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwic3RyaW5naWZ5IiwicHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwiZnVucyIsIm1hcmtfb3Blbl90YWciLCJtYXJrX2Nsb3NlX3RhZyIsInByaW50X29wZW5fdGFnIiwicHJpbnRfY2xvc2VfdGFnIiwic2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwibnVsbF9jaGFyIiwibmV4dF9jaGFyIiwiaWIiLCJwZWVrX2NoYXIiLCJjaGVja2VkX3BlZWtfY2hhciIsImVuZF9vZl9pbnB1dCIsImJlZ2lubmluZ19vZl9pbnB1dCIsIm5hbWVfb2ZfaW5wdXQiLCJjaGFyX2NvdW50IiwicmVzZXRfdG9rZW4iLCJpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciIsInRva2VuX3N0cmluZyIsInRva2VuX2J1ZmZlciIsInNraXBfY2hhciIsImlnbm9yZV9jaGFyIiwic3RvcmVfY2hhciIsImRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemUiLCJjcmVhdGUkNCIsImluYW1lIiwiZnJvbV9zdHJpbmckMSIsImZyb21fZnVuY3Rpb24kMCIsInNjYW5fY2xvc2VfYXRfZW5kIiwic2Nhbl9yYWlzZV9hdF9lbmQiLCJmcm9tX2ljIiwic2Nhbl9jbG9zZV9pYyIsImVvZiIsInN0ZGliIiwib3Blbl9pbl9maWxlIiwiZnJvbV9maWxlIiwiZnJvbV9maWxlX2JpbiIsImZyb21fY2hhbm5lbCQwIiwiY2xvc2VfaW4kMCIsImljJDAiLCJtZW1vIiwibWVtb19mcm9tX2ljIiwibWVtb19mcm9tX2NoYW5uZWwiLCJiYWRfaW5wdXQiLCJiYWRfaW5wdXRfZXNjYXBlIiwiYmFkX3Rva2VuX2xlbmd0aCIsIm1lc3NhZ2UiLCJiYWRfZmxvYXQiLCJiYWRfaGV4X2Zsb2F0IiwiY2hhcmFjdGVyX21pc21hdGNoIiwiY2kiLCJjaGVja190aGlzX2NoYXIiLCJjaGVja19jaGFyIiwidG9rZW5fY2hhciIsInRva2VuX2Jvb2wiLCJpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciIsInRva2VuX2ludF9saXRlcmFsIiwidG9rZW5fZmxvYXQiLCJzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciIsInNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQiLCJzY2FuX2RpZ2l0X3BsdXMiLCJiYXNpcyIsImRpZ2l0cCIsIndpZHRoJDMiLCJpc19iaW5hcnlfZGlnaXQiLCJzY2FuX2JpbmFyeV9pbnQiLCJpc19vY3RhbF9kaWdpdCIsInNjYW5fb2N0YWxfaW50IiwiaXNfaGV4YV9kaWdpdCIsInNjYW5faGV4YWRlY2ltYWxfaW50Iiwic2Nhbl9zaWduIiwic2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsIiwic2Nhbl9pbnRfY29udmVyc2lvbiIsInNjYW5fZnJhY3Rpb25hbF9wYXJ0Iiwic2Nhbl9leHBvbmVudF9wYXJ0Iiwic2Nhbl9mbG9hdCIsInByZWNpc2lvbiIsInByZWNpc2lvbiQwIiwiY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmciLCJzY2FuX2hleF9mbG9hdCIsIndpZHRoJDQiLCJ3aWR0aCQ1Iiwid2lkdGgkNiIsIndpZHRoJDEwIiwid2lkdGgkNyIsIndpZHRoJDgiLCJ3aWR0aCQ5Iiwic2Nhbl9jYW1sX2Zsb2F0X3Jlc3QiLCJ3aWR0aF9wcmVjaXNpb24iLCJmcmFjX3dpZHRoIiwic2Nhbl9jYW1sX2Zsb2F0Iiwic2Nhbl9zdHJpbmciLCJzdHAiLCJzY2FuX2NoYXIiLCJoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIiwiY2hlY2tfbmV4dF9jaGFyIiwiY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIiwiY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmciLCJzY2FuX2JhY2tzbGFzaF9jaGFyIiwiYzAiLCJnZXRfZGlnaXQiLCJnZXRfZGlnaXQkMCIsImMxJDAiLCJjMiQwIiwic2Nhbl9jYW1sX2NoYXIiLCJmaW5kX3N0b3AiLCJzY2FuX2NhbWxfc3RyaW5nIiwiZmluZF9zdG9wJDAiLCJza2lwX3NwYWNlcyIsInNjYW5fY2hhcnNfaW5fY2hhcl9zZXQiLCJzY2FuX2luZGljIiwic2Nhbl9jaGFycyIsInNjYW5mX2JhZF9pbnB1dCIsImdldF9jb3VudGVyIiwid2lkdGhfb2ZfcGFkX29wdCIsInN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQiLCJmbXRpbmciLCJ0YWtlX2Zvcm1hdF9yZWFkZXJzJDAiLCJ0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzJDAiLCJyZWFkZXIiLCJuZXdfayIsInJlYWRlcnNfcmVzdCIsInRha2VfZm9ybWF0X3JlYWRlcnMiLCJmbXQkMjMiLCJmbXQkMjQiLCJmbXQkMjUiLCJ0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIiwibWFrZV9zY2FuZiIsInJlYWRlcnMiLCJzY2FuJDAiLCJzdHJfcmVzdCIsInBhZF9wcmVjX3NjYW5mIiwic2NhbiQxIiwic2NhbiQyIiwic2NhbiIsInNjYW4kMyIsInNjYW4kNCIsImNvbnYkMCIsInNjYW4kNSIsImNvbnYkMSIsInNjYW4kNiIsImNvbnYkMiIsInNjYW4kNyIsInNjYW4kOCIsImZtdGluZ19saXQkMCIsInN0cCQwIiwicyQyIiwic3RyX3Jlc3QkMCIsInJlc3QkMjYiLCJhcmdfcmVzdCIsImtzY2FuZiIsImVmIiwiYXBwbHkiLCJhcmdzJDAiLCJleGMiLCJic2NhbmYiLCJrc3NjYW5mIiwic3NjYW5mIiwic2NhbmYiLCJic2NhbmZfZm9ybWF0IiwiZm9ybWF0Iiwic3NjYW5mX2Zvcm1hdCIsImZvcm1hdF9mcm9tX3N0cmluZyIsInVuZXNjYXBlZCIsImtmc2NhbmYiLCJmc2NhbmYiLCJyZWdpc3RlciIsInJlZ2lzdGVyX2V4Y2VwdGlvbiIsIm8kMCIsInBhcmFtcyQwIiwiaW5pdGlhbF9vYmplY3Rfc2l6ZSIsImR1bW15X2l0ZW0iLCJ0YWciLCJjb21wYXJlJDEzIiwiY29tcGFyZSQxNCIsImNvbXBhcmUkMTUiLCJkdW1teV90YWJsZSIsInRhYmxlX2NvdW50IiwiZHVtbXlfbWV0IiwiZml0X3NpemUiLCJuZXdfdGFibGUiLCJwdWJfbGFiZWxzIiwibWV0aG9kcyIsInJlc2l6ZSQxIiwiYXJyYXkiLCJuZXdfc2l6ZSIsIm9sZF9zaXplIiwibmV3X2J1Y2siLCJtZXRob2RfY291bnQiLCJpbnN0X3Zhcl9jb3VudCIsIm5ld19tZXRob2QiLCJ0YWJsZSIsImdldF9tZXRob2RfbGFiZWwiLCJsYWJlbCIsImdldF9tZXRob2RfbGFiZWxzIiwibmFtZXMiLCJzZXRfbWV0aG9kIiwiZWxlbWVudCIsImdldF9tZXRob2QiLCJ0b19saXN0JDMiLCJhcnIiLCJuYXJyb3ciLCJ2YXJzIiwidmlydF9tZXRocyIsImNvbmNyX21ldGhzIiwidmFycyQwIiwidmlydF9tZXRocyQwIiwiY29uY3JfbWV0aHMkMCIsInZpcnRfbWV0aF9sYWJzIiwiY29uY3JfbWV0aF9sYWJzIiwibGFiIiwidHZhcnMiLCJieV9uYW1lIiwiYnlfbGFiZWwiLCJtZXQiLCJobSIsIndpZGVuIiwic2F2ZWRfdmFycyIsInNhdmVkX2hpZGRlbl9tZXRocyIsIm5ld19zbG90IiwibmV3X3ZhcmlhYmxlIiwidG9fYXJyYXkiLCJuZXdfbWV0aG9kc192YXJpYWJsZXMiLCJtZXRocyIsInZhbHMiLCJtZXRocyQwIiwibm1ldGhzIiwibnZhbHMiLCJnZXRfdmFyaWFibGUiLCJnZXRfdmFyaWFibGVzIiwiYWRkX2luaXRpYWxpemVyIiwiY3JlYXRlX3RhYmxlIiwicHVibGljX21ldGhvZHMiLCJ0YWdzIiwiaW5pdF9jbGFzcyIsImluaGVyaXRzIiwiY2xhIiwic3VwZXIkMCIsIm5tIiwibWFrZV9jbGFzcyIsInB1Yl9tZXRocyIsImNsYXNzX2luaXQiLCJlbnZfaW5pdCIsIm1ha2VfY2xhc3Nfc3RvcmUiLCJpbml0X3RhYmxlIiwiZHVtbXlfY2xhc3MiLCJsb2MiLCJ1bmRlZiIsImNyZWF0ZV9vYmplY3QiLCJjcmVhdGVfb2JqZWN0X29wdCIsIm9ial8wIiwiaXRlcl9mIiwicnVuX2luaXRpYWxpemVycyIsImluaXRzIiwicnVuX2luaXRpYWxpemVyc19vcHQiLCJjcmVhdGVfb2JqZWN0X2FuZF9ydW5faW5pdGlhbGkiLCJnZXRfZGF0YSQwIiwiYnVpbGRfcGF0aCIsImtleXMiLCJsb29rdXBfdGFibGVzIiwicm9vdCIsInRhYmxlcyQyIiwidGFibGVzJDAiLCJ0YWJsZXMkMSIsIm5ld19jYWNoZSIsInNldF9tZXRob2RzIiwiY2xvIiwiY2xvJDAiLCJuJDIiLCJuJDMiLCJuJDQiLCJuJDUiLCJuJDYiLCJ4JDMiLCJuJDciLCJ4JDQiLCJuJDgiLCJuJDkiLCJ4JDUiLCJmJDgiLCJlJDIiLCJuJDEwIiwieCQ2IiwiZiQ5IiwibiQxMSIsIngkNyIsIm4kMTIiLCJ4JDgiLCJuJDEzIiwibiQxNCIsImUkMyIsIm4kMTUiLCJtJDIiLCJ4JDkiLCJtJDMiLCJuJDE2IiwibSQ0IiwiZSQ0IiwibiQxNyIsIm0kNSIsIm4kMTgiLCJzdGF0cyQwIiwiaW5pdF9tb2RfYmxvY2siLCJjb21wcyQwIiwibW9kdSIsInNoYXBlIiwiZm4kMCIsImNvbXBzIiwiaW5pdF9tb2QiLCJ1cGRhdGVfbW9kX2Jsb2NrIiwiY2wiLCJ1cGRhdGVfbW9kIiwiaW5pdGlhbF9idWZmZXIiLCJidWZmZXIiLCJidWZwb3MiLCJyZXNldF9idWZmZXIiLCJzdG9yZSIsIm5ld2J1ZmZlciIsImdldF9zdHJpbmciLCJtYWtlX2xleGVyIiwia2V5d29yZHMiLCJrd2RfdGFibGUiLCJpZGVudF9vcl9rZXl3b3JkIiwia2V5d29yZF9vcl9lcnJvciIsImNvbW1lbnQiLCJlc2NhcGUiLCJlbmRfZXhwb25lbnRfcGFydCIsImV4cG9uZW50X3BhcnQiLCJudW1iZXIiLCJpZGVudDIiLCJuZWdfbnVtYmVyIiwibmV4dF90b2tlbiQwIiwibWF5YmVfY29tbWVudCIsIm5leHRfdG9rZW4iLCJoa2V5IiwiY2xlYW4iLCJpbnNlcnRfYnVja2V0IiwiY29udGFpbmVyIiwicmVtb3ZlX2J1Y2tldCIsImhrIiwicmVwbGFjZV9idWNrZXQiLCJuZXdfZCIsImJ1Y2tldF9sZW5ndGhfYWxpdmUiLCJzdGF0c19hbGl2ZSIsImNyZWF0ZSQ1IiwiZ2V0X2tleSQwIiwiZ2V0X2tleV9jb3B5JDAiLCJzZXRfa2V5JDAiLCJ1bnNldF9rZXkkMCIsImNoZWNrX2tleSQwIiwiYmxpdF9rZXkkMCIsImdldF9kYXRhJDEiLCJnZXRfZGF0YV9jb3B5Iiwic2V0X2RhdGEiLCJ1bnNldF9kYXRhIiwiY2hlY2tfZGF0YSIsImJsaXRfZGF0YSIsInNldF9rZXlfZGF0YSIsImNyZWF0ZSQ2IiwiZ2V0X2tleTEiLCJnZXRfa2V5MV9jb3B5Iiwic2V0X2tleTEiLCJ1bnNldF9rZXkxIiwiY2hlY2tfa2V5MSIsImdldF9rZXkyIiwiZ2V0X2tleTJfY29weSIsInNldF9rZXkyIiwidW5zZXRfa2V5MiIsImNoZWNrX2tleTIiLCJibGl0X2tleTEiLCJibGl0X2tleTIiLCJibGl0X2tleTEyIiwiZ2V0X2RhdGEkMiIsImdldF9kYXRhX2NvcHkkMCIsInNldF9kYXRhJDAiLCJ1bnNldF9kYXRhJDAiLCJjaGVja19kYXRhJDAiLCJibGl0X2RhdGEkMCIsImsyJDAiLCJrMSQwIiwiY3JlYXRlJDciLCJsZW5ndGgkNiIsImdldF9rZXkkMSIsImdldF9rZXlfY29weSQxIiwic2V0X2tleSQxIiwidW5zZXRfa2V5JDEiLCJjaGVja19rZXkkMSIsImJsaXRfa2V5JDEiLCJnZXRfZGF0YSQzIiwiZ2V0X2RhdGFfY29weSQxIiwic2V0X2RhdGEkMSIsInVuc2V0X2RhdGEkMSIsImNoZWNrX2RhdGEkMSIsImJsaXRfZGF0YSQxIiwia2kiLCJrMCIsImdlbmVyaWNfYmFzZW5hbWUiLCJpc19kaXJfc2VwIiwiZ2VuZXJpY19kaXJuYW1lIiwiaXNfcmVsYXRpdmUiLCJpc19pbXBsaWNpdCIsImNoZWNrX3N1ZmZpeCIsInN1ZmYiLCJjaG9wX3N1ZmZpeF9vcHQiLCJsZW5fZiIsInF1b3RlIiwicXVvdGVfY29tbWFuZCIsImJhc2VuYW1lIiwiZGlybmFtZSIsImlzX2Rpcl9zZXAkMCIsImlzX3JlbGF0aXZlJDAiLCJpc19pbXBsaWNpdCQwIiwiY2hlY2tfc3VmZml4JDAiLCJjaG9wX3N1ZmZpeF9vcHQkMCIsInRlbXBfZGlyX25hbWUiLCJxdW90ZSQwIiwiYWRkX2JzIiwibG9vcCQwIiwibG9vcF9icyIsInF1b3RlX2NtZF9maWxlbmFtZSIsInF1b3RlX2NvbW1hbmQkMCIsImRyaXZlX2FuZF9wYXRoIiwiZGlybmFtZSQwIiwicGF0aCIsImRyaXZlIiwiZGlyIiwiYmFzZW5hbWUkMCIsImJhc2VuYW1lJDEiLCJkaXJuYW1lJDEiLCJudWxsJDMiLCJjdXJyZW50X2Rpcl9uYW1lJDIiLCJwYXJlbnRfZGlyX25hbWUkMiIsImRpcl9zZXAkMiIsImlzX2Rpcl9zZXAkMSIsImlzX3JlbGF0aXZlJDEiLCJpc19pbXBsaWNpdCQxIiwiY2hlY2tfc3VmZml4JDEiLCJjaG9wX3N1ZmZpeF9vcHQkMSIsInRlbXBfZGlyX25hbWUkMCIsInF1b3RlJDEiLCJxdW90ZV9jb21tYW5kJDEiLCJiYXNlbmFtZSQyIiwiZGlybmFtZSQyIiwiY29uY2F0JDQiLCJjaG9wX3N1ZmZpeCIsImV4dGVuc2lvbl9sZW4iLCJleHRlbnNpb24iLCJjaG9wX2V4dGVuc2lvbiIsInJlbW92ZV9leHRlbnNpb24iLCJwcm5nJDAiLCJ0ZW1wX2ZpbGVfbmFtZSIsInRlbXBfZGlyIiwicm5kIiwiY3VycmVudF90ZW1wX2Rpcl9uYW1lIiwic2V0X3RlbXBfZGlyX25hbWUiLCJnZXRfdGVtcF9kaXJfbmFtZSIsInRlbXBfZmlsZSIsInRyeV9uYW1lIiwiY291bnRlciQxIiwib3Blbl90ZW1wX2ZpbGUiLCJzdGgkMCIsInBlcm1zIiwic3RoJDEiLCJhZGQkMSIsInN1YiQ0IiwibmVnIiwiY29uaiIsIm11bCIsImRpdiIsImludiIsIm5vcm0yIiwibm9ybSIsInEkMCIsInBvbGFyIiwic3FydCIsInckMCIsImV4cCIsImxvZyIsInBvdyIsImZsb2F0MzIiLCJmbG9hdDY0IiwiaW50OF9zaWduZWQiLCJpbnQ4X3Vuc2lnbmVkIiwiaW50MTZfc2lnbmVkIiwiaW50MTZfdW5zaWduZWQiLCJpbnQzMiQxIiwiaW50NjQkMSIsImludCQyIiwibmF0aXZlaW50JDEiLCJjb21wbGV4MzIiLCJjb21wbGV4NjQiLCJraW5kX3NpemVfaW5fYnl0ZXMiLCJjX2xheW91dCIsImZvcnRyYW5fbGF5b3V0IiwiY2xvb3AiLCJpZHgiLCJjb2wiLCJmbG9vcCIsImluaXQkNSIsImxheW91dCIsImRpbXMiLCJkbGVuIiwic2l6ZV9pbl9ieXRlcyIsImNyZWF0ZSQ4IiwiZ2V0JDIiLCJzZXQkMSIsInNpemVfaW5fYnl0ZXMkMCIsIm9mX3ZhbHVlIiwiY3JlYXRlJDkiLCJkaW0iLCJzaXplX2luX2J5dGVzJDEiLCJzbGljZSIsImluaXQkNiIsIm9mX2FycmF5IiwiYmEiLCJjcmVhdGUkMTAiLCJkaW0xIiwiZGltMiIsInNpemVfaW5fYnl0ZXMkMiIsInNsaWNlX2xlZnQiLCJzbGljZV9yaWdodCIsImluaXQkNyIsIm9mX2FycmF5JDAiLCJyb3ciLCJjcmVhdGUkMTEiLCJkaW0zIiwic2l6ZV9pbl9ieXRlcyQzIiwic2xpY2VfbGVmdF8xIiwic2xpY2VfcmlnaHRfMSIsInNsaWNlX2xlZnRfMiIsInNsaWNlX3JpZ2h0XzIiLCJpbml0JDgiLCJvZl9hcnJheSQxIiwiYXJyYXkwX29mX2dlbmFycmF5IiwiYXJyYXkxX29mX2dlbmFycmF5IiwiYXJyYXkyX29mX2dlbmFycmF5IiwiYXJyYXkzX29mX2dlbmFycmF5IiwicmVzaGFwZV8wIiwicmVzaGFwZV8xIiwicmVzaGFwZV8yIiwicmVzaGFwZV8zIiwiZW1wdHkkMyIsImVtcHR5JDQiLCJuYW1lciIsImVxIiwibiIsIm5hbWVzIiwiZSIsImUkMCIsInRtX2N0eCIsIngiLCJwYWlyIiwieSIsInVucGFpciIsImYiLCJzeW1ib2wiLCJtb2R1bG8iLCJhbnMiLCJpbmRleCIsInAiLCJwYXJhbSIsImwiLCJyZXBsYWNlX250aCIsInJlcGxhY2VfYXNzb2MiLCJrIiwidiIsInYkMCIsImskMCIsInN1YiIsIm9mcyIsImxlbiIsImwkMCIsIm9mcyQwIiwibCQxIiwib2ZzJDEiLCJmaW5kJDAiLCJzIiwiaSIsInNwbGl0X29uX3ByZWRpY2F0ZSIsIm5hbWUiLCJ3ZWlnaHQiLCJhcml0eSIsIm1ha2UkMCIsInRvX3N0cmluZyIsIm9wdCIsInN0aCIsInRvX3N0cmluZyQwIiwidG9fc3RyaW5nJDEiLCJhIiwiZjEiLCJmMiIsImZyZXNoIiwiZXEkMCIsIm5hbWVyJDAiLCJuYW1lcl9uYXR1cmFsIiwidmFyJDAiLCJhcHAiLCJwYXJzZXIiLCJ0ZXJtIiwicyQwIiwiYSQwIiwiYSQxIiwic3RlcCIsInZhcnMiLCJwYXJzZV92YXIiLCJwYXJzZSIsIm9wcyIsImF1eCIsIm8iLCJmJDAiLCJlcSQxIiwidDEiLCJ0MiIsImEyIiwic3RyaW5nX29mX3Rlcm0iLCJpc192YXIiLCJnZXRfdmFyIiwidmFycyQwIiwidCIsIm9jY3VycyIsImdlIiwiZ2Vfb3AiLCJ1IiwiZ3QiLCJiIiwiZyIsImwxIiwibDIiLCJ4MiIsImwxJDAiLCJ4MSIsImwyJDAiLCJ0b19zdHJpbmckMiIsImVtcHR5JDAiLCJpZCIsInJlbmFtZSIsInNpbXBsZSIsImFkZCIsImZpbmQkMSIsInMkMSIsImFwcCQwIiwiY29tcG9zZSIsImVxJDIiLCJzMSIsInMyIiwiaW5jbHVkZWQiLCJpc19yZW5hbWluZyIsImlzX2luamVjdGl2ZV9yZW5hbWluZyIsImludiIsImRvbWFpbiIsImluX2RvbSIsInJlc3RyaWN0IiwidW5pZnkiLCJxJDQiLCJxIiwicSQwIiwicSQxIiwicSQyIiwieCQwIiwicSQzIiwicyQyIiwibWF0Y2hlcyIsImVxdWl2YWxlbnQiLCJsaXN0X3JlbW92ZV9udGgiLCJtYWtlJDEiLCJyIiwib2Zfc3RyaW5nIiwidCQwIiwibmFtZSQwIiwic291cmNlIiwidGFyZ2V0IiwidmFycyQxIiwiYXJpdHkkMCIsImFyZ3MiLCJ6IiwiYXJnc19zdWJzdCIsInRvX3N0cmluZyQzIiwiZXEkMyIsInIxIiwicjIiLCJvcGVyYXRpb25zIiwicnMiLCJydWxlcyIsIm1ha2UkMiIsImVtcHR5JDEiLCJ0b19zdHJpbmckNCIsImZpbmQkMiIsInIkMCIsIm9mX3Rlcm0iLCJ0YXBwIiwiYTEiLCJyYXBwIiwidnIiLCJ2cyIsInN1YnN0Iiwic3QiLCJzb3VyY2UkMCIsInRhcmdldCQwIiwibGFiZWwiLCJhMSQwIiwiYTIkMCIsImEkMiIsInRvX3N0cmluZyQ1IiwicnVsZSIsInBhcmFtJDEiLCJoYXNfY29udGV4dCIsImVxJDQiLCJoYXNfcnVsZSIsInN0ZXBzIiwiY3R4IiwiY3R4JDAiLCJlbXB0eSQyIiwic291cmNlJDEiLCJ0YXJnZXQkMSIsImFwcGVuZF9zdGVwIiwidG9fc3RyaW5nJDYiLCJzcmMiLCJsYmwiLCJ0Z3QiLCJhcHBlbmQkMCIsInRvcGxldmVsX3J1bGVzIiwiZXEkNSIsInAkMCIsInAkMSIsInJ1bGVzJDAiLCJyciIsImxlbmd0aCQwIiwibnRoX3N0ZXAiLCJudGhfdGVybSIsIm5vcm1hbGl6ZSIsImNyaXRpY2FsX3J1bGVzIiwibjIiLCJzdGVwMSIsInN0ZXAyIiwiY3JpdGljYWwiLCJzeW0iLCJzMSQwIiwiczIkMCIsInN0ZXBzJDAiLCJvcmllbnQiLCJrbnV0aF9iZW5kaXgiLCJzdGgkMCIsImNhbGxiYWNrIiwicnMkMCIsIm5hbWVyJDEiLCJxdWV1ZSIsImNwIiwicDEiLCJwMiIsInQyJDAiLCJ0MSQwIiwic3F1aWVyIiwidG9fc3RyaW5nJDciLCJwYSIsInNvdXJjZSQzIiwidGFyZ2V0JDMiLCJzb3VyY2UkMiIsInRhcmdldCQyIiwic3RlcCQwIiwiY29tcCIsImFwcGVuZCQxIiwiY29uY2F0JDEiLCJpbnYkMCIsImVxJDYiLCJwJDIiLCJwJDMiLCJwJDQiLCJwJDUiLCJwJDYiLCJsZW5ndGgkMSIsIm9mX3BhdGgiLCJtYXAkMSIsInRtIiwic3Vic3QkMCIsInJ1bGVfb2NjdXJlbmNlcyIsInJ1bGVfYWxnZWJyYWljX29jY3VyZW5jZXMiLCJpc19pZCIsImlzX2ludiIsImhhc19ydWxlJDAiLCJjYW5vbml6ZSIsInAkMTAiLCJzJDMiLCJwJDciLCJzJDQiLCJwJDgiLCJzJDUiLCJwJDkiLCJzJDYiLCJwJDExIiwicCQxMiIsInAkMTMiLCJ2YWx1ZSIsInByZWZpeCQxIiwicmVwbGFjZV9ydWxlIiwicHIiLCJwYXJhbSQwIiwidG1fY3R4JDIiLCJ0bV9jdHgkMCIsInRtX2N0eCQxIiwicnNfY3R4JDEiLCJyc19jdHgkMCIsIm50aF9zdGVwJDAiLCJudGhfdGVybSQwIiwidG9fbGlzdCIsInBhcnNlJDAiLCJ1bmlkIiwicnNfY3R4IiwibWFrZSQzIiwidG9fc3RyaW5nJDgiLCJjb21wJDAiLCJpbnYkMSIsIm9mX2NlbGwiLCJjYW5vbml6ZSQwIiwidmFsdWUkMCIsInJlcGxhY2VfcnVsZSQwIiwibGVuZ3RoJDIiLCJyb3RhdGUiLCJuYW1lJDEiLCJjIiwibG9vcCIsIm1ha2UkNCIsInRvX3N0cmluZyQ5Iiwicm90YXRlJDAiLCJpbml0IiwidmFsdWUkMSIsInJlcGxhY2VfcnVsZSQxIiwiY3JzIiwicnVsZXMkMSIsImNvaGVyZW5jZSIsInNldF9ydWxlcyIsInRvX3N0cmluZyQxMCIsImNvaGVyZW5jZSQwIiwidG9fdGV4IiwicHJpbnQiLCJ2YXIkMSIsInAxJDEiLCJwMiQxIiwicDIkMiIsInAxJDIiLCJwMiQwIiwicDEkMCIsImQiLCJkJDAiLCJjZCIsIm1hdGNoIiwibWF0Y2gkMCIsImkkMCIsImkkMiIsImkkMSIsImkkMyIsImoiLCJ2aWV3X3BkZiIsIm9jIiwiZm5hbWUiLCJjbWQiLCJtYWtlJDUiLCJmaW5kX3J1bGUiLCJmaW5kJDMiLCJhZGRfY29oZXJlbmNlIiwicm90YXRlJDEiLCJjbmFtZSIsImVsaW1fcnVsZSIsImMkMCIsImVxJDciLCJ0b19zdHJpbmckMTEiLCJjb21wYXJlJDEiLCJsZXEiLCJnZXEiLCJlcSQ4IiwidG9fc3RyaW5nJDEyIiwiY29tcGFyZSQyIiwiZXEkOSIsInRvX3N0cmluZyQxMyIsImNvbXBhcmUkMyIsImxlcSQwIiwiZ2VxJDAiLCJlcSQxMCIsImNvbXBhcmUkNCIsInRvX3N0cmluZyQxNCIsImIkMCIsImNvbXBhcmUiLCJlbXB0eSIsIm9mX2xpc3QiLCJtZW0iLCJpdGVyIiwidSQwIiwidiQxIiwidSQxIiwiZXEkMTEiLCJhZGQkMCIsInkkMCIsInplcm8iLCJuZWciLCJtdWwiLCJvbmUiLCJ0b19zdHJpbmckMTUiLCJlcSQxMiIsImFkZCQxIiwiemVybyQwIiwibmVnJDAiLCJtdWwkMCIsInRvX3N0cmluZyQxNiIsImVxJDEzIiwiYWRkJDIiLCJ6ZXJvJDEiLCJuZWckMSIsIm11bCQxIiwidG9fc3RyaW5nJDE3IiwibGVuZ3RoIiwiZGVncmVlIiwiZHAiLCJkcSIsImNvbXBhY3QiLCJjb2VmZiIsInBsIiwicWwiLCJjbXVsIiwibW9ub21pYWwiLCJlcSQxNCIsImFkZCQzIiwiemVybyQyIiwibmVnJDIiLCJtdWwkMiIsIm9uZSQwIiwidG9fc3RyaW5nJDE4IiwiaW52JDIiLCJlcSQxNSIsImFkZCQ0IiwiemVybyQzIiwibmVnJDMiLCJtdWwkMyIsIm9uZSQxIiwidG9fc3RyaW5nJDE5IiwiaW52JDMiLCJlcSQxNiIsImFkZCQ1IiwiemVybyQ0IiwibmVnJDQiLCJtdWwkNCIsIm9uZSQyIiwidG9fc3RyaW5nJDIwIiwiaW52JDQiLCJnY2QiLCJkaXYiLCJkYiIsImRyIiwiZ2V0IiwiYWYiLCJhdyIsImF3bCIsIngkMSIsImF3JDAiLCJhaSIsIm1ha2UiLCJleHBuIiwiaGFkYW1hcmQiLCJzdGFyIiwicG9seW5vbWlhbCIsInJhdGlvbmFsIiwibGlzdCIsInciLCJjZWxsIiwid2hpc2tlciIsImMyIiwiYzEiLCJkaW0iLCJhdXgkMCIsInckMCIsInckMSIsImMkMSIsImJvdW5kYXJ5IiwibWVtJDAiLCJkaW0kMCIsImluaiIsIndlcSIsInVsIiwidmwiLCJ3YyIsInBlcSIsInVvZmYiLCJ2b2ZmIiwidW5pZmllciIsImFucyQwIiwib3JkZXJlZF91bmlmaWVycyIsIm9yZGVyZWRfdW5pZmllcnNfYmljb250ZXh0IiwibHUiLCJsdiIsInVuaWZpZXJzX2JpY29udGV4dCIsImxleGljb2dyYXBoaWMiLCJkZWdsZXgiLCJzaW5nbGV0b24iLCJzaW5nbGV0b25zIiwiaGQiLCJ0bCIsImQkMSIsImNtcCIsImV4dGVuZCIsImNjIiwiZXZhbCQwIiwiZ2VuZXJhdG9ycyIsInByZXMiLCJ2MSIsInYyIiwiYWRkX3J1bGUiLCJyZWR1Y2UiLCJjb21wbGV0ZSIsInByZXMkMCIsInByZXMkMSIsInRvZG8iLCJwcmVzJDIiLCJ1MiIsInUxIiwibmYiLCJpbnRzZXQiLCJyb3dzIiwibSIsImNvbHMiLCJpc196ZXJvIiwicmVwbGFjZSIsIm1pIiwiZXhjaGFuZ2UiLCJtdWx0IiwibWFkZCIsInJvd19lY2hlbG9uIiwibSQwIiwiaXAiLCJjb2xzJDAiLCJyYW5rIiwibnVsbGl0eSIsImZpbmQiLCJvZl9hcnJheSIsIm1hdHJpeCIsInNldCIsImokMCIsInJhbmskMCIsIm51bGxpdHkkMCIsIml0ZXJfc3JjIiwiaXRlcl90Z3QiLCJpdGVyJDAiLCJtYXAiLCJtYXAkMCIsImxtYXAiLCJtJDEiLCJjaW5qIiwiYWRkX21vbm9taWFsIiwiYmluZCIsImdlbiIsInByZXNlbnRhdGlvbl90b19zdHJpbmciLCJvZl9tYXAiLCJ0b19tYXAiLCJpdGVyJDEiLCJtb2R1bGVzIiwibWFwcyIsInZhbGlkIiwiYmV0dGkiLCJrZXIiLCJpbSIsImNvbXBhcmUkMCIsImxhYmVsJDAiLCJzcmMkMCIsInRndCQwIiwidmVydGljZXMiLCJlZGdlcyIsImFkZF92ZXJ0ZXgiLCJhZGRfZWRnZSIsInZlcnRleF9wcmVkIiwidmVydGV4X3N1Y2MiLCJlZGdlX3ByZWQiLCJlZGdlX3N1Y2MiLCJlZGdlIiwiaGFzX3ZlcnRleCIsInZlcnRpY2VzJDAiLCJlZGdlcyQwIiwidG9fc3RyaW5nJDIxIiwiYWRkMCIsImZyZXNoJDAiLCJ0b19zdHJpbmckMjIiLCJuJDAiLCJmcmVzaCQxIiwidG9fc3RyaW5nJDIzIiwiYWRkX29iamVjdCIsImFkZF9tb3JwaGlzbSIsIm1vcnBoaXNtIiwiYWRkX3JlbGF0aW9uIiwiZ3JhcGgiLCJyZWxhdGlvbnMiLCJyZWxhdGlvbnMkMCIsInJlbGF0aW9ucyQxIiwibGV0dGVyIiwidW5pb24iLCJjb25jYXQiLCJ1bmlvbnMiLCJyJDEiLCJyJDIiLCJzaW1wbCIsInNlcmllcyIsInN0YXRlcyIsImF1dCIsInRyYW5zIiwiYWRkX3RyYW5zaXRpb24iLCJiYiIsImJiJDAiLCJ0cmFuc2l0aW9ucyIsImNyZWF0ZSIsImluaXRpYWwiLCJ0ZXJtaW5hbCIsInRlcm1pbmFsJDAiLCJrbGVlbmUiLCJqaiIsInJyJDAiLCJyciQyIiwic3MiLCJyciQxIiwibXVsX21vbm9taWFsIiwibGVhZGluZyIsImZyZWUiLCJwcCIsImhlYWRzIiwidjEkMCIsInYyJDAiLCJidWNoYmVyZ2VyIiwidTEkMCIsInUyJDAiLCJlcHMiLCJlcHMkMCIsImdyYWRlZCIsIm1vbm9pZCIsIm5vcm1hbGl6ZSQwIiwiY2luaiQwIiwiY211bCQwIiwiY3UiLCJjaGFpbnMiLCJsZWZ0IiwicmVzb2x1dGlvbiIsImF1Z21lbnRhdGlvbiIsImRlYnVnIiwiYXVnbWVudGF0aW9uJDAiLCJhdWdtZW50YXRpb24kMSIsImNoIiwiY3UkMCIsImNuIiwiY25sIiwiY251IiwiY251bCIsInUkMiIsImFucyQxIiwiYW5zJDIiLCJhbnMkMyIsImFucyQ0IiwiYW5zJDUiLCJjYyQwIiwiY29tcGxleCIsImJyYWlkIiwic3ltbWV0cmljIiwiZXh0ZXJpb3IiLCJleG4iLCJtb2R1bGUiLCJnbG9iYWxUaGlzIiwibnVsbCIsInVuZGVmaW5lZCIsImpzb29fZXhwb3J0cyIsImV2ZW50IiwidG9fc3RyaW5nIiwicCIsImF1eCIsInEiLCJjIiwicSQwIiwicCQwIiwicSQxIiwicCQxIiwicCQyIiwieXlsaHMiLCJ5eWxlbiIsInl5ZGVmcmVkIiwieXlkZ290byIsInl5c2luZGV4IiwieXlyaW5kZXgiLCJ5eWdpbmRleCIsInl5dGFibGUiLCJ5eWNoZWNrIiwieXluYW1lc19jb25zdCIsInl5bmFtZXNfYmxvY2siLCJtdWxzIiwibCIsInBvdyIsInAiLCJuIiwieXl0cmFuc2xfY29uc3QiLCJ5eXRyYW5zbF9ibG9jayIsInl5dGFibGVzaXplIiwiY2FtbF9wYXJzZXJfZW52IiwiXzEiLCJfMiIsIl8zIiwieXlhY3QiLCJ5eXRhYmxlcyIsIm1haW4iLCJsZXhmdW4iLCJsZXhidWYiLCJvY2FtbF9sZXhfdGFibGVzIiwidG9rZW4kMCIsImxleGJ1ZiIsIm9jYW1sX2xleF90b2tlbl9yZWMkMCIsIm9jYW1sX2xleF9zdGF0ZSIsIm9jYW1sX2xleF9zdGF0ZSQwIiwib2NhbWxfbGV4X3N0YXRlJDEiLCJuIiwiYyIsInRva2VuIiwib2NhbWxfbGV4X3Rva2VuX3JlYyIsInYiLCJkb2MiLCJidXR0b24iLCJ0eHQiLCJhY3Rpb24iLCJidXR0b25fdHlwZSIsImRlYnVnIiwicyIsImpzZ2V0IiwieCIsInBhcnNlX3BvbCIsImNoYXJfb2Zfc3RyaW5nIiwiaSIsImV2YWxfcG9sIiwicCIsImF1eCIsInEiLCJjIiwicSQwIiwicCQwIiwicSQxIiwicCQxIiwicCQyIiwicmVwbGFjZSIsInQiLCJuIiwicnVuIiwib3JkZXIiLCJhdWdtZW50YXRpb24iLCJtYXhkZWciLCJncm9ibmVyIiwiY2hhaW5zIiwicmVzb2x1dGlvbiIsImJldHRpIiwic3RhdHVzIiwiZXJyb3IiLCJ2YXJzIiwicmVsYXRpb25zIiwidmFycyQwIiwidmFycyQxIiwidmFycyQyIiwicmVsYXRpb25zJDAiLCJyZWxhdGlvbnMkMSIsInJlbGF0aW9ucyQyIiwiZSIsInJlbGF0aW9ucyQzIiwib3JkZXIkMCIsInByZXMiLCJwcmVzJDAiLCJoZWFkcyIsImNjIiwiY2MkMCIsInMkMCIsIm1heGRlZyQwIiwiZCIsInMkMSIsImgiLCJnZW5lcmF0ZV9oYW5kbGVyIiwibGlzdF9pbml0IiwiZiIsImsiLCJzZXQiLCJyIiwiZ2VuIiwidiQyIiwicmVsJDMiLCJpJDIiLCJpJDEiLCJqJDEiLCJyZWwkNCIsInYkMCIsInJlbCIsImoiLCJyZWwkMCIsInYkMyIsInJlbCQ1IiwiaSQ0IiwiaSQzIiwicmVsJDYiLCJpJDUiLCJyZWwkNyIsInYkNCIsInYkNSIsInJlbCQ4IiwieCQxIiwieSQxIiwieiQxIiwieCQyIiwieSQyIiwieiQyIiwieSIsInoiLCJ4JDAiLCJ5JDAiLCJ6JDAiLCJyZWwkOSIsInYkMSIsInJlbCQxIiwiaSQwIiwiaiQwIiwicmVsJDIiXSwic291cmNlcyI6WyIiLCIvYnVpbHRpbi8raW50NjQuanMiLCIvYnVpbHRpbi8rbWxCeXRlcy5qcyIsIi9idWlsdGluLytmYWlsLmpzIiwiL2J1aWx0aW4vK3N0ZGxpYi5qcyIsIi9idWlsdGluLytmb3JtYXQuanMiLCIvYnVpbHRpbi8raWVlZV83NTQuanMiLCIvYnVpbHRpbi8rZnNfbm9kZS5qcyIsIi9idWlsdGluLytmcy5qcyIsIi9idWlsdGluLyt1bml4LmpzIiwiL2J1aWx0aW4vK3N5cy5qcyIsIi9idWlsdGluLytmc19mYWtlLmpzIiwiL2J1aWx0aW4vK25hdC5qcyIsIi9idWlsdGluLytncmFwaGljcy5qcyIsIi9idWlsdGluLyttYXJzaGFsLmpzIiwiL2J1aWx0aW4vK2lvLmpzIiwiL2J1aWx0aW4vK2djLmpzIiwiL2J1aWx0aW4vK2JpZ2FycmF5LmpzIiwiL2J1aWx0aW4vK2pzbGliLmpzIiwiL2J1aWx0aW4vK3BhcnNpbmcuanMiLCIvYnVpbHRpbi8raW50cy5qcyIsIi9idWlsdGluLytoYXNoLmpzIiwiL2J1aWx0aW4vK2NvbXBhcmUuanMiLCIvYnVpbHRpbi8ranNsaWJfanNfb2Zfb2NhbWwuanMiLCIvYnVpbHRpbi8rb2JqLmpzIiwiL2J1aWx0aW4vK2JpZ3N0cmluZy5qcyIsIi9idWlsdGluLytiYWNrdHJhY2UuanMiLCIvYnVpbHRpbi8rbGV4aW5nLmpzIiwiL2J1aWx0aW4vK2FycmF5LmpzIiwiL2J1aWx0aW4vK3dlYWsuanMiLCIvYnVpbHRpbi8rbWQ1LmpzIiwiL2J1aWx0aW4vK3N0ci5qcyIsIi9idWlsdGluLytiaWdzdHJpbmctY3N0cnVjdC5qcyIsIi9ob21lL3NtaW1yYW0vLm9wYW0vNC4xMy4wL2xpYi9vY2FtbC91Y2hhci5tbCIsIi9ob21lL3NtaW1yYW0vLm9wYW0vNC4xMy4wL2xpYi9vY2FtbC9pbnQ2NC5tbCIsIi9ob21lL3NtaW1yYW0vLm9wYW0vNC4xMy4wL2xpYi9vY2FtbC9sZXhpbmcubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvY2FtbGludGVybmFsRm9ybWF0Lm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL3ByaW50ZXhjLm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL2ZpbGVuYW1lLm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL2NvbXBsZXgubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvY2FtbGludGVybmFsRm9ybWF0QmFzaWNzLm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbEF0b21pYy5tbCIsIi9ob21lL3NtaW1yYW0vLm9wYW0vNC4xMy4wL2xpYi9vY2FtbC9zdGRsaWIubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvcGVydmFzaXZlcy5tbCIsIi9ob21lL3NtaW1yYW0vLm9wYW0vNC4xMy4wL2xpYi9vY2FtbC9mbG9hdC5tbCIsIi9ob21lL3NtaW1yYW0vLm9wYW0vNC4xMy4wL2xpYi9vY2FtbC9yYW5kb20ubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvbGlzdC5tbCIsIi9ob21lL3NtaW1yYW0vLm9wYW0vNC4xMy4wL2xpYi9vY2FtbC9zZXEubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvb3B0aW9uLm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL2VpdGhlci5tbCIsIi9ob21lL3NtaW1yYW0vLm9wYW0vNC4xMy4wL2xpYi9vY2FtbC9yZXN1bHQubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvYm9vbC5tbCIsIi9ob21lL3NtaW1yYW0vLm9wYW0vNC4xMy4wL2xpYi9vY2FtbC9jaGFyLm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL25hdGl2ZWludC5tbCIsIi9ob21lL3NtaW1yYW0vLm9wYW0vNC4xMy4wL2xpYi9vY2FtbC9pbnQubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvYnl0ZXMubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvc3RyaW5nLm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL3VuaXQubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvbWFyc2hhbC5tbCIsIi9ob21lL3NtaW1yYW0vLm9wYW0vNC4xMy4wL2xpYi9vY2FtbC9vYmoubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvYXJyYXkubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvaW50MzIubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvcGFyc2luZy5tbCIsIi9ob21lL3NtaW1yYW0vLm9wYW0vNC4xMy4wL2xpYi9vY2FtbC9zZXQubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvbWFwLm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL3N0YWNrLm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL3F1ZXVlLm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbExhenkubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvbGF6eS5tbCIsIi9ob21lL3NtaW1yYW0vLm9wYW0vNC4xMy4wL2xpYi9vY2FtbC9zdHJlYW0ubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvYnVmZmVyLm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL3ByaW50Zi5tbCIsIi9ob21lL3NtaW1yYW0vLm9wYW0vNC4xMy4wL2xpYi9vY2FtbC9hcmcubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvZnVuLm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL2djLm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL2RpZ2VzdC5tbCIsIi9ob21lL3NtaW1yYW0vLm9wYW0vNC4xMy4wL2xpYi9vY2FtbC9oYXNodGJsLm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL3dlYWsubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvZm9ybWF0Lm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL3NjYW5mLm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL2NhbGxiYWNrLm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbE9PLm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbE1vZC5tbCIsIi9ob21lL3NtaW1yYW0vLm9wYW0vNC4xMy4wL2xpYi9vY2FtbC9nZW5sZXgubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvZXBoZW1lcm9uLm1sIiwiL2hvbWUvc21pbXJhbS8ub3BhbS80LjEzLjAvbGliL29jYW1sL2JpZ2FycmF5Lm1sIiwiL2hvbWUvc21pbXJhbS9wcm9nL29jYW1sLWFsZy9fYnVpbGQvZGVmYXVsdC9zcmMvaHlwZXJncmFwaC5tbCIsIi9ob21lL3NtaW1yYW0vcHJvZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvc3JjL2dyYXBoLm1sIiwiL2hvbWUvc21pbXJhbS9wcm9nL29jYW1sLWFsZy9fYnVpbGQvZGVmYXVsdC9zcmMvdXRpbHMubWwiLCIvaG9tZS9zbWltcmFtL3Byb2cvb2NhbWwtYWxnL19idWlsZC9kZWZhdWx0L3NyYy9leHRsaWIubWwiLCIvaG9tZS9zbWltcmFtL3Byb2cvb2NhbWwtYWxnL19idWlsZC9kZWZhdWx0L3NyYy90ZXJtLm1sIiwiL2hvbWUvc21pbXJhbS9wcm9nL29jYW1sLWFsZy9fYnVpbGQvZGVmYXVsdC9zcmMvYWxwaGFiZXQubWwiLCIvaG9tZS9zbWltcmFtL3Byb2cvb2NhbWwtYWxnL19idWlsZC9kZWZhdWx0L3NyYy9zaW1wbGljaWFsLm1sIiwiL2hvbWUvc21pbXJhbS9wcm9nL29jYW1sLWFsZy9fYnVpbGQvZGVmYXVsdC9zcmMvcmluZy5tbCIsIi9ob21lL3NtaW1yYW0vcHJvZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvc3JjL2ZpZWxkLm1sIiwiL2hvbWUvc21pbXJhbS9wcm9nL29jYW1sLWFsZy9fYnVpbGQvZGVmYXVsdC9zcmMvc2VyaWVzLm1sIiwiL2hvbWUvc21pbXJhbS9wcm9nL29jYW1sLWFsZy9fYnVpbGQvZGVmYXVsdC9zcmMvcHJlY2F0ZWdvcnkubWwiLCIvaG9tZS9zbWltcmFtL3Byb2cvb2NhbWwtYWxnL19idWlsZC9kZWZhdWx0L3NyYy9tb25vaWQubWwiLCIvaG9tZS9zbWltcmFtL3Byb2cvb2NhbWwtYWxnL19idWlsZC9kZWZhdWx0L3NyYy9tYXRyaXgubWwiLCIvaG9tZS9zbWltcmFtL3Byb2cvb2NhbWwtYWxnL19idWlsZC9kZWZhdWx0L3NyYy9tb2R1bGUubWwiLCIvaG9tZS9zbWltcmFtL3Byb2cvb2NhbWwtYWxnL19idWlsZC9kZWZhdWx0L3NyYy9nbG9idWxhci5tbCIsIi9ob21lL3NtaW1yYW0vcHJvZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvc3JjL2NhdGVnb3J5Lm1sIiwiL2hvbWUvc21pbXJhbS9wcm9nL29jYW1sLWFsZy9fYnVpbGQvZGVmYXVsdC9zcmMvYXV0b21hdG9uLm1sIiwiL2hvbWUvc21pbXJhbS9wcm9nL29jYW1sLWFsZy9fYnVpbGQvZGVmYXVsdC9zcmMvYWxnZWJyYS5tbCIsIiIsIiIsIi9ob21lL3NtaW1yYW0vcHJvZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvdG9vbHMvYmVyZ21hbi9wb2wubWwiLCIvaG9tZS9zbWltcmFtL3Byb2cvb2NhbWwtYWxnL19idWlsZC9kZWZhdWx0L3Rvb2xzL2JlcmdtYW4vcGFyc2VyLm1sIiwiL2hvbWUvc21pbXJhbS9wcm9nL29jYW1sLWFsZy9fYnVpbGQvZGVmYXVsdC90b29scy9iZXJnbWFuL3BhcnNlci5tbHkiLCIvaG9tZS9zbWltcmFtL3Byb2cvb2NhbWwtYWxnL19idWlsZC9kZWZhdWx0L3Rvb2xzL2JlcmdtYW4vbGV4ZXIubWwiLCIvaG9tZS9zbWltcmFtL3Byb2cvb2NhbWwtYWxnL19idWlsZC9kZWZhdWx0L3Rvb2xzL2JlcmdtYW4vbGV4ZXIubWxsIiwiL2hvbWUvc21pbXJhbS9wcm9nL29jYW1sLWFsZy9fYnVpbGQvZGVmYXVsdC90b29scy9iZXJnbWFuL2JlcmdtYW4ubWwiLCIvaG9tZS9zbWltcmFtLy5vcGFtLzQuMTMuMC9saWIvb2NhbWwvc3RkX2V4aXQubWwiXSwibWFwcGluZ3MiOiI7O0NBQ0MsU0FBVUE7V0FDRkM7Ozs7S0FDTEM7T0FDRTtRQUNDO1VBQXNCRiw4Q0FFaEJH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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VTs7Ozs7OztJc0JuV0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ2tCS0M7S0FDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDd0JBQztLQUNBQztLQUNBQztLQUlBQztLQUNBQzs7OztLQ3pCQUM7S0FtSEFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ285RU1DO0tBUVFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ2xsRmRDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDc0VFQztLQUNBQztLQUNBQztLQUNBQzs7O0tBL0VZQztLQW1IWkM7S0FDQUM7S0FDQUM7S0FDQUM7OztLQW1JQUM7S0FDQUM7S0FDQUM7S0FDQUM7OztLQ3hQRkM7S0FDQUM7S0FDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2FDMGZJQzs7T0FrQ1k7O09BbENaO2dCQUtKLElBRFFDLGNBQ0Esb0JBREFBO2dC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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VDQ0NBLFdEREQsNkJDQ0NDLEtEREQsSUNDQ0M7SURERDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUNDQ0NDLHVCREREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQ0NDQyxNREREOzs7Ozs7Ozs7O3lCQ0NDQSxNREREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QXJIcEJBOzs4QkFzSEk7SUFHZ0IsNENBOU50Qi9COztJQThOc0I7OztPQTNVdEJ6QjtPQUNBQztPQU9BSTtPQUdBRTs7T0FJQUU7T0E0REFDOzs7T0FjQUU7T0FhSVU7T0FPSkc7O1VEbkhMOzs7Ozs7O0lDQUE7Ozs7SUNrQlM7OztVRGxCVCIsInNvdXJjZXNDb250ZW50IjpbbnVsbCwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG52YXIgY2FtbF9pbnQ2NF9vZmZzZXQgPSBNYXRoLnBvdygyLCAtMjQpO1xuXG4vL1Byb3ZpZGVzOiBNbEludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldCwgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gTWxJbnQ2NCAobG8sbWksaGkpIHtcbiAgdGhpcy5sbyA9IGxvICYgMHhmZmZmZmY7XG4gIHRoaXMubWkgPSBtaSAmIDB4ZmZmZmZmO1xuICB0aGlzLmhpID0gaGkgJiAweGZmZmY7XG59XG5NbEludDY0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX2pcIlxuTWxJbnQ2NC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8sdGhpcy5taSx0aGlzLmhpKTtcbn1cblxuTWxJbnQ2NC5wcm90b3R5cGUudWNvbXBhcmUgPSBmdW5jdGlvbiAoeCkge1xuICBpZiAodGhpcy5oaSA+IHguaGkpIHJldHVybiAxO1xuICBpZiAodGhpcy5oaSA8IHguaGkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubWkgPiB4Lm1pKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubWkgPCB4Lm1pKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLmxvID4geC5sbykgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmxvIDwgeC5sbykgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgaGkgPSB0aGlzLmhpIDw8IDE2O1xuICB2YXIgeGhpID0geC5oaSA8PCAxNjtcbiAgaWYgKGhpID4geGhpKSByZXR1cm4gMTtcbiAgaWYgKGhpIDwgeGhpKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLm1pID4geC5taSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLm1pIDwgeC5taSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5sbyA+IHgubG8pIHJldHVybiAxO1xuICBpZiAodGhpcy5sbyA8IHgubG8pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsbyA9IC0gdGhpcy5sbztcbiAgdmFyIG1pID0gLSB0aGlzLm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gLSB0aGlzLmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyArIHgubG87XG4gIHZhciBtaSA9IHRoaXMubWkgKyB4Lm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gdGhpcy5oaSArIHguaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvIC0geC5sbztcbiAgdmFyIG1pID0gdGhpcy5taSAtIHgubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSB0aGlzLmhpIC0geC5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gKiB4LmxvO1xuICB2YXIgbWkgPSAoKGxvICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB0aGlzLm1pICogeC5sbyArIHRoaXMubG8gKiB4Lm1pO1xuICB2YXIgaGkgPSAoKG1pICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB0aGlzLmhpICogeC5sbyArIHRoaXMubWkgKiB4Lm1pICsgdGhpcy5sbyAqIHguaGk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLmxvfHRoaXMubWl8dGhpcy5oaSkgPT0gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMuaGkgPDwgMTYpIDwgMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvICYgeC5sbywgdGhpcy5taSAmIHgubWksIHRoaXMuaGkgJiB4LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG98eC5sbywgdGhpcy5taXx4Lm1pLCB0aGlzLmhpfHguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG9eeC5sbywgdGhpcy5taV54Lm1pLCB0aGlzLmhpXnguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfbGVmdCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICBpZiAocyA8IDI0KSB7XG4gICAgcmV0dXJuIG5ldyBNbEludDY0ICh0aGlzLmxvIDw8IHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5taSA8PCBzKSB8ICh0aGlzLmxvID4+ICgyNCAtIHMpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmhpIDw8IHMpIHwgKHRoaXMubWkgPj4gKDI0IC0gcykpKTtcbiAgfVxuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG8gPDwgKHMgLSAyNCksXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5taSA8PCAocyAtIDI0KSkgfCAodGhpcy5sbyA+PiAoNDggLSBzKSkpO1xuICByZXR1cm4gbmV3IE1sSW50NjQoMCwgMCwgdGhpcy5sbyA8PCAocyAtIDQ4KSlcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X3JpZ2h0X3Vuc2lnbmVkID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLmxvID4+IHMpIHwgKHRoaXMubWkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMubWkgPj4gcykgfCAodGhpcy5oaSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5oaSA+PiBzKSk7XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLm1pID4+IChzIC0gMjQpKSB8ICh0aGlzLmhpIDw8ICg0OCAtIHMpKSxcbiAgICAgICh0aGlzLmhpID4+IChzIC0gMjQpKSxcbiAgICAgIDApO1xuICByZXR1cm4gbmV3IE1sSW50NjQgKHRoaXMuaGkgPj4gKHMgLSA0OCksIDAsIDApO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfcmlnaHQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgdmFyIGggPSAodGhpcy5oaSA8PCAxNikgPj4gMTY7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLmxvID4+IHMpIHwgKHRoaXMubWkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMubWkgPj4gcykgfCAoaCA8PCAoMjQgLSBzKSksXG4gICAgICAoKHRoaXMuaGkgPDwgMTYpID4+IHMpID4+PiAxNik7XG4gIHZhciBzaWduID0gKHRoaXMuaGkgPDwgMTYpID4+IDMxO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5taSA+PiAocyAtIDI0KSkgfCAodGhpcy5oaSA8PCAoNDggLSBzKSksXG4gICAgICAodGhpcy5oaSA8PCAxNikgPj4gKHMgLSAyNCkgPj4gMTYsXG4gICAgICBzaWduICYgMHhmZmZmKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0ICgodGhpcy5oaSA8PCAxNikgPj4gKHMgLSAzMiksIHNpZ24sIHNpZ24pO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubHNsMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oaSA9ICh0aGlzLmhpIDw8IDEpIHwgKHRoaXMubWkgPj4gMjMpO1xuICB0aGlzLm1pID0gKCh0aGlzLm1pIDw8IDEpIHwgKHRoaXMubG8gPj4gMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLmxvID0gKHRoaXMubG8gPDwgMSkgJiAweGZmZmZmZjtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxzcjEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubG8gPSAoKHRoaXMubG8gPj4+IDEpIHwgKHRoaXMubWkgPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLm1pID0gKCh0aGlzLm1pID4+PiAxKSB8ICh0aGlzLmhpIDw8IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5oaSA9IHRoaXMuaGkgPj4+IDE7XG59XG5NbEludDY0LnByb3RvdHlwZS51ZGl2bW9kID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciBtb2R1bHVzID0gdGhpcy5jb3B5KCk7XG4gIHZhciBkaXZpc29yID0geC5jb3B5KCk7XG4gIHZhciBxdW90aWVudCA9IG5ldyBNbEludDY0KDAsMCwwKTtcbiAgd2hpbGUgKG1vZHVsdXMudWNvbXBhcmUoZGl2aXNvcikgPiAwKSB7XG4gICAgb2Zmc2V0Kys7XG4gICAgZGl2aXNvci5sc2wxKCk7XG4gIH1cbiAgd2hpbGUgKG9mZnNldCA+PSAwKSB7XG4gICAgb2Zmc2V0IC0tO1xuICAgIHF1b3RpZW50LmxzbDEoKTtcbiAgICBpZiAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+PSAwKSB7XG4gICAgICBxdW90aWVudC5sbyArKztcbiAgICAgIG1vZHVsdXMgPSBtb2R1bHVzLnN1YihkaXZpc29yKTtcbiAgICB9XG4gICAgZGl2aXNvci5sc3IxKCk7XG4gIH1cbiAgcmV0dXJuIHsgcXVvdGllbnQgOiBxdW90aWVudCwgbW9kdWx1cyA6IG1vZHVsdXMgfTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uICh5KVxue1xuICB2YXIgeCA9IHRoaXM7XG4gIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHguaGkgXiB5LmhpO1xuICBpZiAoeC5oaSAmIDB4ODAwMCkgeCA9IHgubmVnKCk7XG4gIGlmICh5LmhpICYgMHg4MDAwKSB5ID0geS5uZWcoKTtcbiAgdmFyIHEgPSB4LnVkaXZtb2QoeSkucXVvdGllbnQ7XG4gIGlmIChzaWduICYgMHg4MDAwKSBxID0gcS5uZWcoKTtcbiAgcmV0dXJuIHE7XG59XG5NbEludDY0LnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAoeSlcbntcbiAgdmFyIHggPSB0aGlzO1xuICBpZiAoeS5pc1plcm8oKSkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgdmFyIHNpZ24gPSB4LmhpO1xuICBpZiAoeC5oaSAmIDB4ODAwMCkgeCA9IHgubmVnKCk7XG4gIGlmICh5LmhpICYgMHg4MDAwKSB5ID0geS5uZWcoKTtcbiAgdmFyIHIgPSB4LnVkaXZtb2QoeSkubW9kdWx1cztcbiAgaWYgKHNpZ24gJiAweDgwMDApIHIgPSByLm5lZygpO1xuICByZXR1cm4gcjtcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sbyB8ICh0aGlzLm1pIDw8IDI0KTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvRmxvYXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoKHRoaXMuaGkgPDwgMTYpICogTWF0aC5wb3coMiwgMzIpICsgdGhpcy5taSAqIE1hdGgucG93KDIsIDI0KSkgKyB0aGlzLmxvO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFt0aGlzLmhpID4+IDgsXG4gICAgICAgICAgdGhpcy5oaSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5taSA+PiAxNixcbiAgICAgICAgICAodGhpcy5taSA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5taSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5sbyA+PiAxNixcbiAgICAgICAgICAodGhpcy5sbyA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5sbyAmIDB4ZmZdO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubG8zMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubG8gfCAoKHRoaXMubWkgJiAweGZmKSA8PCAyNCk7XG59XG5NbEludDY0LnByb3RvdHlwZS5oaTMyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKCh0aGlzLm1pID4+PiA4KSAmIDB4ZmZmZikgfCAodGhpcy5oaSA8PCAxNik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdWx0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3VsdCh4LHkpIHsgcmV0dXJuIHgudWNvbXBhcmUoeSkgPCAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jb21wYXJlKHgseSwgdG90YWwpIHsgcmV0dXJuIHguY29tcGFyZSh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbmVnIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X25lZyAoeCkgeyByZXR1cm4geC5uZWcoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYWRkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FkZCAoeCwgeSkgeyByZXR1cm4geC5hZGQoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3N1YiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zdWIgKHgsIHkpIHsgcmV0dXJuIHguc3ViKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tdWwgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2ludDY0X211bCh4LHkpIHsgcmV0dXJuIHgubXVsKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc196ZXJvIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX3plcm8oeCkgeyByZXR1cm4gK3guaXNaZXJvKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSB7IHJldHVybiAreC5pc05lZygpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYW5kIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FuZCAoeCwgeSkgeyByZXR1cm4geC5hbmQoeSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vciAoeCwgeSkgeyByZXR1cm4geC5vcih5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3hvciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF94b3IgKHgsIHkpIHsgcmV0dXJuIHgueG9yKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfbGVmdChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfcmlnaHRfdW5zaWduZWQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0ICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X3JpZ2h0KHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9kaXYgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZGl2ICh4LCB5KSB7IHJldHVybiB4LmRpdih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbW9kIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X21vZCAoeCwgeSkgeyByZXR1cm4geC5tb2QoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2ludDMyIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2ludDMyICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh4ICYgMHhmZmZmZmYsICh4ID4+IDI0KSAmIDB4ZmZmZmZmLCAoeCA+PiAzMSkgJiAweGZmZmYpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9faW50MzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9faW50MzIgKHgpIHsgcmV0dXJuIHgudG9JbnQoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fZmxvYXQgKHgpIHsgcmV0dXJuIHgudG9GbG9hdCAoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2Zsb2F0ICh4KSB7XG4gIGlmICh4IDwgMCkgeCA9IE1hdGguY2VpbCh4KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KFxuICAgIHggJiAweGZmZmZmZixcbiAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCkgJiAweGZmZmZmZixcbiAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZm9ybWF0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSwgY2FtbF9pbnQ2NF9uZWdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdG9faW50MzJcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zvcm1hdCAoZm10LCB4KSB7XG4gIHZhciBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgaWYgKGYuc2lnbmVkY29udiAmJiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpKSB7XG4gICAgZi5zaWduID0gLTE7IHggPSBjYW1sX2ludDY0X25lZyh4KTtcbiAgfVxuICB2YXIgYnVmZmVyID0gXCJcIjtcbiAgdmFyIHdiYXNlID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihmLmJhc2UpO1xuICB2YXIgY3Z0YmwgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgZG8ge1xuICAgIHZhciBwID0geC51ZGl2bW9kKHdiYXNlKTtcbiAgICB4ID0gcC5xdW90aWVudDtcbiAgICBidWZmZXIgPSBjdnRibC5jaGFyQXQoY2FtbF9pbnQ2NF90b19pbnQzMihwLm1vZHVsdXMpKSArIGJ1ZmZlcjtcbiAgfSB3aGlsZSAoISBjYW1sX2ludDY0X2lzX3plcm8oeCkpO1xuICBpZiAoZi5wcmVjID49IDApIHtcbiAgICBmLmZpbGxlciA9ICcgJztcbiAgICB2YXIgbiA9IGYucHJlYyAtIGJ1ZmZlci5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBidWZmZXIgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBidWZmZXI7XG4gIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgYnVmZmVyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSwgY2FtbF9mYWlsd2l0aCwgY2FtbF9wYXJzZV9kaWdpdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF91bHRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYWRkLCBjYW1sX2ludDY0X211bCwgY2FtbF9pbnQ2NF9uZWdcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCxjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX3N0cmluZyhzKSB7XG4gIHZhciByID0gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKTtcbiAgdmFyIGkgPSByWzBdLCBzaWduID0gclsxXSwgYmFzZSA9IHJbMl07XG4gIHZhciBiYXNlNjQgPSBjYW1sX2ludDY0X29mX2ludDMyKGJhc2UpO1xuICB2YXIgdGhyZXNob2xkID1cbiAgICAgIG5ldyBNbEludDY0KDB4ZmZmZmZmLCAweGZmZmZmZmYsIDB4ZmZmZikudWRpdm1vZChiYXNlNjQpLnF1b3RpZW50O1xuICB2YXIgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICBmb3IgKDs7KSB7XG4gICAgaSsrO1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gbXVsdGlwbGljYXRpb24gYmFzZSAqIHJlcyAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdCh0aHJlc2hvbGQsIHJlcykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAgIGQgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICAgIHJlcyA9IGNhbWxfaW50NjRfYWRkKGNhbWxfaW50NjRfbXVsKGJhc2U2NCwgcmVzKSwgZCk7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIGFkZGl0aW9uIChiYXNlICogcmVzKSArIGQgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQocmVzLCBkKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgaWYgKGJhc2UgPT0gMTAgJiYgY2FtbF9pbnQ2NF91bHQobmV3IE1sSW50NjQoMCwgMCwgMHg4MDAwKSwgcmVzKSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgaWYgKHNpZ24gPCAwKSByZXMgPSBjYW1sX2ludDY0X25lZyhyZXMpO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkobG8sIG1pLCBoaSl7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKVxufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGxvLCBoaSl7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgbG8gJiAweGZmZmZmZixcbiAgICAoKGxvID4+PiAyNCkgJiAweGZmKSB8ICgoaGkgJiAweGZmZmYpIDw8IDgpLFxuICAgIChoaSA+Pj4gMTYpICYgMHhmZmZmKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbG8zMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9sbzMyKHYpeyByZXR1cm4gdi5sbzMyKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2hpMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaGkzMih2KXsgcmV0dXJuIHYuaGkzMigpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9ieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChhWzddIDw8IDAgfCAoYVs2XSA8PCA4KSB8IChhWzVdIDw8IDE2KSxcbiAgICAgICAgICAgICAgICAgICAgIGFbNF0gPDwgMCB8IChhWzNdIDw8IDgpIHwgKGFbMl0gPDwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgYVsxXSA8PCAwIHwgKGFbMF0gPDwgOCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19ieXRlcyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19ieXRlcyh4KSB7IHJldHVybiB4LnRvQXJyYXkoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGFzaCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oYXNoKHYpe1xuICByZXR1cm4gKHYubG8zMigpKSBeICh2LmhpMzIoKSlcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMC0yMDE0IErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIEFuIE9DYW1sIHN0cmluZyBpcyBhbiBvYmplY3Qgd2l0aCB0aHJlZSBmaWVsZHM6XG4vLyAtIHRhZyAndCdcbi8vIC0gbGVuZ3RoICdsJ1xuLy8gLSBjb250ZW50cyAnYydcbi8vXG4vLyBUaGUgY29udGVudHMgb2YgdGhlIHN0cmluZyBjYW4gYmUgZWl0aGVyIGEgSmF2YVNjcmlwdCBhcnJheSBvclxuLy8gYSBKYXZhU2NyaXB0IHN0cmluZy4gVGhlIGxlbmd0aCBvZiB0aGlzIHN0cmluZyBjYW4gYmUgbGVzcyB0aGFuIHRoZVxuLy8gbGVuZ3RoIG9mIHRoZSBPQ2FtbCBzdHJpbmcuIEluIHRoaXMgY2FzZSwgcmVtYWluaW5nIGJ5dGVzIGFyZVxuLy8gYXNzdW1lZCB0byBiZSB6ZXJvZXMuIEFycmF5cyBhcmUgbXV0YWJsZSBidXQgY29uc3VtZXMgbW9yZSBtZW1vcnlcbi8vIHRoYW4gc3RyaW5ncy4gQSBjb21tb24gcGF0dGVybiBpcyB0byBzdGFydCBmcm9tIGFuIGVtcHR5IHN0cmluZyBhbmRcbi8vIHByb2dyZXNzaXZlbHkgZmlsbCBpdCBmcm9tIHRoZSBzdGFydC4gUGFydGlhbCBzdHJpbmdzIG1ha2VzIGl0XG4vLyBwb3NzaWJsZSB0byBpbXBsZW1lbnQgdGhpcyBlZmZpY2llbnRseS5cbi8vXG4vLyBXaGVuIGNvbnZlcnRpbmcgdG8gYW5kIGZyb20gVVRGLTE2LCB3ZSBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgdGhlXG4vLyBzdHJpbmcgaXMgY29tcG9zZWQgb25seSBvZiBBU0NJSSBjaGFyYWN0ZXJzIChpbiB3aGljaCBjYXNlLCBub1xuLy8gY29udmVyc2lvbiBuZWVkcyB0byBiZSBwZXJmb3JtZWQpIG9yIG5vdC5cbi8vXG4vLyBUaGUgc3RyaW5nIHRhZyBjYW4gdGh1cyB0YWtlIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuLy8gICBmdWxsIHN0cmluZyAgICAgQllURSB8IFVOS05PV046ICAgICAgMFxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IEFTQ0lJOiAgICAgICAgOVxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IE5PVF9BU0NJSTogICAgOFxuLy8gICBzdHJpbmcgcHJlZml4ICAgUEFSVElBTDogICAgICAgICAgICAgMlxuLy8gICBhcnJheSAgICAgICAgICAgQVJSQVk6ICAgICAgICAgICAgICAgNFxuLy9cbi8vIE9uZSBjYW4gdXNlIGJpdCBtYXNraW5nIHRvIGRpc2NyaW1pbmF0ZSB0aGVzZSBkaWZmZXJlbnQgY2FzZXM6XG4vLyAgIGtub3duX2VuY29kaW5nKHgpID0geCY4XG4vLyAgIGlzX2FzY2lpKHgpID0gICAgICAgeCYxXG4vLyAgIGtpbmQoeCkgPSAgICAgICAgICAgeCY2XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9zdHJfcmVwZWF0KG4sIHMpIHtcbiAgaWYobiA9PSAwKSByZXR1cm4gXCJcIjtcbiAgaWYgKHMucmVwZWF0KSB7cmV0dXJuIHMucmVwZWF0KG4pO30gLy8gRUNNQXNjcmlwdCA2IGFuZCBGaXJlZm94IDI0K1xuICB2YXIgciA9IFwiXCIsIGwgPSAwO1xuICBmb3IoOzspIHtcbiAgICBpZiAobiAmIDEpIHIgKz0gcztcbiAgICBuID4+PSAxO1xuICAgIGlmIChuID09IDApIHJldHVybiByO1xuICAgIHMgKz0gcztcbiAgICBsKys7XG4gICAgaWYgKGwgPT0gOSkge1xuICAgICAgcy5zbGljZSgwLDEpOyAvLyBmbGF0dGVuIHRoZSBzdHJpbmdcbiAgICAgIC8vIHRoZW4sIHRoZSBmbGF0dGVuaW5nIG9mIHRoZSB3aG9sZSBzdHJpbmcgd2lsbCBiZSBmYXN0ZXIsXG4gICAgICAvLyBhcyBpdCB3aWxsIGJlIGNvbXBvc2VkIG9mIGxhcmdlciBwaWVjZXNcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG4vL1dlYWtkZWZcbi8vIFByZSBFQ01BU2NyaXB0IDUsIFthcHBseV0gd291bGQgbm90IHN1cHBvcnQgYXJyYXktbGlrZSBvYmplY3QuXG4vLyBJbiBzdWNoIHNldHVwLCBUeXBlZF9hcnJheSB3b3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBwb2x5ZmlsbCwgYW5kIFtmLmFwcGx5XSB3b3VsZFxuLy8gZmFpbCBoZXJlLiBNYXJrIHRoZSBwcmltaXRpdmUgYXMgV2Vha2RlZiwgc28gdGhhdCBwZW9wbGUgY2FuIG92ZXJyaWRlIGl0IGVhc2lseS5cbmZ1bmN0aW9uIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyAoYSwgaSwgbGVuKSB7XG4gIHZhciBmID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgaWYgKGkgPT0gMCAmJiBsZW4gPD0gNDA5NiAmJiBsZW4gPT0gYS5sZW5ndGgpIHJldHVybiBmLmFwcGx5IChudWxsLCBhKTtcbiAgdmFyIHMgPSBcIlwiO1xuICBmb3IgKDsgMCA8IGxlbjsgaSArPSAxMDI0LGxlbi09MTAyNClcbiAgICBzICs9IGYuYXBwbHkgKG51bGwsIGEuc2xpY2UoaSxpICsgTWF0aC5taW4obGVuLCAxMDI0KSkpO1xuICByZXR1cm4gcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF91dGY4X29mX3V0ZjE2XG5mdW5jdGlvbiBjYW1sX3V0Zjhfb2ZfdXRmMTYocykge1xuICBmb3IgKHZhciBiID0gXCJcIiwgdCA9IGIsIGMsIGQsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyAoaiA8IGwpICYmIChjID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGMwIHwgKGMgPj4gNikpO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweGQ4MDAgfHwgYyA+PSAweGRmZmYpIHtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGUwIHwgKGMgPj4gMTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gNikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfSBlbHNlIGlmIChjID49IDB4ZGJmZiB8fCBpICsgMSA9PSBsIHx8XG4gICAgICAgICAgICAgICAoZCA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGQgPiAweGRmZmYpIHtcbiAgICAgIC8vIFVubWF0Y2hlZCBzdXJyb2dhdGUgcGFpciwgcmVwbGFjZWQgYnkgXFx1ZmZmZCAocmVwbGFjZW1lbnQgY2hhcmFjdGVyKVxuICAgICAgdCArPSBcIlxceGVmXFx4YmZcXHhiZFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgICBjID0gKGMgPDwgMTApICsgZCAtIDB4MzVmZGMwMDtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGYwIHwgKGMgPj4gMTgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gMTIpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGNhbWxfdXRmMTZfb2ZfdXRmOChzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gXCJcIiwgYywgYzEsIGMyLCB2LCBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYzEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMxIDwgMHg4MCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyAoaiA8IGwpICYmIChjMSA9IHMuY2hhckNvZGVBdChqKSkgPCAweDgwOyBqKyspO1xuICAgICAgaWYgKGogLSBpID4gNTEyKSB7IHQuc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiOyBiICs9IHMuc2xpY2UoaSwgaikgfVxuICAgICAgZWxzZSB0ICs9IHMuc2xpY2UoaSwgaik7XG4gICAgICBpZiAoaiA9PSBsKSBicmVhaztcbiAgICAgIGkgPSBqO1xuICAgIH1cbiAgICB2ID0gMTtcbiAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSkge1xuICAgICAgYyA9IGMyICsgKGMxIDw8IDYpO1xuICAgICAgaWYgKGMxIDwgMHhlMCkge1xuICAgICAgICB2ID0gYyAtIDB4MzA4MDtcbiAgICAgICAgaWYgKHYgPCAweDgwKSB2ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSAyO1xuICAgICAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSkge1xuICAgICAgICAgIGMgPSBjMiArIChjIDw8IDYpO1xuICAgICAgICAgIGlmIChjMSA8IDB4ZjApIHtcbiAgICAgICAgICAgIHYgPSBjIC0gMHhlMjA4MDtcbiAgICAgICAgICAgIGlmICgodiA8IDB4ODAwKSB8fCAoKHYgPj0gMHhkN2ZmKSAmJiAodiA8IDB4ZTAwMCkpKSB2ID0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdiA9IDM7XG4gICAgICAgICAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSAmJlxuICAgICAgICAgICAgICAgIChjMSA8IDB4ZjUpKSB7XG4gICAgICAgICAgICAgIHYgPSBjMiAtIDB4M2M4MjA4MCArIChjIDw8IDYpO1xuICAgICAgICAgICAgICBpZiAodiA8IDB4MTAwMDAgfHwgdiA+IDB4MTBmZmZmKSB2ID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHYgPCA0KSB7IC8vIEludmFsaWQgc2VxdWVuY2VcbiAgICAgIGkgLT0gdjtcbiAgICAgIHQgKz0gXCJcXHVmZmZkXCI7XG4gICAgfSBlbHNlIGlmICh2ID4gMHhmZmZmKVxuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDdjMCArICh2ID4+IDEwKSwgMHhkYzAwICsgKHYgJiAweDNGRikpXG4gICAgZWxzZVxuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHYpO1xuICAgIGlmICh0Lmxlbmd0aCA+IDEwMjQpIHt0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjt9XG4gIH1cbiAgcmV0dXJuIGIrdDtcbn1cblxuLy9Qcm92aWRlczoganNvb19pc19hc2NpaVxuZnVuY3Rpb24ganNvb19pc19hc2NpaSAocykge1xuICAvLyBUaGUgcmVndWxhciBleHByZXNzaW9uIGdldHMgYmV0dGVyIGF0IGFyb3VuZCB0aGlzIHBvaW50IGZvciBhbGwgYnJvd3NlcnNcbiAgaWYgKHMubGVuZ3RoIDwgMjQpIHtcbiAgICAvLyBTcGlkZXJtb25rZXkgZ2V0cyBtdWNoIHNsb3dlciB3aGVuIHMubGVuZ3RoID49IDI0IChvbiA2NCBiaXQgYXJjaHMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSBpZiAocy5jaGFyQ29kZUF0KGkpID4gMTI3KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZVxuICAgIHJldHVybiAhL1teXFx4MDAtXFx4N2ZdLy50ZXN0KHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHN3aXRjaCAocy50ICYgNikge1xuICBkZWZhdWx0OiAvKiBQQVJUSUFMICovXG4gICAgaWYgKGkgPj0gcy5jLmxlbmd0aCkgcmV0dXJuIDA7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICByZXR1cm4gcy5jLmNoYXJDb2RlQXQoaSk7XG4gIGNhc2UgNDogLyogQVJSQVkgKi9cbiAgICByZXR1cm4gcy5jW2ldXG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYykge1xuICAvLyBUaGUgT0NhbWwgY29tcGlsZXIgdXNlcyBDaGFyLnVuc2FmZV9jaHIgb24gaW50ZWdlcnMgbGFyZ2VyIHRoYW4gMjU1IVxuICBjICY9IDB4ZmY7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykge1xuICAgIGlmIChpID09IHMuYy5sZW5ndGgpIHtcbiAgICAgIHMuYyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgIGlmIChpICsgMSA9PSBzLmwpIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheSAocyk7XG4gIH1cbiAgcy5jW2ldID0gYztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSAxKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDMpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDMpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDIpLFxuICAgICAgYjQgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCB8IGIzIDw8IDE2IHwgYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSA3KSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQ2NChzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQgKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0IChzLCBpLCBjKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldCAocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDE2KHMsaSxpMTYpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAxKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMiA9IDB4RkYgJiBpMTYgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkxNjtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDE2KHMsaSxpMTYpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0MTZcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDE2XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQxNihzLGksaTE2KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQzMihzLGksaTMyKXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjQgPSAweEZGICYgaTMyID4+IDI0LFxuICAgICAgYjMgPSAweEZGICYgaTMyID4+IDE2LFxuICAgICAgYjIgPSAweEZGICYgaTMyID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMzI7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAyLCBiMyk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDMsIGI0KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQzMlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDMyKHMsaSxpMzIpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQzMihzLGksaTMyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gY2FtbF9pbnQ2NF90b19ieXRlcyhpNjQpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgNyAtIGosIGFbal0pO1xuICB9XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDY0KHMsaSxpNjQpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0NjRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDY0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQ2NChzLGksaTY0KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0IChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGY4X29mX3V0ZjE2LCBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nIChzKSB7XG4gIHZhciB0YWcgPSA5IC8qIEJZVEVTIHwgQVNDSUkgKi87XG4gIGlmICghanNvb19pc19hc2NpaShzKSlcbiAgICB0YWcgPSA4IC8qIEJZVEVTIHwgTk9UX0FTQ0lJICovLCBzID0gY2FtbF91dGY4X29mX3V0ZjE2KHMpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXModGFnLCBzLCBzLmxlbmd0aCk7XG59XG5cblxuLy9Qcm92aWRlczogTWxCeXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywganNvb19pc19hc2NpaSwgY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBNbEJ5dGVzICh0YWcsIGNvbnRlbnRzLCBsZW5ndGgpIHtcbiAgdGhpcy50PXRhZzsgdGhpcy5jPWNvbnRlbnRzOyB0aGlzLmw9bGVuZ3RoO1xufVxuTWxCeXRlcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICBzd2l0Y2ggKHRoaXMudCkge1xuICBjYXNlIDk6IC8qQllURVMgfCBBU0NJSSovXG4gICAgcmV0dXJuIHRoaXMuYztcbiAgZGVmYXVsdDpcbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHRoaXMpO1xuICBjYXNlIDA6IC8qQllURVMgfCBVTktPV04qL1xuICAgIGlmIChqc29vX2lzX2FzY2lpKHRoaXMuYykpIHtcbiAgICAgIHRoaXMudCA9IDk7IC8qQllURVMgfCBBU0NJSSovXG4gICAgICByZXR1cm4gdGhpcy5jO1xuICAgIH1cbiAgICB0aGlzLnQgPSA4OyAvKkJZVEVTIHwgTk9UX0FTQ0lJKi9cbiAgY2FzZSA4OiAvKkJZVEVTIHwgTk9UX0FTQ0lJKi9cbiAgICByZXR1cm4gdGhpcy5jO1xuICB9XG59O1xuTWxCeXRlcy5wcm90b3R5cGUudG9VdGYxNiA9IGZ1bmN0aW9uICgpe1xuICB2YXIgciA9IHRoaXMudG9TdHJpbmcoKTtcbiAgaWYodGhpcy50ID09IDkpIHJldHVybiByXG4gIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0Zjgocik7XG59XG5NbEJ5dGVzLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uICgpe1xuICB2YXIgY29udGVudCA9IHRoaXMudCA9PSA0ID8gdGhpcy5jLnNsaWNlKCkgOiB0aGlzLmM7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0aGlzLnQsY29udGVudCx0aGlzLmwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cl9yZXBlYXQsIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlc1xuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyAocykge1xuICAvKiBBc3N1bWVzIG5vdCBCWVRFUyAqL1xuICBpZiAocy50ID09IDIgLyogUEFSVElBTCAqLylcbiAgICBzLmMgKz0gY2FtbF9zdHJfcmVwZWF0KHMubCAtIHMuYy5sZW5ndGgsICdcXDAnKVxuICBlbHNlXG4gICAgcy5jID0gY2FtbF9zdWJhcnJheV90b19qc2J5dGVzIChzLmMsIDAsIHMuYy5sZW5ndGgpO1xuICBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkgKHMpIHtcbiAgLyogQXNzdW1lcyBub3QgQVJSQVkgKi9cbiAgaWYoZ2xvYmFsVGhpcy5VaW50OEFycmF5KSB7XG4gICAgdmFyIGEgPSBuZXcgZ2xvYmFsVGhpcy5VaW50OEFycmF5KHMubCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGEgPSBuZXcgQXJyYXkocy5sKTtcbiAgfVxuICB2YXIgYiA9IHMuYywgbCA9IGIubGVuZ3RoLCBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIGFbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gIGZvciAobCA9IHMubDsgaSA8IGw7IGkrKykgYVtpXSA9IDA7XG4gIHMuYyA9IGE7XG4gIHMudCA9IDQ7IC8qIEFSUkFZICovXG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9ieXRlcyAocykge1xuICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgcmV0dXJuIHMuYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9vZl9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfb2Zfc3RyaW5nIChzKSB7XG4gIHZhciBsID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocyxpKTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9zdHJpbmcobGVuKSB7XG4gIGlmKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9jcmVhdGVfc3RyaW5nKGxlbikge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHJpbmcuY3JlYXRlXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9ieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcyxjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2J5dGVzKGxlbikge1xuICBpZiAobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQnl0ZXMuY3JlYXRlXCIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMobGVuPzI6OSxcIlwiLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2FycmF5IChhKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhhLDAsYS5sZW5ndGgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9hcnJheSAoYSkge1xuICByZXR1cm4gbmV3IE1sQnl0ZXMoNCxhLGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19jb21wYXJlIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfY29tcGFyZShzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDwgczIuYyk/LTE6KHMxLmMgPiBzMi5jKT8xOjA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2VxdWFsKHMxLCBzMikge1xuICBpZihzMSA9PT0gczIpIHJldHVybiAxO1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPT0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19lcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMik7IH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX25vdGVxdWFsKHMxLCBzMikgeyByZXR1cm4gMS1jYW1sX2J5dGVzX2VxdWFsKHMxLCBzMik7IH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzZXF1YWwgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW4gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19sZXNzdGhhbihzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDwgczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMyLHMxKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMixzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19sZXNzdGhhblxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMiwgczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzdGhhbihzMiwgczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbGxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyX3JlcGVhdCwgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2ZpbGxfYnl0ZXMocywgaSwgbCwgYykge1xuICBpZiAobCA+IDApIHtcbiAgICBpZiAoaSA9PSAwICYmIChsID49IHMubCB8fCAocy50ID09IDIgLyogUEFSVElBTCAqLyAmJiBsID49IHMuYy5sZW5ndGgpKSkge1xuICAgICAgaWYgKGMgPT0gMCkge1xuICAgICAgICBzLmMgPSBcIlwiO1xuICAgICAgICBzLnQgPSAyOyAvKiBQQVJUSUFMICovXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLmMgPSBjYW1sX3N0cl9yZXBlYXQgKGwsIFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICBzLnQgPSAobCA9PSBzLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkocyk7XG4gICAgICBmb3IgKGwgKz0gaTsgaSA8IGw7IGkrKykgcy5jW2ldID0gYztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfZmlsbF9ieXRlc1xudmFyIGNhbWxfZmlsbF9zdHJpbmcgPSBjYW1sX2ZpbGxfYnl0ZXNcblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMsIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ibGl0X2J5dGVzKHMxLCBpMSwgczIsIGkyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgaWYgKChpMiA9PSAwKSAmJlxuICAgICAgKGxlbiA+PSBzMi5sIHx8IChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBsZW4gPj0gczIuYy5sZW5ndGgpKSkge1xuICAgIHMyLmMgPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIGlmIChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBpMiA9PSBzMi5jLmxlbmd0aCkge1xuICAgIHMyLmMgKz0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoczEuYywgaTEsIGxlbik6XG4gICAgICAoaTEgPT0gMCAmJiBzMS5jLmxlbmd0aCA9PSBsZW4pP3MxLmM6czEuYy5zdWJzdHIoaTEsIGxlbik7XG4gICAgczIudCA9IChzMi5jLmxlbmd0aCA9PSBzMi5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gIH0gZWxzZSB7XG4gICAgaWYgKHMyLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMyKTtcbiAgICB2YXIgYzEgPSBzMS5jLCBjMiA9IHMyLmM7XG4gICAgaWYgKHMxLnQgPT0gNCAvKiBBUlJBWSAqLykge1xuICAgICAgaWYgKGkyIDw9IGkxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsID0gTWF0aC5taW4gKGxlbiwgYzEubGVuZ3RoIC0gaTEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIGMyIFtpMiArIGldID0gYzEuY2hhckNvZGVBdChpMSArIGkpO1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ibGl0X3N0cmluZyhhLGIsYyxkLGUpIHtcbiAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGEpLGIsYyxkLGUpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9ieXRlc19sZW5ndGgocykgeyByZXR1cm4gcy5sIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHJldHVybiBzLmNoYXJDb2RlQXQoaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYykge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfdW5zYWZlX3NldFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSB7XG4gIHJldHVybiBzLmxlbmd0aFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIHJldHVybiAoczEgPCBzMik/LTE6KHMxID4gczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZXF1YWwgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWwgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDw9IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDwgczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocykge1xuICAocy50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocy5jKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh4KSB7IHJldHVybiB4IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHgpIHsgcmV0dXJuIHggfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGYxNl9vZl91dGY4XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpIHtcbiAgaWYoanNvb19pc19hc2NpaShzKSlcbiAgICByZXR1cm4gcztcbiAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGY4X29mX3V0ZjE2LCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzKSB7XG4gIGlmIChqc29vX2lzX2FzY2lpKHMpKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpXG4gIGVsc2UgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF91dGY4X29mX3V0ZjE2KHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMocykgeyByZXR1cm4gbmV3IE1sQnl0ZXMoMCxzLHMubGVuZ3RoKTsgfVxuXG5cbi8vIFRoZSBzZWN0aW9uIGJlbG93IHNob3VsZCBiZSB1c2VkIHdoZW4gdXNlLWpzLXN0cmluZz1mYWxzZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLGksYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aChzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2NvbXBhcmVcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2NvbXBhcmUoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2VxdWFsXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19lcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfZXF1YWwoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzdGhhblxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzdGhhblxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocykgeyByZXR1cm4gcyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7IHJldHVybiBzIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIHsgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpIHtcbiAgKHMudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIHJldHVybiBzLmMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpe1xuICByZXR1cm4gcy50b1V0ZjE2KClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmdcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nKHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2lzX21sX2J5dGVzKHMpIHtcbiAgcmV0dXJuIChzIGluc3RhbmNlb2YgTWxCeXRlcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9ieXRlc19jb250ZW50KHMpIHtcbiAgc3dpdGNoIChzLnQgJiA2KSB7XG4gIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgcmV0dXJuIHMuYztcbiAgY2FzZSA0OlxuICAgIHJldHVybiBzLmNcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19pc19hc2NpaVxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiAodHlwZW9mIHMgPT09IFwic3RyaW5nXCIgJiYgIS9bXlxceDAwLVxceGZmXS8udGVzdChzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2lzX21sX2J5dGVzKHMpO1xufVxuXG4vLyBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBkZXByZWNhdGVkXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcocykgeyByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9uZXdfc3RyaW5nIChzKSB7IHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdG9fanNfc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfdG9fanNfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc190b19zdHJpbmcgKHMpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHMpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9SYWlzZSBleGNlcHRpb25cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9jb25zdGFudCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2NvbnN0YW50ICh0YWcpIHsgdGhyb3cgdGFnOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKHRhZykgeyByZXR1cm4gdGFnOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgYXJnKSB7IHRocm93IFswLCB0YWcsIGFyZ107IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX2FyZ3MgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9hcmdzICh0YWcsIGFyZ3MpIHsgdGhyb3cgWzAsIHRhZ10uY29uY2F0KGFyZ3MpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKHRhZywgbXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhtc2cpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mYWlsd2l0aCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ZhaWx3aXRoIChtc2cpIHtcbiAgaWYoIWNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSlcbiAgICBjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmU9WzI0OCxjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiRmFpbHVyZVwiKSwtM107XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLCBtc2cpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2ludmFsaWRfYXJndW1lbnQgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuSW52YWxpZF9hcmd1bWVudCwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5FbmRfb2ZfZmlsZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRGl2aXNpb25fYnlfemVybyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5Ob3RfZm91bmQpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuIChjb25zdCwgc2hhbGxvdylcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF9jYWxsX2dlbihmLCBhcmdzKSB7XG4gIGlmKGYuZnVuKVxuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuZnVuLCBhcmdzKTtcbiAgLy9GSVhNRSwgY2FuIGhhcHBlbiB3aXRoIHRvbyBtYW55IGFyZ3VtZW50c1xuICBpZih0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZjtcbiAgdmFyIG4gPSBmLmxlbmd0aCB8IDA7XG4gIGlmKG4gPT09IDApIHJldHVybiBmLmFwcGx5KG51bGwsYXJncyk7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGggfCAwO1xuICB2YXIgZCA9IG4gLSBhcmdzTGVuIHwgMDtcbiAgaWYgKGQgPT0gMClcbiAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTtcbiAgZWxzZSBpZiAoZCA8IDApIHtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLmFwcGx5KG51bGwsYXJncy5zbGljZSgwLG4pKSxhcmdzLnNsaWNlKG4pKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCl7XG4gICAgICB2YXIgZXh0cmFfYXJncyA9IChhcmd1bWVudHMubGVuZ3RoID09IDApPzE6YXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCtleHRyYV9hcmdzKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrICkgbmFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIG5hcmdzW2FyZ3MubGVuZ3RoK2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgbmFyZ3MpXG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG52YXIgY2FtbF9uYW1lZF92YWx1ZXMgPSB7fTtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSAoY29uc3QsY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZShubSx2KSB7XG4gIGNhbWxfbmFtZWRfdmFsdWVzW2NhbWxfanNieXRlc19vZl9zdHJpbmcobm0pXSA9IHY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlc1xuZnVuY3Rpb24gY2FtbF9uYW1lZF92YWx1ZShubSkge1xuICByZXR1cm4gY2FtbF9uYW1lZF92YWx1ZXNbbm1dXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbnZhciBjYW1sX2dsb2JhbF9kYXRhID0gWzBdO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAoY29uc3QsIHNoYWxsb3csIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKG4sIHYsIG5hbWVfb3B0KSB7XG4gIGlmKG5hbWVfb3B0ICYmIGdsb2JhbFRoaXMudG9wbGV2ZWxSZWxvYylcbiAgICBuID0gZ2xvYmFsVGhpcy50b3BsZXZlbFJlbG9jKG5hbWVfb3B0KTtcbiAgY2FtbF9nbG9iYWxfZGF0YVtuICsgMV0gPSB2O1xuICBpZihuYW1lX29wdCkgY2FtbF9nbG9iYWxfZGF0YVtuYW1lX29wdF0gPSB2O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9nbG9iYWxfZGF0YSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2dldF9nbG9iYWxfZGF0YSAoKSB7IHJldHVybiBjYW1sX2dsb2JhbF9kYXRhOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfcHJpbnRhYmxlIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfaXNfcHJpbnRhYmxlKGMpIHsgcmV0dXJuICsoYyA+IDMxICYmIGMgPCAxMjcpOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEZvcm1hdFxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2Zvcm1hdFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2Zvcm1hdCAoZm10KSB7XG4gIGZtdCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KTtcbiAgdmFyIGxlbiA9IGZtdC5sZW5ndGg7XG4gIGlmIChsZW4gPiAzMSkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZm9ybWF0X2ludDogZm9ybWF0IHRvbyBsb25nXCIpO1xuICB2YXIgZiA9XG4gICAgICB7IGp1c3RpZnk6JysnLCBzaWduc3R5bGU6Jy0nLCBmaWxsZXI6JyAnLCBhbHRlcm5hdGU6ZmFsc2UsXG4gICAgICAgIGJhc2U6MCwgc2lnbmVkY29udjpmYWxzZSwgd2lkdGg6MCwgdXBwZXJjYXNlOmZhbHNlLFxuICAgICAgICBzaWduOjEsIHByZWM6LTEsIGNvbnY6J2YnIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IGZtdC5jaGFyQXQoaSk7XG4gICAgc3dpdGNoIChjKSB7XG4gICAgY2FzZSAnLSc6XG4gICAgICBmLmp1c3RpZnkgPSAnLSc7IGJyZWFrO1xuICAgIGNhc2UgJysnOiBjYXNlICcgJzpcbiAgICAgIGYuc2lnbnN0eWxlID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnMCc6XG4gICAgICBmLmZpbGxlciA9ICcwJzsgYnJlYWs7XG4gICAgY2FzZSAnIyc6XG4gICAgICBmLmFsdGVybmF0ZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOiBjYXNlICc1JzpcbiAgICBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgIGYud2lkdGggPSAwO1xuICAgICAgd2hpbGUgKGM9Zm10LmNoYXJDb2RlQXQoaSkgLSA0OCwgYyA+PSAwICYmIGMgPD0gOSkge1xuICAgICAgICBmLndpZHRoID0gZi53aWR0aCAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgICBicmVhaztcbiAgICBjYXNlICcuJzpcbiAgICAgIGYucHJlYyA9IDA7XG4gICAgICBpKys7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYucHJlYyA9IGYucHJlYyAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgY2FzZSAnZCc6IGNhc2UgJ2knOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlICd1JzpcbiAgICAgIGYuYmFzZSA9IDEwOyBicmVhaztcbiAgICBjYXNlICd4JzpcbiAgICAgIGYuYmFzZSA9IDE2OyBicmVhaztcbiAgICBjYXNlICdYJzpcbiAgICAgIGYuYmFzZSA9IDE2OyBmLnVwcGVyY2FzZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJ28nOlxuICAgICAgZi5iYXNlID0gODsgYnJlYWs7XG4gICAgY2FzZSAnZSc6IGNhc2UgJ2YnOiBjYXNlICdnJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYuY29udiA9IGM7IGJyZWFrO1xuICAgIGNhc2UgJ0UnOiBjYXNlICdGJzogY2FzZSAnRyc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyBmLnVwcGVyY2FzZSA9IHRydWU7XG4gICAgICBmLmNvbnYgPSBjLnRvTG93ZXJDYXNlICgpOyBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcmF3YnVmZmVyKSB7XG4gIGlmIChmLnVwcGVyY2FzZSkgcmF3YnVmZmVyID0gcmF3YnVmZmVyLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBsZW4gPSByYXdidWZmZXIubGVuZ3RoO1xuICAvKiBBZGp1c3QgbGVuIHRvIHJlZmxlY3QgYWRkaXRpb25hbCBjaGFycyAoc2lnbiwgZXRjKSAqL1xuICBpZiAoZi5zaWduZWRjb252ICYmIChmLnNpZ24gPCAwIHx8IGYuc2lnbnN0eWxlICE9ICctJykpIGxlbisrO1xuICBpZiAoZi5hbHRlcm5hdGUpIHtcbiAgICBpZiAoZi5iYXNlID09IDgpIGxlbiArPSAxO1xuICAgIGlmIChmLmJhc2UgPT0gMTYpIGxlbiArPSAyO1xuICB9XG4gIC8qIERvIHRoZSBmb3JtYXR0aW5nICovXG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICBpZiAoZi5qdXN0aWZ5ID09ICcrJyAmJiBmLmZpbGxlciA9PSAnICcpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcgJztcbiAgaWYgKGYuc2lnbmVkY29udikge1xuICAgIGlmIChmLnNpZ24gPCAwKSBidWZmZXIgKz0gJy0nO1xuICAgIGVsc2UgaWYgKGYuc2lnbnN0eWxlICE9ICctJykgYnVmZmVyICs9IGYuc2lnbnN0eWxlO1xuICB9XG4gIGlmIChmLmFsdGVybmF0ZSAmJiBmLmJhc2UgPT0gOCkgYnVmZmVyICs9ICcwJztcbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSAxNikgYnVmZmVyICs9IFwiMHhcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJzAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnMCc7XG4gIGJ1ZmZlciArPSByYXdidWZmZXI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJy0nKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGJ1ZmZlcik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczoganNvb19mbG9vcl9sb2cyXG52YXIgbG9nMl9vayA9IE1hdGgubG9nMiAmJiBNYXRoLmxvZzIoMS4xMjM1NTgyMDkyODg5NDc0RSszMDcpID09IDEwMjBcbmZ1bmN0aW9uIGpzb29fZmxvb3JfbG9nMih4KSB7XG4gIGlmKGxvZzJfb2spIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nMih4KSlcbiAgdmFyIGkgPSAwO1xuICBpZiAoeCA9PSAwKSByZXR1cm4gLUluZmluaXR5O1xuICBpZih4Pj0xKSB7d2hpbGUgKHg+PTIpIHt4Lz0yOyBpKyt9IH1cbiAgZWxzZSB7d2hpbGUgKHggPCAxKSB7eCo9MjsgaS0tfSB9O1xuICByZXR1cm4gaTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzIsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSlcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgxLCAwLCAweDdmZjApO1xuICAgIGlmICh4ID4gMClcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweDdmZjApXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4ZmZmMClcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzB4ODAwMDooeD49MCk/MDoweDgwMDA7XG4gIGlmIChzaWduKSB4ID0gLXg7XG4gIC8vIEludDY0LmJpdHNfb2ZfZmxvYXQgMS4xMjM1NTgyMDkyODg5NDc0RSszMDcgPSAweDdmYjAwMDAwMDAwMDAwMDBMXG4gIC8vIHVzaW5nIE1hdGguTE9HMkUqTWF0aC5sb2coeCkgaW4gcGxhY2Ugb2YgTWF0aC5sb2cyIHJlc3VsdCBpbiBwcmVjaXNpb24gbG9zdFxuICB2YXIgZXhwID0ganNvb19mbG9vcl9sb2cyKHgpICsgMTAyMztcbiAgaWYgKGV4cCA8PSAwKSB7XG4gICAgZXhwID0gMDtcbiAgICB4IC89IE1hdGgucG93KDIsLTEwMjYpO1xuICB9IGVsc2Uge1xuICAgIHggLz0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gICAgaWYgKHggPCAxNikge1xuICAgICAgeCAqPSAyOyBleHAgLT0xOyB9XG4gICAgaWYgKGV4cCA9PSAwKSB7XG4gICAgICB4IC89IDI7IH1cbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsMjQpO1xuICB2YXIgcjMgPSB4fDA7XG4gIHggPSAoeCAtIHIzKSAqIGs7XG4gIHZhciByMiA9IHh8MDtcbiAgeCA9ICh4IC0gcjIpICogaztcbiAgdmFyIHIxID0geHwwO1xuICByMyA9IChyMyAmMHhmKSB8IHNpZ24gfCBleHAgPDwgNDtcbiAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKHIxLCByMiwgcjMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBnbG9iYWxUaGlzLkZsb2F0MzJBcnJheSgxKTtcbiAgZmxvYXQzMmFbMF0gPSB4O1xuICB2YXIgaW50MzJhID0gbmV3IGdsb2JhbFRoaXMuSW50MzJBcnJheShmbG9hdDMyYS5idWZmZXIpO1xuICByZXR1cm4gaW50MzJhWzBdIHwgMDtcbn1cblxuLy9GUCBsaXRlcmFscyBjYW4gYmUgd3JpdHRlbiB1c2luZyB0aGUgaGV4YWRlY2ltYWxcbi8vbm90YXRpb24gMHg8bWFudGlzc2EgaW4gaGV4PnA8ZXhwb25lbnQ+IGZyb20gSVNPIEM5OS5cbi8vaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWhleGZsb2F0L2Jsb2IvbWFzdGVyL2hleGZsb2F0LmpzXG4vL1Byb3ZpZGVzOiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcsIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQgKHgsIHByZWMsIHN0eWxlKSB7XG4gIGlmICghaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoaXNOYU4oeCkpIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhcIm5hblwiKTtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKCh4ID4gMCk/XCJpbmZpbml0eVwiOlwiLWluZmluaXR5XCIpO1xuICB9XG4gIHZhciBzaWduID0gKHg9PTAgJiYgMS94ID09IC1JbmZpbml0eSk/MTooeD49MCk/MDoxO1xuICBpZihzaWduKSB4ID0gLXg7XG4gIHZhciBleHAgPSAwO1xuICBpZiAoeCA9PSAwKSB7IH1cbiAgZWxzZSBpZiAoeCA8IDEpIHtcbiAgICB3aGlsZSAoeCA8IDEgJiYgZXhwID4gLTEwMjIpICB7IHggKj0gMjsgZXhwLS0gfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlICh4ID49IDIpIHsgeCAvPSAyOyBleHArKyB9XG4gIH1cbiAgdmFyIGV4cF9zaWduID0gZXhwIDwgMCA/ICcnIDogJysnO1xuICB2YXIgc2lnbl9zdHIgPSAnJztcbiAgaWYgKHNpZ24pIHNpZ25fc3RyID0gJy0nXG4gIGVsc2Uge1xuICAgIHN3aXRjaChzdHlsZSl7XG4gICAgY2FzZSA0MyAvKiAnKycgKi86IHNpZ25fc3RyID0gJysnOyBicmVhaztcbiAgICBjYXNlIDMyIC8qICcgJyAqLzogc2lnbl9zdHIgPSAnICc7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAocHJlYyA+PSAwICYmIHByZWMgPCAxMykge1xuICAgIC8qIElmIGEgcHJlY2lzaW9uIGlzIGdpdmVuLCBhbmQgaXMgc21hbGwsIHJvdW5kIG1hbnRpc3NhIGFjY29yZGluZ2x5ICovXG4gICAgdmFyIGNzdCA9IE1hdGgucG93KDIscHJlYyAqIDQpO1xuICAgIHggPSBNYXRoLnJvdW5kKHggKiBjc3QpIC8gY3N0O1xuICB9XG4gIHZhciB4X3N0ciA9IHgudG9TdHJpbmcoMTYpO1xuICBpZihwcmVjID49IDApe1xuICAgIHZhciBpZHggPSB4X3N0ci5pbmRleE9mKCcuJyk7XG4gICAgaWYoaWR4PDApIHtcbiAgICAgIHhfc3RyICs9ICcuJyArIGNhbWxfc3RyX3JlcGVhdChwcmVjLCAnMCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzaXplID0gaWR4KzErcHJlYztcbiAgICAgIGlmKHhfc3RyLmxlbmd0aCA8IHNpemUpXG4gICAgICAgIHhfc3RyICs9IGNhbWxfc3RyX3JlcGVhdChzaXplIC0geF9zdHIubGVuZ3RoLCAnMCcpO1xuICAgICAgZWxzZVxuICAgICAgICB4X3N0ciA9IHhfc3RyLnN1YnN0cigwLHNpemUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHNpZ25fc3RyICsgJzB4JyArIHhfc3RyICsgJ3AnICsgZXhwX3NpZ24gKyBleHAudG9TdHJpbmcoMTApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGxvID0geC5sbztcbiAgdmFyIG1pID0geC5taTtcbiAgdmFyIGhpID0geC5oaTtcbiAgdmFyIGV4cCA9IChoaSAmIDB4N2ZmZikgPj4gNDtcbiAgaWYgKGV4cCA9PSAyMDQ3KSB7XG4gICAgaWYgKChsb3xtaXwoaGkmMHhmKSkgPT0gMClcbiAgICAgIHJldHVybiAoaGkgJiAweDgwMDApPygtSW5maW5pdHkpOkluZmluaXR5O1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBOYU47XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLC0yNCk7XG4gIHZhciByZXMgPSAobG8qayttaSkqaysoaGkmMHhmKTtcbiAgaWYgKGV4cCA+IDApIHtcbiAgICByZXMgKz0gMTY7XG4gICAgcmVzICo9IE1hdGgucG93KDIsZXhwLTEwMjcpO1xuICB9IGVsc2VcbiAgICByZXMgKj0gTWF0aC5wb3coMiwtMTAyNik7XG4gIGlmIChoaSAmIDB4ODAwMCkgcmVzID0gLSByZXM7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV4dGFmdGVyX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfc3ViLGNhbWxfaW50NjRfb2ZfaW50MzJcbmZ1bmN0aW9uIGNhbWxfbmV4dGFmdGVyX2Zsb2F0ICh4LHkpIHtcbiAgaWYoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybiBOYU47XG4gIGlmKHg9PXkpIHJldHVybiB5O1xuICBpZih4PT0wKXtcbiAgICBpZih5IDwgMClcbiAgICAgIHJldHVybiAtTWF0aC5wb3coMiwgLTEwNzQpXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE1hdGgucG93KDIsIC0xMDc0KVxuICB9XG4gIHZhciBiaXRzID0gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHgpO1xuICB2YXIgb25lID0gY2FtbF9pbnQ2NF9vZl9pbnQzMigxKTtcbiAgaWYgKCh4PHkpID09ICh4PjApKVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X2FkZChiaXRzLCBvbmUpXG4gIGVsc2VcbiAgICBiaXRzID0gY2FtbF9pbnQ2NF9zdWIoYml0cywgb25lKVxuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGJpdHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RydW5jX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX3RydW5jX2Zsb2F0KHgpe1xuICByZXR1cm4gTWF0aC50cnVuYyh4KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGludDMyYSA9IG5ldyBnbG9iYWxUaGlzLkludDMyQXJyYXkoMSk7XG4gIGludDMyYVswXSA9IHg7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBnbG9iYWxUaGlzLkZsb2F0MzJBcnJheShpbnQzMmEuYnVmZmVyKTtcbiAgcmV0dXJuIGZsb2F0MzJhWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NsYXNzaWZ5X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NsYXNzaWZ5X2Zsb2F0ICh4KSB7XG4gIGlmIChpc0Zpbml0ZSAoeCkpIHtcbiAgICBpZiAoTWF0aC5hYnMoeCkgPj0gMi4yMjUwNzM4NTg1MDcyMDE0ZS0zMDgpIHJldHVybiAwO1xuICAgIGlmICh4ICE9IDApIHJldHVybiAxO1xuICAgIHJldHVybiAyO1xuICB9XG4gIHJldHVybiBpc05hTih4KT80OjM7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX21vZGZfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbW9kZl9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgdmFyIG5lZyA9ICgxL3gpIDwgMDtcbiAgICB4ID0gTWF0aC5hYnMoeCk7XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yICh4KTtcbiAgICB2YXIgZiA9IHggLSBpO1xuICAgIGlmIChuZWcpIHsgaSA9IC1pOyBmID0gLWY7IH1cbiAgICByZXR1cm4gWzAsIGYsIGldO1xuICB9XG4gIGlmIChpc05hTiAoeCkpIHJldHVybiBbMCwgTmFOLCBOYU5dO1xuICByZXR1cm4gWzAsIDEveCwgeF07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2xkZXhwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xkZXhwX2Zsb2F0ICh4LGV4cCkge1xuICBleHAgfD0gMDtcbiAgaWYgKGV4cCA+IDEwMjMpIHtcbiAgICBleHAgLT0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIGlmIChleHAgPiAxMDIzKSB7ICAvLyBpbiBjYXNlIHggaXMgc3Vibm9ybWFsXG4gICAgICBleHAgLT0gMTAyMztcbiAgICAgIHggKj0gTWF0aC5wb3coMiwgMTAyMyk7XG4gICAgfVxuICB9XG4gIGlmIChleHAgPCAtMTAyMykge1xuICAgIGV4cCArPSAxMDIzO1xuICAgIHggKj0gTWF0aC5wb3coMiwgLTEwMjMpO1xuICB9XG4gIHggKj0gTWF0aC5wb3coMiwgZXhwKTtcbiAgcmV0dXJuIHg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXhwX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfZnJleHBfZmxvYXQgKHgpIHtcbiAgaWYgKCh4ID09IDApIHx8ICFpc0Zpbml0ZSh4KSkgcmV0dXJuIFswLCB4LCAwXTtcbiAgdmFyIG5lZyA9IHggPCAwO1xuICBpZiAobmVnKSB4ID0gLSB4O1xuICB2YXIgZXhwID0gTWF0aC5tYXgoLTEwMjMsIGpzb29fZmxvb3JfbG9nMih4KSArIDEpO1xuICB4ICo9IE1hdGgucG93KDIsLWV4cCk7XG4gIHdoaWxlICh4IDwgMC41KSB7XG4gICAgeCAqPSAyO1xuICAgIGV4cC0tO1xuICB9XG4gIHdoaWxlICh4ID49IDEpIHtcbiAgICB4ICo9IDAuNTtcbiAgICBleHArKztcbiAgfVxuICBpZiAobmVnKSB4ID0gLSB4O1xuICByZXR1cm4gWzAsIHgsIGV4cF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9mbG9hdF9jb21wYXJlICh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSByZXR1cm4gMDtcbiAgaWYgKHggPCB5KSByZXR1cm4gLTE7XG4gIGlmICh4ID4geSkgcmV0dXJuIDE7XG4gIGlmICh4ID09PSB4KSByZXR1cm4gMTtcbiAgaWYgKHkgPT09IHkpIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29weXNpZ25fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29weXNpZ25fZmxvYXQgKHgsIHkpIHtcbiAgaWYgKHkgPT0gMCkgeSA9IDEgLyB5O1xuICB4ID0gTWF0aC5hYnMoeCk7XG4gIHJldHVybiAoeSA8IDApPygteCk6eDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zaWduYml0X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpZ25iaXRfZmxvYXQoeCkge1xuICBpZiAoeCA9PSAwKSB4ID0gMSAvIHg7XG4gIHJldHVybiAoeCA8IDApPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9leHBtMV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9leHBtMV9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5leHBtMSh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9leHAyX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2V4cDJfZmxvYXQoeCkgeyByZXR1cm4gTWF0aC5wb3coMiwgeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMXBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMXBfZmxvYXQoeCkgeyByZXR1cm4gTWF0aC5sb2cxcCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9sb2cyX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzJfZmxvYXQoeCkgeyByZXR1cm4gTWF0aC5sb2cyKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2h5cG90X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2h5cG90X2Zsb2F0ICh4LCB5KSB7IHJldHVybiBNYXRoLmh5cG90KHgsIHkpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzEwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzEwX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmxvZzEwKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2Nvc2hfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29zaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5jb3NoKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2Fjb3NoX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Fjb3NoX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmFjb3NoKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3NpbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc2luaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5zaW5oKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2FzaW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2FzaW5oX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmFzaW5oKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3RhbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfdGFuaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC50YW5oKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2F0YW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2F0YW5oX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmF0YW5oKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3JvdW5kX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3JvdW5kX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2NicnRfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY2JydF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5jYnJ0KHgpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXJmX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2VyZl9mbG9hdCh4KSB7XG4gIHZhciBhMSA9IDAuMjU0ODI5NTkyO1xuICB2YXIgYTIgPSAtMC4yODQ0OTY3MzY7XG4gIHZhciBhMyA9IDEuNDIxNDEzNzQxO1xuICB2YXIgYTQgPSAtMS40NTMxNTIwMjc7XG4gIHZhciBhNSA9IDEuMDYxNDA1NDI5O1xuICB2YXIgcCA9IDAuMzI3NTkxMTtcblxuICB2YXIgc2lnbiA9IDE7XG4gIGlmICh4IDwgMCkge1xuICAgIHNpZ24gPSAtMTtcbiAgfVxuICB4ID0gTWF0aC5hYnMoeCk7XG4gIHZhciB0ID0gMS4wIC8gKDEuMCArIHAgKiB4KTtcbiAgdmFyIHkgPSAxLjAgLSAoKCgoYTUgKiB0ICsgYTQpICogdCArIGEzKSAqIHQgKyBhMikgKiB0ICsgYTEpICogdCAqIE1hdGguZXhwKC14ICogeCk7XG5cbiAgcmV0dXJuIHNpZ24gKiB5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VyZmNfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfZXJmX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2VyZmNfZmxvYXQoeCkge1xuICByZXR1cm4gMSAtIGNhbWxfZXJmX2Zsb2F0KHgpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZm1hX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZtYV9mbG9hdCh4LCB5LCB6KSB7XG4gIHZhciBTUExJVCA9IE1hdGgucG93KDIsIDI3KSArIDE7XG4gIHZhciBNSU5fVkFMVUUgPSBNYXRoLnBvdygyLCAtMTAyMik7XG4gIHZhciBFUFNJTE9OID0gTWF0aC5wb3coMiwgLTUyKTtcbiAgdmFyIEMgPSA0MTY7XG4gIHZhciBBID0gTWF0aC5wb3coMiwgK0MpO1xuICB2YXIgQiA9IE1hdGgucG93KDIsIC1DKTtcblxuICBmdW5jdGlvbiBtdWx0aXBseSAoYSwgYikge1xuICAgIHZhciBhdCA9IFNQTElUICogYTtcbiAgICB2YXIgYWhpID0gYXQgLSAoYXQgLSBhKTtcbiAgICB2YXIgYWxvID0gYSAtIGFoaTtcbiAgICB2YXIgYnQgPSBTUExJVCAqIGI7XG4gICAgdmFyIGJoaSA9IGJ0IC0gKGJ0IC0gYik7XG4gICAgdmFyIGJsbyA9IGIgLSBiaGk7XG4gICAgdmFyIHAgPSBhICogYjtcbiAgICB2YXIgZSA9ICgoYWhpICogYmhpIC0gcCkgKyBhaGkgKiBibG8gKyBhbG8gKiBiaGkpICsgYWxvICogYmxvO1xuICAgIHJldHVybiB7XG4gICAgICBwOiBwLFxuICAgICAgZTogZVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gYWRkIChhLCBiKSB7XG4gICAgdmFyIHMgPSBhICsgYjtcbiAgICB2YXIgdiA9IHMgLSBhO1xuICAgIHZhciBlID0gKGEgLSAocyAtIHYpKSArIChiIC0gdik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHM6IHMsXG4gICAgICBlOiBlXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBhZGp1c3QgKHgsIHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCAmJiB5ICE9PSAwICYmIFNQTElUICogeCAtIChTUExJVCAqIHggLSB4KSA9PT0geCA/IHggKiAoMSArICh4IDwgMCA/IC0xIDogKzEpICogKHkgPCAwID8gLTEgOiArMSkgKiBFUFNJTE9OKSA6IHg7XG4gIH07XG5cbiAgaWYgKHggPT09IDAgfHwgeCAhPT0geCB8fCB4ID09PSArMSAvIDAgfHwgeCA9PT0gLTEgLyAwIHx8XG4gICAgICB5ID09PSAwIHx8IHkgIT09IHkgfHwgeSA9PT0gKzEgLyAwIHx8IHkgPT09IC0xIC8gMCkge1xuICAgIHJldHVybiB4ICogeSArIHo7XG4gIH1cbiAgaWYgKHogPT09IDApIHtcbiAgICByZXR1cm4geCAqIHk7XG4gIH1cbiAgaWYgKHogIT09IHogfHwgeiA9PT0gKzEgLyAwIHx8IHogPT09IC0xIC8gMCkge1xuICAgIHJldHVybiB6O1xuICB9XG5cbiAgdmFyIHNjYWxlID0gMTtcbiAgd2hpbGUgKE1hdGguYWJzKHgpID4gQSkge1xuICAgIHNjYWxlICo9IEE7XG4gICAgeCAqPSBCO1xuICB9XG4gIHdoaWxlIChNYXRoLmFicyh5KSA+IEEpIHtcbiAgICBzY2FsZSAqPSBBO1xuICAgIHkgKj0gQjtcbiAgfVxuICBpZiAoc2NhbGUgPT09IDEgLyAwKSB7XG4gICAgcmV0dXJuIHggKiB5ICogc2NhbGU7XG4gIH1cbiAgd2hpbGUgKE1hdGguYWJzKHgpIDwgQikge1xuICAgIHNjYWxlICo9IEI7XG4gICAgeCAqPSBBO1xuICB9XG4gIHdoaWxlIChNYXRoLmFicyh5KSA8IEIpIHtcbiAgICBzY2FsZSAqPSBCO1xuICAgIHkgKj0gQTtcbiAgfVxuICBpZiAoc2NhbGUgPT09IDApIHtcbiAgICByZXR1cm4gejtcbiAgfVxuXG4gIHZhciB4cyA9IHg7XG4gIHZhciB5cyA9IHk7XG4gIHZhciB6cyA9IHogLyBzY2FsZTtcblxuICBpZiAoTWF0aC5hYnMoenMpID4gTWF0aC5hYnMoeHMgKiB5cykgKiA0IC8gRVBTSUxPTikge1xuICAgIHJldHVybiB6O1xuICB9XG4gIGlmIChNYXRoLmFicyh6cykgPCBNYXRoLmFicyh4cyAqIHlzKSAqIEVQU0lMT04gLyA0ICogRVBTSUxPTiAvIDQpIHtcbiAgICB6cyA9ICh6IDwgMCA/IC0xIDogKzEpICogTUlOX1ZBTFVFO1xuICB9XG5cbiAgdmFyIHh5ID0gbXVsdGlwbHkoeHMsIHlzKTtcbiAgdmFyIHMgPSBhZGQoeHkucCwgenMpO1xuICB2YXIgdSA9IGFkZCh4eS5lLCBzLmUpO1xuICB2YXIgaSA9IGFkZChzLnMsIHUucyk7XG5cbiAgdmFyIGYgPSBpLnMgKyBhZGp1c3QoaS5lLCB1LmUpO1xuICBpZiAoZiA9PT0gMCkge1xuICAgIHJldHVybiBmO1xuICB9XG5cbiAgdmFyIGZzID0gZiAqIHNjYWxlO1xuICBpZiAoTWF0aC5hYnMoZnMpID4gTUlOX1ZBTFVFKSB7XG4gICAgcmV0dXJuIGZzO1xuICB9XG5cbiAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCB0aGVyZSB3YXMgZXh0cmEgcm91bmRpbmcgZm9yIGEgZGVub3JtYWxpemVkIHZhbHVlLlxuICByZXR1cm4gZnMgKyBhZGp1c3QoZiAtIGZzIC8gc2NhbGUsIGkuZSkgKiBzY2FsZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9mbG9hdCAoZm10LCB4KSB7XG4gIGZ1bmN0aW9uIHRvRml4ZWQoeCxkcCkge1xuICAgIGlmIChNYXRoLmFicyh4KSA8IDEuMCkge1xuICAgICAgcmV0dXJuIHgudG9GaXhlZChkcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlID0gcGFyc2VJbnQoeC50b1N0cmluZygpLnNwbGl0KCcrJylbMV0pO1xuICAgICAgaWYgKGUgPiAyMCkge1xuICAgICAgICBlIC09IDIwO1xuICAgICAgICB4IC89IE1hdGgucG93KDEwLGUpO1xuICAgICAgICB4ICs9IChuZXcgQXJyYXkoZSsxKSkuam9pbignMCcpO1xuICAgICAgICBpZihkcCA+IDApIHtcbiAgICAgICAgICB4ID0geCArICcuJyArIChuZXcgQXJyYXkoZHArMSkpLmpvaW4oJzAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICAgIGVsc2UgcmV0dXJuIHgudG9GaXhlZChkcClcbiAgICB9XG4gIH1cbiAgdmFyIHMsIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICB2YXIgcHJlYyA9IChmLnByZWMgPCAwKT82OmYucHJlYztcbiAgaWYgKHggPCAwIHx8ICh4ID09IDAgJiYgMS94ID09IC1JbmZpbml0eSkpIHsgZi5zaWduID0gLTE7IHggPSAteDsgfVxuICBpZiAoaXNOYU4oeCkpIHsgcyA9IFwibmFuXCI7IGYuZmlsbGVyID0gJyAnOyB9XG4gIGVsc2UgaWYgKCFpc0Zpbml0ZSh4KSkgeyBzID0gXCJpbmZcIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZVxuICAgIHN3aXRjaCAoZi5jb252KSB7XG4gICAgY2FzZSAnZSc6XG4gICAgICB2YXIgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjKTtcbiAgICAgIC8vIGV4cG9uZW50IHNob3VsZCBiZSBhdCBsZWFzdCB0d28gZGlnaXRzXG4gICAgICB2YXIgaSA9IHMubGVuZ3RoO1xuICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgIHMgPSBzLnNsaWNlICgwLCBpIC0gMSkgKyAnMCcgKyBzLnNsaWNlIChpIC0gMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmJzpcbiAgICAgIHMgPSB0b0ZpeGVkKHgsIHByZWMpOyBicmVhaztcbiAgICBjYXNlICdnJzpcbiAgICAgIHByZWMgPSBwcmVjP3ByZWM6MTtcbiAgICAgIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyAtIDEpO1xuICAgICAgdmFyIGogPSBzLmluZGV4T2YoJ2UnKTtcbiAgICAgIHZhciBleHAgPSArcy5zbGljZShqICsgMSk7XG4gICAgICBpZiAoZXhwIDwgLTQgfHwgeCA+PSAxZTIxIHx8IHgudG9GaXhlZCgwKS5sZW5ndGggPiBwcmVjKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgdmFyIGkgPSBqIC0gMTsgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykgaS0tO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKSArIHMuc2xpY2Uoaik7XG4gICAgICAgIGkgPSBzLmxlbmd0aDtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcCA9IHByZWM7XG4gICAgICAgIGlmIChleHAgPCAwKSB7IHAgLT0gZXhwICsgMTsgcyA9IHgudG9GaXhlZChwKTsgfVxuICAgICAgICBlbHNlIHdoaWxlIChzID0geC50b0ZpeGVkKHApLCBzLmxlbmd0aCA+IHByZWMgKyAxKSBwLS07XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICAgIHZhciBpID0gcy5sZW5ndGggLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgICAgaWYgKHMuY2hhckF0KGkpID09ICcuJykgaS0tO1xuICAgICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9zdHJpbmcocykge1xuICB2YXIgcmVzO1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKVxuICByZXMgPSArcztcbiAgaWYgKChzLmxlbmd0aCA+IDApICYmIChyZXMgPT09IHJlcykpIHJldHVybiByZXM7XG4gIHMgPSBzLnJlcGxhY2UoL18vZyxcIlwiKTtcbiAgcmVzID0gK3M7XG4gIGlmICgoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgfHwgL15bKy1dP25hbiQvaS50ZXN0KHMpKSByZXR1cm4gcmVzO1xuICB2YXIgbSA9IC9eICooWystXT8pMHgoWzAtOWEtZl0rKVxcLj8oWzAtOWEtZl0qKShwKFsrLV0/WzAtOV0rKSk/L2kuZXhlYyhzKTtcbiAgLy8gICAgICAgICAgMSAgICAgICAgMiAgICAgICAgICAgICAzICAgICAgICAgICA1XG4gIGlmKG0pe1xuICAgIHZhciBtMyA9IG1bM10ucmVwbGFjZSgvMCskLywnJyk7XG4gICAgdmFyIG1hbnRpc3NhID0gcGFyc2VJbnQobVsxXSArIG1bMl0gKyBtMywgMTYpO1xuICAgIHZhciBleHBvbmVudCA9IChtWzVdfDApIC0gNCptMy5sZW5ndGg7XG4gICAgcmVzID0gbWFudGlzc2EgKiBNYXRoLnBvdygyLCBleHBvbmVudCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZigvXlxcKz9pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gSW5maW5pdHk7XG4gIGlmKC9eLWluZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiAtSW5maW5pdHk7XG4gIGNhbWxfZmFpbHdpdGgoXCJmbG9hdF9vZl9zdHJpbmdcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gZnNfbm9kZV9zdXBwb3J0ZWQgKCkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBnbG9iYWxUaGlzLnByb2Nlc3MgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzLnZlcnNpb25zICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGdsb2JhbFRoaXMucHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSAndW5kZWZpbmVkJylcbn1cbi8vUHJvdmlkZXM6IGZzX25vZGVfc3VwcG9ydGVkXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBmc19ub2RlX3N1cHBvcnRlZCAoKSB7XG4gIHJldHVybiBmYWxzZVxufVxuXG5cbi8vUHJvdmlkZXM6IE1sTm9kZURldmljZVxuLy9SZXF1aXJlczogTWxOb2RlRmlsZSwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfcmFpc2Vfd2l0aF9hcmdzXG4vL1JlcXVpcmVzOiBtYWtlX3VuaXhfZXJyX2FyZ3MsIGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG5mdW5jdGlvbiBNbE5vZGVEZXZpY2Uocm9vdCkge1xuICB0aGlzLmZzID0gcmVxdWlyZSgnZnMnKTtcbiAgdGhpcy5yb290ID0gcm9vdDtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUubm0gPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiAodGhpcy5yb290ICsgbmFtZSk7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5leGlzdHNTeW5jKHRoaXMubm0obmFtZSkpPzE6MDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUubWtkaXIgPSBmdW5jdGlvbihuYW1lLCBtb2RlLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5ta2RpclN5bmModGhpcy5ubShuYW1lKSx7bW9kZTptb2RlfSk7XG4gICAgcmV0dXJuIDBcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ybWRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJtZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgICByZXR1cm4gMFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlYWRkaXIgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMucmVhZGRpclN5bmModGhpcy5ubShuYW1lKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLnN0YXRTeW5jKHRoaXMubm0obmFtZSkpLmlzRGlyZWN0b3J5KCk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBiID0gdGhpcy5mcy5leGlzdHNTeW5jKHRoaXMubm0obmFtZSkpPzE6MDtcbiAgICB0aGlzLmZzLnVubGlua1N5bmModGhpcy5ubShuYW1lKSk7XG4gICAgcmV0dXJuIGI7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIGNvbnN0cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpO1xuICB2YXIgcmVzID0gMDtcbiAgZm9yKHZhciBrZXkgaW4gZil7XG4gICAgc3dpdGNoKGtleSl7XG4gICAgY2FzZSBcInJkb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19SRE9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJ3cm9ubHlcIiAgOiByZXMgfD0gY29uc3RzLk9fV1JPTkxZOyBicmVhaztcbiAgICBjYXNlIFwiYXBwZW5kXCIgIDpcbiAgICAgIHJlcyB8PSBjb25zdHMuT19XUk9OTFkgfCBjb25zdHMuT19BUFBFTkQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY3JlYXRlXCIgICA6IHJlcyB8PSBjb25zdHMuT19DUkVBVDsgICAgYnJlYWs7XG4gICAgY2FzZSBcInRydW5jYXRlXCIgOiByZXMgfD0gY29uc3RzLk9fVFJVTkM7ICAgIGJyZWFrO1xuICAgIGNhc2UgXCJleGNsXCIgICAgIDogcmVzIHw9IGNvbnN0cy5PX0VYQ0w7ICAgICBicmVhaztcbiAgICBjYXNlIFwiYmluYXJ5XCIgICA6IHJlcyB8PSBjb25zdHMuT19CSU5BUlk7ICAgYnJlYWs7XG4gICAgY2FzZSBcInRleHRcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fVEVYVDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJub25ibG9ja1wiIDogcmVzIHw9IGNvbnN0cy5PX05PTkJMT0NLOyBicmVhaztcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgZmQgPSB0aGlzLmZzLm9wZW5TeW5jKHRoaXMubm0obmFtZSksIHJlcyk7XG4gICAgcmV0dXJuIG5ldyBNbE5vZGVGaWxlKGZkKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uKG8sIG4sIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlbmFtZVN5bmModGhpcy5ubShvKSwgdGhpcy5ubShuKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuc3RhdCA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB2YXIganNfc3RhdHMgPSB0aGlzLmZzLnN0YXRTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiB0aGlzLnN0YXRzX2Zyb21fanMoanNfc3RhdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmxzdGF0ID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBqc19zdGF0cyA9IHRoaXMuZnMubHN0YXRTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiB0aGlzLnN0YXRzX2Zyb21fanMoanNfc3RhdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnN5bWxpbmsgPSBmdW5jdGlvbih0b19kaXIsIHRhcmdldCwgcGF0aCwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMuc3ltbGlua1N5bmModGhpcy5ubSh0YXJnZXQpLCB0aGlzLm5tKHBhdGgpLCB0b19kaXIgPyAnZGlyJyA6ICdmaWxlJyk7XG4gICAgcmV0dXJuIDA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGxpbmsgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGxpbmsgPSB0aGlzLmZzLnJlYWRsaW5rU3luYyh0aGlzLm5tKG5hbWUpLCAndXRmOCcpO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhsaW5rKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yYWlzZV9ub2RlanNfZXJyb3IgPSBmdW5jdGlvbihlcnIsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSBjYW1sX25hbWVkX3ZhbHVlKFwiVW5peC5Vbml4X2Vycm9yXCIpO1xuICBpZiAocmFpc2VfdW5peCAmJiB1bml4X2Vycm9yKSB7XG4gICAgdmFyIGFyZ3MgPSBtYWtlX3VuaXhfZXJyX2FyZ3MoZXJyLmNvZGUsIGVyci5zeXNjYWxsLCBlcnIucGF0aCwgZXJyLmVycm5vKTtcbiAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuc3RhdHNfZnJvbV9qcyA9IGZ1bmN0aW9uKGpzX3N0YXRzKSB7XG4gIC8qID09PVVuaXguZmlsZV9raW5kPT09XG4gICAqIHR5cGUgZmlsZV9raW5kID1cbiAgICogICAgIFNfUkVHICAgICAgICAgICAgICAgICAgICAgICAoKiogUmVndWxhciBmaWxlICopXG4gICAqICAgfCBTX0RJUiAgICAgICAgICAgICAgICAgICAgICAgKCoqIERpcmVjdG9yeSAqKVxuICAgKiAgIHwgU19DSFIgICAgICAgICAgICAgICAgICAgICAgICgqKiBDaGFyYWN0ZXIgZGV2aWNlICopXG4gICAqICAgfCBTX0JMSyAgICAgICAgICAgICAgICAgICAgICAgKCoqIEJsb2NrIGRldmljZSAqKVxuICAgKiAgIHwgU19MTksgICAgICAgICAgICAgICAgICAgICAgICgqKiBTeW1ib2xpYyBsaW5rICopXG4gICAqICAgfCBTX0ZJRk8gICAgICAgICAgICAgICAgICAgICAgKCoqIE5hbWVkIHBpcGUgKilcbiAgICogICB8IFNfU09DSyAgICAgICAgICAgICAgICAgICAgICAoKiogU29ja2V0ICopXG4gICAqL1xuICB2YXIgZmlsZV9raW5kO1xuICBpZiAoanNfc3RhdHMuaXNGaWxlKCkpIHtcbiAgICBmaWxlX2tpbmQgPSAwO1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICBmaWxlX2tpbmQgPSAxO1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzQ2hhcmFjdGVyRGV2aWNlKCkpIHtcbiAgICBmaWxlX2tpbmQgPSAyO1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzQmxvY2tEZXZpY2UoKSkge1xuICAgIGZpbGVfa2luZCA9IDM7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgIGZpbGVfa2luZCA9IDQ7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNGSUZPKCkpIHtcbiAgICBmaWxlX2tpbmQgPSA1O1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzU29ja2V0KCkpIHtcbiAgICBmaWxlX2tpbmQgPSA2O1xuICB9XG4gIC8qID09PVVuaXguc3RhdHM9PT1cbiAgICogdHlwZSBzdGF0cyA9XG4gICAqICB7IHN0X2RldiA6IGludDsgICAgICAgICAgICAgICAoKiogRGV2aWNlIG51bWJlciAqKVxuICAgKiAgICBzdF9pbm8gOiBpbnQ7ICAgICAgICAgICAgICAgKCoqIElub2RlIG51bWJlciAqKVxuICAgKiAgICBzdF9raW5kIDogZmlsZV9raW5kOyAgICAgICAgKCoqIEtpbmQgb2YgdGhlIGZpbGUgKilcbiAgICogICAgc3RfcGVybSA6IGZpbGVfcGVybTsgICAgICAgICgqKiBBY2Nlc3MgcmlnaHRzICopXG4gICAqICAgIHN0X25saW5rIDogaW50OyAgICAgICAgICAgICAoKiogTnVtYmVyIG9mIGxpbmtzICopXG4gICAqICAgIHN0X3VpZCA6IGludDsgICAgICAgICAgICAgICAoKiogVXNlciBpZCBvZiB0aGUgb3duZXIgKilcbiAgICogICAgc3RfZ2lkIDogaW50OyAgICAgICAgICAgICAgICgqKiBHcm91cCBJRCBvZiB0aGUgZmlsZSdzIGdyb3VwICopXG4gICAqICAgIHN0X3JkZXYgOiBpbnQ7ICAgICAgICAgICAgICAoKiogRGV2aWNlIElEIChpZiBzcGVjaWFsIGZpbGUpICopXG4gICAqICAgIHN0X3NpemUgOiBpbnQ7ICAgICAgICAgICAgICAoKiogU2l6ZSBpbiBieXRlcyAqKVxuICAgKiAgICBzdF9hdGltZSA6IGZsb2F0OyAgICAgICAgICAgKCoqIExhc3QgYWNjZXNzIHRpbWUgKilcbiAgICogICAgc3RfbXRpbWUgOiBmbG9hdDsgICAgICAgICAgICgqKiBMYXN0IG1vZGlmaWNhdGlvbiB0aW1lICopXG4gICAqICAgIHN0X2N0aW1lIDogZmxvYXQ7ICAgICAgICAgICAoKiogTGFzdCBzdGF0dXMgY2hhbmdlIHRpbWUgKilcbiAgICogIH1cbiAgICovXG4gIHJldHVybiBCTE9DSyhcbiAgICAwLFxuICAgIGpzX3N0YXRzLmRldixcbiAgICBqc19zdGF0cy5pbm8sXG4gICAgZmlsZV9raW5kLFxuICAgIGpzX3N0YXRzLm1vZGUsXG4gICAganNfc3RhdHMubmxpbmssXG4gICAganNfc3RhdHMudWlkLFxuICAgIGpzX3N0YXRzLmdpZCxcbiAgICBqc19zdGF0cy5yZGV2LFxuICAgIGpzX3N0YXRzLnNpemUsXG4gICAganNfc3RhdHMuYXRpbWVNcyxcbiAgICBqc19zdGF0cy5tdGltZU1zLFxuICAgIGpzX3N0YXRzLmN0aW1lTXNcbiAgKTtcbn1cblxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZURldmljZVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVEZXZpY2Vcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIE1sTm9kZURldmljZSgpIHtcbn1cblxuLy9Qcm92aWRlczogTWxOb2RlRmlsZVxuLy9SZXF1aXJlczogTWxGaWxlLCBjYW1sX2FycmF5X29mX3N0cmluZywgY2FtbF9hcnJheV9vZl9ieXRlcywgY2FtbF9ieXRlc19zZXQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBNbE5vZGVGaWxlKGZkKXtcbiAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHRoaXMuZmQgPSBmZDtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcblxuTWxOb2RlRmlsZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB0cnkge1xuICAgIHRoaXMuZnMuZnRydW5jYXRlU3luYyh0aGlzLmZkLGxlbnwwKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5mc3RhdFN5bmModGhpcy5mZCkuc2l6ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYsYnVmX29mZnNldCxsZW4pe1xuICB2YXIgYSA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKGJ1Zik7XG4gIGlmKCEgKGEgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLlVpbnQ4QXJyYXkpKVxuICAgIGEgPSBuZXcgZ2xvYmFsVGhpcy5VaW50OEFycmF5KGEpO1xuICB2YXIgYnVmZmVyID0gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShhKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLndyaXRlU3luYyh0aGlzLmZkLCBidWZmZXIsIGJ1Zl9vZmZzZXQsIGxlbiwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiAwO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG9mZnNldCxidWYsYnVmX29mZnNldCxsZW4pe1xuICB2YXIgYSA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMoYnVmKTtcbiAgaWYoISAoYSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBnbG9iYWxUaGlzLlVpbnQ4QXJyYXkoYSk7XG4gIHZhciBidWZmZXIgPSBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGEpO1xuICB0cnkge1xuICAgIHRoaXMuZnMucmVhZFN5bmModGhpcy5mZCwgYnVmZmVyLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIGNhbWxfYnl0ZXNfc2V0KGJ1ZixidWZfb2Zmc2V0ICsgaSxidWZmZXJbYnVmX29mZnNldCtpXSk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLnJlYWRfb25lID0gZnVuY3Rpb24ob2Zmc2V0KXtcbiAgdmFyIGEgPSBuZXcgZ2xvYmFsVGhpcy5VaW50OEFycmF5KDEpO1xuICB2YXIgYnVmZmVyID0gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShhKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgMCwgMSwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBidWZmZXJbMF07XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5jbG9zZVN5bmModGhpcy5mZCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuXG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZUZpbGU7XG5cbi8vUHJvdmlkZXM6IE1sTm9kZUZpbGVcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIE1sTm9kZUZpbGUoKXtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRHVtbXkgZmlsZXN5c3RlbVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiBjYW1sX3RyYWlsaW5nX3NsYXNoKG5hbWUpe1xuICByZXR1cm4gKG5hbWUuc2xpY2UoLTEpICE9PSBcIi9cIikgPyAobmFtZSArIFwiL1wiKSA6IG5hbWU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VycmVudF9kaXJcbi8vUmVxdWlyZXM6IGNhbWxfdHJhaWxpbmdfc2xhc2gsIGZzX25vZGVfc3VwcG9ydGVkXG5pZihmc19ub2RlX3N1cHBvcnRlZCAoKSAmJiBnbG9iYWxUaGlzLnByb2Nlc3MgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzLmN3ZClcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSBnbG9iYWxUaGlzLnByb2Nlc3MuY3dkKCkucmVwbGFjZSgvXFxcXC9nLCcvJyk7XG5lbHNlXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gIFwiL3N0YXRpY1wiO1xuY2FtbF9jdXJyZW50X2RpciA9IGNhbWxfdHJhaWxpbmdfc2xhc2goY2FtbF9jdXJyZW50X2Rpcik7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X3Jvb3Rcbi8vUmVxdWlyZXM6IHBhdGhfaXNfYWJzb2x1dGVcbmZ1bmN0aW9uIGNhbWxfZ2V0X3Jvb3QocGF0aCl7XG4gIHZhciB4ID0gcGF0aF9pc19hYnNvbHV0ZShwYXRoKTtcbiAgaWYgKCF4KSByZXR1cm47XG4gIHJldHVybiB4WzBdICsgXCIvXCJ9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcm9vdFxuLy9SZXF1aXJlczogY2FtbF9nZXRfcm9vdCwgY2FtbF9jdXJyZW50X2RpciwgY2FtbF9mYWlsd2l0aFxudmFyIGNhbWxfcm9vdCA9IGNhbWxfZ2V0X3Jvb3QoY2FtbF9jdXJyZW50X2RpcikgfHwgY2FtbF9mYWlsd2l0aChcInVuYWJsZSB0byBjb21wdXRlIGNhbWxfcm9vdFwiKTtcblxuXG4vL1Byb3ZpZGVzOiBNbEZpbGVcbmZ1bmN0aW9uIE1sRmlsZSgpeyAgfVxuXG4vL1Byb3ZpZGVzOiBwYXRoX2lzX2Fic29sdXRlXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gbWFrZV9wYXRoX2lzX2Fic29sdXRlKCkge1xuICBmdW5jdGlvbiBwb3NpeChwYXRoKSB7XG4gICAgaWYgKHBhdGguY2hhckF0KDApID09PSAnLycpIHJldHVybiBbXCJcIiwgcGF0aC5zdWJzdHJpbmcoMSldO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpbjMyKHBhdGgpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9iM2ZjYzI0NWZiMjU1Mzk5MDllZjFkNWVhYTAxZGJmOTJlMTY4NjMzL2xpYi9wYXRoLmpzI0w1NlxuICAgIHZhciBzcGxpdERldmljZVJlID0gL14oW2EtekEtWl06fFtcXFxcL117Mn1bXlxcXFwvXStbXFxcXC9dK1teXFxcXC9dKyk/KFtcXFxcL10pPyhbXFxzXFxTXSo/KSQvO1xuICAgIHZhciByZXN1bHQgPSBzcGxpdERldmljZVJlLmV4ZWMocGF0aCk7XG4gICAgdmFyIGRldmljZSA9IHJlc3VsdFsxXSB8fCAnJztcbiAgICB2YXIgaXNVbmMgPSBCb29sZWFuKGRldmljZSAmJiBkZXZpY2UuY2hhckF0KDEpICE9PSAnOicpO1xuXG4gICAgLy8gVU5DIHBhdGhzIGFyZSBhbHdheXMgYWJzb2x1dGVcbiAgICBpZiAoQm9vbGVhbihyZXN1bHRbMl0gfHwgaXNVbmMpKSB7XG4gICAgICB2YXIgcm9vdCA9IChyZXN1bHRbMV0gfHwgJycpO1xuICAgICAgdmFyIHNlcCA9IChyZXN1bHRbMl0gfHwgJycpO1xuICAgICAgcmV0dXJuIFtyb290LCBwYXRoLnN1YnN0cmluZyhyb290Lmxlbmd0aCArIHNlcC5sZW5ndGgpXVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYoZnNfbm9kZV9zdXBwb3J0ZWQgKCkgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzICYmIGdsb2JhbFRoaXMucHJvY2Vzcy5wbGF0Zm9ybSkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMiA6IHBvc2l4O1xuICB9XG4gIGVsc2UgcmV0dXJuIHBvc2l4XG59XG52YXIgcGF0aF9pc19hYnNvbHV0ZSA9IG1ha2VfcGF0aF9pc19hYnNvbHV0ZSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfcGF0aFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcsIHBhdGhfaXNfYWJzb2x1dGVcbmZ1bmN0aW9uIGNhbWxfbWFrZV9wYXRoIChuYW1lKSB7XG4gIG5hbWU9Y2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSk7XG4gIGlmKCAhcGF0aF9pc19hYnNvbHV0ZShuYW1lKSApXG4gICAgbmFtZSA9IGNhbWxfY3VycmVudF9kaXIgKyBuYW1lO1xuICB2YXIgY29tcDAgPSBwYXRoX2lzX2Fic29sdXRlKG5hbWUpO1xuICB2YXIgY29tcCA9IGNvbXAwWzFdLnNwbGl0KFwiL1wiKTtcbiAgdmFyIG5jb21wID0gW11cbiAgZm9yKHZhciBpID0gMDsgaTxjb21wLmxlbmd0aDsgaSsrKXtcbiAgICBzd2l0Y2goY29tcFtpXSl7XG4gICAgY2FzZSBcIi4uXCI6IGlmKG5jb21wLmxlbmd0aD4xKSBuY29tcC5wb3AoKTsgYnJlYWs7XG4gICAgY2FzZSBcIi5cIjogYnJlYWs7XG4gICAgZGVmYXVsdDogbmNvbXAucHVzaChjb21wW2ldKTticmVha1xuICAgIH1cbiAgfVxuICBuY29tcC51bnNoaWZ0KGNvbXAwWzBdKTtcbiAgbmNvbXAub3JpZyA9IG5hbWU7XG4gIHJldHVybiBuY29tcDtcbn1cblxuLy9Qcm92aWRlczpqc29vX21vdW50X3BvaW50XG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIE1sTm9kZURldmljZSwgY2FtbF9yb290LCBmc19ub2RlX3N1cHBvcnRlZFxudmFyIGpzb29fbW91bnRfcG9pbnQgPSBbXVxuaWYgKGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCxkZXZpY2U6bmV3IE1sTm9kZURldmljZShjYW1sX3Jvb3QpfSk7XG59IGVsc2Uge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn1cbmpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpcIi9zdGF0aWMvXCIsIGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKFwiL3N0YXRpYy9cIil9KTtcblxuLy9Qcm92aWRlczpjYW1sX2xpc3RfbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGlzdF9tb3VudF9wb2ludCgpe1xuICB2YXIgcHJldiA9IDBcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspe1xuICAgIHZhciBvbGQgPSBwcmV2O1xuICAgIHByZXYgPSBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhqc29vX21vdW50X3BvaW50W2ldLnBhdGgpLCBvbGRdXG4gIH1cbiAgcmV0dXJuIHByZXY7XG59XG5cbi8vUHJvdmlkZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1JlcXVpcmVzOiBjYW1sX21ha2VfcGF0aCwganNvb19tb3VudF9wb2ludCwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2V0X3Jvb3QsIE1sTm9kZURldmljZSwgY2FtbF90cmFpbGluZ19zbGFzaCwgZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIik7XG4gIHZhciBuYW1lX3NsYXNoID0gY2FtbF90cmFpbGluZ19zbGFzaChuYW1lKTtcbiAgdmFyIHJlcztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbSA9IGpzb29fbW91bnRfcG9pbnRbaV07XG4gICAgaWYobmFtZV9zbGFzaC5zZWFyY2gobS5wYXRoKSA9PSAwXG4gICAgICAgJiYgKCFyZXMgfHwgcmVzLnBhdGgubGVuZ3RoIDwgbS5wYXRoLmxlbmd0aCkpXG4gICAgICByZXMgPSB7cGF0aDptLnBhdGgsZGV2aWNlOm0uZGV2aWNlLHJlc3Q6bmFtZS5zdWJzdHJpbmcobS5wYXRoLmxlbmd0aCxuYW1lLmxlbmd0aCl9O1xuICB9XG4gIGlmKCAhcmVzICYmIGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAgICB2YXIgcm9vdCA9IGNhbWxfZ2V0X3Jvb3QobmFtZSk7XG4gICAgaWYgKHJvb3QgJiYgcm9vdC5tYXRjaCgvXlthLXpBLVpdOlxcLyQvKSl7XG4gICAgICB2YXIgbSA9IHtwYXRoOnJvb3QsZGV2aWNlOm5ldyBNbE5vZGVEZXZpY2Uocm9vdCl9O1xuICAgICAganNvb19tb3VudF9wb2ludC5wdXNoKG0pO1xuICAgICAgcmVzID0ge3BhdGg6bS5wYXRoLGRldmljZTptLmRldmljZSxyZXN0Om5hbWUuc3Vic3RyaW5nKG0ucGF0aC5sZW5ndGgsbmFtZS5sZW5ndGgpfTtcbiAgICB9XG4gIH1cbiAgaWYoIHJlcyApIHJldHVybiByZXM7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwibm8gZGV2aWNlIGZvdW5kIGZvciBcIiArIG5hbWVfc2xhc2gpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vdW50X2F1dG9sb2FkXG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50LCBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiBjYW1sX21vdW50X2F1dG9sb2FkKG5hbWUsZil7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gY2FtbF90cmFpbGluZ19zbGFzaChwYXRoLmpvaW4oXCIvXCIpKTtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOm5hbWUsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UobmFtZSxmKX0pXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VubW91bnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfbWFrZV9wYXRoLCBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiBjYW1sX3VubW91bnQobmFtZSl7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gY2FtbF90cmFpbGluZ19zbGFzaChwYXRoLmpvaW4oXCIvXCIpKTtcbiAgdmFyIGlkeCA9IC0xO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKylcbiAgICBpZihqc29vX21vdW50X3BvaW50W2ldLnBhdGggPT0gbmFtZSkgaWR4ID0gaTtcbiAgaWYoaWR4ID4gLTEpIGpzb29fbW91bnRfcG9pbnQuc3BsaWNlKGlkeCwxKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0Y3dkXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRjd2QoKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfY3VycmVudF9kaXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jaGRpclxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3RyYWlsaW5nX3NsYXNoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19jaGRpcihkaXIpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShkaXIpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIGlmKHJvb3QucmVzdCkgY2FtbF9jdXJyZW50X2RpciA9IGNhbWxfdHJhaWxpbmdfc2xhc2gocm9vdC5wYXRoICsgcm9vdC5yZXN0KTtcbiAgICBlbHNlIGNhbWxfY3VycmVudF9kaXIgPSByb290LnBhdGg7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhkaXIpKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpe1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9hX2RpclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2FfZGlyKG5hbWUpe1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2ZpbGVfZXhpc3RzXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfZmlsZV9leGlzdHMgKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcmV0dXJuIHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfYV9kaXIsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5yZWFkZGlyKHJvb3QucmVzdCk7XG4gIHZhciBsID0gbmV3IEFycmF5KGEubGVuZ3RoICsgMSk7XG4gIGxbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGEubGVuZ3RoO2krKylcbiAgICBsW2krMV0gPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGFbaV0pO1xuICByZXR1cm4gbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVtb3ZlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbW92ZShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIG9rID0gcm9vdC5kZXZpY2UudW5saW5rKHJvb3QucmVzdCk7XG4gIGlmKG9rID09IDApIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNfZGlyZWN0b3J5KG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLmlzX2Rpcihyb290LnJlc3QpO1xuICByZXR1cm4gYT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbmFtZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbmFtZShvLG4pe1xuICB2YXIgb19yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobyk7XG4gIHZhciBuX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuKTtcbiAgaWYob19yb290LmRldmljZSAhPSBuX3Jvb3QuZGV2aWNlKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IGNhbm5vdCBtb3ZlIGZpbGUgYmV0d2VlbiB0d28gZmlsZXN5c3RlbVwiKTtcbiAgaWYoIW9fcm9vdC5kZXZpY2UucmVuYW1lKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IG5vIGltcGxlbWVudGVkXCIpO1xuICBvX3Jvb3QuZGV2aWNlLnJlbmFtZShvX3Jvb3QucmVzdCwgbl9yb290LnJlc3QpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19ta2RpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3N5c19ta2RpcihuYW1lLCBwZXJtKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcm9vdC5kZXZpY2UubWtkaXIocm9vdC5yZXN0LHBlcm0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcm1kaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV9ub3RfYV9kaXJcbmZ1bmN0aW9uIGNhbWxfc3lzX3JtZGlyKG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByb290LmRldmljZS5ybWRpcihyb290LnJlc3QpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZSh2ZmQsIGtpbmQsIGxheW91dCwgc2hhcmVkLCBkaW1zLCBwb3MpIHtcbiAgLy8gdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1t2ZmRdO1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9iYV9tYXBfZmlsZSBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfbWFwX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGUoYXJndixhcmduKXtcbiAgcmV0dXJuIGNhbWxfYmFfbWFwX2ZpbGUoYXJndlswXSxhcmd2WzFdLGFyZ3ZbMl0sYXJndlszXSxhcmd2WzRdLGFyZ3ZbNV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2NyZWF0ZV9maWxlX2V4dGVyblxuZnVuY3Rpb24ganNvb19jcmVhdGVfZmlsZV9leHRlcm4obmFtZSxjb250ZW50KXtcbiAgaWYoZ2xvYmFsVGhpcy5qc29vX2NyZWF0ZV9maWxlKVxuICAgIGdsb2JhbFRoaXMuanNvb19jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpO1xuICBlbHNlIHtcbiAgICBpZighZ2xvYmFsVGhpcy5jYW1sX2ZzX3RtcCkgZ2xvYmFsVGhpcy5jYW1sX2ZzX3RtcCA9IFtdO1xuICAgIGdsb2JhbFRoaXMuY2FtbF9mc190bXAucHVzaCh7bmFtZTpuYW1lLGNvbnRlbnQ6Y29udGVudH0pO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZzX2luaXRcbi8vUmVxdWlyZXM6IGpzb29fY3JlYXRlX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfZnNfaW5pdCAoKXtcbiAgdmFyIHRtcD1nbG9iYWxUaGlzLmNhbWxfZnNfdG1wXG4gIGlmKHRtcCl7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7IGkrKyl7XG4gICAgICBqc29vX2NyZWF0ZV9maWxlKHRtcFtpXS5uYW1lLHRtcFtpXS5jb250ZW50KTtcbiAgICB9XG4gIH1cbiAgZ2xvYmFsVGhpcy5qc29vX2NyZWF0ZV9maWxlID0ganNvb19jcmVhdGVfZmlsZTtcbiAgZ2xvYmFsVGhpcy5jYW1sX2ZzX3RtcCA9IFtdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKCEgcm9vdC5kZXZpY2UucmVnaXN0ZXIpIGNhbWxfZmFpbHdpdGgoXCJjYW5ub3QgcmVnaXN0ZXIgZmlsZVwiKTtcbiAgcm9vdC5kZXZpY2UucmVnaXN0ZXIocm9vdC5yZXN0LGNvbnRlbnQpO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBqc29vX2NyZWF0ZV9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9maWxlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBqc29vX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCkge1xuICB2YXIgbmFtZSA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSk7XG4gIHZhciBjb250ZW50ID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjb250ZW50KTtcbiAgcmV0dXJuIGNhbWxfY3JlYXRlX2ZpbGUobmFtZSwgY29udGVudCk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9yZWFkX2ZpbGVfY29udGVudFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmVhZF9maWxlX2NvbnRlbnQgKG5hbWUpIHtcbiAgdmFyIG5hbWUgPSAodHlwZW9mIG5hbWUgPT0gXCJzdHJpbmdcIik/Y2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKTpuYW1lO1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3Qse3Jkb25seToxfSk7XG4gICAgdmFyIGxlbiAgPSBmaWxlLmxlbmd0aCgpO1xuICAgIHZhciBidWYgID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgICBmaWxlLnJlYWQoMCxidWYsMCxsZW4pO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9ieXRlcyhidWYpXG4gIH1cbiAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSk7XG59XG4iLCIvL1Byb3ZpZGVzOiB1bml4X2dldHRpbWVvZmRheVxuZnVuY3Rpb24gdW5peF9nZXR0aW1lb2ZkYXkgKCkge1xuICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAvIDEwMDA7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfdGltZVxuLy9SZXF1aXJlczogdW5peF9nZXR0aW1lb2ZkYXlcbmZ1bmN0aW9uIHVuaXhfdGltZSAoKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKHVuaXhfZ2V0dGltZW9mZGF5ICgpKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9nbXRpbWVcbmZ1bmN0aW9uIHVuaXhfZ210aW1lICh0KSB7XG4gIHZhciBkID0gbmV3IERhdGUgKHQgKiAxMDAwKTtcbiAgdmFyIGRfbnVtID0gZC5nZXRUaW1lKCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSAobmV3IERhdGUoRGF0ZS5VVEMoZC5nZXRVVENGdWxsWWVhcigpLCAwLCAxKSkpLmdldFRpbWUoKTtcbiAgdmFyIGRveSA9IE1hdGguZmxvb3IoKGRfbnVtIC0gamFudWFyeWZpcnN0KSAvIDg2NDAwMDAwKTtcbiAgcmV0dXJuIEJMT0NLKDAsIGQuZ2V0VVRDU2Vjb25kcygpLCBkLmdldFVUQ01pbnV0ZXMoKSwgZC5nZXRVVENIb3VycygpLFxuICAgICAgICAgICAgICAgZC5nZXRVVENEYXRlKCksIGQuZ2V0VVRDTW9udGgoKSwgZC5nZXRVVENGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICAgICAgIGQuZ2V0VVRDRGF5KCksIGRveSxcbiAgICAgICAgICAgICAgIGZhbHNlIHwgMCAvKiBmb3IgVVRDIGRheWxpZ2h0IHNhdmluZ3MgdGltZSBpcyBmYWxzZSAqLylcbn1cblxuLy9Qcm92aWRlczogdW5peF9sb2NhbHRpbWVcbmZ1bmN0aW9uIHVuaXhfbG9jYWx0aW1lICh0KSB7XG4gIHZhciBkID0gbmV3IERhdGUgKHQgKiAxMDAwKTtcbiAgdmFyIGRfbnVtID0gZC5nZXRUaW1lKCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSAobmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKSkuZ2V0VGltZSgpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZF9udW0gLSBqYW51YXJ5Zmlyc3QpIC8gODY0MDAwMDApO1xuICB2YXIgamFuID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgdmFyIGp1bCA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgNiwgMSk7XG4gIHZhciBzdGRUaW1lem9uZU9mZnNldCA9IE1hdGgubWF4KGphbi5nZXRUaW1lem9uZU9mZnNldCgpLCBqdWwuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG4gIHJldHVybiBCTE9DSygwLCBkLmdldFNlY29uZHMoKSwgZC5nZXRNaW51dGVzKCksIGQuZ2V0SG91cnMoKSxcbiAgICAgICAgICAgICAgIGQuZ2V0RGF0ZSgpLCBkLmdldE1vbnRoKCksIGQuZ2V0RnVsbFllYXIoKSAtIDE5MDAsXG4gICAgICAgICAgICAgICBkLmdldERheSgpLCBkb3ksXG4gICAgICAgICAgICAgICAoZC5nZXRUaW1lem9uZU9mZnNldCgpIDwgc3RkVGltZXpvbmVPZmZzZXQpIHwgMCAvKiBkYXlsaWdodCBzYXZpbmdzIHRpbWUgIGZpZWxkLiAqLylcbn1cblxuLy9Qcm92aWRlczogdW5peF9ta3RpbWVcbi8vUmVxdWlyZXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiB1bml4X21rdGltZSh0bSl7XG4gIHZhciBkID0gKG5ldyBEYXRlKHRtWzZdKzE5MDAsdG1bNV0sdG1bNF0sdG1bM10sdG1bMl0sdG1bMV0pKS5nZXRUaW1lKCk7XG4gIHZhciB0ID0gTWF0aC5mbG9vcihkIC8gMTAwMCk7XG4gIHZhciB0bTIgPSB1bml4X2xvY2FsdGltZSh0KTtcbiAgcmV0dXJuIEJMT0NLKDAsdCx0bTIpO1xufVxuXG4vL1Byb3ZpZGVzOiB3aW5fc3RhcnR1cCBjb25zdFxuZnVuY3Rpb24gd2luX3N0YXJ0dXAoKSB7fVxuXG4vL1Byb3ZpZGVzOiB3aW5fY2xlYW51cCBjb25zdFxuZnVuY3Rpb24gd2luX2NsZWFudXAoKSB7fVxuXG4vL1Byb3ZpZGVzOiB3aW5faGFuZGxlX2ZkIGNvbnN0XG5mdW5jdGlvbiB3aW5faGFuZGxlX2ZkKHgpIHtyZXR1cm4geDt9XG5cbi8vUHJvdmlkZXM6IHVuaXhfaXNhdHR5XG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gdW5peF9pc2F0dHkoZmlsZURlc2NyaXB0b3IpIHtcbiAgaWYoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICAgIHZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcbiAgICByZXR1cm4gdHR5LmlzYXR0eShmaWxlRGVzY3JpcHRvcik/MTowO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IG1ha2VfdW5peF9lcnJfYXJnc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbnZhciB1bml4X2Vycm9yID0gW1xuICAvKiA9PT1Vbml4LmVycm9yPT09XG4gICAqXG4gICAqIFRoaXMgYXJyYXkgaXMgaW4gb3JkZXIgb2YgdGhlIHZhcmlhbnQgaW4gT0NhbWxcbiAgICovXG4gIFwiRTJCSUdcIiwgXCJFQUNDRVNcIiwgXCJFQUdBSU5cIiwgXCJFQkFERlwiLCBcIkVCVVNZXCIsIFwiRUNISUxEXCIsIFwiRURFQURMS1wiLCBcIkVET01cIixcbiAgXCJFRVhJU1RcIiwgXCJFRkFVTFRcIiwgXCJFRkJJR1wiLCBcIkVJTlRSXCIsIFwiRUlOVkFMXCIsIFwiRUlPXCIsIFwiRUlTRElSXCIsIFwiRU1GSUxFXCIsXG4gIFwiRU1MSU5LXCIsIFwiRU5BTUVUT09MT05HXCIsIFwiRU5GSUxFXCIsIFwiRU5PREVWXCIsIFwiRU5PRU5UXCIsIFwiRU5PRVhFQ1wiLCBcIkVOT0xDS1wiLFxuICBcIkVOT01FTVwiLCBcIkVOT1NQQ1wiLCBcIkVOT1NZU1wiLCBcIkVOT1RESVJcIiwgXCJFTk9URU1QVFlcIiwgXCJFTk9UVFlcIiwgXCJFTlhJT1wiLFxuICBcIkVQRVJNXCIsIFwiRVBJUEVcIiwgXCJFUkFOR0VcIiwgXCJFUk9GU1wiLCBcIkVTUElQRVwiLCBcIkVTUkNIXCIsIFwiRVhERVZcIiwgXCJFV09VTERCTE9DS1wiLFxuICBcIkVJTlBST0dSRVNTXCIsIFwiRUFMUkVBRFlcIiwgXCJFTk9UU09DS1wiLCBcIkVERVNUQUREUlJFUVwiLCBcIkVNU0dTSVpFXCIsXG4gIFwiRVBST1RPVFlQRVwiLCBcIkVOT1BST1RPT1BUXCIsIFwiRVBST1RPTk9TVVBQT1JUXCIsIFwiRVNPQ0tUTk9TVVBQT1JUXCIsXG4gIFwiRU9QTk9UU1VQUFwiLCBcIkVQRk5PU1VQUE9SVFwiLCBcIkVBRk5PU1VQUE9SVFwiLCBcIkVBRERSSU5VU0VcIiwgXCJFQUREUk5PVEFWQUlMXCIsXG4gIFwiRU5FVERPV05cIiwgXCJFTkVUVU5SRUFDSFwiLCBcIkVORVRSRVNFVFwiLCBcIkVDT05OQUJPUlRFRFwiLCBcIkVDT05OUkVTRVRcIiwgXCJFTk9CVUZTXCIsXG4gIFwiRUlTQ09OTlwiLCBcIkVOT1RDT05OXCIsIFwiRVNIVVRET1dOXCIsIFwiRVRPT01BTllSRUZTXCIsIFwiRVRJTUVET1VUXCIsIFwiRUNPTk5SRUZVU0VEXCIsXG4gIFwiRUhPU1RET1dOXCIsIFwiRUhPU1RVTlJFQUNIXCIsIFwiRUxPT1BcIiwgXCJFT1ZFUkZMT1dcIlxuXTtcbmZ1bmN0aW9uIG1ha2VfdW5peF9lcnJfYXJncyhjb2RlLCBzeXNjYWxsLCBwYXRoLCBlcnJubykge1xuICB2YXIgdmFyaWFudCA9IHVuaXhfZXJyb3IuaW5kZXhPZihjb2RlKTtcbiAgaWYgKHZhcmlhbnQgPCAwKSB7XG4gICAgLy8gRGVmYXVsdCBpZiB1bmRlZmluZWRcbiAgICBpZiAoZXJybm8gPT0gbnVsbCkge1xuICAgICAgZXJybm8gPSAtOTk5OVxuICAgIH1cbiAgICAvLyBJZiBub25lIG9mIHRoZSBhYm92ZSB2YXJpYW50cywgZmFsbGJhY2sgdG8gRVVOS05PV05FUlIoaW50KVxuICAgIHZhcmlhbnQgPSBCTE9DSygwLCBlcnJubyk7XG4gIH1cbiAgdmFyIGFyZ3MgPSBbXG4gICAgdmFyaWFudCxcbiAgICBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhzeXNjYWxsIHx8IFwiXCIpLFxuICAgIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHBhdGggfHwgXCJcIilcbiAgXTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfc3RhdFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIHVuaXhfc3RhdChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2Uuc3RhdCkge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJ1bml4X3N0YXQ6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2Uuc3RhdChyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfc3RhdF82NFxuLy9SZXF1aXJlczogdW5peF9zdGF0XG52YXIgdW5peF9zdGF0XzY0ID0gdW5peF9zdGF0O1xuXG4vL1Byb3ZpZGVzOiB1bml4X2xzdGF0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gdW5peF9sc3RhdChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UubHN0YXQpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwidW5peF9sc3RhdDogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5sc3RhdChyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfbHN0YXRfNjRcbi8vUmVxdWlyZXM6IHVuaXhfbHN0YXRcbnZhciB1bml4X2xzdGF0XzY0ID0gdW5peF9sc3RhdDtcblxuLy9Qcm92aWRlczogdW5peF9ta2RpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIHVuaXhfbWtkaXIobmFtZSwgcGVybSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLm1rZGlyKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcInVuaXhfbWtkaXI6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UubWtkaXIocm9vdC5yZXN0LCBwZXJtLCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X3JtZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gdW5peF9ybWRpcihuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2Uucm1kaXIpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwidW5peF9ybWRpcjogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5ybWRpcihyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfc3ltbGlua1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIHVuaXhfc3ltbGluayh0b19kaXIsIHNyYywgZHN0KSB7XG4gIHZhciBzcmNfcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKHNyYyk7XG4gIHZhciBkc3Rfcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKGRzdCk7XG4gIGlmKHNyY19yb290LmRldmljZSAhPSBkc3Rfcm9vdC5kZXZpY2UpXG4gICAgY2FtbF9mYWlsd2l0aChcInVuaXhfc3ltbGluazogY2Fubm90IHN5bWxpbmsgYmV0d2VlbiB0d28gZmlsZXN5c3RlbXNcIik7XG4gIGlmICghc3JjX3Jvb3QuZGV2aWNlLnN5bWxpbmspIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwidW5peF9zeW1saW5rOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHNyY19yb290LmRldmljZS5zeW1saW5rKHRvX2Rpciwgc3JjX3Jvb3QucmVzdCwgZHN0X3Jvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9yZWFkbGlua1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIHVuaXhfcmVhZGxpbmsobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnJlYWRsaW5rKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcInVuaXhfcmVhZGxpbms6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UucmVhZGxpbmsocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X3VubGlua1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIHVuaXhfdW5saW5rKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS51bmxpbmspIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwidW5peF91bmxpbms6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UudW5saW5rKHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9nZXR1aWRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG5mdW5jdGlvbiB1bml4X2dldHVpZCh1bml0KSB7XG4gIGlmKGdsb2JhbFRoaXMucHJvY2VzcyAmJiBnbG9iYWxUaGlzLnByb2Nlc3MuZ2V0dWlkKXtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5wcm9jZXNzLmdldHVpZCgpO1xuICB9XG4gIGNhbWxfcmFpc2Vfbm90X2ZvdW5kKCk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfZ2V0cHd1aWRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG5mdW5jdGlvbiB1bml4X2dldHB3dWlkKHVuaXQpIHtcbiAgY2FtbF9yYWlzZV9ub3RfZm91bmQoKVxufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2hhc19zeW1saW5rXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gdW5peF9oYXNfc3ltbGluayh1bml0KSB7XG4gIHJldHVybiBmc19ub2RlX3N1cHBvcnRlZCgpPzE6MFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBTeXNcblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuU3lzX2Vycm9yLCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19leGl0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4aXQgKGNvZGUpIHtcbiAgdmFyIGcgPSBnbG9iYWxUaGlzO1xuICBpZihnLnF1aXQpIGcucXVpdChjb2RlKTtcbiAgLy9ub2RlanNcbiAgaWYoZy5wcm9jZXNzICYmIGcucHJvY2Vzcy5leGl0KVxuICAgIGcucHJvY2Vzcy5leGl0KGNvZGUpO1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJGdW5jdGlvbiAnZXhpdCcgbm90IGltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX3NwZWNpYWxfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2lzX3NwZWNpYWxfZXhjZXB0aW9uKGV4bil7XG4gIHN3aXRjaChleG5bMl0pIHtcbiAgY2FzZSAtODogLy8gTWF0Y2hfZmFpbHVyZVxuICBjYXNlIC0xMTogLy8gQXNzZXJ0X2ZhaWx1cmVcbiAgY2FzZSAtMTI6IC8vIFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlXG4gICAgcmV0dXJuIDE7XG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfZXhjZXB0aW9uXG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2lzX3NwZWNpYWxfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9leGNlcHRpb24oZXhuKXtcbiAgdmFyIHIgPSBcIlwiO1xuICBpZihleG5bMF0gPT0gMCkge1xuICAgIHIgKz0gZXhuWzFdWzFdO1xuICAgIGlmKGV4bi5sZW5ndGggPT0gMyAmJiBleG5bMl1bMF0gPT0gMCAmJiBjYW1sX2lzX3NwZWNpYWxfZXhjZXB0aW9uKGV4blsxXSkpIHtcblxuICAgICAgdmFyIGJ1Y2tldCA9IGV4blsyXTtcbiAgICAgIHZhciBzdGFydCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IDJcbiAgICAgIHZhciBidWNrZXQgPSBleG47XG4gICAgfVxuICAgIHIgKz0gXCIoXCI7XG4gICAgZm9yKHZhciBpID0gc3RhcnQ7IGkgPCBidWNrZXQubGVuZ3RoOyBpICsrKXtcbiAgICAgIGlmKGkgPiBzdGFydCkgcis9XCIsIFwiO1xuICAgICAgdmFyIHYgPSBidWNrZXRbaV1cbiAgICAgIGlmKHR5cGVvZiB2ID09IFwibnVtYmVyXCIpXG4gICAgICAgIHIrPSB2LnRvU3RyaW5nKCk7XG4gICAgICBlbHNlIGlmKHYgaW5zdGFuY2VvZiBNbEJ5dGVzKXtcbiAgICAgICAgcis9ICdcIicgKyB2LnRvU3RyaW5nKCkgKyAnXCInO1xuICAgICAgfVxuICAgICAgZWxzZSBpZih0eXBlb2YgdiA9PSBcInN0cmluZ1wiKXtcbiAgICAgICAgcis9ICdcIicgKyB2LnRvU3RyaW5nKCkgKyAnXCInO1xuICAgICAgfVxuICAgICAgZWxzZSByICs9IFwiX1wiO1xuICAgIH1cbiAgICByICs9IFwiKVwiXG4gIH0gZWxzZSBpZiAoZXhuWzBdID09IDI0OCl7XG4gICAgciArPSBleG5bMV1cbiAgfVxuICByZXR1cm4gclxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvblxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9mb3JtYXRfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbihlcnIpe1xuICBpZihlcnIgaW5zdGFuY2VvZiBBcnJheSAmJiAoZXJyWzBdID09IDAgfHwgZXJyWzBdID09IDI0OCkpIHtcbiAgICB2YXIgaGFuZGxlciA9IGNhbWxfbmFtZWRfdmFsdWUoXCJQcmludGV4Yy5oYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uXCIpO1xuICAgIGlmKGhhbmRsZXIpIGhhbmRsZXIoZXJyLGZhbHNlKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBtc2cgPSBjYW1sX2Zvcm1hdF9leGNlcHRpb24oZXJyKTtcbiAgICAgIHZhciBhdF9leGl0ID0gY2FtbF9uYW1lZF92YWx1ZShcIlBlcnZhc2l2ZXMuZG9fYXRfZXhpdFwiKTtcbiAgICAgIGlmKGF0X2V4aXQpIHsgYXRfZXhpdCgwKSB9XG4gICAgICBnbG9iYWxUaGlzLmNvbnNvbGUuZXJyb3IoXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uIFwiICsgbXNnICsgXCJcXG5cIik7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zZXRfc3RhdGljX2VudlxuZnVuY3Rpb24gY2FtbF9zZXRfc3RhdGljX2VudihrLHYpe1xuICBpZighZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnYpXG4gICAgZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnYgPSB7fVxuICBnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudltrXSA9IHY7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0ZW52IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGVudiAobmFtZSkge1xuICB2YXIgZyA9IGdsb2JhbFRoaXM7XG4gIHZhciBuID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSk7XG4gIC8vbm9kZWpzIGVudlxuICBpZihnLnByb2Nlc3NcbiAgICAgJiYgZy5wcm9jZXNzLmVudlxuICAgICAmJiBnLnByb2Nlc3MuZW52W25dICE9IHVuZGVmaW5lZClcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoZy5wcm9jZXNzLmVudltuXSk7XG4gIGlmKGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52XG4gICAgICYmIGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52W25dKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudltuXSlcbiAgY2FtbF9yYWlzZV9ub3RfZm91bmQgKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3Vuc2FmZV9nZXRlbnZcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2dldGVudlxuZnVuY3Rpb24gY2FtbF9zeXNfdW5zYWZlX2dldGVudihuYW1lKXtcbiAgcmV0dXJuIGNhbWxfc3lzX2dldGVudiAobmFtZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJndlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbnZhciBjYW1sX2FyZ3YgPSAoKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGcgPSBnbG9iYWxUaGlzO1xuICB2YXIgbWFpbiA9IFwiYS5vdXRcIjtcbiAgdmFyIGFyZ3MgPSBbXVxuXG4gIGlmKGcucHJvY2Vzc1xuICAgICAmJiBnLnByb2Nlc3MuYXJndlxuICAgICAmJiBnLnByb2Nlc3MuYXJndi5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGFyZ3YgPSBnLnByb2Nlc3MuYXJndlxuICAgIC8vbm9kZWpzXG4gICAgbWFpbiA9IGFyZ3ZbMV07XG4gICAgYXJncyA9IGFyZ3Yuc2xpY2UoMik7XG4gIH1cblxuICB2YXIgcCA9IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKG1haW4pO1xuICB2YXIgYXJnczIgPSBbMCwgcF07XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKVxuICAgIGFyZ3MyLnB1c2goY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoYXJnc1tpXSkpO1xuICByZXR1cm4gYXJnczI7XG59KSgpKVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG52YXIgY2FtbF9leGVjdXRhYmxlX25hbWUgPSBjYW1sX2FyZ3ZbMV1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2FyZ3YgKGEpIHtcbiAgcmV0dXJuIFswLCBjYW1sX2FyZ3ZbMV0sIGNhbWxfYXJndl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfYXJndiAoYSkge1xuICByZXR1cm4gY2FtbF9hcmd2O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19tb2RpZnlfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19tb2RpZnlfYXJndihhcmcpe1xuICBjYW1sX2FyZ3YgPSBhcmc7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19leGVjdXRhYmxlX25hbWUgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG5mdW5jdGlvbiBjYW1sX3N5c19leGVjdXRhYmxlX25hbWUoYSl7XG4gIHJldHVybiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kKGNtZCl7XG4gIHZhciBjbWQgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhjbWQpO1xuICBpZiAodHlwZW9mIHJlcXVpcmUgIT0gXCJ1bmRlZmluZWRcIlxuICAgICAgJiYgcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpXG4gICAgICAmJiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmMpIHtcbiAgICB0cnkge3JlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYyhjbWQse3N0ZGlvOiAnaW5oZXJpdCd9KTsgcmV0dXJuIDB9XG4gICAgY2F0Y2ggKGUpIHtyZXR1cm4gMX1cbiAgfVxuICBlbHNlIHJldHVybiAxMjc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3RpbWUgbXV0YWJsZVxudmFyIGNhbWxfaW5pdGlhbF90aW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAqIDAuMDAxO1xuZnVuY3Rpb24gY2FtbF9zeXNfdGltZSAoKSB7XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICByZXR1cm4gbm93ICogMC4wMDEgLSBjYW1sX2luaXRpYWxfdGltZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuXG4vL1JlcXVpcmVzOiBjYW1sX3N5c190aW1lXG5mdW5jdGlvbiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW4oYikge1xuICByZXR1cm4gY2FtbF9zeXNfdGltZSgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yYW5kb21fc2VlZCBtdXRhYmxlXG4vL1RoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gYW4gYXJyYXkgc2luY2UgT0NhbWwgNC4wLi4uXG5mdW5jdGlvbiBjYW1sX3N5c19yYW5kb21fc2VlZCAoKSB7XG4gIGlmKGdsb2JhbFRoaXMuY3J5cHRvKSB7XG4gICAgaWYodHlwZW9mIGdsb2JhbFRoaXMuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAvLyBXZWJicm93c2Vyc1xuICAgICAgdmFyIGEgPSBuZXcgZ2xvYmFsVGhpcy5VaW50MzJBcnJheSgxKTtcbiAgICAgIGdsb2JhbFRoaXMuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhKTtcbiAgICAgIHJldHVybiBbMCxhWzBdXTtcbiAgICB9IGVsc2UgaWYoZ2xvYmFsVGhpcy5jcnlwdG8ucmFuZG9tQnl0ZXMgPT09ICdmdW5jdGlvbicpe1xuICAgICAgLy8gTm9kZWpzXG4gICAgICB2YXIgYnVmZiA9IGdsb2JhbFRoaXMuY3J5cHRvLnJhbmRvbUJ5dGVzKDQpO1xuICAgICAgdmFyIGEgPSBuZXcgZ2xvYmFsVGhpcy5VaW50MzJBcnJheShidWZmKTtcbiAgICAgIHJldHVybiBbMCxhWzBdXTtcbiAgICB9XG4gIH1cbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHZhciB4ID0gbm93XjB4ZmZmZmZmZmYqTWF0aC5yYW5kb20oKTtcbiAgcmV0dXJuIFswLHhdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgKCkgeyByZXR1cm4gMzI7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfaW50X3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2ludF9zaXplICgpIHsgcmV0dXJuIDMyOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X21heF93b3NpemUgY29uc3Rcbi8vIG1heF9pbnQgLyA0IHNvIHRoYXQgdGhlIGZvbGxvd2luZyBkb2VzIG5vdCBvdmVyZmxvd1xuLy9sZXQgbWF4X3N0cmluZ19sZW5ndGggPSB3b3JkX3NpemUgLyA4ICogbWF4X2FycmF5X2xlbmd0aCAtIDE7O1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSAoKSB7IHJldHVybiAoMHg3RkZGRkZGRi80KSB8IDA7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCBjb25zdFxuLy9SZXF1aXJlczogb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXggKCkgeyByZXR1cm4gb3NfdHlwZSA9PSBcIlVuaXhcIiA/IDEgOiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIgY29uc3Rcbi8vUmVxdWlyZXM6IG9zX3R5cGVcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiAoKSB7IHJldHVybiBvc190eXBlID09IFwiV2luMzJcIiA/IDEgOiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luIGNvbnN0XG4vL1JlcXVpcmVzOiBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luICgpIHsgcmV0dXJuIG9zX3R5cGUgPT0gXCJDeWd3aW5cIiA/IDEgOiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwianNfb2Zfb2NhbWxcIildO1xufVxuXG4vL1Byb3ZpZGVzOiBvc190eXBlXG52YXIgb3NfdHlwZSA9IChnbG9iYWxUaGlzLnByb2Nlc3MgJiZcbiAgICAgICAgICAgICAgIGdsb2JhbFRoaXMucHJvY2Vzcy5wbGF0Zm9ybSAmJlxuICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtID09IFwid2luMzJcIikgPyBcIkN5Z3dpblwiIDogXCJVbml4XCI7XG5cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2NvbmZpZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2NvbmZpZyAoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhvc190eXBlKSwgMzIsIDBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc2F0dHlcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzYXR0eShfY2hhbikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3ZhcmlhbnRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV92YXJpYW50KF91bml0KSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3BhcmFtZXRlcnNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9wYXJhbWV0ZXJzKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlcigpe3JldHVybiAwfVxuXG4vL1Byb3ZpZGVzOiB1bml4X2luZXRfYWRkcl9vZl9zdHJpbmdcbmZ1bmN0aW9uIHVuaXhfaW5ldF9hZGRyX29mX3N0cmluZyAoKSB7cmV0dXJuIDA7fVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG52YXIgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5nc1xuLy9SZXF1aXJlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG5mdW5jdGlvbiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzIChib29sKSB7XG4gIGNhbWxfcnVudGltZV93YXJuaW5ncyA9IGJvb2w7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZFxuLy9SZXF1aXJlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG5mdW5jdGlvbiBjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZCAoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfcnVudGltZV93YXJuaW5ncztcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NwYWNldGltZV9lbmFibGVkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX2VuYWJsZWQoX3VuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUoX2NoYW5uZWwpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZSgpIHtcbiAgY2FtbF9mYWlsd2l0aChcIlNwYWNldGltZSBwcm9maWxpbmcgb25seSB3b3JrcyBmb3IgbmF0aXZlIGNvZGVcIik7XG59XG5cbi8vQWx3YXlzXG4vL1JlcXVpcmVzOiBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9zZXR1cF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlcigpIHtcbiAgdmFyIGcgPSBnbG9iYWxUaGlzO1xuICBpZihnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLm9uKSB7XG4gICAgZy5wcm9jZXNzLm9uKCd1bmNhdWdodEV4Y2VwdGlvbicsIGZ1bmN0aW9uIChlcnIsIG9yaWdpbikge1xuICAgICAgY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb24oZXJyKTtcbiAgICAgIGcucHJvY2Vzcy5leGl0ICgyKTtcbiAgICB9KVxuICB9XG4gIGVsc2UgaWYoZy5hZGRFdmVudExpc3RlbmVyKXtcbiAgICBnLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgaWYoZXZlbnQuZXJyb3Ipe1xuICAgICAgICBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbihldmVudC5lcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNhbWxfc2V0dXBfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIoKTtcbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IE1sRmFrZURldmljZVxuLy9SZXF1aXJlczogTWxGYWtlRmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfYXJyYXksIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2J5dGVzX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3JhaXNlX3dpdGhfYXJncywgY2FtbF9uYW1lZF92YWx1ZXNcbi8vUmVxdWlyZXM6IG1ha2VfdW5peF9lcnJfYXJnc1xuZnVuY3Rpb24gTWxGYWtlRGV2aWNlIChyb290LCBmKSB7XG4gIHRoaXMuY29udGVudD17fTtcbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdGhpcy5sb29rdXBGdW4gPSBmO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuY3JlYXRlX2Rpcl9pZl9uZWVkZWQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBjb21wID0gbmFtZS5zcGxpdChcIi9cIik7XG4gIHZhciByZXMgPSBcIlwiO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgY29tcC5sZW5ndGggLSAxOyBpKyspe1xuICAgIHJlcyArPSBjb21wW2ldICsgXCIvXCI7XG4gICAgaWYodGhpcy5jb250ZW50W3Jlc10pIGNvbnRpbnVlO1xuICAgIHRoaXMuY29udGVudFtyZXNdID0gU3ltYm9sKFwiZGlyZWN0b3J5XCIpO1xuICB9XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnNsYXNoID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiAvXFwvJC8udGVzdChuYW1lKT9uYW1lOihuYW1lICsgXCIvXCIpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmKCF0aGlzLmNvbnRlbnRbbmFtZV0gJiYgdGhpcy5sb29rdXBGdW4pIHtcbiAgICB2YXIgcmVzID0gdGhpcy5sb29rdXBGdW4oY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnJvb3QpLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpKTtcbiAgICBpZihyZXMgIT09IDApIHtcbiAgICAgIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQobmFtZSk7XG4gICAgICB0aGlzLmNvbnRlbnRbbmFtZV09bmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9zdHJpbmcocmVzWzFdKSk7XG4gICAgfVxuICB9XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgLy8gVGhlIHJvb3Qgb2YgdGhlIGRldmljZSBleGlzdHNcbiAgaWYobmFtZSA9PSBcIlwiKSByZXR1cm4gMTtcbiAgLy8gQ2hlY2sgaWYgYSBkaXJlY3RvcnkgZXhpc3RzXG4gIHZhciBuYW1lX3NsYXNoID0gdGhpcy5zbGFzaChuYW1lKTtcbiAgaWYodGhpcy5jb250ZW50W25hbWVfc2xhc2hdKSByZXR1cm4gMTtcbiAgLy8gQ2hlY2sgaWYgYSBmaWxlIGV4aXN0c1xuICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgcmV0dXJuIHRoaXMuY29udGVudFtuYW1lXT8xOjA7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm1rZGlyID0gZnVuY3Rpb24obmFtZSxtb2RlLCByYWlzZV91bml4KSB7XG4gIHZhciB1bml4X2Vycm9yID0gcmFpc2VfdW5peCAmJiBjYW1sX25hbWVkX3ZhbHVlKCdVbml4LlVuaXhfZXJyb3InKTtcbiAgaWYodGhpcy5leGlzdHMobmFtZSkpIHtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRUVYSVNUXCIsIFwibWtkaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogRmlsZSBleGlzdHNcIik7XG4gICAgfVxuICB9XG4gIHZhciBwYXJlbnQgPSAvXiguKilcXC9bXi9dKy8uZXhlYyhuYW1lKTtcbiAgcGFyZW50ID0gKHBhcmVudCAmJiBwYXJlbnRbMV0pIHx8ICcnO1xuICBpZighdGhpcy5leGlzdHMocGFyZW50KSl7XG4gICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT0VOVFwiLCBcIm1rZGlyXCIsIHRoaXMubm0ocGFyZW50KSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHBhcmVudCArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfVxuICBpZighdGhpcy5pc19kaXIocGFyZW50KSl7XG4gICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT1RESVJcIiwgXCJta2RpclwiLCB0aGlzLm5tKHBhcmVudCkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihwYXJlbnQgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKHRoaXMuc2xhc2gobmFtZSkpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5ybWRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSByYWlzZV91bml4ICYmIGNhbWxfbmFtZWRfdmFsdWUoJ1VuaXguVW5peF9lcnJvcicpO1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KHRoaXMuc2xhc2gobmFtZSkpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSspXCIpO1xuICBpZighdGhpcy5leGlzdHMobmFtZSkpIHtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PRU5UXCIsIFwicm1kaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiKTtcbiAgICB9XG4gIH1cbiAgaWYoIXRoaXMuaXNfZGlyKG5hbWUpKSB7XG4gICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT1RESVJcIiwgXCJybWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICBpZihuLm1hdGNoKHIpKSB7XG4gICAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFTk9URU1QVFlcIiwgXCJybWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCI6IERpcmVjdG9yeSBub3QgZW1wdHlcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlbGV0ZSB0aGlzLmNvbnRlbnRbbmFtZV9zbGFzaF07XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJlYWRkaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgPT0gXCJcIik/XCJcIjoodGhpcy5zbGFzaChuYW1lKSk7XG4gIGlmKCF0aGlzLmV4aXN0cyhuYW1lKSkge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiKTtcbiAgfVxuICBpZighdGhpcy5pc19kaXIobmFtZSkpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbiAgfVxuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSspXCIpO1xuICB2YXIgc2VlbiA9IHt9XG4gIHZhciBhID0gW107XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICB2YXIgbSA9IG4ubWF0Y2gocik7XG4gICAgaWYobSAmJiAhc2VlblttWzFdXSkge3NlZW5bbVsxXV0gPSB0cnVlOyBhLnB1c2gobVsxXSl9XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYobmFtZSA9PSBcIlwiKSAgcmV0dXJuIHRydWU7XG4gIHZhciBuYW1lX3NsYXNoID0gdGhpcy5zbGFzaChuYW1lKTtcbiAgcmV0dXJuIHRoaXMuY29udGVudFtuYW1lX3NsYXNoXT8xOjA7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG9rID0gdGhpcy5jb250ZW50W25hbWVdP3RydWU6ZmFsc2U7XG4gIGRlbGV0ZSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIHJldHVybiBvaztcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYpIHtcbiAgaWYoZi5yZG9ubHkgJiYgZi53cm9ubHkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl9yZG9ubHkgYW5kIE9wZW5fd3Jvbmx5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgaWYoZi50ZXh0ICYmIGYuYmluYXJ5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fdGV4dCBhbmQgT3Blbl9iaW5hcnkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgaWYgKHRoaXMuY29udGVudFtuYW1lXSkge1xuICAgIGlmICh0aGlzLmlzX2RpcihuYW1lKSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogaXMgYSBkaXJlY3RvcnlcIik7XG4gICAgaWYgKGYuY3JlYXRlICYmIGYuZXhjbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmlsZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICB2YXIgZmlsZSA9IHRoaXMuY29udGVudFtuYW1lXTtcbiAgICBpZihmLnRydW5jYXRlKSBmaWxlLnRydW5jYXRlKCk7XG4gICAgcmV0dXJuIGZpbGU7XG4gIH0gZWxzZSBpZiAoZi5jcmVhdGUpIHtcbiAgICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKG5hbWUpO1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKTtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlICh0aGlzLm5tKG5hbWUpKTtcbiAgfVxufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJlZ2lzdGVyPSBmdW5jdGlvbiAobmFtZSxjb250ZW50KXtcbiAgdmFyIGZpbGU7XG4gIGlmKHRoaXMuY29udGVudFtuYW1lXSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmlsZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgaWYoY2FtbF9pc19tbF9ieXRlcyhjb250ZW50KSlcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY29udGVudCk7XG4gIGlmKGNhbWxfaXNfbWxfc3RyaW5nKGNvbnRlbnQpKVxuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhjb250ZW50KSk7XG4gIGVsc2UgaWYoY29udGVudCBpbnN0YW5jZW9mIEFycmF5KVxuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX2FycmF5KGNvbnRlbnQpKTtcbiAgZWxzZSBpZih0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIilcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9qc2J5dGVzKGNvbnRlbnQpKTtcbiAgZWxzZSBpZihjb250ZW50LnRvU3RyaW5nKSB7XG4gICAgdmFyIGJ5dGVzID0gY2FtbF9ieXRlc19vZl9zdHJpbmcoY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoY29udGVudC50b1N0cmluZygpKSk7XG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGJ5dGVzKTtcbiAgfVxuICBpZihmaWxlKXtcbiAgICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKG5hbWUpO1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IGZpbGU7XG4gIH1cbiAgZWxzZSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiByZWdpc3RlcmluZyBmaWxlIHdpdGggaW52YWxpZCBjb250ZW50IHR5cGVcIik7XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbEZha2VEZXZpY2VcblxuLy9Qcm92aWRlczogTWxGYWtlRmlsZVxuLy9SZXF1aXJlczogTWxGaWxlXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ibGl0X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19nZXRcbmZ1bmN0aW9uIE1sRmFrZUZpbGUoY29udGVudCl7XG4gIHRoaXMuZGF0YSA9IGNvbnRlbnQ7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5NbEZha2VGaWxlLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGxlbil7XG4gIHZhciBvbGQgPSB0aGlzLmRhdGE7XG4gIHRoaXMuZGF0YSA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbnwwKTtcbiAgY2FtbF9ibGl0X2J5dGVzKG9sZCwgMCwgdGhpcy5kYXRhLCAwLCBsZW4pO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FtbF9tbF9ieXRlc19sZW5ndGgodGhpcy5kYXRhKTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ob2Zmc2V0LGJ1Zixwb3MsbGVuKXtcbiAgdmFyIGNsZW4gPSB0aGlzLmxlbmd0aCgpO1xuICBpZihvZmZzZXQgKyBsZW4gPj0gY2xlbikge1xuICAgIHZhciBuZXdfc3RyID0gY2FtbF9jcmVhdGVfYnl0ZXMob2Zmc2V0ICsgbGVuKTtcbiAgICB2YXIgb2xkX2RhdGEgPSB0aGlzLmRhdGE7XG4gICAgdGhpcy5kYXRhID0gbmV3X3N0cjtcbiAgICBjYW1sX2JsaXRfYnl0ZXMob2xkX2RhdGEsIDAsIHRoaXMuZGF0YSwgMCwgY2xlbik7XG4gIH1cbiAgY2FtbF9ibGl0X3N0cmluZyhidWYsIHBvcywgdGhpcy5kYXRhLCBvZmZzZXQsIGxlbik7XG4gIHJldHVybiAwXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24ob2Zmc2V0LGJ1Zixwb3MsbGVuKXtcbiAgdmFyIGNsZW4gPSB0aGlzLmxlbmd0aCgpO1xuICBjYW1sX2JsaXRfYnl0ZXModGhpcy5kYXRhLCBvZmZzZXQsIGJ1ZiwgcG9zLCBsZW4pO1xuICByZXR1cm4gMFxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUucmVhZF9vbmUgPSBmdW5jdGlvbihvZmZzZXQpe1xuICByZXR1cm4gY2FtbF9ieXRlc19nZXQodGhpcy5kYXRhLCBvZmZzZXQpO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpe1xuXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZUZpbGVcbiIsIi8vUHJvdmlkZXM6IGluaXRpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IHNlcmlhbGl6ZV9uYXQsIGRlc2VyaWFsaXplX25hdCwgY2FtbF9oYXNoX25hdFxuZnVuY3Rpb24gaW5pdGlhbGl6ZV9uYXQoKSB7XG4gIGNhbWxfY3VzdG9tX29wc1tcIl9uYXRcIl0gPVxuICAgIHsgZGVzZXJpYWxpemUgOiBkZXNlcmlhbGl6ZV9uYXQsXG4gICAgICBzZXJpYWxpemUgOiBzZXJpYWxpemVfbmF0LFxuICAgICAgaGFzaCA6IGNhbWxfaGFzaF9uYXRcbiAgICB9XG59XG5cbi8vUHJvdmlkZXM6IE1sTmF0XG5mdW5jdGlvbiBNbE5hdCh4KXtcbiAgdGhpcy5kYXRhID0gbmV3IGdsb2JhbFRoaXMuSW50MzJBcnJheSh4KTtcbiAgLy8gbGVuZ3RoX25hdCBpc24ndCBleHRlcm5hbCwgc28gd2UgaGF2ZSB0byBtYWtlIHRoZSBPYmouc2l6ZVxuICAvLyB3b3JrIG91dCByaWdodC4gVGhlICsyIHRvIGFycmF5IGxlbmd0aCBzZWVtcyB0byB3b3JrLlxuICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggKyAyXG59XG5cbk1sTmF0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX25hdFwiO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbmF0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9uYXQoeCkge1xuICB2YXIgbGVuID0gbnVtX2RpZ2l0c19uYXQoeCwgMCwgeC5kYXRhLmxlbmd0aCk7XG4gIHZhciBoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB4LmRhdGFbaV0pO1xuICB9XG4gIHJldHVybiBoO1xufVxuXG5cbi8vUHJvdmlkZXM6IG5hdF9vZl9hcnJheVxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIG5hdF9vZl9hcnJheShsKXtcbiAgcmV0dXJuIG5ldyBNbE5hdChsKTtcbn1cblxuLy9Qcm92aWRlczogY3JlYXRlX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGNyZWF0ZV9uYXQoc2l6ZSkge1xuICB2YXIgYXJyID0gbmV3IE1sTmF0KHNpemUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgYXJyLmRhdGFbaV0gPSAtMTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfdG9femVyb19uYXRcbmZ1bmN0aW9uIHNldF90b196ZXJvX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJsaXRfbmF0XG5mdW5jdGlvbiBibGl0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBuYXQyLmRhdGFbb2ZzMitpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdFxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdChuYXQsIG9mcywgZGlnaXQpIHtcbiAgbmF0LmRhdGFbb2ZzXSA9IGRpZ2l0O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbnRoX2RpZ2l0X25hdFxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdChuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdF9uYXRpdmVcbmZ1bmN0aW9uIHNldF9kaWdpdF9uYXRfbmF0aXZlKG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMpIHtcbiAgcmV0dXJuIG5hdC5kYXRhW29mc107XG59XG5cbi8vUHJvdmlkZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBudW1fZGlnaXRzX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYobmF0LmRhdGFbb2ZzK2ldICE9IDApIHJldHVybiBpKzE7XG4gIH1cbiAgcmV0dXJuIDE7IC8vIDAgY291bnRzIGFzIDEgZGlnaXRcbn1cblxuLy9Qcm92aWRlczogbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0XG5mdW5jdGlvbiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0LCBvZnMpIHtcbiAgdmFyIGEgPSBuYXQuZGF0YVtvZnNdO1xuICB2YXIgYiA9IDA7XG4gIGlmKGEgJiAweEZGRkYwMDAwKSB7IGIgKz0xNjsgYSA+Pj49MTY7IH1cbiAgaWYoYSAmIDB4RkYwMCkgICAgIHsgYiArPSA4OyBhID4+Pj0gODsgfVxuICBpZihhICYgMHhGMCkgICAgICAgeyBiICs9IDQ7IGEgPj4+PSA0OyB9XG4gIGlmKGEgJiAxMikgICAgICAgICB7IGIgKz0gMjsgYSA+Pj49IDI7IH1cbiAgaWYoYSAmIDIpICAgICAgICAgIHsgYiArPSAxOyBhID4+Pj0gMTsgfVxuICBpZihhICYgMSkgICAgICAgICAgeyBiICs9IDE7IH1cbiAgcmV0dXJuIDMyIC0gYjtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfaW50XG5mdW5jdGlvbiBpc19kaWdpdF9pbnQobmF0LCBvZnMpIHtcbiAgaWYgKG5hdC5kYXRhW29mc10gPj0gMCkgcmV0dXJuIDFcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X3plcm9cbmZ1bmN0aW9uIGlzX2RpZ2l0X3plcm8obmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSA9PSAwKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X29kZFxuZnVuY3Rpb24gaXNfZGlnaXRfb2RkKG5hdCwgb2ZzKSB7XG4gIGlmKG5hdC5kYXRhW29mc10gJiAxKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBpbmNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICh4IHwgMCk7XG4gICAgaWYoeCA9PSAoeCA+Pj4gMCkpIHtcbiAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBhZGRfbmF0XG4vL1JlcXVpcmVzOiBpbmNyX25hdFxuZnVuY3Rpb24gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4ID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKyBjYXJyeTtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHhcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmNyX25hdChuYXQxLCBvZnMxK2xlbjIsIGxlbjEtbGVuMiwgY2FycnkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wbGVtZW50X25hdFxuZnVuY3Rpb24gY29tcGxlbWVudF9uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQuZGF0YVtvZnMraV0gPSAoLTEgPj4+IDApIC0gKG5hdC5kYXRhW29mcytpXSA+Pj4gMCk7XG4gIH1cbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vUHJvdmlkZXM6IGRlY3JfbmF0XG5mdW5jdGlvbiBkZWNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB4ID0gKG5hdC5kYXRhW29mcytpXSA+Pj4wKSAtIGJvcnJvdztcbiAgICBuYXQuZGF0YVtvZnMraV0gPSB4O1xuICAgIGlmICh4ID49IDApIHtcbiAgICAgIGJvcnJvdyA9IDA7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChib3Jyb3cgPT0gMSkgPyAwIDogMTtcbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogc3ViX25hdFxuLy9SZXF1aXJlczogZGVjcl9uYXRcbmZ1bmN0aW9uIHN1Yl9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgY2FycnlfaW4pIHtcbiAgdmFyIGJvcnJvdyA9IChjYXJyeV9pbiA9PSAxKSA/IDAgOiAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIC0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAtIGJvcnJvdztcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCAoYm9ycm93PT0xKT8wOjEpO1xufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzW29mczNdXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IG11bHRfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBhZGRfbmF0LCBuYXRfb2ZfYXJyYXlcbmZ1bmN0aW9uIG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGEgPSAobmF0My5kYXRhW29mczNdID4+PiAwKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4MSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgKyAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApICogKGEgJiAweDAwMDBGRkZGKSArIGNhcnJ5O1xuICAgIHZhciB4MiA9IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSA+Pj4gMTYpO1xuICAgIGNhcnJ5ID0gTWF0aC5mbG9vcih4Mi82NTUzNik7XG4gICAgdmFyIHgzID0geDEgKyAoeDIgJSA2NTUzNikgKiA2NTUzNjtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHgzO1xuICAgIGNhcnJ5ICs9IE1hdGguZmxvb3IoeDMvNDI5NDk2NzI5Nik7XG4gIH1cblxuICBpZihsZW4yIDwgbGVuMSAmJiBjYXJyeSkge1xuICAgIHJldHVybiBhZGRfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBuYXRfb2ZfYXJyYXkoW2NhcnJ5XSksIDAsIDEsIDApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjYXJyeTtcbiAgfVxufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzXG4vLyBsZW4xID49IGxlbjIgKyBsZW4zLlxuLy9Qcm92aWRlczogbXVsdF9uYXRcbi8vUmVxdWlyZXM6IG11bHRfZGlnaXRfbmF0XG5mdW5jdGlvbiBtdWx0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzLCBsZW4zKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4zOyBpKyspIHtcbiAgICBjYXJyeSArPSBtdWx0X2RpZ2l0X25hdChuYXQxLCBvZnMxK2ksIGxlbjEtaSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMytpKTtcbiAgfVxuICByZXR1cm4gY2Fycnk7XG59XG5cbi8vIG5hdDEgPSAyICogbmF0MSArIG5hdDIgKiBuYXQyXG4vLyBsZW4xID49IDIgKiBsZW4yXG4vL1Byb3ZpZGVzOiBzcXVhcmVfbmF0XG4vL1JlcXVpcmVzOiBtdWx0X25hdCwgYWRkX25hdFxuZnVuY3Rpb24gc3F1YXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGNhcnJ5ICs9IGFkZF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0MSwgb2ZzMSwgbGVuMSwgMCk7XG4gIGNhcnJ5ICs9IG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpO1xuICByZXR1cm4gY2Fycnk7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9sZWZ0X25hdFxuZnVuY3Rpb24gc2hpZnRfbGVmdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbmJpdHMpIHtcbiAgaWYobmJpdHMgPT0gMCkge1xuICAgIG5hdDIuZGF0YVtvZnMyXSA9IDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHdyYXAgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMTsgaSsrKSB7XG4gICAgdmFyIGEgPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPDwgbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA+Pj4gKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vLyBBc3N1bWluZyBjID4gYSwgcmV0dXJucyBbcXVvdGllbnQsIHJlbWFpbmRlcl0gb2YgKGE8PDMyICsgYikvY1xuLy9Qcm92aWRlczogZGl2X2hlbHBlclxuZnVuY3Rpb24gZGl2X2hlbHBlcihhLCBiLCBjKSB7XG4gIHZhciB4ID0gYSAqIDY1NTM2ICsgKGI+Pj4xNik7XG4gIHZhciB5ID0gTWF0aC5mbG9vcih4L2MpICogNjU1MzY7XG4gIHZhciB6ID0gKHggJSBjKSAqIDY1NTM2O1xuICB2YXIgdyA9IHogKyAoYiAmIDB4MDAwMEZGRkYpO1xuICByZXR1cm4gW3kgKyBNYXRoLmZsb29yKHcvYyksIHcgJSBjXTtcbn1cblxuLy8gbmF0MVtvZnMxK2xlbl0gPCBuYXQyW29mczJdXG4vL1Byb3ZpZGVzOiBkaXZfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfZGlnaXRfbmF0KG5hdHEsIG9mc3EsIG5hdHIsIG9mc3IsIG5hdDEsIG9mczEsIGxlbiwgbmF0Miwgb2ZzMikge1xuICB2YXIgcmVtID0gKG5hdDEuZGF0YVtvZnMxK2xlbi0xXSA+Pj4wKTtcbiAgLy8gbmF0cVtvZnNxK2xlbi0xXSBpcyBndWFyYW50ZWVkIHRvIGJlIHplcm8gKGR1ZSB0byB0aGUgTVNEIHJlcXVpcmVtZW50KSxcbiAgLy8gYW5kIHNob3VsZCBub3QgYmUgd3JpdHRlbiB0by5cbiAgZm9yKHZhciBpID0gbGVuLTI7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHggPSBkaXZfaGVscGVyKHJlbSwgKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDIuZGF0YVtvZnMyXSA+Pj4gMCkpO1xuICAgIG5hdHEuZGF0YVtvZnNxK2ldID0geFswXTtcbiAgICByZW0gPSB4WzFdO1xuICB9XG4gIG5hdHIuZGF0YVtvZnNyXSA9IHJlbTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIG5hdDFbbmF0MjpdIDo9IG5hdDEgLyBuYXQyXG4vLyBuYXQxWzpuYXQyXSA6PSBuYXQxICUgbmF0MlxuLy8gbGVuMSA+IGxlbjIsIG5hdDJbb2ZzMitsZW4yLTFdID4gbmF0MVtvZnMxK2xlbjEtMV1cbi8vUHJvdmlkZXM6IGRpdl9uYXRcbi8vUmVxdWlyZXM6IGRpdl9kaWdpdF9uYXQsIGRpdl9oZWxwZXIsIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdCwgc2hpZnRfbGVmdF9uYXQsIHNoaWZ0X3JpZ2h0X25hdCwgY3JlYXRlX25hdCwgc2V0X3RvX3plcm9fbmF0LCBtdWx0X2RpZ2l0X25hdCwgc3ViX25hdCwgY29tcGFyZV9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gZGl2X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIGlmKGxlbjIgPT0gMSkge1xuICAgIGRpdl9kaWdpdF9uYXQobmF0MSwgb2ZzMSsxLCBuYXQxLCBvZnMxLCBuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyKTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBzID0gbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0KG5hdDIsIG9mczIrbGVuMi0xKTtcbiAgc2hpZnRfbGVmdF9uYXQobmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG5cbiAgdmFyIGQgPSAobmF0Mi5kYXRhW29mczIrbGVuMi0xXSA+Pj4gMCkgKyAxO1xuICB2YXIgYSA9IGNyZWF0ZV9uYXQobGVuMisxKTtcbiAgZm9yICh2YXIgaSA9IGxlbjEgLSAxOyBpID49IGxlbjI7IGktLSkge1xuICAgIC8vIERlY2VudCBsb3dlciBib3VuZCBvbiBxdW9cbiAgICB2YXIgcXVvID0gZCA9PSA0Mjk0OTY3Mjk2ID8gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA6IGRpdl9oZWxwZXIoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDEuZGF0YVtvZnMxK2ktMV0gPj4+MCksIGQpWzBdO1xuICAgIHNldF90b196ZXJvX25hdChhLCAwLCBsZW4yKzEpO1xuICAgIG11bHRfZGlnaXRfbmF0KGEsIDAsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFtxdW9dKSwgMCk7XG4gICAgc3ViX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMisxLCBhLCAwLCBsZW4yKzEsIDEpO1xuXG4gICAgd2hpbGUgKG5hdDEuZGF0YVtvZnMxK2ldICE9IDAgfHwgY29tcGFyZV9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpID49IDApIHtcbiAgICAgIHF1byA9IHF1byArIDE7XG4gICAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIG5hdDIsIG9mczIsIGxlbjIsIDEpO1xuICAgIH1cblxuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gcXVvO1xuICB9XG5cbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gc2hpZnQgcmVtYWluZGVyXG4gIHNoaWZ0X3JpZ2h0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7IC8vIHJlc3RvcmVcbiAgcmV0dXJuIDA7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9yaWdodF9uYXRcbmZ1bmN0aW9uIHNoaWZ0X3JpZ2h0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IGxlbjEtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgYSA9IG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPj4+IG5iaXRzKSB8IHdyYXA7XG4gICAgd3JhcCA9IGEgPDwgKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfZGlnaXRzX25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA+IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIDE7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA8IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRcbi8vUmVxdWlyZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjb21wYXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBhID0gbnVtX2RpZ2l0c19uYXQobmF0MSwgb2ZzMSwgbGVuMSk7XG4gIHZhciBiID0gbnVtX2RpZ2l0c19uYXQobmF0Miwgb2ZzMiwgbGVuMik7XG4gIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgaWYoYSA8IGIpIHJldHVybiAtMTtcbiAgZm9yKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgPiAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApKSByZXR1cm4gMTtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA8IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRfcmVhbFxuLy9SZXF1aXJlczogY29tcGFyZV9uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0X3JlYWwobmF0MSxuYXQyKXtcbiAgcmV0dXJuIGNvbXBhcmVfbmF0KG5hdDEsMCxuYXQxLmRhdGEubGVuZ3RoLG5hdDIsMCxuYXQyLmRhdGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogbGFuZF9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxhbmRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdICY9IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGxvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gfD0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbHhvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGx4b3JfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdIF49IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogc2VyaWFsaXplX25hdFxuZnVuY3Rpb24gc2VyaWFsaXplX25hdCh3cml0ZXIsIG5hdCwgc3ope1xuICB2YXIgbGVuID0gbmF0LmRhdGEubGVuZ3RoO1xuICB3cml0ZXIud3JpdGUoMzIsIGxlbik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgd3JpdGVyLndyaXRlKDMyLCBuYXQuZGF0YVtpXSk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICBzelsxXSA9IGxlbiAqIDg7XG59XG5cbi8vUHJvdmlkZXM6IGRlc2VyaWFsaXplX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGRlc2VyaWFsaXplX25hdChyZWFkZXIsIHN6KXtcbiAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBuYXQgPSBuZXcgTWxOYXQobGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBuYXQuZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICByZXR1cm4gbmF0O1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IEh1Z28gSGV1emFyZFxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZVxudmFyIGNhbWxfZ3Jfc3RhdGU7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2dldCgpIHtcbiAgaWYoY2FtbF9ncl9zdGF0ZSkge1xuICAgIHJldHVybiBjYW1sX2dyX3N0YXRlO1xuICB9XG4gIHRocm93IFswLGNhbWxfbmFtZWRfdmFsdWUoXCJHcmFwaGljcy5HcmFwaGljX2ZhaWx1cmVcIiksIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJOb3QgaW5pdGlhbGl6ZWRcIildXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZSxjYW1sX2dyX3N0YXRlX2luaXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfc2V0KGN0eCkge1xuICBjYW1sX2dyX3N0YXRlPWN0eDtcbiAgY2FtbF9ncl9zdGF0ZV9pbml0KClcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9vcGVuX2dyYXBoKGluZm8pe1xuICB2YXIgZyA9IGdsb2JhbFRoaXM7XG4gIHZhciBpbmZvID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoaW5mbyk7XG4gIGZ1bmN0aW9uIGdldChuYW1lKXtcbiAgICB2YXIgcmVzID0gaW5mby5tYXRjaChcIihefCwpICpcIituYW1lK1wiICo9ICooW2EtekEtWjAtOV9dKykgKigsfCQpXCIpO1xuICAgIGlmKHJlcykgcmV0dXJuIHJlc1syXTtcbiAgfVxuICB2YXIgc3BlY3MgPSBbXTtcbiAgaWYoIShpbmZvPT1cIlwiKSkgc3BlY3MucHVzaChpbmZvKTtcbiAgdmFyIHRhcmdldCA9IGdldChcInRhcmdldFwiKTtcbiAgaWYoIXRhcmdldCkgdGFyZ2V0PVwiXCI7XG4gIHZhciBzdGF0dXMgPSBnZXQoXCJzdGF0dXNcIik7XG4gIGlmKCFzdGF0dXMpIHNwZWNzLnB1c2goXCJzdGF0dXM9MVwiKVxuXG4gIHZhciB3ID0gZ2V0KFwid2lkdGhcIik7XG4gIHcgPSB3P3BhcnNlSW50KHcpOjIwMDtcbiAgc3BlY3MucHVzaChcIndpZHRoPVwiK3cpO1xuXG4gIHZhciBoID0gZ2V0KFwiaGVpZ2h0XCIpO1xuICBoID0gaD9wYXJzZUludChoKToyMDA7XG4gIHNwZWNzLnB1c2goXCJoZWlnaHQ9XCIraCk7XG5cbiAgdmFyIHdpbiA9IGcub3BlbihcImFib3V0OmJsYW5rXCIsdGFyZ2V0LHNwZWNzLmpvaW4oXCIsXCIpKTtcbiAgaWYoIXdpbikge2NhbWxfZmFpbHdpdGgoXCJHcmFwaGljcy5vcGVuX2dyYXBoOiBjYW5ub3Qgb3BlbiB0aGUgd2luZG93XCIpfVxuICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuICB2YXIgY2FudmFzID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNhbnZhcy53aWR0aCA9IHc7XG4gIGNhbnZhcy5oZWlnaHQgPSBoO1xuICB2YXIgY3R4ID0gY2FtbF9ncl9zdGF0ZV9jcmVhdGUoY2FudmFzLHcsaCk7XG4gIGN0eC5zZXRfdGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICBkb2MudGl0bGUgPSB0aXRsZTtcbiAgfTtcbiAgY2FtbF9ncl9zdGF0ZV9zZXQoY3R4KTtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgYm9keS5zdHlsZS5tYXJnaW4gPSBcIjBweFwiO1xuICBib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2luaXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X2NvbG9yLGNhbWxfZ3JfbW92ZXRvLGNhbWxfZ3JfcmVzaXplX3dpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfbGluZV93aWR0aCxjYW1sX2dyX3NldF90ZXh0X3NpemUsY2FtbF9ncl9zZXRfZm9udFxuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2luaXQoKXtcbiAgY2FtbF9ncl9tb3ZldG8oY2FtbF9ncl9zdGF0ZS54LGNhbWxfZ3Jfc3RhdGUueSk7XG4gIGNhbWxfZ3JfcmVzaXplX3dpbmRvdyhjYW1sX2dyX3N0YXRlLndpZHRoLGNhbWxfZ3Jfc3RhdGUuaGVpZ2h0KTtcbiAgY2FtbF9ncl9zZXRfbGluZV93aWR0aChjYW1sX2dyX3N0YXRlLmxpbmVfd2lkdGgpO1xuICBjYW1sX2dyX3NldF90ZXh0X3NpemUoY2FtbF9ncl9zdGF0ZS50ZXh0X3NpemUpO1xuICBjYW1sX2dyX3NldF9mb250KGNhbWxfZ3Jfc3RhdGUuZm9udCk7XG4gIGNhbWxfZ3Jfc2V0X2NvbG9yKGNhbWxfZ3Jfc3RhdGUuY29sb3IpO1xuICBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUoY2FtbF9ncl9zdGF0ZS50aXRsZSk7XG4gIC8vY2FtbF9ncl9yZXNpemVfd2luZG93IG1pZ2h0IHJlc2V0IHNvbWUgY2FudmFzJyBwcm9wZXJ0aWVzXG4gIGNhbWxfZ3Jfc3RhdGUuY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfY3JlYXRlKGNhbnZhcyx3LGgpe1xuICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIHJldHVybiB7XG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBjYW52YXMgOiBjYW52YXMsXG4gICAgeCA6IDAsXG4gICAgeSA6IDAsXG4gICAgd2lkdGggOiB3LFxuICAgIGhlaWdodCA6IGgsXG4gICAgbGluZV93aWR0aCA6IDEsXG4gICAgZm9udCA6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJmaXhlZFwiKSxcbiAgICB0ZXh0X3NpemUgOiAyNixcbiAgICBjb2xvciA6IDB4MDAwMDAwLFxuICAgIHRpdGxlIDogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKVxuICB9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RvY19vZl9zdGF0ZVxuZnVuY3Rpb24gY2FtbF9ncl9kb2Nfb2Zfc3RhdGUoc3RhdGUpIHtcbiAgaWYoc3RhdGUuY2FudmFzLm93bmVyRG9jdW1lbnQpXG4gICAgcmV0dXJuIHN0YXRlLmNhbnZhcy5vd25lckRvY3VtZW50O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Nsb3NlX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jbG9zZV9ncmFwaCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY2FudmFzLndpZHRoID0gMDtcbiAgcy5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUobmFtZSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy50aXRsZSA9IG5hbWU7XG4gIHZhciBqc25hbWUgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYocy5zZXRfdGl0bGUpIHMuc2V0X3RpdGxlKGpzbmFtZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3codyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpXG4gIHMud2lkdGggPSB3O1xuICBzLmhlaWdodCA9IGg7XG4gIHMuY2FudmFzLndpZHRoID0gdztcbiAgcy5jYW52YXMuaGVpZ2h0ID0gaDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xlYXJfZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NsZWFyX2dyYXBoKCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jYW52YXMud2lkdGggPSBzLndpZHRoO1xuICBzLmNhbnZhcy5oZWlnaHQgPSBzLmhlaWdodDtcbiAgLy8gIHMuY29udGV4dC5zdHJva2VSZWN0ICgwLiwgMC4sIHMud2lkdGgsIHMuaGVpZ2h0KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2l6ZV94XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zaXplX3goKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy53aWR0aDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2l6ZV95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zaXplX3koKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy5oZWlnaHQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfY29sb3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NldF9jb2xvcihjb2xvcil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgZnVuY3Rpb24gY29udmVydChudW1iZXIpIHtcbiAgICB2YXIgc3RyID0gJycgKyBudW1iZXIudG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgMikgc3RyID0gJzAnICsgc3RyO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgdmFyXG4gIHIgPSAoY29sb3IgPj4gMTYpICYgMHhmZixcbiAgZyA9IChjb2xvciA+PiA4KSAgJiAweGZmLFxuICBiID0gKGNvbG9yID4+IDApICAmIDB4ZmY7XG4gIHMuY29sb3I9Y29sb3I7XG4gIHZhciBjX3N0ciA9ICcjJyArIGNvbnZlcnQocikgKyBjb252ZXJ0KGcpICsgY29udmVydChiKTtcbiAgcy5jb250ZXh0LmZpbGxTdHlsZSA9ICAgY19zdHI7XG4gIHMuY29udGV4dC5zdHJva2VTdHlsZSA9IGNfc3RyO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcGxvdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcGxvdCh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbT1zLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKDEsMSk7XG4gIHZhciBkID0gaW0uZGF0YTtcbiAgdmFyIGNvbG9yID0gcy5jb2xvcjtcbiAgZFswXSA9IChjb2xvciA+PiAxNikgJiAweGZmOyAvL3JcbiAgZFsxXSA9IChjb2xvciA+PiA4KSAgJiAweGZmLCAvL2dcbiAgZFsyXSA9IChjb2xvciA+PiAwKSAgJiAweGZmOyAvL2JcbiAgZFszXSA9IDB4RkY7IC8vYVxuICBzLng9eDtcbiAgcy55PXk7XG4gIHMuY29udGV4dC5wdXRJbWFnZURhdGEoaW0seCxzLmhlaWdodCAtIHkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9wb2ludF9jb2xvclxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcG9pbnRfY29sb3IoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW09cy5jb250ZXh0LmdldEltYWdlRGF0YSh4LHMuaGVpZ2h0IC0geSwxLDEpO1xuICB2YXIgZCA9IGltLmRhdGE7XG4gIHJldHVybiAoZFswXSA8PCAxNikgKyAoZFsxXSA8PCA4KSArIGRbMl07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21vdmV0b1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbW92ZXRvKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy54PXg7XG4gIHMueT15O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jdXJyZW50X3hcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2N1cnJlbnRfeCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLnhcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3VycmVudF95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jdXJyZW50X3koKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy55XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2xpbmV0b1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbGluZXRvKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBzLmNvbnRleHQubW92ZVRvKHMueCxzLmhlaWdodCAtIHMueSk7XG4gIHMuY29udGV4dC5saW5lVG8oeCxzLmhlaWdodCAtIHkpO1xuICBzLmNvbnRleHQuc3Ryb2tlKCk7XG4gIHMueD14O1xuICBzLnk9eTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfcmVjdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19yZWN0KHgseSx3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5zdHJva2VSZWN0KHgscy5oZWlnaHQgLSB5LHcsLWgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2FyY19hdXgoY3R4LGN4LGN5LHJ5LHJ4LGExLGEyKXtcbiAgd2hpbGUoYTE+YTIpIGEyKz0zNjA7XG4gIGExIC89IDE4MDtcbiAgYTIgLz0gMTgwO1xuICB2YXIgcm90ID0gMCx4UG9zLHlQb3MseFBvc19wcmV2LHlQb3NfcHJldjtcbiAgdmFyIHNwYWNlID0gMjtcbiAgdmFyIG51bSA9ICgoKGEyIC0gYTEpICogTWF0aC5QSSAqICgocngrcnkpLzIpKSAvIHNwYWNlKSB8IDA7XG4gIHZhciBkZWx0YSA9IChhMiAtIGExKSAqIE1hdGguUEkgLyBudW07XG4gIHZhciBpID0gYTEgKiBNYXRoLlBJO1xuICBmb3IgKHZhciBqPTA7ajw9bnVtO2orKyl7XG4gICAgeFBvcyA9IGN4IC0gKHJ4ICogTWF0aC5zaW4oaSkpICogTWF0aC5zaW4ocm90ICogTWF0aC5QSSkgKyAocnkgKiBNYXRoLmNvcyhpKSkgKiBNYXRoLmNvcyhyb3QgKiBNYXRoLlBJKTtcbiAgICB4UG9zID0geFBvcy50b0ZpeGVkKDIpO1xuICAgIHlQb3MgPSBjeSArIChyeSAqIE1hdGguY29zKGkpKSAqIE1hdGguc2luKHJvdCAqIE1hdGguUEkpICsgKHJ4ICogTWF0aC5zaW4oaSkpICogTWF0aC5jb3Mocm90ICogTWF0aC5QSSk7XG4gICAgeVBvcyA9IHlQb3MudG9GaXhlZCgyKTtcbiAgICBpZiAoaj09MCkge1xuICAgICAgY3R4Lm1vdmVUbyh4UG9zLCB5UG9zKTtcbiAgICB9IGVsc2UgaWYgKHhQb3NfcHJldiE9eFBvcyB8fCB5UG9zX3ByZXYhPXlQb3Mpe1xuICAgICAgY3R4LmxpbmVUbyh4UG9zLCB5UG9zKTtcbiAgICB9XG4gICAgeFBvc19wcmV2PXhQb3M7XG4gICAgeVBvc19wcmV2PXlQb3M7XG4gICAgaS09IGRlbHRhOy8vY2N3XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2FyY1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXQsIGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2FyYyh4LHkscngscnksYTEsYTIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY2FtbF9ncl9hcmNfYXV4KHMuY29udGV4dCx4LHMuaGVpZ2h0IC0geSxyeCxyeSxhMSxhMik7XG4gIHMuY29udGV4dC5zdHJva2UoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NldF9saW5lX3dpZHRoKHcpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMubGluZV93aWR0aCA9IHc7XG4gIHMuY29udGV4dC5saW5lV2lkdGggPSB3XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfcmVjdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9yZWN0KHgseSx3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5maWxsUmVjdCh4LHMuaGVpZ2h0IC0geSx3LC1oKTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfcG9seVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9wb2x5KGFyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHMuY29udGV4dC5tb3ZlVG8oYXJbMV1bMV0scy5oZWlnaHQgLSBhclsxXVsyXSk7XG4gIGZvcih2YXIgaSA9IDI7IGkgPCBhci5sZW5ndGg7IGkrKylcbiAgICBzLmNvbnRleHQubGluZVRvKGFyW2ldWzFdLHMuaGVpZ2h0IC0gYXJbaV1bMl0pO1xuICBzLmNvbnRleHQubGluZVRvKGFyWzFdWzFdLHMuaGVpZ2h0IC0gYXJbMV1bMl0pO1xuICBzLmNvbnRleHQuZmlsbCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX2FyY1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXQsIGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX2FyYyh4LHkscngscnksYTEsYTIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY2FtbF9ncl9hcmNfYXV4KHMuY29udGV4dCx4LHMuaGVpZ2h0IC0geSxyeCxyeSxhMSxhMik7XG4gIHMuY29udGV4dC5maWxsKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3N0cihzdHIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBtID0gcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHN0cik7XG4gIHZhciBkeCA9IG0ud2lkdGg7XG4gIHMuY29udGV4dC5maWxsVGV4dChzdHIscy54LHMuaGVpZ2h0IC0gcy55KTtcbiAgcy54ICs9IGR4IHwgMDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX2dyX2RyYXdfc3RyXG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfY2hhcihjKXtcbiAgY2FtbF9ncl9kcmF3X3N0cihTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfZ3JfZHJhd19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfc3RyaW5nKHN0cil7XG4gIGNhbWxfZ3JfZHJhd19zdHIoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoc3RyKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9mb250XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2ZvbnQoZil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5mb250ID0gZjtcbiAgcy5jb250ZXh0LmZvbnQgPSBzLnRleHRfc2l6ZSArIFwicHggXCIgKyBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzLmZvbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfdGV4dF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZShzaXplKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLnRleHRfc2l6ZSA9IHNpemU7XG4gIHMuY29udGV4dC5mb250ID0gcy50ZXh0X3NpemUgKyBcInB4IFwiICsgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocy5mb250KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfdGV4dF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3JfdGV4dF9zaXplKHR4dCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIHcgPSBzLmNvbnRleHQubWVhc3VyZVRleHQoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcodHh0KSkud2lkdGg7XG4gIHJldHVybiBbMCx3LHMudGV4dF9zaXplXTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21ha2VfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX21ha2VfaW1hZ2UoYXJyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaCA9IGFyci5sZW5ndGggLSAxIDtcbiAgdmFyIHcgPSBhcnJbMV0ubGVuZ3RoIC0gMTtcbiAgdmFyIGltID0gcy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3LGgpO1xuICBmb3IodmFyIGk9MDtpPGg7aSsrKXtcbiAgICBmb3IodmFyIGo9MDtqPHc7aisrKXtcbiAgICAgIHZhciBjID0gYXJyW2krMV1baisxXTtcbiAgICAgIHZhciBvID0gaSoodyo0KSArIChqICogNCk7XG4gICAgICBpZihjID09IC0xKSB7XG4gICAgICAgIGltLmRhdGFbbyArIDBdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgMV0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAyXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDNdID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltLmRhdGFbbyArIDBdID0gYyA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDFdID0gYyA+PiAgOCAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDJdID0gYyA+PiAgMCAmIDBYZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDNdID0gMHhmZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGltXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2R1bXBfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2R1bXBfaW1hZ2UoaW0pe1xuICB2YXIgZGF0YSA9IFswXVxuICBmb3IodmFyIGk9MDsgaTxpbS5oZWlnaHQ7aSsrKXtcbiAgICBkYXRhW2krMV0gPSBbMF1cbiAgICBmb3IodmFyIGo9MDsgajxpbS53aWR0aDtqKyspe1xuICAgICAgdmFyIG8gPSBpKihpbS53aWR0aCo0KSArIChqICogNCksXG4gICAgICAgICAgciA9IGltLmRhdGFbbyswXSxcbiAgICAgICAgICBnID0gaW0uZGF0YVtvKzFdLFxuICAgICAgICAgIGIgPSBpbS5kYXRhW28rMl07XG4gICAgICBkYXRhW2krMV1baisxXSA9IChyIDw8IDE2KSArIChnIDw8IDgpICsgYlxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2ltYWdlKGltLHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgaWYoIWltLmltYWdlKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gcy53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gcy5oZWlnaHQ7XG4gICAgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5wdXRJbWFnZURhdGEoaW0sMCwwKTtcbiAgICB2YXIgaW1hZ2UgPSBuZXcgZ2xvYmFsVGhpcy5JbWFnZSgpO1xuICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHMuY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UseCxzLmhlaWdodCAtIGltLmhlaWdodCAtIHkpO1xuICAgICAgaW0uaW1hZ2UgPSBpbWFnZTtcbiAgICB9XG4gICAgaW1hZ2Uuc3JjID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgfSBlbHNlIHtcbiAgICBzLmNvbnRleHQuZHJhd0ltYWdlKGltLmltYWdlLHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3JlYXRlX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jcmVhdGVfaW1hZ2UoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh4LHkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9ibGl0X2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9ibGl0X2ltYWdlKGltLHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltMiA9IHMuY29udGV4dC5nZXRJbWFnZURhdGEoeCxzLmhlaWdodCAtIGltLmhlaWdodCAtIHksaW0ud2lkdGgsaW0uaGVpZ2h0KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbTIuZGF0YS5sZW5ndGg7IGkrPTQpe1xuICAgIGltLmRhdGFbaV0gPSBpbTIuZGF0YVtpXTtcbiAgICBpbS5kYXRhW2krMV0gPSBpbTIuZGF0YVtpKzFdO1xuICAgIGltLmRhdGFbaSsyXSA9IGltMi5kYXRhW2krMl07XG4gICAgaW0uZGF0YVtpKzNdID0gaW0yLmRhdGFbaSszXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2lnaW9faGFuZGxlclxuZnVuY3Rpb24gY2FtbF9ncl9zaWdpb19oYW5kbGVyKCl7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpZ2lvX3NpZ25hbFxuZnVuY3Rpb24gY2FtbF9ncl9zaWdpb19zaWduYWwoKXtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfd2FpdF9ldmVudFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl93YWl0X2V2ZW50KF9ldmwpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl93YWl0X2V2ZW50IG5vdCBJbXBsZW1lbnRlZDogdXNlIEdyYXBoaWNzX2pzIGluc3RlYWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3luY2hyb25pemVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3luY2hyb25pemUgKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9zeW5jaHJvbml6ZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3JlbWVtYmVyX21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3JfcmVtZW1iZXJfbW9kZSAoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3JlbWVtYmVyX21vZGUgbm90IEltcGxlbWVudGVkXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kaXNwbGF5X21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3JfZGlzcGxheV9tb2RlKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9kaXNwbGF5X21vZGUgbm90IEltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3dpbmRvd19pZFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl93aW5kb3dfaWQoYSkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl93aW5kb3dfaWQgbm90IEltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX29wZW5fc3Vid2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX29wZW5fc3Vid2luZG93KGEsYixjLGQpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3cgbm90IEltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Nsb3NlX3N1YndpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3coYSkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3cgbm90IEltcGxlbWVudGVkXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9jb25zdGFudHNcbnZhciBjYW1sX21hcnNoYWxfY29uc3RhbnRzID0ge1xuICBQUkVGSVhfU01BTExfQkxPQ0s6ICAgICAgICAgMHg4MCxcbiAgUFJFRklYX1NNQUxMX0lOVDogICAgICAgICAgIDB4NDAsXG4gIFBSRUZJWF9TTUFMTF9TVFJJTkc6ICAgICAgICAweDIwLFxuICBDT0RFX0lOVDg6ICAgICAgICAgICAgICAgICAgMHgwMCxcbiAgQ09ERV9JTlQxNjogICAgICAgICAgICAgICAgIDB4MDEsXG4gIENPREVfSU5UMzI6ICAgICAgICAgICAgICAgICAweDAyLFxuICBDT0RFX0lOVDY0OiAgICAgICAgICAgICAgICAgMHgwMyxcbiAgQ09ERV9TSEFSRUQ4OiAgICAgICAgICAgICAgIDB4MDQsXG4gIENPREVfU0hBUkVEMTY6ICAgICAgICAgICAgICAweDA1LFxuICBDT0RFX1NIQVJFRDMyOiAgICAgICAgICAgICAgMHgwNixcbiAgQ09ERV9CTE9DSzMyOiAgICAgICAgICAgICAgIDB4MDgsXG4gIENPREVfQkxPQ0s2NDogICAgICAgICAgICAgICAweDEzLFxuICBDT0RFX1NUUklORzg6ICAgICAgICAgICAgICAgMHgwOSxcbiAgQ09ERV9TVFJJTkczMjogICAgICAgICAgICAgIDB4MEEsXG4gIENPREVfRE9VQkxFX0JJRzogICAgICAgICAgICAweDBCLFxuICBDT0RFX0RPVUJMRV9MSVRUTEU6ICAgICAgICAgMHgwQyxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0JJRzogICAgIDB4MEQsXG4gIENPREVfRE9VQkxFX0FSUkFZOF9MSVRUTEU6ICAweDBFLFxuICBDT0RFX0RPVUJMRV9BUlJBWTMyX0JJRzogICAgMHgwRixcbiAgQ09ERV9ET1VCTEVfQVJSQVkzMl9MSVRUTEU6IDB4MDcsXG4gIENPREVfQ09ERVBPSU5URVI6ICAgICAgICAgICAweDEwLFxuICBDT0RFX0lORklYUE9JTlRFUjogICAgICAgICAgMHgxMSxcbiAgQ09ERV9DVVNUT006ICAgICAgICAgICAgICAgIDB4MTIsXG4gIENPREVfQ1VTVE9NX0xFTjogICAgICAgICAgICAweDE4LFxuICBDT0RFX0NVU1RPTV9GSVhFRDogICAgICAgICAgMHgxOVxufVxuXG5cbi8vUHJvdmlkZXM6IE1sU3RyaW5nUmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBNbFN0cmluZ1JlYWRlciAocywgaSkgeyB0aGlzLnMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpOyB0aGlzLmkgPSBpOyB9XG5NbFN0cmluZ1JlYWRlci5wcm90b3R5cGUgPSB7XG4gIHJlYWQ4dTpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnMuY2hhckNvZGVBdCh0aGlzLmkrKyk7IH0sXG4gIHJlYWQ4czpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnMuY2hhckNvZGVBdCh0aGlzLmkrKykgPDwgMjQgPj4gMjQ7IH0sXG4gIHJlYWQxNnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkgKyAxKVxuICB9LFxuICByZWFkMTZzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCAyNCA+PiAxNikgfCBzLmNoYXJDb2RlQXQoaSArIDEpO1xuICB9LFxuICByZWFkMzJ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKChzLmNoYXJDb2RlQXQoaSkgPDwgMjQpIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDE2KSB8XG4gICAgICAgICAgICAocy5jaGFyQ29kZUF0KGkrMikgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSszKSkgPj4+IDA7XG4gIH0sXG4gIHJlYWQzMnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCAxNikgfFxuICAgICAgKHMuY2hhckNvZGVBdChpKzIpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkrMyk7XG4gIH0sXG4gIHJlYWRzdHI6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXModGhpcy5zLnN1YnN0cmluZyhpLCBpICsgbGVuKSk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogQmlnU3RyaW5nUmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheSwgY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gQmlnU3RyaW5nUmVhZGVyIChicywgaSkgeyB0aGlzLnMgPSBiczsgdGhpcy5pID0gaTsgfVxuQmlnU3RyaW5nUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbWxfYmFfZ2V0XzEodGhpcy5zLHRoaXMuaSsrKTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbWxfYmFfZ2V0XzEodGhpcy5zLHRoaXMuaSsrKSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgPDwgOCkgfCBjYW1sX2JhX2dldF8xKHMsaSArIDEpXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpIDw8IDI0ID4+IDE2KSB8IGNhbWxfYmFfZ2V0XzEocyxpICsgMSk7XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKGNhbWxfYmFfZ2V0XzEocyxpKSAgIDw8IDI0KSB8IChjYW1sX2JhX2dldF8xKHMsaSsxKSA8PCAxNikgfFxuICAgICAgICAgICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpICAgICAgICAgKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgICA8PCAyNCkgfCAoY2FtbF9iYV9nZXRfMShzLGkrMSkgPDwgMTYpIHxcbiAgICAgIChjYW1sX2JhX2dldF8xKHMsaSsyKSA8PCA4KSAgfCBjYW1sX2JhX2dldF8xKHMsaSszKTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdmFyIGFyciA9IG5ldyBBcnJheShsZW4pXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKXtcbiAgICAgIGFycltqXSA9IGNhbWxfYmFfZ2V0XzEodGhpcy5zLCBpK2opO1xuICAgIH1cbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheShhcnIpO1xuICB9XG59XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKGEpIHtcbiAgcmV0dXJuIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoY2FtbF9pbnQ2NF9vZl9ieXRlcyAoYSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sU3RyaW5nUmVhZGVyLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nKHMsb2ZzKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgTWxTdHJpbmdSZWFkZXIgKHMsIHR5cGVvZiBvZnM9PVwibnVtYmVyXCI/b2ZzOm9mc1swXSk7XG4gIHJldHVybiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxTdHJpbmdSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIsIGNhbWxfc3RyaW5nX29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbFN0cmluZ1JlYWRlciAoY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocyksIHR5cGVvZiBvZnM9PVwibnVtYmVyXCI/b2ZzOm9mc1swXSk7XG4gIHJldHVybiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF91bm1hcnNoYWwocmVhZGVyLCBzaXplKXtcbiAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gIHNpemVbMF0gPSA4O1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyAodCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tYXJzaGFsKHdyaXRlciwgdiwgc2l6ZXMpIHtcbiAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzICh2KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHdyaXRlci53cml0ZSAoOCwgYltpXSk7XG4gIHNpemVzWzBdID0gODsgc2l6ZXNbMV0gPSA4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX3VubWFyc2hhbFxuZnVuY3Rpb24gY2FtbF9pbnQzMl91bm1hcnNoYWwocmVhZGVyLCBzaXplKXtcbiAgc2l6ZVswXSA9IDQ7XG4gIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWwocmVhZGVyLCBzaXplKXtcbiAgc3dpdGNoIChyZWFkZXIucmVhZDh1ICgpKSB7XG4gIGNhc2UgMTpcbiAgICBzaXplWzBdID0gNDtcbiAgICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG4gIGNhc2UgMjpcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IG5hdGl2ZSBpbnRlZ2VyIHZhbHVlIHRvbyBsYXJnZVwiKTtcbiAgZGVmYXVsdDogY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG5hdGl2ZSBpbnRlZ2VyXCIpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF91bm1hcnNoYWwsIGNhbWxfaW50NjRfbWFyc2hhbCwgY2FtbF9pbnQ2NF9jb21wYXJlLCBjYW1sX2ludDY0X2hhc2hcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfdW5tYXJzaGFsLCBjYW1sX25hdGl2ZWludF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfYmFfc2VyaWFsaXplLCBjYW1sX2JhX2Rlc2VyaWFsaXplLCBjYW1sX2JhX2NvbXBhcmUsIGNhbWxfYmFfaGFzaFxudmFyIGNhbWxfY3VzdG9tX29wcyA9XG4gICAge1wiX2pcIjoge1xuICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX2ludDY0X3VubWFyc2hhbCxcbiAgICAgIHNlcmlhbGl6ZSAgOiBjYW1sX2ludDY0X21hcnNoYWwsXG4gICAgICBmaXhlZF9sZW5ndGggOiA4LFxuICAgICAgY29tcGFyZSA6IGNhbWxfaW50NjRfY29tcGFyZSxcbiAgICAgIGhhc2ggOiBjYW1sX2ludDY0X2hhc2hcbiAgICB9LFxuICAgICBcIl9pXCI6IHtcbiAgICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfaW50MzJfdW5tYXJzaGFsLFxuICAgICAgIGZpeGVkX2xlbmd0aCA6IDQsXG4gICAgIH0sXG4gICAgIFwiX25cIjoge1xuICAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsLFxuICAgICAgIGZpeGVkX2xlbmd0aCA6IDQsXG4gICAgIH0sXG4gICAgIFwiX2JpZ2FycmF5XCI6e1xuICAgICAgIGRlc2VyaWFsaXplIDogKGZ1bmN0aW9uIChyZWFkZXIsIHN6KSB7cmV0dXJuIGNhbWxfYmFfZGVzZXJpYWxpemUgKHJlYWRlcixzeixcIl9iaWdhcnJheVwiKX0pLFxuICAgICAgIHNlcmlhbGl6ZSA6IGNhbWxfYmFfc2VyaWFsaXplLFxuICAgICAgIGNvbXBhcmUgOiBjYW1sX2JhX2NvbXBhcmUsXG4gICAgICAgaGFzaDogY2FtbF9iYV9oYXNoLFxuICAgICB9LFxuICAgICBcIl9iaWdhcnIwMlwiOntcbiAgICAgICBkZXNlcmlhbGl6ZSA6IChmdW5jdGlvbiAocmVhZGVyLCBzeikge3JldHVybiBjYW1sX2JhX2Rlc2VyaWFsaXplIChyZWFkZXIsc3osXCJfYmlnYXJyMDJcIil9KSxcbiAgICAgICBzZXJpYWxpemUgOiBjYW1sX2JhX3NlcmlhbGl6ZSxcbiAgICAgICBjb21wYXJlIDogY2FtbF9iYV9jb21wYXJlLFxuICAgICAgIGhhc2g6IGNhbWxfYmFfaGFzaCxcbiAgICAgfVxuICAgIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2Zsb2F0X29mX2J5dGVzLCBjYW1sX2N1c3RvbV9vcHNcblxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcykge1xuICB2YXIgX21hZ2ljID0gcmVhZGVyLnJlYWQzMnUgKClcbiAgdmFyIF9ibG9ja19sZW4gPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIG51bV9vYmplY3RzID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBfc2l6ZV8zMiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgX3NpemVfNjQgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBpbnRlcm5fb2JqX3RhYmxlID0gKG51bV9vYmplY3RzID4gMCk/W106bnVsbDtcbiAgdmFyIG9ial9jb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gaW50ZXJuX3JlYyAoKSB7XG4gICAgdmFyIGNvZGUgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgIGlmIChjb2RlID49IDB4NDAgLypjc3QuUFJFRklYX1NNQUxMX0lOVCovKSB7XG4gICAgICBpZiAoY29kZSA+PSAweDgwIC8qY3N0LlBSRUZJWF9TTUFMTF9CTE9DSyovKSB7XG4gICAgICAgIHZhciB0YWcgPSBjb2RlICYgMHhGO1xuICAgICAgICB2YXIgc2l6ZSA9IChjb2RlID4+IDQpICYgMHg3O1xuICAgICAgICB2YXIgdiA9IFt0YWddO1xuICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gKGNvZGUgJiAweDNGKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvZGUgPj0gMHgyMC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcgKi8pIHtcbiAgICAgICAgdmFyIGxlbiA9IGNvZGUgJiAweDFGO1xuICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoKGNvZGUpIHtcbiAgICAgICAgY2FzZSAweDAwOiAvL2NzdC5DT0RFX0lOVDg6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkOHMgKCk7XG4gICAgICAgIGNhc2UgMHgwMTogLy9jc3QuQ09ERV9JTlQxNjpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQxNnMgKCk7XG4gICAgICAgIGNhc2UgMHgwMjogLy9jc3QuQ09ERV9JTlQzMjpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG4gICAgICAgIGNhc2UgMHgwMzogLy9jc3QuQ09ERV9JTlQ2NDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGludGVnZXIgdG9vIGxhcmdlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDQ6IC8vY3N0LkNPREVfU0hBUkVEODpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNTogLy9jc3QuQ09ERV9TSEFSRUQxNjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQxNnUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDY6IC8vY3N0LkNPREVfU0hBUkVEMzI6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA4OiAvL2NzdC5DT0RFX0JMT0NLMzI6XG4gICAgICAgICAgdmFyIGhlYWRlciA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgIHZhciB0YWcgPSBoZWFkZXIgJiAweEZGO1xuICAgICAgICAgIHZhciBzaXplID0gaGVhZGVyID4+IDEwO1xuICAgICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgICAgaWYgKHNpemUgPT0gMCkgcmV0dXJuIHY7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgxMzogLy9jc3QuQ09ERV9CTE9DSzY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGRhdGEgYmxvY2sgdG9vIGxhcmdlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDk6IC8vY3N0LkNPREVfU1RSSU5HODpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEE6IC8vY3N0LkNPREVfU1RSSU5HMzI6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQzogLy9jc3QuQ09ERV9ET1VCTEVfTElUVExFOlxuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgODtpKyspIHRbNyAtIGldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBCOiAvL2NzdC5DT0RFX0RPVUJMRV9CSUc6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFtpXSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgdmFyIHYgPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRTogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbNyAtIGpdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdltpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBEOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MDc6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbNyAtIGpdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdltpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBGOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWTMyX0JJRzpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2IFtpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEwOiAvL2NzdC5DT0RFX0NPREVQT0lOVEVSOlxuICAgICAgICBjYXNlIDB4MTE6IC8vY3N0LkNPREVfSU5GSVhQT0lOVEVSOlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGNvZGUgcG9pbnRlclwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDEyOiAvL2NzdC5DT0RFX0NVU1RPTTpcbiAgICAgICAgY2FzZSAweDE4OiAvL2NzdC5DT0RFX0NVU1RPTV9MRU46XG4gICAgICAgIGNhc2UgMHgxOTogLy9jc3QuQ09ERV9DVVNUT01fRklYRUQ6XG4gICAgICAgICAgdmFyIGMsIHMgPSBcIlwiO1xuICAgICAgICAgIHdoaWxlICgoYyA9IHJlYWRlci5yZWFkOHUgKCkpICE9IDApIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSAoYyk7XG4gICAgICAgICAgdmFyIG9wcyA9IGNhbWxfY3VzdG9tX29wc1tzXTtcbiAgICAgICAgICB2YXIgZXhwZWN0ZWRfc2l6ZTtcbiAgICAgICAgICBpZighb3BzKVxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB1bmtub3duIGN1c3RvbSBibG9jayBpZGVudGlmaWVyXCIpO1xuICAgICAgICAgIHN3aXRjaChjb2RlKXtcbiAgICAgICAgICBjYXNlIDB4MTI6IC8vIGNzdC5DT0RFX0NVU1RPTSAoZGVwcmVjYXRlZClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHgxOTogLy8gY3N0LkNPREVfQ1VTVE9NX0ZJWEVEXG4gICAgICAgICAgICBpZighb3BzLmZpeGVkX2xlbmd0aClcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBleHBlY3RlZCBhIGZpeGVkLXNpemUgY3VzdG9tIGJsb2NrXCIpO1xuICAgICAgICAgICAgZXhwZWN0ZWRfc2l6ZSA9IG9wcy5maXhlZF9sZW5ndGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4MTg6IC8vIGNzdC5DT0RFX0NVU1RPTV9MRU5cbiAgICAgICAgICAgIGV4cGVjdGVkX3NpemUgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICAgIC8vIFNraXAgc2l6ZTY0XG4gICAgICAgICAgICByZWFkZXIucmVhZDMycygpOyByZWFkZXIucmVhZDMycygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvbGRfcG9zID0gcmVhZGVyLmk7XG4gICAgICAgICAgdmFyIHNpemUgPSBbMF07XG4gICAgICAgICAgdmFyIHYgPSBvcHMuZGVzZXJpYWxpemUocmVhZGVyLCBzaXplKTtcbiAgICAgICAgICBpZihleHBlY3RlZF9zaXplICE9IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBpZihleHBlY3RlZF9zaXplICE9IHNpemVbMF0pXG4gICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaW5jb3JyZWN0IGxlbmd0aCBvZiBzZXJpYWxpemVkIGN1c3RvbSBibG9ja1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbWVzc2FnZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgcmVzID0gaW50ZXJuX3JlYyAoKTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgc2l6ZSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGQgPSB2Lmxlbmd0aDtcbiAgICBpZiAoZCA8IHNpemUpIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgdltkXSA9IGludGVybl9yZWMgKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvZnMhPVwibnVtYmVyXCIpIG9mc1swXSA9IHJlYWRlci5pO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfZGF0YV9zaXplIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAocywgb2ZzKSB7XG4gIGZ1bmN0aW9uIGdldDMyKHMsaSkge1xuICAgIHJldHVybiAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkpIDw8IDI0KSB8XG4gICAgICAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAxKSA8PCAxNikgfFxuICAgICAgKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMikgPDwgOCkgfFxuICAgICAgY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAzKTtcbiAgfVxuICBpZiAoZ2V0MzIocywgb2ZzKSAhPSAoMHg4NDk1QTZCRXwwKSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiTWFyc2hhbC5kYXRhX3NpemU6IGJhZCBvYmplY3RcIik7XG4gIHJldHVybiAoZ2V0MzIocywgb2ZzICsgNCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBNbE9iamVjdFRhYmxlXG52YXIgTWxPYmplY3RUYWJsZTtcbmlmICh0eXBlb2YgZ2xvYmFsVGhpcy5XZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgLyogcG9seWZpbGwgKHVzaW5nIGxpbmVhciBzZWFyY2gpICovXG4gICAgZnVuY3Rpb24gTmFpdmVMb29rdXAob2JqcykgeyB0aGlzLm9ianMgPSBvYmpzOyB9XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLm9ianNbaV0gPT09IHYpIHJldHVybiBpO1xuICAgICAgfVxuICAgIH07XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRG8gbm90aGluZyBoZXJlLiBbTWxPYmplY3RUYWJsZS5zdG9yZV0gd2lsbCBwdXNoIHRvIFt0aGlzLm9ianNdIGRpcmVjdGx5LlxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBOYWl2ZUxvb2t1cCh0aGlzLm9ianMpO1xuICAgIH07XG4gIH0oKTtcbn1cbmVsc2Uge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICB0aGlzLm9ianMgPSBbXTsgdGhpcy5sb29rdXAgPSBuZXcgZ2xvYmFsVGhpcy5XZWFrTWFwKCk7XG4gIH07XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24odikge1xuICB0aGlzLmxvb2t1cC5zZXQodiwgdGhpcy5vYmpzLmxlbmd0aCk7XG4gIHRoaXMub2Jqcy5wdXNoKHYpO1xufVxuXG5NbE9iamVjdFRhYmxlLnByb3RvdHlwZS5yZWNhbGwgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBpID0gdGhpcy5sb29rdXAuZ2V0KHYpO1xuICByZXR1cm4gKGkgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZCA6IHRoaXMub2Jqcy5sZW5ndGggLSBpOyAgIC8qIGluZGV4IGlzIHJlbGF0aXZlICovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlXG4vL1ZlcnNpb246ID49IDQuMDhcbnZhciBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSA9IGZhbHNlXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlXG4vL1ZlcnNpb246IDwgNC4wOFxudmFyIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlID0gdHJ1ZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogTWxPYmplY3RUYWJsZSwgY2FtbF9saXN0X3RvX2pzX2FycmF5LCBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSwgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xudmFyIGNhbWxfb3V0cHV0X3ZhbCA9IGZ1bmN0aW9uICgpe1xuICBmdW5jdGlvbiBXcml0ZXIgKCkgeyB0aGlzLmNodW5rID0gW107IH1cbiAgV3JpdGVyLnByb3RvdHlwZSA9IHtcbiAgICBjaHVua19pZHg6MjAsIGJsb2NrX2xlbjowLCBvYmpfY291bnRlcjowLCBzaXplXzMyOjAsIHNpemVfNjQ6MCxcbiAgICB3cml0ZTpmdW5jdGlvbiAoc2l6ZSwgdmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2F0OmZ1bmN0aW9uIChwb3MsIHNpemUsIHZhbHVlKSB7XG4gICAgICB2YXIgcG9zID0gcG9zO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbcG9zKytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2NvZGU6ZnVuY3Rpb24gKHNpemUsIGNvZGUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gY29kZTtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX3NoYXJlZDpmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICBpZiAob2Zmc2V0IDwgKDEgPDwgOCkpIHRoaXMud3JpdGVfY29kZSg4LCAweDA0IC8qY3N0LkNPREVfU0hBUkVEOCovLCBvZmZzZXQpO1xuICAgICAgZWxzZSBpZiAob2Zmc2V0IDwgKDEgPDwgMTYpKSB0aGlzLndyaXRlX2NvZGUoMTYsIDB4MDUgLypjc3QuQ09ERV9TSEFSRUQxNiovLCBvZmZzZXQpO1xuICAgICAgZWxzZSB0aGlzLndyaXRlX2NvZGUoMzIsIDB4MDYgLypjc3QuQ09ERV9TSEFSRUQzMiovLCBvZmZzZXQpO1xuICAgIH0sXG4gICAgcG9zOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY2h1bmtfaWR4IH0sXG4gICAgZmluYWxpemU6ZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5ibG9ja19sZW4gPSB0aGlzLmNodW5rX2lkeCAtIDIwO1xuICAgICAgdGhpcy5jaHVua19pZHggPSAwO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIDB4ODQ5NUE2QkUpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuYmxvY2tfbGVuKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLm9ial9jb3VudGVyKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLnNpemVfMzIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV82NCk7XG4gICAgICByZXR1cm4gdGhpcy5jaHVuaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICh2LCBmbGFncykge1xuICAgIGZsYWdzID0gY2FtbF9saXN0X3RvX2pzX2FycmF5KGZsYWdzKTtcblxuICAgIHZhciBub19zaGFyaW5nID0gKGZsYWdzLmluZGV4T2YoMCAvKk1hcnNoYWwuTm9fc2hhcmluZyovKSAhPT0gLTEpLFxuICAgICAgICBjbG9zdXJlcyA9ICAoZmxhZ3MuaW5kZXhPZigxIC8qTWFyc2hhbC5DbG9zdXJlcyovKSAhPT0gLTEpO1xuICAgIC8qIE1hcnNoYWwuQ29tcGF0XzMyIGlzIHJlZHVuZGFudCBzaW5jZSBpbnRlZ2VycyBhcmUgMzItYml0IGFueXdheSAqL1xuXG4gICAgaWYgKGNsb3N1cmVzKVxuICAgICAgZ2xvYmFsVGhpcy5jb25zb2xlLndhcm4oXCJpbiBjYW1sX291dHB1dF92YWw6IGZsYWcgTWFyc2hhbC5DbG9zdXJlcyBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcblxuICAgIHZhciB3cml0ZXIgPSBuZXcgV3JpdGVyICgpO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBpbnRlcm5fb2JqX3RhYmxlID0gbm9fc2hhcmluZyA/IG51bGwgOiBuZXcgTWxPYmplY3RUYWJsZSgpO1xuXG4gICAgZnVuY3Rpb24gbWVtbyh2KSB7XG4gICAgICBpZiAobm9fc2hhcmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGV4aXN0aW5nX29mZnNldCA9IGludGVybl9vYmpfdGFibGUucmVjYWxsKHYpO1xuICAgICAgaWYgKGV4aXN0aW5nX29mZnNldCkgeyB3cml0ZXIud3JpdGVfc2hhcmVkKGV4aXN0aW5nX29mZnNldCk7IHJldHVybiB0cnVlOyB9XG4gICAgICBlbHNlIHsgaW50ZXJuX29ial90YWJsZS5zdG9yZSh2KTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZXJuX3JlYyAodikge1xuICAgICAgaWYgKHYuY2FtbF9jdXN0b20pIHtcbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIG5hbWUgPSB2LmNhbWxfY3VzdG9tO1xuICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW25hbWVdO1xuICAgICAgICB2YXIgc3pfMzJfNjQgPSBbMCwwXTtcbiAgICAgICAgaWYoIW9wcy5zZXJpYWxpemUpXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQ3VzdG9tKVwiKTtcbiAgICAgICAgaWYoY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUpIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTIgLypjc3QuQ09ERV9DVVNUT00qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICB9IGVsc2UgaWYob3BzLmZpeGVkX2xlbmd0aCA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOCAvKmNzdC5DT0RFX0NVU1RPTV9MRU4qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgaGVhZGVyX3BvcyA9IHdyaXRlci5wb3MgKCk7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3BzLnNlcmlhbGl6ZSh3cml0ZXIsIHYsIHN6XzMyXzY0KTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcywgMzIsIHN6XzMyXzY0WzBdKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcyArIDQsIDMyLCAwKTsgLy8gemVyb1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgOCwgMzIsIHN6XzMyXzY0WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTkgLypjc3QuQ09ERV9DVVNUT01fRklYRUQqLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHdyaXRlci5wb3MoKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIGlmIChvcHMuZml4ZWRfbGVuZ3RoICE9IHdyaXRlci5wb3MoKSAtIG9sZF9wb3MpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBpbmNvcnJlY3QgZml4ZWQgc2l6ZXMgc3BlY2lmaWVkIGJ5IFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMiArICgoc3pfMzJfNjRbMF0gKyAzKSA+PiAyKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMiArICgoc3pfMzJfNjRbMV0gKyA3KSA+PiAzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2WzBdID09PSAodlswXXwwKSkge1xuICAgICAgICBpZiAodlswXSA9PSAyNTEpIHtcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQWJzdHJhY3QpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2Lmxlbmd0aCA+IDEgJiYgbWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICBpZiAodlswXSA8IDE2ICYmIHYubGVuZ3RoIC0gMSA8IDgpXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDgwIC8qY3N0LlBSRUZJWF9TTUFMTF9CTE9DSyovICsgdlswXSArICgodi5sZW5ndGggLSAxKTw8NCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDggLypjc3QuQ09ERV9CTE9DSzMyKi8sICgodi5sZW5ndGgtMSkgPDwgMTApIHwgdlswXSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IHYubGVuZ3RoO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSB2Lmxlbmd0aDtcbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSkgc3RhY2sucHVzaCAodiwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXModikpIHtcbiAgICAgICAgaWYoIShjYW1sX2lzX21sX2J5dGVzKGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIikpKSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IFtCeXRlcy50XSBjYW5ub3Qgc2FmZWx5IGJlIG1hcnNoYWxlZCB3aXRoIFstLWVuYWJsZSB1c2UtanMtc3RyaW5nXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9ieXRlc19sZW5ndGgodik7XG4gICAgICAgIGlmIChsZW4gPCAweDIwKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgyMCAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HKi8gKyBsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPCAweDEwMClcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoOCwgMHgwOS8qY3N0LkNPREVfU1RSSU5HOCovLCBsZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDMyLCAweDBBIC8qY3N0LkNPREVfU1RSSU5HMzIqLywgbGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IGxlbjtpKyspXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcodikpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICE9ICh2fDApKXtcbiAgICAgICAgICB2YXIgdHlwZV9vZl92ID0gdHlwZW9mIHY7XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBJZiBhIGZsb2F0IGhhcHBlbnMgdG8gYmUgYW4gaW50ZWdlciBpdCBpcyBzZXJpYWxpemVkIGFzIGFuIGludGVnZXJcbiAgICAgICAgICAvLyAoSnNfb2Zfb2NhbWwgY2Fubm90IHRlbGwgd2hldGhlciB0aGUgdHlwZSBvZiBhbiBpbnRlZ2VyIG51bWJlciBpc1xuICAgICAgICAgIC8vIGZsb2F0IG9yIGludGVnZXIuKSBUaGlzIGNhbiByZXN1bHQgaW4gdW5leHBlY3RlZCBjcmFzaGVzIHdoZW5cbiAgICAgICAgICAvLyB1bm1hcnNoYWxsaW5nIHVzaW5nIHRoZSBzdGFuZGFyZCBydW50aW1lLiBJdCBzZWVtcyBiZXR0ZXIgdG9cbiAgICAgICAgICAvLyBzeXN0ZW1hdGljYWxseSBmYWlsIG9uIG1hcnNoYWxsaW5nLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICAgICAgICAgaWYodHlwZV9vZl92ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKFwiK3R5cGVfb2ZfditcIilcIik7XG4gICAgICAgICAgLy8gICAgICAgICAgdmFyIHQgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh2KSk7XG4gICAgICAgICAgLy8gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDBCIC8qY3N0LkNPREVfRE9VQkxFX0JJRyovKTtcbiAgICAgICAgICAvLyAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpPDg7IGkrKyl7d3JpdGVyLndyaXRlKDgsdFtpXSl9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiA+PSAwICYmIHYgPCAweDQwKSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAwWDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLyArIHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2ID49IC0oMSA8PCA3KSAmJiB2IDwgKDEgPDwgNykpXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSg4LCAweDAwIC8qY3N0LkNPREVfSU5UOCovLCB2KTtcbiAgICAgICAgICBlbHNlIGlmICh2ID49IC0oMSA8PCAxNSkgJiYgdiA8ICgxIDw8IDE1KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDE2LCAweDAxIC8qY3N0LkNPREVfSU5UMTYqLywgdik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDIgLypjc3QuQ09ERV9JTlQzMiovLCB2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBleHRlcm5fcmVjICh2KTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGkgPSBzdGFjay5wb3AgKCk7XG4gICAgICB2YXIgdiA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIGlmIChpICsgMSA8IHYubGVuZ3RoKSBzdGFjay5wdXNoICh2LCBpICsgMSk7XG4gICAgICBleHRlcm5fcmVjICh2W2ldKTtcbiAgICB9XG4gICAgaWYgKGludGVybl9vYmpfdGFibGUpIHdyaXRlci5vYmpfY291bnRlciA9IGludGVybl9vYmpfdGFibGUub2Jqcy5sZW5ndGg7XG4gICAgd3JpdGVyLmZpbmFsaXplKCk7XG4gICAgcmV0dXJuIHdyaXRlci5jaHVuaztcbiAgfVxufSAoKTtcblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9ieXRlc19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgKHYsIGZsYWdzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX2JsaXRfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciAocywgb2ZzLCBsZW4sIHYsIGZsYWdzKSB7XG4gIHZhciB0ID0gY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncyk7XG4gIGlmICh0Lmxlbmd0aCA+IGxlbikgY2FtbF9mYWlsd2l0aCAoXCJNYXJzaGFsLnRvX2J1ZmZlcjogYnVmZmVyIG92ZXJmbG93XCIpO1xuICBjYW1sX2JsaXRfYnl0ZXModCwgMCwgcywgb2ZzLCB0Lmxlbmd0aCk7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBJb1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jbG9zZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9zeXNfY2xvc2UoZmQpIHtcbiAgZGVsZXRlIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RkX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX3N0ZF9vdXRwdXQoY2hhbmlkLHMpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIHN0ciA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocyk7XG4gIHZhciBzbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cik7XG4gIGNoYW4uZmlsZS53cml0ZShjaGFuLm9mZnNldCwgc3RyLCAwLCBzbGVuKTtcbiAgY2hhbi5vZmZzZXQgKz0gc2xlbjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX2dsb2JhbF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcyxNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnIsIGpzX3ByaW50X3N0ZG91dFxuLy9SZXF1aXJlczogY2FtbF9zdGRfb3V0cHV0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChpZHgsb3V0cHV0LGZpbGUsZmxhZ3MpIHtcbiAgaWYoY2FtbF9nbG9iYWxfZGF0YS5mZHMgPT09IHVuZGVmaW5lZCkgY2FtbF9nbG9iYWxfZGF0YS5mZHMgPSBuZXcgQXJyYXkoKTtcbiAgZmxhZ3M9ZmxhZ3M/ZmxhZ3M6e307XG4gIHZhciBpbmZvID0ge307XG4gIGluZm8uZmlsZSA9IGZpbGU7XG4gIGluZm8ub2Zmc2V0ID0gZmxhZ3MuYXBwZW5kP2ZpbGUubGVuZ3RoKCk6MDtcbiAgaW5mby5mbGFncyA9IGZsYWdzO1xuICBpbmZvLm91dHB1dCA9IG91dHB1dDtcbiAgY2FtbF9nbG9iYWxfZGF0YS5mZHNbaWR4XSA9IGluZm87XG4gIGlmKCFjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4IHx8IGlkeCA+IGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHgpXG4gICAgY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeCA9IGlkeDtcbiAgcmV0dXJuIGlkeDtcbn1cbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW4gKG5hbWUsIGZsYWdzLCBfcGVybXMpIHtcbiAgdmFyIGYgPSB7fTtcbiAgd2hpbGUoZmxhZ3Mpe1xuICAgIHN3aXRjaChmbGFnc1sxXSl7XG4gICAgY2FzZSAwOiBmLnJkb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAxOiBmLndyb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAyOiBmLmFwcGVuZCA9IDE7YnJlYWs7XG4gICAgY2FzZSAzOiBmLmNyZWF0ZSA9IDE7YnJlYWs7XG4gICAgY2FzZSA0OiBmLnRydW5jYXRlID0gMTticmVhaztcbiAgICBjYXNlIDU6IGYuZXhjbCA9IDE7IGJyZWFrO1xuICAgIGNhc2UgNjogZi5iaW5hcnkgPSAxO2JyZWFrO1xuICAgIGNhc2UgNzogZi50ZXh0ID0gMTticmVhaztcbiAgICBjYXNlIDg6IGYubm9uYmxvY2sgPSAxO2JyZWFrO1xuICAgIH1cbiAgICBmbGFncz1mbGFnc1syXTtcbiAgfVxuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3QsZik7XG4gIHZhciBpZHggPSBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4P2NhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHg6MDtcbiAgcmV0dXJuIGNhbWxfc3lzX29wZW5faW50ZXJuYWwgKGlkeCsxLGNhbWxfc3RkX291dHB1dCxmaWxlLGYpO1xufVxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgwLGNhbWxfc3RkX291dHB1dCwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRpblxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgxLGpzX3ByaW50X3N0ZG91dCwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRvdXRcbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMixqc19wcmludF9zdGRlcnIsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3RkZXJyXG5cblxuLy8gb2NhbWwgQ2hhbm5lbHNcblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX25hbWUoKSB7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbHNcbnZhciBjYW1sX21sX2NoYW5uZWxzID0gbmV3IEFycmF5KCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3QgKCkge1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgYyA9IDA7IGMgPCBjYW1sX21sX2NoYW5uZWxzLmxlbmd0aDsgYysrKXtcbiAgICBpZihjYW1sX21sX2NoYW5uZWxzW2NdICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3BlbmVkICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3V0KVxuICAgICAgbD1bMCxjYW1sX21sX2NoYW5uZWxzW2NdLmZkLGxdO1xuICB9XG4gIHJldHVybiBsO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCAoZmQpIHtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIGlmKGRhdGEuZmxhZ3MucmRvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHJlYWRvbmx5XCIpO1xuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmRhdGEuZmlsZSxcbiAgICBvZmZzZXQ6ZGF0YS5vZmZzZXQsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OnRydWUsXG4gICAgYnVmZmVyOlwiXCJcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9zeXNfb3BlbixjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogZnNfbm9kZV9zdXBwb3J0ZWQsIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiAoZmQpICB7XG4gIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICBpZihkYXRhLmZsYWdzLndyb25seSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJmZCBcIisgZmQgKyBcIiBpcyB3cml0ZW9ubHlcIik7XG4gIHZhciByZWZpbGwgPSBudWxsO1xuICBpZihmZCA9PSAwICYmIGZzX25vZGVfc3VwcG9ydGVkKCkpe1xuICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgcmVmaWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGZzLnJlYWRGaWxlU3luYygwLCAndXRmOCcpKX07XG4gIH1cbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTpkYXRhLmZpbGUsXG4gICAgb2Zmc2V0OmRhdGEub2Zmc2V0LFxuICAgIGZkOmZkLFxuICAgIG9wZW5lZDp0cnVlLFxuICAgIG91dDogZmFsc2UsXG4gICAgcmVmaWxsOnJlZmlsbFxuICB9O1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5uZWwuZmRdPWNoYW5uZWw7XG4gIHJldHVybiBjaGFubmVsLmZkO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvcihjaGFuaWQpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNoYW4uZmQ7XG59XG5cbi8vUHJvdmlkZXM6IHdpbl9maWxlZGVzY3Jfb2ZfY2hhbm5lbFxuLy9SZXF1aXJlczogY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3JcbnZhciB3aW5fZmlsZWRlc2NyX29mX2NoYW5uZWwgPSBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvclxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUoY2hhbmlkLG1vZGUpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXTtcbiAgZGF0YS5mbGFncy50ZXh0ID0gIW1vZGVcbiAgZGF0YS5mbGFncy5iaW5hcnkgPSBtb2RlXG4gIHJldHVybiAwO1xufVxuXG4vL0lucHV0IGZyb20gaW5fY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2Nsb3NlX2NoYW5uZWxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsIGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2Nsb3NlXG5mdW5jdGlvbiBjYW1sX21sX2Nsb3NlX2NoYW5uZWwgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICBjaGFuLm9wZW5lZCA9IGZhbHNlO1xuICBjaGFuLmZpbGUuY2xvc2UoKTtcbiAgY2FtbF9zeXNfY2xvc2UoY2hhbi5mZClcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZShjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjaGFuLmZpbGUubGVuZ3RoKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0KGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2hhbi5maWxlLmxlbmd0aCAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dChjaGFuaWQsZikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0ID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbChjaGFuaWQsZikge1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ucmVmaWxsID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfbWxfcmVmaWxsX2lucHV0IChjaGFuKSB7XG4gIHZhciBzdHIgPSBjaGFuLnJlZmlsbCgpO1xuICB2YXIgc3RyX2xlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIpO1xuICBpZiAoc3RyX2xlbiA9PSAwKSBjaGFuLnJlZmlsbCA9IG51bGw7XG4gIGNoYW4uZmlsZS53cml0ZShjaGFuLmZpbGUubGVuZ3RoKCksIHN0ciwgMCwgc3RyX2xlbik7XG4gIHJldHVybiBzdHJfbGVuO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsID09IG51bGwpIHJldHVybjtcbiAgaWYgKGNoYW4uZmlsZS5sZW5ndGgoKSAhPSBjaGFuLm9mZnNldCkgcmV0dXJuO1xuICBjYW1sX21sX3JlZmlsbF9pbnB1dCAoY2hhbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0IChjaGFuaWQsIHMsIGksIGwpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBsMiA9IGNoYW4uZmlsZS5sZW5ndGgoKSAtIGNoYW4ub2Zmc2V0O1xuICBpZiAobDIgPT0gMCAmJiBjaGFuLnJlZmlsbCAhPSBudWxsKSBsMiA9IGNhbWxfbWxfcmVmaWxsX2lucHV0KGNoYW4pO1xuICBpZiAobDIgPCBsKSBsID0gbDI7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LCBzLCBpLCBsKTtcbiAgY2hhbi5vZmZzZXQgKz0gbDtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcywgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWUgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcblxuICB2YXIgYnVmID0gY2FtbF9jcmVhdGVfYnl0ZXMoOCk7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLDgpO1xuXG4gIC8vIEhlYWRlciBpcyAyMCBieXRlc1xuICB2YXIgbGVuID0gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAoYnVmLCAwKSArIDIwO1xuXG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCxsZW4pO1xuXG4gIHZhciBvZmZzZXQgPSBbMF07XG4gIHZhciByZXMgPSBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMoYnVmLCBvZmZzZXQpO1xuICBjaGFuLm9mZnNldCA9IGNoYW4ub2Zmc2V0ICsgb2Zmc2V0WzBdO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9jaGFyIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dChjaGFuaWQpO1xuICBpZiAoY2hhbi5vZmZzZXQgPj0gY2hhbi5maWxlLmxlbmd0aCgpKVxuICAgIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgdmFyIHJlcyA9IGNoYW4uZmlsZS5yZWFkX29uZShjaGFuLm9mZnNldCk7XG4gIGNoYW4ub2Zmc2V0Kys7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9pbnQgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGZpbGUgPSBjaGFuLmZpbGU7XG4gIHdoaWxlICgoY2hhbi5vZmZzZXQgKyAzKSA+PSBmaWxlLmxlbmd0aCgpKSB7XG4gICAgdmFyIGwgPSBjYW1sX21sX3JlZmlsbF9pbnB1dChjaGFuKTtcbiAgICBpZiAobCA9PSAwKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIH1cbiAgdmFyIG8gPSBjaGFuLm9mZnNldDtcbiAgdmFyIHIgPShmaWxlLnJlYWRfb25lKG8gICkgPDwgMjQpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzEpIDw8IDE2KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobysyKSA8PCA4KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobyszKSk7XG4gIGNoYW4ub2Zmc2V0Kz00O1xuICByZXR1cm4gcjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX2luKGNoYW5pZCxwb3Mpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsICE9IG51bGwpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiSWxsZWdhbCBzZWVrXCIpO1xuICBjaGFuLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbl82NChjaGFuaWQscG9zKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCAhPSBudWxsKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIklsbGVnYWwgc2Vla1wiKTtcbiAgY2hhbi5vZmZzZXQgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pblxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW4oY2hhbmlkKSB7cmV0dXJuIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXR9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbl82NChjaGFuaWQpIHtyZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0KX1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmVcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUoY2hhbmlkKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dChjaGFuaWQpO1xuICB2YXIgcCA9IGNoYW4ub2Zmc2V0O1xuICB2YXIgbGVuID0gY2hhbi5maWxlLmxlbmd0aCgpO1xuICBpZihwID49IGxlbikgeyByZXR1cm4gMDt9XG4gIHdoaWxlKHRydWUpIHtcbiAgICBpZihwID49IGxlbikgcmV0dXJuIC0gKHAgLSBjaGFuLm9mZnNldCk7XG4gICAgaWYoY2hhbi5maWxlLnJlYWRfb25lKHApID09IDEwKSByZXR1cm4gcCAtIGNoYW4ub2Zmc2V0ICsgMTtcbiAgICBwKys7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9mbHVzaFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3QgZmx1c2ggYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgaWYoIWNoYW4uYnVmZmVyIHx8IGNoYW4uYnVmZmVyID09IFwiXCIpIHJldHVybiAwO1xuICBpZihjaGFuLmZkXG4gICAgICYmIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdXG4gICAgICYmIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dCkge1xuICAgIHZhciBvdXRwdXQgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQ7XG4gICAgc3dpdGNoKG91dHB1dC5sZW5ndGgpe1xuICAgIGNhc2UgMjogb3V0cHV0KGNoYW5pZCxjaGFuLmJ1ZmZlcik7YnJlYWs7XG4gICAgZGVmYXVsdDogb3V0cHV0KGNoYW4uYnVmZmVyKVxuICAgIH07XG4gIH1cbiAgY2hhbi5idWZmZXIgPSBcIlwiO1xuICByZXR1cm4gMDtcbn1cblxuLy9vdXRwdXQgdG8gb3V0X2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBvdXRwdXQgdG8gYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgdmFyIGJ5dGVzO1xuICBpZihvZmZzZXQgPT0gMCAmJiBjYW1sX21sX2J5dGVzX2xlbmd0aChidWZmZXIpID09IGxlbilcbiAgICBieXRlcyA9IGJ1ZmZlcjtcbiAgZWxzZSB7XG4gICAgYnl0ZXMgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhidWZmZXIsb2Zmc2V0LGJ5dGVzLDAsbGVuKTtcbiAgfVxuICB2YXIgc3RyaW5nID0gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMoYnl0ZXMpO1xuICB2YXIganNzdHJpbmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHN0cmluZyk7XG4gIHZhciBpZCA9IGpzc3RyaW5nLmxhc3RJbmRleE9mKFwiXFxuXCIpO1xuICBpZihpZCA8IDApXG4gICAgY2hhbi5idWZmZXIrPWpzc3RyaW5nO1xuICBlbHNlIHtcbiAgICBjaGFuLmJ1ZmZlcis9anNzdHJpbmcuc3Vic3RyKDAsaWQrMSk7XG4gICAgY2FtbF9tbF9mbHVzaCAoY2hhbmlkKTtcbiAgICBjaGFuLmJ1ZmZlciArPSBqc3N0cmluZy5zdWJzdHIoaWQrMSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dF9ieXRlcywgY2FtbF9ieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbil7XG4gIHJldHVybiBjYW1sX21sX291dHB1dF9ieXRlcyhjaGFuaWQsY2FtbF9ieXRlc19vZl9zdHJpbmcoYnVmZmVyKSxvZmZzZXQsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfY2hhclxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2NoYXIgKGNoYW5pZCxjKSB7XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCwxKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcsIGNhbWxfbWxfb3V0cHV0LGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWUgKGNoYW5pZCx2LGZsYWdzKSB7XG4gIHZhciBzID0gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nKHYsIGZsYWdzKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCxjYW1sX21sX3N0cmluZ19sZW5ndGgocykpO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0KGNoYW5pZCxwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQgPSBwb3M7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0XzY0KGNoYW5pZCxwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dChjaGFuaWQpIHtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dF82NChjaGFuaWQpIHtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9pbnQgKGNoYW5pZCxpKSB7XG4gIHZhciBhcnIgPSBbKGk+PjI0KSAmIDB4RkYsKGk+PjE2KSAmIDB4RkYsKGk+PjgpICYgMHhGRixpICYgMHhGRiBdO1xuICB2YXIgcyA9IGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsNCk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaXNfYnVmZmVyZWRcbmZ1bmN0aW9uIGNhbWxfbWxfaXNfYnVmZmVyZWQoYykgeyByZXR1cm4gMSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2J1ZmZlcmVkXG5mdW5jdGlvbiBjYW1sX21sX3NldF9idWZmZXJlZChjLHYpIHsgcmV0dXJuIDAgfVxuIiwiXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWlub3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWlub3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX21ham9yXG5mdW5jdGlvbiBjYW1sX2djX21ham9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19mdWxsX21ham9yXG5mdW5jdGlvbiBjYW1sX2djX2Z1bGxfbWFqb3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvbXBhY3Rpb25cbmZ1bmN0aW9uIGNhbWxfZ2NfY29tcGFjdGlvbigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfY291bnRlcnNcbmZ1bmN0aW9uIGNhbWxfZ2NfY291bnRlcnMoKSB7IHJldHVybiBbMjU0LDAsMCwwXSB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3F1aWNrX3N0YXRcbmZ1bmN0aW9uIGNhbWxfZ2NfcXVpY2tfc3RhdCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19zdGF0KCkge1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19zZXRcbmZ1bmN0aW9uIGNhbWxfZ2Nfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX2dldFxuZnVuY3Rpb24gY2FtbF9nY19nZXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMF1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3NldFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3NldChfY29udHJvbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3RlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3RlciAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVsZWFzZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWxlYXNlICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3N0YXJ0XG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc3RhcnQocmF0ZSxzdGFja19zaXplLHRyYWNrZXIpe1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3N0b3BcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zdG9wKHVuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXZlbnRsb2dfcmVzdW1lXG5mdW5jdGlvbiBjYW1sX2V2ZW50bG9nX3Jlc3VtZSh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXZlbnRsb2dfcGF1c2VcbmZ1bmN0aW9uIGNhbWxfZXZlbnRsb2dfcGF1c2UodW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnRcbmZ1bmN0aW9uIGNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudCh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWFqb3Jfc2xpY2VcbmZ1bmN0aW9uIGNhbWxfZ2NfbWFqb3Jfc2xpY2Uod29yaykgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX21pbm9yX3dvcmRzXG5mdW5jdGlvbiBjYW1sX2djX21pbm9yX3dvcmRzKHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfbWlub3JfZnJlZVxuZnVuY3Rpb24gY2FtbF9nZXRfbWlub3JfZnJlZSh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X21ham9yX2J1Y2tldFxuZnVuY3Rpb24gY2FtbF9nZXRfbWFqb3JfYnVja2V0KG4pIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfbWFqb3JfY3JlZGl0XG5mdW5jdGlvbiBjYW1sX2dldF9tYWpvcl9jcmVkaXQobikgeyByZXR1cm4gMDsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmQsIEFuZHkgUmF5XG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4vL1xuLy8gQmlnYXJyYXkuXG4vL1xuLy8gLSBhbGwgYmlnYXJyYXkgdHlwZXMgaW5jbHVkaW5nIEludDY0IGFuZCBDb21wbGV4LlxuLy8gLSBmb3J0cmFuICsgYyBsYXlvdXRzXG4vLyAtIHN1Yi9zbGljZS9yZXNoYXBlXG4vLyAtIHJldGFpbiBmYXN0IHBhdGggZm9yIDFkIGFycmF5IGFjY2Vzc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2luaXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFfaW5pdCgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSB7XG4gIHZhciBuX2RpbXMgPSBkaW1zLmxlbmd0aDtcbiAgdmFyIHNpemUgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5fZGltczsgaSsrKSB7XG4gICAgaWYgKGRpbXNbaV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgc2l6ZSA9IHNpemUgKiBkaW1zW2ldO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpe1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgNzogY2FzZSAxMDogY2FzZSAxMTogcmV0dXJuIDI7XG4gIGRlZmF1bHQ6IHJldHVybiAxO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSl7XG4gIHZhciBnID0gZ2xvYmFsVGhpcztcbiAgdmFyIHZpZXc7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSAwOiAgdmlldyA9IGcuRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxOiAgdmlldyA9IGcuRmxvYXQ2NEFycmF5OyBicmVhaztcbiAgY2FzZSAyOiAgdmlldyA9IGcuSW50OEFycmF5OyBicmVhaztcbiAgY2FzZSAzOiAgdmlldyA9IGcuVWludDhBcnJheTsgYnJlYWs7XG4gIGNhc2UgNDogIHZpZXcgPSBnLkludDE2QXJyYXk7IGJyZWFrO1xuICBjYXNlIDU6ICB2aWV3ID0gZy5VaW50MTZBcnJheTsgYnJlYWs7XG4gIGNhc2UgNjogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDc6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA4OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgOTogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDEwOiB2aWV3ID0gZy5GbG9hdDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDExOiB2aWV3ID0gZy5GbG9hdDY0QXJyYXk7IGJyZWFrO1xuICBjYXNlIDEyOiB2aWV3ID0gZy5VaW50OEFycmF5OyBicmVhaztcbiAgfVxuICBpZiAoIXZpZXcpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmNyZWF0ZTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgdmFyIGRhdGEgPSBuZXcgdmlldyhzaXplICogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1ZlcnNpb246IDwgNC4xMVxudmFyIGNhbWxfYmFfY3VzdG9tX25hbWUgPSBcIl9iaWdhcnJheVwiXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vVmVyc2lvbjogPj0gNC4xMVxudmFyIGNhbWxfYmFfY3VzdG9tX25hbWUgPSBcIl9iaWdhcnIwMlwiXG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpLCBjYW1sX2ludDY0X2hpMzIsIGNhbWxfaW50NjRfbG8zMlxuZnVuY3Rpb24gTWxfQmlnYXJyYXkgKGtpbmQsIGxheW91dCwgZGltcywgYnVmZmVyKSB7XG5cbiAgdGhpcy5raW5kICAgPSBraW5kIDtcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuZGltcyAgID0gZGltcztcbiAgdGhpcy5kYXRhID0gYnVmZmVyO1xufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBjYW1sX2JhX2N1c3RvbV9uYW1lO1xuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKGFyZykge1xuICB2YXIgb2ZzID0gMDtcbiAgaWYodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIikgYXJnID0gW2FyZ107XG4gIGlmICghIChhcmcgaW5zdGFuY2VvZiBBcnJheSkpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImJpZ2FycmF5LmpzOiBpbnZhbGlkIG9mZnNldFwiKTtcbiAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT0gYXJnLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5nZXQvc2V0OiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gIGlmKHRoaXMubGF5b3V0ID09IDAgLyogY19sYXlvdXQgKi8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFyZ1tpXSA8IDAgfHwgYXJnW2ldID49IHRoaXMuZGltc1tpXSlcbiAgICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgb2ZzID0gKG9mcyAqIHRoaXMuZGltc1tpXSkgKyBhcmdbaV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmRpbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChhcmdbaV0gPCAxIHx8IGFyZ1tpXSA+IHRoaXMuZGltc1tpXSl7XG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIG9mcyA9IChvZnMgKiB0aGlzLmRpbXNbaV0pICsgKGFyZ1tpXSAtIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2ZzO1xufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mcykge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdmFyIGwgPSB0aGlzLmRhdGFbb2ZzICogMiArIDBdO1xuICAgIHZhciBoID0gdGhpcy5kYXRhW29mcyAqIDIgKyAxXTtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobCxoKTtcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHZhciByID0gdGhpcy5kYXRhW29mcyAqIDIgKyAwXTtcbiAgICB2YXIgaSA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgcmV0dXJuIFsyNTQsIHIsIGldO1xuICBkZWZhdWx0OlxuICAgIHJldHVybiB0aGlzLmRhdGFbb2ZzXVxuICB9XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2ZzLHYpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSBjYW1sX2ludDY0X2xvMzIodik7XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAxXSA9IGNhbWxfaW50NjRfaGkzMih2KTtcbiAgICBicmVhaztcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSB2WzFdO1xuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMV0gPSB2WzJdO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMFxufVxuXG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHZhciBhID0gY2FtbF9pbnQ2NF9sbzMyKHYpO1xuICAgIHZhciBiID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgIGlmKGEgPT0gYil7XG4gICAgICB0aGlzLmRhdGEuZmlsbChhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpPHRoaXMuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IChpJTIgPT0gMCkgPyBhIDogYjtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB2YXIgaW0gPSB2WzFdO1xuICAgIHZhciByZSA9IHZbMl07XG4gICAgaWYoaW0gPT0gcmUpe1xuICAgICAgdGhpcy5kYXRhLmZpbGwoaW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGk8dGhpcy5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gKGklMiA9PSAwKSA/IGltIDogcmU7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRoaXMuZGF0YS5maWxsKHYpO1xuICAgIGJyZWFrO1xuICB9XG59XG5cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYiwgdG90YWwpIHtcbiAgaWYgKHRoaXMubGF5b3V0ICE9IGIubGF5b3V0IHx8IHRoaXMua2luZCAhPSBiLmtpbmQpIHtcbiAgICB2YXIgazEgPSB0aGlzLmtpbmQgfCAodGhpcy5sYXlvdXQgPDwgOCk7XG4gICAgdmFyIGsyID0gICAgYi5raW5kIHwgKGIubGF5b3V0IDw8IDgpO1xuICAgIHJldHVybiBrMiAtIGsxO1xuICB9XG4gIGlmICh0aGlzLmRpbXMubGVuZ3RoICE9IGIuZGltcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYi5kaW1zLmxlbmd0aCAtIHRoaXMuZGltcy5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKHRoaXMuZGltc1tpXSAhPSBiLmRpbXNbaV0pXG4gICAgICByZXR1cm4gKHRoaXMuZGltc1tpXSA8IGIuZGltc1tpXSkgPyAtMSA6IDE7XG4gIHN3aXRjaCAodGhpcy5raW5kKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICBjYXNlIDEwOlxuICBjYXNlIDExOlxuICAgIC8vIEZsb2F0c1xuICAgIHZhciB4LCB5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB4ID0gdGhpcy5kYXRhW2ldO1xuICAgICAgeSA9IGIuZGF0YVtpXTtcbiAgICAgIGlmICh4IDwgeSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHggPiB5KVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICh4ICE9IHkpIHtcbiAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgaWYgKHggPT0geCkgcmV0dXJuIDE7XG4gICAgICAgIGlmICh5ID09IHkpIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSs9Mikge1xuICAgICAgLy8gQ2hlY2sgaGlnaGVzdCBiaXRzIGZpcnN0XG4gICAgICBpZiAodGhpcy5kYXRhW2krMV0gPCBiLmRhdGFbaSsxXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMuZGF0YVtpKzFdID4gYi5kYXRhW2krMV0pXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKCh0aGlzLmRhdGFbaV0gPj4+IDApIDwgKGIuZGF0YVtpXSA+Pj4gMCkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICgodGhpcy5kYXRhW2ldID4+PiAwKSA+IChiLmRhdGFbaV0gPj4+IDApKVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMjpcbiAgY2FzZSAzOlxuICBjYXNlIDQ6XG4gIGNhc2UgNTpcbiAgY2FzZSA2OlxuICBjYXNlIDg6XG4gIGNhc2UgOTpcbiAgY2FzZSAxMjpcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuZGF0YVtpXSA8IGIuZGF0YVtpXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMuZGF0YVtpXSA+IGIuZGF0YVtpXSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBNbF9CaWdhcnJheV9jXzFfMVxuLy9SZXF1aXJlczogTWxfQmlnYXJyYXksIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gTWxfQmlnYXJyYXlfY18xXzEoa2luZCwgbGF5b3V0LCBkaW1zLCBidWZmZXIpIHtcbiAgdGhpcy5raW5kICAgPSBraW5kIDtcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuZGltcyAgID0gZGltcztcbiAgdGhpcy5kYXRhICAgPSBidWZmZXI7XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZSA9IG5ldyBNbF9CaWdhcnJheSgpXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKGFyZykge1xuICBpZih0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKXtcbiAgICBpZigoYXJnIGluc3RhbmNlb2YgQXJyYXkpICYmIGFyZy5sZW5ndGggPT0gMSlcbiAgICAgIGFyZyA9IGFyZ1swXTtcbiAgICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIk1sX0JpZ2FycmF5X2NfMV8xLm9mZnNldFwiKTtcbiAgfVxuICBpZiAoYXJnIDwgMCB8fCBhcmcgPj0gdGhpcy5kaW1zWzBdKVxuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFyZztcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YVtvZnNdO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9mcyx2KSB7XG4gIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgcmV0dXJuIDBcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodikge1xuICB0aGlzLmRhdGEuZmlsbCh2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jb21wYXJlXG5mdW5jdGlvbiBjYW1sX2JhX2NvbXBhcmUoYSxiLHRvdGFsKXtcbiAgcmV0dXJuIGEuY29tcGFyZShiLHRvdGFsKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbi8vUmVxdWlyZXM6IE1sX0JpZ2FycmF5LCBNbF9CaWdhcnJheV9jXzFfMSwgY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKXtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpO1xuICBpZihjYW1sX2JhX2dldF9zaXplKGRpbXMpICogc2l6ZV9wZXJfZWxlbWVudCAhPSBkYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImxlbmd0aCBkb2Vzbid0IG1hdGNoIGRpbXNcIik7XG4gIH1cbiAgaWYobGF5b3V0ID09IDAgJiYgLy8gY19sYXlvdXRcbiAgICAgZGltcy5sZW5ndGggPT0gMSAmJiAvLyBBcnJheTFcbiAgICAgc2l6ZV9wZXJfZWxlbWVudCA9PSAxKSAvLyAxLXRvLTEgbWFwcGluZ1xuICAgIHJldHVybiBuZXcgTWxfQmlnYXJyYXlfY18xXzEoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbiAgcmV0dXJuIG5ldyBNbF9CaWdhcnJheShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuXG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlKGtpbmQsIGxheW91dCwgZGltc19tbCkge1xuICB2YXIgZGltcyA9IGNhbWxfanNfZnJvbV9hcnJheShkaW1zX21sKTtcbiAgdmFyIGRhdGEgPSBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGNhbWxfYmFfY2hhbmdlX2xheW91dChiYSwgbGF5b3V0KSB7XG4gIGlmKGJhLmxheW91dCA9PSBsYXlvdXQpIHJldHVybiBiYTtcbiAgdmFyIG5ld19kaW1zID0gW11cbiAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIG5ld19kaW1zW2ldID0gYmEuZGltc1tiYS5kaW1zLmxlbmd0aCAtIGkgLSAxXTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBsYXlvdXQsIG5ld19kaW1zLCBiYS5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9raW5kXG5mdW5jdGlvbiBjYW1sX2JhX2tpbmQoYmEpIHtcbiAgcmV0dXJuIGJhLmtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbGF5b3V0XG5mdW5jdGlvbiBjYW1sX2JhX2xheW91dChiYSkge1xuICByZXR1cm4gYmEubGF5b3V0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX251bV9kaW1zXG5mdW5jdGlvbiBjYW1sX2JhX251bV9kaW1zKGJhKSB7XG4gIHJldHVybiBiYS5kaW1zLmxlbmd0aDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1cbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9kaW0oYmEsIGkpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gYmEuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZGltXCIpO1xuICByZXR1cm4gYmEuZGltc1tpXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMVxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzEoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMlxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzIoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fM1xuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzMoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfZ2VuZXJpY1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9nZW5lcmljKGJhLCBpKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoY2FtbF9qc19mcm9tX2FycmF5KGkpKTtcbiAgcmV0dXJuIGJhLmdldChvZnMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDE2KGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcyArIDEpO1xuICByZXR1cm4gKGIxIHwgKGIyIDw8IDgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQzMihiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyswKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcysxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcysyKTtcbiAgdmFyIGI0ID0gYmEuZ2V0KG9mcyszKTtcbiAgcmV0dXJuICggKGIxIDw8IDApICB8XG4gICAgICAgICAgIChiMiA8PCA4KSAgfFxuICAgICAgICAgICAoYjMgPDwgMTYpIHxcbiAgICAgICAgICAgKGI0IDw8IDI0KSApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDY0KGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgNyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKzApO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzKzEpO1xuICB2YXIgYjMgPSBiYS5nZXQob2ZzKzIpO1xuICB2YXIgYjQgPSBiYS5nZXQob2ZzKzMpO1xuICB2YXIgYjUgPSBiYS5nZXQob2ZzKzQpO1xuICB2YXIgYjYgPSBiYS5nZXQob2ZzKzUpO1xuICB2YXIgYjcgPSBiYS5nZXQob2ZzKzYpO1xuICB2YXIgYjggPSBiYS5nZXQob2ZzKzcpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbYjgsYjcsYjYsYjUsYjQsYjMsYjIsYjFdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMShiYSwgaTApIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoaTApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMihiYSwgaTAsIGkxKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KFtpMCxpMV0pKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMyhiYSwgaTAsIGkxLCBpMikge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsaTEsaTJdKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfZ2VuZXJpYyhiYSwgaSwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KGNhbWxfanNfZnJvbV9hcnJheShpKSksIHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDE2KGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBiYS5zZXQob2ZzKzAsICB2ICAgICAgICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzEsICh2ID4+PiA4KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQzMihiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyswLCAgdiAgICAgICAgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMSwgKHYgPj4+IDgpICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzIsICh2ID4+PiAxNikgJiAweGZmKTtcbiAgYmEuc2V0KG9mcyszLCAodiA+Pj4gMjQpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDY0KGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgNyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgdiA9IGNhbWxfaW50NjRfdG9fYnl0ZXModik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA4OyBpKyspIGJhLnNldChvZnMraSwgdls3LWldKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMShiYSwgaTAsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChpMCksIHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8yXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8yKGJhLCBpMCwgaTEsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChbaTAsaTFdKSwgdik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8zXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8zKGJhLCBpMCwgaTEsIGkyLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoW2kwLGkxLGkyXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9maWxsXG5mdW5jdGlvbiBjYW1sX2JhX2ZpbGwoYmEsIHYpIHtcbiAgYmEuZmlsbCh2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2JsaXQoc3JjLCBkc3QpIHtcbiAgaWYgKGRzdC5kaW1zLmxlbmd0aCAhPSBzcmMuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRzdC5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIGlmIChkc3QuZGltc1tpXSAhPSBzcmMuZGltc1tpXSlcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZHN0LmRhdGEuc2V0KHNyYy5kYXRhKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc3ViXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9zdWIoYmEsIG9mcywgbGVuKSB7XG4gIHZhciBjaGFuZ2VkX2RpbTtcbiAgdmFyIG11bCA9IDE7XG4gIGlmIChiYS5sYXlvdXQgPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICAgIG11bCA9IG11bCAqIGJhLmRpbXNbaV07XG4gICAgY2hhbmdlZF9kaW0gPSAwO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKGJhLmRpbXMubGVuZ3RoIC0gMSk7IGkrKylcbiAgICAgIG11bCA9IG11bCAqIGJhLmRpbXNbaV07XG4gICAgY2hhbmdlZF9kaW0gPSBiYS5kaW1zLmxlbmd0aCAtIDE7XG4gICAgb2ZzID0gb2ZzIC0gMTtcbiAgfVxuICBpZiAob2ZzIDwgMCB8fCBsZW4gPCAwIHx8IChvZnMgKyBsZW4pID4gYmEuZGltc1tjaGFuZ2VkX2RpbV0pe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnN1YjogYmFkIHN1Yi1hcnJheVwiKTtcbiAgfVxuICB2YXIgbmV3X2RpbXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIG5ld19kaW1zW2ldID0gYmEuZGltc1tpXTtcbiAgbmV3X2RpbXNbY2hhbmdlZF9kaW1dID0gbGVuO1xuICBtdWwgKj0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChiYS5raW5kKTtcbiAgdmFyIG5ld19kYXRhID0gYmEuZGF0YS5zdWJhcnJheShvZnMgKiBtdWwsIChvZnMgKyBsZW4pICogbXVsKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW1zLCBuZXdfZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2xpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfc2xpY2UoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG51bV9pbmRzID0gdmluZC5sZW5ndGg7XG4gIHZhciBpbmRleCA9IFtdO1xuICB2YXIgc3ViX2RpbXMgPSBbXTtcbiAgdmFyIG9mcztcblxuICBpZiAobnVtX2luZHMgPiBiYS5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zbGljZTogdG9vIG1hbnkgaW5kaWNlc1wiKTtcblxuICAvLyBDb21wdXRlIG9mZnNldCBhbmQgY2hlY2sgYm91bmRzXG4gIGlmIChiYS5sYXlvdXQgPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2ldID0gdmluZFtpXTtcbiAgICBmb3IgKDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgICBpbmRleFtpXSA9IDA7XG4gICAgc3ViX2RpbXMgPSBiYS5kaW1zLnNsaWNlKG51bV9pbmRzKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzICsgaV0gPSB2aW5kW2ldO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGggLSBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSAxO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZSgwLCBiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzKTtcbiAgfVxuICBvZnMgPSBiYS5vZmZzZXQoaW5kZXgpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoc3ViX2RpbXMpO1xuICB2YXIgc2l6ZV9wZXJfZWxlbWVudCA9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkob2ZzICogc2l6ZV9wZXJfZWxlbWVudCwgKG9mcyArIHNpemUpICogc2l6ZV9wZXJfZWxlbWVudCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBzdWJfZGltcywgbmV3X2RhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3Jlc2hhcGVcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfYmFfZ2V0X3NpemVcbmZ1bmN0aW9uIGNhbWxfYmFfcmVzaGFwZShiYSwgdmluZCkge1xuICB2aW5kID0gY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpO1xuICB2YXIgbmV3X2RpbSA9IFtdO1xuICB2YXIgbnVtX2RpbXMgPSB2aW5kLmxlbmd0aDtcblxuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgfVxuICB2YXIgbnVtX2VsdHMgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIHtcbiAgICBuZXdfZGltW2ldID0gdmluZFtpXTtcbiAgICBpZiAobmV3X2RpbVtpXSA8IDApXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgbnVtX2VsdHMgPSBudW1fZWx0cyAqIG5ld19kaW1baV07XG4gIH1cblxuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoYmEuZGltcyk7XG4gIC8vIENoZWNrIHRoYXQgc2l6ZXMgYWdyZWVcbiAgaWYgKG51bV9lbHRzICE9IHNpemUpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogc2l6ZSBtaXNtYXRjaFwiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW0sIGJhLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfYmFfc2VyaWFsaXplKHdyaXRlciwgYmEsIHN6KSB7XG4gIHdyaXRlci53cml0ZSgzMiwgYmEuZGltcy5sZW5ndGgpO1xuICB3cml0ZXIud3JpdGUoMzIsIChiYS5raW5kIHwgKGJhLmxheW91dCA8PCA4KSkpO1xuICBpZihiYS5jYW1sX2N1c3RvbSA9PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZihiYS5kaW1zW2ldIDwgMHhmZmZmKVxuICAgICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRpbXNbaV0pO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHdyaXRlci53cml0ZSgxNiwgMHhmZmZmKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCAwKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kaW1zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIGVsc2VcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgd3JpdGVyLndyaXRlKDMyLGJhLmRpbXNbaV0pXG4gIHN3aXRjaChiYS5raW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSg4LCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIHdyaXRlci53cml0ZSg4LDApO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGJhLmdldChpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGIpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBqID0gYmEuZ2V0KGkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsxXSkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsyXSkpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBjb21wbGV4ID0gYmEuZ2V0KGkpO1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChjb21wbGV4WzFdKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsyXSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHN6WzBdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA0O1xuICBzelsxXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kZXNlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzLCBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2Rlc2VyaWFsaXplKHJlYWRlciwgc3osIG5hbWUpe1xuICB2YXIgbnVtX2RpbXMgPSByZWFkZXIucmVhZDMycygpO1xuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB3cm9uZyBudW1iZXIgb2YgYmlnYXJyYXkgZGltZW5zaW9uc1wiKTtcbiAgdmFyIHRhZyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBraW5kID0gdGFnICYgMHhmZlxuICB2YXIgbGF5b3V0ID0gKHRhZyA+PiA4KSAmIDE7XG4gIHZhciBkaW1zID0gW11cbiAgaWYobmFtZSA9PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgICAgdmFyIHNpemVfZGltID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICAgIGlmKHNpemVfZGltID09IDB4ZmZmZil7XG4gICAgICAgIHZhciBzaXplX2RpbV9oaSA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgIHZhciBzaXplX2RpbV9sbyA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgIGlmKHNpemVfZGltX2hpICE9IDApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBiaWdhcnJheSBkaW1lbnNpb24gb3ZlcmZsb3cgaW4gMzJiaXRcIik7XG4gICAgICAgIHNpemVfZGltID0gc2l6ZV9kaW1fbG87XG4gICAgICB9XG4gICAgICBkaW1zLnB1c2goc2l6ZV9kaW0pO1xuICAgIH1cbiAgZWxzZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykgZGltcy5wdXNoKHJlYWRlci5yZWFkMzJ1KCkpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoZGltcyk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIHNpemUpO1xuICB2YXIgYmEgPSBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkOHMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICB2YXIgc2l4dHkgPSByZWFkZXIucmVhZDh1KCk7XG4gICAgaWYoc2l4dHkpIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogY2Fubm90IHJlYWQgYmlnYXJyYXkgd2l0aCA2NC1iaXQgT0NhbWwgaW50c1wiKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OiAvLyAoaW50NjQpXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGludDY0ID0gY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KTtcbiAgICAgIGJhLnNldChpLGludDY0KTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBmID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgYmEuc2V0KGksZik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIHZhciBmID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgYmEuc2V0KGksZik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIHZhciByZSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIHZhciBpbSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIGJhLnNldChpLFsyNTQscmUsaW1dKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciByZSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBpbSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGJhLnNldChpLFsyNTQscmUsaW1dKTtcbiAgICB9XG4gICAgYnJlYWtcbiAgfVxuICBzelswXSA9ICg0ICsgbnVtX2RpbXMpICogNDtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xufVxuXG4vL0RlcHJlY2F0ZWRcbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2Zyb21cbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9mcm9tKGRhdGExLCBkYXRhMiwganN0eXAsIGtpbmQsIGxheW91dCwgZGltcyl7XG4gIGlmKGRhdGEyIHx8IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkgPT0gMil7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iYV9jcmVhdGVfZnJvbTogdXNlIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcIik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGExKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9oYXNoIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9mbG9hdFxuZnVuY3Rpb24gY2FtbF9iYV9oYXNoKGJhKXtcbiAgdmFyIG51bV9lbHRzID0gY2FtbF9iYV9nZXRfc2l6ZShiYS5kaW1zKTtcbiAgdmFyIGggPSAwO1xuICBzd2l0Y2goYmEua2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBpZihudW1fZWx0cyA+IDI1NikgbnVtX2VsdHMgPSAyNTY7XG4gICAgdmFyIHcgPSAwLCBpID0wO1xuICAgIGZvcihpID0gMDsgaSArIDQgPD0gYmEuZGF0YS5sZW5ndGg7IGkrPTQpe1xuICAgICAgdyA9IGJhLmRhdGFbaSswXSB8IChiYS5kYXRhW2krMV0gPDwgOCkgfCAoYmEuZGF0YVtpKzJdIDw8IDE2KSB8IChiYS5kYXRhW2krM10gPDwgMjQpO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsdyk7XG4gICAgfVxuICAgIHcgPSAwO1xuICAgIHN3aXRjaCAobnVtX2VsdHMgJiAzKSB7XG4gICAgY2FzZSAzOiB3ICA9IGJhLmRhdGFbaSsyXSA8PCAxNjsgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlIDI6IHcgfD0gYmEuZGF0YVtpKzFdIDw8IDg7ICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgMTogdyB8PSBiYS5kYXRhW2krMF07XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgaWYobnVtX2VsdHMgPiAxMjgpIG51bV9lbHRzID0gMTI4O1xuICAgIHZhciB3ID0gMCwgaSA9MDtcbiAgICBmb3IoaSA9IDA7IGkgKyAyIDw9IGJhLmRhdGEubGVuZ3RoOyBpKz0yKXtcbiAgICAgIHcgPSBiYS5kYXRhW2krMF0gfCAoYmEuZGF0YVtpKzFdIDw8IDE2KTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLHcpO1xuICAgIH1cbiAgICBpZiAoKG51bV9lbHRzICYgMSkgIT0gMClcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBpZiAobnVtX2VsdHMgPiAzMikgbnVtX2VsdHMgPSAzMjtcbiAgICBudW1fZWx0cyAqPSAyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBudW1fZWx0cyAqPTI7IC8qIGZhbGx0aHJvdWdoICovXG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIG51bV9lbHRzICo9MjsgLyogZmFsbHRocm91Z2ggKi9cbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgaWYgKG51bV9lbHRzID4gMzIpIG51bV9lbHRzID0gMzI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV90b190eXBlZF9hcnJheSBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGJhKXtcbiAgcmV0dXJuIGJhLmRhdGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSh0YSl7XG4gIHZhciBnID0gZ2xvYmFsVGhpcztcbiAgdmFyIGtpbmQ7XG4gIGlmICh0YSBpbnN0YW5jZW9mIGcuRmxvYXQzMkFycmF5KSBraW5kID0gMDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkZsb2F0NjRBcnJheSkga2luZCA9IDE7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5JbnQ4QXJyYXkpIGtpbmQgPSAyO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDhBcnJheSkga2luZCA9IDM7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5JbnQxNkFycmF5KSBraW5kID0gNDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLlVpbnQxNkFycmF5KSBraW5kID0gNTtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgcmV0dXJuIGtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGtpbmQgPSBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWJcblxuLy9Qcm92aWRlczogY2FtbF9qc19wdXJlX2V4cHIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfcHVyZV9leHByIChmKSB7IHJldHVybiBmKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19zZXQgKG11dGFibGUsIGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfc2V0KG8sZix2KSB7IG9bZl09djtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0IG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0KG8sZikgeyByZXR1cm4gb1tmXTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19kZWxldGUgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19kZWxldGUobyxmKSB7IGRlbGV0ZSBvW2ZdOyByZXR1cm4gMH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19pbnN0YW5jZW9mIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2luc3RhbmNlb2YobyxjKSB7IHJldHVybiAobyBpbnN0YW5jZW9mIGMpID8gMSA6IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc190eXBlb2YgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190eXBlb2YobykgeyByZXR1cm4gdHlwZW9mIG87IH1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVcbmZ1bmN0aW9uIGNhbWxfdHJhbXBvbGluZShyZXMpIHtcbiAgdmFyIGMgPSAxO1xuICB3aGlsZShyZXMgJiYgcmVzLmpvb190cmFtcCl7XG4gICAgcmVzID0gcmVzLmpvb190cmFtcC5hcHBseShudWxsLCByZXMuam9vX2FyZ3MpO1xuICAgIGMrKztcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfdHJhbXBvbGluZV9yZXR1cm5cbmZ1bmN0aW9uIGNhbWxfdHJhbXBvbGluZV9yZXR1cm4oZixhcmdzKSB7XG4gIHJldHVybiB7am9vX3RyYW1wOmYsam9vX2FyZ3M6YXJnc307XG59XG5cbi8vUHJvdmlkZXM6IGpzX3ByaW50X3N0ZG91dCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGpzX3ByaW50X3N0ZG91dChzKSB7XG4gIHZhciBzID0gY2FtbF91dGYxNl9vZl91dGY4KHMpO1xuICB2YXIgZyA9IGdsb2JhbFRoaXM7XG4gIGlmIChnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLnN0ZG91dCAmJiBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKSB7XG4gICAgZy5wcm9jZXNzLnN0ZG91dC53cml0ZShzKVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIGlmKHMuY2hhckNvZGVBdChzLmxlbmd0aCAtIDEpID09IDEwKVxuICAgICAgcyA9IHMuc3Vic3RyKDAscy5sZW5ndGggLSAxICk7XG4gICAgdmFyIHYgPSBnLmNvbnNvbGU7XG4gICAgdiAgJiYgdi5sb2cgJiYgdi5sb2cocyk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGpzX3ByaW50X3N0ZGVyciAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGpzX3ByaW50X3N0ZGVycihzKSB7XG4gIHZhciBzID0gY2FtbF91dGYxNl9vZl91dGY4KHMpO1xuICB2YXIgZyA9IGdsb2JhbFRoaXM7XG4gIGlmIChnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLnN0ZG91dCAmJiBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKSB7XG4gICAgZy5wcm9jZXNzLnN0ZGVyci53cml0ZShzKVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIGlmKHMuY2hhckNvZGVBdChzLmxlbmd0aCAtIDEpID09IDEwKVxuICAgICAgcyA9IHMuc3Vic3RyKDAscy5sZW5ndGggLSAxICk7XG4gICAgdmFyIHYgPSBnLmNvbnNvbGU7XG4gICAgdiAmJiB2LmVycm9yICYmIHYuZXJyb3Iocyk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19qc1xuZnVuY3Rpb24gY2FtbF9pc19qcygpIHtcbiAgcmV0dXJuIDE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd3JhcF9leGNlcHRpb24gY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSxjYW1sX3N0cmluZ19vZl9qc3N0cmluZyxjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnRcbmZ1bmN0aW9uIGNhbWxfd3JhcF9leGNlcHRpb24oZSkge1xuICBpZihlIGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBlO1xuICAvL1N0YWNrX292ZXJmbG93OiBjaHJvbWUsIHNhZmFyaVxuICBpZihnbG9iYWxUaGlzLlJhbmdlRXJyb3JcbiAgICAgJiYgZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuUmFuZ2VFcnJvclxuICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgJiYgZS5tZXNzYWdlLm1hdGNoKC9tYXhpbXVtIGNhbGwgc3RhY2svaSkpXG4gICAgcmV0dXJuIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93KTtcbiAgLy9TdGFja19vdmVyZmxvdzogZmlyZWZveFxuICBpZihnbG9iYWxUaGlzLkludGVybmFsRXJyb3JcbiAgICAgJiYgZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuSW50ZXJuYWxFcnJvclxuICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgJiYgZS5tZXNzYWdlLm1hdGNoKC90b28gbXVjaCByZWN1cnNpb24vaSkpXG4gICAgcmV0dXJuIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93KTtcbiAgLy9XcmFwIEVycm9yIGluIEpzLkVycm9yIGV4Y2VwdGlvblxuICBpZihlIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5FcnJvciAmJiBjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSlcbiAgICByZXR1cm4gWzAsY2FtbF9uYW1lZF92YWx1ZShcImpzRXJyb3JcIiksZV07XG4gIC8vZmFsbGJhY2s6IHdyYXBwZWQgaW4gRmFpbHVyZVxuICByZXR1cm4gWzAsY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChTdHJpbmcoZSkpXTtcbn1cblxuLy8gRXhwZXJpbWVudGFsXG4vL1Byb3ZpZGVzOiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UoZXhuLCBmb3JjZSkge1xuICAvL25ldmVyIHJlcmFpc2UgZm9yIGNvbnN0YW50IGV4blxuICBpZighZXhuLmpzX2Vycm9yIHx8IGZvcmNlIHx8IGV4blswXSA9PSAyNDgpIGV4bi5qc19lcnJvciA9IG5ldyBnbG9iYWxUaGlzLkVycm9yKFwiSnMgZXhjZXB0aW9uIGNvbnRhaW5pbmcgYmFja3RyYWNlXCIpO1xuICByZXR1cm4gZXhuO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb3B0aW9uX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vcHRpb25fb2ZfZXhjZXB0aW9uKGV4bikge1xuICBpZihleG4uanNfZXJyb3IpIHsgcmV0dXJuIFswLCBleG4uanNfZXJyb3JdOyB9XG4gIHJldHVybiAwO1xufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Jvb2woeCkgeyByZXR1cm4gISF4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19ib29sKHgpIHsgcmV0dXJuICt4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19mbG9hdCh4KSB7IHJldHVybiB4OyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2FycmF5KGEpIHtcbiAgcmV0dXJuIGEuc2xpY2UoMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2FycmF5KGEpIHtcbiAgdmFyIGxlbiA9IGEubGVuZ3RoO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGJbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGxlbjtpKyspIGJbaSsxXSA9IGFbaV07XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9saXN0X29mX2pzX2FycmF5KGEpe1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgaT1hLmxlbmd0aCAtIDE7IGk+PTA7IGktLSl7XG4gICAgdmFyIGUgPSBhW2ldO1xuICAgIGwgPSBbMCxlLGxdO1xuICB9XG4gIHJldHVybiBsXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF90b19qc19hcnJheSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xpc3RfdG9fanNfYXJyYXkobCl7XG4gIHZhciBhID0gW107XG4gIGZvcig7IGwgIT09IDA7IGwgPSBsWzJdKSB7XG4gICAgYS5wdXNoKGxbMV0pO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3ZhciBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdmFyKHgpIHtcbiAgdmFyIHggPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh4KTtcbiAgLy9DaGVja3MgdGhhdCB4IGhhcyB0aGUgZm9ybSBpZGVudFsuaWRlbnRdKlxuICBpZigheC5tYXRjaCgvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKihcXC5bYS16QS1aXyRdW2EtekEtWl8kMC05XSopKiQvKSl7XG4gICAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9qc192YXI6IFxcXCJcIiArIHggKyBcIlxcXCIgaXMgbm90IGEgdmFsaWQgSmF2YVNjcmlwdCB2YXJpYWJsZS4gY29udGludWluZyAuLlwiKTtcbiAgICAvL2dsb2JhbFRoaXMuY29uc29sZS5lcnJvcihcIkpzLlVuc2FmZS5ldmFsX3N0cmluZ1wiKVxuICB9XG4gIHJldHVybiBldmFsKHgpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19jYWxsIChjb25zdCwgbXV0YWJsZSwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19jYWxsKGYsIG8sIGFyZ3MpIHsgcmV0dXJuIGYuYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mdW5fY2FsbCAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfZnVuX2NhbGwoZiwgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIGYoKTtcbiAgY2FzZSAyOiByZXR1cm4gZiAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIGYgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgcmV0dXJuIGYuYXBwbHkobnVsbCwgY2FtbF9qc19mcm9tX2FycmF5KGEpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbWV0aF9jYWxsIChtdXRhYmxlLCBjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbWV0aF9jYWxsKG8sIGYsIGFyZ3MpIHtcbiAgcmV0dXJuIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoZildLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX25ldyAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbmV3KGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBuZXcgYztcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9vanNfbmV3X2FyciAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb2pzX25ld19hcnIoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMDogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDE6IHJldHVybiBuZXcgYyAoYVswXSk7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgYSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobGVuID4gMCl7XG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBbdW5kZWZpbmVkXSk7XG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHNcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIFthcmdzXSk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobiA9PSBhcml0eSAmJiBmLmxlbmd0aCA9PSBhcml0eSkgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSk7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGgsIGFyaXR5KVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsYXJncyk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLFt0aGlzLGFyZ3NdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSArIDEpO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoLCBhcml0eSlcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7IH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXF1YWxzIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZXF1YWxzICh4LCB5KSB7IHJldHVybiArKHggPT0geSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19ldmFsX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19ldmFsX3N0cmluZyAocykge3JldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXhwciAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2V4cHIocykge1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblxcblwiKTtcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9wdXJlX2pzX2V4cHIgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9wdXJlX2pzX2V4cHIgKHMpe1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX3B1cmVfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXFxuXCIpO1xuICByZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29iamVjdCAob2JqZWN0X2xpdGVyYWwpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19vYmplY3QgKGEpIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBhW2ldO1xuICAgIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocFsxXSldID0gcFsyXTtcbiAgfVxuICByZXR1cm4gbztcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBwYXJzaW5nLmMgODk4MyAyMDA4LTA4LTA2IDA5OjM4OjI1WiB4bGVyb3kgJCAqL1xuXG4vKiBUaGUgUERBIGF1dG9tYXRvbiBmb3IgcGFyc2VycyBnZW5lcmF0ZWQgYnkgY2FtbHlhY2MgKi9cblxuLyogVGhlIHB1c2hkb3duIGF1dG9tYXRhICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2xleF9hcnJheVxuZnVuY3Rpb24gY2FtbF9wYXJzZV9lbmdpbmUodGFibGVzLCBlbnYsIGNtZCwgYXJnKVxue1xuICB2YXIgRVJSQ09ERSA9IDI1NjtcblxuICAvL3ZhciBTVEFSVCA9IDA7XG4gIC8vdmFyIFRPS0VOX1JFQUQgPSAxO1xuICAvL3ZhciBTVEFDS1NfR1JPV05fMSA9IDI7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8yID0gMztcbiAgLy92YXIgU0VNQU5USUNfQUNUSU9OX0NPTVBVVEVEID0gNDtcbiAgLy92YXIgRVJST1JfREVURUNURUQgPSA1O1xuICB2YXIgbG9vcCA9IDY7XG4gIHZhciB0ZXN0c2hpZnQgPSA3O1xuICB2YXIgc2hpZnQgPSA4O1xuICB2YXIgc2hpZnRfcmVjb3ZlciA9IDk7XG4gIHZhciByZWR1Y2UgPSAxMDtcblxuICB2YXIgUkVBRF9UT0tFTiA9IDA7XG4gIHZhciBSQUlTRV9QQVJTRV9FUlJPUiA9IDE7XG4gIHZhciBHUk9XX1NUQUNLU18xID0gMjtcbiAgdmFyIEdST1dfU1RBQ0tTXzIgPSAzO1xuICB2YXIgQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04gPSA0O1xuICB2YXIgQ0FMTF9FUlJPUl9GVU5DVElPTiA9IDU7XG5cbiAgdmFyIGVudl9zX3N0YWNrID0gMTtcbiAgdmFyIGVudl92X3N0YWNrID0gMjtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0X3N0YWNrID0gMztcbiAgdmFyIGVudl9zeW1iX2VuZF9zdGFjayA9IDQ7XG4gIHZhciBlbnZfc3RhY2tzaXplID0gNTtcbiAgdmFyIGVudl9zdGFja2Jhc2UgPSA2O1xuICB2YXIgZW52X2N1cnJfY2hhciA9IDc7XG4gIHZhciBlbnZfbHZhbCA9IDg7XG4gIHZhciBlbnZfc3ltYl9zdGFydCA9IDk7XG4gIHZhciBlbnZfc3ltYl9lbmQgPSAxMDtcbiAgdmFyIGVudl9hc3AgPSAxMTtcbiAgdmFyIGVudl9ydWxlX2xlbiA9IDEyO1xuICB2YXIgZW52X3J1bGVfbnVtYmVyID0gMTM7XG4gIHZhciBlbnZfc3AgPSAxNDtcbiAgdmFyIGVudl9zdGF0ZSA9IDE1O1xuICB2YXIgZW52X2VycmZsYWcgPSAxNjtcblxuICAvLyB2YXIgX3RibF9hY3Rpb25zID0gMTtcbiAgdmFyIHRibF90cmFuc2xfY29uc3QgPSAyO1xuICB2YXIgdGJsX3RyYW5zbF9ibG9jayA9IDM7XG4gIHZhciB0YmxfbGhzID0gNDtcbiAgdmFyIHRibF9sZW4gPSA1O1xuICB2YXIgdGJsX2RlZnJlZCA9IDY7XG4gIHZhciB0YmxfZGdvdG8gPSA3O1xuICB2YXIgdGJsX3NpbmRleCA9IDg7XG4gIHZhciB0YmxfcmluZGV4ID0gOTtcbiAgdmFyIHRibF9naW5kZXggPSAxMDtcbiAgdmFyIHRibF90YWJsZXNpemUgPSAxMTtcbiAgdmFyIHRibF90YWJsZSA9IDEyO1xuICB2YXIgdGJsX2NoZWNrID0gMTM7XG4gIC8vIHZhciBfdGJsX2Vycm9yX2Z1bmN0aW9uID0gMTQ7XG4gIC8vIHZhciBfdGJsX25hbWVzX2NvbnN0ID0gMTU7XG4gIC8vIHZhciBfdGJsX25hbWVzX2Jsb2NrID0gMTY7XG5cbiAgaWYgKCF0YWJsZXMuZGdvdG8pIHtcbiAgICB0YWJsZXMuZGVmcmVkID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZGVmcmVkXSk7XG4gICAgdGFibGVzLnNpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3NpbmRleF0pO1xuICAgIHRhYmxlcy5jaGVjayAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9jaGVja10pO1xuICAgIHRhYmxlcy5yaW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9yaW5kZXhdKTtcbiAgICB0YWJsZXMudGFibGUgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfdGFibGVdKTtcbiAgICB0YWJsZXMubGVuICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGVuXSk7XG4gICAgdGFibGVzLmxocyAgICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2xoc10pO1xuICAgIHRhYmxlcy5naW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9naW5kZXhdKTtcbiAgICB0YWJsZXMuZGdvdG8gID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZGdvdG9dKTtcbiAgfVxuXG4gIHZhciByZXMgPSAwLCBuLCBuMSwgbjIsIHN0YXRlMTtcblxuICAvLyBSRVNUT1JFXG4gIHZhciBzcCA9IGVudltlbnZfc3BdO1xuICB2YXIgc3RhdGUgPSBlbnZbZW52X3N0YXRlXTtcbiAgdmFyIGVycmZsYWcgPSBlbnZbZW52X2VycmZsYWddO1xuXG4gIGV4aXQ6Zm9yICg7Oykge1xuICAgIHN3aXRjaChjbWQpIHtcbiAgICBjYXNlIDA6Ly9TVEFSVDpcbiAgICAgIHN0YXRlID0gMDtcbiAgICAgIGVycmZsYWcgPSAwO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIDY6Ly9sb29wOlxuICAgICAgbiA9IHRhYmxlcy5kZWZyZWRbc3RhdGVdO1xuICAgICAgaWYgKG4gIT0gMCkgeyBjbWQgPSByZWR1Y2U7IGJyZWFrOyB9XG4gICAgICBpZiAoZW52W2Vudl9jdXJyX2NoYXJdID49IDApIHsgY21kID0gdGVzdHNoaWZ0OyBicmVhazsgfVxuICAgICAgcmVzID0gUkVBRF9UT0tFTjtcbiAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgbGV4ZXIgYW5kIHVwZGF0ZXMgKi9cbiAgICAgIC8qIHN5bWJfc3RhcnQgYW5kIHN5bWJfZW5kICovXG4gICAgY2FzZSAxOi8vVE9LRU5fUkVBRDpcbiAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSB0YWJsZXNbdGJsX3RyYW5zbF9ibG9ja11bYXJnWzBdICsgMV07XG4gICAgICAgIGVudltlbnZfbHZhbF0gPSBhcmdbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSB0YWJsZXNbdGJsX3RyYW5zbF9jb25zdF1bYXJnICsgMV07XG4gICAgICAgIGVudltlbnZfbHZhbF0gPSAwO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIDc6Ly90ZXN0c2hpZnQ6XG4gICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgY21kID0gc2hpZnQ7IGJyZWFrO1xuICAgICAgfVxuICAgICAgbjEgPSB0YWJsZXMucmluZGV4W3N0YXRlXTtcbiAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gZW52W2Vudl9jdXJyX2NoYXJdKSB7XG4gICAgICAgIG4gPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgICBjbWQgPSByZWR1Y2U7IGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGVycmZsYWcgPD0gMCkge1xuICAgICAgICByZXMgPSBDQUxMX0VSUk9SX0ZVTkNUSU9OO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgZXJyb3IgZnVuY3Rpb24gKi9cbiAgICBjYXNlIDU6Ly9FUlJPUl9ERVRFQ1RFRDpcbiAgICAgIGlmIChlcnJmbGFnIDwgMykge1xuICAgICAgICBlcnJmbGFnID0gMztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3AgKyAxXTtcbiAgICAgICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGUxXTtcbiAgICAgICAgICBuMiA9IG4xICsgRVJSQ09ERTtcbiAgICAgICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IEVSUkNPREUpIHtcbiAgICAgICAgICAgIGNtZCA9IHNoaWZ0X3JlY292ZXI7IGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3AgPD0gZW52W2Vudl9zdGFja2Jhc2VdKSByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgICAgICAgICAvKiBUaGUgTUwgY29kZSByYWlzZXMgUGFyc2VfZXJyb3IgKi9cbiAgICAgICAgICAgIHNwLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZW52W2Vudl9jdXJyX2NoYXJdID09IDApIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICAgICAgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IC0xO1xuICAgICAgICBjbWQgPSBsb29wOyBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgIGNhc2UgODovL3NoaWZ0OlxuICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICBpZiAoZXJyZmxhZyA+IDApIGVycmZsYWctLTtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgIGNhc2UgOTovL3NoaWZ0X3JlY292ZXI6XG4gICAgICBzdGF0ZSA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICBzcCsrO1xuICAgICAgaWYgKHNwID49IGVudltlbnZfc3RhY2tzaXplXSkge1xuICAgICAgICByZXMgPSBHUk9XX1NUQUNLU18xO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSByZXNpemVzIHRoZSBzdGFja3MgKi9cbiAgICBjYXNlIDI6Ly9TVEFDS1NfR1JPV05fMTpcbiAgICAgIGVudltlbnZfc19zdGFja11bc3AgKyAxXSA9IHN0YXRlO1xuICAgICAgZW52W2Vudl92X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9sdmFsXTtcbiAgICAgIGVudltlbnZfc3ltYl9zdGFydF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9zdGFydF07XG4gICAgICBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF07XG4gICAgICBjbWQgPSBsb29wO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDEwOi8vcmVkdWNlOlxuICAgICAgdmFyIG0gPSB0YWJsZXMubGVuW25dO1xuICAgICAgZW52W2Vudl9hc3BdID0gc3A7XG4gICAgICBlbnZbZW52X3J1bGVfbnVtYmVyXSA9IG47XG4gICAgICBlbnZbZW52X3J1bGVfbGVuXSA9IG07XG4gICAgICBzcCA9IHNwIC0gbSArIDE7XG4gICAgICBtID0gdGFibGVzLmxoc1tuXTtcbiAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3BdO1xuICAgICAgbjEgPSB0YWJsZXMuZ2luZGV4W21dO1xuICAgICAgbjIgPSBuMSArIHN0YXRlMTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBzdGF0ZTEpXG4gICAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMuZGdvdG9bbV07XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzI7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMzovL1NUQUNLU19HUk9XTl8yOlxuICAgICAgcmVzID0gQ09NUFVURV9TRU1BTlRJQ19BQ1RJT047XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIHNlbWFudGljIGFjdGlvbiAqL1xuICAgIGNhc2UgNDovL1NFTUFOVElDX0FDVElPTl9DT01QVVRFRDpcbiAgICAgIGVudltlbnZfc19zdGFja11bc3AgKyAxXSA9IHN0YXRlO1xuICAgICAgZW52W2Vudl92X3N0YWNrXVtzcCArIDFdID0gYXJnO1xuICAgICAgdmFyIGFzcCA9IGVudltlbnZfYXNwXTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIGlmIChzcCA+IGFzcCkge1xuICAgICAgICAvKiBUaGlzIGlzIGFuIGVwc2lsb24gcHJvZHVjdGlvbi4gVGFrZSBzeW1iX3N0YXJ0IGVxdWFsIHRvIHN5bWJfZW5kLiAqL1xuICAgICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIH1cbiAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgLyogU2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvLyBTQVZFXG4gIGVudltlbnZfc3BdID0gc3A7XG4gIGVudltlbnZfc3RhdGVdID0gc3RhdGU7XG4gIGVudltlbnZfZXJyZmxhZ10gPSBlcnJmbGFnO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9wYXJzZXJfdHJhY2UgY29uc3Rcbi8vRHVtbXkgZnVuY3Rpb24hXG5mdW5jdGlvbiBjYW1sX3NldF9wYXJzZXJfdHJhY2UoKSB7IHJldHVybiAwOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9pbnQgY29uc3QgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nLCBjYW1sX3N0cl9yZXBlYXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2ludChmbXQsIGkpIHtcbiAgaWYgKGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KSA9PSBcIiVkXCIpIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIraSk7XG4gIHZhciBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgaWYgKGkgPCAwKSB7IGlmIChmLnNpZ25lZGNvbnYpIHsgZi5zaWduID0gLTE7IGkgPSAtaTsgfSBlbHNlIGkgPj4+PSAwOyB9XG4gIHZhciBzID0gaS50b1N0cmluZyhmLmJhc2UpO1xuICBpZiAoZi5wcmVjID49IDApIHtcbiAgICBmLmZpbGxlciA9ICcgJztcbiAgICB2YXIgbiA9IGYucHJlYyAtIHMubGVuZ3RoO1xuICAgIGlmIChuID4gMCkgcyA9IGNhbWxfc3RyX3JlcGVhdCAobiwgJzAnKSArIHM7XG4gIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpIHtcbiAgdmFyIGkgPSAwLCBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyksIGJhc2UgPSAxMCwgc2lnbiA9IDE7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgc3dpdGNoIChjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsaSkpIHtcbiAgICBjYXNlIDQ1OiBpKys7IHNpZ24gPSAtMTsgYnJlYWs7XG4gICAgY2FzZSA0MzogaSsrOyBzaWduID0gMTsgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChpICsgMSA8IGxlbiAmJiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpID09IDQ4KVxuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpICsgMSkpIHtcbiAgICBjYXNlIDEyMDogY2FzZSA4ODogYmFzZSA9IDE2OyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgMTExOiBjYXNlIDc5OiBiYXNlID0gIDg7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAgOTg6IGNhc2UgNjY6IGJhc2UgPSAgMjsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlIDExNzogY2FzZSA4NTogaSArPSAyOyBicmVhaztcbiAgICB9XG4gIHJldHVybiBbaSwgc2lnbiwgYmFzZV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZGlnaXRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZGlnaXQoYykge1xuICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KSAgcmV0dXJuIGMgLSA0ODtcbiAgaWYgKGMgPj0gNjUgJiYgYyA8PSA5MCkgIHJldHVybiBjIC0gNTU7XG4gIGlmIChjID49IDk3ICYmIGMgPD0gMTIyKSByZXR1cm4gYyAtIDg3O1xuICByZXR1cm4gLTE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50X29mX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSwgY2FtbF9wYXJzZV9kaWdpdCwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9pbnRfb2Zfc3RyaW5nIChzKSB7XG4gIHZhciByID0gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKTtcbiAgdmFyIGkgPSByWzBdLCBzaWduID0gclsxXSwgYmFzZSA9IHJbMl07XG4gIHZhciBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyk7XG4gIHZhciB0aHJlc2hvbGQgPSAtMSA+Pj4gMDtcbiAgdmFyIGMgPSAoaSA8IGxlbik/Y2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTowO1xuICB2YXIgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB2YXIgcmVzID0gZDtcbiAgZm9yIChpKys7aTxsZW47aSsrKSB7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIHJlcyA9IGJhc2UgKiByZXMgKyBkO1xuICAgIGlmIChyZXMgPiB0aHJlc2hvbGQpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB9XG4gIGlmIChpICE9IGxlbikgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIC8vIEZvciBiYXNlIGRpZmZlcmVudCBmcm9tIDEwLCB3ZSBleHBlY3QgYW4gdW5zaWduZWQgcmVwcmVzZW50YXRpb24sXG4gIC8vIGhlbmNlIGFueSB2YWx1ZSBvZiAncmVzJyAobGVzcyB0aGFuICd0aHJlc2hvbGQnKSBpcyBhY2NlcHRhYmxlLlxuICAvLyBCdXQgd2UgaGF2ZSB0byBjb252ZXJ0IHRoZSByZXN1bHQgYmFjayB0byBhIHNpZ25lZCBpbnRlZ2VyLlxuICByZXMgPSBzaWduICogcmVzO1xuICBpZiAoKGJhc2UgPT0gMTApICYmICgocmVzIHwgMCkgIT0gcmVzKSlcbiAgICAvKiBTaWduZWQgcmVwcmVzZW50YXRpb24gZXhwZWN0ZWQsIGFsbG93IC0yXihuYml0cy0xKSB0byAyXihuYml0cy0xKSAtIDEgKi9cbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgcmV0dXJuIHJlcyB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbXVsIGNvbnN0XG5mdW5jdGlvbiBjYW1sX211bChhLGIpe1xuICByZXR1cm4gTWF0aC5pbXVsKGEsYik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZGl2XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBjYW1sX2Rpdih4LHkpIHtcbiAgaWYgKHkgPT0gMCkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgcmV0dXJuICh4L3kpfDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbW9kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBjYW1sX21vZCh4LHkpIHtcbiAgaWYgKHkgPT0gMCkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgcmV0dXJuIHgleTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ic3dhcDE2XG5mdW5jdGlvbiBjYW1sX2Jzd2FwMTYoeCkge1xuICByZXR1cm4gKCgoKHggJiAweDAwRkYpIDw8IDgpIHxcbiAgICAgICAgICAgKCh4ICYgMHhGRjAwKSA+PiA4KSkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9ic3dhcFxuZnVuY3Rpb24gY2FtbF9pbnQzMl9ic3dhcCh4KSB7XG4gIHJldHVybiAoKCh4ICYgMHgwMDAwMDBGRikgPDwgMjQpIHxcbiAgICAgICAgICAoKHggJiAweDAwMDBGRjAwKSA8PCA4KSB8XG4gICAgICAgICAgKCh4ICYgMHgwMEZGMDAwMCkgPj4+IDgpIHxcbiAgICAgICAgICAoKHggJiAweEZGMDAwMDAwKSA+Pj4gMjQpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYnN3YXBcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYnN3YXAoeCkge1xuICB2YXIgeSA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoeCk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKFt5WzddLCB5WzZdLCB5WzVdLCB5WzRdLCB5WzNdLCB5WzJdLCB5WzFdLCB5WzBdXSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEhhc2h0YmxcblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX3VuaXZfcGFyYW0gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2hhc2hfdW5pdl9wYXJhbSAoY291bnQsIGxpbWl0LCBvYmopIHtcbiAgdmFyIGhhc2hfYWNjdSA9IDA7XG4gIGZ1bmN0aW9uIGhhc2hfYXV4IChvYmopIHtcbiAgICBsaW1pdCAtLTtcbiAgICBpZiAoY291bnQgPCAwIHx8IGxpbWl0IDwgMCkgcmV0dXJuO1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSAmJiBvYmpbMF0gPT09IChvYmpbMF18MCkpIHtcbiAgICAgIHN3aXRjaCAob2JqWzBdKSB7XG4gICAgICBjYXNlIDI0ODpcbiAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmpbMl0pIHwgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBsaW1pdCsrOyBoYXNoX2F1eChvYmopOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBvYmpbMF0pIHwgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IG9iai5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSBoYXNoX2F1eCAob2JqW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMob2JqKSkge1xuICAgICAgY291bnQgLS07XG4gICAgICB2YXIgY29udGVudCA9IGNhbWxfbWxfYnl0ZXNfY29udGVudChvYmopO1xuICAgICAgaWYodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcblx0Zm9yICh2YXIgYiA9IGNvbnRlbnQsIGwgPSBiLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgICB9IGVsc2UgeyAvKiBBUlJBWSAqL1xuICAgICAgICBmb3IgKHZhciBhID0gY29udGVudCwgbCA9IGEubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBhW2ldKSB8IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyhvYmopKSB7XG4gICAgICB2YXIganNieXRlcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob2JqKTtcbiAgICAgIGZvciAodmFyIGIgPSBqc2J5dGVzLCBsID0ganNieXRlcy5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGZvciAodmFyIGIgPSBvYmosIGwgPSBvYmoubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgfSBlbHNlIGlmIChvYmogPT09IChvYmp8MCkpIHtcbiAgICAgIC8vIEludGVnZXJcbiAgICAgIGNvdW50IC0tO1xuICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqKSB8IDA7XG4gICAgfSBlbHNlIGlmIChvYmogPT09ICtvYmopIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBjb3VudC0tO1xuICAgICAgdmFyIHAgPSBjYW1sX2ludDY0X3RvX2J5dGVzIChjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKG9iaikpO1xuICAgICAgZm9yICh2YXIgaSA9IDc7IGkgPj0gMDsgaS0tKSBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBwW2ldKSB8IDA7XG4gICAgfSBlbHNlIGlmKG9iaiAmJiBvYmouY2FtbF9jdXN0b20pIHtcbiAgICAgIGlmKGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dLmhhc2gpIHtcbiAgICAgICAgdmFyIGggPSBjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXS5oYXNoKG9iaikgfCAwO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBoKSB8IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhc2hfYXV4IChvYmopO1xuICByZXR1cm4gaGFzaF9hY2N1ICYgMHgzRkZGRkZGRjtcbn1cblxuLy9mdW5jdGlvbiBST1RMMzIoeCxuKSB7IHJldHVybiAoKHggPDwgbikgfCAoeCA+Pj4gKDMyLW4pKSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX211bFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQoaCxkKSB7XG4gIGQgPSBjYW1sX211bChkLCAweGNjOWUyZDUxfDApO1xuICBkID0gKChkIDw8IDE1KSB8IChkID4+PiAoMzItMTUpKSk7IC8vIFJPVEwzMihkLCAxNSk7XG4gIGQgPSBjYW1sX211bChkLCAweDFiODczNTkzKTtcbiAgaCBePSBkO1xuICBoID0gKChoIDw8IDEzKSB8IChoID4+PiAoMzItMTMpKSk7ICAgLy9ST1RMMzIoaCwgMTMpO1xuICByZXR1cm4gKCgoaCArIChoIDw8IDIpKXwwKSArICgweGU2NTQ2YjY0fDApKXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX211bFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9maW5hbChoKSB7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIGggPSBjYW1sX211bCAoaCwgMHg4NWViY2E2YnwwKTtcbiAgaCBePSBoID4+PiAxMztcbiAgaCA9IGNhbWxfbXVsIChoLCAweGMyYjJhZTM1fDApO1xuICBoIF49IGggPj4+IDE2O1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2hhc2hfbWl4X2ludDY0XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2Zsb2F0IChoLCB2MCkge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9pbnQ2NChoLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHYwKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9sbzMyLCBjYW1sX2ludDY0X2hpMzJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfaW50NjQgKGgsIHYpIHtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGNhbWxfaW50NjRfbG8zMih2KSk7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBjYW1sX2ludDY0X2hpMzIodikpO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzLmNoYXJDb2RlQXQoaSlcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDgpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNilcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzMpIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICBjYXNlIDM6IHcgID0gcy5jaGFyQ29kZUF0KGkrMikgPDwgMTY7XG4gIGNhc2UgMjogdyB8PSBzLmNoYXJDb2RlQXQoaSsxKSA8PCA4O1xuICBjYXNlIDE6XG4gICAgdyB8PSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICBkZWZhdWx0OlxuICB9XG4gIGggXj0gbGVuO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FycihoLCBzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aCwgaSwgdztcbiAgZm9yIChpID0gMDsgaSArIDQgPD0gbGVuOyBpICs9IDQpIHtcbiAgICB3ID0gc1tpXVxuICAgICAgfCAoc1tpKzFdIDw8IDgpXG4gICAgICB8IChzW2krMl0gPDwgMTYpXG4gICAgICB8IChzW2krM10gPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gIGNhc2UgMzogdyAgPSBzW2krMl0gPDwgMTY7XG4gIGNhc2UgMjogdyB8PSBzW2krMV0gPDwgODtcbiAgY2FzZSAxOiB3IHw9IHNbaV07XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICBkZWZhdWx0OlxuICB9XG4gIGggXj0gbGVuO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19jb250ZW50XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2J5dGVzKGgsIHYpIHtcbiAgdmFyIGNvbnRlbnQgPSBjYW1sX21sX2J5dGVzX2NvbnRlbnQodik7XG4gIGlmKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgY29udGVudClcbiAgZWxzZSAvKiBBUlJBWSAqL1xuICAgIHJldHVybiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FycihoLCBjb250ZW50KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9zdHJpbmcoaCwgdikge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIGNhbWxfanNieXRlc19vZl9zdHJpbmcodikpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmxvYXQsIGNhbWxfaGFzaF9taXhfc3RyaW5nLCBjYW1sX2hhc2hfbWl4X2J5dGVzLCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9oYXNoIChjb3VudCwgbGltaXQsIHNlZWQsIG9iaikge1xuICB2YXIgcXVldWUsIHJkLCB3ciwgc3osIG51bSwgaCwgdiwgaSwgbGVuO1xuICBzeiA9IGxpbWl0O1xuICBpZiAoc3ogPCAwIHx8IHN6ID4gMjU2KSBzeiA9IDI1NjtcbiAgbnVtID0gY291bnQ7XG4gIGggPSBzZWVkO1xuICBxdWV1ZSA9IFtvYmpdOyByZCA9IDA7IHdyID0gMTtcbiAgd2hpbGUgKHJkIDwgd3IgJiYgbnVtID4gMCkge1xuICAgIHYgPSBxdWV1ZVtyZCsrXTtcbiAgICBpZiAodiAmJiB2LmNhbWxfY3VzdG9tKXtcbiAgICAgIGlmKGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaGggPSBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCh2KTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50IChoLCBoaCk7XG4gICAgICAgIG51bSAtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKHZbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHZbMl0pO1xuICAgICAgICBudW0tLTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBxdWV1ZVstLXJkXSA9IHZbMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHRhZyA9ICgodi5sZW5ndGggLSAxKSA8PCAxMCkgfCB2WzBdO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdGFnKTtcbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICh3ciA+PSBzeikgYnJlYWs7XG4gICAgICAgICAgcXVldWVbd3IrK10gPSB2W2ldO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSAodnwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHYrdisxKTtcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gK3YpIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLHYpO1xuICAgICAgbnVtLS07XG4gICAgfVxuICB9XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpO1xuICByZXR1cm4gaCAmIDB4M0ZGRkZGRkY7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfdGFnKGEpe1xuICBpZiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKGEpKSByZXR1cm4gMjUyOyAvLyBzdHJpbmdfdGFnXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKGEpKSByZXR1cm4gMTI1MjsgLy8gb2NhbWwgc3RyaW5nIChpZiBkaWZmZXJlbnQgZnJvbSBieXRlcylcbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEFycmF5ICYmIGFbMF0gPT09IChhWzBdPj4+MCkgJiYgYVswXSA8PSAyNTUpIHtcbiAgICAvLyBMb29rIGxpa2UgYW4gb2NhbWwgYmxvY2tcbiAgICB2YXIgdGFnID0gYVswXSB8IDA7XG4gICAgLy8gaWdub3JlIGRvdWJsZV9hcnJheV90YWcgYmVjYXVzZSB3ZSBjYW5ub3QgYWNjdXJhdGVseSBzZXRcbiAgICAvLyB0aGlzIHRhZyB3aGVuIHdlIGNyZWF0ZSBhbiBhcnJheSBvZiBmbG9hdC5cbiAgICByZXR1cm4gKHRhZyA9PSAyNTQpPzA6dGFnXG4gIH1cbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIFN0cmluZykgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHJldHVybiAxMjUyMDsgLy8gamF2YXNjcmlwdCBzdHJpbmcsIGxpa2Ugc3RyaW5nX3RhZyAoMjUyKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgTnVtYmVyKSByZXR1cm4gMTAwMDsgLy8gaW50X3RhZyAod2UgdXNlIGl0IGZvciBhbGwgbnVtYmVycylcbiAgZWxzZSBpZiAoYSAmJiBhLmNhbWxfY3VzdG9tKSByZXR1cm4gMTI1NTsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKGEgJiYgYS5jb21wYXJlKSByZXR1cm4gMTI1NjsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIDEyNDc7IC8vIGxpa2UgY2xvc3VyZV90YWcgKDI0NylcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzeW1ib2xcIikgcmV0dXJuIDEyNTE7XG4gIHJldHVybiAxMDAxOyAvL291dF9vZl9oZWFwX3RhZ1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGEpe1xuICByZXR1cm4gY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1thLmNhbWxfY3VzdG9tXS5jb21wYXJlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKG51bSwgY3VzdG9tLCBzd2FwLCB0b3RhbCkge1xuICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShjdXN0b20pO1xuICBpZihjb21wKSB7XG4gICAgdmFyIHggPSAoc3dhcCA+IDApP2NvbXAoY3VzdG9tLG51bSx0b3RhbCk6Y29tcChudW0sY3VzdG9tLHRvdGFsKTtcbiAgICBpZih0b3RhbCAmJiB4ICE9IHgpIHJldHVybiBzd2FwOyAvLyB0b3RhbCAmJiBuYW5cbiAgICBpZigreCAhPSAreCkgcmV0dXJuICt4OyAvLyBuYW5cbiAgICBpZigoeCB8IDApICE9IDApIHJldHVybiAoeCB8IDApOyAvLyAhbmFuXG4gIH1cbiAgcmV0dXJuIHN3YXBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbCAoY29uc3QsIGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW50X2NvbXBhcmUsIGNhbWxfc3RyaW5nX2NvbXBhcmUsIGNhbWxfYnl0ZXNfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20sIGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRvdGFsKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICBmb3IoOzspIHtcbiAgICBpZiAoISh0b3RhbCAmJiBhID09PSBiKSkge1xuICAgICAgdmFyIHRhZ19hID0gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSk7XG4gICAgICAvLyBmb3J3YXJkX3RhZyA/XG4gICAgICBpZih0YWdfYSA9PSAyNTApIHsgYSA9IGFbMV07IGNvbnRpbnVlIH1cblxuICAgICAgdmFyIHRhZ19iID0gY2FtbF9jb21wYXJlX3ZhbF90YWcoYik7XG4gICAgICAvLyBmb3J3YXJkX3RhZyA/XG4gICAgICBpZih0YWdfYiA9PSAyNTApIHsgYiA9IGJbMV07IGNvbnRpbnVlIH1cblxuICAgICAgLy8gdGFncyBhcmUgZGlmZmVyZW50XG4gICAgICBpZih0YWdfYSAhPT0gdGFnX2IpIHtcbiAgICAgICAgaWYodGFnX2EgPT0gMTAwMCkge1xuICAgICAgICAgIGlmKHRhZ19iID09IDEyNTUpIHsgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYSwgYiwgLTEsIHRvdGFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYodGFnX2IgPT0gMTAwMCkge1xuICAgICAgICAgIGlmKHRhZ19hID09IDEyNTUpIHsgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYiwgYSwgMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGFnX2EgPCB0YWdfYik/LTE6MTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCh0YWdfYSl7XG4gICAgICAgIC8vIDI0NjogTGF6eV90YWcgaGFuZGxlZCBiZWxsb3dcbiAgICAgIGNhc2UgMjQ3OiAvLyBDbG9zdXJlX3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI0ODogLy8gT2JqZWN0XG4gICAgICAgIHZhciB4ID0gY2FtbF9pbnRfY29tcGFyZShhWzJdLCBiWzJdKTtcbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDk6IC8vIEluZml4XG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjUwOiAvLyBGb3J3YXJkIHRhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRm9yd2FyZF90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUxOiAvL0Fic3RyYWN0XG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MjogLy8gT0NhbWwgYnl0ZXNcbiAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICB2YXIgeCA9IGNhbWxfYnl0ZXNfY29tcGFyZShhLCBiKTtcbiAgICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MzogLy8gRG91YmxlX3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheV90YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlbiwgaGFuZGxlZCBhYm92ZVxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IERvdWJsZV9hcnJheV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTU6IC8vIEN1c3RvbV90YWdcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBDdXN0b21fdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNDc6IC8vIEZ1bmN0aW9uXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU1OiAvLyBDdXN0b21cbiAgICAgICAgdmFyIGNvbXAgPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSk7XG4gICAgICAgIGlmKGNvbXAgIT0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGIpKXtcbiAgICAgICAgICByZXR1cm4gKGEuY2FtbF9jdXN0b208Yi5jYW1sX2N1c3RvbSk/LTE6MTtcbiAgICAgICAgfVxuICAgICAgICBpZighY29tcClcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgdmFyIHggPSBjb21wKGEsYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIFVOT1JERVJFRFxuICAgICAgICAgIHJldHVybiB0b3RhbD8tMTp4O1xuICAgICAgICB9XG4gICAgICAgIGlmKHggIT09ICh4fDApKXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU2OiAvLyBjb21wYXJlIGZ1bmN0aW9uXG4gICAgICAgIHZhciB4ID0gYS5jb21wYXJlKGIsdG90YWwpO1xuICAgICAgICBpZih4ICE9IHgpIHsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwMDA6IC8vIE51bWJlclxuICAgICAgICBhID0gK2E7XG4gICAgICAgIGIgPSArYjtcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMTogLy8gVGhlIHJlc3RcbiAgICAgICAgLy8gSGVyZSB3ZSBjYW4gYmUgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgLy8gMS4gSmF2YVNjcmlwdCBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMi4gSmF2YVNjcmlwdCBvYmplY3QgdGhhdCBjYW4gYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMy4gSmF2YVNjcmlwdCBvYmplY3QgdGhhbiBjYW5ub3QgYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gKDMpIHdpbGwgcmFpc2UgYSBbVHlwZUVycm9yXVxuICAgICAgICAvLyAoMikgd2lsbCBjb2VyY2UgdG8gcHJpbWl0aXZlIHR5cGVzIHVzaW5nIFt2YWx1ZU9mXSBvciBbdG9TdHJpbmddXG4gICAgICAgIC8vICgyKSBhbmQgKDMpLCBhZnRlciBldmVudHVhbCBjb2VyY2lvblxuICAgICAgICAvLyAtIGlmIGEgYW5kIGIgYXJlIHN0cmluZ3MsIGFwcGx5IGxleGljb2dyYXBoaWMgY29tcGFyaXNvblxuICAgICAgICAvLyAtIGlmIGEgb3IgYiBhcmUgbm90IHN0cmluZ3MsIGNvbnZlcnQgYSBhbmQgYiB0byBudW1iZXJcbiAgICAgICAgLy8gICBhbmQgYXBwbHkgc3RhbmRhcmQgY29tcGFyaXNvblxuICAgICAgICAvL1xuICAgICAgICAvLyBFeGNlcHRpb246IGAhPWAgd2lsbCBub3QgY29lcmNlL2NvbnZlcnQgaWYgYm90aCBhIGFuZCBiIGFyZSBvYmplY3RzXG4gICAgICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICBpZiAoYSAhPSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICBpZiAoYSA9PSBhKSByZXR1cm4gMTtcbiAgICAgICAgICBpZiAoYiA9PSBiKSByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTE6IC8vIEphdmFTY3JpcHQgU3ltYm9sLCBubyBvcmRlcmluZy5cbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTI6IC8vIG9jYW1sIHN0cmluZ3NcbiAgICAgICAgdmFyIGEgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGEpO1xuICAgICAgICB2YXIgYiA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYik7XG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjA6IC8vIGphdmFzY3JpcHQgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGEudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGIgPSBiLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjQ2OiAvLyBMYXp5X3RhZ1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheVxuICAgICAgZGVmYXVsdDogLy8gQmxvY2sgd2l0aCBvdGhlciB0YWdcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gKGEubGVuZ3RoIDwgYi5sZW5ndGgpPy0xOjE7XG4gICAgICAgIGlmIChhLmxlbmd0aCA+IDEpIHN0YWNrLnB1c2goYSwgYiwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhY2subGVuZ3RoID09IDApIHJldHVybiAwO1xuICAgIHZhciBpID0gc3RhY2sucG9wKCk7XG4gICAgYiA9IHN0YWNrLnBvcCgpO1xuICAgIGEgPSBzdGFjay5wb3AoKTtcbiAgICBpZiAoaSArIDEgPCBhLmxlbmd0aCkgc3RhY2sucHVzaChhLCBiLCBpICsgMSk7XG4gICAgYSA9IGFbaV07XG4gICAgYiA9IGJbaV07XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9jb21wYXJlIChhLCBiKSB7IHJldHVybiBjYW1sX2NvbXBhcmVfdmFsIChhLCBiLCB0cnVlKTsgfVxuLy9Qcm92aWRlczogY2FtbF9pbnRfY29tcGFyZSBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2ludF9jb21wYXJlIChhLCBiKSB7XG4gIGlmIChhIDwgYikgcmV0dXJuICgtMSk7IGlmIChhID09IGIpIHJldHVybiAwOyByZXR1cm4gMTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9lcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ub3RlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgIT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JlYXRlcmVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcmVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVydGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJ0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3NlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3NlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPD0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc3RoYW4gbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9sZXNzdGhhbiAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPCAwKTsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgbGlicmFyeVxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEpzbGliOiBjb2RlIHNwZWNpZmljIHRvIEpzX29mX29jYW1sXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfb25faWUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfb25faWUgKCkge1xuICB2YXIgdWEgPVxuICAgICAgZ2xvYmFsVGhpcy5uYXZpZ2F0b3I/Z2xvYmFsVGhpcy5uYXZpZ2F0b3IudXNlckFnZW50OlwiXCI7XG4gIHJldHVybiB1YS5pbmRleE9mKFwiTVNJRVwiKSAhPSAtMSAmJiB1YS5pbmRleE9mKFwiT3BlcmFcIikgIT0gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19odG1sX2VzY2FwZSBjb25zdCAoY29uc3QpXG52YXIgY2FtbF9qc19yZWdleHBzID0geyBhbXA6LyYvZywgbHQ6LzwvZywgcXVvdDovXFxcIi9nLCBhbGw6L1smPFxcXCJdLyB9O1xuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VzY2FwZSAocykge1xuICBpZiAoIWNhbWxfanNfcmVnZXhwcy5hbGwudGVzdChzKSkgcmV0dXJuIHM7XG4gIHJldHVybiBzLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmFtcCwgXCImYW1wO1wiKVxuICAgIC5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5sdCwgXCImbHQ7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLnF1b3QsIFwiJnF1b3Q7XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZW50aXRpZXNcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfanNfaHRtbF9lbnRpdGllcyhzKSB7XG4gIHZhciBlbnRpdHkgPSAvXiYjP1swLTlhLXpBLVpdKzskL1xuICBpZihzLm1hdGNoKGVudGl0eSkpXG4gIHtcbiAgICB2YXIgc3RyLCB0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgIHRlbXAuaW5uZXJIVE1MPSBzO1xuICAgIHN0cj0gdGVtcC50ZXh0Q29udGVudCB8fCB0ZW1wLmlubmVyVGV4dDtcbiAgICB0ZW1wPW51bGw7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiSW52YWxpZCBlbnRpdHkgXCIgKyBzKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2dldF9jb25zb2xlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX2dldF9jb25zb2xlICgpIHtcbiAgdmFyIGMgPSBnbG9iYWxUaGlzLmNvbnNvbGU/Z2xvYmFsVGhpcy5jb25zb2xlOnt9O1xuICB2YXIgbSA9IFtcImxvZ1wiLCBcImRlYnVnXCIsIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiLCBcImFzc2VydFwiLCBcImRpclwiLCBcImRpcnhtbFwiLFxuICAgICAgICAgICBcInRyYWNlXCIsIFwiZ3JvdXBcIiwgXCJncm91cENvbGxhcHNlZFwiLCBcImdyb3VwRW5kXCIsIFwidGltZVwiLCBcInRpbWVFbmRcIl07XG4gIGZ1bmN0aW9uIGYgKCkge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSBpZiAoIWNbbVtpXV0pIGNbbVtpXV09ZjtcbiAgcmV0dXJuIGM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1dlYWtkZWZcbmZ1bmN0aW9uIGNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlKHVuaXQpe1xuICB2YXIgZyA9IGdsb2JhbFRoaXM7XG4gIGlmKHR5cGVvZiBnLlhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7IHJldHVybiBuZXcgZy5YTUxIdHRwUmVxdWVzdCB9IGNhdGNoIChlKSB7IH07XG4gIH1cbiAgaWYodHlwZW9mIGcuYWN0aXZlWE9iamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGcuYWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLmFjdGl2ZVhPYmplY3QoXCJNc3htbDMuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICAgIHRyeSB7IHJldHVybiBuZXcgZy5hY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgfVxuICBjYW1sX2ZhaWx3aXRoKFwiQ2Fubm90IGNyZWF0ZSBhIFhNTEh0dHBSZXF1ZXN0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24oZXhuKSB7XG4gIGlmKGV4bi5qc19lcnJvcikgeyByZXR1cm4gZXhuLmpzX2Vycm9yOyB9XG4gIHJldHVybiBudWxsO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF91cGRhdGVfZHVtbXlcbmZ1bmN0aW9uIGNhbWxfdXBkYXRlX2R1bW15ICh4LCB5KSB7XG4gIGlmKCB0eXBlb2YgeT09PVwiZnVuY3Rpb25cIiApIHsgeC5mdW4gPSB5OyByZXR1cm4gMDsgfVxuICBpZiggeS5mdW4gKSB7IHguZnVuID0geS5mdW47IHJldHVybiAwOyB9XG4gIHZhciBpID0geS5sZW5ndGg7IHdoaWxlIChpLS0pIHhbaV0gPSB5W2ldOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfaXNfYmxvY2sgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfaXNfYmxvY2sgKHgpIHsgcmV0dXJuICsoeCBpbnN0YW5jZW9mIEFycmF5KTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9pc19tbF9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfb2JqX3RhZyAoeCkge1xuICBpZiAoKHggaW5zdGFuY2VvZiBBcnJheSkgJiYgeFswXSA9PSAoeFswXSA+Pj4gMCkpXG4gICAgcmV0dXJuIHhbMF1cbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh4KSlcbiAgICByZXR1cm4gMjUyXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHgpKVxuICAgIHJldHVybiAyNTJcbiAgZWxzZSBpZiAoKHggaW5zdGFuY2VvZiBGdW5jdGlvbikgfHwgdHlwZW9mIHggPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiAyNDdcbiAgZWxzZSBpZiAoeCAmJiB4LmNhbWxfY3VzdG9tKVxuICAgIHJldHVybiAyNTVcbiAgZWxzZVxuICAgIHJldHVybiAxMDAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3NldF90YWcgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfc2V0X3RhZyAoeCwgdGFnKSB7IHhbMF0gPSB0YWc7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX29ial9ibG9jayBjb25zdCAoY29uc3QsY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9ibG9jayAodGFnLCBzaXplKSB7XG4gIHZhciBvID0gbmV3IEFycmF5KHNpemUrMSk7XG4gIG9bMF09dGFnO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSBzaXplOyBpKyspIG9baV0gPSAwO1xuICByZXR1cm4gbztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfd2l0aF90YWdcbmZ1bmN0aW9uIGNhbWxfb2JqX3dpdGhfdGFnKHRhZyx4KSB7XG4gIHZhciBsID0geC5sZW5ndGg7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gdGFnO1xuICBmb3IodmFyIGkgPSAxOyBpIDwgbDsgaSsrICkgYVtpXSA9IHhbaV07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9kdXAgbXV0YWJsZSAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9kdXAgKHgpIHtcbiAgdmFyIGwgPSB4Lmxlbmd0aDtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKysgKSBhW2ldID0geFtpXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RydW5jYXRlIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9vYmpfdHJ1bmNhdGUgKHgsIHMpIHtcbiAgaWYgKHM8PTAgfHwgcyArIDEgPiB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiT2JqLnRydW5jYXRlXCIpO1xuICBpZiAoeC5sZW5ndGggIT0gcyArIDEpIHgubGVuZ3RoID0gcyArIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9tYWtlX2ZvcndhcmRcbmZ1bmN0aW9uIGNhbWxfb2JqX21ha2VfZm9yd2FyZCAoYix2KSB7XG4gIGJbMF09MjUwO1xuICBiWzFdPXY7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9sYXp5X21ha2VfZm9yd2FyZCAodikgeyByZXR1cm4gWzI1MCwgdl07IH1cblxuLy8vLy8vLy8vLy8vLyBDYW1saW50ZXJuYWxPT1xuLy9Qcm92aWRlczogY2FtbF9nZXRfcHVibGljX21ldGhvZCBjb25zdFxudmFyIGNhbWxfbWV0aG9kX2NhY2hlID0gW107XG5mdW5jdGlvbiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIChvYmosIHRhZywgY2FjaGVpZCkge1xuICB2YXIgbWV0aHMgPSBvYmpbMV07XG4gIHZhciBvZnMgPSBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXTtcbiAgaWYgKG9mcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhcnJheSBpcyBub3Qgc3BhcnNlXG4gICAgZm9yICh2YXIgaSA9IGNhbWxfbWV0aG9kX2NhY2hlLmxlbmd0aDsgaSA8IGNhY2hlaWQ7IGkrKylcbiAgICAgIGNhbWxfbWV0aG9kX2NhY2hlW2ldID0gMDtcbiAgfSBlbHNlIGlmIChtZXRoc1tvZnNdID09PSB0YWcpIHtcbiAgICByZXR1cm4gbWV0aHNbb2ZzIC0gMV07XG4gIH1cbiAgdmFyIGxpID0gMywgaGkgPSBtZXRoc1sxXSAqIDIgKyAxLCBtaTtcbiAgd2hpbGUgKGxpIDwgaGkpIHtcbiAgICBtaSA9ICgobGkraGkpID4+IDEpIHwgMTtcbiAgICBpZiAodGFnIDwgbWV0aHNbbWkrMV0pIGhpID0gbWktMjtcbiAgICBlbHNlIGxpID0gbWk7XG4gIH1cbiAgY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF0gPSBsaSArIDE7XG4gIC8qIHJldHVybiAwIGlmIHRhZyBpcyBub3QgdGhlcmUgKi9cbiAgcmV0dXJuICh0YWcgPT0gbWV0aHNbbGkrMV0gPyBtZXRoc1tsaV0gOiAwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vb19sYXN0X2lkXG52YXIgY2FtbF9vb19sYXN0X2lkID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9zZXRfb29faWRcbi8vUmVxdWlyZXM6IGNhbWxfb29fbGFzdF9pZFxuZnVuY3Rpb24gY2FtbF9zZXRfb29faWQgKGIpIHtcbiAgYlsyXT1jYW1sX29vX2xhc3RfaWQrKztcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZnJlc2hfb29faWQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfb29fbGFzdF9pZFxuZnVuY3Rpb24gY2FtbF9mcmVzaF9vb19pZCgpIHtcbiAgcmV0dXJuIGNhbWxfb29fbGFzdF9pZCsrO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9yYXdfZmllbGRcbmZ1bmN0aW9uIGNhbWxfb2JqX3Jhd19maWVsZChvLGkpIHsgcmV0dXJuIG9baSsxXSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3NldF9yYXdfZmllbGRcbmZ1bmN0aW9uIGNhbWxfb2JqX3NldF9yYXdfZmllbGQobyxpLHYpIHsgcmV0dXJuIG9baSsxXSA9IHYgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9yZWFjaGFibGVfd29yZHNcbmZ1bmN0aW9uIGNhbWxfb2JqX3JlYWNoYWJsZV93b3JkcyhvKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2FkZF9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfb2JqX2FkZF9vZmZzZXQodixvZmZzZXQpIHtcbiAgY2FtbF9mYWlsd2l0aChcIk9iai5hZGRfb2Zmc2V0IGlzIG5vdCBzdXBwb3J0ZWRcIik7XG59XG4iLCIvLy8vLy8vLy8gQklHU1RSSU5HXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9iaWdzdHJpbmcoaCwgYnMpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsYnMuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlcihicykge1xuICByZXR1cm4gYnMuZGF0YS5idWZmZXJcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b190eXBlZF9hcnJheShicykge1xuICByZXR1cm4gYnMuZGF0YVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlcihhYikge1xuICB2YXIgdGEgPSBuZXcgZ2xvYmFsVGhpcy5VaW50OEFycmF5KGFiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5KGJhKSB7XG4gIHZhciB0YSA9IG5ldyBnbG9iYWxUaGlzLlVpbnQ4QXJyYXkoYmEuYnVmZmVyLCBiYS5ieXRlT2Zmc2V0LCBiYS5sZW5ndGggKiBiYS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX21lbWNtcFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfbWVtY21wKHMxLCBwb3MxLCBzMiwgcG9zMiwgbGVuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBhID0gY2FtbF9iYV9nZXRfMShzMSxwb3MxICsgaSk7XG4gICAgdmFyIGIgPSBjYW1sX2JhX2dldF8xKHMyLHBvczIgKyBpKTtcbiAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEoYmExLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMS5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKG9mczEgKyBsZW4gPiBiYTEuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gYmExLmRhdGEuc3ViYXJyYXkob2ZzMSxvZnMxK2xlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxwb3MyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEoc3RyMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKHBvczEgKyBsZW4gPiBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyMSkpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBjYW1sX2FycmF5X29mX3N0cmluZyhzdHIxKS5zbGljZShwb3MxLHBvczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2Usb2ZzMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9hcnJheV9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEoc3RyMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKHBvczEgKyBsZW4gPiBjYW1sX21sX2J5dGVzX2xlbmd0aChzdHIxKSkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMoc3RyMSkuc2xpY2UocG9zMSxwb3MxICsgbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLG9mczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMoYmExLCBwb3MxLCBieXRlczIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMS5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMxID0gYmExLm9mZnNldChwb3MxKTtcbiAgaWYob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKHBvczIgKyBsZW4gPiBjYW1sX21sX2J5dGVzX2xlbmd0aChieXRlczIpKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gYmExLmRhdGEuc2xpY2Uob2ZzMSwgb2ZzMStsZW4pO1xuICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9hcnJheShzbGljZSksIDAsIGJ5dGVzMiwgcG9zMiwgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9iYWNrdHJhY2Vfc3RhdHVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmVjb3JkX2JhY2t0cmFjZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3QgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZV9zbG90OiBpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlKGV4biwgYnQpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2sgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrICgpIHsgcmV0dXJuIFswXTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90KCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XCIpO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IGxleGluZy5jIDYwNDUgMjAwNC0wMS0wMSAxNjo0Mjo0M1ogZG9saWdleiAkICovXG5cbi8qIFRoZSB0YWJsZS1kcml2ZW4gYXV0b21hdG9uIGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXguICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2xleF9hcnJheShzKSB7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpO1xuICB2YXIgbCA9IHMubGVuZ3RoIC8gMjtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgIGFbaV0gPSAocy5jaGFyQ29kZUF0KDIgKiBpKSB8IChzLmNoYXJDb2RlQXQoMiAqIGkgKyAxKSA8PCA4KSkgPDwgMTYgPj4gMTY7XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5LCBjYW1sX2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuXG4gIGlmICghdGJsLmxleF9kZWZhdWx0KSB7XG4gICAgdGJsLmxleF9iYXNlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF0pO1xuICB9XG5cbiAgdmFyIGMsIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMobGV4YnVmW2xleF9idWZmZXJdKTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvcig7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHJldHVybiAtYmFzZS0xO1xuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogTmV3IGxleGVyIGVuZ2luZSwgd2l0aCBtZW1vcnkgb2YgcG9zaXRpb25zICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9sZXhfcnVuX21lbShzLCBpLCBtZW0sIGN1cnJfcG9zKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm47XG4gICAgdmFyIHNyYyA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChzcmMgPT0gMHhmZilcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBjdXJyX3BvcztcbiAgICBlbHNlXG4gICAgICBtZW0gW2RzdCArIDFdID0gbWVtIFtzcmMgKyAxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fdGFnKHMsIGksIG1lbSkge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChkc3QgPT0gMHhmZikgcmV0dXJuIDtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IC0xO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbmV3X2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9tZW0gPSAxMDtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuICB2YXIgbGV4X2Jhc2VfY29kZSA9IDY7XG4gIHZhciBsZXhfYmFja3Rya19jb2RlID0gNztcbiAgdmFyIGxleF9kZWZhdWx0X2NvZGUgPSA4O1xuICB2YXIgbGV4X3RyYW5zX2NvZGUgPSA5O1xuICB2YXIgbGV4X2NoZWNrX2NvZGUgPSAxMDtcbiAgdmFyIGxleF9jb2RlID0gMTE7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHRfY29kZSkge1xuICAgIHRibC5sZXhfYmFzZV9jb2RlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV9jb2RlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrX2NvZGUgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrX2NvZGVdKTtcbiAgICB0YmwubGV4X2NoZWNrX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrX2NvZGVdKTtcbiAgICB0YmwubGV4X3RyYW5zX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zX2NvZGVdKTtcbiAgICB0YmwubGV4X2RlZmF1bHRfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRfY29kZV0pO1xuICB9XG4gIGlmICh0YmwubGV4X2NvZGUgPT0gbnVsbCkgdGJsLmxleF9jb2RlID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh0YmxbbGV4X2NvZGVdKTtcblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF9hcnJheV9vZl9ieXRlcyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFzZV9jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICByZXR1cm4gLWJhc2UtMTtcbiAgICB9XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFja3Rya19jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIHZhciBwc3RhdGUgPSBzdGF0ZSA7XG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBJZiBzb21lIHRyYW5zaXRpb24sIGdldCBhbmQgcGVyZm9ybSBtZW1vcnkgbW92ZXMgKi9cbiAgICAgIHZhciBiYXNlX2NvZGUgPSB0YmwubGV4X2Jhc2VfY29kZVtwc3RhdGVdLCBwY19vZmY7XG4gICAgICBpZiAodGJsLmxleF9jaGVja19jb2RlW2Jhc2VfY29kZSArIGNdID09IHBzdGF0ZSlcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF90cmFuc19jb2RlW2Jhc2VfY29kZSArIGNdO1xuICAgICAgZWxzZVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X2RlZmF1bHRfY29kZVtwc3RhdGVdO1xuICAgICAgaWYgKHBjX29mZiA+IDApXG4gICAgICAgIGNhbWxfbGV4X3J1bl9tZW1cbiAgICAgICh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dLCBsZXhidWZbbGV4X2N1cnJfcG9zXSk7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gQXJyYXlcblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9zdWIgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9zdWIgKGEsIGksIGxlbikge1xuICB2YXIgYTIgPSBuZXcgQXJyYXkobGVuKzEpO1xuICBhMlswXT0wO1xuICBmb3IodmFyIGkyID0gMSwgaTE9IGkrMTsgaTIgPD0gbGVuOyBpMisrLGkxKysgKXtcbiAgICBhMltpMl09YVtpMV07XG4gIH1cbiAgcmV0dXJuIGEyO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2FwcGVuZCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2FwcGVuZChhMSwgYTIpIHtcbiAgdmFyIGwxID0gYTEubGVuZ3RoLCBsMiA9IGEyLmxlbmd0aDtcbiAgdmFyIGwgPSBsMStsMi0xXG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gMDtcbiAgdmFyIGkgPSAxLGogPSAxO1xuICBmb3IoO2k8bDE7aSsrKSBhW2ldPWExW2ldO1xuICBmb3IoO2k8bDtpKyssaisrKSBhW2ldPWEyW2pdO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9jb25jYXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9jb25jYXQobCkge1xuICB2YXIgYSA9IFswXTtcbiAgd2hpbGUgKGwgIT09IDApIHtcbiAgICB2YXIgYiA9IGxbMV07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiLmxlbmd0aDsgaSsrKSBhLnB1c2goYltpXSk7XG4gICAgbCA9IGxbMl07XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYmxpdFxuZnVuY3Rpb24gY2FtbF9hcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgaWYgKGkyIDw9IGkxKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbGVuOyBqKyspIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMTsgai0tKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRhcnJheV9ibGl0XG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKSB7XG4gIGlmIChpMiA8PSBpMSkge1xuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IGxlbjsgaisrKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBqID0gbGVuOyBqID49IDE7IGotLSkgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH07XG4gIHJldHVybiAwO1xufVxuXG4vLy8vLy8vLy8vLy8vIFBlcnZhc2l2ZVxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9zZXQgKG11dGFibGUsIGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfc2V0IChhcnJheSwgaW5kZXgsIG5ld3ZhbCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGFycmF5W2luZGV4KzFdPW5ld3ZhbDsgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfZ2V0IG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfZ2V0IChhcnJheSwgaW5kZXgpIHtcbiAgaWYgKChpbmRleCA8IDApIHx8IChpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXlbaW5kZXgrMV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfZmlsbFxuZnVuY3Rpb24gY2FtbF9hcnJheV9maWxsKGFycmF5LCBvZnMsIGxlbiwgdil7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgYXJyYXlbb2ZzK2krMV0gPSB2O1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NoZWNrX2JvdW5kIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2NoZWNrX2JvdW5kIChhcnJheSwgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID4+PiAwID49IGFycmF5Lmxlbmd0aCAtIDEpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfdmVjdCBjb25zdCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9tYWtlX3ZlY3QgKGxlbiwgaW5pdCkge1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IGluaXQ7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfZmxvYXRfdmVjdCBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21ha2VfZmxvYXRfdmVjdChsZW4pe1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MjU0O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gMDtcbiAgcmV0dXJuIGJcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRhcnJheV9jcmVhdGUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9mbG9hdGFycmF5X2NyZWF0ZShsZW4pe1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MjU0O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gMDtcbiAgcmV0dXJuIGJcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBXZWFrIEFQSSwgYnV0IHdpdGhvdXQgdGhlIHdlYWsgc2VtYW50aWNzXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG52YXIgY2FtbF9lcGhlX2tleV9vZmZzZXQgPSAzXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxudmFyIGNhbWxfZXBoZV9kYXRhX29mZnNldCA9IDJcblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2NyZWF0ZSAobikge1xuICBpZiAobiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmNyZWF0ZVwiKTtcbiAgdmFyIHggPSBbMjUxLFwiY2FtbF9lcGhlX2xpc3RfaGVhZFwiXTtcbiAgeC5sZW5ndGggPSBjYW1sX2VwaGVfa2V5X29mZnNldCArIG47XG4gIHJldHVybiB4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfc2V0KHgsIGksIHYpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLnNldFwiKTtcbiAgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldID0gdjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfZ2V0KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmdldF9rZXlcIik7XG4gIHJldHVybiAoeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgXT09PXVuZGVmaW5lZCk/MDp4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfZ2V0X2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19nZXQsY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfZ2V0X2NvcHkoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuZ2V0X2NvcHlcIik7XG4gIHZhciB5ID0gY2FtbF93ZWFrX2dldCh4LCBpKTtcbiAgaWYgKHkgPT09IDApIHJldHVybiB5O1xuICB2YXIgeiA9IHlbMV07XG4gIGlmICh6IGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBbMCwgY2FtbF9vYmpfZHVwKHopXTtcbiAgcmV0dXJuIHk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19jaGVjayBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuZnVuY3Rpb24gY2FtbF93ZWFrX2NoZWNrKHgsIGkpIHtcbiAgaWYoeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldIT09dW5kZWZpbmVkICYmIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSAhPT0wKVxuICAgIHJldHVybiAxO1xuICBlbHNlXG4gICAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX3dlYWtfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKSB7XG4gIC8vIG1pbnVzIG9uZSBiZWNhdXNlIGNhbWxfYXJyYXlfYmxpdCB3b3JrcyBvbiBvY2FtbCBhcnJheVxuICBjYW1sX2FycmF5X2JsaXQoYTEsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaTEgLSAxLFxuICAgICAgICAgICAgICAgICAgYTIsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaTIgLSAxLFxuICAgICAgICAgICAgICAgICAgbGVuKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19jcmVhdGVcbnZhciBjYW1sX2VwaGVfY3JlYXRlID0gY2FtbF93ZWFrX2NyZWF0ZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19ibGl0XG52YXIgY2FtbF9lcGhlX2JsaXRfa2V5ID0gY2FtbF93ZWFrX2JsaXRcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19nZXRcbnZhciBjYW1sX2VwaGVfZ2V0X2tleSA9IGNhbWxfd2Vha19nZXRcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlfY29weVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldF9jb3B5XG52YXIgY2FtbF9lcGhlX2dldF9rZXlfY29weSA9IGNhbWxfd2Vha19nZXRfY29weVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfY2hlY2tcbnZhciBjYW1sX2VwaGVfY2hlY2tfa2V5ID0gY2FtbF93ZWFrX2NoZWNrXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfc2V0X2tleSh4LCBpLCB2KSB7XG4gIHJldHVybiBjYW1sX3dlYWtfc2V0KHgsIGksIFswLCB2XSlcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3Vuc2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX3NldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3Vuc2V0X2tleSh4LCBpKSB7XG4gIHJldHVybiBjYW1sX3dlYWtfc2V0KHgsIGksIDApXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9ibGl0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX2JsaXRfZGF0YShzcmMsIGRzdCl7XG4gIGRzdFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gc3JjW2NhbWxfZXBoZV9kYXRhX29mZnNldF07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhKHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiBbMCwgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwXG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2RhdGFfY29weSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0pXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfZGF0YSh4LCBkYXRhKXtcbiAgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gZGF0YTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV91bnNldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9kYXRhKHgsIGRhdGEpe1xuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSB1bmRlZmluZWQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfY2hlY2tfZGF0YSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gMTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X2NoYW5cbi8vUmVxdWlyZXM6IGNhbWxfbWQ1X3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfYXJyYXksY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX21kNV9jaGFuKGNoYW5pZCxsZW4pe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGNoYW5fbGVuID0gY2hhbi5maWxlLmxlbmd0aCgpO1xuICBpZihsZW48MCkgbGVuID0gY2hhbl9sZW4gLSBjaGFuLm9mZnNldDtcbiAgaWYoY2hhbi5vZmZzZXQgKyBsZW4gPiBjaGFuX2xlbikgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB2YXIgYnVmID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsYnVmLDAsbGVuKTtcbiAgcmV0dXJuIGNhbWxfbWQ1X3N0cmluZyhjYW1sX3N0cmluZ19vZl9ieXRlcyhidWYpLDAsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX3N0cmluZywgY2FtbF9tZDVfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWQ1X3N0cmluZyhzLCBvZnMsIGxlbikge1xuICByZXR1cm4gY2FtbF9tZDVfYnl0ZXMoY2FtbF9ieXRlc19vZl9zdHJpbmcocyksb2ZzLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheSwgY2FtbF9tbF9ieXRlc19jb250ZW50XG52YXIgY2FtbF9tZDVfYnl0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGFkZCAoeCwgeSkgeyByZXR1cm4gKHggKyB5KSB8IDA7IH1cbiAgZnVuY3Rpb24geHgocSxhLGIseCxzLHQpIHtcbiAgICBhID0gYWRkKGFkZChhLCBxKSwgYWRkKHgsIHQpKTtcbiAgICByZXR1cm4gYWRkKChhIDw8IHMpIHwgKGEgPj4+ICgzMiAtIHMpKSwgYik7XG4gIH1cbiAgZnVuY3Rpb24gZmYoYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2coYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gaGgoYSxiLGMsZCx4LHMsdCkgeyByZXR1cm4geHgoYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTsgfVxuICBmdW5jdGlvbiBpaShhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7IH1cblxuICBmdW5jdGlvbiBtZDUoYnVmZmVyLCBsZW5ndGgpIHtcbiAgICB2YXIgaSA9IGxlbmd0aDtcbiAgICBidWZmZXJbaSA+PiAyXSB8PSAweDgwIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgZm9yIChpID0gKGkgJiB+MHgzKSArIDg7KGkgJiAweDNGKSA8IDYwIDtpICs9IDQpXG4gICAgICBidWZmZXJbKGkgPj4gMikgLSAxXSA9IDA7XG4gICAgYnVmZmVyWyhpID4+IDIpIC0xXSA9IGxlbmd0aCA8PCAzO1xuICAgIGJ1ZmZlcltpID4+IDJdID0gKGxlbmd0aCA+PiAyOSkgJiAweDFGRkZGRkZGO1xuXG4gICAgdmFyIHcgPSBbMHg2NzQ1MjMwMSwgMHhFRkNEQUI4OSwgMHg5OEJBRENGRSwgMHgxMDMyNTQ3Nl07XG5cbiAgICBmb3IoaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICB2YXIgYSA9IHdbMF0sIGIgPSB3WzFdLCBjID0gd1syXSwgZCA9IHdbM107XG5cbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgMF0sIDcsIDB4RDc2QUE0NzgpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAxXSwgMTIsIDB4RThDN0I3NTYpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyAyXSwgMTcsIDB4MjQyMDcwREIpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAzXSwgMjIsIDB4QzFCRENFRUUpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA0XSwgNywgMHhGNTdDMEZBRik7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDVdLCAxMiwgMHg0Nzg3QzYyQSk7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krIDZdLCAxNywgMHhBODMwNDYxMyk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krIDddLCAyMiwgMHhGRDQ2OTUwMSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDhdLCA3LCAweDY5ODA5OEQ4KTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgOV0sIDEyLCAweDhCNDRGN0FGKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsxMF0sIDE3LCAweEZGRkY1QkIxKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsxMV0sIDIyLCAweDg5NUNEN0JFKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsxMl0sIDcsIDB4NkI5MDExMjIpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEzXSwgMTIsIDB4RkQ5ODcxOTMpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE0XSwgMTcsIDB4QTY3OTQzOEUpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzE1XSwgMjIsIDB4NDlCNDA4MjEpO1xuXG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDFdLCA1LCAweEY2MUUyNTYyKTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsgNl0sIDksIDB4QzA0MEIzNDApO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzExXSwgMTQsIDB4MjY1RTVBNTEpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAwXSwgMjAsIDB4RTlCNkM3QUEpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA1XSwgNSwgMHhENjJGMTA1RCk7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krMTBdLCA5LCAweDAyNDQxNDUzKTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsxNV0sIDE0LCAweEQ4QTFFNjgxKTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgNF0sIDIwLCAweEU3RDNGQkM4KTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgOV0sIDUsIDB4MjFFMUNERTYpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzE0XSwgOSwgMHhDMzM3MDdENik7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krIDNdLCAxNCwgMHhGNEQ1MEQ4Nyk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDhdLCAyMCwgMHg0NTVBMTRFRCk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krMTNdLCA1LCAweEE5RTNFOTA1KTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsgMl0sIDksIDB4RkNFRkEzRjgpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA3XSwgMTQsIDB4Njc2RjAyRDkpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEyXSwgMjAsIDB4OEQyQTRDOEEpO1xuXG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krIDVdLCA0LCAweEZGRkEzOTQyKTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgOF0sIDExLCAweDg3NzFGNjgxKTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsxMV0sIDE2LCAweDZEOUQ2MTIyKTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsxNF0sIDIzLCAweEZERTUzODBDKTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgMV0sIDQsIDB4QTRCRUVBNDQpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA0XSwgMTEsIDB4NEJERUNGQTkpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA3XSwgMTYsIDB4RjZCQjRCNjApO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEwXSwgMjMsIDB4QkVCRkJDNzApO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEzXSwgNCwgMHgyODlCN0VDNik7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDBdLCAxMSwgMHhFQUExMjdGQSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krIDNdLCAxNiwgMHhENEVGMzA4NSk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krIDZdLCAyMywgMHgwNDg4MUQwNSk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krIDldLCA0LCAweEQ5RDREMDM5KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsxMl0sIDExLCAweEU2REI5OUU1KTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsxNV0sIDE2LCAweDFGQTI3Q0Y4KTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsgMl0sIDIzLCAweEM0QUM1NjY1KTtcblxuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAwXSwgNiwgMHhGNDI5MjI0NCk7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krIDddLCAxMCwgMHg0MzJBRkY5Nyk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krMTRdLCAxNSwgMHhBQjk0MjNBNyk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krIDVdLCAyMSwgMHhGQzkzQTAzOSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krMTJdLCA2LCAweDY1NUI1OUMzKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsgM10sIDEwLCAweDhGMENDQzkyKTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsxMF0sIDE1LCAweEZGRUZGNDdEKTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgMV0sIDIxLCAweDg1ODQ1REQxKTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsgOF0sIDYsIDB4NkZBODdFNEYpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzE1XSwgMTAsIDB4RkUyQ0U2RTApO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA2XSwgMTUsIDB4QTMwMTQzMTQpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEzXSwgMjEsIDB4NEUwODExQTEpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA0XSwgNiwgMHhGNzUzN0U4Mik7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krMTFdLCAxMCwgMHhCRDNBRjIzNSk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krIDJdLCAxNSwgMHgyQUQ3RDJCQik7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krIDldLCAyMSwgMHhFQjg2RDM5MSk7XG5cbiAgICAgIHdbMF0gPSBhZGQoYSwgd1swXSk7XG4gICAgICB3WzFdID0gYWRkKGIsIHdbMV0pO1xuICAgICAgd1syXSA9IGFkZChjLCB3WzJdKTtcbiAgICAgIHdbM10gPSBhZGQoZCwgd1szXSk7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoMTYpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAgICAgIHRbaSAqIDQgKyBqXSA9ICh3W2ldID4+ICg4ICogaikpICYgMHhGRjtcbiAgICByZXR1cm4gdDtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAocywgb2ZzLCBsZW4pIHtcbiAgICAvLyBGSVg6IG1heWJlIHdlIHNob3VsZCBwZXJmb3JtIHRoZSBjb21wdXRhdGlvbiBieSBjaHVuayBvZiA2NCBieXRlc1xuICAgIC8vIGFzIGluIGh0dHA6Ly93d3cubXllcnNkYWlseS5vcmcvam9zZXBoL2phdmFzY3JpcHQvbWQ1LmpzXG4gICAgdmFyIGJ1ZiA9IFtdO1xuICAgIHZhciBjb250ZW50ID0gY2FtbF9tbF9ieXRlc19jb250ZW50KHMpO1xuICAgIGlmKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKXtcbiAgICAgIHZhciBiID0gY29udGVudDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICAgIHZhciBqID0gaSArIG9mcztcbiAgICAgICAgYnVmW2k+PjJdID1cbiAgICAgICAgICBiLmNoYXJDb2RlQXQoaikgfCAoYi5jaGFyQ29kZUF0KGorMSkgPDwgOCkgfFxuICAgICAgICAgIChiLmNoYXJDb2RlQXQoaisyKSA8PCAxNikgfCAoYi5jaGFyQ29kZUF0KGorMykgPDwgMjQpO1xuICAgICAgfVxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYnVmW2k+PjJdIHw9IGIuY2hhckNvZGVBdChpICsgb2ZzKSA8PCAoOCAqIChpICYgMykpO1xuICAgIH0gZWxzZSB7IC8qIEFSUkFZICovXG4gICAgICB2YXIgYSA9IGNvbnRlbnQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgICB2YXIgaiA9IGkgKyBvZnM7XG4gICAgICAgIGJ1ZltpPj4yXSA9IGFbal0gfCAoYVtqKzFdIDw8IDgpIHwgKGFbaisyXSA8PCAxNikgfCAoYVtqKzNdIDw8IDI0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIGJ1ZltpPj4yXSB8PSBhW2kgKyBvZnNdIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgfVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheShtZDUoYnVmLCBsZW4pKTtcbiAgfVxufSAoKTtcbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAyMCAtIEh1Z28gSGV1emFyZFxuLy8gQ29weXJpZ2h0IChDKSAyMDIwIC0gU2hhY2hhciBJdHpoYWt5XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vb2NhbWwvb2NhbWwvYmxvYi80LjA3L290aGVybGlicy9zdHIvc3Ryc3R1YnMuY1xuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pzY29xL2pzY29xL2Jsb2IvdjguMTEvY29xLWpzL2pzX3N0dWIvc3RyLmpzXG5cbi8vUHJvdmlkZXM6IHJlX21hdGNoXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19nZXRcblxudmFyIHJlX21hdGNoID0gZnVuY3Rpb24oKXtcbiAgdmFyIHJlX3dvcmRfbGV0dGVycyA9IFtcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweDAwLTB4MUY6IG5vbmUgKi9cbiAgICAweDAwLCAweDAwLCAweEZGLCAweDAzLCAgICAgICAvKiAweDIwLTB4M0Y6IGRpZ2l0cyAwLTkgKi9cbiAgICAweEZFLCAweEZGLCAweEZGLCAweDg3LCAgICAgICAvKiAweDQwLTB4NUY6IEEgdG8gWiwgXyAqL1xuICAgIDB4RkUsIDB4RkYsIDB4RkYsIDB4MDcsICAgICAgIC8qIDB4NjAtMHg3RjogYSB0byB6ICovXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHg4MC0weDlGOiBub25lICovXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHhBMC0weEJGOiBub25lICovXG4gICAgMHhGRiwgMHhGRiwgMHg3RiwgMHhGRiwgICAgICAgLyogMHhDMC0weERGOiBMYXRpbi0xIGFjY2VudGVkIHVwcGVyY2FzZSAqL1xuICAgIDB4RkYsIDB4RkYsIDB4N0YsIDB4RkYgICAgICAgIC8qIDB4RTAtMHhGRjogTGF0aW4tMSBhY2NlbnRlZCBsb3dlcmNhc2UgKi9cbiAgXTtcblxuICB2YXIgb3Bjb2RlcyA9IHtcbiAgICBDSEFSOiAwLCBDSEFSTk9STTogMSwgU1RSSU5HOiAyLCBTVFJJTkdOT1JNOiAzLCBDSEFSQ0xBU1M6IDQsXG4gICAgQk9MOiA1LCBFT0w6IDYsIFdPUkRCT1VOREFSWTogNyxcbiAgICBCRUdHUk9VUDogOCwgRU5ER1JPVVA6IDksIFJFRkdST1VQOiAxMCxcbiAgICBBQ0NFUFQ6IDExLFxuICAgIFNJTVBMRU9QVDogMTIsIFNJTVBMRVNUQVI6IDEzLCBTSU1QTEVQTFVTOiAxNCxcbiAgICBHT1RPOiAxNSwgUFVTSEJBQ0s6IDE2LCBTRVRNQVJLOiAxNyxcbiAgICBDSEVDS1BST0dSRVNTOiAxOFxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzX3dvcmRfbGV0dGVyKGMpIHtcbiAgICByZXR1cm4gKHJlX3dvcmRfbGV0dGVyc1sgIChjID4+IDMpXSA+PiAoYyAmIDcpKSAmIDE7XG4gIH1cblxuICBmdW5jdGlvbiBpbl9iaXRzZXQocyxpKSB7XG4gICAgcmV0dXJuIChjYW1sX3N0cmluZ19nZXQocywoaSA+PiAzKSkgPj4gKGkgJiA3KSkgJiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVfbWF0Y2hfaW1wbChyZSwgcywgcG9zLCBwYXJ0aWFsKSB7XG5cbiAgICB2YXIgcHJvZyAgICAgICAgICA9IGNhbWxfanNfZnJvbV9hcnJheShyZVsxXSksXG4gICAgICAgIGNwb29sICAgICAgICAgPSBjYW1sX2pzX2Zyb21fYXJyYXkocmVbMl0pLFxuICAgICAgICBub3JtdGFibGUgICAgID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZVszXSksXG4gICAgICAgIG51bWdyb3VwcyAgICAgPSByZVs0XSB8IDAsXG4gICAgICAgIG51bXJlZ2lzdGVycyAgPSByZVs1XSB8IDAsXG4gICAgICAgIHN0YXJ0Y2hhcnMgICAgPSByZVs2XSB8IDA7XG5cbiAgICB2YXIgcyA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKHMpO1xuXG4gICAgdmFyIHBjID0gMCxcbiAgICAgICAgcXVpdCA9IGZhbHNlLFxuICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICBncm91cHMgPSBuZXcgQXJyYXkobnVtZ3JvdXBzKSxcbiAgICAgICAgcmVfcmVnaXN0ZXIgPSBuZXcgQXJyYXkobnVtcmVnaXN0ZXJzKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspe1xuICAgICAgZ3JvdXBzW2ldID0ge3N0YXJ0OiAtMSwgZW5kOi0xfVxuICAgIH1cbiAgICBncm91cHNbMF0uc3RhcnQgPSBwb3M7XG5cbiAgICB2YXIgYmFja3RyYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgaXRlbSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoaXRlbS51bmRvKSB7XG4gICAgICAgICAgaXRlbS51bmRvLm9ialtpdGVtLnVuZG8ucHJvcF0gPSBpdGVtLnVuZG8udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihpdGVtLnBvcykge1xuICAgICAgICAgIHBjID0gaXRlbS5wb3MucGM7XG4gICAgICAgICAgcG9zID0gaXRlbS5wb3MudHh0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcXVpdCA9IHRydWU7XG4gICAgfTtcblxuICAgIHZhciBwdXNoID0gZnVuY3Rpb24oaXRlbSkgeyBzdGFjay5wdXNoKGl0ZW0pOyB9O1xuXG4gICAgdmFyIGFjY2VwdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGdyb3Vwc1swXS5lbmQgPSBwb3M7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KDEgKyBncm91cHMubGVuZ3RoKjIpO1xuICAgICAgcmVzdWx0WzBdID0gMDsgLy8gdGFnXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGcgPSBncm91cHNbaV07XG4gICAgICAgIGlmKGcuc3RhcnQgPCAwIHx8IGcuZW5kIDwgMCkge1xuICAgICAgICAgIGcuc3RhcnQgPSBnLmVuZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFsyKmkgKyAxIF0gPSBnLnN0YXJ0O1xuICAgICAgICByZXN1bHRbMippICsgMSArIDEgXSA9IGcuZW5kO1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgdmFyIHByZWZpeF9tYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmKHBhcnRpYWwpIHJldHVybiBhY2NlcHQgKCk7XG4gICAgICBlbHNlIGJhY2t0cmFjayAoKTtcbiAgICB9XG5cbiAgICAvKiBNYWluIERGQSBpbnRlcnByZXRlciBsb29wICovXG4gICAgd2hpbGUgKCFxdWl0KSB7XG4gICAgICB2YXIgb3AgPSBwcm9nW3BjXSAmIDB4ZmYsXG4gICAgICAgICAgc2FyZyA9IHByb2dbcGNdID4+IDgsXG4gICAgICAgICAgdWFyZyA9IHNhcmcgJiAweGZmLFxuICAgICAgICAgIGMgPSBzW3Bvc10sXG4gICAgICAgICAgZ3JvdXA7XG5cbiAgICAgIHBjKys7XG5cbiAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChjID09PSB1YXJnKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUk5PUk06XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSB1YXJnKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU1RSSU5HOlxuICAgICAgICBmb3IgKHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYgKGMgPT09IGFyZy5jaGFyQ29kZUF0KGkpKVxuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIGVsc2UgeyBiYWNrdHJhY2soKTsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TVFJJTkdOT1JNOlxuICAgICAgICBmb3IgKHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSBhcmcuY2hhckNvZGVBdChpKSlcbiAgICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICBlbHNlIHsgYmFja3RyYWNrKCk7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUkNMQVNTOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQk9MOlxuICAgICAgICBpZihwb3MgPiAwICYmIHNbcG9zIC0gMV0gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkVPTDpcbiAgICAgICAgaWYocG9zIDwgcy5sZW5ndGggJiYgc1twb3NdICE9IDEwIC8qIFxcbiAqLykge2JhY2t0cmFjaygpfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5XT1JEQk9VTkRBUlk6XG4gICAgICAgIGlmKHBvcyA9PSAwKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbMF0pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3MgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1twb3MgLSAxXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSAhPSBpc193b3JkX2xldHRlcihzW3Bvc10pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2sgKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQkVHR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOmdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdyb3VwLnN0YXJ0fX0pO1xuICAgICAgICBncm91cC5zdGFydCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU5ER1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOiBncm91cCxcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6J2VuZCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuZW5kfX0pO1xuICAgICAgICBncm91cC5lbmQgPSBwb3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlJFRkdST1VQOlxuICAgICAgICBncm91cCA9IGdyb3Vwc1t1YXJnXTtcbiAgICAgICAgaWYoZ3JvdXAuc3RhcnQgPCAwIHx8IGdyb3VwLmVuZCA8IDApIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICBmb3IgKHZhciBpID0gZ3JvdXAuc3RhcnQ7IGkgPCBncm91cC5lbmQ7IGkrKyl7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmKHNbaV0gIT0gc1twb3NdKSB7YmFja3RyYWNrICgpOyBicmVha31cbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVPUFQ6XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0lNUExFU1RBUjpcbiAgICAgICAgd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpXG4gICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVQTFVTOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIH0gd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkFDQ0VQVDpcbiAgICAgICAgcmV0dXJuIGFjY2VwdCgpO1xuICAgICAgY2FzZSBvcGNvZGVzLkdPVE86XG4gICAgICAgIHBjID0gcGMgKyBzYXJnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5QVVNIQkFDSzpcbiAgICAgICAgcHVzaCh7cG9zOiB7cGM6IHBjICsgc2FyZywgdHh0OiBwb3N9fSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNFVE1BUks6XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6cmVfcmVnaXN0ZXIsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOiB1YXJnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlX3JlZ2lzdGVyW3VhcmddfX0pO1xuICAgICAgICByZV9yZWdpc3Rlclt1YXJnXSA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hFQ0tQUk9HUkVTUzpcbiAgICAgICAgaWYgKHJlX3JlZ2lzdGVyW3VhcmddID09PSBwb3MpIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnl0ZWNvZGVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHJlX21hdGNoX2ltcGw7XG59KCk7XG5cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2ZvcndhcmRcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc2VhcmNoX2ZvcndhcmQocmUsIHMsIHBvcykge1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2ZvcndhcmRcIilcbiAgd2hpbGUgKHBvcyA8PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIHtcbiAgICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gICAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgICBwb3MrKztcbiAgfVxuXG4gIHJldHVybiBbMF07ICAvKiBbfHxdIDogaW50IGFycmF5ICovXG59XG5cbi8vUHJvdmlkZXM6IHJlX3NlYXJjaF9iYWNrd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfYmFja3dhcmQocmUsIHMsIHBvcykge1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2JhY2t3YXJkXCIpXG4gIHdoaWxlIChwb3MgPj0gMCkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcy0tO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuXG4vL1Byb3ZpZGVzOiByZV9zdHJpbmdfbWF0Y2hcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc3RyaW5nX21hdGNoKHJlLHMscG9zKXtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnN0cmluZ19tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcGFydGlhbF9tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9wYXJ0aWFsX21hdGNoKHJlLHMscG9zKXtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnBhcnRpYWxfbWF0Y2hcIilcbiAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDEpO1xuICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICBlbHNlIHJldHVybiBbMF07XG59XG5cbi8vUHJvdmlkZXM6IHJlX3JlcGxhY2VtZW50X3RleHRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vLyBleHRlcm5hbCByZV9yZXBsYWNlbWVudF90ZXh0OiBzdHJpbmcgLT4gaW50IGFycmF5IC0+IHN0cmluZyAtPiBzdHJpbmdcbmZ1bmN0aW9uIHJlX3JlcGxhY2VtZW50X3RleHQocmVwbCxncm91cHMsb3JpZykge1xuICB2YXIgcmVwbCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocmVwbCk7XG4gIHZhciBsZW4gPSByZXBsLmxlbmd0aDtcbiAgdmFyIG9yaWcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9yaWcpO1xuICB2YXIgcmVzID0gXCJcIjsgLy9yZXN1bHRcbiAgdmFyIG4gPSAwOyAvLyBjdXJyZW50IHBvc2l0aW9uXG4gIHZhciBjdXI7IC8vY3VycmVudCBjaGFyXG4gIHZhciBzdGFydCwgZW5kLCBjO1xuICB3aGlsZShuIDwgbGVuKXtcbiAgICBjdXIgPSByZXBsLmNoYXJBdChuKyspO1xuICAgIGlmKGN1ciAhPSAnXFxcXCcpe1xuICAgICAgcmVzICs9IGN1cjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZihuID09IGxlbikgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiBpbGxlZ2FsIGJhY2tzbGFzaCBzZXF1ZW5jZVwiKTtcbiAgICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgICBzd2l0Y2goY3VyKXtcbiAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICByZXMgKz0gY3VyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzAnOiBjYXNlICcxJzogY2FzZSAnMic6IGNhc2UgJzMnOiBjYXNlICc0JzpcbiAgICAgIGNhc2UgJzUnOiBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgICAgYyA9ICtjdXI7XG4gICAgICAgIGlmIChjKjIgPj0gZ3JvdXBzLmxlbmd0aCAtIDEgKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogcmVmZXJlbmNlIHRvIHVubWF0Y2hlZCBncm91cFwiICk7XG4gICAgICAgIHN0YXJ0ID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLGMqMik7XG4gICAgICAgIGVuZCA9IGNhbWxfYXJyYXlfZ2V0KGdyb3VwcywgYyoyICsxKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09IC0xKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogcmVmZXJlbmNlIHRvIHVubWF0Y2hlZCBncm91cFwiKTtcbiAgICAgICAgcmVzKz1vcmlnLnNsaWNlKHN0YXJ0LGVuZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzICs9ICgnXFxcXCcgICsgY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocmVzKTsgfVxuIiwiLy9UaGUgZm9sbG93aW5nIGFyZSBkZWZpbmVkIGluIENzdHJ1Y3Rcbi8vVGhlcmUgYXJlIGp1c3QgcHJvdmlkZWQgaGVyZSBmb3IgY29tcGF0aWJpbGl0eSByZWFzb25zXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX2JpZ3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuLy9XZWFrZGVmXG52YXIgY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmcgPSBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICBEYW5pZWwgQy4gQnVlbnpsaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5cbmxldCBlcnJfbm9fcHJlZCA9IFwiVSswMDAwIGhhcyBubyBwcmVkZWNlc3NvclwiXG5sZXQgZXJyX25vX3N1Y2MgPSBcIlUrMTBGRkZGIGhhcyBubyBzdWNjZXNzb3JcIlxubGV0IGVycl9ub3Rfc3YgaSA9IGZvcm1hdF9pbnQgXCIlWFwiIGkgXiBcIiBpcyBub3QgYW4gVW5pY29kZSBzY2FsYXIgdmFsdWVcIlxubGV0IGVycl9ub3RfbGF0aW4xIHUgPSBcIlUrXCIgXiBmb3JtYXRfaW50IFwiJTA0WFwiIHUgXiBcIiBpcyBub3QgYSBsYXRpbjEgY2hhcmFjdGVyXCJcblxudHlwZSB0ID0gaW50XG5cbmxldCBtaW4gPSAweDAwMDBcbmxldCBtYXggPSAweDEwRkZGRlxubGV0IGxvX2JvdW5kID0gMHhEN0ZGXG5sZXQgaGlfYm91bmQgPSAweEUwMDBcblxubGV0IGJvbSA9IDB4RkVGRlxubGV0IHJlcCA9IDB4RkZGRFxuXG5sZXQgc3VjYyB1ID1cbiAgaWYgdSA9IGxvX2JvdW5kIHRoZW4gaGlfYm91bmQgZWxzZVxuICBpZiB1ID0gbWF4IHRoZW4gaW52YWxpZF9hcmcgZXJyX25vX3N1Y2MgZWxzZVxuICB1ICsgMVxuXG5sZXQgcHJlZCB1ID1cbiAgaWYgdSA9IGhpX2JvdW5kIHRoZW4gbG9fYm91bmQgZWxzZVxuICBpZiB1ID0gbWluIHRoZW4gaW52YWxpZF9hcmcgZXJyX25vX3ByZWQgZWxzZVxuICB1IC0gMVxuXG5sZXQgaXNfdmFsaWQgaSA9IChtaW4gPD0gaSAmJiBpIDw9IGxvX2JvdW5kKSB8fCAoaGlfYm91bmQgPD0gaSAmJiBpIDw9IG1heClcbmxldCBvZl9pbnQgaSA9IGlmIGlzX3ZhbGlkIGkgdGhlbiBpIGVsc2UgaW52YWxpZF9hcmcgKGVycl9ub3Rfc3YgaSlcbmV4dGVybmFsIHVuc2FmZV9vZl9pbnQgOiBpbnQgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHRvX2ludCA6IHQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgaXNfY2hhciB1ID0gdSA8IDI1NlxubGV0IG9mX2NoYXIgYyA9IENoYXIuY29kZSBjXG5sZXQgdG9fY2hhciB1ID1cbiAgaWYgdSA+IDI1NSB0aGVuIGludmFsaWRfYXJnIChlcnJfbm90X2xhdGluMSB1KSBlbHNlXG4gIENoYXIudW5zYWZlX2NociB1XG5cbmxldCB1bnNhZmVfdG9fY2hhciA9IENoYXIudW5zYWZlX2NoclxuXG5sZXQgZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5sZXQgaGFzaCA9IHRvX2ludFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0ludDY0XTogNjQtYml0IGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZyA6IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbmVnXCJcbmV4dGVybmFsIGFkZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYWRkXCJcbmV4dGVybmFsIHN1YiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfc3ViXCJcbmV4dGVybmFsIG11bCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbXVsXCJcbmV4dGVybmFsIGRpdiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfZGl2XCJcbmV4dGVybmFsIHJlbSA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYW5kXCJcbmV4dGVybmFsIGxvZ29yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vclwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGludDY0IC0+IGludCA9IFwiJWludDY0X3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF90b19mbG9hdFwiIFwiY2FtbF9pbnQ2NF90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG9mX2ludDMyIDogaW50MzIgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnQzMlwiXG5leHRlcm5hbCB0b19pbnQzMiA6IGludDY0IC0+IGludDMyID0gXCIlaW50NjRfdG9faW50MzJcIlxuZXh0ZXJuYWwgb2ZfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfbmF0aXZlaW50XCJcbmV4dGVybmFsIHRvX25hdGl2ZWludCA6IGludDY0IC0+IG5hdGl2ZWludCA9IFwiJWludDY0X3RvX25hdGl2ZWludFwiXG5cbmxldCB6ZXJvID0gMExcbmxldCBvbmUgPSAxTFxubGV0IG1pbnVzX29uZSA9IC0xTFxubGV0IHN1Y2MgbiA9IGFkZCBuIDFMXG5sZXQgcHJlZCBuID0gc3ViIG4gMUxcbmxldCBhYnMgbiA9IGlmIG4gPj0gMEwgdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBtaW5faW50ID0gMHg4MDAwMDAwMDAwMDAwMDAwTFxubGV0IG1heF9pbnQgPSAweDdGRkZGRkZGRkZGRkZGRkZMXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFMKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgZnVuIG4gLT5cbiAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgU29tZSAodG9faW50IG4pXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDY0ID0gXCJjYW1sX2ludDY0X29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5cblxuZXh0ZXJuYWwgYml0c19vZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbnR5cGUgdCA9IGludDY0XG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG5cbmxldCB1bnNpZ25lZF9jb21wYXJlIG4gbSA9XG4gIGNvbXBhcmUgKHN1YiBuIG1pbl9pbnQpIChzdWIgbSBtaW5faW50KVxuXG5sZXQgbWluIHggeSA6IHQgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgOiB0ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcblxuKCogVW5zaWduZWQgZGl2aXNpb24gZnJvbSBzaWduZWQgZGl2aXNpb24gb2YgdGhlIHNhbWVcbiAgIGJpdG5lc3MuIFNlZSBXYXJyZW4gSnIuLCBIZW5yeSBTLiAoMjAxMykuIEhhY2tlcidzIERlbGlnaHQgKDIgZWQuKSwgU2VjIDktMy5cbiopXG5sZXQgdW5zaWduZWRfZGl2IG4gZCA9XG4gIGlmIGQgPCB6ZXJvIHRoZW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIG4gZCA8IDAgdGhlbiB6ZXJvIGVsc2Ugb25lXG4gIGVsc2VcbiAgICBsZXQgcSA9IHNoaWZ0X2xlZnQgKGRpdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBuIDEpIGQpIDEgaW5cbiAgICBsZXQgciA9IHN1YiBuIChtdWwgcSBkKSBpblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgciBkID49IDAgdGhlbiBzdWNjIHEgZWxzZSBxXG5cbmxldCB1bnNpZ25lZF9yZW0gbiBkID1cbiAgc3ViIG4gKG11bCAodW5zaWduZWRfZGl2IG4gZCkgZClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVGhlIHJ1bi10aW1lIGxpYnJhcnkgZm9yIGxleGVycyBnZW5lcmF0ZWQgYnkgY2FtbGxleCAqKVxuXG50eXBlIHBvc2l0aW9uID0ge1xuICBwb3NfZm5hbWUgOiBzdHJpbmc7XG4gIHBvc19sbnVtIDogaW50O1xuICBwb3NfYm9sIDogaW50O1xuICBwb3NfY251bSA6IGludDtcbn1cblxubGV0IGR1bW15X3BvcyA9IHtcbiAgcG9zX2ZuYW1lID0gXCJcIjtcbiAgcG9zX2xudW0gPSAwO1xuICBwb3NfYm9sID0gMDtcbiAgcG9zX2NudW0gPSAtMTtcbn1cblxudHlwZSBsZXhidWYgPVxuICB7IHJlZmlsbF9idWZmIDogbGV4YnVmIC0+IHVuaXQ7XG4gICAgbXV0YWJsZSBsZXhfYnVmZmVyIDogYnl0ZXM7XG4gICAgbXV0YWJsZSBsZXhfYnVmZmVyX2xlbiA6IGludDtcbiAgICBtdXRhYmxlIGxleF9hYnNfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X3N0YXJ0X3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9jdXJyX3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9sYXN0X3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9sYXN0X2FjdGlvbiA6IGludDtcbiAgICBtdXRhYmxlIGxleF9lb2ZfcmVhY2hlZCA6IGJvb2w7XG4gICAgbXV0YWJsZSBsZXhfbWVtIDogaW50IGFycmF5O1xuICAgIG11dGFibGUgbGV4X3N0YXJ0X3AgOiBwb3NpdGlvbjtcbiAgICBtdXRhYmxlIGxleF9jdXJyX3AgOiBwb3NpdGlvbjtcbiAgfVxuXG50eXBlIGxleF90YWJsZXMgPVxuICB7IGxleF9iYXNlOiBzdHJpbmc7XG4gICAgbGV4X2JhY2t0cms6IHN0cmluZztcbiAgICBsZXhfZGVmYXVsdDogc3RyaW5nO1xuICAgIGxleF90cmFuczogc3RyaW5nO1xuICAgIGxleF9jaGVjazogc3RyaW5nO1xuICAgIGxleF9iYXNlX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2JhY2t0cmtfY29kZSA6IHN0cmluZztcbiAgICBsZXhfZGVmYXVsdF9jb2RlIDogc3RyaW5nO1xuICAgIGxleF90cmFuc19jb2RlIDogc3RyaW5nO1xuICAgIGxleF9jaGVja19jb2RlIDogc3RyaW5nO1xuICAgIGxleF9jb2RlOiBzdHJpbmc7fVxuXG5leHRlcm5hbCBjX2VuZ2luZSA6IGxleF90YWJsZXMgLT4gaW50IC0+IGxleGJ1ZiAtPiBpbnQgPSBcImNhbWxfbGV4X2VuZ2luZVwiXG5leHRlcm5hbCBjX25ld19lbmdpbmUgOiBsZXhfdGFibGVzIC0+IGludCAtPiBsZXhidWYgLT4gaW50XG4gICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbmV3X2xleF9lbmdpbmVcIlxuXG5sZXQgZW5naW5lIHRibCBzdGF0ZSBidWYgPVxuICBsZXQgcmVzdWx0ID0gY19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiBpblxuICBpZiByZXN1bHQgPj0gMCAmJiBidWYubGV4X2N1cnJfcCAhPSBkdW1teV9wb3MgdGhlbiBiZWdpblxuICAgIGJ1Zi5sZXhfc3RhcnRfcCA8LSBidWYubGV4X2N1cnJfcDtcbiAgICBidWYubGV4X2N1cnJfcCA8LSB7YnVmLmxleF9jdXJyX3BcbiAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBwb3NfY251bSA9IGJ1Zi5sZXhfYWJzX3BvcyArIGJ1Zi5sZXhfY3Vycl9wb3N9O1xuICBlbmQ7XG4gIHJlc3VsdFxuXG5cbmxldCBuZXdfZW5naW5lIHRibCBzdGF0ZSBidWYgPVxuICBsZXQgcmVzdWx0ID0gY19uZXdfZW5naW5lIHRibCBzdGF0ZSBidWYgaW5cbiAgaWYgcmVzdWx0ID49IDAgJiYgYnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zIHRoZW4gYmVnaW5cbiAgICBidWYubGV4X3N0YXJ0X3AgPC0gYnVmLmxleF9jdXJyX3A7XG4gICAgYnVmLmxleF9jdXJyX3AgPC0ge2J1Zi5sZXhfY3Vycl9wXG4gICAgICAgICAgICAgICAgICAgICAgIHdpdGggcG9zX2NudW0gPSBidWYubGV4X2Fic19wb3MgKyBidWYubGV4X2N1cnJfcG9zfTtcbiAgZW5kO1xuICByZXN1bHRcblxubGV0IGxleF9yZWZpbGwgcmVhZF9mdW4gYXV4X2J1ZmZlciBsZXhidWYgPVxuICBsZXQgcmVhZCA9XG4gICAgcmVhZF9mdW4gYXV4X2J1ZmZlciAoQnl0ZXMubGVuZ3RoIGF1eF9idWZmZXIpIGluXG4gIGxldCBuID1cbiAgICBpZiByZWFkID4gMFxuICAgIHRoZW4gcmVhZFxuICAgIGVsc2UgKGxleGJ1Zi5sZXhfZW9mX3JlYWNoZWQgPC0gdHJ1ZTsgMCkgaW5cbiAgKCogQ3VycmVudCBzdGF0ZSBvZiB0aGUgYnVmZmVyOlxuICAgICAgICA8LS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0+XG4gICAgICAgIHwgIGp1bmsgfCAgICAgIHZhbGlkIGRhdGEgICAgIHwgICBqdW5rICAgIHxcbiAgICAgICAgXiAgICAgICBeICAgICAgICAgICAgICAgICAgICAgXiAgICAgICAgICAgXlxuICAgICAgICAwICAgIHN0YXJ0X3BvcyAgICAgICAgICAgICBidWZmZXJfZW5kICAgIEJ5dGVzLmxlbmd0aCBidWZmZXJcbiAgKilcbiAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuICsgbiA+IEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlciB0aGVuIGJlZ2luXG4gICAgKCogVGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgKilcbiAgICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcyArIG5cbiAgICAgICA8PSBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXJcbiAgICB0aGVuIGJlZ2luXG4gICAgICAoKiBCdXQgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGlmIHdlIHJlY2xhaW0gdGhlIGp1bmsgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgb2YgdGhlIGJ1ZmZlciAqKVxuICAgICAgQnl0ZXMuYmxpdCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X3N0YXJ0X3Bvc1xuICAgICAgICAgICAgICAgICAgbGV4YnVmLmxleF9idWZmZXIgMFxuICAgICAgICAgICAgICAgICAgKGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zKVxuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAoKiBXZSBtdXN0IGdyb3cgdGhlIGJ1ZmZlci4gIERvdWJsaW5nIGl0cyBzaXplIHdpbGwgcHJvdmlkZSBlbm91Z2hcbiAgICAgICAgIHNwYWNlIHNpbmNlIG4gPD0gU3RyaW5nLmxlbmd0aCBhdXhfYnVmZmVyIDw9IFN0cmluZy5sZW5ndGggYnVmZmVyLlxuICAgICAgICAgV2F0Y2ggb3V0IGZvciBzdHJpbmcgbGVuZ3RoIG92ZXJmbG93LCB0aG91Z2guICopXG4gICAgICBsZXQgbmV3bGVuID1cbiAgICAgICAgSW50Lm1pbiAoMiAqIEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlcikgU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGluXG4gICAgICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcyArIG4gPiBuZXdsZW5cbiAgICAgIHRoZW4gZmFpbHdpdGggXCJMZXhpbmcubGV4X3JlZmlsbDogY2Fubm90IGdyb3cgYnVmZmVyXCI7XG4gICAgICBsZXQgbmV3YnVmID0gQnl0ZXMuY3JlYXRlIG5ld2xlbiBpblxuICAgICAgKCogQ29weSB0aGUgdmFsaWQgZGF0YSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXcgYnVmZmVyICopXG4gICAgICBCeXRlcy5ibGl0IGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zXG4gICAgICAgICAgICAgICAgICBuZXdidWYgMFxuICAgICAgICAgICAgICAgICAgKGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zKTtcbiAgICAgIGxleGJ1Zi5sZXhfYnVmZmVyIDwtIG5ld2J1ZlxuICAgIGVuZDtcbiAgICAoKiBSZWFsbG9jYXRpb24gb3Igbm90LCB3ZSBoYXZlIHNoaWZ0ZWQgdGhlIGRhdGEgbGVmdCBieVxuICAgICAgIHN0YXJ0X3BvcyBjaGFyYWN0ZXJzOyB1cGRhdGUgdGhlIHBvc2l0aW9ucyAqKVxuICAgIGxldCBzID0gbGV4YnVmLmxleF9zdGFydF9wb3MgaW5cbiAgICBsZXhidWYubGV4X2Fic19wb3MgPC0gbGV4YnVmLmxleF9hYnNfcG9zICsgcztcbiAgICBsZXhidWYubGV4X2N1cnJfcG9zIDwtIGxleGJ1Zi5sZXhfY3Vycl9wb3MgLSBzO1xuICAgIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIDwtIDA7XG4gICAgbGV4YnVmLmxleF9sYXN0X3BvcyA8LSBsZXhidWYubGV4X2xhc3RfcG9zIC0gcztcbiAgICBsZXhidWYubGV4X2J1ZmZlcl9sZW4gPC0gbGV4YnVmLmxleF9idWZmZXJfbGVuIC0gcyA7XG4gICAgbGV0IHQgPSBsZXhidWYubGV4X21lbSBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC0xIGRvXG4gICAgICBsZXQgdiA9IHQuKGkpIGluXG4gICAgICBpZiB2ID49IDAgdGhlblxuICAgICAgICB0LihpKSA8LSB2LXNcbiAgICBkb25lXG4gIGVuZDtcbiAgKCogVGhlcmUgaXMgbm93IGVub3VnaCBzcGFjZSBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgKilcbiAgQnl0ZXMuYmxpdCBhdXhfYnVmZmVyIDAgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9idWZmZXJfbGVuIG47XG4gIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiA8LSBsZXhidWYubGV4X2J1ZmZlcl9sZW4gKyBuXG5cbmxldCB6ZXJvX3BvcyA9IHtcbiAgcG9zX2ZuYW1lID0gXCJcIjtcbiAgcG9zX2xudW0gPSAxO1xuICBwb3NfYm9sID0gMDtcbiAgcG9zX2NudW0gPSAwO1xufVxuXG5sZXQgZnJvbV9mdW5jdGlvbiA/KHdpdGhfcG9zaXRpb25zID0gdHJ1ZSkgZiA9XG4gIHsgcmVmaWxsX2J1ZmYgPSBsZXhfcmVmaWxsIGYgKEJ5dGVzLmNyZWF0ZSA1MTIpO1xuICAgIGxleF9idWZmZXIgPSBCeXRlcy5jcmVhdGUgMTAyNDtcbiAgICBsZXhfYnVmZmVyX2xlbiA9IDA7XG4gICAgbGV4X2Fic19wb3MgPSAwO1xuICAgIGxleF9zdGFydF9wb3MgPSAwO1xuICAgIGxleF9jdXJyX3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9hY3Rpb24gPSAwO1xuICAgIGxleF9tZW0gPSBbfHxdO1xuICAgIGxleF9lb2ZfcmVhY2hlZCA9IGZhbHNlO1xuICAgIGxleF9zdGFydF9wID0gaWYgd2l0aF9wb3NpdGlvbnMgdGhlbiB6ZXJvX3BvcyBlbHNlIGR1bW15X3BvcztcbiAgICBsZXhfY3Vycl9wID0gaWYgd2l0aF9wb3NpdGlvbnMgdGhlbiB6ZXJvX3BvcyBlbHNlIGR1bW15X3BvcztcbiAgfVxuXG5sZXQgZnJvbV9jaGFubmVsID93aXRoX3Bvc2l0aW9ucyBpYyA9XG4gIGZyb21fZnVuY3Rpb24gP3dpdGhfcG9zaXRpb25zIChmdW4gYnVmIG4gLT4gaW5wdXQgaWMgYnVmIDAgbilcblxubGV0IGZyb21fc3RyaW5nID8od2l0aF9wb3NpdGlvbnMgPSB0cnVlKSBzID1cbiAgeyByZWZpbGxfYnVmZiA9IChmdW4gbGV4YnVmIC0+IGxleGJ1Zi5sZXhfZW9mX3JlYWNoZWQgPC0gdHJ1ZSk7XG4gICAgbGV4X2J1ZmZlciA9IEJ5dGVzLm9mX3N0cmluZyBzOyAoKiBoYXZlIHRvIG1ha2UgYSBjb3B5IGZvciBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHVuc2FmZS1zdHJpbmcgbW9kZSAqKVxuICAgIGxleF9idWZmZXJfbGVuID0gU3RyaW5nLmxlbmd0aCBzO1xuICAgIGxleF9hYnNfcG9zID0gMDtcbiAgICBsZXhfc3RhcnRfcG9zID0gMDtcbiAgICBsZXhfY3Vycl9wb3MgPSAwO1xuICAgIGxleF9sYXN0X3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfYWN0aW9uID0gMDtcbiAgICBsZXhfbWVtID0gW3x8XTtcbiAgICBsZXhfZW9mX3JlYWNoZWQgPSB0cnVlO1xuICAgIGxleF9zdGFydF9wID0gaWYgd2l0aF9wb3NpdGlvbnMgdGhlbiB6ZXJvX3BvcyBlbHNlIGR1bW15X3BvcztcbiAgICBsZXhfY3Vycl9wID0gaWYgd2l0aF9wb3NpdGlvbnMgdGhlbiB6ZXJvX3BvcyBlbHNlIGR1bW15X3BvcztcbiAgfVxuXG5sZXQgc2V0X3Bvc2l0aW9uIGxleGJ1ZiBwb3NpdGlvbiA9XG4gIGxleGJ1Zi5sZXhfY3Vycl9wICA8LSB7cG9zaXRpb24gd2l0aCBwb3NfZm5hbWUgPSBsZXhidWYubGV4X2N1cnJfcC5wb3NfZm5hbWV9O1xuICBsZXhidWYubGV4X2Fic19wb3MgPC0gcG9zaXRpb24ucG9zX2NudW1cblxubGV0IHNldF9maWxlbmFtZSBsZXhidWYgZm5hbWUgPVxuICBsZXhidWYubGV4X2N1cnJfcCA8LSB7bGV4YnVmLmxleF9jdXJyX3Agd2l0aCBwb3NfZm5hbWUgPSBmbmFtZX1cblxubGV0IHdpdGhfcG9zaXRpb25zIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wICE9IGR1bW15X3Bvc1xuXG5sZXQgbGV4ZW1lIGxleGJ1ZiA9XG4gIGxldCBsZW4gPSBsZXhidWYubGV4X2N1cnJfcG9zIC0gbGV4YnVmLmxleF9zdGFydF9wb3MgaW5cbiAgQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X3N0YXJ0X3BvcyBsZW5cblxubGV0IHN1Yl9sZXhlbWUgbGV4YnVmIGkxIGkyID1cbiAgbGV0IGxlbiA9IGkyLWkxIGluXG4gIEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgaTEgbGVuXG5cbmxldCBzdWJfbGV4ZW1lX29wdCBsZXhidWYgaTEgaTIgPVxuICBpZiBpMSA+PSAwIHRoZW4gYmVnaW5cbiAgICBsZXQgbGVuID0gaTItaTEgaW5cbiAgICBTb21lIChCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGkxIGxlbilcbiAgZW5kIGVsc2UgYmVnaW5cbiAgICBOb25lXG4gIGVuZFxuXG5sZXQgc3ViX2xleGVtZV9jaGFyIGxleGJ1ZiBpID0gQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIGlcblxubGV0IHN1Yl9sZXhlbWVfY2hhcl9vcHQgbGV4YnVmIGkgPVxuICBpZiBpID49IDAgdGhlblxuICAgIFNvbWUgKEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciBpKVxuICBlbHNlXG4gICAgTm9uZVxuXG5cbmxldCBsZXhlbWVfY2hhciBsZXhidWYgaSA9XG4gIEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciAobGV4YnVmLmxleF9zdGFydF9wb3MgKyBpKVxuXG5sZXQgbGV4ZW1lX3N0YXJ0IGxleGJ1ZiA9IGxleGJ1Zi5sZXhfc3RhcnRfcC5wb3NfY251bVxubGV0IGxleGVtZV9lbmQgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3AucG9zX2NudW1cblxubGV0IGxleGVtZV9zdGFydF9wIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfc3RhcnRfcFxubGV0IGxleGVtZV9lbmRfcCBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcFxuXG5sZXQgbmV3X2xpbmUgbGV4YnVmID1cbiAgbGV0IGxjcCA9IGxleGJ1Zi5sZXhfY3Vycl9wIGluXG4gIGlmIGxjcCAhPSBkdW1teV9wb3MgdGhlblxuICAgIGxleGJ1Zi5sZXhfY3Vycl9wIDwtXG4gICAgICB7IGxjcCB3aXRoXG4gICAgICAgIHBvc19sbnVtID0gbGNwLnBvc19sbnVtICsgMTtcbiAgICAgICAgcG9zX2JvbCA9IGxjcC5wb3NfY251bTtcbiAgICAgIH1cblxuXG5cbigqIERpc2NhcmQgZGF0YSBsZWZ0IGluIGxleGVyIGJ1ZmZlci4gKilcblxubGV0IGZsdXNoX2lucHV0IGxiID1cbiAgbGIubGV4X2N1cnJfcG9zIDwtIDA7XG4gIGxiLmxleF9hYnNfcG9zIDwtIDA7XG4gIGxldCBsY3AgPSBsYi5sZXhfY3Vycl9wIGluXG4gIGlmIGxjcCAhPSBkdW1teV9wb3MgdGhlblxuICAgIGxiLmxleF9jdXJyX3AgPC0ge3plcm9fcG9zIHdpdGggcG9zX2ZuYW1lID0gbGNwLnBvc19mbmFtZX07XG4gIGxiLmxleF9idWZmZXJfbGVuIDwtIDA7XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgQmVub2l0IFZhdWdvbiwgRU5TVEEgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICgqIFRvb2xzIHRvIG1hbmlwdWxhdGUgc2Nhbm5pbmcgc2V0IG9mIGNoYXJzIChzZWUgJVsuLi5dKSAqKVxuXG50eXBlIG11dGFibGVfY2hhcl9zZXQgPSBieXRlc1xuXG4oKiBDcmVhdGUgYSBmcmVzaCwgZW1wdHksIG11dGFibGUgY2hhciBzZXQuICopXG5sZXQgY3JlYXRlX2NoYXJfc2V0ICgpID0gQnl0ZXMubWFrZSAzMiAnXFwwMDAnXG5cbigqIEFkZCBhIGNoYXIgaW4gYSBtdXRhYmxlIGNoYXIgc2V0LiAqKVxubGV0IGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjID1cbiAgbGV0IGluZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgbGV0IHN0cl9pbmQgPSBpbmQgbHNyIDMgYW5kIG1hc2sgPSAxIGxzbCAoaW5kIGxhbmQgMGIxMTEpIGluXG4gIEJ5dGVzLnNldCBjaGFyX3NldCBzdHJfaW5kXG4gICAgKGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciAoQnl0ZXMuZ2V0IGNoYXJfc2V0IHN0cl9pbmQpIGxvciBtYXNrKSlcblxubGV0IGZyZWV6ZV9jaGFyX3NldCBjaGFyX3NldCA9XG4gIEJ5dGVzLnRvX3N0cmluZyBjaGFyX3NldFxuXG4oKiBDb21wdXRlIHRoZSBjb21wbGVtZW50IG9mIGEgY2hhciBzZXQuICopXG5sZXQgcmV2X2NoYXJfc2V0IGNoYXJfc2V0ID1cbiAgbGV0IGNoYXJfc2V0JyA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICBmb3IgaSA9IDAgdG8gMzEgZG9cbiAgICBCeXRlcy5zZXQgY2hhcl9zZXQnIGlcbiAgICAgIChjaGFyX29mX2ludCAoaW50X29mX2NoYXIgKFN0cmluZy5nZXQgY2hhcl9zZXQgaSkgbHhvciAweEZGKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgY2hhcl9zZXQnXG5cbigqIFJldHVybiB0cnVlIGlmIGEgYGMnIGlzIGluIGBjaGFyX3NldCcuICopXG5sZXQgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyA9XG4gIGxldCBpbmQgPSBpbnRfb2ZfY2hhciBjIGluXG4gIGxldCBzdHJfaW5kID0gaW5kIGxzciAzIGFuZCBtYXNrID0gMSBsc2wgKGluZCBsYW5kIDBiMTExKSBpblxuICAoaW50X29mX2NoYXIgKFN0cmluZy5nZXQgY2hhcl9zZXQgc3RyX2luZCkgbGFuZCBtYXNrKSA8PiAwXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKiBJZ25vcmVkIHBhcmFtIGNvbnZlcnNpb24gKilcblxuKCogR0FEVCB1c2VkIHRvIGFic3RyYWN0IGFuIGV4aXN0ZW50aWFsIHR5cGUgcGFyYW1ldGVyLiAqKVxuKCogU2VlIHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdC4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhcmFtX2Zvcm1hdF9lYmIgPSBQYXJhbV9mb3JtYXRfRUJCIDpcbiAgICAoJ3ggLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhcmFtX2Zvcm1hdF9lYmJcblxuKCogQ29tcHV0ZSBhIHBhZGRpbmcgYXNzb2NpYXRlZCB0byBhIHBhZF9vcHRpb24gKHNlZSBcIiVfNDJkXCIpLiAqKVxubGV0IHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IE5vX3BhZGRpbmdcbiAgfCBTb21lIHdpZHRoIC0+IExpdF9wYWRkaW5nIChSaWdodCwgd2lkdGgpXG5cbigqIENvbXB1dGUgYSBwcmVjaXNpb24gYXNzb2NpYXRlZCB0byBhIHByZWNfb3B0aW9uIChzZWUgXCIlXy40MmZcIikuICopXG5sZXQgcHJlY19vZl9wcmVjX29wdCBwcmVjX29wdCA9IG1hdGNoIHByZWNfb3B0IHdpdGhcbiAgfCBOb25lIC0+IE5vX3ByZWNpc2lvblxuICB8IFNvbWUgbmRlYyAtPiBMaXRfcHJlY2lzaW9uIG5kZWNcblxuKCogVHVybiBhbiBpZ25vcmVkIHBhcmFtIGludG8gaXRzIGVxdWl2YWxlbnQgbm90LWlnbm9yZWQgZm9ybWF0IG5vZGUuICopXG4oKiBVc2VkIGZvciBmb3JtYXQgcHJldHR5LXByaW50aW5nIGFuZCBTY2FuZi4gKilcbmxldCBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSAuXG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT4gKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhcmFtX2Zvcm1hdF9lYmIgPVxuZnVuIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDaGFyIGZtdClcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENhbWxfY2hhciBmbXQpXG4gIHwgSWdub3JlZF9zdHJpbmcgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFN0cmluZyAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDYW1sX3N0cmluZyAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2ludCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoSW50IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfaW50MzIgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChJbnQzMiAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKE5hdGl2ZWludCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2ludDY0IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoSW50NjQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9mbG9hdCAocGFkX29wdCwgcHJlY19vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEZsb2F0ICgoRmxvYXRfZmxhZ18sIEZsb2F0X2YpLFxuICAgICAgICAgICAgICBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBwcmVjX29mX3ByZWNfb3B0IHByZWNfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfYm9vbCBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQm9vbCAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCBmbXQpKVxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgZm10KSlcbiAgfCBJZ25vcmVkX3JlYWRlciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFJlYWRlciBmbXQpXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdCkpXG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXQpKVxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX25leHRfY2hhciBmbXQpXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFR5cGVzICopXG5cbnR5cGUgKCdiLCAnYykgYWNjX2Zvcm1hdHRpbmdfZ2VuID1cbiAgfCBBY2Nfb3Blbl90YWcgb2YgKCdiLCAnYykgYWNjXG4gIHwgQWNjX29wZW5fYm94IG9mICgnYiwgJ2MpIGFjY1xuXG4oKiBSZXZlcnNlZCBsaXN0IG9mIHByaW50aW5nIGF0b21zLiAqKVxuKCogVXNlZCB0byBhY2N1bXVsYXRlIHByaW50ZiBhcmd1bWVudHMuICopXG5hbmQgKCdiLCAnYykgYWNjID1cbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgb2YgKCdiLCAnYykgYWNjICogZm9ybWF0dGluZ19saXRcbiAgICAgICgqIFNwZWNpYWwgZm10dGluZyAoYm94KSAqKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiBvZiAoJ2IsICdjKSBhY2MgKiAoJ2IsICdjKSBhY2NfZm9ybWF0dGluZ19nZW5cbiAgICAgICgqIFNwZWNpYWwgZm10dGluZyAoYm94KSAqKVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmcgICAgICgqIExpdGVyYWwgc3RyaW5nICopXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAgIG9mICgnYiwgJ2MpIGFjYyAqIGNoYXIgICAgICAgKCogTGl0ZXJhbCBjaGFyICopXG4gIHwgQWNjX2RhdGFfc3RyaW5nICAgIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZyAgICAgKCogR2VuZXJhdGVkIHN0cmluZyAqKVxuICB8IEFjY19kYXRhX2NoYXIgICAgICBvZiAoJ2IsICdjKSBhY2MgKiBjaGFyICAgICAgICgqIEdlbmVyYXRlZCBjaGFyICopXG4gIHwgQWNjX2RlbGF5ICAgICAgICAgIG9mICgnYiwgJ2MpIGFjYyAqICgnYiAtPiAnYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIERlbGF5ZWQgcHJpbnRpbmcgKCVhLCAldCkgKilcbiAgfCBBY2NfZmx1c2ggICAgICAgICAgb2YgKCdiLCAnYykgYWNjICAgICAgICAgICAgICAoKiBGbHVzaCAqKVxuICB8IEFjY19pbnZhbGlkX2FyZyAgICBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmdcbiAgICAgICgqIFJhaXNlIEludmFsaWRfYXJndW1lbnQgbXNnICopXG4gIHwgRW5kX29mX2FjY1xuXG4oKiBMaXN0IG9mIGhldGVyb2dlbmVvdXMgdmFsdWVzLiAqKVxuKCogVXNlZCB0byBhY2N1bXVsYXRlIHNjYW5mIGNhbGxiYWNrIGFyZ3VtZW50cy4gKilcbnR5cGUgKCdhLCAnYikgaGV0ZXJfbGlzdCA9XG4gIHwgQ29ucyA6ICdjICogKCdhLCAnYikgaGV0ZXJfbGlzdCAtPiAoJ2MgLT4gJ2EsICdiKSBoZXRlcl9saXN0XG4gIHwgTmlsIDogKCdiLCAnYikgaGV0ZXJfbGlzdFxuXG4oKiBFeGlzdGVudGlhbCBCbGFjayBCb3hlcy4gKilcbigqIFVzZWQgdG8gYWJzdHJhY3Qgc29tZSBleGlzdGVudGlhbCB0eXBlIHBhcmFtZXRlcnMuICopXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcgYW5kIGFuIGZtdHR5LiAqKVxuKCogU2VlIHRoZSB0eXBlX3BhZGRpbmcgZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRkaW5nX2ZtdHR5X2ViYiA9IFBhZGRpbmdfZm10dHlfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkZGluZ19mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGFuIGZtdHR5LiAqKVxuKCogU2VlIHRoZSB0eXBlX3BhZHByZWMgZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRwcmVjX2ZtdHR5X2ViYiA9IFBhZHByZWNfZm10dHlfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ3opIHByZWNpc2lvbiAqICgneiwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkcHJlY19mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZyBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcGFkZGluZ19mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2UsICdmKSBwYWRkaW5nX2ZtdF9lYmIgPSBQYWRkaW5nX2ZtdF9FQkIgOlxuICAgICAoXywgJ3ggLT4gJ2EpIHBhZGRpbmcgKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZSwgJ2YpIHBhZGRpbmdfZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwcmVjaXNpb24gYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2UsICdmKSBwcmVjaXNpb25fZm10X2ViYiA9IFByZWNpc2lvbl9mbXRfRUJCIDpcbiAgICAgKF8sICd4IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZSwgJ2YpIHByZWNpc2lvbl9mbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgncCwgJ2IsICdjLCAnZSwgJ2YpIHBhZHByZWNfZm10X2ViYiA9IFBhZHByZWNfZm10X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICdwIC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgncCwgJ2IsICdjLCAnZSwgJ2YpIHBhZHByZWNfZm10X2ViYlxuXG4oKiBBYnN0cmFjdCB0aGUgJ2EgYW5kICdkIHBhcmFtZXRlcnMgb2YgYW4gZm10LiAqKVxuKCogT3V0cHV0IHR5cGUgb2YgdGhlIGZvcm1hdCBwYXJzaW5nIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2IsICdjLCAnZSwgJ2YpIGZtdF9lYmIgPSBGbXRfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ2IsICdjLCAnZSwgJ2YpIGZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGFuIGZtdHR5IGFuZCBhbiBmbXQuICopXG4oKiBTZWUgdGhlIHR5cGVfZm9ybWF0X2dlbiBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmIgPSBGbXRfZm10dHlfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGZtdCAqXG4gICAgICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10X2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYW4gZm10dHkgYW5kIGFuIGZtdC4gKilcbigqIFNlZSB0aGUgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9mbXRfZWJiID0gRm10dHlfZm10X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBmbXR0eSAqXG4gICAgICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXRfZm10dHlfZWJiIC0+XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9mbXRfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBmbXR0eSB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgZm9ybWF0IHR5cGVzLiAqKVxudHlwZSBmbXR0eV9lYmIgPSBGbXR0eV9FQkIgOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT4gZm10dHlfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBwYWRkaW5nIHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBwYWRkaW5ncy4gKilcbnR5cGUgcGFkZGluZ19lYmIgPSBQYWRkaW5nX0VCQiA6ICgnYSwgJ2IpIHBhZGRpbmcgLT4gcGFkZGluZ19lYmJcblxuKCogQWJzdHJhY3QgYWxsIHByZWNpc2lvbiB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgcHJlY2lzaW9ucy4gKilcbnR5cGUgcHJlY2lzaW9uX2ViYiA9IFByZWNpc2lvbl9FQkIgOiAoJ2EsICdiKSBwcmVjaXNpb24gLT4gcHJlY2lzaW9uX2ViYlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIENvbnN0YW50cyAqKVxuXG4oKiBEZWZhdWx0IHByZWNpc2lvbiBmb3IgZmxvYXQgcHJpbnRpbmcuICopXG5sZXQgZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYgPVxuICBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HIHwgRmxvYXRfaCB8IEZsb2F0X0hcbiAgfCBGbG9hdF9DRiAtPiAtNlxuICAoKiBGb3IgJWggJUggYW5kICUjRiBmb3JtYXRzLCBhIG5lZ2F0aXZlIHByZWNpc2lvbiBtZWFucyBcImFzIG1hbnkgZGlnaXRzIGFzXG4gICAgIG5lY2Vzc2FyeVwiLiAgRm9yIHRoZSBvdGhlciBGUCBmb3JtYXRzLCB3ZSB0YWtlIHRoZSBhYnNvbHV0ZSB2YWx1ZVxuICAgICBvZiB0aGUgcHJlY2lzaW9uLCBoZW5jZSA2IGRpZ2l0cyBieSBkZWZhdWx0LiAqKVxuICB8IEZsb2F0X0YgLT4gMTJcbiAgKCogRGVmYXVsdCBwcmVjaXNpb24gZm9yIE9DYW1sIGZsb2F0IHByaW50aW5nICglRikuICopXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRXh0ZXJuYWxzICopXG5cbmV4dGVybmFsIGZvcm1hdF9mbG9hdDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfaW50MzI6IHN0cmluZyAtPiBpbnQzMiAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaW50MzJfZm9ybWF0XCJcbmV4dGVybmFsIGZvcm1hdF9uYXRpdmVpbnQ6IHN0cmluZyAtPiBuYXRpdmVpbnQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX25hdGl2ZWludF9mb3JtYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDY0OiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG5leHRlcm5hbCBoZXhzdHJpbmdfb2ZfZmxvYXQ6IGZsb2F0IC0+IGludCAtPiBjaGFyIC0+IHN0cmluZ1xuICA9IFwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXRcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgKCogVG9vbHMgdG8gcHJldHR5LXByaW50IGZvcm1hdHMgKilcblxuKCogVHlwZSBvZiBleHRlbnNpYmxlIGNoYXJhY3RlciBidWZmZXJzLiAqKVxudHlwZSBidWZmZXIgPSB7XG4gIG11dGFibGUgaW5kIDogaW50O1xuICBtdXRhYmxlIGJ5dGVzIDogYnl0ZXM7XG59XG5cbigqIENyZWF0ZSBhIGZyZXNoIGJ1ZmZlci4gKilcbmxldCBidWZmZXJfY3JlYXRlIGluaXRfc2l6ZSA9IHsgaW5kID0gMDsgYnl0ZXMgPSBCeXRlcy5jcmVhdGUgaW5pdF9zaXplIH1cblxuKCogQ2hlY2sgc2l6ZSBvZiB0aGUgYnVmZmVyIGFuZCBncm93IGl0IGlmIG5lZWRlZC4gKilcbmxldCBidWZmZXJfY2hlY2tfc2l6ZSBidWYgb3ZlcmhlYWQgPVxuICBsZXQgbGVuID0gQnl0ZXMubGVuZ3RoIGJ1Zi5ieXRlcyBpblxuICBsZXQgbWluX2xlbiA9IGJ1Zi5pbmQgKyBvdmVyaGVhZCBpblxuICBpZiBtaW5fbGVuID4gbGVuIHRoZW4gKFxuICAgIGxldCBuZXdfbGVuID0gSW50Lm1heCAobGVuICogMikgbWluX2xlbiBpblxuICAgIGxldCBuZXdfc3RyID0gQnl0ZXMuY3JlYXRlIG5ld19sZW4gaW5cbiAgICBCeXRlcy5ibGl0IGJ1Zi5ieXRlcyAwIG5ld19zdHIgMCBsZW47XG4gICAgYnVmLmJ5dGVzIDwtIG5ld19zdHI7XG4gIClcblxuKCogQWRkIHRoZSBjaGFyYWN0ZXIgYGMnIHRvIHRoZSBidWZmZXIgYGJ1ZicuICopXG5sZXQgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjID1cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIDE7XG4gIEJ5dGVzLnNldCBidWYuYnl0ZXMgYnVmLmluZCBjO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyAxXG5cbigqIEFkZCB0aGUgc3RyaW5nIGBzJyB0byB0aGUgYnVmZmVyIGBidWYnLiAqKVxubGV0IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzID1cbiAgbGV0IHN0cl9sZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIHN0cl9sZW47XG4gIFN0cmluZy5ibGl0IHMgMCBidWYuYnl0ZXMgYnVmLmluZCBzdHJfbGVuO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyBzdHJfbGVuXG5cbigqIEdldCB0aGUgY29udGVudCBvZiB0aGUgYnVmZmVyLiAqKVxubGV0IGJ1ZmZlcl9jb250ZW50cyBidWYgPVxuICBCeXRlcy5zdWJfc3RyaW5nIGJ1Zi5ieXRlcyAwIGJ1Zi5pbmRcblxuKCoqKilcblxuKCogQ29udmVydCBhbiBpbnRlZ2VyIGNvbnZlcnNpb24gdG8gY2hhci4gKilcbmxldCBjaGFyX29mX2ljb252IGljb252ID0gbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkIHwgSW50X0NkIC0+ICdkJyB8IEludF9pIHwgSW50X3BpIHwgSW50X3NpXG4gIHwgSW50X0NpIC0+ICdpJyB8IEludF94IHwgSW50X0N4IC0+ICd4JyB8IEludF9YIHwgSW50X0NYIC0+ICdYJyB8IEludF9vXG4gIHwgSW50X0NvIC0+ICdvJyB8IEludF91IHwgSW50X0N1IC0+ICd1J1xuXG4oKiBDb252ZXJ0IGEgZmxvYXQgY29udmVyc2lvbiB0byBjaGFyLiAqKVxuKCogYGNGJyB3aWxsIGJlICdGJyBmb3IgZGlzcGxheWluZyBmb3JtYXQgYW5kICdnJyB0byBjYWxsIGxpYmMgcHJpbnRmICopXG5sZXQgY2hhcl9vZl9mY29udiA/KGNGPSdGJykgZmNvbnYgPSBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2YgLT4gJ2YnIHwgRmxvYXRfZSAtPiAnZSdcbiAgfCBGbG9hdF9FIC0+ICdFJyB8IEZsb2F0X2cgLT4gJ2cnXG4gIHwgRmxvYXRfRyAtPiAnRycgfCBGbG9hdF9GIC0+IGNGXG4gIHwgRmxvYXRfaCAtPiAnaCcgfCBGbG9hdF9IIC0+ICdIJ1xuICB8IEZsb2F0X0NGIC0+ICdGJ1xuXG5cbigqIENvbnZlcnQgYSBzY2FubmluZyBjb3VudGVyIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIgPSBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgIC0+ICdsJ1xuICB8IENoYXJfY291bnRlciAgLT4gJ24nXG4gIHwgVG9rZW5fY291bnRlciAtPiAnTidcblxuKCoqKilcblxuKCogUHJpbnQgYSBjaGFyX3NldCBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBPQ2FtbCBmb3JtYXQgbGV4aWNhbCBjb252ZW50aW9uLiAqKVxubGV0IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQgPVxuICBsZXQgcmVjIHByaW50X3N0YXJ0IHNldCA9XG4gICAgbGV0IGlzX2Fsb25lIGMgPVxuICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXIgPSBDaGFyLihjaHIgKGNvZGUgYyAtIDEpLCBjaHIgKGNvZGUgYyArIDEpKSBpblxuICAgICAgaXNfaW5fY2hhcl9zZXQgc2V0IGNcbiAgICAgICYmIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IGJlZm9yZSAmJiBpc19pbl9jaGFyX3NldCBzZXQgYWZ0ZXIpIGluXG4gICAgaWYgaXNfYWxvbmUgJ10nIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSc7XG4gICAgcHJpbnRfb3V0IHNldCAxO1xuICAgIGlmIGlzX2Fsb25lICctJyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy0nO1xuICBhbmQgcHJpbnRfb3V0IHNldCBpID1cbiAgICBpZiBpIDwgMjU2IHRoZW5cbiAgICAgIGlmIGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaSkgdGhlbiBwcmludF9maXJzdCBzZXQgaVxuICAgICAgZWxzZSBwcmludF9vdXQgc2V0IChpICsgMSlcbiAgYW5kIHByaW50X2ZpcnN0IHNldCBpID1cbiAgICBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICdcXDI1NScgLT4gcHJpbnRfY2hhciBidWYgMjU1O1xuICAgIHwgJ10nIHwgJy0nIC0+IHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICB8IF8gLT4gcHJpbnRfc2Vjb25kIHNldCAoaSArIDEpO1xuICBhbmQgcHJpbnRfc2Vjb25kIHNldCBpID1cbiAgICBpZiBpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGkpIHRoZW5cbiAgICAgIG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgICAgfCAnXFwyNTUnIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIDI1NDtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgMjU1O1xuICAgICAgfCAnXScgfCAnLScgd2hlbiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgKGkgKyAxKSkpIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICAgIHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICAgIHwgXyB3aGVuIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCAoaSArIDEpKSkgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgaTtcbiAgICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDIpO1xuICAgICAgfCBfIC0+XG4gICAgICAgIHByaW50X2luIHNldCAoaSAtIDEpIChpICsgMik7XG4gICAgZWxzZSAoXG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgIClcbiAgYW5kIHByaW50X2luIHNldCBpIGogPVxuICAgIGlmIGogPSAyNTYgfHwgbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGopKSB0aGVuIChcbiAgICAgIHByaW50X2NoYXIgYnVmIGk7XG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaW50X29mX2NoYXIgJy0nKTtcbiAgICAgIHByaW50X2NoYXIgYnVmIChqIC0gMSk7XG4gICAgICBpZiBqIDwgMjU2IHRoZW4gcHJpbnRfb3V0IHNldCAoaiArIDEpO1xuICAgICkgZWxzZVxuICAgICAgcHJpbnRfaW4gc2V0IGkgKGogKyAxKTtcbiAgYW5kIHByaW50X2NoYXIgYnVmIGkgPSBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICclJyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgfCAnQCcgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0AnO1xuICAgIHwgYyAgIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgaW5cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnWyc7XG4gIHByaW50X3N0YXJ0IChcbiAgICBpZiBpc19pbl9jaGFyX3NldCBjaGFyX3NldCAnXFwwMDAnXG4gICAgdGhlbiAoIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ14nOyByZXZfY2hhcl9zZXQgY2hhcl9zZXQgKVxuICAgIGVsc2UgY2hhcl9zZXRcbiAgKTtcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSdcblxuKCoqKilcblxuKCogUHJpbnQgYSBwYWR0eSBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eSA9IG1hdGNoIHBhZHR5IHdpdGhcbiAgfCBMZWZ0ICAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICctJ1xuICB8IFJpZ2h0IC0+ICgpXG4gIHwgWmVyb3MgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnMCdcblxuKCogUHJpbnQgdGhlICdfJyBvZiBhbiBpZ25vcmVkIGZsYWcgaWYgbmVlZGVkLiAqKVxubGV0IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnID1cbiAgaWYgaWduX2ZsYWcgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICdfJ1xuXG4oKioqKVxuXG5sZXQgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSB3aWR0aCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgd2lkdGgpXG5cbigqKiopXG5cbigqIFByaW50IHBhZGRpbmcgaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wYWRkaW5nIDogdHlwZSBhIGIgLiBidWZmZXIgLT4gKGEsIGIpIHBhZGRpbmcgLT4gdW5pdCA9XG5mdW4gYnVmIHBhZCAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT4gKClcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIG4pIC0+XG4gICAgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgbik7XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBicHJpbnRfcGFkdHkgYnVmIHBhZHR5O1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyonXG5cbigqIFByaW50IHByZWNpc2lvbiBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3ByZWNpc2lvbiA6IHR5cGUgYSBiIC4gYnVmZmVyIC0+IChhLCBiKSBwcmVjaXNpb24gLT4gdW5pdCA9XG4gIGZ1biBidWYgcHJlYyAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gLT4gKClcbiAgfCBMaXRfcHJlY2lzaW9uIG4gLT5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcuJztcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgbik7XG4gIHwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIi4qXCJcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJywgJyAnIG9yICcjJyBhc3NvY2lhdGVkIHRvIGFuIGludCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udiA9IG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfcGQgfCBJbnRfcGkgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBJbnRfc2QgfCBJbnRfc2kgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnICdcbiAgfCBJbnRfQ3ggfCBJbnRfQ1ggfCBJbnRfQ28gfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyMnXG4gIHwgSW50X2QgfCBJbnRfaSB8IEludF94IHwgSW50X1ggfCBJbnRfbyB8IEludF91IC0+ICgpXG5cbigqIFByaW50IGFuIGNvbXBsZXRlIGludCBmb3JtYXQgaW4gYSBidWZmZXIgKGV4OiBcIiUzLipkXCIpLiAqKVxubGV0IGJwcmludF9pbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2ljb252IGljb252KVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQgZm9ybWF0IGluIGEgYnVmZmVyLiAqKVxubGV0IGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyBjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9pY29udiBpY29udilcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJywgJyAnIGFuZC9vciAnIycgYXNzb2NpYXRlZCB0byBhIGZsb2F0IGNvbnZlcnNpb24uICopXG5sZXQgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252ID1cbiAgYmVnaW4gbWF0Y2ggZnN0IGZjb252IHdpdGhcbiAgfCBGbG9hdF9mbGFnX3AgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBGbG9hdF9mbGFnX3MgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnICdcbiAgfCBGbG9hdF9mbGFnXyAtPiAoKSBlbmQ7XG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfQ0YgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnIydcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfR1xuICB8IEZsb2F0X0YgfCBGbG9hdF9oIHwgRmxvYXRfSCAtPiAoKVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZsb2F0IGZvcm1hdCBpbiBhIGJ1ZmZlciAoZXg6IFwiJSsqLjNmXCIpLiAqKVxubGV0IGJwcmludF9mbG9hdF9mbXQgYnVmIGlnbl9mbGFnIGZjb252IHBhZCBwcmVjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfZmNvbnYgZmNvbnYpXG5cbigqIENvbXB1dGUgdGhlIGxpdGVyYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgRm9ybWF0dGluZ19saXQuICopXG4oKiBVc2VkIGJ5IFByaW50ZiBhbmQgU2NhbmYgd2hlcmUgZm9ybWF0dGluZyBpcyBub3QgaW50ZXJwcmV0ZWQuICopXG5sZXQgc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZvcm1hdHRpbmdfbGl0ID0gbWF0Y2ggZm9ybWF0dGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgIC0+IFwiQF1cIlxuICB8IENsb3NlX3RhZyAgICAgICAgICAgIC0+IFwiQH1cIlxuICB8IEJyZWFrIChzdHIsIF8sIF8pICAgIC0+IHN0clxuICB8IEZGbHVzaCAgICAgICAgICAgICAgIC0+IFwiQD9cIlxuICB8IEZvcmNlX25ld2xpbmUgICAgICAgIC0+IFwiQFxcblwiXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgLT4gXCJALlwiXG4gIHwgTWFnaWNfc2l6ZSAoc3RyLCBfKSAgLT4gc3RyXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgLT4gXCJAQFwiXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgLT4gXCJAJVwiXG4gIHwgU2Nhbl9pbmRpYyBjIC0+IFwiQFwiIF4gKFN0cmluZy5tYWtlIDEgYylcblxuKCoqKilcblxuKCogUHJpbnQgYSBsaXRlcmFsIGNoYXIgaW4gYSBidWZmZXIsIGVzY2FwZSAnJScgYnkgXCIlJVwiLiAqKVxubGV0IGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIGNociA9IG1hdGNoIGNociB3aXRoXG4gIHwgJyUnIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUlXCJcbiAgfCBfIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgY2hyXG5cbigqIFByaW50IGEgbGl0ZXJhbCBzdHJpbmcgaW4gYSBidWZmZXIsIGVzY2FwZSBhbGwgJyUnIGJ5IFwiJSVcIi4gKilcbmxldCBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIHN0ciA9XG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHN0ciAtIDEgZG9cbiAgICBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBzdHIuW2ldXG4gIGRvbmVcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHByZXR0eS1wcmludGluZyAqKVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZvcm1hdCB0eXBlIChhbiBmbXR0eSkgaW4gYSBidWZmZXIuICopXG5sZXQgcmVjIGJwcmludF9mbXR0eSA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgLlxuICAgIGJ1ZmZlciAtPiAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCkgZm10dHlfcmVsIC0+IHVuaXQgPVxuZnVuIGJ1ZiBmbXR0eSAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0ICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWNcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlc1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludF90eSByZXN0ICAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVpXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWxpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlbmlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludDY0X3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVMaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWZcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBCb29sX3R5IHJlc3QgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlQlwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEFscGhhX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVhXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXRcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlP1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFJlYWRlcl90eSByZXN0ICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVyXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJV9yXCI7XG4gICAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgRm9ybWF0X2FyZ190eSAoc3ViX2ZtdHR5LCByZXN0KSAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV7XCI7IGJwcmludF9mbXR0eSBidWYgc3ViX2ZtdHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV9XCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHN1Yl9mbXR0eSwgXywgcmVzdCkgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlKFwiOyBicHJpbnRfZm10dHkgYnVmIHN1Yl9mbXR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlKVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBFbmRfb2ZfZm10dHkgLT4gKClcblxuKCoqKilcblxubGV0IHJlYyBpbnRfb2ZfY3VzdG9tX2FyaXR5IDogdHlwZSBhIGIgYyAuXG4gIChhLCBiLCBjKSBjdXN0b21fYXJpdHkgLT4gaW50ID1cbiAgZnVuY3Rpb25cbiAgfCBDdXN0b21femVybyAtPiAwXG4gIHwgQ3VzdG9tX3N1Y2MgeCAtPiAxICsgaW50X29mX2N1c3RvbV9hcml0eSB4XG5cbigqIFByaW50IGEgY29tcGxldGUgZm9ybWF0IGluIGEgYnVmZmVyLiAqKVxubGV0IGJwcmludF9mbXQgYnVmIGZtdCA9XG4gIGxldCByZWMgZm10aXRlciA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBib29sIC0+IHVuaXQgPVxuICBmdW4gZm10IGlnbl9mbGFnIC0+IG1hdGNoIGZtdCB3aXRoXG4gICAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3MnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ1MnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfaW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWM7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnbCc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ24nO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ0wnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfZmxvYXRfZm10IGJ1ZiBpZ25fZmxhZyBmY29udiBwYWQgcHJlYztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgQ2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdjJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0MnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdCJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEFscGhhIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ2EnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBUaGV0YSByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICd0JzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgLT5cbiAgICAgIGZvciBfaSA9IDEgdG8gaW50X29mX2N1c3RvbV9hcml0eSBhcml0eSBkb1xuICAgICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJz8nO1xuICAgICAgZG9uZTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFJlYWRlciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdyJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRmx1c2ggcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSFcIjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgc3RyO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuICAgIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBjaHI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3snO1xuICAgICAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ30nO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0OyBidWZmZXJfYWRkX2NoYXIgYnVmICcoJztcbiAgICAgIGJwcmludF9mbXR0eSBidWYgZm10dHk7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICcpJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiB3aWR0aF9vcHQ7IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQ7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIpO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBcIjBjXCI7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgICAgbGV0IFBhcmFtX2Zvcm1hdF9FQkIgZm10JyA9IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdCBpblxuICAgICAgZm10aXRlciBmbXQnIHRydWU7XG5cbiAgICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiAoc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQpO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuICAgIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpIC0+XG4gICAgICBiZWdpbiBtYXRjaCBmbXRpbmdfZ2VuIHdpdGhcbiAgICAgIHwgT3Blbl90YWcgKEZvcm1hdCAoXywgc3RyKSkgLT5cbiAgICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiQHtcIjsgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHN0clxuICAgICAgfCBPcGVuX2JveCAoRm9ybWF0IChfLCBzdHIpKSAtPlxuICAgICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCJAW1wiOyBidWZmZXJfYWRkX3N0cmluZyBidWYgc3RyXG4gICAgICBlbmQ7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IEVuZF9vZl9mb3JtYXQgLT4gKClcblxuICBpbiBmbXRpdGVyIGZtdCBmYWxzZVxuXG4oKioqKVxuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHRvIHN0cmluZy4gKilcbmxldCBzdHJpbmdfb2ZfZm10IGZtdCA9XG4gIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gIGJwcmludF9mbXQgYnVmIGZtdDtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUeXBlIGV4dHJhY3Rpb24gKilcblxudHlwZSAoXywgXykgZXEgPSBSZWZsIDogKCdhLCAnYSkgZXFcblxuKCogSW52YXJpYW50OiB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBpZGVudGl0eSBvbiB2YWx1ZXMuXG5cbiAgIEluIHBhcnRpY3VsYXIsIGlmICh0eTEsIHR5MikgaGF2ZSBlcXVhbCB2YWx1ZXMsIHRoZW5cbiAgICh0cmFucyAoc3ltbSB0eTEpIHR5MikgcmVzcGVjdHMgdGhlICd0cmFucycgcHJlY29uZGl0aW9uLiAqKVxubGV0IHJlYyBzeW1tIDogdHlwZSBhMSBiMSBjMSBkMSBlMSBmMSBhMiBiMiBjMiBkMiBlMiBmMiAuXG4gICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbi0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLFxuICAgIGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdHR5X3JlbFxuPSBmdW5jdGlvblxuICB8IENoYXJfdHkgcmVzdCAtPiBDaGFyX3R5IChzeW1tIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT4gSW50X3R5IChzeW1tIHJlc3QpXG4gIHwgSW50MzJfdHkgcmVzdCAtPiBJbnQzMl90eSAoc3ltbSByZXN0KVxuICB8IEludDY0X3R5IHJlc3QgLT4gSW50NjRfdHkgKHN5bW0gcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPiBOYXRpdmVpbnRfdHkgKHN5bW0gcmVzdClcbiAgfCBGbG9hdF90eSByZXN0IC0+IEZsb2F0X3R5IChzeW1tIHJlc3QpXG4gIHwgQm9vbF90eSByZXN0IC0+IEJvb2xfdHkgKHN5bW0gcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPiBTdHJpbmdfdHkgKHN5bW0gcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+IFRoZXRhX3R5IChzeW1tIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPiBBbHBoYV90eSAoc3ltbSByZXN0KVxuICB8IEFueV90eSByZXN0IC0+IEFueV90eSAoc3ltbSByZXN0KVxuICB8IFJlYWRlcl90eSByZXN0IC0+IFJlYWRlcl90eSAoc3ltbSByZXN0KVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT4gSWdub3JlZF9yZWFkZXJfdHkgKHN5bW0gcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgc3ltbSByZXN0KVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTIsIHR5MSwgc3ltbSByZXN0KVxuICB8IEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcblxubGV0IHJlYyBmbXR0eV9yZWxfZGV0IDogdHlwZSBhMSBiIGMgZDEgZTEgZjEgYTIgZDIgZTIgZjIgLlxuICAoYTEsIGIsIGMsIGQxLCBlMSwgZjEsXG4gICBhMiwgYiwgYywgZDIsIGUyLCBmMikgZm10dHlfcmVsIC0+XG4gICAgKChmMSwgZjIpIGVxIC0+IChhMSwgYTIpIGVxKVxuICAqICgoYTEsIGEyKSBlcSAtPiAoZjEsIGYyKSBlcSlcbiAgKiAoKGUxLCBlMikgZXEgLT4gKGQxLCBkMikgZXEpXG4gICogKChkMSwgZDIpIGVxIC0+IChlMSwgZTIpIGVxKVxuPSBmdW5jdGlvblxuICB8IEVuZF9vZl9mbXR0eSAtPlxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKVxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG5cbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcbiAgfCBGb3JtYXRfYXJnX3R5IChfdHksIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICBsZXQgYWcsIGdhLCBkaiwgamQgPSBmbXR0eV9yZWxfZGV0IHR5IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBsZXQgUmVmbCA9IGFnIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZ2EgUmVmbCBpbiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBsZXQgUmVmbCA9IGRqIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gamQgUmVmbCBpbiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcblxuKCogUHJlY29uZGl0aW9uOiB3ZSBhc3N1bWUgdGhhdCB0aGUgdHdvIGZtdHR5X3JlbCBhcmd1bWVudHMgaGF2ZSBlcXVhbFxuICAgdmFsdWVzIChhdCBwb3NzaWJseSBkaXN0aW5jdCB0eXBlcyk7IHRoaXMgaW52YXJpYW50IGNvbWVzIGZyb20gdGhlIHdheVxuICAgZm10dHlfcmVsIHdpdG5lc3NlcyBhcmUgcHJvZHVjZWQgYnkgdGhlIHR5cGUtY2hlY2tlclxuXG4gICBUaGUgY29kZSBiZWxvdyB1c2VzIChhc3NlcnQgZmFsc2UpIHdoZW4gdGhpcyBhc3N1bXB0aW9uIGlzIGJyb2tlbi4gVGhlXG4gICBjb2RlIHBhdHRlcm4gaXMgdGhlIGZvbGxvd2luZzpcblxuICAgICB8IEZvbyB4LCBGb28geSAtPlxuICAgICAgICgqIGNhc2Ugd2hlcmUgaW5kZWVkIGJvdGggdmFsdWVzXG4gICAgICAgICAgc3RhcnQgd2l0aCBjb25zdHJ1Y3RvciBGb28gKilcbiAgICAgfCBGb28gXywgX1xuICAgICB8IF8sIEZvbyBfIC0+XG4gICAgICAgKCogZGlmZmVyZW50IGhlYWQgY29uc3RydWN0b3JzOiBicm9rZW4gcHJlY29uZGl0aW9uICopXG4gICAgICAgYXNzZXJ0IGZhbHNlXG4qKVxuYW5kIHRyYW5zIDogdHlwZVxuICBhMSBiMSBjMSBkMSBlMSBmMVxuICBhMiBiMiBjMiBkMiBlMiBmMlxuICBhMyBiMyBjMyBkMyBlMyBmM1xuLlxuICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4tPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMixcbiAgICBhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eV9yZWxcbi0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5X3JlbFxuPSBmdW4gdHkxIHR5MiAtPiBtYXRjaCB0eTEsIHR5MiB3aXRoXG4gIHwgQ2hhcl90eSByZXN0MSwgQ2hhcl90eSByZXN0MiAtPiBDaGFyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBTdHJpbmdfdHkgcmVzdDEsIFN0cmluZ190eSByZXN0MiAtPiBTdHJpbmdfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEJvb2xfdHkgcmVzdDEsIEJvb2xfdHkgcmVzdDIgLT4gQm9vbF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50X3R5IHJlc3QxLCBJbnRfdHkgcmVzdDIgLT4gSW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnQzMl90eSByZXN0MSwgSW50MzJfdHkgcmVzdDIgLT4gSW50MzJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludDY0X3R5IHJlc3QxLCBJbnQ2NF90eSByZXN0MiAtPiBJbnQ2NF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QxLCBOYXRpdmVpbnRfdHkgcmVzdDIgLT4gTmF0aXZlaW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBGbG9hdF90eSByZXN0MSwgRmxvYXRfdHkgcmVzdDIgLT4gRmxvYXRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuXG4gIHwgQWxwaGFfdHkgcmVzdDEsIEFscGhhX3R5IHJlc3QyIC0+IEFscGhhX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBBbHBoYV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEFscGhhX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBUaGV0YV90eSByZXN0MSwgVGhldGFfdHkgcmVzdDIgLT4gVGhldGFfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFRoZXRhX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgVGhldGFfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEFueV90eSByZXN0MSwgQW55X3R5IHJlc3QyIC0+IEFueV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQW55X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgQW55X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBSZWFkZXJfdHkgcmVzdDEsIFJlYWRlcl90eSByZXN0MiAtPiBSZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFJlYWRlcl90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIFJlYWRlcl90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdDEsIElnbm9yZWRfcmVhZGVyX3R5IHJlc3QyIC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgSWdub3JlZF9yZWFkZXJfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEZvcm1hdF9hcmdfdHkgKHR5MSwgcmVzdDEpLCBGb3JtYXRfYXJnX3R5ICh0eTIsIHJlc3QyKSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHRyYW5zIHR5MSB0eTIsIHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZvcm1hdF9hcmdfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBGb3JtYXRfYXJnX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MTEsIHR5MTIsIHJlc3QxKSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MjEsIHR5MjIsIHJlc3QyKSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MTIpIHR5MjEgaW5cbiAgICBsZXQgXywgZjIsIF8sIGY0ID0gZm10dHlfcmVsX2RldCB0eSBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxMSwgdHkyMiwgdHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRm9ybWF0X3N1YnN0X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBFbmRfb2ZfZm10dHksIEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcbiAgfCBFbmRfb2ZfZm10dHksIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRW5kX29mX2ZtdHR5IC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgcmVjIGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gZm9ybWF0dGluZ19nZW4gLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSAtPiBmbXR0eV9vZl9mbXQgZm10XG5cbigqIEV4dHJhY3QgdGhlIHR5cGUgcmVwcmVzZW50YXRpb24gKGFuIGZtdHR5KSBvZiBhIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9mbXQgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGZtdHR5IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG5cbiAgfCBJbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEludDMyIChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludDMyX3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IE5hdGl2ZWludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChOYXRpdmVpbnRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgSW50NjQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50NjRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgRmxvYXQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoRmxvYXRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG5cbiAgfCBDaGFyIHJlc3QgICAgICAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBDYW1sX2NoYXIgcmVzdCAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBCb29sIChwYWQsIHJlc3QpICAgICAgICAgICAtPlxuICAgICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKEJvb2xfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcbiAgfCBBbHBoYSByZXN0ICAgICAgICAgICAgICAgICAtPiBBbHBoYV90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgVGhldGEgcmVzdCAgICAgICAgICAgICAgICAgLT4gVGhldGFfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpICAgIC0+IGZtdHR5X29mX2N1c3RvbSBhcml0eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgUmVhZGVyIHJlc3QgICAgICAgICAgICAgICAgLT4gUmVhZGVyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEZvcm1hdF9hcmcgKF8sIHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHksIHR5LCBmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEZsdXNoIHJlc3QgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpICAgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT4gU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPiBJbnRfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgIC0+IGZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0XG4gIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgIC0+XG4gICAgY29uY2F0X2ZtdHR5IChmbXR0eV9vZl9mb3JtYXR0aW5nX2dlbiBmbXRpbmdfZ2VuKSAoZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBFbmRfb2ZfZm9ybWF0ICAgICAgICAgICAgICAtPiBFbmRfb2ZfZm10dHlcblxuYW5kIGZtdHR5X29mX2N1c3RvbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgKHksIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBhcml0eSBmbXR0eSAtPiBtYXRjaCBhcml0eSB3aXRoXG4gIHwgQ3VzdG9tX3plcm8gLT4gZm10dHlcbiAgfCBDdXN0b21fc3VjYyBhcml0eSAtPiBBbnlfdHkgKGZtdHR5X29mX2N1c3RvbSBhcml0eSBmbXR0eSlcblxuKCogRXh0cmFjdCB0aGUgZm10dHkgb2YgYW4gaWdub3JlZCBwYXJhbWV0ZXIgZm9sbG93ZWQgYnkgdGhlIHJlc3Qgb2ZcbiAgIHRoZSBmb3JtYXQuICopXG5hbmQgZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiBjb25jYXRfZm10dHkgZm10dHkgKGZtdHR5X29mX2ZtdCBmbXQpXG4gIHwgSWdub3JlZF9yZWFkZXIgICAgICAgICAgICAgICAgICAtPiBJZ25vcmVkX3JlYWRlcl90eSAoZm10dHlfb2ZfZm10IGZtdClcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcblxuKCogQWRkIGFuIEludF90eSBub2RlIGlmIHBhZGRpbmcgaXMgdGFrZW4gYXMgYW4gZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqc1wiKS4gKilcbmFuZCBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IDogdHlwZSB4IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgYSkgcGFkZGluZyAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKHgsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbiAgZnVuIHBhZCBmbXR0eSAtPiBtYXRjaCBwYWQgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAgICAtPiBmbXR0eVxuICAgIHwgTGl0X3BhZGRpbmcgXyAtPiBmbXR0eVxuICAgIHwgQXJnX3BhZGRpbmcgXyAtPiBJbnRfdHkgZm10dHlcblxuKCogQWRkIGFuIEludF90eSBub2RlIGlmIHByZWNpc2lvbiBpcyB0YWtlbiBhcyBhbiBleHRyYSBhcmd1bWVudCAoZXg6IFwiJS4qZlwiKS4qKVxuYW5kIGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSA6IHR5cGUgeCBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIGEpIHByZWNpc2lvbiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKHgsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbiAgZnVuIHByZWMgZm10dHkgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgfCBOb19wcmVjaXNpb24gICAgLT4gZm10dHlcbiAgICB8IExpdF9wcmVjaXNpb24gXyAtPiBmbXR0eVxuICAgIHwgQXJnX3ByZWNpc2lvbiAgIC0+IEludF90eSBmbXR0eVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCB0eXBpbmcgKilcblxuKCogRXhjZXB0aW9uIHJhaXNlZCB3aGVuIGEgZm9ybWF0IGRvZXMgbm90IG1hdGNoIGEgZ2l2ZW4gZm9ybWF0IHR5cGUuICopXG5leGNlcHRpb24gVHlwZV9taXNtYXRjaFxuXG4oKiBUeXBlIGEgcGFkZGluZy4gKilcbigqIFRha2UgYW4gSW50X3R5IGZyb20gdGhlIGZtdHR5IGlmIHRoZSBpbnRlZ2VyIHNob3VsZCBiZSBrZXB0IGFzIGFyZ3VtZW50LiAqKVxuKCogUmFpc2UgVHlwZV9taXNtYXRjaCBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgdHlwZV9wYWRkaW5nIDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhZGRpbmdfZm10dHlfZWJiID1cbmZ1biBwYWQgZm10dHkgLT4gbWF0Y2ggcGFkLCBmbXR0eSB3aXRoXG4gIHwgTm9fcGFkZGluZywgXyAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoTm9fcGFkZGluZywgZm10dHkpXG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgXyAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoTGl0X3BhZGRpbmcgKHBhZHR5LHcpLGZtdHR5KVxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBJbnRfdHkgcmVzdCAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoQXJnX3BhZGRpbmcgcGFkdHkscmVzdClcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogQ29udmVydCBhICh1cGFkZGluZywgdXByZWNpc2lvbikgdG8gYSAocGFkZGluZywgcHJlY2lzaW9uKS4gKilcbigqIFRha2Ugb25lIG9yIHR3byBJbnRfdHkgZnJvbSB0aGUgZm10dHkgaWYgbmVlZGVkLiAqKVxuKCogUmFpc2UgVHlwZV9taXNtYXRjaCBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgdHlwZV9wYWRwcmVjIDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgeiAuXG4gICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6KSBwcmVjaXNpb24gLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhZHByZWNfZm10dHlfZWJiID1cbmZ1biBwYWQgcHJlYyBmbXR0eSAtPiBtYXRjaCBwcmVjLCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgfCBOb19wcmVjaXNpb24sIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgTm9fcHJlY2lzaW9uLCByZXN0KVxuICB8IExpdF9wcmVjaXNpb24gcCwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBMaXRfcHJlY2lzaW9uIHAsIHJlc3QpXG4gIHwgQXJnX3ByZWNpc2lvbiwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgSW50X3R5IHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgQXJnX3ByZWNpc2lvbiwgcmVzdClcbiAgfCBfLCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBUeXBlIGEgZm9ybWF0IGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbigqIElmIHR5cGluZyBzdWNjZWVkLCBnZW5lcmF0ZSBhIGNvcHkgb2YgdGhlIGZvcm1hdCB3aXRoIHRoZSBzYW1lXG4gICAgdHlwZSBwYXJhbWV0ZXJzIGFzIHRoZSBmbXR0eS4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHJlYyB0eXBlX2Zvcm1hdCA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eVxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10XG49IGZ1biBmbXQgZm10dHkgLT4gbWF0Y2ggdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSB3aXRoXG4gIHwgRm10X2ZtdHR5X0VCQiAoZm10JywgRW5kX29mX2ZtdHR5KSAtPiBmbXQnXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbmFuZCB0eXBlX2Zvcm1hdF9nZW4gOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjIgIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdF9mbXR0eV9lYmJcbj0gZnVuIGZtdCBmbXR0eSAtPiBtYXRjaCBmbXQsIGZtdHR5IHdpdGhcbiAgfCBDaGFyIGZtdF9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2hhciBmbXQnLCBmbXR0eScpXG4gIHwgQ2FtbF9jaGFyIGZtdF9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2FtbF9jaGFyIGZtdCcsIGZtdHR5JylcbiAgfCBTdHJpbmcgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIFN0cmluZ190eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoU3RyaW5nIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIFN0cmluZ190eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnQzMl90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50MzIgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBOYXRpdmVpbnRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50NjRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludDY0IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBGbG9hdF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgQm9vbCAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgQm9vbF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoQm9vbCAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEZsdXNoIGZtdF9yZXN0LCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZsdXNoIGZtdCcsIGZtdHR5JylcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTdHJpbmdfbGl0ZXJhbCAoc3RyLCBmbXQnKSwgZm10dHknKVxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2hhcl9saXRlcmFsIChjaHIsIGZtdCcpLCBmbXR0eScpXG5cbiAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHksIGZtdF9yZXN0KSxcbiAgICBGb3JtYXRfYXJnX3R5IChzdWJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiBzdWJfZm10dHkgPD4gRm10dHlfRUJCIHN1Yl9mbXR0eScgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHknLCBmbXQnKSwgZm10dHknKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5LCBmbXRfcmVzdCksXG4gICAgRm9ybWF0X3N1YnN0X3R5IChzdWJfZm10dHkxLCBfc3ViX2ZtdHR5MiwgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWJfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1Yl9mbXR0eTEpIHRoZW5cbiAgICAgIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPVxuICAgICAgdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IChlcmFzZV9yZWwgZm10dHlfcmVzdClcbiAgICBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5MSwgZm10JyksIGZtdHR5JylcbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IEFscGhhIGZtdF9yZXN0LCBBbHBoYV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEFscGhhIGZtdCcsIGZtdHR5JylcbiAgfCBUaGV0YSBmbXRfcmVzdCwgVGhldGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChUaGV0YSBmbXQnLCBmbXR0eScpXG5cbiAgKCogRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdCcpLCBmbXR0eScpXG4gIHwgRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmdfZ2VuLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICB0eXBlX2Zvcm1hdHRpbmdfZ2VuIGZvcm1hdHRpbmdfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3RcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgUmVhZGVyIGZtdF9yZXN0LCBSZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChSZWFkZXIgZm10JywgZm10dHknKVxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdF9yZXN0KSwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10JyksIGZtdHR5JylcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCksIEludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdCcpLCBmbXR0eScpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIHR5cGVfaWdub3JlZF9wYXJhbSBpZ24gcmVzdCBmbXR0eV9yZXN0XG5cbiAgfCBFbmRfb2ZfZm9ybWF0LCBmbXR0eV9yZXN0IC0+IEZtdF9mbXR0eV9FQkIgKEVuZF9vZl9mb3JtYXQsIGZtdHR5X3Jlc3QpXG5cbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuYW5kIHR5cGVfZm9ybWF0dGluZ19nZW4gOiB0eXBlIGExIGEzIGIxIGIzIGMxIGMzIGQxIGQzIGUxIGUyIGUzIGYxIGYyIGYzIC5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm9ybWF0dGluZ19nZW4gLT5cbiAgICAoZjEsIGIxLCBjMSwgZTEsIGUyLCBmMikgZm10IC0+XG4gICAgKGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5IC0+XG4gICAgKGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdF9mbXR0eV9lYmIgPVxuZnVuIGZvcm1hdHRpbmdfZ2VuIGZtdDAgZm10dHkwIC0+IG1hdGNoIGZvcm1hdHRpbmdfZ2VuIHdpdGhcbiAgfCBPcGVuX3RhZyAoRm9ybWF0IChmbXQxLCBzdHIpKSAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQyLCBmbXR0eTIpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDEgZm10dHkwIGluXG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDMsIGZtdHR5MykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MCBmbXR0eTIgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10Miwgc3RyKSksIGZtdDMpLCBmbXR0eTMpXG4gIHwgT3Blbl9ib3ggKEZvcm1hdCAoZm10MSwgc3RyKSkgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MiwgZm10dHkyKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQxIGZtdHR5MCBpblxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQzLCBmbXR0eTMpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDAgZm10dHkyIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdDIsIHN0cikpLCBmbXQzKSwgZm10dHkzKVxuXG4oKiBUeXBlIGFuIElnbm9yZWRfcGFyYW0gbm9kZSBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG5hbmQgdHlwZV9pZ25vcmVkX3BhcmFtIDogdHlwZSBwIHEgeCB5IHogdCB1IHYgYSBiIGMgZCBlIGYgLlxuICAgICh4LCB5LCB6LCB0LCBxLCBwKSBpZ25vcmVkIC0+XG4gICAgKHAsIHksIHosIHEsIHUsIHYpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXRfZm10dHlfZWJiID1cbmZ1biBpZ24gZm10IGZtdHR5IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQgXyAgICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQzMiBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgXyAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQ2NCBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mbG9hdCBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHkpIC0+XG4gICAgdHlwZV9pZ25vcmVkX3BhcmFtX29uZSAoSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHkpKSBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5KSAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHknLCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHkgZm10IGZtdHR5IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdCcpLFxuICAgICAgICAgICAgICAgICAgIGZtdHR5JylcbiAgfCBJZ25vcmVkX3JlYWRlciAtPiAoXG4gICAgbWF0Y2ggZm10dHkgd2l0aFxuICAgIHwgSWdub3JlZF9yZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfcmVhZGVyLCBmbXQnKSwgZm10dHknKVxuICAgIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcblxuYW5kIHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgOiB0eXBlIGExIGEyIGIxIGIyIGMxIGMyIGQxIGQyIGUxIGUyIGYxIGYyIC5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGQyLCBhMikgaWdub3JlZCAtPlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXQgLT5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHkgLT5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10X2ZtdHR5X2ViYlxuPSBmdW4gaWduIGZtdCBmbXR0eSAtPlxuICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkgaW5cbiAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoaWduLCBmbXQnKSwgZm10dHknKVxuXG4oKiBUeXBpbmcgb2YgdGhlIGNvbXBsZXggY2FzZTogXCIlXyguLi4lKVwiLiAqKVxuYW5kIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIDogdHlwZSB3IHggeSB6IHAgcyB0IHUgYSBiIGMgZCBlIGYgLlxuICAgICh3LCB4LCB5LCB6LCBzLCBwKSBmbXR0eSAtPlxuICAgIChwLCB4LCB5LCBzLCB0LCB1KSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5X2ZtdF9lYmIgPVxuZnVuIHN1Yl9mbXR0eSBmbXQgZm10dHkgLT4gbWF0Y2ggc3ViX2ZtdHR5LCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSBzdWJfZm10dHlfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChDaGFyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBTdHJpbmdfdHkgc3ViX2ZtdHR5X3Jlc3QsIFN0cmluZ190eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChTdHJpbmdfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludF90eSBzdWJfZm10dHlfcmVzdCwgSW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50MzJfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludDMyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludDMyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBOYXRpdmVpbnRfdHkgc3ViX2ZtdHR5X3Jlc3QsIE5hdGl2ZWludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChOYXRpdmVpbnRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludDY0X3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnQ2NF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnQ2NF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgRmxvYXRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEZsb2F0X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZsb2F0X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBCb29sX3R5IHN1Yl9mbXR0eV9yZXN0LCBCb29sX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEJvb2xfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEFscGhhX3R5IHN1Yl9mbXR0eV9yZXN0LCBBbHBoYV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChBbHBoYV90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgVGhldGFfdHkgc3ViX2ZtdHR5X3Jlc3QsIFRoZXRhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFRoZXRhX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBSZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIFJlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChSZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0LCBJZ25vcmVkX3JlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJZ25vcmVkX3JlYWRlcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG5cbiAgfCBGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5LCBzdWJfZm10dHlfcmVzdCksXG4gICAgRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIHN1YjJfZm10dHkgPD4gRm10dHlfRUJCIHN1YjJfZm10dHknIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHknLCBzdWJfZm10dHlfcmVzdCcpLCBmbXQnKVxuICB8IEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eSwgIHN1YjJfZm10dHksICBzdWJfZm10dHlfcmVzdCksXG4gICAgRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5Jywgc3ViMl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgKCogVE9ETyBkZWZpbmUgRm10dHlfcmVsX0VCQiB0byByZW1vdmUgdGhvc2UgZXJhc2VfcmVsICopXG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMV9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMV9mbXR0eScpXG4gICAgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjJfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjJfZm10dHknKVxuICAgIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgc3ViX2ZtdHR5JyA9IHRyYW5zIChzeW1tIHN1YjFfZm10dHknKSBzdWIyX2ZtdHR5JyBpblxuICAgIGxldCBfLCBmMiwgXywgZjQgPSBmbXR0eV9yZWxfZGV0IHN1Yl9mbXR0eScgaW5cbiAgICBsZXQgUmVmbCA9IGYyIFJlZmwgaW5cbiAgICBsZXQgUmVmbCA9IGY0IFJlZmwgaW5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiAoZXJhc2VfcmVsIHN1Yl9mbXR0eV9yZXN0KSBmbXQgZm10dHlfcmVzdFxuICAgIGluXG4gICAgRm10dHlfZm10X0VCQiAoRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5Jywgc3ViMl9mbXR0eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1tIHN1Yl9mbXR0eV9yZXN0JyksXG4gICAgICAgICAgICAgICAgICAgZm10JylcbiAgfCBFbmRfb2ZfZm10dHksIGZtdHR5IC0+XG4gICAgRm10dHlfZm10X0VCQiAoRW5kX29mX2ZtdHR5LCB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5KVxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIGByZWNhc3RgIGlzIGEgYml0IGRpc2FwcG9pbnRpbmcuIFRoZVxuICAgaW52YXJpYW50IHByb3ZpZGVkIGJ5IHRoZSB0eXBlIGFyZSB2ZXJ5IHN0cm9uZzogdGhlIGlucHV0IGZvcm1hdCdzXG4gICB0eXBlIGlzIGluIHJlbGF0aW9uIHRvIHRoZSBvdXRwdXQgdHlwZSdzIGFzIHdpdG5lc3NlZCBieSB0aGVcbiAgIGZtdHR5X3JlbCBhcmd1bWVudC4gT25lIHdvdWxkIGF0IGZpcnN0IGV4cGVjdCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICB0b3RhbCwgYW5kIGltcGxlbWVudGFibGUgYnkgZXhoYXVzdGl2ZSBwYXR0ZXJuIG1hdGNoaW5nLiBJbnN0ZWFkLFxuICAgd2UgcmV1c2UgdGhlIGhpZ2hseSBwYXJ0aWFsIGFuZCBtdWNoIGxlc3Mgd2VsbC1kZWZpbmVkIGZ1bmN0aW9uXG4gICBgdHlwZV9mb3JtYXRgIHRoYXQgaGFzIGxvc3QgYWxsIGtub3dsZWRnZSBvZiB0aGUgY29ycmVzcG9uZGVuY2VcbiAgIGJldHdlZW4gdGhlIGFyZ3VtZW50J3MgdHlwZXMuXG5cbiAgIEJlc2lkZXMgdGhlIGZhY3QgdGhhdCB0aGlzIGZ1bmN0aW9uIHJldXNlcyBhIGxvdCBvZiB0aGVcbiAgIGB0eXBlX2Zvcm1hdGAgbG9naWMgKGVnLjogc2VlaW5nIEludF90eSBpbiB0aGUgZm10dHkgcGFyYW1ldGVyIGRvZXNcbiAgIG5vdCBsZXQgeW91IG1hdGNoIG9uIEludCBvbmx5LCBhcyB5b3UgbWF5IGluIGZhY3QgaGF2ZSBGbG9hdFxuICAgKEFyZ19wYWRkaW5nLCAuLi4pIChcIiUuKmRcIikgYmVnaW5uaW5nIHdpdGggYW4gSW50X3R5KSwgaXQgaXMgYWxzb1xuICAgYSBwYXJ0aWFsIGZ1bmN0aW9uLCBiZWNhdXNlIHRoZSB0eXBpbmcgaW5mb3JtYXRpb24gaW4gYSBmb3JtYXQgaXNcbiAgIG5vdCBxdWl0ZSBlbm91Z2ggdG8gcmVjb25zdHJ1Y3QgaXQgdW5hbWJpZ3VvdXNseS4gRm9yIGV4YW1wbGUsIHRoZVxuICAgZm9ybWF0IHR5cGVzIG9mIFwiJWQlX3JcIiBhbmQgXCIlX3IlZFwiIGhhdmUgdGhlIHNhbWUgZm9ybWF0NlxuICAgcGFyYW1ldGVycywgYnV0IHRoZXkgYXJlIG5vdCBhdCBhbGwgZXhjaGFuZ2VhYmxlLCBhbmQgcHV0dGluZyBvbmVcbiAgIGluIHBsYWNlIG9mIHRoZSBvdGhlciBtdXN0IHJlc3VsdCBpbiBhIGR5bmFtaWMgZmFpbHVyZS5cblxuICAgR2l2ZW4gdGhhdDpcbiAgIC0gd2UnZCBoYXZlIHRvIGR1cGxpY2F0ZSBhIGxvdCBvZiBub24tdHJpdmlhbCB0eXBpbmcgbG9naWMgZnJvbSB0eXBlX2Zvcm1hdFxuICAgLSB0aGlzIHdvdWxkbid0IGV2ZW4gZWxpbWluYXRlIChhbGwpIHRoZSBkeW5hbWljIGZhaWx1cmVzXG4gICB3ZSBkZWNpZGVkIHRvIGp1c3QgcmV1c2UgdHlwZV9mb3JtYXQgZGlyZWN0bHkgZm9yIG5vdy5cbiopXG5sZXQgcmVjYXN0IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyXG4gIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10XG49IGZ1biBmbXQgZm10dHkgLT5cbiAgdHlwZV9mb3JtYXQgZm10IChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBQcmludGluZyB0b29scyAqKVxuXG4oKiBBZGQgcGFkZGluZyBzcGFjZXMgYXJvdW5kIGEgc3RyaW5nLiAqKVxubGV0IGZpeF9wYWRkaW5nIHBhZHR5IHdpZHRoIHN0ciA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgd2lkdGgsIHBhZHR5ID1cbiAgICBhYnMgd2lkdGgsXG4gICAgKCogd2hpbGUgbGl0ZXJhbCBwYWRkaW5nIHdpZHRocyBhcmUgYWx3YXlzIG5vbi1uZWdhdGl2ZSxcbiAgICAgICBkeW5hbWljYWxseS1zZXQgd2lkdGhzIChBcmdfcGFkZGluZywgZWcuICUqZCkgbWF5IGJlIG5lZ2F0aXZlO1xuICAgICAgIHdlIGludGVycHJldCB0aG9zZSBhcyBzcGVjaWZ5aW5nIGEgcGFkZGluZy10by10aGUtbGVmdDsgdGhpc1xuICAgICAgIG1lYW5zIHRoYXQgJzAnIG1heSBnZXQgZHJvcHBlZCBldmVuIGlmIGl0IHdhcyBleHBsaWNpdGx5IHNldCxcbiAgICAgICBidXQ6XG4gICAgICAgLSB0aGlzIGlzIHdoYXQgdGhlIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBkb2VzLCBhbmRcbiAgICAgICAgIHdlIHByZXNlcnZlIGNvbXBhdGliaWxpdHkgaWYgcG9zc2libGVcbiAgICAgICAtIHdlIGNvdWxkIG9ubHkgc2lnbmFsIHRoaXMgaXNzdWUgYnkgZmFpbGluZyBhdCBydW50aW1lLFxuICAgICAgICAgd2hpY2ggaXMgbm90IHZlcnkgbmljZS4uLiAqKVxuICAgIGlmIHdpZHRoIDwgMCB0aGVuIExlZnQgZWxzZSBwYWR0eSBpblxuICBpZiB3aWR0aCA8PSBsZW4gdGhlbiBzdHIgZWxzZVxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIHdpZHRoIChpZiBwYWR0eSA9IFplcm9zIHRoZW4gJzAnIGVsc2UgJyAnKSBpblxuICAgIGJlZ2luIG1hdGNoIHBhZHR5IHdpdGhcbiAgICB8IExlZnQgIC0+IFN0cmluZy5ibGl0IHN0ciAwIHJlcyAwIGxlblxuICAgIHwgUmlnaHQgLT4gU3RyaW5nLmJsaXQgc3RyIDAgcmVzICh3aWR0aCAtIGxlbikgbGVuXG4gICAgfCBaZXJvcyB3aGVuIGxlbiA+IDAgJiYgKHN0ci5bMF0gPSAnKycgfHwgc3RyLlswXSA9ICctJyB8fCBzdHIuWzBdID0gJyAnKSAtPlxuICAgICAgQnl0ZXMuc2V0IHJlcyAwIHN0ci5bMF07XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMSByZXMgKHdpZHRoIC0gbGVuICsgMSkgKGxlbiAtIDEpXG4gICAgfCBaZXJvcyB3aGVuIGxlbiA+IDEgJiYgc3RyLlswXSA9ICcwJyAmJiAoc3RyLlsxXSA9ICd4JyB8fCBzdHIuWzFdID0gJ1gnKSAtPlxuICAgICAgQnl0ZXMuc2V0IHJlcyAxIHN0ci5bMV07XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMiByZXMgKHdpZHRoIC0gbGVuICsgMikgKGxlbiAtIDIpXG4gICAgfCBaZXJvcyAtPlxuICAgICAgU3RyaW5nLmJsaXQgc3RyIDAgcmVzICh3aWR0aCAtIGxlbikgbGVuXG4gICAgZW5kO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIEFkZCAnMCcgcGFkZGluZyB0byBpbnQsIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiAqKVxubGV0IGZpeF9pbnRfcHJlY2lzaW9uIHByZWMgc3RyID1cbiAgbGV0IHByZWMgPSBhYnMgcHJlYyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbWF0Y2ggc3RyLlswXSB3aXRoXG4gIHwgKCcrJyB8ICctJyB8ICcgJykgYXMgYyB3aGVuIHByZWMgKyAxID4gbGVuIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKHByZWMgKyAxKSAnMCcgaW5cbiAgICBCeXRlcy5zZXQgcmVzIDAgYztcbiAgICBTdHJpbmcuYmxpdCBzdHIgMSByZXMgKHByZWMgLSBsZW4gKyAyKSAobGVuIC0gMSk7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCAnMCcgd2hlbiBwcmVjICsgMiA+IGxlbiAmJiBsZW4gPiAxICYmIChzdHIuWzFdID0gJ3gnIHx8IHN0ci5bMV0gPSAnWCcpIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKHByZWMgKyAyKSAnMCcgaW5cbiAgICBCeXRlcy5zZXQgcmVzIDEgc3RyLlsxXTtcbiAgICBTdHJpbmcuYmxpdCBzdHIgMiByZXMgKHByZWMgLSBsZW4gKyA0KSAobGVuIC0gMik7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgd2hlbiBwcmVjID4gbGVuIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgcHJlYyAnMCcgaW5cbiAgICBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHByZWMgLSBsZW4pIGxlbjtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8IF8gLT5cbiAgICBzdHJcblxuKCogRXNjYXBlIGEgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgT0NhbWwgbGV4aW5nIGNvbnZlbnRpb24uICopXG5sZXQgc3RyaW5nX3RvX2NhbWxfc3RyaW5nIHN0ciA9XG4gIGxldCBzdHIgPSBTdHJpbmcuZXNjYXBlZCBzdHIgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVzID0gQnl0ZXMubWFrZSAobCArIDIpICdcXFwiJyBpblxuICBTdHJpbmcudW5zYWZlX2JsaXQgc3RyIDAgcmVzIDEgbDtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogR2VuZXJhdGUgdGhlIGZvcm1hdF9pbnQvaW50MzIvbmF0aXZlaW50L2ludDY0IGZpcnN0IGFyZ3VtZW50XG4gICBmcm9tIGFuIGludF9jb252LiAqKVxubGV0IGZvcm1hdF9vZl9pY29udiA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlZFwiIHwgSW50X3BkIC0+IFwiJStkXCIgfCBJbnRfc2QgLT4gXCIlIGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJWlcIiB8IEludF9waSAtPiBcIiUraVwiIHwgSW50X3NpIC0+IFwiJSBpXCJcbiAgfCBJbnRfeCAtPiBcIiV4XCIgfCBJbnRfQ3ggLT4gXCIlI3hcIlxuICB8IEludF9YIC0+IFwiJVhcIiB8IEludF9DWCAtPiBcIiUjWFwiXG4gIHwgSW50X28gLT4gXCIlb1wiIHwgSW50X0NvIC0+IFwiJSNvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiV1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udkwgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJUxkXCIgfCBJbnRfcGQgLT4gXCIlK0xkXCIgfCBJbnRfc2QgLT4gXCIlIExkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVMaVwiIHwgSW50X3BpIC0+IFwiJStMaVwiIHwgSW50X3NpIC0+IFwiJSBMaVwiXG4gIHwgSW50X3ggLT4gXCIlTHhcIiB8IEludF9DeCAtPiBcIiUjTHhcIlxuICB8IEludF9YIC0+IFwiJUxYXCIgfCBJbnRfQ1ggLT4gXCIlI0xYXCJcbiAgfCBJbnRfbyAtPiBcIiVMb1wiIHwgSW50X0NvIC0+IFwiJSNMb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlTHVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252bCA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlbGRcIiB8IEludF9wZCAtPiBcIiUrbGRcIiB8IEludF9zZCAtPiBcIiUgbGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJWxpXCIgfCBJbnRfcGkgLT4gXCIlK2xpXCIgfCBJbnRfc2kgLT4gXCIlIGxpXCJcbiAgfCBJbnRfeCAtPiBcIiVseFwiIHwgSW50X0N4IC0+IFwiJSNseFwiXG4gIHwgSW50X1ggLT4gXCIlbFhcIiB8IEludF9DWCAtPiBcIiUjbFhcIlxuICB8IEludF9vIC0+IFwiJWxvXCIgfCBJbnRfQ28gLT4gXCIlI2xvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVsdVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZuID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVuZFwiIHwgSW50X3BkIC0+IFwiJStuZFwiIHwgSW50X3NkIC0+IFwiJSBuZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlbmlcIiB8IEludF9waSAtPiBcIiUrbmlcIiB8IEludF9zaSAtPiBcIiUgbmlcIlxuICB8IEludF94IC0+IFwiJW54XCIgfCBJbnRfQ3ggLT4gXCIlI254XCJcbiAgfCBJbnRfWCAtPiBcIiVuWFwiIHwgSW50X0NYIC0+IFwiJSNuWFwiXG4gIHwgSW50X28gLT4gXCIlbm9cIiB8IEludF9DbyAtPiBcIiUjbm9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJW51XCJcblxuKCogR2VuZXJhdGUgdGhlIGZvcm1hdF9mbG9hdCBmaXJzdCBhcmd1bWVudCBmcm9tIGEgZmxvYXRfY29udi4gKilcbmxldCBmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYyA9XG4gICAgbGV0IHByZWMgPSBhYnMgcHJlYyBpblxuICAgIGxldCBzeW1iID0gY2hhcl9vZl9mY29udiB+Y0Y6J2cnIGZjb252IGluXG4gICAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLic7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIHByZWMpO1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgc3ltYjtcbiAgICBidWZmZXJfY29udGVudHMgYnVmXG5cbmxldCB0cmFuc2Zvcm1faW50X2FsdCBpY29udiBzID1cbiAgbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAtPlxuICAgIGxldCBkaWdpdHMgPVxuICAgICAgbGV0IG4gPSByZWYgMCBpblxuICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgICAgbWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICAgfCAnMCcuLic5JyAtPiBpbmNyIG5cbiAgICAgICAgfCBfIC0+ICgpXG4gICAgICBkb25lO1xuICAgICAgIW5cbiAgICBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgKFN0cmluZy5sZW5ndGggcyArIChkaWdpdHMgLSAxKSAvIDMpIGluXG4gICAgbGV0IHBvcyA9IHJlZiAwIGluXG4gICAgbGV0IHB1dCBjID0gQnl0ZXMuc2V0IGJ1ZiAhcG9zIGM7IGluY3IgcG9zIGluXG4gICAgbGV0IGxlZnQgPSByZWYgKChkaWdpdHMgLSAxKSBtb2QgMyArIDEpIGluXG4gICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICcwJy4uJzknIGFzIGMgLT5cbiAgICAgICAgICBpZiAhbGVmdCA9IDAgdGhlbiAocHV0ICdfJzsgbGVmdCA6PSAzKTsgZGVjciBsZWZ0OyBwdXQgY1xuICAgICAgfCBjIC0+IHB1dCBjXG4gICAgZG9uZTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGJ1ZlxuICB8IF8gLT4gc1xuXG4oKiBDb252ZXJ0IGFuIGludGVnZXIgdG8gYSBzdHJpbmcgYWNjb3JkaW5nIHRvIGEgY29udmVyc2lvbi4gKilcbmxldCBjb252ZXJ0X2ludCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQgKGZvcm1hdF9vZl9pY29udiBpY29udikgbilcbmxldCBjb252ZXJ0X2ludDMyIGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludDMyIChmb3JtYXRfb2ZfaWNvbnZsIGljb252KSBuKVxubGV0IGNvbnZlcnRfbmF0aXZlaW50IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X25hdGl2ZWludCAoZm9ybWF0X29mX2ljb252biBpY29udikgbilcbmxldCBjb252ZXJ0X2ludDY0IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludDY0IChmb3JtYXRfb2ZfaWNvbnZMIGljb252KSBuKVxuXG4oKiBDb252ZXJ0IGEgZmxvYXQgdG8gc3RyaW5nLiAqKVxuKCogRml4IHNwZWNpYWwgY2FzZSBvZiBcIk9DYW1sIGZsb2F0IGZvcm1hdFwiLiAqKVxubGV0IGNvbnZlcnRfZmxvYXQgZmNvbnYgcHJlYyB4ID1cbiAgbGV0IGhleCAoKSA9XG4gICAgbGV0IHNpZ24gPVxuICAgICAgbWF0Y2ggZnN0IGZjb252IHdpdGhcbiAgICAgIHwgRmxvYXRfZmxhZ19wIC0+ICcrJ1xuICAgICAgfCBGbG9hdF9mbGFnX3MgLT4gJyAnXG4gICAgICB8IF8gLT4gJy0nIGluXG4gICAgaGV4c3RyaW5nX29mX2Zsb2F0IHggcHJlYyBzaWduIGluXG4gIGxldCBhZGRfZG90X2lmX25lZWRlZCBzdHIgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxldCByZWMgaXNfdmFsaWQgaSA9XG4gICAgICBpZiBpID0gbGVuIHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2ldIHdpdGhcbiAgICAgICAgfCAnLicgfCAnZScgfCAnRScgLT4gdHJ1ZVxuICAgICAgICB8IF8gLT4gaXNfdmFsaWQgKGkgKyAxKSBpblxuICAgIGlmIGlzX3ZhbGlkIDAgdGhlbiBzdHIgZWxzZSBzdHIgXiBcIi5cIiBpblxuICBsZXQgY2FtbF9zcGVjaWFsX3ZhbCBzdHIgPSBtYXRjaCBjbGFzc2lmeV9mbG9hdCB4IHdpdGhcbiAgICB8IEZQX25vcm1hbCB8IEZQX3N1Ym5vcm1hbCB8IEZQX3plcm8gLT4gc3RyXG4gICAgfCBGUF9pbmZpbml0ZSAtPiBpZiB4IDwgMC4wIHRoZW4gXCJuZWdfaW5maW5pdHlcIiBlbHNlIFwiaW5maW5pdHlcIlxuICAgIHwgRlBfbmFuIC0+IFwibmFuXCIgaW5cbiAgbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9oIC0+IGhleCAoKVxuICB8IEZsb2F0X0ggLT4gU3RyaW5nLnVwcGVyY2FzZV9hc2NpaSAoaGV4ICgpKVxuICB8IEZsb2F0X0NGIC0+IGNhbWxfc3BlY2lhbF92YWwgKGhleCAoKSlcbiAgfCBGbG9hdF9GIC0+XG4gICAgbGV0IHN0ciA9IGZvcm1hdF9mbG9hdCAoZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMpIHggaW5cbiAgICBjYW1sX3NwZWNpYWxfdmFsIChhZGRfZG90X2lmX25lZWRlZCBzdHIpXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0cgLT5cbiAgICBmb3JtYXRfZmxvYXQgKGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjKSB4XG5cbigqIENvbnZlcnQgYSBjaGFyIHRvIGEgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgT0NhbWwgbGV4aWNhbCBjb252ZW50aW9uLiAqKVxubGV0IGZvcm1hdF9jYW1sX2NoYXIgYyA9XG4gIGxldCBzdHIgPSBDaGFyLmVzY2FwZWQgYyBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCByZXMgPSBCeXRlcy5tYWtlIChsICsgMikgJ1xcJycgaW5cbiAgU3RyaW5nLnVuc2FmZV9ibGl0IHN0ciAwIHJlcyAxIGw7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIENvbnZlcnQgYSBmb3JtYXQgdHlwZSB0byBzdHJpbmcgKilcbmxldCBzdHJpbmdfb2ZfZm10dHkgZm10dHkgPVxuICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICBicHJpbnRfZm10dHkgYnVmIGZtdHR5O1xuICBidWZmZXJfY29udGVudHMgYnVmXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAoKiBHZW5lcmljIHByaW50aW5nIGZ1bmN0aW9uICopXG5cbigqIE1ha2UgYSBnZW5lcmljIHByaW50aW5nIGZ1bmN0aW9uLiAqKVxuKCogVXNlZCB0byBnZW5lcmF0ZSBQcmludGYgYW5kIEZvcm1hdCBwcmludGluZyBmdW5jdGlvbnMuICopXG4oKiBQYXJhbWV0ZXJzOlxuICAgICBrOiBhIGNvbnRpbnVhdGlvbiBmaW5hbGx5IGFwcGxpZWQgdG8gdGhlIG91dHB1dCBzdHJlYW0gYW5kIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgbzogdGhlIG91dHB1dCBzdHJlYW0gKHNlZSBrLCAlYSBhbmQgJXQpLlxuICAgICBhY2M6IHJldiBsaXN0IG9mIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXNoLCBmb3JtYXR0aW5nLCAuLi4pLlxuICAgICBmbXQ6IHRoZSBmb3JtYXQuICopXG5sZXQgcmVjIG1ha2VfcHJpbnRmIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgQ2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfY2hhciAoYWNjLCBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmb3JtYXRfY2FtbF9jaGFyIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIGFjYyByZXN0IHBhZCAoZnVuIHN0ciAtPiBzdHIpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgc3RyaW5nX3RvX2NhbWxfc3RyaW5nXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQgaWNvbnZcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50MzIgaWNvbnZcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X25hdGl2ZWludCBpY29udlxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQ2NCBpY29udlxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfZmxvYXRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBmY29udlxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgc3RyaW5nX29mX2Jvb2xcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgZnVuIGYgeCAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGVsYXkgKGFjYywgZnVuIG8gLT4gZiBvIHgpKSByZXN0XG4gIHwgVGhldGEgcmVzdCAtPlxuICAgIGZ1biBmIC0+IG1ha2VfcHJpbnRmIGsgKEFjY19kZWxheSAoYWNjLCBmKSkgcmVzdFxuICB8IEN1c3RvbSAoYXJpdHksIGYsIHJlc3QpIC0+XG4gICAgbWFrZV9jdXN0b20gayBhY2MgcmVzdCBhcml0eSAoZiAoKSlcbiAgfCBSZWFkZXIgXyAtPlxuICAgICgqIFRoaXMgY2FzZSBpcyBpbXBvc3NpYmxlLCBieSB0eXBpbmcgb2YgZm9ybWF0cy4gKilcbiAgICAoKiBJbmRlZWQsIHNpbmNlIHByaW50ZiBhbmQgY28uIHRha2UgYSBmb3JtYXQ0IGFzIGFyZ3VtZW50LCB0aGUgJ2QgYW5kICdlXG4gICAgICAgdHlwZSBwYXJhbWV0ZXJzIG9mIGZtdCBhcmUgb2J2aW91c2x5IGVxdWFscy4gVGhlIFJlYWRlciBpcyB0aGVcbiAgICAgICBvbmx5IGNvbnN0cnVjdG9yIHdoaWNoIHRvdWNoICdkIGFuZCAnZSB0eXBlIHBhcmFtZXRlcnMgb2YgdGhlIGZvcm1hdFxuICAgICAgIHR5cGUsIGl0IGFkZHMgYW4gKC0+KSB0byB0aGUgJ2QgcGFyYW1ldGVycy4gQ29uc2VxdWVudGx5LCBhIGZvcm1hdDRcbiAgICAgICBjYW5ub3QgY29udGFpbiBhIFJlYWRlciBub2RlLCBleGNlcHQgaW4gdGhlIHN1Yi1mb3JtYXQgYXNzb2NpYXRlZCB0b1xuICAgICAgIGFuICV7Li4uJX0uIEl0J3Mgbm90IGEgcHJvYmxlbSBiZWNhdXNlIG1ha2VfcHJpbnRmIGRvIG5vdCBjYWxsXG4gICAgICAgaXRzZWxmIHJlY3Vyc2l2ZWx5IG9uIHRoZSBzdWItZm9ybWF0IGFzc29jaWF0ZWQgdG8gJXsuLi4lfS4gKilcbiAgICBhc3NlcnQgZmFsc2VcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX2ZsdXNoIGFjYykgcmVzdFxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2Nfc3RyaW5nX2xpdGVyYWwgKGFjYywgc3RyKSkgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19jaGFyX2xpdGVyYWwgKGFjYywgY2hyKSkgcmVzdFxuXG4gIHwgRm9ybWF0X2FyZyAoXywgc3ViX2ZtdHR5LCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHN0cmluZ19vZl9mbXR0eSBzdWJfZm10dHkgaW5cbiAgICAoZnVuIHN0ciAtPlxuICAgICAgaWdub3JlIHN0cjtcbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCB0eSkpIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBmdW4gKEZvcm1hdCAoZm10LCBfKSkgLT4gbWFrZV9wcmludGYgayBhY2NcbiAgICAgIChjb25jYXRfZm10IChyZWNhc3QgZm10IGZtdHR5KSByZXN0KVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT5cbiAgICBsZXQgbmV3X2FjYyA9IEFjY19pbnZhbGlkX2FyZyAoYWNjLCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJVtcIikgaW5cbiAgICBmdW4gXyAtPiBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+XG4gICAgKCogVGhpcyBjYXNlIHNob3VsZCBiZSByZWZ1c2VkIGZvciBQcmludGYuICopXG4gICAgKCogQWNjZXB0ZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuICopXG4gICAgKCogSW50ZXJwcmV0ICVsLCAlbiBhbmQgJUwgYXMgJXUuICopXG4gICAgZnVuIG4gLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZvcm1hdF9pbnQgXCIldVwiIG4pIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9jaGFyIChhY2MsIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBtYWtlX2lnbm9yZWRfcGFyYW0gayBhY2MgaWduIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2xpdCAoYWNjLCBmbXRpbmdfbGl0KSkgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgbGV0IGsnIGthY2MgPVxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2Zvcm1hdHRpbmdfZ2VuIChhY2MsIEFjY19vcGVuX3RhZyBrYWNjKSkgcmVzdCBpblxuICAgIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10J1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgbGV0IGsnIGthY2MgPVxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2Zvcm1hdHRpbmdfZ2VuIChhY2MsIEFjY19vcGVuX2JveCBrYWNjKSkgcmVzdCBpblxuICAgIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10J1xuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIGsgYWNjXG5cbigqIERlbGF5IHRoZSBlcnJvciAoSW52YWxpZF9hcmd1bWVudCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikuICopXG4oKiBHZW5lcmF0ZSBmdW5jdGlvbnMgdG8gdGFrZSByZW1haW5pbmcgYXJndW1lbnRzIChhZnRlciB0aGUgXCIlX1wiKS4gKilcbmFuZCBtYWtlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyBmbXR0eSBmbXRcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuXG5cbigqIFNwZWNpYWwgY2FzZSBvZiBwcmludGYgXCIlXyhcIi4gKilcbmFuZCBtYWtlX2Zyb21fZm10dHkgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBmbXR0eSAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10dHkgZm10IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnQzMl90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBGbG9hdF90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBCb29sX3R5IHJlc3QgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBBbHBoYV90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IFRoZXRhX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEFueV90eSByZXN0ICAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IFJlYWRlcl90eSBfICAgICAgICAgICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IF8gICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IEZvcm1hdF9hcmdfdHkgKF8sIHJlc3QpIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEVuZF9vZl9mbXR0eSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyAoY29uY2F0X2ZtdHR5IHR5IHJlc3QpIGZtdFxuXG4oKiBJbnNlcnQgYW4gQWNjX2ludmFsaWRfYXJnIGluIHRoZSBhY2N1bXVsYXRvciBhbmQgY29udGludWUgdG8gZ2VuZXJhdGVcbiAgIGNsb3N1cmVzIHRvIGdldCB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cy4gKilcbmFuZCBtYWtlX2ludmFsaWRfYXJnIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10IC0+XG4gIG1ha2VfcHJpbnRmIGsgKEFjY19pbnZhbGlkX2FyZyAoYWNjLCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikpIGZtdFxuXG4oKiBGaXggcGFkZGluZywgdGFrZSBpdCBhcyBhbiBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50IGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX3BhZGRpbmcgOiB0eXBlIHggeiBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeiAtPiBhKSBwYWRkaW5nIC0+ICh6IC0+IHN0cmluZykgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHRyYW5zIC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCB0cmFucyB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgd2lkdGgpIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZpeF9wYWRkaW5nIHBhZHR5IHdpZHRoICh0cmFucyB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIGZtdFxuXG4oKiBGaXggcGFkZGluZyBhbmQgcHJlY2lzaW9uIGZvciBpbnQsIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQuICopXG4oKiBUYWtlIG9uZSBvciB0d28gZXh0cmEgaW50ZWdlciBhcmd1bWVudHMgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT4gKGludF9jb252IC0+IHogLT4gc3RyaW5nKSAtPlxuICAgIGludF9jb252IC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCBwcmVjIHRyYW5zIGljb252IC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSB0cmFucyBpY29udiB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG5cbigqIENvbnZlcnQgYSBmbG9hdCwgZml4IHBhZGRpbmcgYW5kIHByZWNpc2lvbiBpZiBuZWVkZWQuICopXG4oKiBUYWtlIHRoZSBmbG9hdCBhcmd1bWVudCBhbmQgb25lIG9yIHR3byBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50cyBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh5LCBmbG9hdCAtPiBhKSBwcmVjaXNpb24gLT4gZmxvYXRfY29udiAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgcHJlYyBmY29udiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIGxldCBzdHInID0gZml4X3BhZGRpbmcgcGFkdHkgdyBzdHIgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHInKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIGxldCBzdHInID0gZml4X3BhZGRpbmcgcGFkdHkgdyBzdHIgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHInKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuYW5kIG1ha2VfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiB4IC0+IHkgPVxuICBmdW4gayBhY2MgcmVzdCBhcml0eSBmIC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgZikpIHJlc3RcbiAgfCBDdXN0b21fc3VjYyBhcml0eSAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBtYWtlX2N1c3RvbSBrIGFjYyByZXN0IGFyaXR5IChmIHgpXG5cbmxldCBjb25zdCB4IF8gPSB4XG5cbmxldCByZWMgbWFrZV9pcHJpbnRmIDogdHlwZSBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+IHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG4gIGZ1biBrIG8gZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gICAgfCBDaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IENhbWxfc3RyaW5nIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9zdHJpbmcgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX3N0cmluZyAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgSW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBJbnQzMiAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgTmF0aXZlaW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBJbnQ2NCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgRmxvYXQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEJvb2wgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBCb29sIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQm9vbCAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgQWxwaGEgcmVzdCAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBUaGV0YSByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9jdXN0b21fYXJpdHkgayBvIHJlc3QgYXJpdHlcbiAgICB8IFJlYWRlciBfIC0+XG4gICAgICAgICgqIFRoaXMgY2FzZSBpcyBpbXBvc3NpYmxlLCBieSB0eXBpbmcgb2YgZm9ybWF0cy4gIFNlZSB0aGVcbiAgICAgICAgICAgbm90ZSBpbiB0aGUgY29ycmVzcG9uZGluZyBjYXNlIGZvciBtYWtlX3ByaW50Zi4gKilcbiAgICAgICAgYXNzZXJ0IGZhbHNlXG4gICAgfCBGbHVzaCByZXN0IC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IEZvcm1hdF9hcmcgKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAtPlxuICAgICAgICBmdW4gKEZvcm1hdCAoZm10LCBfKSkgLT5cbiAgICAgICAgICBtYWtlX2lwcmludGYgayBvXG4gICAgICAgICAgICAoY29uY2F0X2ZtdCAocmVjYXN0IGZtdCBmbXR0eSkgcmVzdClcbiAgICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lnbm9yZWRfcGFyYW0gKGZ1biBfIC0+IGsgbykgKEVuZF9vZl9hY2MpIGlnbiByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgKGZ1biBrb2MgLT4gbWFrZV9pcHJpbnRmIGsga29jIHJlc3QpIG8gZm10J1xuICAgIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIChmdW4ga29jIC0+IG1ha2VfaXByaW50ZiBrIGtvYyByZXN0KSBvIGZtdCdcbiAgICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICAgICAgayBvXG5hbmQgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gOlxuICB0eXBlIHggeSB6IGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT4gc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT4geCA9XG4gIGZ1biBrIG8gZm10IHBhZCBwcmVjIC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gICAgfCBOb19wYWRkaW5nICAgLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTm9fcGFkZGluZyAgICwgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IE5vX3BhZGRpbmcgICAsIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IExpdF9wYWRkaW5nIF8sIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTGl0X3BhZGRpbmcgXywgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSkpXG5hbmQgZm5fb2ZfY3VzdG9tX2FyaXR5IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPlxuICBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geSA9XG4gIGZ1biBrIG8gZm10IC0+IGZ1bmN0aW9uXG4gICAgfCBDdXN0b21femVybyAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIGZtdFxuICAgIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT5cbiAgICAgICAgY29uc3QgKGZuX29mX2N1c3RvbV9hcml0eSBrIG8gZm10IGFyaXR5KVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBDb250aW51YXRpb25zIGZvciBtYWtlX3ByaW50ZiAqKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGFuIG91dHB1dF9zdHJlYW0uICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBvdXRwdXRfYWNjIG8gYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAe1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAW1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfY2hhciBvIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IGYgb1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgZmx1c2ggb1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBvdXRwdXRfYWNjIG8gcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgYnVmcHV0X2FjYyBiIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAe1wiOyBidWZwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQFtcIjsgYnVmcHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IGYgYlxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBidWZwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gYnVmcHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIGJ1ZnB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mICVhIGFuZCAldC4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgYiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQHtcIjsgc3RycHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkBbXCI7IHN0cnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIChmICgpKVxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRXJyb3IgbWFuYWdlbWVudCAqKVxuXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIHByZXR0eS1wcmludGVkIGVycm9yIG1lc3NhZ2UuICopXG5sZXQgZmFpbHdpdGhfbWVzc2FnZSAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDI1NiBpblxuICBsZXQgayBhY2MgPSBzdHJwdXRfYWNjIGJ1ZiBhY2M7IGZhaWx3aXRoIChCdWZmZXIuY29udGVudHMgYnVmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0dGluZyB0b29scyAqKVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGFuIG9wZW4gYmxvY2sgZGVzY3JpcHRpb24gKGluZGVudCwgYmxvY2tfdHlwZSkgKilcbmxldCBvcGVuX2JveF9vZl9zdHJpbmcgc3RyID1cbiAgaWYgc3RyID0gXCJcIiB0aGVuICgwLCBQcF9ib3gpIGVsc2VcbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZXQgaW52YWxpZF9ib3ggKCkgPSBmYWlsd2l0aF9tZXNzYWdlIFwiaW52YWxpZCBib3ggZGVzY3JpcHRpb24gJVNcIiBzdHIgaW5cbiAgICBsZXQgcmVjIHBhcnNlX3NwYWNlcyBpID1cbiAgICAgIGlmIGkgPSBsZW4gdGhlbiBpIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltpXSB3aXRoXG4gICAgICAgIHwgJyAnIHwgJ1xcdCcgLT4gcGFyc2Vfc3BhY2VzIChpICsgMSlcbiAgICAgICAgfCBfIC0+IGlcbiAgICBhbmQgcGFyc2VfbHdvcmQgaSBqID1cbiAgICAgIGlmIGogPSBsZW4gdGhlbiBqIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltqXSB3aXRoXG4gICAgICAgIHwgJ2EnIC4uICd6JyAtPiBwYXJzZV9sd29yZCBpIChqICsgMSlcbiAgICAgICAgfCBfIC0+IGpcbiAgICBhbmQgcGFyc2VfaW50IGkgaiA9XG4gICAgICBpZiBqID0gbGVuIHRoZW4gaiBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5bal0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gcGFyc2VfaW50IGkgKGogKyAxKVxuICAgICAgICB8IF8gLT4gaiBpblxuICAgIGxldCB3c3RhcnQgPSBwYXJzZV9zcGFjZXMgMCBpblxuICAgIGxldCB3ZW5kID0gcGFyc2VfbHdvcmQgd3N0YXJ0IHdzdGFydCBpblxuICAgIGxldCBib3hfbmFtZSA9IFN0cmluZy5zdWIgc3RyIHdzdGFydCAod2VuZCAtIHdzdGFydCkgaW5cbiAgICBsZXQgbnN0YXJ0ID0gcGFyc2Vfc3BhY2VzIHdlbmQgaW5cbiAgICBsZXQgbmVuZCA9IHBhcnNlX2ludCBuc3RhcnQgbnN0YXJ0IGluXG4gICAgbGV0IGluZGVudCA9XG4gICAgICBpZiBuc3RhcnQgPSBuZW5kIHRoZW4gMCBlbHNlXG4gICAgICAgIHRyeSBpbnRfb2Zfc3RyaW5nIChTdHJpbmcuc3ViIHN0ciBuc3RhcnQgKG5lbmQgLSBuc3RhcnQpKVxuICAgICAgICB3aXRoIEZhaWx1cmUgXyAtPiBpbnZhbGlkX2JveCAoKSBpblxuICAgIGxldCBleHBfZW5kID0gcGFyc2Vfc3BhY2VzIG5lbmQgaW5cbiAgICBpZiBleHBfZW5kIDw+IGxlbiB0aGVuIGludmFsaWRfYm94ICgpO1xuICAgIGxldCBib3hfdHlwZSA9IG1hdGNoIGJveF9uYW1lIHdpdGhcbiAgICAgIHwgXCJcIiB8IFwiYlwiIC0+IFBwX2JveFxuICAgICAgfCBcImhcIiAgICAgIC0+IFBwX2hib3hcbiAgICAgIHwgXCJ2XCIgICAgICAtPiBQcF92Ym94XG4gICAgICB8IFwiaHZcIiAgICAgLT4gUHBfaHZib3hcbiAgICAgIHwgXCJob3ZcIiAgICAtPiBQcF9ob3Zib3hcbiAgICAgIHwgXyAgICAgICAgLT4gaW52YWxpZF9ib3ggKCkgaW5cbiAgICAoaW5kZW50LCBib3hfdHlwZSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBQYXJzaW5nIHRvb2xzICopXG5cbigqIENyZWF0ZSBhIHBhZGRpbmdfZm10X2ViYiBmcm9tIGEgcGFkZGluZyBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwYWRkaW5nIHRvIGRpc2pvaW4gdGhlIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudCBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcGFkZGluZ19mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+IChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAgIChfLCBfLCBfLCBfLCBfKSBwYWRkaW5nX2ZtdF9lYmIgPVxuZnVuIHBhZCBmbXQgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nICAgICAgICAgLT4gUGFkZGluZ19mbXRfRUJCIChOb19wYWRkaW5nLCBmbXQpXG4gIHwgTGl0X3BhZGRpbmcgKHMsIHcpIC0+IFBhZGRpbmdfZm10X0VCQiAoTGl0X3BhZGRpbmcgKHMsIHcpLCBmbXQpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZGRpbmdfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgZm10KVxuXG4oKiBDcmVhdGUgYSBwcmVjaXNpb25fZm10X2ViYiBmcm9tIGEgcHJlY2lzaW9uIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnQgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwcmVjaXNpb24gLT4gKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgICAgKF8sIF8sIF8sIF8sIF8pIHByZWNpc2lvbl9mbXRfZWJiID1cbmZ1biBwcmVjIGZtdCAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gICAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKE5vX3ByZWNpc2lvbiwgZm10KVxuICB8IExpdF9wcmVjaXNpb24gcCAtPiBQcmVjaXNpb25fZm10X0VCQiAoTGl0X3ByZWNpc2lvbiBwLCBmbXQpXG4gIHwgQXJnX3ByZWNpc2lvbiAgIC0+IFByZWNpc2lvbl9mbXRfRUJCIChBcmdfcHJlY2lzaW9uLCBmbXQpXG5cbigqIENyZWF0ZSBhIHBhZHByZWNfZm10X2ViYiBmcm9tIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcGFkZGluZyBhbmQgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudHNcbiAgIGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgOiB0eXBlIHggeSB6IHQgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh6LCB0KSBwcmVjaXNpb24gLT5cbiAgICAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgKF8sIF8sIF8sIF8sIF8pIHBhZHByZWNfZm10X2ViYiA9XG5mdW4gcGFkIHByZWMgZm10IC0+XG4gIGxldCBQcmVjaXNpb25fZm10X0VCQiAocHJlYywgZm10JykgPSBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIHByZWMgZm10IGluXG4gIG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAgICAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoTm9fcGFkZGluZywgcHJlYywgZm10JylcbiAgfCBMaXRfcGFkZGluZyAocywgdykgLT4gUGFkcHJlY19mbXRfRUJCIChMaXRfcGFkZGluZyAocywgdyksIHByZWMsIGZtdCcpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgcHJlYywgZm10JylcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHBhcnNpbmcgKilcblxuKCogUGFyc2UgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZm9ybWF0IGFuZCBjcmVhdGUgYSBmbXRfZWJiLiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIGluIGNhc2Ugb2YgaW52YWxpZCBmb3JtYXQuICopXG5sZXQgZm10X2ViYl9vZl9zdHJpbmcgP2xlZ2FjeV9iZWhhdmlvciBzdHIgPVxuICAoKiBQYXJhbWV0ZXJzIG5hbWluZyBjb252ZW50aW9uOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBsaXRfc3RhcnQ6IHN0YXJ0IG9mIHRoZSBsaXRlcmFsIHNlcXVlbmNlLiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHN0cl9pbmQ6IGN1cnJlbnQgaW5kZXggaW4gdGhlIHN0cmluZy4gICAgICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gZW5kX2luZDogZW5kIG9mIHRoZSBjdXJyZW50IChzdWItKWZvcm1hdC4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBwY3RfaW5kOiBpbmRleCBvZiB0aGUgJyUnIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgKilcbiAgKCogICAtIHplcm86ICBpcyB0aGUgJzAnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gbWludXM6IGlzIHRoZSAnLScgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBwbHVzOiAgaXMgdGhlICcrJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIGhhc2g6ICBpcyB0aGUgJyMnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gc3BhY2U6IGlzIHRoZSAnICcgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBpZ246ICAgaXMgdGhlICdfJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHBhZDogcGFkZGluZyBvZiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gcHJlYzogcHJlY2lzaW9uIG9mIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBzeW1iOiBjaGFyIHJlcHJlc2VudGluZyB0aGUgY29udmVyc2lvbiAoJ2MnLCAncycsICdkJywgLi4uKS4gKilcbiAgKCogICAtIGNoYXJfc2V0OiBzZXQgb2YgY2hhcmFjdGVycyBhcyBiaXRtYXAgKHNlZSBzY2FuZiAlWy4uLl0pLiAgICAqKVxuXG4gIGxldCBsZWdhY3lfYmVoYXZpb3IgPSBtYXRjaCBsZWdhY3lfYmVoYXZpb3Igd2l0aFxuICAgIHwgU29tZSBmbGFnIC0+IGZsYWdcbiAgICB8IE5vbmUgLT4gdHJ1ZVxuICAoKiAgV2hlbiB0aGlzIGZsYWcgaXMgZW5hYmxlZCwgdGhlIGZvcm1hdCBwYXJzZXIgdHJpZXMgdG8gYmVoYXZlIGFzXG4gICAgICB0aGUgPDQuMDIgaW1wbGVtZW50YXRpb25zLCBpbiBwYXJ0aWN1bGFyIGl0IGlnbm9yZXMgbW9zdCBiZW5pbmVcbiAgICAgIG5vbnNlbnNpY2FsIGZvcm1hdC4gV2hlbiB0aGUgZmxhZyBpcyBkaXNhYmxlZCwgaXQgd2lsbCByZWplY3QgYW55XG4gICAgICBmb3JtYXQgdGhhdCBpcyBub3QgYWNjZXB0ZWQgYnkgdGhlIHNwZWNpZmljYXRpb24uXG5cbiAgICAgIEEgdHlwaWNhbCBleGFtcGxlIHdvdWxkIGJlIFwiJSsgZFwiOiBzcGVjaWZ5aW5nIGJvdGggJysnIChpZiB0aGVcbiAgICAgIG51bWJlciBpcyBwb3NpdGl2ZSwgcGFkIHdpdGggYSAnKycgdG8gZ2V0IHRoZSBzYW1lIHdpZHRoIGFzXG4gICAgICBuZWdhdGl2ZSBudW1iZXJzKSBhbmQgJyAnIChpZiB0aGUgbnVtYmVyIGlzIHBvc2l0aXZlLCBwYWQgd2l0aFxuICAgICAgYSBzcGFjZSkgZG9lcyBub3QgbWFrZSBzZW5zZSwgYnV0IHRoZSBsZWdhY3kgKDwgNC4wMilcbiAgICAgIGltcGxlbWVudGF0aW9uIHdhcyBoYXBweSB0byBqdXN0IGlnbm9yZSB0aGUgc3BhY2UuXG4gICopXG4gIGluXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlLiAqKVxuICBsZXQgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBzdHJfaW5kIG1zZyA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJXNcIlxuICAgICAgc3RyIHN0cl9pbmQgbXNnXG4gIGluXG5cbiAgKCogVXNlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIGZvcm1hdCAob3IgdGhlIGN1cnJlbnQgc3ViLWZvcm1hdCkgd2FzIGVuY291bnRlcmVkXG4gICAgICB1bmV4cGVjdGVkbHkuICopXG4gIGxldCB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZCA9XG4gICAgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBlbmRfaW5kXG4gICAgICBcInVuZXhwZWN0ZWQgZW5kIG9mIGZvcm1hdFwiXG4gIGluXG5cbiAgKCogVXNlZCBmb3IgJTBjOiBubyBvdGhlciB3aWR0aHMgYXJlIGltcGxlbWVudGVkICopXG4gIGxldCBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kID1cbiAgICBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIHN0cl9pbmRcbiAgICAgIFwibm9uLXplcm8gd2lkdGhzIGFyZSB1bnN1cHBvcnRlZCBmb3IgJWMgY29udmVyc2lvbnNcIlxuICBpblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gb3B0aW9uIGRlcGVuZGVuY3lcbiAgICAgcHJvYmxlbS4gKilcbiAgbGV0IGludmFsaWRfZm9ybWF0X3dpdGhvdXQgc3RyX2luZCBjIHMgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICclYycgd2l0aG91dCAlc1wiXG4gICAgICBzdHIgc3RyX2luZCBjIHNcbiAgaW5cblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gdW5leHBlY3RlZFxuICAgICBjaGFyYWN0ZXIuICopXG4gIGxldCBleHBlY3RlZF9jaGFyYWN0ZXIgc3RyX2luZCBleHBlY3RlZCByZWFkID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICVzIGV4cGVjdGVkLCByZWFkICVDXCJcbiAgICAgIHN0ciBzdHJfaW5kIGV4cGVjdGVkIHJlYWRcbiAgaW5cblxuICAoKiBQYXJzZSB0aGUgc3RyaW5nIGZyb20gYmVnX2luZCAoaW5jbHVkZWQpIHRvIGVuZF9pbmQgKGV4Y2x1ZGVkKS4gKilcbiAgbGV0IHJlYyBwYXJzZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBiZWdfaW5kIGVuZF9pbmQgLT4gcGFyc2VfbGl0ZXJhbCBiZWdfaW5kIGJlZ19pbmQgZW5kX2luZFxuXG4gICgqIFJlYWQgbGl0ZXJhbCBjaGFyYWN0ZXJzIHVwIHRvICclJyBvciAnQCcgc3BlY2lhbCBjaGFyYWN0ZXJzLiAqKVxuICBhbmQgcGFyc2VfbGl0ZXJhbCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgRW5kX29mX2Zvcm1hdCBlbHNlXG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2VfZm9ybWF0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBmbXRfcmVzdFxuICAgICAgfCAnQCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZV9hZnRlcl9hdCAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgZm10X3Jlc3RcbiAgICAgIHwgXyAtPlxuICAgICAgICBwYXJzZV9saXRlcmFsIGxpdF9zdGFydCAoc3RyX2luZCArIDEpIGVuZF9pbmRcblxuICAoKiBQYXJzZSBhIGZvcm1hdCBhZnRlciAnJScgKilcbiAgYW5kIHBhcnNlX2Zvcm1hdCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIGVuZF9pbmQgLT4gcGFyc2VfaWduIHBjdF9pbmQgKHBjdF9pbmQgKyAxKSBlbmRfaW5kXG5cbiAgYW5kIHBhcnNlX2lnbiA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXycgLT4gcGFyc2VfZmxhZ3MgcGN0X2luZCAoc3RyX2luZCsxKSBlbmRfaW5kIHRydWVcbiAgICAgIHwgXyAtPiBwYXJzZV9mbGFncyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBmYWxzZVxuXG4gIGFuZCBwYXJzZV9mbGFncyA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiAoXywgXywgZSwgZikgZm10X2ViYlxuICA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBpZ24gLT5cbiAgICBsZXQgemVybyA9IHJlZiBmYWxzZSBhbmQgbWludXMgPSByZWYgZmFsc2VcbiAgICBhbmQgcGx1cyA9IHJlZiBmYWxzZSBhbmQgc3BhY2UgPSByZWYgZmFsc2VcbiAgICBhbmQgaGFzaCA9IHJlZiBmYWxzZSBpblxuICAgIGxldCBzZXRfZmxhZyBzdHJfaW5kIGZsYWcgPVxuICAgICAgKCogaW4gbGVnYWN5IG1vZGUsIGR1cGxpY2F0ZSBmbGFncyBhcmUgYWNjZXB0ZWQgKilcbiAgICAgIGlmICFmbGFnICYmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgZHVwbGljYXRlIGZsYWcgJUNcIlxuICAgICAgICAgIHN0ciBzdHJfaW5kIHN0ci5bc3RyX2luZF07XG4gICAgICBmbGFnIDo9IHRydWU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHJlYWRfZmxhZ3Mgc3RyX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICcwJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHplcm87ICByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJy0nIC0+IHNldF9mbGFnIHN0cl9pbmQgbWludXM7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnKycgLT4gc2V0X2ZsYWcgc3RyX2luZCBwbHVzOyAgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcjJyAtPiBzZXRfZmxhZyBzdHJfaW5kIGhhc2g7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnICcgLT4gc2V0X2ZsYWcgc3RyX2luZCBzcGFjZTsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcGFyc2VfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZFxuICAgICAgICAgICF6ZXJvICFtaW51cyAhcGx1cyAhaGFzaCAhc3BhY2UgaWduXG4gICAgICBlbmRcbiAgICBpblxuICAgIHJlYWRfZmxhZ3Mgc3RyX2luZFxuXG4gICgqIFRyeSB0byByZWFkIGEgZGlnaXRhbCBvciBhICcqJyBwYWRkaW5nLiAqKVxuICBhbmQgcGFyc2VfcGFkZGluZyA6IHR5cGUgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgIChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIHplcm8gbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhZHR5ID0gbWF0Y2ggemVybywgbWludXMgd2l0aFxuICAgICAgfCBmYWxzZSwgZmFsc2UgLT4gUmlnaHRcbiAgICAgIHwgZmFsc2UsIHRydWUgIC0+IExlZnRcbiAgICAgIHwgIHRydWUsIGZhbHNlIC0+IFplcm9zXG4gICAgICB8ICB0cnVlLCB0cnVlICAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMZWZ0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICctJyBcIjBcIiBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPlxuICAgICAgbGV0IG5ld19pbmQsIHdpZHRoID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBuZXdfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAoTGl0X3BhZGRpbmcgKHBhZHR5LCB3aWR0aCkpXG4gICAgfCAnKicgLT5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlXG4gICAgICAgIGlnbiAoQXJnX3BhZGRpbmcgcGFkdHkpXG4gICAgfCBfIC0+XG4gICAgICBiZWdpbiBtYXRjaCBwYWR0eSB3aXRoXG4gICAgICB8IExlZnQgIC0+XG4gICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLScgXCJwYWRkaW5nXCI7XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIHwgWmVyb3MgLT5cbiAgICAgICAgICgqIGEgJzAnIHBhZGRpbmcgaW5kaWNhdGlvbiBub3QgZm9sbG93ZWQgYnkgYW55dGhpbmcgc2hvdWxkXG4gICAgICAgICAgIGJlIGludGVycHJldGVkIGFzIGEgUmlnaHQgcGFkZGluZyBvZiB3aWR0aCAwLiBUaGlzIGlzIHVzZWRcbiAgICAgICAgICAgYnkgc2Nhbm5pbmcgY29udmVyc2lvbnMgJTBzIGFuZCAlMGMgKilcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgKExpdF9wYWRkaW5nIChSaWdodCwgMCkpXG4gICAgICB8IFJpZ2h0IC0+XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIGVuZFxuXG4gICgqIElzIHByZWNpc2lvbiBkZWZpbmVkPyAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcGFkZGluZyA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcuJyAtPlxuICAgICAgcGFyc2VfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgcGFkXG4gICAgfCBzeW1iIC0+XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIE5vX3ByZWNpc2lvbiBwYWQgc3ltYlxuXG4gICgqIFJlYWQgdGhlIGRpZ2l0YWwgb3IgJyonIHByZWNpc2lvbi4gKilcbiAgYW5kIHBhcnNlX3ByZWNpc2lvbiA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfbGl0ZXJhbCBtaW51cyBzdHJfaW5kID1cbiAgICAgIGxldCBuZXdfaW5kLCBwcmVjID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIG5ld19pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIHBhZCAoTGl0X3ByZWNpc2lvbiBwcmVjKSBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPiBwYXJzZV9saXRlcmFsIG1pbnVzIHN0cl9pbmRcbiAgICB8ICgnKycgfCAnLScpIGFzIHN5bWIgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT5cbiAgICAgICgqIExlZ2FjeSBtb2RlIHdvdWxkIGFjY2VwdCBhbmQgaWdub3JlICcrJyBvciAnLScgYmVmb3JlIHRoZVxuICAgICAgICAgaW50ZWdlciBkZXNjcmliaW5nIHRoZSBkZXNpcmVkIHByZWNpc2lvbjsgbm90ZSB0aGF0IHRoaXNcbiAgICAgICAgIGNhbm5vdCBoYXBwZW4gZm9yIHBhZGRpbmcgd2lkdGgsIGFzICcrJyBhbmQgJy0nIGFscmVhZHkgaGF2ZVxuICAgICAgICAgYSBzZW1hbnRpY3MgdGhlcmUuXG5cbiAgICAgICAgIFRoYXQgc2FpZCwgdGhlIGlkZWEgKHN1cHBvcnRlZCBieSB0aGlzIHR3ZWFrKSB0aGF0IHdpZHRoIGFuZFxuICAgICAgICAgcHJlY2lzaW9uIGxpdGVyYWxzIGFyZSBcImludGVnZXIgbGl0ZXJhbHNcIiBpbiB0aGUgT0NhbWwgc2Vuc2UgaXNcbiAgICAgICAgIHN0aWxsIGJsYXRhbnRseSB3cm9uZywgYXMgMTIzXzQ1NiBvciAweEZGIGFyZSByZWplY3RlZC4gKilcbiAgICAgIHBhcnNlX2xpdGVyYWwgKG1pbnVzIHx8IHN5bWIgPSAnLScpIChzdHJfaW5kICsgMSlcbiAgICB8ICcqJyAtPlxuICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZVxuICAgICAgICBpZ24gcGFkIEFyZ19wcmVjaXNpb25cbiAgICB8IF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICgqIG5vdGUgdGhhdCBsZWdhY3kgaW1wbGVtZW50YXRpb24gZGlkIG5vdCBpZ25vcmUgJy4nIHdpdGhvdXRcbiAgICAgICAgICAgYSBudW1iZXIgKGFzIGl0IGRvZXMgZm9yIHBhZGRpbmcgaW5kaWNhdGlvbnMpLCBidXRcbiAgICAgICAgICAgaW50ZXJwcmV0cyBpdCBhcyAnLjAnICopXG4gICAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgcGFkIChMaXRfcHJlY2lzaW9uIDApXG4gICAgICBlbHNlXG4gICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLicgXCJwcmVjaXNpb25cIlxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBjb252ZXJzaW9uLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiB0IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIHkpIHBhZGRpbmcgLT4gKHosIHQpIHByZWNpc2lvbiAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCBwcmVjIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfY29udiAodHlwZSB1KSAodHlwZSB2KSAocGFkcHJlYyA6ICh1LCB2KSBwYWRkaW5nKSA9XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIHByZWMgcGFkcHJlYyBzdHIuW3N0cl9pbmRdIGluXG4gICAgKCogaW4gbGVnYWN5IG1vZGUsIHNvbWUgZm9ybWF0cyAoJXMgYW5kICVTKSBhY2NlcHQgYSB3ZWlyZCBtaXggb2ZcbiAgICAgICBwYWRkaW5nIGFuZCBwcmVjaXNpb24sIHdoaWNoIGlzIG1lcmdlZCBhcyBhIHNpbmdsZSBwYWRkaW5nXG4gICAgICAgaW5mb3JtYXRpb24uIEZvciBleGFtcGxlLCBpbiAlLjEwcyB0aGUgcHJlY2lzaW9uIGlzIGltcGxpY2l0bHlcbiAgICAgICB1bmRlcnN0b29kIGFzIHBhZGRpbmcgJTEwcywgYnV0IHRoZSBsZWZ0LXBhZGRpbmcgY29tcG9uZW50IG1heVxuICAgICAgIGJlIHNwZWNpZmllZCBlaXRoZXIgYXMgYSBsZWZ0IHBhZGRpbmcgb3IgYSBuZWdhdGl2ZSBwcmVjaXNpb246XG4gICAgICAgJS0uM3MgYW5kICUuLTNzIGFyZSBlcXVpdmFsZW50IHRvICUtM3MgKilcbiAgICBtYXRjaCBwYWQgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAtPiAoXG4gICAgICBtYXRjaCBtaW51cywgcHJlYyB3aXRoXG4gICAgICAgIHwgXywgTm9fcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgTm9fcGFkZGluZ1xuICAgICAgICB8IGZhbHNlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKSlcbiAgICAgICAgfCB0cnVlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKExlZnQsIG4pKVxuICAgICAgICB8IGZhbHNlLCBBcmdfcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgKEFyZ19wYWRkaW5nIFJpZ2h0KVxuICAgICAgICB8IHRydWUsIEFyZ19wcmVjaXNpb24gLT4gcGFyc2VfY29udiAoQXJnX3BhZGRpbmcgTGVmdClcbiAgICApXG4gICAgfCBwYWQgLT4gcGFyc2VfY29udiBwYWRcblxuICAoKiBDYXNlIGFuYWx5c2lzIG9uIGNvbnZlcnNpb24uICopXG4gIGFuZCBwYXJzZV9jb252ZXJzaW9uIDogdHlwZSB4IHkgeiB0IHUgdiBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiAoeCwgeSkgcGFkZGluZyAtPlxuICAgICAgICAoeiwgdCkgcHJlY2lzaW9uIC0+ICh1LCB2KSBwYWRkaW5nIC0+IGNoYXIgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgcHJlYyBwYWRwcmVjIHN5bWIgLT5cbiAgICAoKiBGbGFncyB1c2VkIHRvIGNoZWNrIG9wdGlvbiB1c2FnZXMvY29tcGF0aWJpbGl0aWVzLiAqKVxuICAgIGxldCBwbHVzX3VzZWQgID0gcmVmIGZhbHNlIGFuZCBoYXNoX3VzZWQgPSByZWYgZmFsc2VcbiAgICBhbmQgc3BhY2VfdXNlZCA9IHJlZiBmYWxzZSBhbmQgaWduX3VzZWQgICA9IHJlZiBmYWxzZVxuICAgIGFuZCBwYWRfdXNlZCAgID0gcmVmIGZhbHNlIGFuZCBwcmVjX3VzZWQgID0gcmVmIGZhbHNlIGluXG5cbiAgICAoKiBBY2Nlc3MgdG8gb3B0aW9ucywgdXBkYXRlIGZsYWdzLiAqKVxuICAgIGxldCBnZXRfcGx1cyAgICAoKSA9IHBsdXNfdXNlZCAgOj0gdHJ1ZTsgcGx1c1xuICAgIGFuZCBnZXRfaGFzaCAgICgpID0gaGFzaF91c2VkIDo9IHRydWU7IGhhc2hcbiAgICBhbmQgZ2V0X3NwYWNlICAgKCkgPSBzcGFjZV91c2VkIDo9IHRydWU7IHNwYWNlXG4gICAgYW5kIGdldF9pZ24gICAgICgpID0gaWduX3VzZWQgICA6PSB0cnVlOyBpZ25cbiAgICBhbmQgZ2V0X3BhZCAgICAgKCkgPSBwYWRfdXNlZCAgIDo9IHRydWU7IHBhZFxuICAgIGFuZCBnZXRfcHJlYyAgICAoKSA9IHByZWNfdXNlZCAgOj0gdHJ1ZTsgcHJlY1xuICAgIGFuZCBnZXRfcGFkcHJlYyAoKSA9IHBhZF91c2VkICAgOj0gdHJ1ZTsgcGFkcHJlYyBpblxuXG4gICAgbGV0IGdldF9pbnRfcGFkICgpIDogKHgseSkgcGFkZGluZyA9XG4gICAgICAoKiAlNS4zZCBpcyBhY2NlcHRlZCBhbmQgbWVhbmluZ2Z1bDogcGFkIHRvIGxlbmd0aCA1IHdpdGhcbiAgICAgICAgIHNwYWNlcywgYnV0IGZpcnN0IHBhZCB3aXRoIHplcm9zIHVwdG8gbGVuZ3RoIDMgKDAtcGFkZGluZ1xuICAgICAgICAgaXMgdGhlIGludGVycHJldGF0aW9uIG9mIFwicHJlY2lzaW9uXCIgZm9yIGludGVnZXIgZm9ybWF0cykuXG5cbiAgICAgICAgICUwNS4zZCBpcyByZWR1bmRhbnQ6IHBhZCB0byBsZW5ndGggNSAqd2l0aCB6ZXJvcyosIGJ1dFxuICAgICAgICAgZmlyc3QgcGFkIHdpdGggemVyb3MuLi4gVG8gYWRkIGluc3VsdCB0byB0aGUgaW5qdXJ5LCB0aGVcbiAgICAgICAgIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBpZ25vcmVzIHRoZSAwLXBhZGRpbmcgaW5kaWNhdGlvbiBhbmRcbiAgICAgICAgIGRvZXMgdGhlIDUgcGFkZGluZyB3aXRoIHNwYWNlcyBpbnN0ZWFkLiBXZSByZXVzZSB0aGlzXG4gICAgICAgICBpbnRlcnByZXRhdGlvbiBmb3IgY29tcGF0aWJpbGl0eSwgYnV0IHN0YXRpY2FsbHkgcmVqZWN0IHRoaXNcbiAgICAgICAgIGZvcm1hdCB3aGVuIHRoZSBsZWdhY3kgbW9kZSBpcyBkaXNhYmxlZCwgdG8gcHJvdGVjdCBzdHJpY3RcbiAgICAgICAgIHVzZXJzIGZyb20gdGhpcyBjb3JuZXIgY2FzZS4gKilcbiAgICAgICBtYXRjaCBnZXRfcGFkICgpLCBnZXRfcHJlYyAoKSB3aXRoXG4gICAgICAgICB8IHBhZCwgTm9fcHJlY2lzaW9uIC0+IHBhZFxuICAgICAgICAgfCBOb19wYWRkaW5nLCBfICAgICAtPiBOb19wYWRkaW5nXG4gICAgICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgbiksIF8gLT5cbiAgICAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKVxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcywgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBMaXRfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWRcbiAgICAgICAgIHwgQXJnX3BhZGRpbmcgXyBhcyBwYWQsIF8gLT4gcGFkIGluXG5cbiAgICAoKiBDaGVjayB0aGF0IHBhZHR5IDw+IFplcm9zLiAqKVxuICAgIGxldCBjaGVja19ub18wIHN5bWIgKHR5cGUgYSBiKSAocGFkIDogKGEsIGIpIHBhZGRpbmcpIDogKGEsYikgcGFkZGluZyA9XG4gICAgICBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoKExlZnQgfCBSaWdodCksIF8pIC0+IHBhZFxuICAgICAgfCBBcmdfcGFkZGluZyAoTGVmdCB8IFJpZ2h0KSAtPiBwYWRcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aClcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIjBcIlxuICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcyAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgaW5cblxuICAgICgqIEdldCBwYWRkaW5nIGFzIGEgcGFkX29wdGlvbiAoc2VlIFwiJV9cIiwgXCIle1wiLCBcIiUoXCIgYW5kIFwiJVtcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgb3B0X29mX3BhZCBjICh0eXBlIGEpICh0eXBlIGIpIChwYWQgOiAoYSwgYikgcGFkZGluZykgPSBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IE5vbmVcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aCkgLT4gU29tZSB3aWR0aFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBTb21lIHdpZHRoXG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInMCdcIlxuICAgICAgfCBMaXRfcGFkZGluZyAoTGVmdCwgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIictJ1wiXG4gICAgICB8IEFyZ19wYWRkaW5nIF8gLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInKidcIlxuICAgIGluXG4gICAgbGV0IGdldF9wYWRfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWQgKCkpIGluXG4gICAgbGV0IGdldF9wYWRwcmVjX29wdCBjID0gb3B0X29mX3BhZCBjIChnZXRfcGFkcHJlYyAoKSkgaW5cblxuICAgICgqIEdldCBwcmVjaXNpb24gYXMgYSBwcmVjX29wdGlvbiAoc2VlIFwiJV9mXCIpLlxuICAgICAgIChubyBuZWVkIGZvciBsZWdhY3kgbW9kZSB0d2Vha2luZywgdGhvc2Ugd2VyZSByZWplY3RlZCBieSB0aGVcbiAgICAgICBsZWdhY3kgcGFyc2VyIGFzIHdlbGwpICopXG4gICAgbGV0IGdldF9wcmVjX29wdCAoKSA9IG1hdGNoIGdldF9wcmVjICgpIHdpdGhcbiAgICAgIHwgTm9fcHJlY2lzaW9uICAgICAgIC0+IE5vbmVcbiAgICAgIHwgTGl0X3ByZWNpc2lvbiBuZGVjIC0+IFNvbWUgbmRlY1xuICAgICAgfCBBcmdfcHJlY2lzaW9uICAgICAgLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICdfJyBcIicqJ1wiXG4gICAgaW5cblxuICAgIGxldCBmbXRfcmVzdWx0ID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnLCcgLT5cbiAgICAgIHBhcnNlIHN0cl9pbmQgZW5kX2luZFxuICAgIHwgJ2MnIC0+XG4gICAgICBsZXQgY2hhcl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jaGFyLCBmbXRfcmVzdCkpXG4gICAgICAgIGVsc2UgRm10X0VCQiAoQ2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgc2Nhbl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlMGMgKilcbiAgICAgICAgaWYgZ2V0X2lnbiAoKVxuICAgICAgICB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChTY2FuX25leHRfY2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgYmVnaW4gbWF0Y2ggZ2V0X3BhZF9vcHQgJ2MnIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSAwIC0+IHNjYW5fZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSBfbiAtPlxuICAgICAgICAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yXG4gICAgICAgICAgIHRoZW4gaW52YWxpZF9ub25udWxsX2NoYXJfd2lkdGggc3RyX2luZFxuICAgICAgICAgICBlbHNlICgqIGxlZ2FjeSBpZ25vcmVzICVjIHdpZHRocyAqKSBjaGFyX2Zvcm1hdCBmbXRfcmVzdFxuICAgICAgZW5kXG4gICAgfCAnQycgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jYW1sX2NoYXIsZm10X3Jlc3QpKVxuICAgICAgZWxzZSBGbXRfRUJCIChDYW1sX2NoYXIgZm10X3Jlc3QpXG4gICAgfCAncycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc3RyaW5nIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChTdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnUycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfY2FtbF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKENhbWxfc3RyaW5nIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2QnIHwgJ2knIHwgJ3gnIHwgJ1gnIHwgJ28nIHwgJ3UnIC0+XG4gICAgICBsZXQgaWNvbnYgPSBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50IChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoSW50IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnTicgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IFRva2VuX2NvdW50ZXIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIHwgJ24nIHwgJ0wnIHdoZW4gc3RyX2luZD1lbmRfaW5kIHx8IG5vdCAoaXNfaW50X2Jhc2Ugc3RyLltzdHJfaW5kXSkgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IGNvdW50ZXJfb2ZfY2hhciBzeW1iIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSlcbiAgICB8ICdsJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50MzIgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ24nIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpXG4gICAgICAgICAgKGdldF9oYXNoICgpKSAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9uYXRpdmVpbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChOYXRpdmVpbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdMJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50NjQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQ2NCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2YnIHwgJ2UnIHwgJ0UnIHwgJ2cnIHwgJ0cnIHwgJ0YnIHwgJ2gnIHwgJ0gnIC0+XG4gICAgICBsZXQgZmNvbnYgPVxuICAgICAgICBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kXG4gICAgICAgICAgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpIChnZXRfc3BhY2UgKCkpIHN5bWIgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zsb2F0IChnZXRfcGFkX29wdCAnXycsIGdldF9wcmVjX29wdCAoKSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoRmxvYXQgKGZjb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdiJyB8ICdCJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9ib29sIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChCb29sIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2EnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoQWxwaGEgZm10X3Jlc3QpXG4gICAgfCAndCcgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChUaGV0YSBmbXRfcmVzdClcbiAgICB8ICdyJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3JlYWRlciwgZm10X3Jlc3QpKVxuICAgICAgZWxzZSBGbXRfRUJCIChSZWFkZXIgZm10X3Jlc3QpXG4gICAgfCAnIScgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGbHVzaCBmbXRfcmVzdClcbiAgICB8ICgnJScgfCAnQCcpIGFzIGMgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKGMsIGZtdF9yZXN0KSlcbiAgICB8ICd7JyAtPlxuICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgJ30nIGluXG4gICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCBzdWJfZW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdWJfZW5kICsgMikgZW5kX2luZCBpblxuICAgICAgbGV0IHN1Yl9mbXR0eSA9IGZtdHR5X29mX2ZtdCBzdWJfZm10IGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zvcm1hdF9hcmcgKGdldF9wYWRfb3B0ICdfJywgc3ViX2ZtdHR5KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdF9hcmcgKGdldF9wYWRfb3B0ICd7Jywgc3ViX2ZtdHR5LCBmbXRfcmVzdCkpXG4gICAgfCAnKCcgLT5cbiAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgc3RyX2luZCBlbmRfaW5kICcpJyBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3ViX2VuZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIHN1Yl9lbmQgaW5cbiAgICAgIGxldCBzdWJfZm10dHkgPSBmbXR0eV9vZl9mbXQgc3ViX2ZtdCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mb3JtYXRfc3Vic3QgKGdldF9wYWRfb3B0ICdfJywgc3ViX2ZtdHR5KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdF9zdWJzdCAoZ2V0X3BhZF9vcHQgJygnLCBzdWJfZm10dHksIGZtdF9yZXN0KSlcbiAgICB8ICdbJyAtPlxuICAgICAgbGV0IG5leHRfaW5kLCBjaGFyX3NldCA9IHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgKGdldF9wYWRfb3B0ICdfJywgY2hhcl9zZXQpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9jaGFyX3NldCAoZ2V0X3BhZF9vcHQgJ1snLCBjaGFyX3NldCwgZm10X3Jlc3QpKVxuICAgIHwgJy0nIHwgJysnIHwgJyMnIHwgJyAnIHwgJ18nIC0+XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIFxcXG4gICAgICAgICBmbGFnICVDIGlzIG9ubHkgYWxsb3dlZCBhZnRlciB0aGUgJyUlJywgYmVmb3JlIHBhZGRpbmcgYW5kIHByZWNpc2lvblwiXG4gICAgICAgIHN0ciBwY3RfaW5kIHN5bWJcbiAgICB8IF8gLT5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgIGludmFsaWQgY29udmVyc2lvbiBcXFwiJSUlY1xcXCJcIiBzdHIgKHN0cl9pbmQgLSAxKSBzeW1iXG4gICAgaW5cbiAgICAoKiBDaGVjayBmb3IgdW51c2VkIG9wdGlvbnMsIGFuZCByZWplY3QgdGhlbSBhcyBpbmNvbXBhdGlibGUuXG5cbiAgICAgICBTdWNoIGNoZWNrcyBuZWVkIHRvIGJlIGRpc2FibGVkIGluIGxlZ2FjeSBtb2RlLCBhcyB0aGUgbGVnYWN5XG4gICAgICAgcGFyc2VyIHNpbGVudGx5IGlnbm9yZWQgaW5jb21wYXRpYmxlIGZsYWdzLiAqKVxuICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlbiBiZWdpblxuICAgIGlmIG5vdCAhcGx1c191c2VkICYmIHBsdXMgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInKydcIjtcbiAgICBpZiBub3QgIWhhc2hfdXNlZCAmJiBoYXNoIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyMnXCI7XG4gICAgaWYgbm90ICFzcGFjZV91c2VkICYmIHNwYWNlIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCI7XG4gICAgaWYgbm90ICFwYWRfdXNlZCAgJiYgUGFkZGluZ19FQkIgcGFkIDw+IFBhZGRpbmdfRUJCIE5vX3BhZGRpbmcgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCJgcGFkZGluZydcIjtcbiAgICBpZiBub3QgIXByZWNfdXNlZCAmJiBQcmVjaXNpb25fRUJCIHByZWMgPD4gUHJlY2lzaW9uX0VCQiBOb19wcmVjaXNpb24gdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIChpZiBpZ24gdGhlbiAnXycgZWxzZSBzeW1iKVxuICAgICAgICBcImBwcmVjaXNpb24nXCI7XG4gICAgaWYgaWduICYmIHBsdXMgdGhlbiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJ18nIFwiJysnXCI7XG4gICAgZW5kO1xuICAgICgqIHRoaXMgbGFzdCB0ZXN0IG11c3Qgbm90IGJlIGRpc2FibGVkIGluIGxlZ2FjeSBtb2RlLFxuICAgICAgIGFzIGlnbm9yaW5nIGl0IHdvdWxkIHR5cGljYWxseSByZXN1bHQgaW4gYSBkaWZmZXJlbnQgdHlwaW5nXG4gICAgICAgdGhhbiB3aGF0IHRoZSBsZWdhY3kgcGFyc2VyIHVzZWQgKilcbiAgICBpZiBub3QgIWlnbl91c2VkICYmIGlnbiB0aGVuXG4gICAgICBiZWdpbiBtYXRjaCBzeW1iIHdpdGhcbiAgICAgICAgKCogYXJndW1lbnQtbGVzcyBmb3JtYXRzIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBpbiBsZWdhY3kgbW9kZSAqKVxuICAgICAgICB8ICgnQCcgfCAnJScgfCAnIScgfCAnLCcpIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+ICgpXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJ18nXCJcbiAgICAgIGVuZDtcbiAgICBmbXRfcmVzdWx0XG5cbiAgKCogUGFyc2UgZm9ybWF0dGluZyBpbmZvcm1hdGlvbiAoYWZ0ZXIgJ0AnKS4gKilcbiAgYW5kIHBhcnNlX2FmdGVyX2F0IDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIEVuZF9vZl9mb3JtYXQpKVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnWycgLT5cbiAgICAgICAgcGFyc2VfdGFnIGZhbHNlIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKENsb3NlX2JveCwgZm10X3Jlc3QpKVxuICAgICAgfCAneycgLT5cbiAgICAgICAgcGFyc2VfdGFnIHRydWUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICd9JyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfdGFnLCBmbXRfcmVzdCkpXG4gICAgICB8ICcsJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQnJlYWsgKFwiQCxcIiwgMCwgMCksIGZtdF9yZXN0KSlcbiAgICAgIHwgJyAnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJAIFwiLCAxLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnOycgLT5cbiAgICAgICAgcGFyc2VfZ29vZF9icmVhayAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJz8nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGRmx1c2gsIGZtdF9yZXN0KSlcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZvcmNlX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJy4nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGbHVzaF9uZXdsaW5lLCBmbXRfcmVzdCkpXG4gICAgICB8ICc8JyAtPlxuICAgICAgICBwYXJzZV9tYWdpY19zaXplIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnQCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfYXQsIGZtdF9yZXN0KSlcbiAgICAgIHwgJyUnIHdoZW4gc3RyX2luZCArIDEgPCBlbmRfaW5kICYmIHN0ci5bc3RyX2luZCArIDFdID0gJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChFc2NhcGVkX3BlcmNlbnQsIGZtdF9yZXN0KSlcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoJ0AnLCBmbXRfcmVzdCkpXG4gICAgICB8IGMgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKFNjYW5faW5kaWMgYywgZm10X3Jlc3QpKVxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBvcHRpb25hbCA8bmFtZT4gYWZ0ZXIgXCJAe1wiIG9yIFwiQFtcIi4gKilcbiAgYW5kIHBhcnNlX3RhZyA6IHR5cGUgZSBmIC4gYm9vbCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGlzX29wZW5fdGFnIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIHRyeVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIGxldCBpbmQgPSBTdHJpbmcuaW5kZXhfZnJvbSBzdHIgKHN0cl9pbmQgKyAxKSAnPicgaW5cbiAgICAgICAgaWYgaW5kID49IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdWJfc3RyID0gU3RyaW5nLnN1YiBzdHIgc3RyX2luZCAoaW5kIC0gc3RyX2luZCArIDEpIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKGluZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgKGluZCArIDEpIGluXG4gICAgICAgIGxldCBzdWJfZm9ybWF0ID0gRm9ybWF0IChzdWJfZm10LCBzdWJfc3RyKSBpblxuICAgICAgICBsZXQgZm9ybWF0dGluZyA9XG4gICAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZywgZm10X3Jlc3QpKVxuICAgICAgfCBfIC0+XG4gICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IHN1Yl9mb3JtYXQgPSBGb3JtYXQgKEVuZF9vZl9mb3JtYXQsIFwiXCIpIGluXG4gICAgICBsZXQgZm9ybWF0dGluZyA9XG4gICAgICAgIGlmIGlzX29wZW5fdGFnIHRoZW4gT3Blbl90YWcgc3ViX2Zvcm1hdCBlbHNlIE9wZW5fYm94IHN1Yl9mb3JtYXQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIG9wdGlvbmFsIDx3aWR0aCBvZmZzZXQ+IGFmdGVyIFwiQDtcIi4gKilcbiAgYW5kIHBhcnNlX2dvb2RfYnJlYWsgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgbGV0IG5leHRfaW5kLCBmb3JtYXR0aW5nX2xpdCA9XG4gICAgICB0cnlcbiAgICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgfHwgc3RyLltzdHJfaW5kXSA8PiAnPCcgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiAoXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMiwgd2lkdGggPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgICBsZXQgc3RyX2luZF8zID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfMiBlbmRfaW5kIGluXG4gICAgICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfM10gd2l0aFxuICAgICAgICAgICAgICB8ICc+JyAtPlxuICAgICAgICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQtMikgKHN0cl9pbmRfMy1zdHJfaW5kKzMpIGluXG4gICAgICAgICAgICAgICAgc3RyX2luZF8zICsgMSwgQnJlYWsgKHMsIHdpZHRoLCAwKVxuICAgICAgICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF80LCBvZmZzZXQgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMyBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgbGV0IHN0cl9pbmRfNSA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzQgZW5kX2luZCBpblxuICAgICAgICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF81XSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF81LXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzUgKyAxLCBCcmVhayAocywgd2lkdGgsIG9mZnNldClcbiAgICAgICAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICApXG4gICAgICAgIHwgXyAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIHN0cl9pbmQsIEJyZWFrIChcIkA7XCIsIDEsIDApXG4gICAgaW5cbiAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSlcblxuICAoKiBQYXJzZSB0aGUgc2l6ZSBpbiBhIDxuPi4gKilcbiAgYW5kIHBhcnNlX21hZ2ljX3NpemUgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgbWF0Y2hcbiAgICAgIHRyeVxuICAgICAgICBsZXQgc3RyX2luZF8xID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfMV0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT5cbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCBzaXplID0gcGFyc2VfaW50ZWdlciBzdHJfaW5kXzEgZW5kX2luZCBpblxuICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICBpZiBzdHIuW3N0cl9pbmRfM10gPD4gJz4nIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQgLSAyKSAoc3RyX2luZF8zIC0gc3RyX2luZCArIDMpIGluXG4gICAgICAgICAgU29tZSAoc3RyX2luZF8zICsgMSwgTWFnaWNfc2l6ZSAocywgc2l6ZSkpXG4gICAgICAgIHwgXyAtPiBOb25lXG4gICAgICB3aXRoIE5vdF9mb3VuZCB8IEZhaWx1cmUgXyAtPlxuICAgICAgICBOb25lXG4gICAgd2l0aFxuICAgIHwgU29tZSAobmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0KSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSlcbiAgICB8IE5vbmUgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyAnPCcsIGZtdF9yZXN0KSlcblxuICAoKiBQYXJzZSBhbmQgY29uc3RydWN0IGEgY2hhciBzZXQuICopXG4gIGFuZCBwYXJzZV9jaGFyX3NldCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG5cbiAgICBsZXQgY2hhcl9zZXQgPSBjcmVhdGVfY2hhcl9zZXQgKCkgaW5cbiAgICBsZXQgYWRkX2NoYXIgYyA9XG4gICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYztcbiAgICBpblxuICAgIGxldCBhZGRfcmFuZ2UgYyBjJyA9XG4gICAgICBmb3IgaSA9IGludF9vZl9jaGFyIGMgdG8gaW50X29mX2NoYXIgYycgZG9cbiAgICAgICAgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IChjaGFyX29mX2ludCBpKTtcbiAgICAgIGRvbmU7XG4gICAgaW5cblxuICAgIGxldCBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQgPVxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiAnJSUnIGFsb25lIGlzIG5vdCBhY2NlcHRlZCBpbiBjaGFyYWN0ZXIgc2V0cywgXFxcbiAgICAgICAgIHVzZSAlJSUlIGluc3RlYWQgYXQgcG9zaXRpb24gJWQuXCIgc3RyIHN0cl9pbmRcbiAgICBpblxuXG4gICAgKCogUGFyc2UgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIGNoYXIgc2V0LiAqKVxuICAgIGxldCByZWMgcGFyc2VfY2hhcl9zZXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBsZXQgYyA9IHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFBhcnNlIHRoZSBjb250ZW50IG9mIGEgY2hhciBzZXQgdW50aWwgdGhlIGZpcnN0ICddJy4gKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfY29udGVudCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJy0nIC0+XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgYyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG5cbiAgICAoKiBUZXN0IGZvciByYW5nZSBpbiBjaGFyIHNldC4gKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfbWludXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcbiAgICAgIHwgKCclJyB8ICdAJykgYXMgYycgd2hlbiBjID0gJyUnIC0+XG4gICAgICAgIGFkZF9jaGFyIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjJyAtPlxuICAgICAgICBpZiBjID0gJyUnIHRoZW4gZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kO1xuICAgICAgICAoKiBub3RlIHRoYXQgJ0AnIGFsb25lIGlzIGFjY2VwdGVkLCBhcyBkb25lIGJ5IHRoZSBsZWdhY3lcbiAgICAgICAgICAgaW1wbGVtZW50YXRpb247IHRoZSBkb2N1bWVudGF0aW9uIHNwZWNpZmljYWxseSByZXF1aXJlcyAlQFxuICAgICAgICAgICBzbyB3ZSBjb3VsZCB3YXJuIG9uIHRoYXQgKilcbiAgICAgICAgYWRkX2NoYXIgYztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgYydcblxuICAgICgqIE1hbmFnZSByYW5nZSBpbiBjaGFyIHNldCAoZXhjZXB0IGlmIHRoZSAnLScgdGhlIGxhc3QgY2hhciBiZWZvcmUgJ10nKSAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBhZGRfY2hhciAnLSc7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICclJyAtPlxuICAgICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICAgIHwgKCclJyB8ICdAJykgYXMgYycgLT5cbiAgICAgICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDIpIGVuZF9pbmRcbiAgICAgICAgICB8IF8gLT4gZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kXG4gICAgICAgIGVuZFxuICAgICAgfCBjJyAtPlxuICAgICAgICBhZGRfcmFuZ2UgYyBjJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICBpblxuICAgIGxldCBzdHJfaW5kLCByZXZlcnNlID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgICAgfCAnXicgLT4gc3RyX2luZCArIDEsIHRydWVcbiAgICAgICAgfCBfIC0+IHN0cl9pbmQsIGZhbHNlIGluXG4gICAgbGV0IG5leHRfaW5kID0gcGFyc2VfY2hhcl9zZXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgbGV0IGNoYXJfc2V0ID0gZnJlZXplX2NoYXJfc2V0IGNoYXJfc2V0IGluXG4gICAgbmV4dF9pbmQsIChpZiByZXZlcnNlIHRoZW4gcmV2X2NoYXJfc2V0IGNoYXJfc2V0IGVsc2UgY2hhcl9zZXQpXG5cbiAgKCogQ29uc3VtZSBhbGwgbmV4dCBzcGFjZXMsIHJhaXNlIGFuIEZhaWx1cmUgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2Vfc3BhY2VzIHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBpZiBzdHIuW3N0cl9pbmRdID0gJyAnIHRoZW4gcGFyc2Vfc3BhY2VzIChzdHJfaW5kICsgMSkgZW5kX2luZCBlbHNlIHN0cl9pbmRcblxuICAoKiBSZWFkIGEgcG9zaXRpdmUgaW50ZWdlciBmcm9tIHRoZSBzdHJpbmcsIHJhaXNlIGEgRmFpbHVyZSBpZiBlbmRfaW5kIGlzXG4gICAgIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgYWNjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IGFjYyAqIDEwICsgKGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnMCcpIGluXG4gICAgICBpZiBuZXdfYWNjID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW5cbiAgICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGludGVnZXIgJWQgaXMgZ3JlYXRlciB0aGFuIHRoZSBsaW1pdCAlZFwiXG4gICAgICAgICAgc3RyIG5ld19hY2MgU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgICBlbHNlXG4gICAgICAgIHBhcnNlX3Bvc2l0aXZlIChzdHJfaW5kICsgMSkgZW5kX2luZCBuZXdfYWNjXG4gICAgfCBfIC0+IHN0cl9pbmQsIGFjY1xuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlXG4gICAgIGlmIGVuZF9pbmQgaXMgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX2ludGVnZXIgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPiBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMFxuICAgIHwgJy0nIC0+IChcbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIC0+XG4gICAgICAgIGxldCBuZXh0X2luZCwgbiA9IHBhcnNlX3Bvc2l0aXZlIChzdHJfaW5kICsgMSkgZW5kX2luZCAwIGluXG4gICAgICAgIG5leHRfaW5kLCAtblxuICAgICAgfCBjIC0+XG4gICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiZGlnaXRcIiBjXG4gICAgKVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBBZGQgYSBsaXRlcmFsIHRvIGEgZm9ybWF0IGZyb20gYSBsaXRlcmFsIGNoYXJhY3RlciBzdWItc2VxdWVuY2UuICopXG4gIGFuZCBhZGRfbGl0ZXJhbCA6IHR5cGUgYSBkIGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IChhLCBfLCBfLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGxpdF9zdGFydCBzdHJfaW5kIGZtdCAtPiBtYXRjaCBzdHJfaW5kIC0gbGl0X3N0YXJ0IHdpdGhcbiAgICB8IDAgICAgLT4gRm10X0VCQiBmbXRcbiAgICB8IDEgICAgLT4gRm10X0VCQiAoQ2hhcl9saXRlcmFsIChzdHIuW2xpdF9zdGFydF0sIGZtdCkpXG4gICAgfCBzaXplIC0+IEZtdF9FQkIgKFN0cmluZ19saXRlcmFsIChTdHJpbmcuc3ViIHN0ciBsaXRfc3RhcnQgc2l6ZSwgZm10KSlcblxuICAoKiBTZWFyY2ggdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzdWItZm9ybWF0XG4gICAgIChpLmUuIHRoZSBjb3JyZXNwb25kaW5nIFwiJX1cIiBvciBcIiUpXCIpICopXG4gIGFuZCBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiB1bmNsb3NlZCBzdWItZm9ybWF0LCBcXFxuICAgICAgICAgZXhwZWN0ZWQgXFxcIiUlJWNcXFwiIGF0IGNoYXJhY3RlciBudW1iZXIgJWRcIiBzdHIgYyBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJyUnIC0+XG4gICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGlmIHN0ci5bc3RyX2luZCArIDFdID0gYyB0aGVuICgqIEVuZCBvZiBmb3JtYXQgZm91bmQgKikgc3RyX2luZCBlbHNlXG4gICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDFdIHdpdGhcbiAgICAgICAgfCAnXycgLT5cbiAgICAgICAgICAoKiBTZWFyY2ggZm9yIFwiJV8oXCIgb3IgXCIlX3tcIi4gKilcbiAgICAgICAgICBpZiBzdHJfaW5kICsgMiA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAyXSB3aXRoXG4gICAgICAgICAgfCAneycgLT5cbiAgICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAzKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgICB8ICcoJyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJyknIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgY1xuICAgICAgICAgIGVuZFxuICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICgqICV7Li4uJX0gc3ViLWZvcm1hdCBmb3VuZC4gKilcbiAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCAnfScgaW5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICB8ICcoJyAtPlxuICAgICAgICAgICgqICUoLi4uJSkgc3ViLWZvcm1hdCBmb3VuZC4gKilcbiAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICB8ICd9JyAtPlxuICAgICAgICAgICgqIEVycm9yOiAlKC4uLiV9LiAqKVxuICAgICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiY2hhcmFjdGVyICcpJ1wiICd9J1xuICAgICAgICB8ICcpJyAtPlxuICAgICAgICAgICgqIEVycm9yOiAley4uLiUpLiAqKVxuICAgICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiY2hhcmFjdGVyICd9J1wiICcpJ1xuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICBlbmRcbiAgICB8IF8gLT4gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAoKiBDaGVjayBpZiBzeW1iIGlzIGEgdmFsaWQgaW50IGNvbnZlcnNpb24gYWZ0ZXIgXCIlbFwiLCBcIiVuXCIgb3IgXCIlTFwiICopXG4gIGFuZCBpc19pbnRfYmFzZSBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnZCcgfCAnaScgfCAneCcgfCAnWCcgfCAnbycgfCAndScgLT4gdHJ1ZVxuICAgIHwgXyAtPiBmYWxzZVxuXG4gICgqIENvbnZlcnQgYSBjaGFyIChsLCBuIG9yIEwpIHRvIGl0cyBhc3NvY2lhdGVkIGNvdW50ZXIuICopXG4gIGFuZCBjb3VudGVyX29mX2NoYXIgc3ltYiA9IG1hdGNoIHN5bWIgd2l0aFxuICAgIHwgJ2wnIC0+IExpbmVfY291bnRlciAgfCAnbicgLT4gQ2hhcl9jb3VudGVyXG4gICAgfCAnTCcgLT4gVG9rZW5fY291bnRlciB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQ29udmVydCAocGx1cywgc3ltYikgdG8gaXRzIGFzc29jaWF0ZWQgaW50X2NvbnYuICopXG4gIGFuZCBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggc3BhY2Ugc3ltYiA9XG4gICAgbWF0Y2ggcGx1cywgaGFzaCwgc3BhY2UsIHN5bWIgd2l0aFxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9kICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfaVxuICAgIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2QnIC0+IEludF9zZCB8IGZhbHNlLCBmYWxzZSwgIHRydWUsICdpJyAtPiBJbnRfc2lcbiAgICB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdkJyAtPiBJbnRfcGQgfCAgdHJ1ZSwgZmFsc2UsIGZhbHNlLCAnaScgLT4gSW50X3BpXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAneCcgLT4gSW50X3ggIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ1gnIC0+IEludF9YXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAneCcgLT4gSW50X0N4IHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ1gnIC0+IEludF9DWFxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ28nIC0+IEludF9vXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnbycgLT4gSW50X0NvXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAndScgLT4gSW50X3VcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdkJyAtPiBJbnRfQ2RcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdpJyAtPiBJbnRfQ2lcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd1JyAtPiBJbnRfQ3VcbiAgICB8IF8sIHRydWUsIF8sICd4JyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ3hcbiAgICB8IF8sIHRydWUsIF8sICdYJyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ1hcbiAgICB8IF8sIHRydWUsIF8sICdvJyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ29cbiAgICB8IF8sIHRydWUsIF8sICgnZCcgfCAnaScgfCAndScpIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBmYWxzZSBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyMnXCJcbiAgICB8IHRydWUsIF8sIHRydWUsIF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICgqIHBsdXMgYW5kIHNwYWNlOiBsZWdhY3kgaW1wbGVtZW50YXRpb24gcHJlZmVycyBwbHVzICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnICcgXCInKydcIlxuICAgIHwgZmFsc2UsIF8sIHRydWUsIF8gICAgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggZmFsc2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicgJ1wiXG4gICAgfCB0cnVlLCBfLCBmYWxzZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIGZhbHNlIGhhc2ggc3BhY2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgZmFsc2UsIF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQ29udmVydCAocGx1cywgc3BhY2UsIHN5bWIpIHRvIGl0cyBhc3NvY2lhdGVkIGZsb2F0X2NvbnYuICopXG4gIGFuZCBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBsZXQgZmxhZyA9IG1hdGNoIHBsdXMsIHNwYWNlIHdpdGhcbiAgICB8IGZhbHNlLCBmYWxzZSAtPiBGbG9hdF9mbGFnX1xuICAgIHwgZmFsc2UsICB0cnVlIC0+IEZsb2F0X2ZsYWdfc1xuICAgIHwgIHRydWUsIGZhbHNlIC0+IEZsb2F0X2ZsYWdfcFxuICAgIHwgIHRydWUsICB0cnVlIC0+XG4gICAgICAoKiBwbHVzIGFuZCBzcGFjZTogbGVnYWN5IGltcGxlbWVudGF0aW9uIHByZWZlcnMgcGx1cyAqKVxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gRmxvYXRfZmxhZ19wXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnICcgXCInKydcIiBpblxuICAgIGxldCBraW5kID0gbWF0Y2ggaGFzaCwgc3ltYiB3aXRoXG4gICAgfCBfLCAnZicgLT4gRmxvYXRfZlxuICAgIHwgXywgJ2UnIC0+IEZsb2F0X2VcbiAgICB8IF8sICdFJyAtPiBGbG9hdF9FXG4gICAgfCBfLCAnZycgLT4gRmxvYXRfZ1xuICAgIHwgXywgJ0cnIC0+IEZsb2F0X0dcbiAgICB8IF8sICdoJyAtPiBGbG9hdF9oXG4gICAgfCBfLCAnSCcgLT4gRmxvYXRfSFxuICAgIHwgZmFsc2UsICdGJyAtPiBGbG9hdF9GXG4gICAgfCB0cnVlLCAnRicgLT4gRmxvYXRfQ0ZcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIGluXG4gICAgZmxhZywga2luZFxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBpbmNvbXBhdGlibGUgb3B0aW9ucy4qKVxuICBhbmQgaW5jb21wYXRpYmxlX2ZsYWcgOiB0eXBlIGEgLiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gc3RyaW5nIC0+IGEgPVxuICAgIGZ1biBwY3RfaW5kIHN0cl9pbmQgc3ltYiBvcHRpb24gLT5cbiAgICAgIGxldCBzdWJmbXQgPSBTdHJpbmcuc3ViIHN0ciBwY3RfaW5kIChzdHJfaW5kIC0gcGN0X2luZCkgaW5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgICVzIGlzIGluY29tcGF0aWJsZSB3aXRoICclYycgaW4gc3ViLWZvcm1hdCAlU1wiXG4gICAgICAgIHN0ciBwY3RfaW5kIG9wdGlvbiBzeW1iIHN1YmZtdFxuXG4gIGluIHBhcnNlIDAgKFN0cmluZy5sZW5ndGggc3RyKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgKCogR3VhcmRlZCBzdHJpbmcgdG8gZm9ybWF0IGNvbnZlcnNpb25zICopXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBmb3JtYXQgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgZm9ybWF0X29mX3N0cmluZ19mbXR0eSBzdHIgZm10dHkgPVxuICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzdHIgaW5cbiAgdHJ5IEZvcm1hdCAodHlwZV9mb3JtYXQgZm10IGZtdHR5LCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiXG4gICAgICBzdHIgKHN0cmluZ19vZl9mbXR0eSBmbXR0eSlcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBjb21wYXRpYmxlIHdpdGggYW4gb3RoZXIgZm9ybWF0LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgZm9ybWF0X29mX3N0cmluZ19mb3JtYXQgc3RyIChGb3JtYXQgKGZtdCcsIHN0cicpKSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgKGZtdHR5X29mX2ZtdCBmbXQnKSwgc3RyKVxuICB3aXRoIFR5cGVfbWlzbWF0Y2ggLT5cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImJhZCBpbnB1dDogZm9ybWF0IHR5cGUgbWlzbWF0Y2ggYmV0d2VlbiAlUyBhbmQgJVNcIiBzdHIgc3RyJ1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIFByaW50ZlxuXG50eXBlIHQgPSBleG4gPSAuLlxuXG5sZXQgcHJpbnRlcnMgPSBBdG9taWMubWFrZSBbXVxuXG5sZXQgbG9jZm10ID0gZm9ybWF0X29mX3N0cmluZyBcIkZpbGUgXFxcIiVzXFxcIiwgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZDogJXNcIlxuXG5sZXQgZmllbGQgeCBpID1cbiAgbGV0IGYgPSBPYmouZmllbGQgeCBpIGluXG4gIGlmIG5vdCAoT2JqLmlzX2Jsb2NrIGYpIHRoZW5cbiAgICBzcHJpbnRmIFwiJWRcIiAoT2JqLm1hZ2ljIGYgOiBpbnQpICAgICAgICAgICAoKiBjYW4gYWxzbyBiZSBhIGNoYXIgKilcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouc3RyaW5nX3RhZyB0aGVuXG4gICAgc3ByaW50ZiBcIiVTXCIgKE9iai5tYWdpYyBmIDogc3RyaW5nKVxuICBlbHNlIGlmIE9iai50YWcgZiA9IE9iai5kb3VibGVfdGFnIHRoZW5cbiAgICBzdHJpbmdfb2ZfZmxvYXQgKE9iai5tYWdpYyBmIDogZmxvYXQpXG4gIGVsc2VcbiAgICBcIl9cIlxuXG5sZXQgcmVjIG90aGVyX2ZpZWxkcyB4IGkgPVxuICBpZiBpID49IE9iai5zaXplIHggdGhlbiBcIlwiXG4gIGVsc2Ugc3ByaW50ZiBcIiwgJXMlc1wiIChmaWVsZCB4IGkpIChvdGhlcl9maWVsZHMgeCAoaSsxKSlcblxubGV0IGZpZWxkcyB4ID1cbiAgbWF0Y2ggT2JqLnNpemUgeCB3aXRoXG4gIHwgMCAtPiBcIlwiXG4gIHwgMSAtPiBcIlwiXG4gIHwgMiAtPiBzcHJpbnRmIFwiKCVzKVwiIChmaWVsZCB4IDEpXG4gIHwgXyAtPiBzcHJpbnRmIFwiKCVzJXMpXCIgKGZpZWxkIHggMSkgKG90aGVyX2ZpZWxkcyB4IDIpXG5cbmxldCB1c2VfcHJpbnRlcnMgeCA9XG4gIGxldCByZWMgY29udiA9IGZ1bmN0aW9uXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICAobWF0Y2ggaGQgeCB3aXRoXG4gICAgICAgICB8IE5vbmUgfCBleGNlcHRpb24gXyAtPiBjb252IHRsXG4gICAgICAgICB8IFNvbWUgcyAtPiBTb21lIHMpXG4gICAgfCBbXSAtPiBOb25lIGluXG4gIGNvbnYgKEF0b21pYy5nZXQgcHJpbnRlcnMpXG5cbmxldCB0b19zdHJpbmdfZGVmYXVsdCA9IGZ1bmN0aW9uXG4gIHwgT3V0X29mX21lbW9yeSAtPiBcIk91dCBvZiBtZW1vcnlcIlxuICB8IFN0YWNrX292ZXJmbG93IC0+IFwiU3RhY2sgb3ZlcmZsb3dcIlxuICB8IE1hdGNoX2ZhaWx1cmUoZmlsZSwgbGluZSwgY2hhcikgLT5cbiAgICAgIHNwcmludGYgbG9jZm10IGZpbGUgbGluZSBjaGFyIChjaGFyKzUpIFwiUGF0dGVybiBtYXRjaGluZyBmYWlsZWRcIlxuICB8IEFzc2VydF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIkFzc2VydGlvbiBmYWlsZWRcIlxuICB8IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIlVuZGVmaW5lZCByZWN1cnNpdmUgbW9kdWxlXCJcbiAgfCB4IC0+XG4gICAgICBsZXQgeCA9IE9iai5yZXByIHggaW5cbiAgICAgIGlmIE9iai50YWcgeCA8PiAwIHRoZW5cbiAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIHggMCkgOiBzdHJpbmcpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBjb25zdHJ1Y3RvciA9XG4gICAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIChPYmouZmllbGQgeCAwKSAwKSA6IHN0cmluZykgaW5cbiAgICAgICAgY29uc3RydWN0b3IgXiAoZmllbGRzIHgpXG5cbmxldCB0b19zdHJpbmcgZSA9XG4gIG1hdGNoIHVzZV9wcmludGVycyBlIHdpdGhcbiAgfCBTb21lIHMgLT4gc1xuICB8IE5vbmUgLT4gdG9fc3RyaW5nX2RlZmF1bHQgZVxuXG5sZXQgcHJpbnQgZmN0IGFyZyA9XG4gIHRyeVxuICAgIGZjdCBhcmdcbiAgd2l0aCB4IC0+XG4gICAgZXByaW50ZiBcIlVuY2F1Z2h0IGV4Y2VwdGlvbjogJXNcXG5cIiAodG9fc3RyaW5nIHgpO1xuICAgIGZsdXNoIHN0ZGVycjtcbiAgICByYWlzZSB4XG5cbmxldCBjYXRjaCBmY3QgYXJnID1cbiAgdHJ5XG4gICAgZmN0IGFyZ1xuICB3aXRoIHggLT5cbiAgICBmbHVzaCBzdGRvdXQ7XG4gICAgZXByaW50ZiBcIlVuY2F1Z2h0IGV4Y2VwdGlvbjogJXNcXG5cIiAodG9fc3RyaW5nIHgpO1xuICAgIGV4aXQgMlxuXG50eXBlIHJhd19iYWNrdHJhY2Vfc2xvdFxudHlwZSByYXdfYmFja3RyYWNlX2VudHJ5ID0gcHJpdmF0ZSBpbnRcbnR5cGUgcmF3X2JhY2t0cmFjZSA9IHJhd19iYWNrdHJhY2VfZW50cnkgYXJyYXlcblxubGV0IHJhd19iYWNrdHJhY2VfZW50cmllcyBidCA9IGJ0XG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlOlxuICB1bml0IC0+IHJhd19iYWNrdHJhY2UgPSBcImNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlXCJcblxuZXh0ZXJuYWwgcmFpc2Vfd2l0aF9iYWNrdHJhY2U6IGV4biAtPiByYXdfYmFja3RyYWNlIC0+ICdhXG4gID0gXCIlcmFpc2Vfd2l0aF9iYWNrdHJhY2VcIlxuXG50eXBlIGJhY2t0cmFjZV9zbG90ID1cbiAgfCBLbm93bl9sb2NhdGlvbiBvZiB7XG4gICAgICBpc19yYWlzZSAgICA6IGJvb2w7XG4gICAgICBmaWxlbmFtZSAgICA6IHN0cmluZztcbiAgICAgIGxpbmVfbnVtYmVyIDogaW50O1xuICAgICAgc3RhcnRfY2hhciAgOiBpbnQ7XG4gICAgICBlbmRfY2hhciAgICA6IGludDtcbiAgICAgIGlzX2lubGluZSAgIDogYm9vbDtcbiAgICAgIGRlZm5hbWUgICAgIDogc3RyaW5nO1xuICAgIH1cbiAgfCBVbmtub3duX2xvY2F0aW9uIG9mIHtcbiAgICAgIGlzX3JhaXNlIDogYm9vbFxuICAgIH1cblxuKCogdG8gYXZvaWQgd2FybmluZyAqKVxubGV0IF8gPSBbS25vd25fbG9jYXRpb24geyBpc19yYWlzZSA9IGZhbHNlOyBmaWxlbmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVfbnVtYmVyID0gMDsgc3RhcnRfY2hhciA9IDA7IGVuZF9jaGFyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNfaW5saW5lID0gZmFsc2U7IGRlZm5hbWUgPSBcIlwiIH07XG4gICAgICAgICBVbmtub3duX2xvY2F0aW9uIHsgaXNfcmFpc2UgPSBmYWxzZSB9XVxuXG5leHRlcm5hbCBjb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdDpcbiAgcmF3X2JhY2t0cmFjZV9zbG90IC0+IGJhY2t0cmFjZV9zbG90ID0gXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XCJcblxuZXh0ZXJuYWwgY29udmVydF9yYXdfYmFja3RyYWNlOlxuICByYXdfYmFja3RyYWNlIC0+IGJhY2t0cmFjZV9zbG90IGFycmF5ID0gXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZVwiXG5cbmxldCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UgYnQgPVxuICB0cnkgU29tZSAoY29udmVydF9yYXdfYmFja3RyYWNlIGJ0KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgcG9zIHNsb3QgPVxuICBsZXQgaW5mbyBpc19yYWlzZSA9XG4gICAgaWYgaXNfcmFpc2UgdGhlblxuICAgICAgaWYgcG9zID0gMCB0aGVuIFwiUmFpc2VkIGF0XCIgZWxzZSBcIlJlLXJhaXNlZCBhdFwiXG4gICAgZWxzZVxuICAgICAgaWYgcG9zID0gMCB0aGVuIFwiUmFpc2VkIGJ5IHByaW1pdGl2ZSBvcGVyYXRpb24gYXRcIiBlbHNlIFwiQ2FsbGVkIGZyb21cIlxuICBpblxuICBtYXRjaCBzbG90IHdpdGhcbiAgfCBVbmtub3duX2xvY2F0aW9uIGwgLT5cbiAgICAgIGlmIGwuaXNfcmFpc2UgdGhlblxuICAgICAgICAoKiBjb21waWxlci1pbnNlcnRlZCByZS1yYWlzZSwgc2tpcHBlZCAqKSBOb25lXG4gICAgICBlbHNlXG4gICAgICAgIFNvbWUgKHNwcmludGYgXCIlcyB1bmtub3duIGxvY2F0aW9uXCIgKGluZm8gZmFsc2UpKVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT5cbiAgICAgIFNvbWUgKHNwcmludGYgXCIlcyAlcyBpbiBmaWxlIFxcXCIlc1xcXCIlcywgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZFwiXG4gICAgICAgICAgICAgIChpbmZvIGwuaXNfcmFpc2UpIGwuZGVmbmFtZSBsLmZpbGVuYW1lXG4gICAgICAgICAgICAgIChpZiBsLmlzX2lubGluZSB0aGVuIFwiIChpbmxpbmVkKVwiIGVsc2UgXCJcIilcbiAgICAgICAgICAgICAgbC5saW5lX251bWJlciBsLnN0YXJ0X2NoYXIgbC5lbmRfY2hhcilcblxubGV0IHByaW50X2V4Y2VwdGlvbl9iYWNrdHJhY2Ugb3V0Y2hhbiBiYWNrdHJhY2UgPVxuICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICB8IE5vbmUgLT5cbiAgICAgIGZwcmludGYgb3V0Y2hhblxuICAgICAgICBcIihQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgY2Fubm90IHByaW50IHN0YWNrIGJhY2t0cmFjZSlcXG5cIlxuICB8IFNvbWUgYSAtPlxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBhIC0gMSBkb1xuICAgICAgICBtYXRjaCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgaSBhLihpKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIHN0ciAtPiBmcHJpbnRmIG91dGNoYW4gXCIlc1xcblwiIHN0clxuICAgICAgZG9uZVxuXG5sZXQgcHJpbnRfcmF3X2JhY2t0cmFjZSBvdXRjaGFuIHJhd19iYWNrdHJhY2UgPVxuICBwcmludF9leGNlcHRpb25fYmFja3RyYWNlIG91dGNoYW4gKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlKVxuXG4oKiBjb25mdXNpbmdseSBuYW1lZDogcHJpbnRzIHRoZSBnbG9iYWwgY3VycmVudCBiYWNrdHJhY2UgKilcbmxldCBwcmludF9iYWNrdHJhY2Ugb3V0Y2hhbiA9XG4gIHByaW50X3Jhd19iYWNrdHJhY2Ugb3V0Y2hhbiAoZ2V0X3Jhd19iYWNrdHJhY2UgKCkpXG5cbmxldCBiYWNrdHJhY2VfdG9fc3RyaW5nIGJhY2t0cmFjZSA9XG4gIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICBcIihQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgY2Fubm90IHByaW50IHN0YWNrIGJhY2t0cmFjZSlcXG5cIlxuICB8IFNvbWUgYSAtPlxuICAgICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDEwMjQgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggYSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZm9ybWF0X2JhY2t0cmFjZV9zbG90IGkgYS4oaSkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBzdHIgLT4gYnByaW50ZiBiIFwiJXNcXG5cIiBzdHJcbiAgICAgIGRvbmU7XG4gICAgICBCdWZmZXIuY29udGVudHMgYlxuXG5sZXQgcmF3X2JhY2t0cmFjZV90b19zdHJpbmcgcmF3X2JhY2t0cmFjZSA9XG4gIGJhY2t0cmFjZV90b19zdHJpbmcgKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlKVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2UgPSBmdW5jdGlvblxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19yYWlzZVxuICB8IFVua25vd25fbG9jYXRpb24gbCAtPiBsLmlzX3JhaXNlXG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmUgPSBmdW5jdGlvblxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19pbmxpbmVcbiAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gZmFsc2VcblxudHlwZSBsb2NhdGlvbiA9IHtcbiAgZmlsZW5hbWUgOiBzdHJpbmc7XG4gIGxpbmVfbnVtYmVyIDogaW50O1xuICBzdGFydF9jaGFyIDogaW50O1xuICBlbmRfY2hhciA6IGludDtcbn1cblxubGV0IGJhY2t0cmFjZV9zbG90X2xvY2F0aW9uID0gZnVuY3Rpb25cbiAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gTm9uZVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT5cbiAgICBTb21lIHtcbiAgICAgIGZpbGVuYW1lICAgID0gbC5maWxlbmFtZTtcbiAgICAgIGxpbmVfbnVtYmVyID0gbC5saW5lX251bWJlcjtcbiAgICAgIHN0YXJ0X2NoYXIgID0gbC5zdGFydF9jaGFyO1xuICAgICAgZW5kX2NoYXIgICAgPSBsLmVuZF9jaGFyO1xuICAgIH1cblxubGV0IGJhY2t0cmFjZV9zbG90X2RlZm5hbWUgPSBmdW5jdGlvblxuICB8IFVua25vd25fbG9jYXRpb24gX1xuICB8IEtub3duX2xvY2F0aW9uIHsgZGVmbmFtZSA9IFwiXCIgfSAtPiBOb25lXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBTb21lIGwuZGVmbmFtZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RzIHJhd19iYWNrdHJhY2UgPVxuICAoKiBUaGUgZG9jdW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGd1YXJhbnRlZXMgdGhhdCBTb21lIGlzXG4gICAgIHJldHVybmVkIG9ubHkgaWYgYSBwYXJ0IG9mIHRoZSB0cmFjZSBpcyB1c2FibGUuIFRoaXMgZ2l2ZXMgdXNcbiAgICAgYSBiaXQgbW9yZSB3b3JrIHRoYW4ganVzdCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UsIGJ1dCBpdCBtYWtlcyB0aGVcbiAgICAgQVBJIG1vcmUgdXNlci1mcmllbmRseSAtLSBvdGhlcndpc2UgbW9zdCB1c2VycyB3b3VsZCBoYXZlIHRvXG4gICAgIHJlaW1wbGVtZW50IHRoZSBcIlByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBzb3JyeVwiIGxvZ2ljXG4gICAgIHRoZW1zZWx2ZXMuICopXG4gIG1hdGNoIGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBiYWNrdHJhY2UgLT5cbiAgICAgIGxldCB1c2FibGVfc2xvdCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IGZhbHNlXG4gICAgICAgIHwgS25vd25fbG9jYXRpb24gXyAtPiB0cnVlIGluXG4gICAgICBsZXQgcmVjIGV4aXN0c191c2FibGUgPSBmdW5jdGlvblxuICAgICAgICB8ICgtMSkgLT4gZmFsc2VcbiAgICAgICAgfCBpIC0+IHVzYWJsZV9zbG90IGJhY2t0cmFjZS4oaSkgfHwgZXhpc3RzX3VzYWJsZSAoaSAtIDEpIGluXG4gICAgICBpZiBleGlzdHNfdXNhYmxlIChBcnJheS5sZW5ndGggYmFja3RyYWNlIC0gMSlcbiAgICAgIHRoZW4gU29tZSBiYWNrdHJhY2VcbiAgICAgIGVsc2UgTm9uZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RzX29mX3Jhd19lbnRyeSBlbnRyeSA9XG4gIGJhY2t0cmFjZV9zbG90cyBbfCBlbnRyeSB8XVxuXG5tb2R1bGUgU2xvdCA9IHN0cnVjdFxuICB0eXBlIHQgPSBiYWNrdHJhY2Vfc2xvdFxuICBsZXQgZm9ybWF0ID0gZm9ybWF0X2JhY2t0cmFjZV9zbG90XG4gIGxldCBpc19yYWlzZSA9IGJhY2t0cmFjZV9zbG90X2lzX3JhaXNlXG4gIGxldCBpc19pbmxpbmUgPSBiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmVcbiAgbGV0IGxvY2F0aW9uID0gYmFja3RyYWNlX3Nsb3RfbG9jYXRpb25cbiAgbGV0IG5hbWUgPSBiYWNrdHJhY2Vfc2xvdF9kZWZuYW1lXG5lbmRcblxubGV0IHJhd19iYWNrdHJhY2VfbGVuZ3RoIGJ0ID0gQXJyYXkubGVuZ3RoIGJ0XG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlX3Nsb3QgOlxuICByYXdfYmFja3RyYWNlIC0+IGludCAtPiByYXdfYmFja3RyYWNlX3Nsb3QgPSBcImNhbWxfcmF3X2JhY2t0cmFjZV9zbG90XCJcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90IDpcbiAgcmF3X2JhY2t0cmFjZV9zbG90IC0+IHJhd19iYWNrdHJhY2Vfc2xvdCBvcHRpb25cbiAgPSBcImNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3RcIlxuXG4oKiBjb25mdXNpbmdseSBuYW1lZDpcbiAgIHJldHVybnMgdGhlICpzdHJpbmcqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdsb2JhbCBjdXJyZW50IGJhY2t0cmFjZSAqKVxubGV0IGdldF9iYWNrdHJhY2UgKCkgPSByYXdfYmFja3RyYWNlX3RvX3N0cmluZyAoZ2V0X3Jhd19iYWNrdHJhY2UgKCkpXG5cbmV4dGVybmFsIHJlY29yZF9iYWNrdHJhY2U6IGJvb2wgLT4gdW5pdCA9IFwiY2FtbF9yZWNvcmRfYmFja3RyYWNlXCJcbmV4dGVybmFsIGJhY2t0cmFjZV9zdGF0dXM6IHVuaXQgLT4gYm9vbCA9IFwiY2FtbF9iYWNrdHJhY2Vfc3RhdHVzXCJcblxubGV0IHJlYyByZWdpc3Rlcl9wcmludGVyIGZuID1cbiAgbGV0IG9sZF9wcmludGVycyA9IEF0b21pYy5nZXQgcHJpbnRlcnMgaW5cbiAgbGV0IG5ld19wcmludGVycyA9IGZuIDo6IG9sZF9wcmludGVycyBpblxuICBsZXQgc3VjY2VzcyA9IEF0b21pYy5jb21wYXJlX2FuZF9zZXQgcHJpbnRlcnMgb2xkX3ByaW50ZXJzIG5ld19wcmludGVycyBpblxuICBpZiBub3Qgc3VjY2VzcyB0aGVuIHJlZ2lzdGVyX3ByaW50ZXIgZm5cblxuZXh0ZXJuYWwgZ2V0X2NhbGxzdGFjazogaW50IC0+IHJhd19iYWNrdHJhY2UgPSBcImNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrXCJcblxubGV0IGV4bl9zbG90IHggPVxuICBsZXQgeCA9IE9iai5yZXByIHggaW5cbiAgaWYgT2JqLnRhZyB4ID0gMCB0aGVuIE9iai5maWVsZCB4IDAgZWxzZSB4XG5cbmxldCBleG5fc2xvdF9pZCB4ID1cbiAgbGV0IHNsb3QgPSBleG5fc2xvdCB4IGluXG4gIChPYmoub2JqIChPYmouZmllbGQgc2xvdCAxKSA6IGludClcblxubGV0IGV4bl9zbG90X25hbWUgeCA9XG4gIGxldCBzbG90ID0gZXhuX3Nsb3QgeCBpblxuICAoT2JqLm9iaiAoT2JqLmZpZWxkIHNsb3QgMCkgOiBzdHJpbmcpXG5cbmV4dGVybmFsIGdldF9kZWJ1Z19pbmZvX3N0YXR1cyA6IHVuaXQgLT4gaW50ID0gXCJjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzXCJcblxuKCogRGVzY3JpcHRpb25zIGZvciBlcnJvcnMgaW4gc3RhcnR1cC5oLiBTZWUgYWxzbyBiYWNrdHJhY2UuYyAqKVxubGV0IGVycm9ycyA9IFt8IFwiXCI7XG4gICgqIEZJTEVfTk9UX0ZPVU5EICopXG4gIFwiKENhbm5vdCBwcmludCBsb2NhdGlvbnM6XFxuIFxcXG4gICAgICBieXRlY29kZSBleGVjdXRhYmxlIHByb2dyYW0gZmlsZSBub3QgZm91bmQpXCI7XG4gICgqIEJBRF9CWVRFQ09ERSAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgYXBwZWFycyB0byBiZSBjb3JydXB0KVwiO1xuICAoKiBXUk9OR19NQUdJQyAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgaGFzIHdyb25nIG1hZ2ljIG51bWJlcilcIjtcbiAgKCogTk9fRkRTICopXG4gIFwiKENhbm5vdCBwcmludCBsb2NhdGlvbnM6XFxuIFxcXG4gICAgICBieXRlY29kZSBleGVjdXRhYmxlIHByb2dyYW0gZmlsZSBjYW5ub3QgYmUgb3BlbmVkO1xcbiBcXFxuICAgICAgLS0gdG9vIG1hbnkgb3BlbiBmaWxlcy4gVHJ5IHJ1bm5pbmcgd2l0aCBPQ0FNTFJVTlBBUkFNPWI9MilcIlxufF1cblxubGV0IGRlZmF1bHRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZXhuIHJhd19iYWNrdHJhY2UgPVxuICBlcHJpbnRmIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiAlc1xcblwiICh0b19zdHJpbmcgZXhuKTtcbiAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgbGV0IHN0YXR1cyA9IGdldF9kZWJ1Z19pbmZvX3N0YXR1cyAoKSBpblxuICBpZiBzdGF0dXMgPCAwIHRoZW5cbiAgICBwcmVycl9lbmRsaW5lIGVycm9ycy4oYWJzIHN0YXR1cyk7XG4gIGZsdXNoIHN0ZGVyclxuXG5sZXQgdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgPSByZWYgZGVmYXVsdF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlclxuXG5sZXQgc2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIGZuID0gdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgOj0gZm5cblxubGV0IGVtcHR5X2JhY2t0cmFjZSA6IHJhd19iYWNrdHJhY2UgPSBbfCB8XVxuXG5sZXQgdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpID1cbiAgdHJ5XG4gICAgZ2V0X3Jhd19iYWNrdHJhY2UgKClcbiAgd2l0aCBfICgqIE91dF9vZl9tZW1vcnk/ICopIC0+XG4gICAgZW1wdHlfYmFja3RyYWNlXG5cbmxldCBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uJyBleG4gZGVidWdnZXJfaW5fdXNlID1cbiAgdHJ5XG4gICAgKCogR2V0IHRoZSBiYWNrdHJhY2Ugbm93LCBpbiBjYXNlIG9uZSBvZiB0aGUgW2F0X2V4aXRdIGZ1bmN0aW9uXG4gICAgICAgZGVzdHJveXMgaXQuICopXG4gICAgbGV0IHJhd19iYWNrdHJhY2UgPVxuICAgICAgaWYgZGVidWdnZXJfaW5fdXNlICgqIFNhbWUgdGVzdCBhcyBpbiBbcnVudGltZS9wcmludGV4Yy5jXSAqKSB0aGVuXG4gICAgICAgIGVtcHR5X2JhY2t0cmFjZVxuICAgICAgZWxzZVxuICAgICAgICB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKClcbiAgICBpblxuICAgICh0cnkgU3RkbGliLmRvX2F0X2V4aXQgKCkgd2l0aCBfIC0+ICgpKTtcbiAgICB0cnlcbiAgICAgICF1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBleG4gcmF3X2JhY2t0cmFjZVxuICAgIHdpdGggZXhuJyAtPlxuICAgICAgbGV0IHJhd19iYWNrdHJhY2UnID0gdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiAlc1xcblwiICh0b19zdHJpbmcgZXhuKTtcbiAgICAgIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3IgaW4gdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXI6IGV4Y2VwdGlvbiAlc1xcblwiXG4gICAgICAgICh0b19zdHJpbmcgZXhuJyk7XG4gICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlJztcbiAgICAgIGZsdXNoIHN0ZGVyclxuICB3aXRoXG4gICAgfCBPdXRfb2ZfbWVtb3J5IC0+XG4gICAgICAgIHByZXJyX2VuZGxpbmVcbiAgICAgICAgICBcIkZhdGFsIGVycm9yOiBvdXQgb2YgbWVtb3J5IGluIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyXCJcblxuKCogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgW2NhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXSBpblxuICAgW3J1bnRpbWUvcHJpbnRleGMuY10gd2hpY2ggZXhwZWN0cyBubyBleGNlcHRpb24gaXMgcmFpc2VkLiAqKVxubGV0IGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24gZXhuIGRlYnVnZ2VyX2luX3VzZSA9XG4gIHRyeVxuICAgIGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24nIGV4biBkZWJ1Z2dlcl9pbl91c2VcbiAgd2l0aCBfIC0+XG4gICAgKCogVGhlcmUgaXMgbm90IG11Y2ggd2UgY2FuIGRvIGF0IHRoaXMgcG9pbnQgKilcbiAgICAoKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiAnYSAtPiB1bml0XG4gID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0ICgpID1cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQcmludGV4Yy5oYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uXCJcbiAgICBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgWGF2aWVyIExlcm95IGFuZCBEYW1pZW4gRG9saWdleiwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmxldCBnZW5lcmljX3F1b3RlIHF1b3RlcXVvdGUgcyA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAobCArIDIwKSBpblxuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFwnJztcbiAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgaWYgcy5baV0gPSAnXFwnJ1xuICAgIHRoZW4gQnVmZmVyLmFkZF9zdHJpbmcgYiBxdW90ZXF1b3RlXG4gICAgZWxzZSBCdWZmZXIuYWRkX2NoYXIgYiAgcy5baV1cbiAgZG9uZTtcbiAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcJyc7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG5cbigqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyB0aGUgT3BlbiBHcm91cCBzcGVjaWZpY2F0aW9uIGZvdW5kIGhlcmU6XG4gIFtbMV1dIGh0dHA6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L3V0aWxpdGllcy9iYXNlbmFtZS5odG1sXG4gIEluIHN0ZXAgMSBvZiBbWzFdXSwgd2UgY2hvb3NlIHRvIHJldHVybiBcIi5cIiBmb3IgZW1wdHkgaW5wdXQuXG4gICAgKGZvciBjb21wYXRpYmlsaXR5IHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgT0NhbWwpXG4gIEluIHN0ZXAgMiwgd2UgY2hvb3NlIHRvIHByb2Nlc3MgXCIvL1wiIG5vcm1hbGx5LlxuICBTdGVwIDYgaXMgbm90IGltcGxlbWVudGVkOiB3ZSBjb25zaWRlciB0aGF0IHRoZSBbc3VmZml4XSBvcGVyYW5kIGlzXG4gICAgYWx3YXlzIGFic2VudC4gIFN1ZmZpeGVzIGFyZSBoYW5kbGVkIGJ5IFtjaG9wX3N1ZmZpeF0gYW5kIFtjaG9wX2V4dGVuc2lvbl0uXG4qKVxubGV0IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIG5hbWUgPVxuICBsZXQgcmVjIGZpbmRfZW5kIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBmaW5kX2VuZCAobiAtIDEpXG4gICAgZWxzZSBmaW5kX2JlZyBuIChuICsgMSlcbiAgYW5kIGZpbmRfYmVnIG4gcCA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCBwXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIFN0cmluZy5zdWIgbmFtZSAobiArIDEpIChwIC0gbiAtIDEpXG4gICAgZWxzZSBmaW5kX2JlZyAobiAtIDEpIHBcbiAgaW5cbiAgaWYgbmFtZSA9IFwiXCJcbiAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gIGVsc2UgZmluZF9lbmQgKFN0cmluZy5sZW5ndGggbmFtZSAtIDEpXG5cbigqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyB0aGUgT3BlbiBHcm91cCBzcGVjaWZpY2F0aW9uIGZvdW5kIGhlcmU6XG4gIFtbMl1dIGh0dHA6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L3V0aWxpdGllcy9kaXJuYW1lLmh0bWxcbiAgSW4gc3RlcCA2IG9mIFtbMl1dLCB3ZSBjaG9vc2UgdG8gcHJvY2VzcyBcIi8vXCIgbm9ybWFsbHkuXG4qKVxubGV0IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgbmFtZSA9XG4gIGxldCByZWMgdHJhaWxpbmdfc2VwIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiB0cmFpbGluZ19zZXAgKG4gLSAxKVxuICAgIGVsc2UgYmFzZSBuXG4gIGFuZCBiYXNlIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gY3VycmVudF9kaXJfbmFtZVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBpbnRlcm1lZGlhdGVfc2VwIG5cbiAgICBlbHNlIGJhc2UgKG4gLSAxKVxuICBhbmQgaW50ZXJtZWRpYXRlX3NlcCBuID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIDFcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gaW50ZXJtZWRpYXRlX3NlcCAobiAtIDEpXG4gICAgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCAobiArIDEpXG4gIGluXG4gIGlmIG5hbWUgPSBcIlwiXG4gIHRoZW4gY3VycmVudF9kaXJfbmFtZVxuICBlbHNlIHRyYWlsaW5nX3NlcCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxubW9kdWxlIHR5cGUgU1lTREVQUyA9IHNpZ1xuICB2YWwgbnVsbCA6IHN0cmluZ1xuICB2YWwgY3VycmVudF9kaXJfbmFtZSA6IHN0cmluZ1xuICB2YWwgcGFyZW50X2Rpcl9uYW1lIDogc3RyaW5nXG4gIHZhbCBkaXJfc2VwIDogc3RyaW5nXG4gIHZhbCBpc19kaXJfc2VwIDogc3RyaW5nIC0+IGludCAtPiBib29sXG4gIHZhbCBpc19yZWxhdGl2ZSA6IHN0cmluZyAtPiBib29sXG4gIHZhbCBpc19pbXBsaWNpdCA6IHN0cmluZyAtPiBib29sXG4gIHZhbCBjaGVja19zdWZmaXggOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGNob3Bfc3VmZml4X29wdCA6IHN1ZmZpeDpzdHJpbmcgLT4gc3RyaW5nIC0+IHN0cmluZyBvcHRpb25cbiAgdmFsIHRlbXBfZGlyX25hbWUgOiBzdHJpbmdcbiAgdmFsIHF1b3RlIDogc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgcXVvdGVfY29tbWFuZCA6XG4gICAgc3RyaW5nIC0+ID9zdGRpbjogc3RyaW5nIC0+ID9zdGRvdXQ6IHN0cmluZyAtPiA/c3RkZXJyOiBzdHJpbmdcbiAgICAgICAgICAgLT4gc3RyaW5nIGxpc3QgLT4gc3RyaW5nXG4gIHZhbCBiYXNlbmFtZSA6IHN0cmluZyAtPiBzdHJpbmdcbiAgdmFsIGRpcm5hbWUgOiBzdHJpbmcgLT4gc3RyaW5nXG5lbmRcblxubW9kdWxlIFVuaXggOiBTWVNERVBTID0gc3RydWN0XG4gIGxldCBudWxsID0gXCIvZGV2L251bGxcIlxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIi9cIlxuICBsZXQgaXNfZGlyX3NlcCBzIGkgPSBzLltpXSA9ICcvJ1xuICBsZXQgaXNfcmVsYXRpdmUgbiA9IFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJy8nXG4gIGxldCBpc19pbXBsaWNpdCBuID1cbiAgICBpc19yZWxhdGl2ZSBuXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uL1wiKVxuICBsZXQgY2hlY2tfc3VmZml4IG5hbWUgc3VmZiA9XG4gICAgU3RyaW5nLmVuZHNfd2l0aCB+c3VmZml4OnN1ZmYgbmFtZVxuXG4gIGxldCBjaG9wX3N1ZmZpeF9vcHQgfnN1ZmZpeCBmaWxlbmFtZSA9XG4gICAgbGV0IGxlbl9zID0gU3RyaW5nLmxlbmd0aCBzdWZmaXggYW5kIGxlbl9mID0gU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSBpblxuICAgIGlmIGxlbl9mID49IGxlbl9zIHRoZW5cbiAgICAgIGxldCByID0gU3RyaW5nLnN1YiBmaWxlbmFtZSAobGVuX2YgLSBsZW5fcykgbGVuX3MgaW5cbiAgICAgIGlmIHIgPSBzdWZmaXggdGhlblxuICAgICAgICBTb21lIChTdHJpbmcuc3ViIGZpbGVuYW1lIDAgKGxlbl9mIC0gbGVuX3MpKVxuICAgICAgZWxzZVxuICAgICAgICBOb25lXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG4gIGxldCB0ZW1wX2Rpcl9uYW1lID1cbiAgICB0cnkgU3lzLmdldGVudiBcIlRNUERJUlwiIHdpdGggTm90X2ZvdW5kIC0+IFwiL3RtcFwiXG4gIGxldCBxdW90ZSA9IGdlbmVyaWNfcXVvdGUgXCInXFxcXCcnXCJcbiAgbGV0IHF1b3RlX2NvbW1hbmQgY21kID9zdGRpbiA/c3Rkb3V0ID9zdGRlcnIgYXJncyA9XG4gICAgU3RyaW5nLmNvbmNhdCBcIiBcIiAoTGlzdC5tYXAgcXVvdGUgKGNtZCA6OiBhcmdzKSlcbiAgICBeIChtYXRjaCBzdGRpbiAgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPFwiIF4gcXVvdGUgZilcbiAgICBeIChtYXRjaCBzdGRvdXQgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPlwiIF4gcXVvdGUgZilcbiAgICBeIChtYXRjaCBzdGRlcnIgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gaWYgc3RkZXJyID0gc3Rkb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIFwiIDI+JjFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBcIiAyPlwiIF4gcXVvdGUgZilcbiAgbGV0IGJhc2VuYW1lID0gZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbiAgbGV0IGRpcm5hbWUgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG5lbmRcblxubW9kdWxlIFdpbjMyIDogU1lTREVQUyA9IHN0cnVjdFxuICBsZXQgbnVsbCA9IFwiTlVMXCJcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCJcXFxcXCJcbiAgbGV0IGlzX2Rpcl9zZXAgcyBpID0gbGV0IGMgPSBzLltpXSBpbiBjID0gJy8nIHx8IGMgPSAnXFxcXCcgfHwgYyA9ICc6J1xuICBsZXQgaXNfcmVsYXRpdmUgbiA9XG4gICAgKFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJy8nKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICdcXFxcJylcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBuLlsxXSA8PiAnOicpXG4gIGxldCBpc19pbXBsaWNpdCBuID1cbiAgICBpc19yZWxhdGl2ZSBuXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi5cXFxcXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLlxcXFxcIilcbiAgbGV0IGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICAgU3RyaW5nLmxlbmd0aCBuYW1lID49IFN0cmluZy5sZW5ndGggc3VmZiAmJlxuICAgKGxldCBzID0gU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFN0cmluZy5sZW5ndGggc3VmZikgaW5cbiAgICBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHMgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN1ZmYpXG5cbiAgbGV0IGNob3Bfc3VmZml4X29wdCB+c3VmZml4IGZpbGVuYW1lID1cbiAgICBsZXQgbGVuX3MgPSBTdHJpbmcubGVuZ3RoIHN1ZmZpeCBhbmQgbGVuX2YgPSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgaWYgbGVuX2YgPj0gbGVuX3MgdGhlblxuICAgICAgbGV0IHIgPSBTdHJpbmcuc3ViIGZpbGVuYW1lIChsZW5fZiAtIGxlbl9zKSBsZW5fcyBpblxuICAgICAgaWYgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSByID0gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzdWZmaXggdGhlblxuICAgICAgICBTb21lIChTdHJpbmcuc3ViIGZpbGVuYW1lIDAgKGxlbl9mIC0gbGVuX3MpKVxuICAgICAgZWxzZVxuICAgICAgICBOb25lXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5cbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVEVNUFwiIHdpdGggTm90X2ZvdW5kIC0+IFwiLlwiXG4gIGxldCBxdW90ZSBzID1cbiAgICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAobCArIDIwKSBpblxuICAgIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbCB0aGVuIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJyBlbHNlXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICdcXFwiJyAtPiBsb29wX2JzIDAgaTtcbiAgICAgIHwgJ1xcXFwnIC0+IGxvb3BfYnMgMCBpO1xuICAgICAgfCBjICAgIC0+IEJ1ZmZlci5hZGRfY2hhciBiIGM7IGxvb3AgKGkrMSk7XG4gICAgYW5kIGxvb3BfYnMgbiBpID1cbiAgICAgIGlmIGkgPSBsIHRoZW4gYmVnaW5cbiAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInO1xuICAgICAgICBhZGRfYnMgbjtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgICAgfCAnXFxcIicgLT4gYWRkX2JzICgyKm4rMSk7IEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJzsgbG9vcCAoaSsxKTtcbiAgICAgICAgfCAnXFxcXCcgLT4gbG9vcF9icyAobisxKSAoaSsxKTtcbiAgICAgICAgfCBfICAgIC0+IGFkZF9icyBuOyBsb29wIGlcbiAgICAgIGVuZFxuICAgIGFuZCBhZGRfYnMgbiA9IGZvciBfaiA9IDEgdG8gbiBkbyBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcXCc7IGRvbmVcbiAgICBpblxuICAgIGxvb3AgMDtcbiAgICBCdWZmZXIuY29udGVudHMgYlxuKCpcblF1b3RpbmcgY29tbWFuZHMgZm9yIGV4ZWN1dGlvbiBieSBjbWQuZXhlIGlzIGRpZmZpY3VsdC5cbjEtIEVhY2ggYXJndW1lbnQgaXMgZmlyc3QgcXVvdGVkIHVzaW5nIHRoZSBcInF1b3RlXCIgZnVuY3Rpb24gYWJvdmUsIHRvXG4gICBwcm90ZWN0IGl0IGFnYWluc3QgdGhlIHByb2Nlc3NpbmcgcGVyZm9ybWVkIGJ5IHRoZSBDIHJ1bnRpbWUgc3lzdGVtLFxuICAgdGhlbiBjbWQuZXhlJ3Mgc3BlY2lhbCBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkIHdpdGggJ14nLCB1c2luZ1xuICAgdGhlIFwicXVvdGVfY21kXCIgZnVuY3Rpb24gYmVsb3cuICBGb3IgbW9yZSBkZXRhaWxzLCBzZWVcbiAgIGh0dHBzOi8vYmxvZ3MubXNkbi5taWNyb3NvZnQuY29tL3R3aXN0eWxpdHRsZXBhc3NhZ2VzYWxsYWxpa2UvMjAxMS8wNC8yM1xuMi0gVGhlIGNvbW1hbmQgYW5kIHRoZSByZWRpcmVjdGlvbiBmaWxlcywgaWYgYW55LCBtdXN0IGJlIGRvdWJsZS1xdW90ZWRcbiAgIGluIGNhc2UgdGhleSBjb250YWluIHNwYWNlcy4gIFRoaXMgcXVvdGluZyBpcyBpbnRlcnByZXRlZCBieSBjbWQuZXhlLFxuICAgbm90IGJ5IHRoZSBDIHJ1bnRpbWUgc3lzdGVtLCBoZW5jZSB0aGUgXCJxdW90ZVwiIGZ1bmN0aW9uIGFib3ZlXG4gICBjYW5ub3QgYmUgdXNlZC4gIFRoZSB0d28gY2hhcmFjdGVycyB3ZSBkb24ndCBrbm93IGhvdyB0byBxdW90ZVxuICAgaW5zaWRlIGEgZG91YmxlLXF1b3RlZCBjbWQuZXhlIHN0cmluZyBhcmUgZG91YmxlLXF1b3RlIGFuZCBwZXJjZW50LlxuICAgV2UganVzdCBmYWlsIGlmIHRoZSBjb21tYW5kIG5hbWUgb3IgdGhlIHJlZGlyZWN0aW9uIGZpbGUgbmFtZXNcbiAgIGNvbnRhaW4gYSBkb3VibGUgcXVvdGUgKG5vdCBhbGxvd2VkIGluIFdpbmRvd3MgZmlsZSBuYW1lcywgYW55d2F5KVxuICAgb3IgYSBwZXJjZW50LiAgU2VlIGZ1bmN0aW9uIFwicXVvdGVfY21kX2ZpbGVuYW1lXCIgYmVsb3cuXG4zLSBUaGUgd2hvbGUgc3RyaW5nIHBhc3NlZCB0byBTeXMuY29tbWFuZCBpcyB0aGVuIGVuY2xvc2VkIGluIGRvdWJsZVxuICAgcXVvdGVzLCB3aGljaCBhcmUgaW1tZWRpYXRlbHkgc3RyaXBwZWQgYnkgY21kLmV4ZS4gIE90aGVyd2lzZSxcbiAgIHNvbWUgb2YgdGhlIGRvdWJsZSBxdW90ZXMgZnJvbSBzdGVwIDIgYWJvdmUgY2FuIGJlIG1pc3BhcnNlZC5cbiAgIFNlZSBlLmcuIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85OTY1MTQxXG4qKVxuICBsZXQgcXVvdGVfY21kIHMgPVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAoU3RyaW5nLmxlbmd0aCBzICsgMjApIGluXG4gICAgU3RyaW5nLml0ZXJcbiAgICAgIChmdW4gYyAtPlxuICAgICAgICBtYXRjaCBjIHdpdGhcbiAgICAgICAgfCAnKCcgfCAnKScgfCAnIScgfCAnXicgfCAnJScgfCAnXFxcIicgfCAnPCcgfCAnPicgfCAnJicgfCAnfCcgLT5cbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiICdeJzsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiIGMpXG4gICAgICBzO1xuICAgIEJ1ZmZlci5jb250ZW50cyBiXG4gIGxldCBxdW90ZV9jbWRfZmlsZW5hbWUgZiA9XG4gICAgaWYgU3RyaW5nLmNvbnRhaW5zIGYgJ1xcXCInIHx8IFN0cmluZy5jb250YWlucyBmICclJyB0aGVuXG4gICAgICBmYWlsd2l0aCAoXCJGaWxlbmFtZS5xdW90ZV9jb21tYW5kOiBiYWQgZmlsZSBuYW1lIFwiIF4gZilcbiAgICBlbHNlIGlmIFN0cmluZy5jb250YWlucyBmICcgJyB0aGVuXG4gICAgICBcIlxcXCJcIiBeIGYgXiBcIlxcXCJcIlxuICAgIGVsc2VcbiAgICAgIGZcbiAgKCogUmVkaXJlY3Rpb25zIGluIGNtZC5leGU6IHNlZSBodHRwczovL3NzNjQuY29tL250L3N5bnRheC1yZWRpcmVjdGlvbi5odG1sXG4gICAgIGFuZCBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9wcmV2aW91cy12ZXJzaW9ucy93aW5kb3dzL2l0LXByby93aW5kb3dzLXhwL2JiNDkwOTgyKHY9dGVjaG5ldC4xMClcbiAgKilcbiAgbGV0IHF1b3RlX2NvbW1hbmQgY21kID9zdGRpbiA/c3Rkb3V0ID9zdGRlcnIgYXJncyA9XG4gICAgU3RyaW5nLmNvbmNhdCBcIlwiIFtcbiAgICAgIFwiXFxcIlwiO1xuICAgICAgcXVvdGVfY21kX2ZpbGVuYW1lIGNtZDtcbiAgICAgIFwiIFwiO1xuICAgICAgcXVvdGVfY21kIChTdHJpbmcuY29uY2F0IFwiIFwiIChMaXN0Lm1hcCBxdW90ZSBhcmdzKSk7XG4gICAgICAobWF0Y2ggc3RkaW4gIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+IFwiIDxcIiBeIHF1b3RlX2NtZF9maWxlbmFtZSBmKTtcbiAgICAgIChtYXRjaCBzdGRvdXQgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPlwiIF4gcXVvdGVfY21kX2ZpbGVuYW1lIGYpO1xuICAgICAgKG1hdGNoIHN0ZGVyciB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHN0ZGVyciA9IHN0ZG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gXCIgMj4mMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBcIiAyPlwiIF4gcXVvdGVfY21kX2ZpbGVuYW1lIGYpO1xuICAgICAgXCJcXFwiXCJcbiAgICBdXG4gIGxldCBoYXNfZHJpdmUgcyA9XG4gICAgbGV0IGlzX2xldHRlciA9IGZ1bmN0aW9uXG4gICAgICB8ICdBJyAuLiAnWicgfCAnYScgLi4gJ3onIC0+IHRydWVcbiAgICAgIHwgXyAtPiBmYWxzZVxuICAgIGluXG4gICAgU3RyaW5nLmxlbmd0aCBzID49IDIgJiYgaXNfbGV0dGVyIHMuWzBdICYmIHMuWzFdID0gJzonXG4gIGxldCBkcml2ZV9hbmRfcGF0aCBzID1cbiAgICBpZiBoYXNfZHJpdmUgc1xuICAgIHRoZW4gKFN0cmluZy5zdWIgcyAwIDIsIFN0cmluZy5zdWIgcyAyIChTdHJpbmcubGVuZ3RoIHMgLSAyKSlcbiAgICBlbHNlIChcIlwiLCBzKVxuICBsZXQgZGlybmFtZSBzID1cbiAgICBsZXQgKGRyaXZlLCBwYXRoKSA9IGRyaXZlX2FuZF9wYXRoIHMgaW5cbiAgICBsZXQgZGlyID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBwYXRoIGluXG4gICAgZHJpdmUgXiBkaXJcbiAgbGV0IGJhc2VuYW1lIHMgPVxuICAgIGxldCAoX2RyaXZlLCBwYXRoKSA9IGRyaXZlX2FuZF9wYXRoIHMgaW5cbiAgICBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBwYXRoXG5lbmRcblxubW9kdWxlIEN5Z3dpbiA6IFNZU0RFUFMgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIi9kZXYvbnVsbFwiXG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwID0gV2luMzIuaXNfZGlyX3NlcFxuICBsZXQgaXNfcmVsYXRpdmUgPSBXaW4zMi5pc19yZWxhdGl2ZVxuICBsZXQgaXNfaW1wbGljaXQgPSBXaW4zMi5pc19pbXBsaWNpdFxuICBsZXQgY2hlY2tfc3VmZml4ID0gV2luMzIuY2hlY2tfc3VmZml4XG4gIGxldCBjaG9wX3N1ZmZpeF9vcHQgPSBXaW4zMi5jaG9wX3N1ZmZpeF9vcHRcbiAgbGV0IHRlbXBfZGlyX25hbWUgPSBVbml4LnRlbXBfZGlyX25hbWVcbiAgbGV0IHF1b3RlID0gVW5peC5xdW90ZVxuICBsZXQgcXVvdGVfY29tbWFuZCA9IFVuaXgucXVvdGVfY29tbWFuZFxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5tb2R1bGUgU3lzZGVwcyA9XG4gICh2YWwgKG1hdGNoIFN5cy5vc190eXBlIHdpdGhcbiAgICAgICB8IFwiV2luMzJcIiAtPiAobW9kdWxlIFdpbjMyOiBTWVNERVBTKVxuICAgICAgIHwgXCJDeWd3aW5cIiAtPiAobW9kdWxlIEN5Z3dpbjogU1lTREVQUylcbiAgICAgICB8IF8gLT4gKG1vZHVsZSBVbml4OiBTWVNERVBTKSkpXG5cbmluY2x1ZGUgU3lzZGVwc1xuXG5sZXQgY29uY2F0IGRpcm5hbWUgZmlsZW5hbWUgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggZGlybmFtZSBpblxuICBpZiBsID0gMCB8fCBpc19kaXJfc2VwIGRpcm5hbWUgKGwtMSlcbiAgdGhlbiBkaXJuYW1lIF4gZmlsZW5hbWVcbiAgZWxzZSBkaXJuYW1lIF4gZGlyX3NlcCBeIGZpbGVuYW1lXG5cbmxldCBjaG9wX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICBsZXQgbiA9IFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZiBpblxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9zdWZmaXhcIiBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIG5cblxubGV0IGV4dGVuc2lvbl9sZW4gbmFtZSA9XG4gIGxldCByZWMgY2hlY2sgaTAgaSA9XG4gICAgaWYgaSA8IDAgfHwgaXNfZGlyX3NlcCBuYW1lIGkgdGhlbiAwXG4gICAgZWxzZSBpZiBuYW1lLltpXSA9ICcuJyB0aGVuIGNoZWNrIGkwIChpIC0gMSlcbiAgICBlbHNlIFN0cmluZy5sZW5ndGggbmFtZSAtIGkwXG4gIGluXG4gIGxldCByZWMgc2VhcmNoX2RvdCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaSAoaSAtIDEpXG4gICAgZWxzZSBzZWFyY2hfZG90IChpIC0gMSlcbiAgaW5cbiAgc2VhcmNoX2RvdCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxubGV0IGV4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBcIlwiIGVsc2UgU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKSBsXG5cbmxldCBjaG9wX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZpbGVuYW1lLmNob3BfZXh0ZW5zaW9uXCJcbiAgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gbClcblxubGV0IHJlbW92ZV9leHRlbnNpb24gbmFtZSA9XG4gIGxldCBsID0gZXh0ZW5zaW9uX2xlbiBuYW1lIGluXG4gIGlmIGwgPSAwIHRoZW4gbmFtZSBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5leHRlcm5hbCBvcGVuX2Rlc2M6IHN0cmluZyAtPiBvcGVuX2ZsYWcgbGlzdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX3N5c19vcGVuXCJcbmV4dGVybmFsIGNsb3NlX2Rlc2M6IGludCAtPiB1bml0ID0gXCJjYW1sX3N5c19jbG9zZVwiXG5cbmxldCBwcm5nID0gbGF6eShSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQgKCkpXG5cbmxldCB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJuZCA9IChSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSkgbGFuZCAweEZGRkZGRiBpblxuICBjb25jYXQgdGVtcF9kaXIgKFByaW50Zi5zcHJpbnRmIFwiJXMlMDZ4JXNcIiBwcmVmaXggcm5kIHN1ZmZpeClcblxuXG5sZXQgY3VycmVudF90ZW1wX2Rpcl9uYW1lID0gcmVmIHRlbXBfZGlyX25hbWVcblxubGV0IHNldF90ZW1wX2Rpcl9uYW1lIHMgPSBjdXJyZW50X3RlbXBfZGlyX25hbWUgOj0gc1xubGV0IGdldF90ZW1wX2Rpcl9uYW1lICgpID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZVxuXG5sZXQgdGVtcF9maWxlID8odGVtcF9kaXIgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lKSBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJlYyB0cnlfbmFtZSBjb3VudGVyID1cbiAgICBsZXQgbmFtZSA9IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggaW5cbiAgICB0cnlcbiAgICAgIGNsb3NlX2Rlc2Mob3Blbl9kZXNjIG5hbWUgW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX2V4Y2xdIDBvNjAwKTtcbiAgICAgIG5hbWVcbiAgICB3aXRoIFN5c19lcnJvciBfIGFzIGUgLT5cbiAgICAgIGlmIGNvdW50ZXIgPj0gMTAwMCB0aGVuIHJhaXNlIGUgZWxzZSB0cnlfbmFtZSAoY291bnRlciArIDEpXG4gIGluIHRyeV9uYW1lIDBcblxubGV0IG9wZW5fdGVtcF9maWxlID8obW9kZSA9IFtPcGVuX3RleHRdKSA/KHBlcm1zID0gMG82MDApXG4gICAgICAgICAgICAgICAgICAgPyh0ZW1wX2RpciA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWUpIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgKG5hbWUsXG4gICAgICAgb3Blbl9vdXRfZ2VuIChPcGVuX3dyb25seTo6T3Blbl9jcmVhdDo6T3Blbl9leGNsOjptb2RlKSBwZXJtcyBuYW1lKVxuICAgIHdpdGggU3lzX2Vycm9yIF8gYXMgZSAtPlxuICAgICAgaWYgY291bnRlciA+PSAxMDAwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDb21wbGV4IG51bWJlcnMgKilcblxudHlwZSB0ID0geyByZTogZmxvYXQ7IGltOiBmbG9hdCB9XG5cbmxldCB6ZXJvID0geyByZSA9IDAuMDsgaW0gPSAwLjAgfVxubGV0IG9uZSA9IHsgcmUgPSAxLjA7IGltID0gMC4wIH1cbmxldCBpID0geyByZSA9IDAuMDsgaW0gPSAxLjAgfVxuXG5sZXQgYWRkIHggeSA9IHsgcmUgPSB4LnJlICsuIHkucmU7IGltID0geC5pbSArLiB5LmltIH1cblxubGV0IHN1YiB4IHkgPSB7IHJlID0geC5yZSAtLiB5LnJlOyBpbSA9IHguaW0gLS4geS5pbSB9XG5cbmxldCBuZWcgeCA9IHsgcmUgPSAtLiB4LnJlOyBpbSA9IC0uIHguaW0gfVxuXG5sZXQgY29uaiB4ID0geyByZSA9IHgucmU7IGltID0gLS4geC5pbSB9XG5cbmxldCBtdWwgeCB5ID0geyByZSA9IHgucmUgKi4geS5yZSAtLiB4LmltICouIHkuaW07XG4gICAgICAgICAgICAgICAgaW0gPSB4LnJlICouIHkuaW0gKy4geC5pbSAqLiB5LnJlIH1cblxubGV0IGRpdiB4IHkgPVxuICBpZiBhYnNfZmxvYXQgeS5yZSA+PSBhYnNfZmxvYXQgeS5pbSB0aGVuXG4gICAgbGV0IHIgPSB5LmltIC8uIHkucmUgaW5cbiAgICBsZXQgZCA9IHkucmUgKy4gciAqLiB5LmltIGluXG4gICAgeyByZSA9ICh4LnJlICsuIHIgKi4geC5pbSkgLy4gZDtcbiAgICAgIGltID0gKHguaW0gLS4gciAqLiB4LnJlKSAvLiBkIH1cbiAgZWxzZVxuICAgIGxldCByID0geS5yZSAvLiB5LmltIGluXG4gICAgbGV0IGQgPSB5LmltICsuIHIgKi4geS5yZSBpblxuICAgIHsgcmUgPSAociAqLiB4LnJlICsuIHguaW0pIC8uIGQ7XG4gICAgICBpbSA9IChyICouIHguaW0gLS4geC5yZSkgLy4gZCB9XG5cbmxldCBpbnYgeCA9IGRpdiBvbmUgeFxuXG5sZXQgbm9ybTIgeCA9IHgucmUgKi4geC5yZSArLiB4LmltICouIHguaW1cblxubGV0IG5vcm0geCA9XG4gICgqIFdhdGNoIG91dCBmb3Igb3ZlcmZsb3cgaW4gY29tcHV0aW5nIHJlXjIgKyBpbV4yICopXG4gIGxldCByID0gYWJzX2Zsb2F0IHgucmUgYW5kIGkgPSBhYnNfZmxvYXQgeC5pbSBpblxuICBpZiByID0gMC4wIHRoZW4gaVxuICBlbHNlIGlmIGkgPSAwLjAgdGhlbiByXG4gIGVsc2UgaWYgciA+PSBpIHRoZW5cbiAgICBsZXQgcSA9IGkgLy4gciBpbiByICouIHNxcnQoMS4wICsuIHEgKi4gcSlcbiAgZWxzZVxuICAgIGxldCBxID0gciAvLiBpIGluIGkgKi4gc3FydCgxLjAgKy4gcSAqLiBxKVxuXG5sZXQgYXJnIHggPSBhdGFuMiB4LmltIHgucmVcblxubGV0IHBvbGFyIG4gYSA9IHsgcmUgPSBjb3MgYSAqLiBuOyBpbSA9IHNpbiBhICouIG4gfVxuXG5sZXQgc3FydCB4ID1cbiAgaWYgeC5yZSA9IDAuMCAmJiB4LmltID0gMC4wIHRoZW4geyByZSA9IDAuMDsgaW0gPSAwLjAgfVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBhYnNfZmxvYXQgeC5yZSBhbmQgaSA9IGFic19mbG9hdCB4LmltIGluXG4gICAgbGV0IHcgPVxuICAgICAgaWYgciA+PSBpIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IHEgPSBpIC8uIHIgaW5cbiAgICAgICAgc3FydChyKSAqLiBzcXJ0KDAuNSAqLiAoMS4wICsuIHNxcnQoMS4wICsuIHEgKi4gcSkpKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IHEgPSByIC8uIGkgaW5cbiAgICAgICAgc3FydChpKSAqLiBzcXJ0KDAuNSAqLiAocSArLiBzcXJ0KDEuMCArLiBxICouIHEpKSlcbiAgICAgIGVuZCBpblxuICAgIGlmIHgucmUgPj0gMC4wXG4gICAgdGhlbiB7IHJlID0gdzsgIGltID0gMC41ICouIHguaW0gLy4gdyB9XG4gICAgZWxzZSB7IHJlID0gMC41ICouIGkgLy4gdzsgIGltID0gaWYgeC5pbSA+PSAwLjAgdGhlbiB3IGVsc2UgLS4gdyB9XG4gIGVuZFxuXG5sZXQgZXhwIHggPVxuICBsZXQgZSA9IGV4cCB4LnJlIGluIHsgcmUgPSBlICouIGNvcyB4LmltOyBpbSA9IGUgKi4gc2luIHguaW0gfVxuXG5sZXQgbG9nIHggPSB7IHJlID0gbG9nIChub3JtIHgpOyBpbSA9IGF0YW4yIHguaW0geC5yZSB9XG5cbmxldCBwb3cgeCB5ID0gZXhwIChtdWwgeSAobG9nIHgpKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgIEJlbm9pdCBWYXVnb24sIEVOU1RBICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQYWRkaW5nIHBvc2l0aW9uLiAqKVxudHlwZSBwYWR0eSA9XG4gIHwgTGVmdCAgICgqIFRleHQgaXMgbGVmdCBqdXN0aWZpZWQgKCctJyBvcHRpb24pLiAgICAgICAgICAgICAgICopXG4gIHwgUmlnaHQgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIChubyAnLScgb3B0aW9uKS4gICAgICAgICAgICopXG4gIHwgWmVyb3MgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIGJ5IHplcm9zIChzZWUgJzAnIG9wdGlvbikuICopXG5cbigqKiopXG5cbigqIEludGVnZXIgY29udmVyc2lvbi4gKilcbnR5cGUgaW50X2NvbnYgPVxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkICAgICAgICAoKiAgJWQgfCAlK2QgfCAlIGQgICopXG4gIHwgSW50X2kgfCBJbnRfcGkgfCBJbnRfc2kgICAgICAgICgqICAlaSB8ICUraSB8ICUgaSAgKilcbiAgfCBJbnRfeCB8IEludF9DeCAgICAgICAgICAgICAgICAgKCogICV4IHwgJSN4ICAgICAgICAqKVxuICB8IEludF9YIHwgSW50X0NYICAgICAgICAgICAgICAgICAoKiAgJVggfCAlI1ggICAgICAgICopXG4gIHwgSW50X28gfCBJbnRfQ28gICAgICAgICAgICAgICAgICgqICAlbyB8ICUjbyAgICAgICAgKilcbiAgfCBJbnRfdSAgICAgICAgICAgICAgICAgICAgICAgICAgKCogICV1ICAgICAgICAgICAgICAqKVxuICB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAgICAgICAoKiAgJSNkIHwgJSNpIHwgJSN1ICopXG5cbigqIEZsb2F0IGNvbnZlcnNpb24uICopXG50eXBlIGZsb2F0X2ZsYWdfY29udiA9XG4gIHwgRmxvYXRfZmxhZ18gICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGaEhdICopXG4gIHwgRmxvYXRfZmxhZ19wICAgICAgICAgICAgICAgICAgICgqICUrW2ZlRWdHRmhIXSAqKVxuICB8IEZsb2F0X2ZsYWdfcyAgICAgICAgICAgICAgICAgICAoKiAlIFtmZUVnR0ZoSF0gKilcbnR5cGUgZmxvYXRfa2luZF9jb252ID1cbiAgfCBGbG9hdF9mICAgICAgICAgICAgICAgICAgICAgICAgKCogICVmIHwgJStmIHwgJSBmICAqKVxuICB8IEZsb2F0X2UgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJWUgfCAlK2UgfCAlIGUgICopXG4gIHwgRmxvYXRfRSAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRSB8ICUrRSB8ICUgRSAgKilcbiAgfCBGbG9hdF9nICAgICAgICAgICAgICAgICAgICAgICAgKCogICVnIHwgJStnIHwgJSBnICAqKVxuICB8IEZsb2F0X0cgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUcgfCAlK0cgfCAlIEcgICopXG4gIHwgRmxvYXRfRiAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRiB8ICUrRiB8ICUgRiAgKilcbiAgfCBGbG9hdF9oICAgICAgICAgICAgICAgICAgICAgICAgKCogICVoIHwgJStoIHwgJSBoICAqKVxuICB8IEZsb2F0X0ggICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUggfCAlK0ggfCAlIEggICopXG4gIHwgRmxvYXRfQ0YgICAgICAgICAgICAgICAgICAgICAgICgqICAlI0Z8ICUrI0Z8ICUgI0YgKilcbnR5cGUgZmxvYXRfY29udiA9IGZsb2F0X2ZsYWdfY29udiAqIGZsb2F0X2tpbmRfY29udlxuXG4oKioqKVxuXG4oKiBDaGFyIHNldHMgKHNlZSAlWy4uLl0pIGFyZSBiaXRtYXBzIGltcGxlbWVudGVkIGFzIDMyLWNoYXIgc3RyaW5ncy4gKilcbnR5cGUgY2hhcl9zZXQgPSBzdHJpbmdcblxuKCoqKilcblxuKCogQ291bnRlciB1c2VkIGluIFNjYW5mLiAqKVxudHlwZSBjb3VudGVyID1cbiAgfCBMaW5lX2NvdW50ZXIgICAgICgqICAlbCAgICAgICopXG4gIHwgQ2hhcl9jb3VudGVyICAgICAoKiAgJW4gICAgICAqKVxuICB8IFRva2VuX2NvdW50ZXIgICAgKCogICVOLCAlTCAgKilcblxuKCoqKilcblxuKCogUGFkZGluZyBvZiBzdHJpbmdzIGFuZCBudW1iZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwYWRkaW5nID1cbiAgKCogTm8gcGFkZGluZyAoZXg6IFwiJWRcIikgKilcbiAgfCBOb19wYWRkaW5nICA6ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogTGl0ZXJhbCBwYWRkaW5nIChleDogXCIlOGRcIikgKilcbiAgfCBMaXRfcGFkZGluZyA6IHBhZHR5ICogaW50IC0+ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogUGFkZGluZyBhcyBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpkXCIpICopXG4gIHwgQXJnX3BhZGRpbmcgOiBwYWR0eSAtPiAoaW50IC0+ICdhLCAnYSkgcGFkZGluZ1xuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9kLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHBhZGRpbmcgb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcGFkX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogUHJlY2lzaW9uIG9mIGZsb2F0cyBhbmQgJzAnLXBhZGRpbmcgb2YgaW50ZWdlcnMuICopXG50eXBlICgnYSwgJ2IpIHByZWNpc2lvbiA9XG4gICgqIE5vIHByZWNpc2lvbiAoZXg6IFwiJWZcIikgKilcbiAgfCBOb19wcmVjaXNpb24gOiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogTGl0ZXJhbCBwcmVjaXNpb24gKGV4OiBcIiUuM2ZcIikgKilcbiAgfCBMaXRfcHJlY2lzaW9uIDogaW50IC0+ICgnYSwgJ2EpIHByZWNpc2lvblxuICAoKiBQcmVjaXNpb24gYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUuKmZcIikgKilcbiAgfCBBcmdfcHJlY2lzaW9uIDogKGludCAtPiAnYSwgJ2EpIHByZWNpc2lvblxuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9mLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHByZWNpc2lvbiBvcHRpb24gKG5vIGV4dHJhIGFyZ3VtZW50KSAqKVxudHlwZSBwcmVjX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogc2VlIHRoZSBDdXN0b20gZm9ybWF0IGNvbWJpbmF0b3IgKilcbnR5cGUgKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSA9XG4gIHwgQ3VzdG9tX3plcm8gOiAoJ2EsIHN0cmluZywgJ2EpIGN1c3RvbV9hcml0eVxuICB8IEN1c3RvbV9zdWNjIDogKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSAtPlxuICAgICgnYSwgJ3ggLT4gJ2IsICd4IC0+ICdjKSBjdXN0b21fYXJpdHlcblxuKCoqKilcblxuKCogICAgICAgIFJlbGF0aW9uYWwgZm9ybWF0IHR5cGVzXG5cbkluIHRoZSBmaXJzdCBmb3JtYXQrZ2FkdHMgaW1wbGVtZW50YXRpb24sIHRoZSB0eXBlIGZvciAlKC4uJSkgaW4gdGhlXG5mbXQgR0FEVCB3YXMgYXMgZm9sbG93czpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqICgnZDEsICdxMSwgJ2QyLCAncTIpIHJlYWRlcl9uYl91bmlmaWVyICpcbiAgICAoJ3gsICdiLCAnYywgJ2QxLCAncTEsICd1KSBmbXR0eSAqXG4gICAgKCd1LCAnYiwgJ2MsICdxMSwgJ2UxLCAnZikgZm10IC0+XG4gICAgICAoKCd4LCAnYiwgJ2MsICdkMiwgJ3EyLCAndSkgZm9ybWF0NiAtPiAneCwgJ2IsICdjLCAnZDEsICdlMSwgJ2YpIGZtdFxuXG5Ob3RpY2UgdGhhdCB0aGUgJ3UgcGFyYW1ldGVyIGluICdmIHBvc2l0aW9uIGluIHRoZSBmb3JtYXQgYXJndW1lbnRcbigoJ3gsIC4uLCAndSkgZm9ybWF0NiAtPiAuLikgaXMgZXF1YWwgdG8gdGhlICd1IHBhcmFtZXRlciBpbiAnYVxucG9zaXRpb24gaW4gdGhlIGZvcm1hdCB0YWlsICgoJ3UsIC4uLCAnZikgZm10KS4gVGhpcyBtZWFucyB0aGF0IHRoZVxudHlwZSBvZiB0aGUgZXhwZWN0ZWQgZm9ybWF0IHBhcmFtZXRlciBkZXBlbmRzIG9mIHdoZXJlIHRoZSAlKC4uLiUpXG5hcmUgaW4gdGhlIGZvcm1hdCBzdHJpbmc6XG5cbiAgIyBQcmludGYucHJpbnRmIFwiJSglKVwiXG4gIC0gOiAodW5pdCwgb3V0X2NoYW5uZWwsIHVuaXQsICdfYSwgJ19hLCB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gdW5pdFxuICA9IDxmdW4+XG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSklZFwiXG4gIC0gOiAoaW50IC0+IHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgaW50IC0+IHVuaXQpXG4gICAgICBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NiAtPiBpbnQgLT4gdW5pdFxuICA9IDxmdW4+XG5cbk9uIHRoZSBjb250cmFyeSwgdGhlIGxlZ2FjeSB0eXBlciBnaXZlcyBhIGNsZXZlciB0eXBlIHRoYXQgZG9lcyBub3RcbmRlcGVuZCBvbiB0aGUgcG9zaXRpb24gb2YgJSguLiUpIGluIHRoZSBmb3JtYXQgc3RyaW5nLiBGb3IgZXhhbXBsZSxcbiUoJSkgd2lsbCBoYXZlIHRoZSBwb2x5bW9ycGhpYyB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKTogaXQgY2FuXG5iZSBjb25jYXRlbmF0ZWQgdG8gYW55IGZvcm1hdCB0eXBlLCBhbmQgb25seSBlbmZvcmNlcyB0aGUgY29uc3RyYWludFxudGhhdCBpdHMgJ2EgYW5kICdmIHBhcmFtZXRlcnMgYXJlIGVxdWFsIChubyBmb3JtYXQgYXJndW1lbnRzKSBhbmQgJ2RcbmFuZCAnZSBhcmUgZXF1YWwgKG5vIHJlYWRlciBhcmd1bWVudCkuXG5cblRoZSB3ZWFrZW5pbmcgb2YgdGhpcyBwYXJhbWV0ZXIgdHlwZSBpbiB0aGUgR0FEVCB2ZXJzaW9uIGJyb2tlIHVzZXJcbmNvZGUgKGluIGZhY3QgaXQgZXNzZW50aWFsbHkgbWFkZSAlKC4uLiUpIHVudXNhYmxlIGV4Y2VwdCBhdCB0aGUgbGFzdFxucG9zaXRpb24gb2YgYSBmb3JtYXQpLiBJbiBwYXJ0aWN1bGFyLCB0aGUgZm9sbG93aW5nIHdvdWxkIG5vdCB3b3JrXG5hbnltb3JlOlxuXG4gIGZ1biBzZXAgLT5cbiAgICBGb3JtYXQucHJpbnRmIFwiZm9vJSglKWJhciUoJSliYXpcIiBzZXAgc2VwXG5cbkFzIHRoZSB0eXBlLWNoZWNrZXIgd291bGQgcmVxdWlyZSB0d28gKmluY29tcGF0aWJsZSogdHlwZXMgZm9yIHRoZSAlKCUpXG5pbiBkaWZmZXJlbnQgcG9zaXRpb25zLlxuXG5UaGUgc29sdXRpb24gdG8gcmVnYWluIGEgZ2VuZXJhbCB0eXBlIGZvciAlKC4uJSkgaXMgdG8gZ2VuZXJhbGl6ZSB0aGlzXG50ZWNobmlxdWUsIG5vdCBvbmx5IG9uIHRoZSAnZCwgJ2UgcGFyYW1ldGVycywgYnV0IG9uIGFsbCBzaXhcbnBhcmFtZXRlcnMgb2YgYSBmb3JtYXQ6IHdlIGludHJvZHVjZSBhIFwicmVsYXRpb25hbFwiIHR5cGVcbiAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbndob3NlIHZhbHVlcyBhcmUgcHJvb2ZzIHRoYXQgKCdhMSwgLi4sICdmMSkgYW5kICgnYTIsIC4uLCAnZjIpIG1vcmFsbHlcbmNvcnJlc3BvbmQgdG8gdGhlIHNhbWUgZm9ybWF0IHR5cGU6ICdhMSBpcyBvYnRhaW5lZCBmcm9tICdmMSwnYjEsJ2MxXG5pbiB0aGUgZXhhY3Qgc2FtZSB3YXkgdGhhdCAnYTIgaXMgb2J0YWluZWQgZnJvbSAnZjIsJ2IyLCdjMiwgZXRjLlxuXG5Gb3IgZXhhbXBsZSwgdGhlIHJlbGF0aW9uIGJldHdlZW4gdHdvIGZvcm1hdCB0eXBlcyBiZWdpbm5pbmcgd2l0aCBhIENoYXJcbnBhcmFtZXRlciBpcyBhcyBmb2xsb3dzOlxuXG58IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgY2hhciAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuSW4gdGhlIGdlbmVyYWwgY2FzZSwgdGhlIHRlcm0gc3RydWN0dXJlIG9mIGZtdHR5X3JlbCBpcyAoYWxtb3N0WzFdKVxuaXNvbW9ycGhpYyB0byB0aGUgZm10dHkgb2YgdGhlIHByZXZpb3VzIGltcGxlbWVudGF0aW9uOiBldmVyeVxuY29uc3RydWN0b3IgaXMgcmUtcmVhZCB3aXRoIGEgYmluYXJ5LCByZWxhdGlvbmFsIHR5cGUsIGluc3RlYWQgb2YgdGhlXG5wcmV2aW91cyB1bmFyeSB0eXBpbmcuIGZtdHR5IGNhbiB0aGVuIGJlIHJlLWRlZmluZWQgYXMgdGhlIGRpYWdvbmFsIG9mXG5mbXR0eV9yZWw6XG5cbiAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgICAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9yZWxcblxuT25jZSB3ZSBoYXZlIHRoaXMgZm10dHlfcmVsIHR5cGUgaW4gcGxhY2UsIHdlIGNhbiBnaXZlIHRoZSBtb3JlXG5nZW5lcmFsIHR5cGUgdG8gJSguLi4lKTpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IsICdjLCAnajIsICdkLCAnYSkgZm10dHlfcmVsICpcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IsICdjLCAnajIsICdlLCAnZikgZm10XG5cbldlIGFjY2VwdCBhbnkgZm9ybWF0ICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NikgKHRoaXMgaXNcbmNvbXBsZXRlbHkgdW5yZWxhdGVkIHRvIHRoZSB0eXBlIG9mIHRoZSBjdXJyZW50IGZvcm1hdCksIGJ1dCBhbHNvXG5yZXF1aXJlIGEgcHJvb2YgdGhhdCB0aGlzIGZvcm1hdCBpcyBpbiByZWxhdGlvbiB0byBhbm90aGVyIGZvcm1hdCB0aGF0XG5pcyBjb25jYXRlbmFibGUgdG8gdGhlIGZvcm1hdCB0YWlsLiBXaGVuIGV4ZWN1dGluZyBhICUoLi4uJSkgZm9ybWF0XG4oaW4gY2FtbGludGVybmFsRm9ybWF0Lm1sOm1ha2VfcHJpbnRmIG9yIHNjYW5mLm1sOm1ha2Vfc2NhbmYpLCB3ZVxudHJhbnN0eXBlIHRoZSBmb3JtYXQgYWxvbmcgdGhpcyByZWxhdGlvbiB1c2luZyB0aGUgJ3JlY2FzdCcgZnVuY3Rpb25cbnRvIHRyYW5zcG9zZSBiZXR3ZWVuIHJlbGF0ZWQgZm9ybWF0IHR5cGVzLlxuXG4gIHZhbCByZWNhc3QgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSkgZm10XG4gIC0+ICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIC0+ICgnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXRcblxuTk9URSBbMV06IHRoZSB0eXBpbmcgb2YgRm9ybWF0X3N1YnN0X3R5IHJlcXVpcmVzIG5vdCBvbmUgZm9ybWF0IHR5cGUsIGJ1dFxudHdvLCBvbmUgdG8gZXN0YWJsaXNoIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdCBhcmd1bWVudCBhbmQgdGhlXG5maXJzdCBzaXggcGFyYW1ldGVycywgYW5kIHRoZSBvdGhlciBmb3IgdGhlIGxpbmsgYmV0d2VlbiB0aGUgZm9ybWF0XG5hcmd1bWVudCBhbmQgdGhlIGxhc3Qgc2l4IHBhcmFtZXRlcnMuXG5cbnwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZDEsICdhMSkgZm10dHlfcmVsICpcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG5XaGVuIHdlIGdlbmVyYXRlIGEgZm9ybWF0IEFTVCwgd2UgZ2VuZXJhdGUgZXhhY3RseSB0aGUgc2FtZSB3aXRuZXNzXG5mb3IgYm90aCByZWxhdGlvbnMsIGFuZCB0aGUgd2l0bmVzcy1jb252ZXJzaW9uIGZ1bmN0aW9ucyBpblxuY2FtbGludGVybmFsRm9ybWF0IGRvIHJlbHkgb24gdGhpcyBpbnZhcmlhbnQuIEZvciBleGFtcGxlLCB0aGVcbmZ1bmN0aW9uIHRoYXQgcHJvdmVzIHRoYXQgdGhlIHJlbGF0aW9uIGlzIHRyYW5zaXRpdmVcblxuICB2YWwgdHJhbnMgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMixcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuXG5kb2VzIGFzc3VtZSB0aGF0IHRoZSB0d28gaW5wdXRzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSB0ZXJtIHN0cnVjdHVyZVxuKGFuZCBpcyBvbmx5IGV2ZXJ5IHVzZWQgZm9yIGFyZ3VtZW50IHdpdG5lc3NlcyBvZiB0aGVcbkZvcm1hdF9zdWJzdF90eSBjb25zdHJ1Y3RvcikuXG4qKVxuXG4oKiBUeXBlIG9mIGEgYmxvY2sgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBibG9ja190eXBlID1cbiAgfCBQcF9oYm94ICAgKCogSG9yaXpvbnRhbCBibG9jayBubyBsaW5lIGJyZWFraW5nICopXG4gIHwgUHBfdmJveCAgICgqIFZlcnRpY2FsIGJsb2NrIGVhY2ggYnJlYWsgbGVhZHMgdG8gYSBuZXcgbGluZSAqKVxuICB8IFBwX2h2Ym94ICAoKiBIb3Jpem9udGFsLXZlcnRpY2FsIGJsb2NrOiBzYW1lIGFzIHZib3gsIGV4Y2VwdCBpZiB0aGlzIGJsb2NrXG4gICAgICAgICAgICAgICAgIGlzIHNtYWxsIGVub3VnaCB0byBmaXQgb24gYSBzaW5nbGUgbGluZSAqKVxuICB8IFBwX2hvdmJveCAoKiBIb3Jpem9udGFsIG9yIFZlcnRpY2FsIGJsb2NrOiBicmVha3MgbGVhZCB0byBuZXcgbGluZVxuICAgICAgICAgICAgICAgICBvbmx5IHdoZW4gbmVjZXNzYXJ5IHRvIHByaW50IHRoZSBjb250ZW50IG9mIHRoZSBibG9jayAqKVxuICB8IFBwX2JveCAgICAoKiBIb3Jpem9udGFsIG9yIEluZGVudCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2ssIG9yXG4gICAgICAgICAgICAgICAgIHdoZW4gaXQgbGVhZHMgdG8gYSBuZXcgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgbGluZSAqKVxuICB8IFBwX2ZpdHMgICAoKiBJbnRlcm5hbCB1c2FnZTogd2hlbiBhIGJsb2NrIGZpdHMgb24gYSBzaW5nbGUgbGluZSAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBmb3JtYXR0aW5nX2xpdCA9XG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBdICAgKilcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQH0gICAqKVxuICB8IEJyZWFrIG9mIHN0cmluZyAqIGludCAqIGludCAgICAgICAgICAoKiBALCB8IEAgIHwgQDsgfCBAOzw+ICopXG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEA/ICAgKilcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFxcbiAgKilcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQC4gICAqKVxuICB8IE1hZ2ljX3NpemUgb2Ygc3RyaW5nICogaW50ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPG4+ICopXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBAICAgKilcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQCUlICAqKVxuICB8IFNjYW5faW5kaWMgb2YgY2hhciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAWCAgICopXG5cbigqIEZvcm1hdHRpbmcgZWxlbWVudCB1c2VkIGJ5IHRoZSBGb3JtYXQgcHJldHR5LXByaW50ZXIuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlbiA9XG4gIHwgT3Blbl90YWcgOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEB7ICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cbiAgfCBPcGVuX2JveCA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICAgICAgKCogQFsgICAqKVxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlblxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCB0eXBlIGVsZW1lbnRzLiAqKVxuKCogSW4gcGFydGljdWxhciB1c2VkIHRvIHJlcHJlc2VudCAlKC4uLiUpIGFuZCAley4uLiV9IGNvbnRlbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSA9XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5hbmQgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCA9XG4gIHwgQ2hhcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoY2hhciAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgU3RyaW5nX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoc3RyaW5nIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgc3RyaW5nIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQzMl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQzMiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDMyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IE5hdGl2ZWludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbmQgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKG5hdGl2ZWludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIG5hdGl2ZWludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQ2NF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQ2NCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDY0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEZsb2F0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGZsb2F0IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgZmxvYXQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQm9vbF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVCICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoYm9vbCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGJvb2wgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBGb3JtYXRfYXJnX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXsuLi4lfSAqKVxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5ICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG4gIHwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiMiwgJ2MyLCAnajIsICdkMiwgJ2EyKSBmbXR0eV9yZWwgKlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZTEsICdmMSxcbiAgICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKVxuICAgICAgICAgICBmbXR0eV9yZWxcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnMuICopXG4gIHwgQWxwaGFfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVhICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdiMSAtPiAneCAtPiAnYzEpIC0+ICd4IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdiMiAtPiAneCAtPiAnYzIpIC0+ICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFRoZXRhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ2MxKSAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ2MyKSAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBBbnlfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFVzZWQgZm9yIGN1c3RvbSBmb3JtYXRzICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yLiAqKVxuICB8IFJlYWRlcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCd4IC0+ICdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ3ggLT4gJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBFbmRfb2ZfZm10dHkgOlxuICAgICAgKCdmMSwgJ2IxLCAnYzEsICdkMSwgJ2QxLCAnZjEsXG4gICAgICAgJ2YyLCAnYjIsICdjMiwgJ2QyLCAnZDIsICdmMikgZm10dHlfcmVsXG5cbigqKiopXG5cbigqIExpc3Qgb2YgZm9ybWF0IGVsZW1lbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgPVxuICB8IENoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVDICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFN0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVTICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDMyIC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgTmF0aXZlaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5bZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBuYXRpdmVpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlTFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDY0IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRmxvYXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtmZUVnR0ZoSF0gKilcbiAgICAgIGZsb2F0X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBmbG9hdCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEJvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbYkJdICopXG4gICAgICAoJ3gsIGJvb2wgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGbHVzaCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlISAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBhYmMgKilcbiAgICAgIHN0cmluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENoYXJfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIHggKilcbiAgICAgIGNoYXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICB8IEZvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgICAgcGFkX29wdGlvbiAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYiwgJ2MsICdqMiwgJ2UsICdmKSBmbXRcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBBbHBoYSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICd4IC0+ICdjKSAtPiAneCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBUaGV0YSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICdjKSAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3I6ICopXG4gIHwgRm9ybWF0dGluZ19saXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF8gKilcbiAgICAgIGZvcm1hdHRpbmdfbGl0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0dGluZ19nZW4gOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBfICopXG4gICAgICAoJ2ExLCAnYiwgJ2MsICdkMSwgJ2UxLCAnZjEpIGZvcm1hdHRpbmdfZ2VuICpcbiAgICAgICgnZjEsICdiLCAnYywgJ2UxLCAnZTIsICdmMikgZm10IC0+ICgnYTEsICdiLCAnYywgJ2QxLCAnZTIsICdmMikgZm10XG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IFJlYWRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVyICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCAtPiAnYSwgJ2IsICdjLCAoJ2IgLT4gJ3gpIC0+ICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fY2hhcl9zZXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoc3RyaW5nIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChpbnQgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9uZXh0X2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJTBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJZ25vcmVkX3BhcmFtIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGlnbm9yZWQgKiAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBDdXN0b20gcHJpbnRpbmcgZm9ybWF0IChQUiM2NDUyLCBHUFIjMTQwKVxuXG4gICAgIFdlIGluY2x1ZGUgYSB0eXBlIEN1c3RvbSBvZiBcImN1c3RvbSBjb252ZXJ0ZXJzXCIsIHdoZXJlIGFuXG4gICAgIGFyYml0cmFyeSBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBjb252ZXJ0IG9uZSBvciBtb3JlXG4gICAgIGFyZ3VtZW50cy4gVGhlcmUgaXMgbm8gc3ludGF4IGZvciBjdXN0b20gY29udmVydGVycywgaXQgaXMgb25seVxuICAgICBpbnRlbmRlZCBmb3IgY3VzdG9tIHByb2Nlc3NvcnMgdGhhdCB3aXNoIHRvIHJlbHkgb24gdGhlXG4gICAgIHN0ZGxpYi1kZWZpbmVkIGZvcm1hdCBHQURUcy5cblxuICAgICBGb3IgaW5zdGFuY2UgYSBwcmUtcHJvY2Vzc29yIGNvdWxkIGNob29zZSB0byBpbnRlcnByZXQgc3RyaW5nc1xuICAgICBwcmVmaXhlZCB3aXRoIFtcIiFcIl0gYXMgZm9ybWF0IHN0cmluZ3Mgd2hlcmUgWyV7eyAuLi4gfX1dIGlzXG4gICAgIGEgc3BlY2lhbCBmb3JtIHRvIHBhc3MgYSB0b19zdHJpbmcgZnVuY3Rpb24sIHNvIHRoYXQgb25lIGNvdWxkXG4gICAgIHdyaXRlOlxuXG4gICAgIHtbXG4gICAgICAgdHlwZSB0ID0geyB4IDogaW50OyB5IDogaW50IH1cblxuICAgICAgIGxldCBzdHJpbmdfb2ZfdCB0ID0gUHJpbnRmLnNwcmludGYgXCJ7IHggPSAlZDsgeSA9ICVkIH1cIiB0LnggdC55XG5cbiAgICAgICBQcmludGYucHJpbnRmICFcInQgPSAle3tzdHJpbmdfb2ZfdH19XCIgeyB4ID0gNDI7IHkgPSA0MiB9XG4gICAgIF19XG4gICopXG4gIHwgQ3VzdG9tIDpcbiAgICAgICgnYSwgJ3gsICd5KSBjdXN0b21fYXJpdHkgKiAodW5pdCAtPiAneCkgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoJ3ksICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogZW5kIG9mIGEgZm9ybWF0IHNwZWNpZmljYXRpb24gKilcbiAgfCBFbmRfb2ZfZm9ybWF0IDpcbiAgICAgICAgKCdmLCAnYiwgJ2MsICdlLCAnZSwgJ2YpIGZtdFxuXG4oKioqKVxuXG4oKiBUeXBlIGZvciBpZ25vcmVkIHBhcmFtZXRlcnMgKHNlZSBcIiVfXCIpLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkID1cbiAgfCBJZ25vcmVkX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2MgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9DICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfcyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfUyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9sZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9uZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9MZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mbG9hdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9mICopXG4gICAgICBwYWRfb3B0aW9uICogcHJlY19vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Jvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0IgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3suLi4lfSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfKC4uLiUpICopXG4gICAgICBwYWRfb3B0aW9uICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9yZWFkZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9yICopXG4gICAgICAoJ2EsICdiLCAnYywgKCdiIC0+ICd4KSAtPiAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0IC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXzBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPVxuICBGb3JtYXQgb2YgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAqIHN0cmluZ1xuXG5sZXQgcmVjIGVyYXNlX3JlbCA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgLlxuICAoYSwgYiwgYywgZCwgZSwgZixcbiAgIGcsIGgsIGksIGosIGssIGwpIGZtdHR5X3JlbCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlcbj0gZnVuY3Rpb25cbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIFN0cmluZ190eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBJbnRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIE5hdGl2ZWludF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBCb29sX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIF90eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIEFscGhhX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgVGhldGFfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIFJlYWRlcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGUgY29uY2F0ZW5hdGlvbiAqKVxuXG4oKiBDb25jYXRlbmF0ZSB0d28gZm9ybWF0IHR5cGVzLiAqKVxuKCogVXNlZCBieTpcbiAgICogcmVhZGVyX25iX3VuaWZpZXJfb2ZfZm10dHkgdG8gY291bnQgcmVhZGVycyBpbiBhbiBmbXR0eSxcbiAgICogU2NhbmYudGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyB0byBleHRyYWN0IHJlYWRlcnMgaW5zaWRlICUoLi4uJSksXG4gICAqIENhbWxpbnRlcm5hbEZvcm1hdC5mbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCB0byBleHRyYWN0IGZvcm1hdCB0eXBlLiAqKVxuXG4oKlxubGV0IHJlYyBjb25jYXRfZm10dHkgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGYsIGIsIGMsIGUsIGcsIGgpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdHR5ID1cbiopXG5sZXQgcmVjIGNvbmNhdF9mbXR0eSA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMlxuICAgICAgIGcxIGoxIGcyIGoyXG4gIC5cbiAgICAoZzEsIGIxLCBjMSwgajEsIGQxLCBhMSxcbiAgICAgZzIsIGIyLCBjMiwgajIsIGQyLCBhMikgZm10dHlfcmVsIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbCAtPlxuICAgIChnMSwgYjEsIGMxLCBqMSwgZTEsIGYxLFxuICAgICBnMiwgYjIsIGMyLCBqMiwgZTIsIGYyKSBmbXR0eV9yZWwgPVxuZnVuIGZtdHR5MSBmbXR0eTIgLT4gbWF0Y2ggZm10dHkxIHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBTdHJpbmdfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIEludF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgTmF0aXZlaW50X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgQm9vbF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBBbHBoYV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBUaGV0YV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBSZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEVuZF9vZl9mbXR0eSAtPiBmbXR0eTJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBjb25jYXRlbmF0aW9uICopXG5cbigqIENvbmNhdGVuYXRlIHR3byBmb3JtYXRzLiAqKVxubGV0IHJlYyBjb25jYXRfZm10IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoZiwgYiwgYywgZSwgZywgaCkgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdCA9XG5mdW4gZm10MSBmbXQyIC0+IG1hdGNoIGZtdDEgd2l0aFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIFN0cmluZyAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIENhbWxfc3RyaW5nIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludDY0IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBDaGFyIChyZXN0KSAtPlxuICAgIENoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgQ2FtbF9jaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgQm9vbCAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgQWxwaGEgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFRoZXRhIHJlc3QgLT5cbiAgICBUaGV0YSAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ3VzdG9tIChhcml0eSwgZiwgcmVzdCkgLT5cbiAgICBDdXN0b20gKGFyaXR5LCBmLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBSZWFkZXIgcmVzdCAtPlxuICAgIFJlYWRlciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIEZsdXNoIChjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nX2xpdGVyYWwgKHN0ciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgQ2hhcl9saXRlcmFsICAgKGNociwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBGb3JtYXRfYXJnIChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmcgICAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdCAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgKHJlc3QpIC0+XG4gICAgU2Nhbl9uZXh0X2NoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBJZ25vcmVkX3BhcmFtIChpZ24sIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAtPlxuICAgIEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBmbXQyXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBHYWJyaWVsIFNjaGVyZXIsIHByb2pldCBQYXJ0b3V0LCBJTlJJQSBQYXJpcy1TYWNsYXkgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDIwIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENhbWxpbnRlcm5hbEF0b21pYyBpcyBhIGRlcGVuZGVuY3kgb2YgU3RkbGliLCBzbyBpdCBpcyBjb21waWxlZCB3aXRoXG4gICAtbm9wZXJ2YXNpdmVzLiAqKVxuZXh0ZXJuYWwgKCA9PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxXCJcbmV4dGVybmFsICggKyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgaWdub3JlIDogJ2EgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbigqIFdlIGFyZSBub3QgcmV1c2luZyAoJ2EgcmVmKSBkaXJlY3RseSB0byBtYWtlIGl0IGVhc2llciB0byByZWFzb25cbiAgIGFib3V0IGF0b21pY2l0eSBpZiB3ZSB3aXNoIHRvOiBldmVuIGluIGEgc2VxdWVudGlhbCBpbXBsZW1lbnRhdGlvbixcbiAgIHNpZ25hbHMgYW5kIG90aGVyIGFzeW5jaHJvbm91cyBjYWxsYmFja3MgbWlnaHQgYnJlYWsgYXRvbWljaXR5LiAqKVxudHlwZSAnYSB0ID0ge211dGFibGUgdjogJ2F9XG5cbmxldCBtYWtlIHYgPSB7dn1cbmxldCBnZXQgciA9IHIudlxubGV0IHNldCByIHYgPSByLnYgPC0gdlxuXG4oKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBhcmUgc2V0IHRvIG5ldmVyIGJlIGlubGluZWQ6IEZsYW1iZGEgaXNcbiAgIGFsbG93ZWQgdG8gbW92ZSBzdXJyb3VuZGluZyBjb2RlIGluc2lkZSB0aGUgY3JpdGljYWwgc2VjdGlvbixcbiAgIGluY2x1ZGluZyBhbGxvY2F0aW9ucy4gKilcblxubGV0W0BpbmxpbmUgbmV2ZXJdIGV4Y2hhbmdlIHIgdiA9XG4gICgqIEJFR0lOIEFUT01JQyAqKVxuICBsZXQgY3VyID0gci52IGluXG4gIHIudiA8LSB2O1xuICAoKiBFTkQgQVRPTUlDICopXG4gIGN1clxuXG5sZXRbQGlubGluZSBuZXZlcl0gY29tcGFyZV9hbmRfc2V0IHIgc2VlbiB2ID1cbiAgKCogQkVHSU4gQVRPTUlDICopXG4gIGxldCBjdXIgPSByLnYgaW5cbiAgaWYgY3VyID09IHNlZW4gdGhlbiAoXG4gICAgci52IDwtIHY7XG4gICAgKCogRU5EIEFUT01JQyAqKVxuICAgIHRydWVcbiAgKSBlbHNlXG4gICAgZmFsc2VcblxubGV0W0BpbmxpbmUgbmV2ZXJdIGZldGNoX2FuZF9hZGQgciBuID1cbiAgKCogQkVHSU4gQVRPTUlDICopXG4gIGxldCBjdXIgPSByLnYgaW5cbiAgci52IDwtIChjdXIgKyBuKTtcbiAgKCogRU5EIEFUT01JQyAqKVxuICBjdXJcblxubGV0IGluY3IgciA9IGlnbm9yZSAoZmV0Y2hfYW5kX2FkZCByIDEpXG5sZXQgZGVjciByID0gaWdub3JlIChmZXRjaF9hbmRfYWRkIHIgKC0xKSlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogRXhjZXB0aW9ucyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiAnYSAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gICgqIGZvciBydW50aW1lL2ZhaWxfbmF0LmMgKilcbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQZXJ2YXNpdmVzLmFycmF5X2JvdW5kX2Vycm9yXCJcbiAgICAoSW52YWxpZF9hcmd1bWVudCBcImluZGV4IG91dCBvZiBib3VuZHNcIilcblxuZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZVwiXG5leHRlcm5hbCByYWlzZV9ub3RyYWNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2Vfbm90cmFjZVwiXG5cbmxldCBmYWlsd2l0aCBzID0gcmFpc2UoRmFpbHVyZSBzKVxubGV0IGludmFsaWRfYXJnIHMgPSByYWlzZShJbnZhbGlkX2FyZ3VtZW50IHMpXG5cbmV4Y2VwdGlvbiBFeGl0XG5leGNlcHRpb24gTWF0Y2hfZmFpbHVyZSA9IE1hdGNoX2ZhaWx1cmVcbmV4Y2VwdGlvbiBBc3NlcnRfZmFpbHVyZSA9IEFzc2VydF9mYWlsdXJlXG5leGNlcHRpb24gSW52YWxpZF9hcmd1bWVudCA9IEludmFsaWRfYXJndW1lbnRcbmV4Y2VwdGlvbiBGYWlsdXJlID0gRmFpbHVyZVxuZXhjZXB0aW9uIE5vdF9mb3VuZCA9IE5vdF9mb3VuZFxuZXhjZXB0aW9uIE91dF9vZl9tZW1vcnkgPSBPdXRfb2ZfbWVtb3J5XG5leGNlcHRpb24gU3RhY2tfb3ZlcmZsb3cgPSBTdGFja19vdmVyZmxvd1xuZXhjZXB0aW9uIFN5c19lcnJvciA9IFN5c19lcnJvclxuZXhjZXB0aW9uIEVuZF9vZl9maWxlID0gRW5kX29mX2ZpbGVcbmV4Y2VwdGlvbiBEaXZpc2lvbl9ieV96ZXJvID0gRGl2aXNpb25fYnlfemVyb1xuZXhjZXB0aW9uIFN5c19ibG9ja2VkX2lvID0gU3lzX2Jsb2NrZWRfaW9cbmV4Y2VwdGlvbiBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSA9IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlXG5cbigqIENvbXBvc2l0aW9uIG9wZXJhdG9ycyAqKVxuXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuZXh0ZXJuYWwgKCBAQCApIDogKCdhIC0+ICdiKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcblxuKCogRGVidWdnaW5nICopXG5cbmV4dGVybmFsIF9fTE9DX18gOiBzdHJpbmcgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fRklMRV9fIDogc3RyaW5nID0gXCIlbG9jX0ZJTEVcIlxuZXh0ZXJuYWwgX19MSU5FX18gOiBpbnQgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX01PRFVMRV9fIDogc3RyaW5nID0gXCIlbG9jX01PRFVMRVwiXG5leHRlcm5hbCBfX1BPU19fIDogc3RyaW5nICogaW50ICogaW50ICogaW50ID0gXCIlbG9jX1BPU1wiXG5leHRlcm5hbCBfX0ZVTkNUSU9OX18gOiBzdHJpbmcgPSBcIiVsb2NfRlVOQ1RJT05cIlxuXG5leHRlcm5hbCBfX0xPQ19PRl9fIDogJ2EgLT4gc3RyaW5nICogJ2EgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fTElORV9PRl9fIDogJ2EgLT4gaW50ICogJ2EgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX1BPU19PRl9fIDogJ2EgLT4gKHN0cmluZyAqIGludCAqIGludCAqIGludCkgKiAnYSA9IFwiJWxvY19QT1NcIlxuXG4oKiBDb21wYXJpc29ucyAqKVxuXG5leHRlcm5hbCAoID0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5leHRlcm5hbCAoIDw+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA8ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG5leHRlcm5hbCAoID49ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcmVxdWFsXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcblxubGV0IG1pbiB4IHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG5leHRlcm5hbCAoID09ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXFcIlxuZXh0ZXJuYWwgKCAhPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxXCJcblxuKCogQm9vbGVhbiBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggb3IgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcblxuKCogSW50ZWdlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsICggfi0gKSA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgKCB+KyApIDogaW50IC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxuZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCAoIC0gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsICggKiApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgKCAvICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCAoIG1vZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxuXG5sZXQgYWJzIHggPSBpZiB4ID49IDAgdGhlbiB4IGVsc2UgLXhcblxuZXh0ZXJuYWwgKCBsYW5kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFuZGludFwiXG5leHRlcm5hbCAoIGxvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCAoIGx4b3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcblxubGV0IGxub3QgeCA9IHggbHhvciAoLTEpXG5cbmV4dGVybmFsICggbHNsICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCAoIGxzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuZXh0ZXJuYWwgKCBhc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcblxubGV0IG1heF9pbnQgPSAoLTEpIGxzciAxXG5sZXQgbWluX2ludCA9IG1heF9pbnQgKyAxXG5cbigqIEZsb2F0aW5nLXBvaW50IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LS4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgKCB+Ky4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgKCArLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCAoIC0uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsICggKi4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgKCAvLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCAoICoqICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9wb3dlcl9mbG9hdFwiIFwicG93XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cG0xIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwbTFfZmxvYXRcIiBcImNhbWxfZXhwbTFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zaF9mbG9hdFwiIFwiY2FtbF9hY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbmhfZmxvYXRcIiBcImNhbWxfYXNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuaF9mbG9hdFwiIFwiY2FtbF9hdGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhYnNfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFic2Zsb2F0XCJcbmV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG5leHRlcm5hbCBmbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfaW50IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgaW50X29mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxubGV0IGluZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5lZ19pbmZpbml0eSA9XG4gIGZsb2F0X29mX2JpdHMgMHhGRl9GMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBuYW4gPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDFMXG5sZXQgbWF4X2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0VGX0ZGX0ZGX0ZGX0ZGX0ZGX0ZGTFxubGV0IG1pbl9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHgwMF8xMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBlcHNpbG9uX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDNDX0IwXzAwXzAwXzAwXzAwXzAwXzAwTFxuXG50eXBlIGZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cblxuKCogU3RyaW5nIGFuZCBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGVzIFN0cmluZyBhbmQgQnl0ZXMgKilcblxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2xlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBieXRlc19jcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIHN0cmluZ19ibGl0IDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX2JsaXQgOiBieXRlcyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgKCBeICkgczEgczIgPVxuICBsZXQgbDEgPSBzdHJpbmdfbGVuZ3RoIHMxIGFuZCBsMiA9IHN0cmluZ19sZW5ndGggczIgaW5cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgKGwxICsgbDIpIGluXG4gIHN0cmluZ19ibGl0IHMxIDAgcyAwIGwxO1xuICBzdHJpbmdfYmxpdCBzMiAwIHMgbDEgbDI7XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBDaGFyICopXG5cbmV4dGVybmFsIGludF9vZl9jaGFyIDogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB1bnNhZmVfY2hhcl9vZl9pbnQgOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcbmxldCBjaGFyX29mX2ludCBuID1cbiAgaWYgbiA8IDAgfHwgbiA+IDI1NSB0aGVuIGludmFsaWRfYXJnIFwiY2hhcl9vZl9pbnRcIiBlbHNlIHVuc2FmZV9jaGFyX29mX2ludCBuXG5cbigqIFVuaXQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBpZ25vcmUgOiAnYSAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxuKCogUGFpciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGZzdCA6ICdhICogJ2IgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgc25kIDogJ2EgKiAnYiAtPiAnYiA9IFwiJWZpZWxkMVwiXG5cbigqIFJlZmVyZW5jZXMgKilcblxudHlwZSAnYSByZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5leHRlcm5hbCBpbmNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlaW5jclwiXG5leHRlcm5hbCBkZWNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlZGVjclwiXG5cbigqIFJlc3VsdCB0eXBlICopXG5cbnR5cGUgKCdhLCdiKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdiXG5cbigqIFN0cmluZyBjb252ZXJzaW9uIGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQgOiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5cbmxldCBzdHJpbmdfb2ZfYm9vbCBiID1cbiAgaWYgYiB0aGVuIFwidHJ1ZVwiIGVsc2UgXCJmYWxzZVwiXG5sZXQgYm9vbF9vZl9zdHJpbmcgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgfCBfIC0+IGludmFsaWRfYXJnIFwiYm9vbF9vZl9zdHJpbmdcIlxuXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0ID0gZnVuY3Rpb25cbiAgfCBcInRydWVcIiAtPiBTb21lIHRydWVcbiAgfCBcImZhbHNlXCIgLT4gU29tZSBmYWxzZVxuICB8IF8gLT4gTm9uZVxuXG5sZXQgc3RyaW5nX29mX2ludCBuID1cbiAgZm9ybWF0X2ludCBcIiVkXCIgblxuXG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuZXh0ZXJuYWwgc3RyaW5nX2dldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5cbmxldCB2YWxpZF9mbG9hdF9sZXhlbSBzID1cbiAgbGV0IGwgPSBzdHJpbmdfbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPj0gbCB0aGVuIHMgXiBcIi5cIiBlbHNlXG4gICAgbWF0Y2ggc3RyaW5nX2dldCBzIGkgd2l0aFxuICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBsb29wIChpICsgMSlcbiAgICB8IF8gLT4gc1xuICBpblxuICBsb29wIDBcblxubGV0IHN0cmluZ19vZl9mbG9hdCBmID0gdmFsaWRfZmxvYXRfbGV4ZW0gKGZvcm1hdF9mbG9hdCBcIiUuMTJnXCIgZilcblxuZXh0ZXJuYWwgZmxvYXRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChmbG9hdF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG4oKiBMaXN0IG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGUgTGlzdCAqKVxuXG5sZXQgcmVjICggQCApIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgaGQgOjogdGwgLT4gaGQgOjogKHRsIEAgbDIpXG5cbigqIEkvTyBvcGVyYXRpb25zICopXG5cbnR5cGUgaW5fY2hhbm5lbFxudHlwZSBvdXRfY2hhbm5lbFxuXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDogaW50IC0+IG91dF9jaGFubmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcIlxuZXh0ZXJuYWwgb3Blbl9kZXNjcmlwdG9yX2luIDogaW50IC0+IGluX2NoYW5uZWwgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXCJcblxubGV0IHN0ZGluID0gb3Blbl9kZXNjcmlwdG9yX2luIDBcbmxldCBzdGRvdXQgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDFcbmxldCBzdGRlcnIgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDJcblxuKCogR2VuZXJhbCBvdXRwdXQgZnVuY3Rpb25zICopXG5cbnR5cGUgb3Blbl9mbGFnID1cbiAgICBPcGVuX3Jkb25seSB8IE9wZW5fd3Jvbmx5IHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0IHwgT3Blbl90cnVuYyB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5IHwgT3Blbl90ZXh0IHwgT3Blbl9ub25ibG9ja1xuXG5leHRlcm5hbCBvcGVuX2Rlc2MgOiBzdHJpbmcgLT4gb3Blbl9mbGFnIGxpc3QgLT4gaW50IC0+IGludCA9IFwiY2FtbF9zeXNfb3BlblwiXG5cbmV4dGVybmFsIHNldF9vdXRfY2hhbm5lbF9uYW1lOiBvdXRfY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5fb3V0X2dlbiBtb2RlIHBlcm0gbmFtZSA9XG4gIGxldCBjID0gb3Blbl9kZXNjcmlwdG9yX291dChvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9vdXRfY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9vdXQgbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fdGV4dF0gMG82NjYgbmFtZVxuXG5sZXQgb3Blbl9vdXRfYmluIG5hbWUgPVxuICBvcGVuX291dF9nZW4gW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX3RydW5jOyBPcGVuX2JpbmFyeV0gMG82NjYgbmFtZVxuXG5leHRlcm5hbCBmbHVzaCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfZmx1c2hcIlxuXG5leHRlcm5hbCBvdXRfY2hhbm5lbHNfbGlzdCA6IHVuaXQgLT4gb3V0X2NoYW5uZWwgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3RcIlxuXG5sZXQgZmx1c2hfYWxsICgpID1cbiAgbGV0IHJlYyBpdGVyID0gZnVuY3Rpb25cbiAgICAgIFtdIC0+ICgpXG4gICAgfCBhOjpsIC0+XG4gICAgICAgIGJlZ2luIHRyeVxuICAgICAgICAgICAgZmx1c2ggYVxuICAgICAgICB3aXRoIFN5c19lcnJvciBfIC0+XG4gICAgICAgICAgKCkgKCogaWdub3JlIGNoYW5uZWxzIGNsb3NlZCBkdXJpbmcgYSBwcmVjZWRpbmcgZmx1c2guICopXG4gICAgICAgIGVuZDtcbiAgICAgICAgaXRlciBsXG4gIGluIGl0ZXIgKG91dF9jaGFubmVsc19saXN0ICgpKVxuXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0IDogb3V0X2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dF9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0X3N0cmluZyA6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dFwiXG5cbmV4dGVybmFsIG91dHB1dF9jaGFyIDogb3V0X2NoYW5uZWwgLT4gY2hhciAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcblxubGV0IG91dHB1dF9ieXRlcyBvYyBzID1cbiAgdW5zYWZlX291dHB1dCBvYyBzIDAgKGJ5dGVzX2xlbmd0aCBzKVxuXG5sZXQgb3V0cHV0X3N0cmluZyBvYyBzID1cbiAgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyAwIChzdHJpbmdfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXQgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJvdXRwdXRcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXQgb2MgcyBvZnMgbGVuXG5cbmxldCBvdXRwdXRfc3Vic3RyaW5nIG9jIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBzdHJpbmdfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dF9zdWJzdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXRfc3RyaW5nIG9jIHMgb2ZzIGxlblxuXG5leHRlcm5hbCBvdXRwdXRfYnl0ZSA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcbmV4dGVybmFsIG91dHB1dF9iaW5hcnlfaW50IDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2ludFwiXG5cbmV4dGVybmFsIG1hcnNoYWxfdG9fY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+ICdhIC0+IHVuaXQgbGlzdCAtPiB1bml0XG4gICAgID0gXCJjYW1sX291dHB1dF92YWx1ZVwiXG5sZXQgb3V0cHV0X3ZhbHVlIGNoYW4gdiA9IG1hcnNoYWxfdG9fY2hhbm5lbCBjaGFuIHYgW11cblxuZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dFwiXG5leHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19vdXRcIlxuZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9vdXRfY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfY2xvc2VfY2hhbm5lbFwiXG5sZXQgY2xvc2Vfb3V0IG9jID0gZmx1c2ggb2M7IGNsb3NlX291dF9jaGFubmVsIG9jXG5sZXQgY2xvc2Vfb3V0X25vZXJyIG9jID1cbiAgKHRyeSBmbHVzaCBvYyB3aXRoIF8gLT4gKCkpO1xuICAodHJ5IGNsb3NlX291dF9jaGFubmVsIG9jIHdpdGggXyAtPiAoKSlcbmV4dGVybmFsIHNldF9iaW5hcnlfbW9kZV9vdXQgOiBvdXRfY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXCJcblxuKCogR2VuZXJhbCBpbnB1dCBmdW5jdGlvbnMgKilcblxuZXh0ZXJuYWwgc2V0X2luX2NoYW5uZWxfbmFtZTogaW5fY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5faW5fZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3JfaW4ob3Blbl9kZXNjIG5hbWUgbW9kZSBwZXJtKSBpblxuICBzZXRfaW5fY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9pbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX3RleHRdIDAgbmFtZVxuXG5sZXQgb3Blbl9pbl9iaW4gbmFtZSA9XG4gIG9wZW5faW5fZ2VuIFtPcGVuX3Jkb25seTsgT3Blbl9iaW5hcnldIDAgbmFtZVxuXG5leHRlcm5hbCBpbnB1dF9jaGFyIDogaW5fY2hhbm5lbCAtPiBjaGFyID0gXCJjYW1sX21sX2lucHV0X2NoYXJcIlxuXG5leHRlcm5hbCB1bnNhZmVfaW5wdXQgOiBpbl9jaGFubmVsIC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gaW50XG4gICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfaW5wdXRcIlxuXG5sZXQgaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJpbnB1dFwiXG4gIGVsc2UgdW5zYWZlX2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVjIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgbGVuIDw9IDAgdGhlbiAoKSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuIGluXG4gICAgaWYgciA9IDBcbiAgICB0aGVuIHJhaXNlIEVuZF9vZl9maWxlXG4gICAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgKG9mcyArIHIpIChsZW4gLSByKVxuICBlbmRcblxubGV0IHJlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcInJlYWxseV9pbnB1dFwiXG4gIGVsc2UgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW5cblxubGV0IHJlYWxseV9pbnB1dF9zdHJpbmcgaWMgbGVuID1cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgbGVuIGluXG4gIHJlYWxseV9pbnB1dCBpYyBzIDAgbGVuO1xuICBieXRlc191bnNhZmVfdG9fc3RyaW5nIHNcblxuZXh0ZXJuYWwgaW5wdXRfc2Nhbl9saW5lIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXCJcblxubGV0IGlucHV0X2xpbmUgY2hhbiA9XG4gIGxldCByZWMgYnVpbGRfcmVzdWx0IGJ1ZiBwb3MgPSBmdW5jdGlvblxuICAgIFtdIC0+IGJ1ZlxuICB8IGhkIDo6IHRsIC0+XG4gICAgICBsZXQgbGVuID0gYnl0ZXNfbGVuZ3RoIGhkIGluXG4gICAgICBieXRlc19ibGl0IGhkIDAgYnVmIChwb3MgLSBsZW4pIGxlbjtcbiAgICAgIGJ1aWxkX3Jlc3VsdCBidWYgKHBvcyAtIGxlbikgdGwgaW5cbiAgbGV0IHJlYyBzY2FuIGFjY3UgbGVuID1cbiAgICBsZXQgbiA9IGlucHV0X3NjYW5fbGluZSBjaGFuIGluXG4gICAgaWYgbiA9IDAgdGhlbiBiZWdpbiAgICAgICAgICAgICAgICAgICAoKiBuID0gMDogd2UgYXJlIGF0IEVPRiAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJhaXNlIEVuZF9vZl9maWxlXG4gICAgICB8IF8gIC0+IGJ1aWxkX3Jlc3VsdCAoYnl0ZXNfY3JlYXRlIGxlbikgbGVuIGFjY3VcbiAgICBlbmQgZWxzZSBpZiBuID4gMCB0aGVuIGJlZ2luICAgICAgICAgICgqIG4gPiAwOiBuZXdsaW5lIGZvdW5kIGluIGJ1ZmZlciAqKVxuICAgICAgbGV0IHJlcyA9IGJ5dGVzX2NyZWF0ZSAobiAtIDEpIGluXG4gICAgICBpZ25vcmUgKHVuc2FmZV9pbnB1dCBjaGFuIHJlcyAwIChuIC0gMSkpO1xuICAgICAgaWdub3JlIChpbnB1dF9jaGFyIGNoYW4pOyAgICAgICAgICAgKCogc2tpcCB0aGUgbmV3bGluZSAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJlc1xuICAgICAgfCAgXyAtPiBsZXQgbGVuID0gbGVuICsgbiAtIDEgaW5cbiAgICAgICAgICAgICAgYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gKHJlcyA6OiBhY2N1KVxuICAgIGVuZCBlbHNlIGJlZ2luICAgICAgICAgICAgICAgICAgICAgICAgKCogbiA8IDA6IG5ld2xpbmUgbm90IGZvdW5kICopXG4gICAgICBsZXQgYmVnID0gYnl0ZXNfY3JlYXRlICgtbikgaW5cbiAgICAgIGlnbm9yZSh1bnNhZmVfaW5wdXQgY2hhbiBiZWcgMCAoLW4pKTtcbiAgICAgIHNjYW4gKGJlZyA6OiBhY2N1KSAobGVuIC0gbilcbiAgICBlbmRcbiAgaW4gYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyAoc2NhbiBbXSAwKVxuXG5leHRlcm5hbCBpbnB1dF9ieXRlIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5leHRlcm5hbCBpbnB1dF9iaW5hcnlfaW50IDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfaW50XCJcbmV4dGVybmFsIGlucHV0X3ZhbHVlIDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXCJcbmV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19pblwiXG5leHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9pbl9ub2VyciBpYyA9ICh0cnkgY2xvc2VfaW4gaWMgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX2luIDogaW5fY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIG91dHB1dCAqKVxuXG5sZXQgcHJpbnRfY2hhciBjID0gb3V0cHV0X2NoYXIgc3Rkb3V0IGNcbmxldCBwcmludF9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IHNcbmxldCBwcmludF9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZG91dCBzXG5sZXQgcHJpbnRfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByaW50X2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJpbnRfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRvdXQgczsgb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcbmxldCBwcmludF9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBlcnJvciAqKVxuXG5sZXQgcHJlcnJfY2hhciBjID0gb3V0cHV0X2NoYXIgc3RkZXJyIGNcbmxldCBwcmVycl9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIHNcbmxldCBwcmVycl9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZGVyciBzXG5sZXQgcHJlcnJfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByZXJyX2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJlcnJfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRlcnIgczsgb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcbmxldCBwcmVycl9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcblxuKCogSW5wdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGlucHV0ICopXG5cbmxldCByZWFkX2xpbmUgKCkgPSBmbHVzaCBzdGRvdXQ7IGlucHV0X2xpbmUgc3RkaW5cbmxldCByZWFkX2ludCAoKSA9IGludF9vZl9zdHJpbmcocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9pbnRfb3B0ICgpID0gaW50X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9mbG9hdCAoKSA9IGZsb2F0X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0X29wdCAoKSA9IGZsb2F0X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5cbigqIE9wZXJhdGlvbnMgb24gbGFyZ2UgZmlsZXMgKilcblxubW9kdWxlIExhcmdlRmlsZSA9XG4gIHN0cnVjdFxuICAgIGV4dGVybmFsIHNlZWtfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dF82NFwiXG4gICAgZXh0ZXJuYWwgcG9zX291dCA6IG91dF9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19vdXRfNjRcIlxuICAgIGV4dGVybmFsIG91dF9jaGFubmVsX2xlbmd0aCA6IG91dF9jaGFubmVsIC0+IGludDY0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gICAgZXh0ZXJuYWwgc2Vla19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXzY0XCJcbiAgICBleHRlcm5hbCBwb3NfaW4gOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19pbl82NFwiXG4gICAgZXh0ZXJuYWwgaW5fY2hhbm5lbF9sZW5ndGggOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gIGVuZFxuXG4oKiBGb3JtYXRzICopXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcbiAgID0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG4gICA9IEZvcm1hdCBvZiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZtdFxuICAgICAgICAgICAgICAgKiBzdHJpbmdcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgPSAoJ2EsICdiLCAnYywgJ2MsICdjLCAnZCkgZm9ybWF0NlxuXG50eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYywgJ2MpIGZvcm1hdDRcblxubGV0IHN0cmluZ19vZl9mb3JtYXQgKEZvcm1hdCAoX2ZtdCwgc3RyKSkgPSBzdHJcblxuZXh0ZXJuYWwgZm9ybWF0X29mX3N0cmluZyA6XG4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9IFwiJWlkZW50aXR5XCJcblxubGV0ICggXl4gKSAoRm9ybWF0IChmbXQxLCBzdHIxKSkgKEZvcm1hdCAoZm10Miwgc3RyMikpID1cbiAgRm9ybWF0IChDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuY29uY2F0X2ZtdCBmbXQxIGZtdDIsXG4gICAgICAgICAgc3RyMSBeIFwiJSxcIiBeIHN0cjIpXG5cbigqIE1pc2NlbGxhbmVvdXMgKilcblxuZXh0ZXJuYWwgc3lzX2V4aXQgOiBpbnQgLT4gJ2EgPSBcImNhbWxfc3lzX2V4aXRcIlxuXG5sZXQgZXhpdF9mdW5jdGlvbiA9IENhbWxpbnRlcm5hbEF0b21pYy5tYWtlIGZsdXNoX2FsbFxuXG5sZXQgcmVjIGF0X2V4aXQgZiA9XG4gIGxldCBtb2R1bGUgQXRvbWljID0gQ2FtbGludGVybmFsQXRvbWljIGluXG4gICgqIE1QUiM3MjUzLCBNUFIjNzc5NjogbWFrZSBzdXJlIFwiZlwiIGlzIGV4ZWN1dGVkIG9ubHkgb25jZSAqKVxuICBsZXQgZl95ZXRfdG9fcnVuID0gQXRvbWljLm1ha2UgdHJ1ZSBpblxuICBsZXQgb2xkX2V4aXQgPSBBdG9taWMuZ2V0IGV4aXRfZnVuY3Rpb24gaW5cbiAgbGV0IG5ld19leGl0ICgpID1cbiAgICBpZiBBdG9taWMuY29tcGFyZV9hbmRfc2V0IGZfeWV0X3RvX3J1biB0cnVlIGZhbHNlIHRoZW4gZiAoKSA7XG4gICAgb2xkX2V4aXQgKClcbiAgaW5cbiAgbGV0IHN1Y2Nlc3MgPSBBdG9taWMuY29tcGFyZV9hbmRfc2V0IGV4aXRfZnVuY3Rpb24gb2xkX2V4aXQgbmV3X2V4aXQgaW5cbiAgaWYgbm90IHN1Y2Nlc3MgdGhlbiBhdF9leGl0IGZcblxubGV0IGRvX2F0X2V4aXQgKCkgPSAoQ2FtbGludGVybmFsQXRvbWljLmdldCBleGl0X2Z1bmN0aW9uKSAoKVxuXG5sZXQgZXhpdCByZXRjb2RlID1cbiAgZG9fYXRfZXhpdCAoKTtcbiAgc3lzX2V4aXQgcmV0Y29kZVxuXG5sZXQgXyA9IHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIgZG9fYXRfZXhpdFxuXG5leHRlcm5hbCBtYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19tYWpvclwiXG5leHRlcm5hbCBuYWtlZF9wb2ludGVyc19jaGVja2VkIDogdW5pdCAtPiBib29sXG4gID0gXCJjYW1sX3N5c19jb25zdF9uYWtlZF9wb2ludGVyc19jaGVja2VkXCJcbmxldCAoKSA9IGlmIG5ha2VkX3BvaW50ZXJzX2NoZWNrZWQgKCkgdGhlbiBhdF9leGl0IG1ham9yXG5cbigqTU9EVUxFX0FMSUFTRVMqKVxubW9kdWxlIEFyZyAgICAgICAgICA9IEFyZ1xubW9kdWxlIEFycmF5ICAgICAgICA9IEFycmF5XG5tb2R1bGUgQXJyYXlMYWJlbHMgID0gQXJyYXlMYWJlbHNcbm1vZHVsZSBBdG9taWMgICAgICAgPSBBdG9taWNcbm1vZHVsZSBCaWdhcnJheSAgICAgPSBCaWdhcnJheVxubW9kdWxlIEJvb2wgICAgICAgICA9IEJvb2xcbm1vZHVsZSBCdWZmZXIgICAgICAgPSBCdWZmZXJcbm1vZHVsZSBCeXRlcyAgICAgICAgPSBCeXRlc1xubW9kdWxlIEJ5dGVzTGFiZWxzICA9IEJ5dGVzTGFiZWxzXG5tb2R1bGUgQ2FsbGJhY2sgICAgID0gQ2FsbGJhY2tcbm1vZHVsZSBDaGFyICAgICAgICAgPSBDaGFyXG5tb2R1bGUgQ29tcGxleCAgICAgID0gQ29tcGxleFxubW9kdWxlIERpZ2VzdCAgICAgICA9IERpZ2VzdFxubW9kdWxlIEVpdGhlciAgICAgICA9IEVpdGhlclxubW9kdWxlIEVwaGVtZXJvbiAgICA9IEVwaGVtZXJvblxubW9kdWxlIEZpbGVuYW1lICAgICA9IEZpbGVuYW1lXG5tb2R1bGUgRmxvYXQgICAgICAgID0gRmxvYXRcbm1vZHVsZSBGb3JtYXQgICAgICAgPSBGb3JtYXRcbm1vZHVsZSBGdW4gICAgICAgICAgPSBGdW5cbm1vZHVsZSBHYyAgICAgICAgICAgPSBHY1xubW9kdWxlIEdlbmxleCAgICAgICA9IEdlbmxleFxubW9kdWxlIEhhc2h0YmwgICAgICA9IEhhc2h0Ymxcbm1vZHVsZSBJbnQgICAgICAgICAgPSBJbnRcbm1vZHVsZSBJbnQzMiAgICAgICAgPSBJbnQzMlxubW9kdWxlIEludDY0ICAgICAgICA9IEludDY0XG5tb2R1bGUgTGF6eSAgICAgICAgID0gTGF6eVxubW9kdWxlIExleGluZyAgICAgICA9IExleGluZ1xubW9kdWxlIExpc3QgICAgICAgICA9IExpc3Rcbm1vZHVsZSBMaXN0TGFiZWxzICAgPSBMaXN0TGFiZWxzXG5tb2R1bGUgTWFwICAgICAgICAgID0gTWFwXG5tb2R1bGUgTWFyc2hhbCAgICAgID0gTWFyc2hhbFxubW9kdWxlIE1vcmVMYWJlbHMgICA9IE1vcmVMYWJlbHNcbm1vZHVsZSBOYXRpdmVpbnQgICAgPSBOYXRpdmVpbnRcbm1vZHVsZSBPYmogICAgICAgICAgPSBPYmpcbm1vZHVsZSBPbyAgICAgICAgICAgPSBPb1xubW9kdWxlIE9wdGlvbiAgICAgICA9IE9wdGlvblxubW9kdWxlIFBhcnNpbmcgICAgICA9IFBhcnNpbmdcbm1vZHVsZSBQZXJ2YXNpdmVzICAgPSBQZXJ2YXNpdmVzXG5tb2R1bGUgUHJpbnRleGMgICAgID0gUHJpbnRleGNcbm1vZHVsZSBQcmludGYgICAgICAgPSBQcmludGZcbm1vZHVsZSBRdWV1ZSAgICAgICAgPSBRdWV1ZVxubW9kdWxlIFJhbmRvbSAgICAgICA9IFJhbmRvbVxubW9kdWxlIFJlc3VsdCAgICAgICA9IFJlc3VsdFxubW9kdWxlIFNjYW5mICAgICAgICA9IFNjYW5mXG5tb2R1bGUgU2VxICAgICAgICAgID0gU2VxXG5tb2R1bGUgU2V0ICAgICAgICAgID0gU2V0XG5tb2R1bGUgU3RhY2sgICAgICAgID0gU3RhY2tcbm1vZHVsZSBTdGRMYWJlbHMgICAgPSBTdGRMYWJlbHNcbm1vZHVsZSBTdHJlYW0gICAgICAgPSBTdHJlYW1cbm1vZHVsZSBTdHJpbmcgICAgICAgPSBTdHJpbmdcbm1vZHVsZSBTdHJpbmdMYWJlbHMgPSBTdHJpbmdMYWJlbHNcbm1vZHVsZSBTeXMgICAgICAgICAgPSBTeXNcbm1vZHVsZSBVY2hhciAgICAgICAgPSBVY2hhclxubW9kdWxlIFVuaXQgICAgICAgICA9IFVuaXRcbm1vZHVsZSBXZWFrICAgICAgICAgPSBXZWFrXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICBKZXJlbWllIERpbWlubywgSmFuZSBTdHJlZXQgRXVyb3BlICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE3IEphbmUgU3RyZWV0IEdyb3VwIExMQyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqKiBAZGVwcmVjYXRlZCBVc2UgeyFTdGRsaWJ9ICopXG5cbmV4dGVybmFsIHJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2VcIlxuZXh0ZXJuYWwgcmFpc2Vfbm90cmFjZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlX25vdHJhY2VcIlxubGV0IGludmFsaWRfYXJnID0gaW52YWxpZF9hcmdcbmxldCBmYWlsd2l0aCA9IGZhaWx3aXRoXG5leGNlcHRpb24gRXhpdFxuZXh0ZXJuYWwgKCA9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuZXh0ZXJuYWwgKCA8PiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbmV4dGVybmFsICggPCApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbmV4dGVybmFsICggPiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbmV4dGVybmFsICggPD0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuZXh0ZXJuYWwgKCA+PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5leHRlcm5hbCBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5sZXQgbWluID0gbWluXG5sZXQgbWF4ID0gbWF4XG5leHRlcm5hbCAoID09ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXFcIlxuZXh0ZXJuYWwgKCAhPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxXCJcbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbiAgW0BAb2NhbWwuZGVwcmVjYXRlZCBcIlVzZSAoJiYpIGluc3RlYWQuXCJdXG5leHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5leHRlcm5hbCAoIG9yICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWQgXCJVc2UgKHx8KSBpbnN0ZWFkLlwiXVxuZXh0ZXJuYWwgX19MT0NfXyA6IHN0cmluZyA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19GSUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfRklMRVwiXG5leHRlcm5hbCBfX0xJTkVfXyA6IGludCA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fTU9EVUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfTU9EVUxFXCJcbmV4dGVybmFsIF9fUE9TX18gOiBzdHJpbmcgKiBpbnQgKiBpbnQgKiBpbnQgPSBcIiVsb2NfUE9TXCJcbmV4dGVybmFsIF9fTE9DX09GX18gOiAnYSAtPiBzdHJpbmcgKiAnYSA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19MSU5FX09GX18gOiAnYSAtPiBpbnQgKiAnYSA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fUE9TX09GX18gOiAnYSAtPiAoc3RyaW5nICogaW50ICogaW50ICogaW50KSAqICdhID0gXCIlbG9jX1BPU1wiXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuZXh0ZXJuYWwgKCBAQCApIDogKCdhIC0+ICdiKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcbmV4dGVybmFsICggfi0gKSA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgKCB+KyApIDogaW50IC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxuZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCAoIC0gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsICggKiApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgKCAvICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCAoIG1vZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxubGV0IGFicyA9IGFic1xubGV0IG1heF9pbnQgPSBtYXhfaW50XG5sZXQgbWluX2ludCA9IG1pbl9pbnRcbmV4dGVybmFsICggbGFuZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuZXh0ZXJuYWwgKCBsb3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlb3JpbnRcIlxuZXh0ZXJuYWwgKCBseG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXhvcmludFwiXG5sZXQgbG5vdCA9IGxub3RcbmV4dGVybmFsICggbHNsICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCAoIGxzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuZXh0ZXJuYWwgKCBhc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcbmV4dGVybmFsICggfi0uICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsICggfisuICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsICggKy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgKCAtLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCAoICouICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsICggLy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgKCAqKiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcG93ZXJfZmxvYXRcIiBcInBvd1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luaF9mbG9hdFwiIFwic2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuaF9mbG9hdFwiIFwidGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhYnNfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFic2Zsb2F0XCJcbmV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG5leHRlcm5hbCBmbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfaW50IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgaW50X29mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5sZXQgaW5maW5pdHkgPSBpbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IG5lZ19pbmZpbml0eVxubGV0IG5hbiA9IG5hblxubGV0IG1heF9mbG9hdCA9IG1heF9mbG9hdFxubGV0IG1pbl9mbG9hdCA9IG1pbl9mbG9hdFxubGV0IGVwc2lsb25fZmxvYXQgPSBlcHNpbG9uX2Zsb2F0XG50eXBlIG5vbnJlYyBmcGNsYXNzID0gZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxubGV0ICggXiApID0gKCBeIClcbmV4dGVybmFsIGludF9vZl9jaGFyIDogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5sZXQgY2hhcl9vZl9pbnQgPSBjaGFyX29mX2ludFxuZXh0ZXJuYWwgaWdub3JlIDogJ2EgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5sZXQgc3RyaW5nX29mX2Jvb2wgPSBzdHJpbmdfb2ZfYm9vbFxubGV0IGJvb2xfb2Zfc3RyaW5nID0gYm9vbF9vZl9zdHJpbmdcbmxldCBib29sX29mX3N0cmluZ19vcHQgPSBib29sX29mX3N0cmluZ19vcHRcbmxldCBzdHJpbmdfb2ZfaW50ID0gc3RyaW5nX29mX2ludFxuZXh0ZXJuYWwgaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQgPSBcImNhbWxfaW50X29mX3N0cmluZ1wiXG5sZXQgaW50X29mX3N0cmluZ19vcHQgPSBpbnRfb2Zfc3RyaW5nX29wdFxubGV0IHN0cmluZ19vZl9mbG9hdCA9IHN0cmluZ19vZl9mbG9hdFxuZXh0ZXJuYWwgZmxvYXRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5sZXQgZmxvYXRfb2Zfc3RyaW5nX29wdCA9IGZsb2F0X29mX3N0cmluZ19vcHRcbmV4dGVybmFsIGZzdCA6ICdhICogJ2IgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgc25kIDogJ2EgKiAnYiAtPiAnYiA9IFwiJWZpZWxkMVwiXG5sZXQgKCBAICkgID0gKCBAIClcbnR5cGUgbm9ucmVjIGluX2NoYW5uZWwgPSBpbl9jaGFubmVsXG50eXBlIG5vbnJlYyBvdXRfY2hhbm5lbCA9IG91dF9jaGFubmVsXG5sZXQgc3RkaW4gPSBzdGRpblxubGV0IHN0ZG91dCA9IHN0ZG91dFxubGV0IHN0ZGVyciA9IHN0ZGVyclxubGV0IHByaW50X2NoYXIgPSBwcmludF9jaGFyXG5sZXQgcHJpbnRfc3RyaW5nID0gcHJpbnRfc3RyaW5nXG5sZXQgcHJpbnRfYnl0ZXMgPSBwcmludF9ieXRlc1xubGV0IHByaW50X2ludCA9IHByaW50X2ludFxubGV0IHByaW50X2Zsb2F0ID0gcHJpbnRfZmxvYXRcbmxldCBwcmludF9lbmRsaW5lID0gcHJpbnRfZW5kbGluZVxubGV0IHByaW50X25ld2xpbmUgPSBwcmludF9uZXdsaW5lXG5sZXQgcHJlcnJfY2hhciA9IHByZXJyX2NoYXJcbmxldCBwcmVycl9zdHJpbmcgPSBwcmVycl9zdHJpbmdcbmxldCBwcmVycl9ieXRlcyA9IHByZXJyX2J5dGVzXG5sZXQgcHJlcnJfaW50ID0gcHJlcnJfaW50XG5sZXQgcHJlcnJfZmxvYXQgPSBwcmVycl9mbG9hdFxubGV0IHByZXJyX2VuZGxpbmUgPSBwcmVycl9lbmRsaW5lXG5sZXQgcHJlcnJfbmV3bGluZSA9IHByZXJyX25ld2xpbmVcbmxldCByZWFkX2xpbmUgPSByZWFkX2xpbmVcbmxldCByZWFkX2ludCA9IHJlYWRfaW50XG5sZXQgcmVhZF9pbnRfb3B0ID0gcmVhZF9pbnRfb3B0XG5sZXQgcmVhZF9mbG9hdCA9IHJlYWRfZmxvYXRcbmxldCByZWFkX2Zsb2F0X29wdCA9IHJlYWRfZmxvYXRfb3B0XG50eXBlIG5vbnJlYyBvcGVuX2ZsYWcgPSBvcGVuX2ZsYWcgPVxuICAgIE9wZW5fcmRvbmx5XG4gIHwgT3Blbl93cm9ubHlcbiAgfCBPcGVuX2FwcGVuZFxuICB8IE9wZW5fY3JlYXRcbiAgfCBPcGVuX3RydW5jXG4gIHwgT3Blbl9leGNsXG4gIHwgT3Blbl9iaW5hcnlcbiAgfCBPcGVuX3RleHRcbiAgfCBPcGVuX25vbmJsb2NrXG5sZXQgb3Blbl9vdXQgPSBvcGVuX291dFxubGV0IG9wZW5fb3V0X2JpbiA9IG9wZW5fb3V0X2JpblxubGV0IG9wZW5fb3V0X2dlbiA9IG9wZW5fb3V0X2dlblxubGV0IGZsdXNoID0gZmx1c2hcbmxldCBmbHVzaF9hbGwgPSBmbHVzaF9hbGxcbmxldCBvdXRwdXRfY2hhciA9IG91dHB1dF9jaGFyXG5sZXQgb3V0cHV0X3N0cmluZyA9IG91dHB1dF9zdHJpbmdcbmxldCBvdXRwdXRfYnl0ZXMgPSBvdXRwdXRfYnl0ZXNcbmxldCBvdXRwdXQgPSBvdXRwdXRcbmxldCBvdXRwdXRfc3Vic3RyaW5nID0gb3V0cHV0X3N1YnN0cmluZ1xubGV0IG91dHB1dF9ieXRlID0gb3V0cHV0X2J5dGVcbmxldCBvdXRwdXRfYmluYXJ5X2ludCA9IG91dHB1dF9iaW5hcnlfaW50XG5sZXQgb3V0cHV0X3ZhbHVlID0gb3V0cHV0X3ZhbHVlXG5sZXQgc2Vla19vdXQgPSBzZWVrX291dFxubGV0IHBvc19vdXQgPSBwb3Nfb3V0XG5sZXQgb3V0X2NoYW5uZWxfbGVuZ3RoID0gb3V0X2NoYW5uZWxfbGVuZ3RoXG5sZXQgY2xvc2Vfb3V0ID0gY2xvc2Vfb3V0XG5sZXQgY2xvc2Vfb3V0X25vZXJyID0gY2xvc2Vfb3V0X25vZXJyXG5sZXQgc2V0X2JpbmFyeV9tb2RlX291dCA9IHNldF9iaW5hcnlfbW9kZV9vdXRcbmxldCBvcGVuX2luID0gb3Blbl9pblxubGV0IG9wZW5faW5fYmluID0gb3Blbl9pbl9iaW5cbmxldCBvcGVuX2luX2dlbiA9IG9wZW5faW5fZ2VuXG5sZXQgaW5wdXRfY2hhciA9IGlucHV0X2NoYXJcbmxldCBpbnB1dF9saW5lID0gaW5wdXRfbGluZVxubGV0IGlucHV0ID0gaW5wdXRcbmxldCByZWFsbHlfaW5wdXQgPSByZWFsbHlfaW5wdXRcbmxldCByZWFsbHlfaW5wdXRfc3RyaW5nID0gcmVhbGx5X2lucHV0X3N0cmluZ1xubGV0IGlucHV0X2J5dGUgPSBpbnB1dF9ieXRlXG5sZXQgaW5wdXRfYmluYXJ5X2ludCA9IGlucHV0X2JpbmFyeV9pbnRcbmxldCBpbnB1dF92YWx1ZSA9IGlucHV0X3ZhbHVlXG5sZXQgc2Vla19pbiA9IHNlZWtfaW5cbmxldCBwb3NfaW4gPSBwb3NfaW5cbmxldCBpbl9jaGFubmVsX2xlbmd0aCA9IGluX2NoYW5uZWxfbGVuZ3RoXG5sZXQgY2xvc2VfaW4gPSBjbG9zZV9pblxubGV0IGNsb3NlX2luX25vZXJyID0gY2xvc2VfaW5fbm9lcnJcbmxldCBzZXRfYmluYXJ5X21vZGVfaW4gPSBzZXRfYmluYXJ5X21vZGVfaW5cbm1vZHVsZSBMYXJnZUZpbGUgPSBMYXJnZUZpbGVcbnR5cGUgbm9ucmVjICdhIHJlZiA9ICdhIHJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cbmV4dGVybmFsIHJlZiA6ICdhIC0+ICdhIHJlZiA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsICggISApIDogJ2EgcmVmIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsICggOj0gKSA6ICdhIHJlZiAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcbmV4dGVybmFsIGluY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVpbmNyXCJcbmV4dGVybmFsIGRlY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVkZWNyXCJcbnR5cGUgbm9ucmVjICgnYSwnYikgcmVzdWx0ID0gKCdhLCdiKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdiXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG50eXBlICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA9ICgnYSwgJ2IsICdjLCAnYywgJ2MsICdkKSBmb3JtYXQ2XG50eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYywgJ2MpIGZvcm1hdDRcbmxldCBzdHJpbmdfb2ZfZm9ybWF0ID0gc3RyaW5nX29mX2Zvcm1hdFxuZXh0ZXJuYWwgZm9ybWF0X29mX3N0cmluZyA6XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID0gXCIlaWRlbnRpdHlcIlxubGV0ICggXl4gKSA9ICggXl4gKVxubGV0IGV4aXQgPSBleGl0XG5sZXQgYXRfZXhpdCA9IGF0X2V4aXRcbmxldCB2YWxpZF9mbG9hdF9sZXhlbSA9IHZhbGlkX2Zsb2F0X2xleGVtXG5sZXQgZG9fYXRfZXhpdCA9IGRvX2F0X2V4aXRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgTmljb2xhcyBPamVkYSBCYXIsIExleGlGaSAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXh0ZXJuYWwgbmVnIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVuZWdmbG9hdFwiXG5leHRlcm5hbCBhZGQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFkZGZsb2F0XCJcbmV4dGVybmFsIHN1YiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlc3ViZmxvYXRcIlxuZXh0ZXJuYWwgbXVsIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVtdWxmbG9hdFwiXG5leHRlcm5hbCBkaXYgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWRpdmZsb2F0XCJcbmV4dGVybmFsIHJlbSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Ztb2RfZmxvYXRcIiBcImZtb2RcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZm1hIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1hX2Zsb2F0XCIgXCJjYW1sX2ZtYVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhYnMgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFic2Zsb2F0XCJcblxubGV0IHplcm8gPSAwLlxubGV0IG9uZSA9IDEuXG5sZXQgbWludXNfb25lID0gLTEuXG5sZXQgaW5maW5pdHkgPSBTdGRsaWIuaW5maW5pdHlcbmxldCBuZWdfaW5maW5pdHkgPSBTdGRsaWIubmVnX2luZmluaXR5XG5sZXQgbmFuID0gU3RkbGliLm5hblxubGV0IGlzX2Zpbml0ZSAoeDogZmxvYXQpID0geCAtLiB4ID0gMC5cbmxldCBpc19pbmZpbml0ZSAoeDogZmxvYXQpID0gMS4gLy4geCA9IDAuXG5sZXQgaXNfbmFuICh4OiBmbG9hdCkgPSB4IDw+IHhcblxubGV0IHBpID0gMHgxLjkyMWZiNTQ0NDJkMThwKzFcbmxldCBtYXhfZmxvYXQgPSBTdGRsaWIubWF4X2Zsb2F0XG5sZXQgbWluX2Zsb2F0ID0gU3RkbGliLm1pbl9mbG9hdFxubGV0IGVwc2lsb24gPSBTdGRsaWIuZXBzaWxvbl9mbG9hdFxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCB0b19pbnQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBmbG9hdCA9IFwiY2FtbF9mbG9hdF9vZl9zdHJpbmdcIlxubGV0IG9mX3N0cmluZ19vcHQgPSBTdGRsaWIuZmxvYXRfb2Zfc3RyaW5nX29wdFxubGV0IHRvX3N0cmluZyA9IFN0ZGxpYi5zdHJpbmdfb2ZfZmxvYXRcbnR5cGUgZnBjbGFzcyA9IFN0ZGxpYi5mcGNsYXNzID1cbiAgICBGUF9ub3JtYWxcbiAgfCBGUF9zdWJub3JtYWxcbiAgfCBGUF96ZXJvXG4gIHwgRlBfaW5maW5pdGVcbiAgfCBGUF9uYW5cbmV4dGVybmFsIGNsYXNzaWZ5X2Zsb2F0IDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IGZwY2xhc3MgPVxuICBcImNhbWxfY2xhc3NpZnlfZmxvYXRcIiBcImNhbWxfY2xhc3NpZnlfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBwb3cgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9wb3dlcl9mbG9hdFwiIFwicG93XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNxcnQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zcXJ0X2Zsb2F0XCIgXCJzcXJ0XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNicnQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jYnJ0X2Zsb2F0XCIgXCJjYW1sX2NicnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwMiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cDJfZmxvYXRcIiBcImNhbWxfZXhwMlwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cyIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMl9mbG9hdFwiIFwiY2FtbF9sb2cyXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cG0xIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwbTFfZmxvYXRcIiBcImNhbWxfZXhwbTFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMXAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxcF9mbG9hdFwiIFwiY2FtbF9sb2cxcFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NfZmxvYXRcIiBcImNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5fZmxvYXRcIiBcInNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5fZmxvYXRcIiBcInRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc19mbG9hdFwiIFwiYWNvc1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbl9mbG9hdFwiIFwiYXNpblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbl9mbG9hdFwiIFwiYXRhblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuMiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW4yX2Zsb2F0XCIgXCJhdGFuMlwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBoeXBvdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luaF9mbG9hdFwiIFwic2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuaF9mbG9hdFwiIFwidGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NoX2Zsb2F0XCIgXCJjYW1sX2Fjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbmhfZmxvYXRcIiBcImNhbWxfYXNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuaF9mbG9hdFwiIFwiY2FtbF9hdGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBlcmYgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9lcmZfZmxvYXRcIiBcImNhbWxfZXJmXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGVyZmMgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9lcmZjX2Zsb2F0XCIgXCJjYW1sX2VyZmNcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdHJ1bmMgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90cnVuY19mbG9hdFwiIFwiY2FtbF90cnVuY1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCByb3VuZCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3JvdW5kX2Zsb2F0XCIgXCJjYW1sX3JvdW5kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNlaWwgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jZWlsX2Zsb2F0XCIgXCJjZWlsXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb29yIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZmxvb3JfZmxvYXRcIiBcImZsb29yXCJcbltAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbmxldCBpc19pbnRlZ2VyIHggPSB4ID0gdHJ1bmMgeCAmJiBpc19maW5pdGUgeFxuXG5leHRlcm5hbCBuZXh0X2FmdGVyIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgPSBcImNhbWxfbmV4dGFmdGVyX2Zsb2F0XCIgXCJjYW1sX25leHRhZnRlclwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbmxldCBzdWNjIHggPSBuZXh0X2FmdGVyIHggaW5maW5pdHlcbmxldCBwcmVkIHggPSBuZXh0X2FmdGVyIHggbmVnX2luZmluaXR5XG5cbmV4dGVybmFsIGNvcHlfc2lnbiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICAgICA9IFwiY2FtbF9jb3B5c2lnbl9mbG9hdFwiIFwiY2FtbF9jb3B5c2lnblwiXG4gICAgICAgICAgICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2lnbl9iaXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gYm9vbFxuICA9IFwiY2FtbF9zaWduYml0X2Zsb2F0XCIgXCJjYW1sX3NpZ25iaXRcIiBbQEBub2FsbG9jXVxuXG5leHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcbmV4dGVybmFsIGxkZXhwIDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IChpbnQgW0B1bnRhZ2dlZF0pIC0+IChmbG9hdCBbQHVuYm94ZWRdKSA9XG4gIFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZGYgOiBmbG9hdCAtPiBmbG9hdCAqIGZsb2F0ID0gXCJjYW1sX21vZGZfZmxvYXRcIlxudHlwZSB0ID0gZmxvYXRcbmV4dGVybmFsIGNvbXBhcmUgOiBmbG9hdCAtPiBmbG9hdCAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmxldCBlcXVhbCB4IHkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0W0BpbmxpbmVdIG1pbiAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geSB0aGVuIHkgZWxzZSB4XG4gIGVsc2UgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxuXG5sZXRbQGlubGluZV0gbWF4ICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB4IHRoZW4geCBlbHNlIHlcbiAgZWxzZSBpZiBpc19uYW4geSB0aGVuIHkgZWxzZSB4XG5cbmxldFtAaW5saW5lXSBtaW5fbWF4ICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIGlzX25hbiB4IHx8IGlzX25hbiB5IHRoZW4gKG5hbiwgbmFuKVxuICBlbHNlIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlbiAoeCwgeSkgZWxzZSAoeSwgeClcblxubGV0W0BpbmxpbmVdIG1pbl9udW0gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgeFxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4geCBlbHNlIHlcblxubGV0W0BpbmxpbmVdIG1heF9udW0gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgeVxuICBlbHNlIGlmIGlzX25hbiB4IHRoZW4geSBlbHNlIHhcblxubGV0W0BpbmxpbmVdIG1pbl9tYXhfbnVtICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIGlzX25hbiB4IHRoZW4gKHkseSlcbiAgZWxzZSBpZiBpc19uYW4geSB0aGVuICh4LHgpXG4gIGVsc2UgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuICh4LHkpIGVsc2UgKHkseClcblxuZXh0ZXJuYWwgc2VlZGVkX2hhc2hfcGFyYW0gOiBpbnQgLT4gaW50IC0+IGludCAtPiBmbG9hdCAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcblxubW9kdWxlIEFycmF5ID0gc3RydWN0XG5cbiAgdHlwZSB0ID0gZmxvYXRhcnJheVxuXG4gIGV4dGVybmFsIGxlbmd0aCA6IHQgLT4gaW50ID0gXCIlZmxvYXRhcnJheV9sZW5ndGhcIlxuICBleHRlcm5hbCBnZXQgOiB0IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBzZXQgOiB0IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV9zYWZlX3NldFwiXG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiB0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldCA6IHQgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldCA6IHQgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9zZXRcIlxuXG4gIGxldCB1bnNhZmVfZmlsbCBhIG9mcyBsZW4gdiA9XG4gICAgZm9yIGkgPSBvZnMgdG8gb2ZzICsgbGVuIC0gMSBkbyB1bnNhZmVfc2V0IGEgaSB2IGRvbmVcblxuICBleHRlcm5hbCB1bnNhZmVfYmxpdDogdCAtPiBpbnQgLT4gdCAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPVxuICAgIFwiY2FtbF9mbG9hdGFycmF5X2JsaXRcIiBbQEBub2FsbG9jXVxuXG4gIGxldCBjaGVjayBhIG9mcyBsZW4gbXNnID1cbiAgICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzICsgbGVuIDwgMCB8fCBvZnMgKyBsZW4gPiBsZW5ndGggYSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBtc2dcblxuICBsZXQgbWFrZSBuIHYgPVxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbiBpblxuICAgIHVuc2FmZV9maWxsIHJlc3VsdCAwIG4gdjtcbiAgICByZXN1bHRcblxuICBsZXQgaW5pdCBsIGYgPVxuICAgIGlmIGwgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5pbml0XCJcbiAgICBlbHNlXG4gICAgICBsZXQgcmVzID0gY3JlYXRlIGwgaW5cbiAgICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IHJlcyBpIChmIGkpXG4gICAgICBkb25lO1xuICAgICAgcmVzXG5cbiAgbGV0IGFwcGVuZCBhMSBhMiA9XG4gICAgbGV0IGwxID0gbGVuZ3RoIGExIGluXG4gICAgbGV0IGwyID0gbGVuZ3RoIGEyIGluXG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSAobDEgKyBsMikgaW5cbiAgICB1bnNhZmVfYmxpdCBhMSAwIHJlc3VsdCAwIGwxO1xuICAgIHVuc2FmZV9ibGl0IGEyIDAgcmVzdWx0IGwxIGwyO1xuICAgIHJlc3VsdFxuXG4gICgqIG5leHQgMyBmdW5jdGlvbnM6IG1vZGlmaWVkIGNvcHkgb2YgY29kZSBmcm9tIHN0cmluZy5tbCAqKVxuICBsZXQgZW5zdXJlX2dlICh4OmludCkgeSA9XG4gICAgaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkuY29uY2F0XCJcblxuICBsZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIGFjYykgYWNjKSB0bFxuXG4gIGxldCBjb25jYXQgbCA9XG4gICAgbGV0IGxlbiA9IHN1bV9sZW5ndGhzIDAgbCBpblxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbGVuIGluXG4gICAgbGV0IHJlYyBsb29wIGwgaSA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IChpID0gbGVuKVxuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICBsZXQgaGxlbiA9IGxlbmd0aCBoZCBpblxuICAgICAgICB1bnNhZmVfYmxpdCBoZCAwIHJlc3VsdCBpIGhsZW47XG4gICAgICAgIGxvb3AgdGwgKGkgKyBobGVuKVxuICAgIGluXG4gICAgbG9vcCBsIDA7XG4gICAgcmVzdWx0XG5cbiAgbGV0IHN1YiBhIG9mcyBsZW4gPVxuICAgIGNoZWNrIGEgb2ZzIGxlbiBcIkZsb2F0LkFycmF5LnN1YlwiO1xuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbGVuIGluXG4gICAgdW5zYWZlX2JsaXQgYSBvZnMgcmVzdWx0IDAgbGVuO1xuICAgIHJlc3VsdFxuXG4gIGxldCBjb3B5IGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIGwgaW5cbiAgICB1bnNhZmVfYmxpdCBhIDAgcmVzdWx0IDAgbDtcbiAgICByZXN1bHRcblxuICBsZXQgZmlsbCBhIG9mcyBsZW4gdiA9XG4gICAgY2hlY2sgYSBvZnMgbGVuIFwiRmxvYXQuQXJyYXkuZmlsbFwiO1xuICAgIHVuc2FmZV9maWxsIGEgb2ZzIGxlbiB2XG5cbiAgbGV0IGJsaXQgc3JjIHNvZnMgZHN0IGRvZnMgbGVuID1cbiAgICBjaGVjayBzcmMgc29mcyBsZW4gXCJGbG9hdC5hcnJheS5ibGl0XCI7XG4gICAgY2hlY2sgZHN0IGRvZnMgbGVuIFwiRmxvYXQuYXJyYXkuYmxpdFwiO1xuICAgIHVuc2FmZV9ibGl0IHNyYyBzb2ZzIGRzdCBkb2ZzIGxlblxuXG4gIGxldCB0b19saXN0IGEgPVxuICAgIExpc3QuaW5pdCAobGVuZ3RoIGEpICh1bnNhZmVfZ2V0IGEpXG5cbiAgbGV0IG9mX2xpc3QgbCA9XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSAoTGlzdC5sZW5ndGggbCkgaW5cbiAgICBsZXQgcmVjIGZpbGwgaSBsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiByZXN1bHRcbiAgICAgIHwgaCA6OiB0IC0+IHVuc2FmZV9zZXQgcmVzdWx0IGkgaDsgZmlsbCAoaSArIDEpIHRcbiAgICBpblxuICAgIGZpbGwgMCBsXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyIGYgYSA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgaXRlcjIgZiBhIGIgPVxuICAgIGlmIGxlbmd0aCBhIDw+IGxlbmd0aCBiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkuaXRlcjI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgICBlbHNlXG4gICAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpIGRvbmVcblxuICBsZXQgbWFwIGYgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbiAgbGV0IG1hcDIgZiBhIGIgPVxuICAgIGxldCBsYSA9IGxlbmd0aCBhIGluXG4gICAgbGV0IGxiID0gbGVuZ3RoIGIgaW5cbiAgICBpZiBsYSA8PiBsYiB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5Lm1hcDI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IGNyZWF0ZSBsYSBpblxuICAgICAgZm9yIGkgPSAwIHRvIGxhIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkpXG4gICAgICBkb25lO1xuICAgICAgclxuICAgIGVuZFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgaXRlcmkgZiBhID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxuICBsZXQgbWFwaSBmIGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmb2xkX2xlZnQgZiB4IGEgPVxuICAgIGxldCByID0gcmVmIHggaW5cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgYSBpKVxuICAgIGRvbmU7XG4gICAgIXJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZvbGRfcmlnaHQgZiBhIHggPVxuICAgIGxldCByID0gcmVmIHggaW5cbiAgICBmb3IgaSA9IGxlbmd0aCBhIC0gMSBkb3dudG8gMCBkb1xuICAgICAgciA6PSBmICh1bnNhZmVfZ2V0IGEgaSkgIXJcbiAgICBkb25lO1xuICAgICFyXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBleGlzdHMgcCBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgICBlbHNlIGxvb3AgKGkgKyAxKSBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZm9yX2FsbCBwIGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIHRydWVcbiAgICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gbG9vcCAoaSArIDEpXG4gICAgICBlbHNlIGZhbHNlIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBtZW0geCBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgICAgZWxzZSBpZiBjb21wYXJlICh1bnNhZmVfZ2V0IGEgaSkgeCA9IDAgdGhlbiB0cnVlXG4gICAgICBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cbiAgKCogbW9zdGx5IGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCwgYnV0IHNsaWdodGx5IGRpZmZlcmVudCAqKVxuICBsZXQgbWVtX2llZWUgeCBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgICAgZWxzZSBpZiB4ID0gKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgZXhjZXB0aW9uIEJvdHRvbSBvZiBpbnRcbiAgbGV0IHNvcnQgY21wIGEgPVxuICAgIGxldCBtYXhzb24gbCBpID1cbiAgICAgIGxldCBpMzEgPSBpK2kraSsxIGluXG4gICAgICBsZXQgeCA9IHJlZiBpMzEgaW5cbiAgICAgIGlmIGkzMSsyIDwgbCB0aGVuIGJlZ2luXG4gICAgICAgIGlmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwIHRoZW4geCA6PSBpMzErMTtcbiAgICAgICAgaWYgY21wIChnZXQgYSAheCkgKGdldCBhIChpMzErMikpIDwgMCB0aGVuIHggOj0gaTMxKzI7XG4gICAgICAgICF4XG4gICAgICBlbmQgZWxzZVxuICAgICAgICBpZiBpMzErMSA8IGwgJiYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDBcbiAgICAgICAgdGhlbiBpMzErMVxuICAgICAgICBlbHNlIGlmIGkzMSA8IGwgdGhlbiBpMzEgZWxzZSByYWlzZSAoQm90dG9tIGkpXG4gICAgaW5cbiAgICBsZXQgcmVjIHRyaWNrbGVkb3duIGwgaSBlID1cbiAgICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgICAgaWYgY21wIChnZXQgYSBqKSBlID4gMCB0aGVuIGJlZ2luXG4gICAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgICB0cmlja2xlZG93biBsIGogZTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBhIGkgZTtcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxldCB0cmlja2xlIGwgaSBlID0gdHJ5IHRyaWNrbGVkb3duIGwgaSBlIHdpdGggQm90dG9tIGkgLT4gc2V0IGEgaSBlIGluXG4gICAgbGV0IHJlYyBidWJibGVkb3duIGwgaSA9XG4gICAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgYnViYmxlZG93biBsIGpcbiAgICBpblxuICAgIGxldCBidWJibGUgbCBpID0gdHJ5IGJ1YmJsZWRvd24gbCBpIHdpdGggQm90dG9tIGkgLT4gaSBpblxuICAgIGxldCByZWMgdHJpY2tsZXVwIGkgZSA9XG4gICAgICBsZXQgZmF0aGVyID0gKGkgLSAxKSAvIDMgaW5cbiAgICAgIGFzc2VydCAoaSA8PiBmYXRoZXIpO1xuICAgICAgaWYgY21wIChnZXQgYSBmYXRoZXIpIGUgPCAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGEgaSAoZ2V0IGEgZmF0aGVyKTtcbiAgICAgICAgaWYgZmF0aGVyID4gMCB0aGVuIHRyaWNrbGV1cCBmYXRoZXIgZSBlbHNlIHNldCBhIDAgZTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBhIGkgZTtcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBmb3IgaSA9IChsICsgMSkgLyAzIC0gMSBkb3dudG8gMCBkbyB0cmlja2xlIGwgaSAoZ2V0IGEgaSk7IGRvbmU7XG4gICAgZm9yIGkgPSBsIC0gMSBkb3dudG8gMiBkb1xuICAgICAgbGV0IGUgPSAoZ2V0IGEgaSkgaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIDApO1xuICAgICAgdHJpY2tsZXVwIChidWJibGUgaSAwKSBlO1xuICAgIGRvbmU7XG4gICAgaWYgbCA+IDEgdGhlbiAobGV0IGUgPSAoZ2V0IGEgMSkgaW4gc2V0IGEgMSAoZ2V0IGEgMCk7IHNldCBhIDAgZSlcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwsIGV4Y2VwdCBmb3IgdGhlIGNhbGwgdG8gW2NyZWF0ZV0gKilcbiAgbGV0IGN1dG9mZiA9IDVcbiAgbGV0IHN0YWJsZV9zb3J0IGNtcCBhID1cbiAgICBsZXQgbWVyZ2Ugc3JjMW9mcyBzcmMxbGVuIHNyYzIgc3JjMm9mcyBzcmMybGVuIGRzdCBkc3RvZnMgPVxuICAgICAgbGV0IHNyYzFyID0gc3JjMW9mcyArIHNyYzFsZW4gYW5kIHNyYzJyID0gc3JjMm9mcyArIHNyYzJsZW4gaW5cbiAgICAgIGxldCByZWMgbG9vcCBpMSBzMSBpMiBzMiBkID1cbiAgICAgICAgaWYgY21wIHMxIHMyIDw9IDAgdGhlbiBiZWdpblxuICAgICAgICAgIHNldCBkc3QgZCBzMTtcbiAgICAgICAgICBsZXQgaTEgPSBpMSArIDEgaW5cbiAgICAgICAgICBpZiBpMSA8IHNyYzFyIHRoZW5cbiAgICAgICAgICAgIGxvb3AgaTEgKGdldCBhIGkxKSBpMiBzMiAoZCArIDEpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYmxpdCBzcmMyIGkyIGRzdCAoZCArIDEpIChzcmMyciAtIGkyKVxuICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgIHNldCBkc3QgZCBzMjtcbiAgICAgICAgICBsZXQgaTIgPSBpMiArIDEgaW5cbiAgICAgICAgICBpZiBpMiA8IHNyYzJyIHRoZW5cbiAgICAgICAgICAgIGxvb3AgaTEgczEgaTIgKGdldCBzcmMyIGkyKSAoZCArIDEpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYmxpdCBhIGkxIGRzdCAoZCArIDEpIChzcmMxciAtIGkxKVxuICAgICAgICBlbmRcbiAgICAgIGluIGxvb3Agc3JjMW9mcyAoZ2V0IGEgc3JjMW9mcykgc3JjMm9mcyAoZ2V0IHNyYzIgc3JjMm9mcykgZHN0b2ZzO1xuICAgIGluXG4gICAgbGV0IGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIGxldCBlID0gKGdldCBhIChzcmNvZnMgKyBpKSkgaW5cbiAgICAgICAgbGV0IGogPSByZWYgKGRzdG9mcyArIGkgLSAxKSBpblxuICAgICAgICB3aGlsZSAoIWogPj0gZHN0b2ZzICYmIGNtcCAoZ2V0IGRzdCAhaikgZSA+IDApIGRvXG4gICAgICAgICAgc2V0IGRzdCAoIWogKyAxKSAoZ2V0IGRzdCAhaik7XG4gICAgICAgICAgZGVjciBqO1xuICAgICAgICBkb25lO1xuICAgICAgICBzZXQgZHN0ICghaiArIDEpIGU7XG4gICAgICBkb25lO1xuICAgIGluXG4gICAgbGV0IHJlYyBzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICAgIGlmIGxlbiA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBsMSA9IGxlbiAvIDIgaW5cbiAgICAgICAgbGV0IGwyID0gbGVuIC0gbDEgaW5cbiAgICAgICAgc29ydHRvIChzcmNvZnMgKyBsMSkgZHN0IChkc3RvZnMgKyBsMSkgbDI7XG4gICAgICAgIHNvcnR0byBzcmNvZnMgYSAoc3Jjb2ZzICsgbDIpIGwxO1xuICAgICAgICBtZXJnZSAoc3Jjb2ZzICsgbDIpIGwxIGRzdCAoZHN0b2ZzICsgbDEpIGwyIGRzdCBkc3RvZnM7XG4gICAgICBlbmQ7XG4gICAgaW5cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgaWYgbCA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIDAgYSAwIGwgZWxzZSBiZWdpblxuICAgICAgbGV0IGwxID0gbCAvIDIgaW5cbiAgICAgIGxldCBsMiA9IGwgLSBsMSBpblxuICAgICAgbGV0IHQgPSBjcmVhdGUgbDIgaW5cbiAgICAgIHNvcnR0byBsMSB0IDAgbDI7XG4gICAgICBzb3J0dG8gMCBhIGwyIGwxO1xuICAgICAgbWVyZ2UgbDIgbDEgdCAwIGwyIGEgMDtcbiAgICBlbmRcblxuICBsZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IHRvX3NlcSBhID1cbiAgICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICAgIGlmIGkgPCBsZW5ndGggYVxuICAgICAgdGhlblxuICAgICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gICAgICBlbHNlIFNlcS5OaWxcbiAgICBpblxuICAgIGF1eCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCB0b19zZXFpIGEgPVxuICAgIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgICB0aGVuXG4gICAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gICAgICBlbHNlIFNlcS5OaWxcbiAgICBpblxuICAgIGF1eCAwXG5cbiAgKCogbW9zdGx5IGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgb2ZfcmV2X2xpc3QgbCA9XG4gICAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIGwgaW5cbiAgICBsZXQgYSA9IGNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgIFtdIC0+IGFcbiAgICAgIHwgaGQ6OnRsIC0+IHVuc2FmZV9zZXQgYSBpIGhkOyBmaWxsIChpLTEpIHRsXG4gICAgaW5cbiAgICBmaWxsIChsZW4tMSkgbFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgb2Zfc2VxIGkgPVxuICAgIGxldCBsID0gU2VxLmZvbGRfbGVmdCAoZnVuIGFjYyB4IC0+IHg6OmFjYykgW10gaSBpblxuICAgIG9mX3Jldl9saXN0IGxcblxuXG4gIGxldCBtYXBfdG9fYXJyYXkgZiBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgaWYgbCA9IDAgdGhlbiBbfCB8XSBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IEFycmF5Lm1ha2UgbCAoZiAodW5zYWZlX2dldCBhIDApKSBpblxuICAgICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICAgIEFycmF5LnVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgICBkb25lO1xuICAgICAgclxuICAgIGVuZFxuXG4gIGxldCBtYXBfZnJvbV9hcnJheSBmIGEgPVxuICAgIGxldCBsID0gQXJyYXkubGVuZ3RoIGEgaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiAoQXJyYXkudW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuXG5lbmRcblxubW9kdWxlIEFycmF5TGFiZWxzID0gQXJyYXlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG4gICBUaGlzIGlzIGEgbGFnZ2VkLUZpYm9uYWNjaSBGKDU1LCAyNCwgKykgd2l0aCBhIG1vZGlmaWVkIGFkZGl0aW9uXG4gICBmdW5jdGlvbiB0byBlbmhhbmNlIHRoZSBtaXhpbmcgb2YgYml0cy5cbiAgIElmIHdlIHVzZSBub3JtYWwgYWRkaXRpb24sIHRoZSBsb3ctb3JkZXIgYml0IGZhaWxzIHRlc3RzIDEgYW5kIDdcbiAgIG9mIHRoZSBEaWVoYXJkIHRlc3Qgc3VpdGUsIGFuZCBiaXRzIDEgYW5kIDIgYWxzbyBmYWlsIHRlc3QgNy5cbiAgIElmIHdlIHVzZSBtdWx0aXBsaWNhdGlvbiBhcyBzdWdnZXN0ZWQgYnkgTWFyc2FnbGlhLCBpdCBkb2Vzbid0IGZhcmVcbiAgIG11Y2ggYmV0dGVyLlxuICAgQnkgbWl4aW5nIHRoZSBiaXRzIG9mIG9uZSBvZiB0aGUgbnVtYmVycyBiZWZvcmUgYWRkaXRpb24gKFhPUiB0aGVcbiAgIDUgaGlnaC1vcmRlciBiaXRzIGludG8gdGhlIGxvdy1vcmRlciBiaXRzKSwgd2UgZ2V0IGEgZ2VuZXJhdG9yIHRoYXRcbiAgIHBhc3NlcyBhbGwgdGhlIERpZWhhcmQgdGVzdHMuXG4qKVxuXG5leHRlcm5hbCByYW5kb21fc2VlZDogdW5pdCAtPiBpbnQgYXJyYXkgPSBcImNhbWxfc3lzX3JhbmRvbV9zZWVkXCJcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG5cbiAgdHlwZSB0ID0geyBzdCA6IGludCBhcnJheTsgbXV0YWJsZSBpZHggOiBpbnQgfVxuXG4gIGxldCBuZXdfc3RhdGUgKCkgPSB7IHN0ID0gQXJyYXkubWFrZSA1NSAwOyBpZHggPSAwIH1cbiAgbGV0IGFzc2lnbiBzdDEgc3QyID1cbiAgICBBcnJheS5ibGl0IHN0Mi5zdCAwIHN0MS5zdCAwIDU1O1xuICAgIHN0MS5pZHggPC0gc3QyLmlkeFxuXG5cbiAgbGV0IGZ1bGxfaW5pdCBzIHNlZWQgPVxuICAgIGxldCBjb21iaW5lIGFjY3UgeCA9IERpZ2VzdC5zdHJpbmcgKGFjY3UgXiBJbnQudG9fc3RyaW5nIHgpIGluXG4gICAgbGV0IGV4dHJhY3QgZCA9XG4gICAgICBDaGFyLmNvZGUgZC5bMF0gKyAoQ2hhci5jb2RlIGQuWzFdIGxzbCA4KSArIChDaGFyLmNvZGUgZC5bMl0gbHNsIDE2KVxuICAgICAgKyAoQ2hhci5jb2RlIGQuWzNdIGxzbCAyNClcbiAgICBpblxuICAgIGxldCBzZWVkID0gaWYgQXJyYXkubGVuZ3RoIHNlZWQgPSAwIHRoZW4gW3wgMCB8XSBlbHNlIHNlZWQgaW5cbiAgICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBzZWVkIGluXG4gICAgZm9yIGkgPSAwIHRvIDU0IGRvXG4gICAgICBzLnN0LihpKSA8LSBpO1xuICAgIGRvbmU7XG4gICAgbGV0IGFjY3UgPSByZWYgXCJ4XCIgaW5cbiAgICBmb3IgaSA9IDAgdG8gNTQgKyBJbnQubWF4IDU1IGwgZG9cbiAgICAgIGxldCBqID0gaSBtb2QgNTUgaW5cbiAgICAgIGxldCBrID0gaSBtb2QgbCBpblxuICAgICAgYWNjdSA6PSBjb21iaW5lICFhY2N1IHNlZWQuKGspO1xuICAgICAgcy5zdC4oaikgPC0gKHMuc3QuKGopIGx4b3IgZXh0cmFjdCAhYWNjdSkgbGFuZCAweDNGRkZGRkZGOyAgKCogUFIjNTU3NSAqKVxuICAgIGRvbmU7XG4gICAgcy5pZHggPC0gMFxuXG5cbiAgbGV0IG1ha2Ugc2VlZCA9XG4gICAgbGV0IHJlc3VsdCA9IG5ld19zdGF0ZSAoKSBpblxuICAgIGZ1bGxfaW5pdCByZXN1bHQgc2VlZDtcbiAgICByZXN1bHRcblxuXG4gIGxldCBtYWtlX3NlbGZfaW5pdCAoKSA9IG1ha2UgKHJhbmRvbV9zZWVkICgpKVxuXG4gIGxldCBjb3B5IHMgPVxuICAgIGxldCByZXN1bHQgPSBuZXdfc3RhdGUgKCkgaW5cbiAgICBhc3NpZ24gcmVzdWx0IHM7XG4gICAgcmVzdWx0XG5cblxuICAoKiBSZXR1cm5zIDMwIHJhbmRvbSBiaXRzIGFzIGFuIGludGVnZXIgMCA8PSB4IDwgMTA3Mzc0MTgyNCAqKVxuICBsZXQgYml0cyBzID1cbiAgICBzLmlkeCA8LSAocy5pZHggKyAxKSBtb2QgNTU7XG4gICAgbGV0IGN1cnZhbCA9IHMuc3QuKHMuaWR4KSBpblxuICAgIGxldCBuZXd2YWwgPSBzLnN0Ligocy5pZHggKyAyNCkgbW9kIDU1KVxuICAgICAgICAgICAgICAgICArIChjdXJ2YWwgbHhvciAoKGN1cnZhbCBsc3IgMjUpIGxhbmQgMHgxRikpIGluXG4gICAgbGV0IG5ld3ZhbDMwID0gbmV3dmFsIGxhbmQgMHgzRkZGRkZGRiBpbiAgKCogUFIjNTU3NSAqKVxuICAgIHMuc3QuKHMuaWR4KSA8LSBuZXd2YWwzMDtcbiAgICBuZXd2YWwzMFxuXG5cbiAgbGV0IHJlYyBpbnRhdXggcyBuID1cbiAgICBsZXQgciA9IGJpdHMgcyBpblxuICAgIGxldCB2ID0gciBtb2QgbiBpblxuICAgIGlmIHIgLSB2ID4gMHgzRkZGRkZGRiAtIG4gKyAxIHRoZW4gaW50YXV4IHMgbiBlbHNlIHZcblxuICBsZXQgaW50IHMgYm91bmQgPVxuICAgIGlmIGJvdW5kID4gMHgzRkZGRkZGRiB8fCBib3VuZCA8PSAwXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnRcIlxuICAgIGVsc2UgaW50YXV4IHMgYm91bmRcblxuICBsZXQgcmVjIGludDYzYXV4IHMgbiA9XG4gICAgbGV0IG1heF9pbnRfMzIgPSAoMSBsc2wgMzApICsgMHgzRkZGRkZGRiBpbiAoKiAweDdGRkZGRkZGICopXG4gICAgbGV0IGIxID0gYml0cyBzIGluXG4gICAgbGV0IGIyID0gYml0cyBzIGluXG4gICAgbGV0IChyLCBtYXhfaW50KSA9XG4gICAgICBpZiBuIDw9IG1heF9pbnRfMzIgdGhlblxuICAgICAgICAoKiAzMSByYW5kb20gYml0cyBvbiBib3RoIDY0LWJpdCBPQ2FtbCBhbmQgSmF2YVNjcmlwdC5cbiAgICAgICAgICAgVXNlIHVwcGVyIDE1IGJpdHMgb2YgYjEgYW5kIDE2IGJpdHMgb2YgYjIuICopXG4gICAgICAgIGxldCBicG9zID1cbiAgICAgICAgICAoKChiMiBsYW5kIDB4M0ZGRkMwMDApIGxzbCAxKSBsb3IgKGIxIGxzciAxNSkpXG4gICAgICAgIGluXG4gICAgICAgICAgKGJwb3MsIG1heF9pbnRfMzIpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBiMyA9IGJpdHMgcyBpblxuICAgICAgICAoKiA2MiByYW5kb20gYml0cyBvbiA2NC1iaXQgT0NhbWw7IHVucmVhY2hhYmxlIG9uIEphdmFTY3JpcHQuXG4gICAgICAgICAgIFVzZSB1cHBlciAyMCBiaXRzIG9mIGIxIGFuZCAyMSBiaXRzIG9mIGIyIGFuZCBiMy4gKilcbiAgICAgICAgbGV0IGJwb3MgPVxuICAgICAgICAgICgoKChiMyBsYW5kIDB4M0ZGRkZFMDApIGxzbCAxMikgbG9yIChiMiBsc3IgOSkpIGxzbCAyMClcbiAgICAgICAgICAgIGxvciAoYjEgbHNyIDEwKVxuICAgICAgICBpblxuICAgICAgICAgIChicG9zLCBtYXhfaW50KVxuICAgIGluXG4gICAgbGV0IHYgPSByIG1vZCBuIGluXG4gICAgaWYgciAtIHYgPiBtYXhfaW50IC0gbiArIDEgdGhlbiBpbnQ2M2F1eCBzIG4gZWxzZSB2XG5cbiAgbGV0IGZ1bGxfaW50IHMgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDAgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJSYW5kb20uZnVsbF9pbnRcIlxuICAgIGVsc2UgaWYgYm91bmQgPiAweDNGRkZGRkZGIHRoZW5cbiAgICAgIGludDYzYXV4IHMgYm91bmRcbiAgICBlbHNlXG4gICAgICBpbnRhdXggcyBib3VuZFxuXG5cbiAgbGV0IHJlYyBpbnQzMmF1eCBzIG4gPVxuICAgIGxldCBiMSA9IEludDMyLm9mX2ludCAoYml0cyBzKSBpblxuICAgIGxldCBiMiA9IEludDMyLnNoaWZ0X2xlZnQgKEludDMyLm9mX2ludCAoYml0cyBzIGxhbmQgMSkpIDMwIGluXG4gICAgbGV0IHIgPSBJbnQzMi5sb2dvciBiMSBiMiBpblxuICAgIGxldCB2ID0gSW50MzIucmVtIHIgbiBpblxuICAgIGlmIEludDMyLnN1YiByIHYgPiBJbnQzMi5hZGQgKEludDMyLnN1YiBJbnQzMi5tYXhfaW50IG4pIDFsXG4gICAgdGhlbiBpbnQzMmF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50MzIgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMGxcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDMyXCJcbiAgICBlbHNlIGludDMyYXV4IHMgYm91bmRcblxuXG4gIGxldCByZWMgaW50NjRhdXggcyBuID1cbiAgICBsZXQgYjEgPSBJbnQ2NC5vZl9pbnQgKGJpdHMgcykgaW5cbiAgICBsZXQgYjIgPSBJbnQ2NC5zaGlmdF9sZWZ0IChJbnQ2NC5vZl9pbnQgKGJpdHMgcykpIDMwIGluXG4gICAgbGV0IGIzID0gSW50NjQuc2hpZnRfbGVmdCAoSW50NjQub2ZfaW50IChiaXRzIHMgbGFuZCA3KSkgNjAgaW5cbiAgICBsZXQgciA9IEludDY0LmxvZ29yIGIxIChJbnQ2NC5sb2dvciBiMiBiMykgaW5cbiAgICBsZXQgdiA9IEludDY0LnJlbSByIG4gaW5cbiAgICBpZiBJbnQ2NC5zdWIgciB2ID4gSW50NjQuYWRkIChJbnQ2NC5zdWIgSW50NjQubWF4X2ludCBuKSAxTFxuICAgIHRoZW4gaW50NjRhdXggcyBuXG4gICAgZWxzZSB2XG5cbiAgbGV0IGludDY0IHMgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDBMXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnQ2NFwiXG4gICAgZWxzZSBpbnQ2NGF1eCBzIGJvdW5kXG5cblxuICBsZXQgbmF0aXZlaW50ID1cbiAgICBpZiBOYXRpdmVpbnQuc2l6ZSA9IDMyXG4gICAgdGhlbiBmdW4gcyBib3VuZCAtPiBOYXRpdmVpbnQub2ZfaW50MzIgKGludDMyIHMgKE5hdGl2ZWludC50b19pbnQzMiBib3VuZCkpXG4gICAgZWxzZSBmdW4gcyBib3VuZCAtPiBJbnQ2NC50b19uYXRpdmVpbnQgKGludDY0IHMgKEludDY0Lm9mX25hdGl2ZWludCBib3VuZCkpXG5cblxuICAoKiBSZXR1cm5zIGEgZmxvYXQgMCA8PSB4IDw9IDEgd2l0aCBhdCBtb3N0IDYwIGJpdHMgb2YgcHJlY2lzaW9uLiAqKVxuICBsZXQgcmF3ZmxvYXQgcyA9XG4gICAgbGV0IHNjYWxlID0gMTA3Mzc0MTgyNC4wICAoKiAyXjMwICopXG4gICAgYW5kIHIxID0gU3RkbGliLmZsb2F0IChiaXRzIHMpXG4gICAgYW5kIHIyID0gU3RkbGliLmZsb2F0IChiaXRzIHMpXG4gICAgaW4gKHIxIC8uIHNjYWxlICsuIHIyKSAvLiBzY2FsZVxuXG5cbiAgbGV0IGZsb2F0IHMgYm91bmQgPSByYXdmbG9hdCBzICouIGJvdW5kXG5cbiAgbGV0IGJvb2wgcyA9IChiaXRzIHMgbGFuZCAxID0gMClcblxuZW5kXG5cbigqIFRoaXMgaXMgdGhlIHN0YXRlIHlvdSBnZXQgd2l0aCBbaW5pdCAyNzE4MjgxOF0gYW5kIHRoZW4gYXBwbHlpbmdcbiAgIHRoZSBcImxhbmQgMHgzRkZGRkZGRlwiIGZpbHRlciB0byB0aGVtLiAgU2VlICM1NTc1LCAjNTc5MywgIzU5NzcuICopXG5sZXQgZGVmYXVsdCA9IHtcbiAgU3RhdGUuc3QgPSBbfFxuICAgICAgMHgzYWUyNTIyYjsgMHgxZDhkNDYzNDsgMHgxNWI0ZmFkMDsgMHgxOGIxNGFjZTsgMHgxMmY4YTNjNDsgMHgzYjA4NmM0NztcbiAgICAgIDB4MTZkNDY3ZDY7IDB4MTAxZDkxYzc7IDB4MzIxZGYxNzc7IDB4MDE3NmMxOTM7IDB4MWZmNzJiZjE7IDB4MWU4ODkxMDk7XG4gICAgICAweDBiNDY0YjE4OyAweDJiODZiOTdjOyAweDA4OTFkYTQ4OyAweDAzMTM3NDYzOyAweDA4NWFjNWExOyAweDE1ZDYxZjJmO1xuICAgICAgMHgzYmNlZDM1OTsgMHgyOWMxYzEzMjsgMHgzYTg2NzY2ZTsgMHgzNjZkOGM4NjsgMHgxZjViNjIyMjsgMHgzY2UxYjU5ZjtcbiAgICAgIDB4MmViZjc4ZTE7IDB4MjdjZDFiODY7IDB4MjU4ZjNkYzM7IDB4Mzg5YTgxOTQ7IDB4MDJlNGM0NGM7IDB4MThjNDNmN2Q7XG4gICAgICAweDBmNmU1MzRmOyAweDFlN2RmMzU5OyAweDA1NWQwYjdlOyAweDEwZTg0ZTdlOyAweDEyNjE5OGU0OyAweDBlNzcyMmNiO1xuICAgICAgMHgxY2JlZGUyODsgMHgzMzkxYjk2NDsgMHgzZDQwZTkyYTsgMHgwYzU5OTMzZDsgMHgwYjhjZDBiNzsgMHgyNGVmZmYxYztcbiAgICAgIDB4MjgwM2ZkYWE7IDB4MDhlYmM3MmU7IDB4MGY1MjJlMzI7IDB4MDUzOThlZGM7IDB4MjE0NGEwNGM7IDB4MGFlZjNjYmQ7XG4gICAgICAweDAxYWQ0NzE5OyAweDM1YjkzY2Q2OyAweDJhNTU5ZDRmOyAweDFlNmZkNzY4OyAweDI2ZTI3ZjM2OyAweDE4NmYxOGMzO1xuICAgICAgMHgyZmJmOTY3YTtcbiAgICB8XTtcbiAgU3RhdGUuaWR4ID0gMDtcbn1cblxubGV0IGJpdHMgKCkgPSBTdGF0ZS5iaXRzIGRlZmF1bHRcbmxldCBpbnQgYm91bmQgPSBTdGF0ZS5pbnQgZGVmYXVsdCBib3VuZFxubGV0IGZ1bGxfaW50IGJvdW5kID0gU3RhdGUuZnVsbF9pbnQgZGVmYXVsdCBib3VuZFxubGV0IGludDMyIGJvdW5kID0gU3RhdGUuaW50MzIgZGVmYXVsdCBib3VuZFxubGV0IG5hdGl2ZWludCBib3VuZCA9IFN0YXRlLm5hdGl2ZWludCBkZWZhdWx0IGJvdW5kXG5sZXQgaW50NjQgYm91bmQgPSBTdGF0ZS5pbnQ2NCBkZWZhdWx0IGJvdW5kXG5sZXQgZmxvYXQgc2NhbGUgPSBTdGF0ZS5mbG9hdCBkZWZhdWx0IHNjYWxlXG5sZXQgYm9vbCAoKSA9IFN0YXRlLmJvb2wgZGVmYXVsdFxuXG5sZXQgZnVsbF9pbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgZGVmYXVsdCBzZWVkXG5sZXQgaW5pdCBzZWVkID0gU3RhdGUuZnVsbF9pbml0IGRlZmF1bHQgW3wgc2VlZCB8XVxubGV0IHNlbGZfaW5pdCAoKSA9IGZ1bGxfaW5pdCAocmFuZG9tX3NlZWQoKSlcblxuKCogTWFuaXB1bGF0aW5nIHRoZSBjdXJyZW50IHN0YXRlLiAqKVxuXG5sZXQgZ2V0X3N0YXRlICgpID0gU3RhdGUuY29weSBkZWZhdWx0XG5sZXQgc2V0X3N0YXRlIHMgPSBTdGF0ZS5hc3NpZ24gZGVmYXVsdCBzXG5cbigqKioqKioqKioqKioqKioqKioqKlxuXG4oKiBUZXN0IGZ1bmN0aW9ucy4gIE5vdCBpbmNsdWRlZCBpbiB0aGUgbGlicmFyeS5cbiAgIFRoZSBbY2hpc3F1YXJlXSBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIHdpdGggbiA+IDEwci5cbiAgIEl0IHJldHVybnMgYSB0cmlwbGUgKGxvdywgYWN0dWFsLCBoaWdoKS5cbiAgIElmIGxvdyA8PSBhY3R1YWwgPD0gaGlnaCwgdGhlIFtnXSBmdW5jdGlvbiBwYXNzZWQgdGhlIHRlc3QsXG4gICBvdGhlcndpc2UgaXQgZmFpbGVkLlxuXG4gIFNvbWUgcmVzdWx0czpcblxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCA1MDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMDAgMTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAyOTk3OTI2NDM7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMTQxNDIxMzY7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZiAxMDI0OyBjaGlzcXVhcmUgZGlmZiAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmIDEwMDsgY2hpc3F1YXJlIGRpZmYgMTAwMDAwIDEwMFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmMiAxMDI0OyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZjIgMTAwOyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMFxuaW5pdCAxNDE0MjEzNjsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG5pbml0IDI5OTc5MjY0MzsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG4tIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDkzNi43NTQ0NDY3OTY2MzI0NjUsIDk5Ny41LCAxMDYzLjI0NTU1MzIwMzM2NzU0KVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODkuNzQwMDAwMDAwMDA1MjM4NywgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg0ODU4LjU3ODY0Mzc2MjY5LCA1MDQ1LjUsIDUxNDEuNDIxMzU2MjM3MzEpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPVxuKDkzNi43NTQ0NDY3OTY2MzI0NjUsIDk0NC44MDU5OTk5OTk5ODIzMDUsIDEwNjMuMjQ1NTUzMjAzMzY3NTQpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTAxOS4xOTc0NDAwMDAwMDM1NSwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA1OS4zMTc3NjAwMDAwMDUzNiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTAzOS45ODQ2Mzk5OTk5OTUxMiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA1NC4zODIwNzk5OTk5OTU3NywgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA5MC4wOTYwMDAwMDAwMDUsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA3Ni43ODcyMDAwMDAwMDYxMiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4NS4xNzYwMDAwMDAwMDY3NTIxLCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODUuMjE2MDAwMDAwMDAwMzQ5MiwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDgwLjYyMjAwMDAwMDAwMzAyNjgsIDEyMC4pXG5cbiopXG5cbigqIFJldHVybiB0aGUgc3VtIG9mIHRoZSBzcXVhcmVzIG9mIHZbaTAsaTFbICopXG5sZXQgcmVjIHN1bXNxIHYgaTAgaTEgPVxuICBpZiBpMCA+PSBpMSB0aGVuIDAuMFxuICBlbHNlIGlmIGkxID0gaTAgKyAxIHRoZW4gU3RkbGliLmZsb2F0IHYuKGkwKSAqLiBTdGRsaWIuZmxvYXQgdi4oaTApXG4gIGVsc2Ugc3Vtc3EgdiBpMCAoKGkwK2kxKS8yKSArLiBzdW1zcSB2ICgoaTAraTEpLzIpIGkxXG5cblxubGV0IGNoaXNxdWFyZSBnIG4gciA9XG4gIGlmIG4gPD0gMTAgKiByIHRoZW4gaW52YWxpZF9hcmcgXCJjaGlzcXVhcmVcIjtcbiAgbGV0IGYgPSBBcnJheS5tYWtlIHIgMCBpblxuICBmb3IgaSA9IDEgdG8gbiBkb1xuICAgIGxldCB0ID0gZyByIGluXG4gICAgZi4odCkgPC0gZi4odCkgKyAxXG4gIGRvbmU7XG4gIGxldCB0ID0gc3Vtc3EgZiAwIHJcbiAgYW5kIHIgPSBTdGRsaWIuZmxvYXQgclxuICBhbmQgbiA9IFN0ZGxpYi5mbG9hdCBuIGluXG4gIGxldCBzciA9IDIuMCAqLiBzcXJ0IHIgaW5cbiAgKHIgLS4gc3IsICAgKHIgKi4gdCAvLiBuKSAtLiBuLCAgIHIgKy4gc3IpXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBsaW5lYXIgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb20gbnVtYmVycy5cbiopXG5sZXQgc3QgPSByZWYgMFxubGV0IGluaXRfZGlmZiByID0gc3QgOj0gaW50IHJcbmxldCBkaWZmIHIgPVxuICBsZXQgeDEgPSAhc3RcbiAgYW5kIHgyID0gaW50IHJcbiAgaW5cbiAgc3QgOj0geDI7XG4gIGlmIHgxID49IHgyIHRoZW5cbiAgICB4MSAtIHgyXG4gIGVsc2VcbiAgICByICsgeDEgLSB4MlxuXG5cbmxldCBzdDEgPSByZWYgMFxuYW5kIHN0MiA9IHJlZiAwXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBxdWFkcmF0aWMgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb21cbiAgIG51bWJlcnMuXG4qKVxubGV0IGluaXRfZGlmZjIgciA9IHN0MSA6PSBpbnQgcjsgc3QyIDo9IGludCByXG5sZXQgZGlmZjIgciA9XG4gIGxldCB4MSA9ICFzdDFcbiAgYW5kIHgyID0gIXN0MlxuICBhbmQgeDMgPSBpbnQgclxuICBpblxuICBzdDEgOj0geDI7XG4gIHN0MiA6PSB4MztcbiAgKHgzIC0geDIgLSB4MiArIHgxICsgMipyKSBtb2QgclxuXG5cbioqKioqKioqKioqKioqKioqKioqKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgbGlzdHMuICopXG50eXBlICdhIHQgPSAnYSBsaXN0ID0gW10gfCAoOjopIG9mICdhICogJ2EgbGlzdFxuXG4oKiBMaXN0IG9wZXJhdGlvbnMgKilcblxubGV0IHJlYyBsZW5ndGhfYXV4IGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gbGVuXG4gIHwgXzo6bCAtPiBsZW5ndGhfYXV4IChsZW4gKyAxKSBsXG5cbmxldCBsZW5ndGggbCA9IGxlbmd0aF9hdXggMCBsXG5cbmxldCBjb25zIGEgbCA9IGE6OmxcblxubGV0IGhkID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWlsd2l0aCBcImhkXCJcbiAgfCBhOjpfIC0+IGFcblxubGV0IHRsID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWlsd2l0aCBcInRsXCJcbiAgfCBfOjpsIC0+IGxcblxubGV0IG50aCBsIG4gPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5udGhcIiBlbHNlXG4gIGxldCByZWMgbnRoX2F1eCBsIG4gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gZmFpbHdpdGggXCJudGhcIlxuICAgIHwgYTo6bCAtPiBpZiBuID0gMCB0aGVuIGEgZWxzZSBudGhfYXV4IGwgKG4tMSlcbiAgaW4gbnRoX2F1eCBsIG5cblxubGV0IG50aF9vcHQgbCBuID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QubnRoXCIgZWxzZVxuICBsZXQgcmVjIG50aF9hdXggbCBuID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IGE6OmwgLT4gaWYgbiA9IDAgdGhlbiBTb21lIGEgZWxzZSBudGhfYXV4IGwgKG4tMSlcbiAgaW4gbnRoX2F1eCBsIG5cblxubGV0IGFwcGVuZCA9IChAKVxuXG5sZXQgcmVjIHJldl9hcHBlbmQgbDEgbDIgPVxuICBtYXRjaCBsMSB3aXRoXG4gICAgW10gLT4gbDJcbiAgfCBhIDo6IGwgLT4gcmV2X2FwcGVuZCBsIChhIDo6IGwyKVxuXG5sZXQgcmV2IGwgPSByZXZfYXBwZW5kIGwgW11cblxubGV0IHJlYyBpbml0X3RhaWxyZWNfYXV4IGFjYyBpIG4gZiA9XG4gIGlmIGkgPj0gbiB0aGVuIGFjY1xuICBlbHNlIGluaXRfdGFpbHJlY19hdXggKGYgaSA6OiBhY2MpIChpKzEpIG4gZlxuXG5sZXQgcmVjIGluaXRfYXV4IGkgbiBmID1cbiAgaWYgaSA+PSBuIHRoZW4gW11cbiAgZWxzZVxuICAgIGxldCByID0gZiBpIGluXG4gICAgciA6OiBpbml0X2F1eCAoaSsxKSBuIGZcblxubGV0IHJldl9pbml0X3RocmVzaG9sZCA9XG4gIG1hdGNoIFN5cy5iYWNrZW5kX3R5cGUgd2l0aFxuICB8IFN5cy5OYXRpdmUgfCBTeXMuQnl0ZWNvZGUgLT4gMTBfMDAwXG4gICgqIFdlIGRvbid0IGtub3cgdGhlIHNpemUgb2YgdGhlIHN0YWNrLCBiZXR0ZXIgYmUgc2FmZSBhbmQgYXNzdW1lIGl0J3NcbiAgICAgc21hbGwuICopXG4gIHwgU3lzLk90aGVyIF8gLT4gNTBcblxubGV0IGluaXQgbGVuIGYgPVxuICBpZiBsZW4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0LmluaXRcIiBlbHNlXG4gIGlmIGxlbiA+IHJldl9pbml0X3RocmVzaG9sZCB0aGVuIHJldiAoaW5pdF90YWlscmVjX2F1eCBbXSAwIGxlbiBmKVxuICBlbHNlIGluaXRfYXV4IDAgbGVuIGZcblxubGV0IHJlYyBmbGF0dGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGw6OnIgLT4gbCBAIGZsYXR0ZW4gclxuXG5sZXQgY29uY2F0ID0gZmxhdHRlblxuXG5sZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGE6OmwgLT4gbGV0IHIgPSBmIGEgaW4gciA6OiBtYXAgZiBsXG5cbmxldCByZWMgbWFwaSBpIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgYTo6bCAtPiBsZXQgciA9IGYgaSBhIGluIHIgOjogbWFwaSAoaSArIDEpIGYgbFxuXG5sZXQgbWFwaSBmIGwgPSBtYXBpIDAgZiBsXG5cbmxldCByZXZfbWFwIGYgbCA9XG4gIGxldCByZWMgcm1hcF9mIGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjdVxuICAgIHwgYTo6bCAtPiBybWFwX2YgKGYgYSA6OiBhY2N1KSBsXG4gIGluXG4gIHJtYXBfZiBbXSBsXG5cblxubGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+ICgpXG4gIHwgYTo6bCAtPiBmIGE7IGl0ZXIgZiBsXG5cbmxldCByZWMgaXRlcmkgaSBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoKVxuICB8IGE6OmwgLT4gZiBpIGE7IGl0ZXJpIChpICsgMSkgZiBsXG5cbmxldCBpdGVyaSBmIGwgPSBpdGVyaSAwIGYgbFxuXG5sZXQgcmVjIGZvbGRfbGVmdCBmIGFjY3UgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdIC0+IGFjY3VcbiAgfCBhOjpsIC0+IGZvbGRfbGVmdCBmIChmIGFjY3UgYSkgbFxuXG5sZXQgcmVjIGZvbGRfcmlnaHQgZiBsIGFjY3UgPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAtPiBhY2N1XG4gIHwgYTo6bCAtPiBmIGEgKGZvbGRfcmlnaHQgZiBsIGFjY3UpXG5cbmxldCByZWMgbWFwMiBmIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBsZXQgciA9IGYgYTEgYTIgaW4gciA6OiBtYXAyIGYgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0Lm1hcDJcIlxuXG5sZXQgcmV2X21hcDIgZiBsMSBsMiA9XG4gIGxldCByZWMgcm1hcDJfZiBhY2N1IGwxIGwyID1cbiAgICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgfCAoW10sIFtdKSAtPiBhY2N1XG4gICAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHJtYXAyX2YgKGYgYTEgYTIgOjogYWNjdSkgbDEgbDJcbiAgICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QucmV2X21hcDJcIlxuICBpblxuICBybWFwMl9mIFtdIGwxIGwyXG5cblxubGV0IHJlYyBpdGVyMiBmIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+ICgpXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmIGExIGEyOyBpdGVyMiBmIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5pdGVyMlwiXG5cbmxldCByZWMgZm9sZF9sZWZ0MiBmIGFjY3UgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gYWNjdVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZm9sZF9sZWZ0MiBmIChmIGFjY3UgYTEgYTIpIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb2xkX2xlZnQyXCJcblxubGV0IHJlYyBmb2xkX3JpZ2h0MiBmIGwxIGwyIGFjY3UgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gYWNjdVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZiBhMSBhMiAoZm9sZF9yaWdodDIgZiBsMSBsMiBhY2N1KVxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9sZF9yaWdodDJcIlxuXG5sZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gdHJ1ZVxuICB8IGE6OmwgLT4gcCBhICYmIGZvcl9hbGwgcCBsXG5cbmxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBwIGEgfHwgZXhpc3RzIHAgbFxuXG5sZXQgcmVjIGZvcl9hbGwyIHAgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gdHJ1ZVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcCBhMSBhMiAmJiBmb3JfYWxsMiBwIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb3JfYWxsMlwiXG5cbmxldCByZWMgZXhpc3RzMiBwIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGZhbHNlXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBwIGExIGEyIHx8IGV4aXN0czIgcCBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZXhpc3RzMlwiXG5cbmxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBjb21wYXJlIGEgeCA9IDAgfHwgbWVtIHggbFxuXG5sZXQgcmVjIG1lbXEgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IGEgPT0geCB8fCBtZW1xIHggbFxuXG5sZXQgcmVjIGFzc29jIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IChhLGIpOjpsIC0+IGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIGIgZWxzZSBhc3NvYyB4IGxcblxubGV0IHJlYyBhc3NvY19vcHQgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gTm9uZVxuICB8IChhLGIpOjpsIC0+IGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIFNvbWUgYiBlbHNlIGFzc29jX29wdCB4IGxcblxubGV0IHJlYyBhc3NxIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IChhLGIpOjpsIC0+IGlmIGEgPT0geCB0aGVuIGIgZWxzZSBhc3NxIHggbFxuXG5sZXQgcmVjIGFzc3Ffb3B0IHggPSBmdW5jdGlvblxuICAgIFtdIC0+IE5vbmVcbiAgfCAoYSxiKTo6bCAtPiBpZiBhID09IHggdGhlbiBTb21lIGIgZWxzZSBhc3NxX29wdCB4IGxcblxubGV0IHJlYyBtZW1fYXNzb2MgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoYSwgXykgOjogbCAtPiBjb21wYXJlIGEgeCA9IDAgfHwgbWVtX2Fzc29jIHggbFxuXG5sZXQgcmVjIG1lbV9hc3NxIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IGZhbHNlXG4gIHwgKGEsIF8pIDo6IGwgLT4gYSA9PSB4IHx8IG1lbV9hc3NxIHggbFxuXG5sZXQgcmVjIHJlbW92ZV9hc3NvYyB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IChhLCBfIGFzIHBhaXIpIDo6IGwgLT5cbiAgICAgIGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIGwgZWxzZSBwYWlyIDo6IHJlbW92ZV9hc3NvYyB4IGxcblxubGV0IHJlYyByZW1vdmVfYXNzcSB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IChhLCBfIGFzIHBhaXIpIDo6IGwgLT4gaWYgYSA9PSB4IHRoZW4gbCBlbHNlIHBhaXIgOjogcmVtb3ZlX2Fzc3EgeCBsXG5cbmxldCByZWMgZmluZCBwID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4geCBlbHNlIGZpbmQgcCBsXG5cbmxldCByZWMgZmluZF9vcHQgcCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBTb21lIHggZWxzZSBmaW5kX29wdCBwIGxcblxubGV0IHJlYyBmaW5kX21hcCBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBsIC0+XG4gICAgIGJlZ2luIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgcmVzdWx0IC0+IHJlc3VsdFxuICAgICAgIHwgTm9uZSAtPiBmaW5kX21hcCBmIGxcbiAgICAgZW5kXG5cbmxldCBmaW5kX2FsbCBwID1cbiAgbGV0IHJlYyBmaW5kIGFjY3UgPSBmdW5jdGlvblxuICB8IFtdIC0+IHJldiBhY2N1XG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIGZpbmQgKHggOjogYWNjdSkgbCBlbHNlIGZpbmQgYWNjdSBsIGluXG4gIGZpbmQgW11cblxubGV0IGZpbHRlciA9IGZpbmRfYWxsXG5cbmxldCBmaWx0ZXJpIHAgbCA9XG4gIGxldCByZWMgYXV4IGkgYWNjID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByZXYgYWNjXG4gIHwgeDo6bCAtPiBhdXggKGkgKyAxKSAoaWYgcCBpIHggdGhlbiB4OjphY2MgZWxzZSBhY2MpIGxcbiAgaW5cbiAgYXV4IDAgW10gbFxuXG5sZXQgZmlsdGVyX21hcCBmID1cbiAgbGV0IHJlYyBhdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXYgYWNjdVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBhdXggYWNjdSBsXG4gICAgICAgIHwgU29tZSB2IC0+IGF1eCAodiA6OiBhY2N1KSBsXG4gIGluXG4gIGF1eCBbXVxuXG5sZXQgY29uY2F0X21hcCBmIGwgPVxuICBsZXQgcmVjIGF1eCBmIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXYgYWNjXG4gICAgfCB4IDo6IGwgLT5cbiAgICAgICBsZXQgeHMgPSBmIHggaW5cbiAgICAgICBhdXggZiAocmV2X2FwcGVuZCB4cyBhY2MpIGxcbiAgaW4gYXV4IGYgW10gbFxuXG5sZXQgZm9sZF9sZWZ0X21hcCBmIGFjY3UgbCA9XG4gIGxldCByZWMgYXV4IGFjY3UgbF9hY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3UsIHJldiBsX2FjY3VcbiAgICB8IHggOjogbCAtPlxuICAgICAgICBsZXQgYWNjdSwgeCA9IGYgYWNjdSB4IGluXG4gICAgICAgIGF1eCBhY2N1ICh4IDo6IGxfYWNjdSkgbCBpblxuICBhdXggYWNjdSBbXSBsXG5cbmxldCBwYXJ0aXRpb24gcCBsID1cbiAgbGV0IHJlYyBwYXJ0IHllcyBubyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gKHJldiB5ZXMsIHJldiBubylcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gcGFydCAoeCA6OiB5ZXMpIG5vIGwgZWxzZSBwYXJ0IHllcyAoeCA6OiBubykgbCBpblxuICBwYXJ0IFtdIFtdIGxcblxubGV0IHBhcnRpdGlvbl9tYXAgcCBsID1cbiAgbGV0IHJlYyBwYXJ0IGxlZnQgcmlnaHQgPSBmdW5jdGlvblxuICB8IFtdIC0+IChyZXYgbGVmdCwgcmV2IHJpZ2h0KVxuICB8IHggOjogbCAtPlxuICAgICBiZWdpbiBtYXRjaCBwIHggd2l0aFxuICAgICAgIHwgRWl0aGVyLkxlZnQgdiAtPiBwYXJ0ICh2IDo6IGxlZnQpIHJpZ2h0IGxcbiAgICAgICB8IEVpdGhlci5SaWdodCB2IC0+IHBhcnQgbGVmdCAodiA6OiByaWdodCkgbFxuICAgICBlbmRcbiAgaW5cbiAgcGFydCBbXSBbXSBsXG5cbmxldCByZWMgc3BsaXQgPSBmdW5jdGlvblxuICAgIFtdIC0+IChbXSwgW10pXG4gIHwgKHgseSk6OmwgLT5cbiAgICAgIGxldCAocngsIHJ5KSA9IHNwbGl0IGwgaW4gKHg6OnJ4LCB5OjpyeSlcblxubGV0IHJlYyBjb21iaW5lIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiAoYTEsIGEyKSA6OiBjb21iaW5lIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5jb21iaW5lXCJcblxuKCoqIHNvcnRpbmcgKilcblxubGV0IHJlYyBtZXJnZSBjbXAgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBsMiAtPiBsMlxuICB8IGwxLCBbXSAtPiBsMVxuICB8IGgxIDo6IHQxLCBoMiA6OiB0MiAtPlxuICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgIHRoZW4gaDEgOjogbWVyZ2UgY21wIHQxIGwyXG4gICAgICBlbHNlIGgyIDo6IG1lcmdlIGNtcCBsMSB0MlxuXG5cbmxldCBzdGFibGVfc29ydCBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPD0gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPSBpZiBjbXAgeDEgeDIgPD0gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV0gaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGlmIGNtcCB4MSB4MiA8PSAwIHRoZW5cbiAgICAgICAgICAgIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzIDw9IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZV9yZXYgczEgczIgW10sIHRsKVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID0gaWYgY21wIHgxIHgyID4gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV0gaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGlmIGNtcCB4MSB4MiA+IDAgdGhlblxuICAgICAgICAgICAgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzID4gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHNvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlIHMxIHMyIFtdLCB0bClcbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2UgZnN0IChzb3J0IGxlbiBsKVxuXG5cbmxldCBzb3J0ID0gc3RhYmxlX3NvcnRcbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiBOb3RlOiBvbiBhIGxpc3Qgb2YgbGVuZ3RoIGJldHdlZW4gYWJvdXQgMTAwMDAwIChkZXBlbmRpbmcgb24gdGhlIG1pbm9yXG4gICBoZWFwIHNpemUgYW5kIHRoZSB0eXBlIG9mIHRoZSBsaXN0KSBhbmQgU3lzLm1heF9hcnJheV9zaXplLCBpdCBpc1xuICAgYWN0dWFsbHkgZmFzdGVyIHRvIHVzZSB0aGUgZm9sbG93aW5nLCBidXQgaXQgbWlnaHQgYWxzbyB1c2UgbW9yZSBtZW1vcnlcbiAgIGJlY2F1c2UgdGhlIGFyZ3VtZW50IGxpc3QgY2Fubm90IGJlIGRlYWxsb2NhdGVkIGluY3JlbWVudGFsbHkuXG5cbiAgIEFsc28sIHRoZXJlIHNlZW1zIHRvIGJlIGEgYnVnIGluIHRoaXMgY29kZSBvciBpbiB0aGVcbiAgIGltcGxlbWVudGF0aW9uIG9mIG9ial90cnVuY2F0ZS5cblxuZXh0ZXJuYWwgb2JqX3RydW5jYXRlIDogJ2EgYXJyYXkgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3RydW5jYXRlXCJcblxubGV0IGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYSA9XG4gIGxldCBsID0gQXJyYXkubGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGFjY3UgbiBwID1cbiAgICBpZiBwIDw9IDAgdGhlbiBhY2N1IGVsc2UgYmVnaW5cbiAgICAgIGlmIHAgPSBuIHRoZW4gYmVnaW5cbiAgICAgICAgb2JqX3RydW5jYXRlIGEgcDtcbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSAobi0xMDAwKSAocC0xKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSBuIChwLTEpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBbXSAobC0xMDAwKSBsXG5cblxubGV0IHN0YWJsZV9zb3J0IGNtcCBsID1cbiAgbGV0IGEgPSBBcnJheS5vZl9saXN0IGwgaW5cbiAgQXJyYXkuc3RhYmxlX3NvcnQgY21wIGE7XG4gIGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYVxuXG4qKVxuXG5cbigqKiBzb3J0aW5nICsgcmVtb3ZpbmcgZHVwbGljYXRlcyAqKVxuXG5sZXQgc29ydF91bmlxIGNtcCBsID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGxldCBjID0gY21wIGgxIGgyIGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gcmV2X21lcmdlIHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZV9yZXYgdDEgdDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIGlmIGMgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml0gZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSByZXZfc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlX3JldiBzMSBzMiBbXSwgdGwpXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml0gZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSBzb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZSBzMSBzMiBbXSwgdGwpXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIGZzdCAoc29ydCBsZW4gbClcblxuXG5sZXQgcmVjIGNvbXBhcmVfbGVuZ3RocyBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCBfIDo6IGwxLCBfIDo6IGwyIC0+IGNvbXBhcmVfbGVuZ3RocyBsMSBsMlxuOztcblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aF93aXRoIGwgbiA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgaWYgbiA9IDAgdGhlbiAwIGVsc2VcbiAgICAgIGlmIG4gPiAwIHRoZW4gLTEgZWxzZSAxXG4gIHwgXyA6OiBsIC0+XG4gICAgaWYgbiA8PSAwIHRoZW4gMSBlbHNlXG4gICAgICBjb21wYXJlX2xlbmd0aF93aXRoIGwgKG4tMSlcbjs7XG5cbigqKiB7MSBDb21wYXJpc29ufSAqKVxuXG4oKiBOb3RlOiB3ZSBhcmUgKm5vdCogc2hvcnRjdXR0aW5nIHRoZSBsaXN0IGJ5IHVzaW5nXG4gICBbTGlzdC5jb21wYXJlX2xlbmd0aHNdIGZpcnN0OyB0aGlzIG1heSBiZSBzbG93ZXIgb24gbG9uZyBsaXN0c1xuICAgaW1tZWRpYXRlbHkgc3RhcnQgd2l0aCBkaXN0aW5jdCBlbGVtZW50cy4gSXQgaXMgYWxzbyBpbmNvcnJlY3QgZm9yXG4gICBbY29tcGFyZV0gYmVsb3csIGFuZCBpdCBpcyBiZXR0ZXIgKHByaW5jaXBsZSBvZiBsZWFzdCBzdXJwcmlzZSkgdG9cbiAgIHVzZSB0aGUgc2FtZSBhcHByb2FjaCBmb3IgYm90aCBmdW5jdGlvbnMuICopXG5sZXQgcmVjIGVxdWFsIGVxIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gdHJ1ZVxuICB8IFtdLCBfOjpfIHwgXzo6XywgW10gLT4gZmFsc2VcbiAgfCBhMTo6bDEsIGEyOjpsMiAtPiBlcSBhMSBhMiAmJiBlcXVhbCBlcSBsMSBsMlxuXG5sZXQgcmVjIGNvbXBhcmUgY21wIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gMFxuICB8IFtdLCBfOjpfIC0+IC0xXG4gIHwgXzo6XywgW10gLT4gMVxuICB8IGExOjpsMSwgYTI6OmwyIC0+XG4gICAgbGV0IGMgPSBjbXAgYTEgYTIgaW5cbiAgICBpZiBjIDw+IDAgdGhlbiBjXG4gICAgZWxzZSBjb21wYXJlIGNtcCBsMSBsMlxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGwgPVxuICBsZXQgcmVjIGF1eCBsICgpID0gbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBTZXEuTmlsXG4gICAgfCB4IDo6IHRhaWwgLT4gU2VxLkNvbnMgKHgsIGF1eCB0YWlsKVxuICBpblxuICBhdXggbFxuXG5sZXQgb2Zfc2VxIHNlcSA9XG4gIGxldCByZWMgZGlyZWN0IGRlcHRoIHNlcSA6IF8gbGlzdCA9XG4gICAgaWYgZGVwdGg9MFxuICAgIHRoZW5cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIHNlcVxuICAgICAgfD4gcmV2ICgqIHRhaWxyZWMgKilcbiAgICBlbHNlIG1hdGNoIHNlcSgpIHdpdGhcbiAgICAgIHwgU2VxLk5pbCAtPiBbXVxuICAgICAgfCBTZXEuQ29ucyAoeCwgbmV4dCkgLT4geCA6OiBkaXJlY3QgKGRlcHRoLTEpIG5leHRcbiAgaW5cbiAgZGlyZWN0IDUwMCBzZXFcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICBTaW1vbiBDcnVhbmVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtTZXFdOiBmdW5jdGlvbmFsIGl0ZXJhdG9ycyAqKVxuXG50eXBlICsnYSBub2RlID1cbiAgfCBOaWxcbiAgfCBDb25zIG9mICdhICogJ2EgdFxuXG5hbmQgJ2EgdCA9IHVuaXQgLT4gJ2Egbm9kZVxuXG5sZXQgZW1wdHkgKCkgPSBOaWxcblxubGV0IHJldHVybiB4ICgpID0gQ29ucyAoeCwgZW1wdHkpXG5cbmxldCBjb25zIHggbmV4dCAoKSA9IENvbnMgKHgsIG5leHQpXG5cbmxldCByZWMgYXBwZW5kIHNlcTEgc2VxMiAoKSA9XG4gIG1hdGNoIHNlcTEoKSB3aXRoXG4gIHwgTmlsIC0+IHNlcTIoKVxuICB8IENvbnMgKHgsIG5leHQpIC0+IENvbnMgKHgsIGFwcGVuZCBuZXh0IHNlcTIpXG5cbmxldCByZWMgbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPiBDb25zIChmIHgsIG1hcCBmIG5leHQpXG5cbmxldCByZWMgZmlsdGVyX21hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwIGYgbmV4dCAoKVxuICAgICAgICB8IFNvbWUgeSAtPiBDb25zICh5LCBmaWx0ZXJfbWFwIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXIgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBpZiBmIHhcbiAgICAgIHRoZW4gQ29ucyAoeCwgZmlsdGVyIGYgbmV4dClcbiAgICAgIGVsc2UgZmlsdGVyIGYgbmV4dCAoKVxuXG5sZXQgcmVjIGNvbmNhdCBzZXEgKCkgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICBhcHBlbmQgeCAoY29uY2F0IG5leHQpICgpXG5cbmxldCByZWMgZmxhdF9tYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgIGFwcGVuZCAoZiB4KSAoZmxhdF9tYXAgZiBuZXh0KSAoKVxuXG5sZXQgY29uY2F0X21hcCA9IGZsYXRfbWFwXG5cbmxldCBmb2xkX2xlZnQgZiBhY2Mgc2VxID1cbiAgbGV0IHJlYyBhdXggZiBhY2Mgc2VxID0gbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IE5pbCAtPiBhY2NcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGxldCBhY2MgPSBmIGFjYyB4IGluXG4gICAgICAgIGF1eCBmIGFjYyBuZXh0XG4gIGluXG4gIGF1eCBmIGFjYyBzZXFcblxubGV0IGl0ZXIgZiBzZXEgPVxuICBsZXQgcmVjIGF1eCBzZXEgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgTmlsIC0+ICgpXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBmIHg7XG4gICAgICAgIGF1eCBuZXh0XG4gIGluXG4gIGF1eCBzZXFcblxubGV0IHJlYyB1bmZvbGQgZiB1ICgpID1cbiAgbWF0Y2ggZiB1IHdpdGhcbiAgfCBOb25lIC0+IE5pbFxuICB8IFNvbWUgKHgsIHUnKSAtPiBDb25zICh4LCB1bmZvbGQgZiB1JylcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAnYSB0ID0gJ2Egb3B0aW9uID0gTm9uZSB8IFNvbWUgb2YgJ2FcblxubGV0IG5vbmUgPSBOb25lXG5sZXQgc29tZSB2ID0gU29tZSB2XG5sZXQgdmFsdWUgbyB+ZGVmYXVsdCA9IG1hdGNoIG8gd2l0aCBTb21lIHYgLT4gdiB8IE5vbmUgLT4gZGVmYXVsdFxubGV0IGdldCA9IGZ1bmN0aW9uIFNvbWUgdiAtPiB2IHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIm9wdGlvbiBpcyBOb25lXCJcbmxldCBiaW5kIG8gZiA9IG1hdGNoIG8gd2l0aCBOb25lIC0+IE5vbmUgfCBTb21lIHYgLT4gZiB2XG5sZXQgam9pbiA9IGZ1bmN0aW9uIFNvbWUgbyAtPiBvIHwgTm9uZSAtPiBOb25lXG5sZXQgbWFwIGYgbyA9IG1hdGNoIG8gd2l0aCBOb25lIC0+IE5vbmUgfCBTb21lIHYgLT4gU29tZSAoZiB2KVxubGV0IGZvbGQgfm5vbmUgfnNvbWUgPSBmdW5jdGlvbiBTb21lIHYgLT4gc29tZSB2IHwgTm9uZSAtPiBub25lXG5sZXQgaXRlciBmID0gZnVuY3Rpb24gU29tZSB2IC0+IGYgdiB8IE5vbmUgLT4gKClcbmxldCBpc19ub25lID0gZnVuY3Rpb24gTm9uZSAtPiB0cnVlIHwgU29tZSBfIC0+IGZhbHNlXG5sZXQgaXNfc29tZSA9IGZ1bmN0aW9uIE5vbmUgLT4gZmFsc2UgfCBTb21lIF8gLT4gdHJ1ZVxuXG5sZXQgZXF1YWwgZXEgbzAgbzEgPSBtYXRjaCBvMCwgbzEgd2l0aFxufCBTb21lIHYwLCBTb21lIHYxIC0+IGVxIHYwIHYxXG58IE5vbmUsIE5vbmUgLT4gdHJ1ZVxufCBfIC0+IGZhbHNlXG5cbmxldCBjb21wYXJlIGNtcCBvMCBvMSA9IG1hdGNoIG8wLCBvMSB3aXRoXG58IFNvbWUgdjAsIFNvbWUgdjEgLT4gY21wIHYwIHYxXG58IE5vbmUsIE5vbmUgLT4gMFxufCBOb25lLCBTb21lIF8gLT4gLTFcbnwgU29tZSBfLCBOb25lIC0+IDFcblxubGV0IHRvX3Jlc3VsdCB+bm9uZSA9IGZ1bmN0aW9uIE5vbmUgLT4gRXJyb3Igbm9uZSB8IFNvbWUgdiAtPiBPayB2XG5sZXQgdG9fbGlzdCA9IGZ1bmN0aW9uIE5vbmUgLT4gW10gfCBTb21lIHYgLT4gW3ZdXG5sZXQgdG9fc2VxID0gZnVuY3Rpb24gTm9uZSAtPiBTZXEuZW1wdHkgfCBTb21lIHYgLT4gU2VxLnJldHVybiB2XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEdhYnJpZWwgU2NoZXJlciwgcHJvamV0IFBhcnNpZmFsLCBJTlJJQSBTYWNsYXkgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE5IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgKCdhLCAnYikgdCA9IExlZnQgb2YgJ2EgfCBSaWdodCBvZiAnYlxuXG5sZXQgbGVmdCB2ID0gTGVmdCB2XG5sZXQgcmlnaHQgdiA9IFJpZ2h0IHZcblxubGV0IGlzX2xlZnQgPSBmdW5jdGlvblxufCBMZWZ0IF8gLT4gdHJ1ZVxufCBSaWdodCBfIC0+IGZhbHNlXG5cbmxldCBpc19yaWdodCA9IGZ1bmN0aW9uXG58IExlZnQgXyAtPiBmYWxzZVxufCBSaWdodCBfIC0+IHRydWVcblxubGV0IGZpbmRfbGVmdCA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBTb21lIHZcbnwgUmlnaHQgXyAtPiBOb25lXG5cbmxldCBmaW5kX3JpZ2h0ID0gZnVuY3Rpb25cbnwgTGVmdCBfIC0+IE5vbmVcbnwgUmlnaHQgdiAtPiBTb21lIHZcblxubGV0IG1hcF9sZWZ0IGYgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gTGVmdCAoZiB2KVxufCBSaWdodCBfIGFzIGUgLT4gZVxuXG5sZXQgbWFwX3JpZ2h0IGYgPSBmdW5jdGlvblxufCBMZWZ0IF8gYXMgZSAtPiBlXG58IFJpZ2h0IHYgLT4gUmlnaHQgKGYgdilcblxubGV0IG1hcCB+bGVmdCB+cmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gTGVmdCAobGVmdCB2KVxufCBSaWdodCB2IC0+IFJpZ2h0IChyaWdodCB2KVxuXG5sZXQgZm9sZCB+bGVmdCB+cmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gbGVmdCB2XG58IFJpZ2h0IHYgLT4gcmlnaHQgdlxuXG5sZXQgaXRlciA9IGZvbGRcblxubGV0IGZvcl9hbGwgPSBmb2xkXG5cbmxldCBlcXVhbCB+bGVmdCB+cmlnaHQgZTEgZTIgPSBtYXRjaCBlMSwgZTIgd2l0aFxufCBMZWZ0IHYxLCBMZWZ0IHYyIC0+IGxlZnQgdjEgdjJcbnwgUmlnaHQgdjEsIFJpZ2h0IHYyIC0+IHJpZ2h0IHYxIHYyXG58IExlZnQgXywgUmlnaHQgXyB8IFJpZ2h0IF8sIExlZnQgXyAtPiBmYWxzZVxuXG5sZXQgY29tcGFyZSB+bGVmdCB+cmlnaHQgZTEgZTIgPSBtYXRjaCBlMSwgZTIgd2l0aFxufCBMZWZ0IHYxLCBMZWZ0IHYyIC0+IGxlZnQgdjEgdjJcbnwgUmlnaHQgdjEsIFJpZ2h0IHYyIC0+IHJpZ2h0IHYxIHYyXG58IExlZnQgXywgUmlnaHQgXyAtPiAoLTEpXG58IFJpZ2h0IF8sIExlZnQgXyAtPiAxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2VcblxubGV0IG9rIHYgPSBPayB2XG5sZXQgZXJyb3IgZSA9IEVycm9yIGVcbmxldCB2YWx1ZSByIH5kZWZhdWx0ID0gbWF0Y2ggciB3aXRoIE9rIHYgLT4gdiB8IEVycm9yIF8gLT4gZGVmYXVsdFxubGV0IGdldF9vayA9IGZ1bmN0aW9uIE9rIHYgLT4gdiB8IEVycm9yIF8gLT4gaW52YWxpZF9hcmcgXCJyZXN1bHQgaXMgRXJyb3IgX1wiXG5sZXQgZ2V0X2Vycm9yID0gZnVuY3Rpb24gRXJyb3IgZSAtPiBlIHwgT2sgXyAtPiBpbnZhbGlkX2FyZyBcInJlc3VsdCBpcyBPayBfXCJcbmxldCBiaW5kIHIgZiA9IG1hdGNoIHIgd2l0aCBPayB2IC0+IGYgdiB8IEVycm9yIF8gYXMgZSAtPiBlXG5sZXQgam9pbiA9IGZ1bmN0aW9uIE9rIHIgLT4gciB8IEVycm9yIF8gYXMgZSAtPiBlXG5sZXQgbWFwIGYgPSBmdW5jdGlvbiBPayB2IC0+IE9rIChmIHYpIHwgRXJyb3IgXyBhcyBlIC0+IGVcbmxldCBtYXBfZXJyb3IgZiA9IGZ1bmN0aW9uIEVycm9yIGUgLT4gRXJyb3IgKGYgZSkgfCBPayBfIGFzIHYgLT4gdlxubGV0IGZvbGQgfm9rIH5lcnJvciA9IGZ1bmN0aW9uIE9rIHYgLT4gb2sgdiB8IEVycm9yIGUgLT4gZXJyb3IgZVxubGV0IGl0ZXIgZiA9IGZ1bmN0aW9uIE9rIHYgLT4gZiB2IHwgRXJyb3IgXyAtPiAoKVxubGV0IGl0ZXJfZXJyb3IgZiA9IGZ1bmN0aW9uIEVycm9yIGUgLT4gZiBlIHwgT2sgXyAtPiAoKVxubGV0IGlzX29rID0gZnVuY3Rpb24gT2sgXyAtPiB0cnVlIHwgRXJyb3IgXyAtPiBmYWxzZVxubGV0IGlzX2Vycm9yID0gZnVuY3Rpb24gRXJyb3IgXyAtPiB0cnVlIHwgT2sgXyAtPiBmYWxzZVxuXG5sZXQgZXF1YWwgfm9rIH5lcnJvciByMCByMSA9IG1hdGNoIHIwLCByMSB3aXRoXG58IE9rIHYwLCBPayB2MSAtPiBvayB2MCB2MVxufCBFcnJvciBlMCwgRXJyb3IgZTEgLT4gZXJyb3IgZTAgZTFcbnwgXywgXyAtPiBmYWxzZVxuXG5sZXQgY29tcGFyZSB+b2sgfmVycm9yIHIwIHIxID0gbWF0Y2ggcjAsIHIxIHdpdGhcbnwgT2sgdjAsIE9rIHYxIC0+IG9rIHYwIHYxXG58IEVycm9yIGUwLCBFcnJvciBlMSAtPiBlcnJvciBlMCBlMVxufCBPayBfLCBFcnJvciBfIC0+IC0xXG58IEVycm9yIF8sIE9rIF8gLT4gMVxuXG5sZXQgdG9fb3B0aW9uID0gZnVuY3Rpb24gT2sgdiAtPiBTb21lIHYgfCBFcnJvciBfIC0+IE5vbmVcbmxldCB0b19saXN0ID0gZnVuY3Rpb24gT2sgdiAtPiBbdl0gfCBFcnJvciBfIC0+IFtdXG5sZXQgdG9fc2VxID0gZnVuY3Rpb24gT2sgdiAtPiBTZXEucmV0dXJuIHYgfCBFcnJvciBfIC0+IFNlcS5lbXB0eVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSBib29sID0gZmFsc2UgfCB0cnVlXG5cbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmxldCBlcXVhbCA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gKCA9IClcbmxldCBjb21wYXJlIDogYm9vbCAtPiBib29sIC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5leHRlcm5hbCB0b19pbnQgOiBib29sIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmxldCB0b19mbG9hdCA9IGZ1bmN0aW9uIGZhbHNlIC0+IDAuIHwgdHJ1ZSAtPiAxLlxuXG4oKlxubGV0IG9mX3N0cmluZyA9IGZ1bmN0aW9uXG58IFwiZmFsc2VcIiAtPiBTb21lIGZhbHNlXG58IFwidHJ1ZVwiIC0+IFNvbWUgdHJ1ZVxufCBfIC0+IE5vbmVcbiopXG5cbmxldCB0b19zdHJpbmcgPSBmdW5jdGlvbiBmYWxzZSAtPiBcImZhbHNlXCIgfCB0cnVlIC0+IFwidHJ1ZVwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENoYXJhY3RlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGNvZGU6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdW5zYWZlX2NocjogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBjaHIgbiA9XG4gIGlmIG4gPCAwIHx8IG4gPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyBcIkNoYXIuY2hyXCIgZWxzZSB1bnNhZmVfY2hyIG5cblxuZXh0ZXJuYWwgYnl0ZXNfY3JlYXRlOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmxldCBlc2NhcGVkID0gZnVuY3Rpb25cbiAgfCAnXFwnJyAtPiBcIlxcXFwnXCJcbiAgfCAnXFxcXCcgLT4gXCJcXFxcXFxcXFwiXG4gIHwgJ1xcbicgLT4gXCJcXFxcblwiXG4gIHwgJ1xcdCcgLT4gXCJcXFxcdFwiXG4gIHwgJ1xccicgLT4gXCJcXFxcclwiXG4gIHwgJ1xcYicgLT4gXCJcXFxcYlwiXG4gIHwgJyAnIC4uICd+JyBhcyBjIC0+XG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSAxIGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCBjO1xuICAgICAgdW5zYWZlX3RvX3N0cmluZyBzXG4gIHwgYyAtPlxuICAgICAgbGV0IG4gPSBjb2RlIGMgaW5cbiAgICAgIGxldCBzID0gYnl0ZXNfY3JlYXRlIDQgaW5cbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAwICdcXFxcJztcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAxICh1bnNhZmVfY2hyICg0OCArIG4gLyAxMDApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAyICh1bnNhZmVfY2hyICg0OCArIChuIC8gMTApIG1vZCAxMCkpO1xuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDMgKHVuc2FmZV9jaHIgKDQ4ICsgbiBtb2QgMTApKTtcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuXG5sZXQgbG93ZXJjYXNlID0gZnVuY3Rpb25cbiAgfCAnQScgLi4gJ1onXG4gIHwgJ1xcMTkyJyAuLiAnXFwyMTQnXG4gIHwgJ1xcMjE2JyAuLiAnXFwyMjInIGFzIGMgLT5cbiAgICB1bnNhZmVfY2hyKGNvZGUgYyArIDMyKVxuICB8IGMgLT4gY1xuXG5sZXQgdXBwZXJjYXNlID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onXG4gIHwgJ1xcMjI0JyAuLiAnXFwyNDYnXG4gIHwgJ1xcMjQ4JyAuLiAnXFwyNTQnIGFzIGMgLT5cbiAgICB1bnNhZmVfY2hyKGNvZGUgYyAtIDMyKVxuICB8IGMgLT4gY1xuXG5sZXQgbG93ZXJjYXNlX2FzY2lpID0gZnVuY3Rpb25cbiAgfCAnQScgLi4gJ1onIGFzIGMgLT4gdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgfCBjIC0+IGNcblxubGV0IHVwcGVyY2FzZV9hc2NpaSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6JyBhcyBjIC0+IHVuc2FmZV9jaHIoY29kZSBjIC0gMzIpXG4gIHwgYyAtPiBjXG5cbnR5cGUgdCA9IGNoYXJcblxubGV0IGNvbXBhcmUgYzEgYzIgPSBjb2RlIGMxIC0gY29kZSBjMlxubGV0IGVxdWFsIChjMTogdCkgKGMyOiB0KSA9IGNvbXBhcmUgYzEgYzIgPSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbTmF0aXZlaW50XTogcHJvY2Vzc29yLW5hdGl2ZSBpbnRlZ2VycyAqKVxuXG5leHRlcm5hbCBuZWc6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbmVnXCJcbmV4dGVybmFsIGFkZDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYWRkXCJcbmV4dGVybmFsIHN1YjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfc3ViXCJcbmV4dGVybmFsIG11bDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbXVsXCJcbmV4dGVybmFsIGRpdjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfZGl2XCJcbmV4dGVybmFsIHJlbTogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYW5kXCJcbmV4dGVybmFsIGxvZ29yOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9vclwiXG5leHRlcm5hbCBsb2d4b3I6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0OiBuYXRpdmVpbnQgLT4gaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQ6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FzclwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsOiBuYXRpdmVpbnQgLT4gaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50OiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29mX2ludFwiXG5leHRlcm5hbCB0b19pbnQ6IG5hdGl2ZWludCAtPiBpbnQgPSBcIiVuYXRpdmVpbnRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gbmF0aXZlaW50XG4gID0gXCJjYW1sX25hdGl2ZWludF9vZl9mbG9hdFwiIFwiY2FtbF9uYXRpdmVpbnRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IG5hdGl2ZWludCAtPiBmbG9hdFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfdG9fZmxvYXRcIiBcImNhbWxfbmF0aXZlaW50X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzI6IGludDMyIC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9vZl9pbnQzMlwiXG5leHRlcm5hbCB0b19pbnQzMjogbmF0aXZlaW50IC0+IGludDMyID0gXCIlbmF0aXZlaW50X3RvX2ludDMyXCJcblxubGV0IHplcm8gPSAwblxubGV0IG9uZSA9IDFuXG5sZXQgbWludXNfb25lID0gLTFuXG5sZXQgc3VjYyBuID0gYWRkIG4gMW5cbmxldCBwcmVkIG4gPSBzdWIgbiAxblxubGV0IGFicyBuID0gaWYgbiA+PSAwbiB0aGVuIG4gZWxzZSBuZWcgblxubGV0IHNpemUgPSBTeXMud29yZF9zaXplXG5sZXQgbWluX2ludCA9IHNoaWZ0X2xlZnQgMW4gKHNpemUgLSAxKVxubGV0IG1heF9pbnQgPSBzdWIgbWluX2ludCAxblxubGV0IGxvZ25vdCBuID0gbG9neG9yIG4gKC0xbilcblxubGV0IHVuc2lnbmVkX3RvX2ludCA9XG4gIGxldCBtYXhfaW50ID0gb2ZfaW50IFN0ZGxpYi5tYXhfaW50IGluXG4gIGZ1biBuIC0+XG4gICAgaWYgY29tcGFyZSB6ZXJvIG4gPD0gMCAmJiBjb21wYXJlIG4gbWF4X2ludCA8PSAwIHRoZW5cbiAgICAgIFNvbWUgKHRvX2ludCBuKVxuICAgIGVsc2VcbiAgICAgIE5vbmVcblxuZXh0ZXJuYWwgZm9ybWF0IDogc3RyaW5nIC0+IG5hdGl2ZWludCAtPiBzdHJpbmcgPSBcImNhbWxfbmF0aXZlaW50X2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nOiBzdHJpbmcgLT4gbmF0aXZlaW50ID0gXCJjYW1sX25hdGl2ZWludF9vZl9zdHJpbmdcIlxuXG5sZXQgb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogZXhwb3NlIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlIGRpcmVjdGx5LiAqKVxuICB0cnkgU29tZSAob2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxudHlwZSB0ID0gbmF0aXZlaW50XG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG5cbmxldCB1bnNpZ25lZF9jb21wYXJlIG4gbSA9XG4gIGNvbXBhcmUgKHN1YiBuIG1pbl9pbnQpIChzdWIgbSBtaW5faW50KVxuXG5sZXQgbWluIHggeSA6IHQgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgOiB0ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcblxuKCogVW5zaWduZWQgZGl2aXNpb24gZnJvbSBzaWduZWQgZGl2aXNpb24gb2YgdGhlIHNhbWVcbiAgIGJpdG5lc3MuIFNlZSBXYXJyZW4gSnIuLCBIZW5yeSBTLiAoMjAxMykuIEhhY2tlcidzIERlbGlnaHQgKDIgZWQuKSwgU2VjIDktMy5cbiopXG5sZXQgdW5zaWduZWRfZGl2IG4gZCA9XG4gIGlmIGQgPCB6ZXJvIHRoZW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIG4gZCA8IDAgdGhlbiB6ZXJvIGVsc2Ugb25lXG4gIGVsc2VcbiAgICBsZXQgcSA9IHNoaWZ0X2xlZnQgKGRpdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBuIDEpIGQpIDEgaW5cbiAgICBsZXQgciA9IHN1YiBuIChtdWwgcSBkKSBpblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgciBkID49IDAgdGhlbiBzdWNjIHEgZWxzZSBxXG5cbmxldCB1bnNpZ25lZF9yZW0gbiBkID1cbiAgc3ViIG4gKG11bCAodW5zaWduZWRfZGl2IG4gZCkgZClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gaW50XG5cbmxldCB6ZXJvID0gMFxubGV0IG9uZSA9IDFcbmxldCBtaW51c19vbmUgPSAtMVxuZXh0ZXJuYWwgbmVnIDogaW50IC0+IGludCA9IFwiJW5lZ2ludFwiXG5leHRlcm5hbCBhZGQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCBzdWIgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXN1YmludFwiXG5leHRlcm5hbCBtdWwgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW11bGludFwiXG5leHRlcm5hbCBkaXYgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCByZW0gOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW1vZGludFwiXG5leHRlcm5hbCBzdWNjIDogaW50IC0+IGludCA9IFwiJXN1Y2NpbnRcIlxuZXh0ZXJuYWwgcHJlZCA6IGludCAtPiBpbnQgPSBcIiVwcmVkaW50XCJcbmxldCBhYnMgeCA9IGlmIHggPj0gMCB0aGVuIHggZWxzZSAteFxubGV0IG1heF9pbnQgPSAoLTEpIGxzciAxXG5sZXQgbWluX2ludCA9IG1heF9pbnQgKyAxXG5leHRlcm5hbCBsb2dhbmQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFuZGludFwiXG5leHRlcm5hbCBsb2dvciA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlb3JpbnRcIlxuZXh0ZXJuYWwgbG9neG9yIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxubGV0IGxvZ25vdCB4ID0gbG9neG9yIHggKC0xKVxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNsaW50XCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhc3JpbnRcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNyaW50XCJcbmxldCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGludCAtPiBpbnQgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmxldCBtaW4geCB5IDogdCA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA6IHQgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5cbigqXG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcbmxldCBvZl9zdHJpbmcgcyA9IHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHMpIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcbiopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmxldCB0b19zdHJpbmcgeCA9IGZvcm1hdF9pbnQgXCIlZFwiIHhcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zICopXG5cbigqIFdBUk5JTkc6IFNvbWUgZnVuY3Rpb25zIGluIHRoaXMgZmlsZSBhcmUgZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgZm9yXG4gICBlZmZpY2llbmN5IHJlYXNvbnMuIFdoZW4geW91IG1vZGlmeSB0aGUgb25lIGluIHRoaXMgZmlsZSB5b3UgbmVlZCB0b1xuICAgbW9kaWZ5IGl0cyBkdXBsaWNhdGUgaW4gc3RyaW5nLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBieXRlcyAtPiBpbnQgPSBcIiVieXRlc19sZW5ndGhcIlxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGdldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfZmlsbF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfdG9fc3RyaW5nIDogYnl0ZXMgLT4gc3RyaW5nID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcbmV4dGVybmFsIHVuc2FmZV9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gYnl0ZXMgPSBcIiVieXRlc19vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IGJ5dGVzIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2JsaXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cblxubGV0IG1ha2UgbiBjID1cbiAgbGV0IHMgPSBjcmVhdGUgbiBpblxuICB1bnNhZmVfZmlsbCBzIDAgbiBjO1xuICBzXG5cbmxldCBpbml0IG4gZiA9XG4gIGxldCBzID0gY3JlYXRlIG4gaW5cbiAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgdW5zYWZlX3NldCBzIGkgKGYgaSlcbiAgZG9uZTtcbiAgc1xuXG5sZXQgZW1wdHkgPSBjcmVhdGUgMFxuXG5sZXQgY29weSBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCByID0gY3JlYXRlIGxlbiBpblxuICB1bnNhZmVfYmxpdCBzIDAgciAwIGxlbjtcbiAgclxuXG5sZXQgdG9fc3RyaW5nIGIgPSB1bnNhZmVfdG9fc3RyaW5nIChjb3B5IGIpXG5sZXQgb2Zfc3RyaW5nIHMgPSBjb3B5ICh1bnNhZmVfb2Zfc3RyaW5nIHMpXG5cbmxldCBzdWIgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuc3ViIC8gQnl0ZXMuc3ViXCJcbiAgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGxlbiBpblxuICAgIHVuc2FmZV9ibGl0IHMgb2ZzIHIgMCBsZW47XG4gICAgclxuICBlbmRcblxubGV0IHN1Yl9zdHJpbmcgYiBvZnMgbGVuID0gdW5zYWZlX3RvX3N0cmluZyAoc3ViIGIgb2ZzIGxlbilcblxuKCogYWRkaXRpb24gd2l0aCBhbiBvdmVyZmxvdyBjaGVjayAqKVxubGV0ICgrKykgYSBiID1cbiAgbGV0IGMgPSBhICsgYiBpblxuICBtYXRjaCBhIDwgMCwgYiA8IDAsIGMgPCAwIHdpdGhcbiAgfCB0cnVlICwgdHJ1ZSAsIGZhbHNlXG4gIHwgZmFsc2UsIGZhbHNlLCB0cnVlICAtPiBpbnZhbGlkX2FyZyBcIkJ5dGVzLmV4dGVuZFwiICgqIG92ZXJmbG93ICopXG4gIHwgXyAtPiBjXG5cbmxldCBleHRlbmQgcyBsZWZ0IHJpZ2h0ID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzICsrIGxlZnQgKysgcmlnaHQgaW5cbiAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gIGxldCAoc3Jjb2ZmLCBkc3RvZmYpID0gaWYgbGVmdCA8IDAgdGhlbiAtbGVmdCwgMCBlbHNlIDAsIGxlZnQgaW5cbiAgbGV0IGNweWxlbiA9IEludC5taW4gKGxlbmd0aCBzIC0gc3Jjb2ZmKSAobGVuIC0gZHN0b2ZmKSBpblxuICBpZiBjcHlsZW4gPiAwIHRoZW4gdW5zYWZlX2JsaXQgcyBzcmNvZmYgciBkc3RvZmYgY3B5bGVuO1xuICByXG5cbmxldCBmaWxsIHMgb2ZzIGxlbiBjID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuZmlsbCAvIEJ5dGVzLmZpbGxcIlxuICBlbHNlIHVuc2FmZV9maWxsIHMgb2ZzIGxlbiBjXG5cbmxldCBibGl0IHMxIG9mczEgczIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggczEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIHMyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCeXRlcy5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBzMSBvZnMxIHMyIG9mczIgbGVuXG5cbmxldCBibGl0X3N0cmluZyBzMSBvZnMxIHMyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gc3RyaW5nX2xlbmd0aCBzMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggczIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5ibGl0IC8gQnl0ZXMuYmxpdF9zdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9ibGl0X3N0cmluZyBzMSBvZnMxIHMyIG9mczIgbGVuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaXRlciBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYodW5zYWZlX2dldCBhIGkpIGRvbmVcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJCeXRlcy5jb25jYXRcIlxuXG5sZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyBzZXBsZW4gPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY1xuICB8IGhkIDo6IFtdIC0+IGxlbmd0aCBoZCArIGFjY1xuICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIHNlcGxlbiArIGFjYykgYWNjKSBzZXBsZW4gdGxcblxubGV0IHJlYyB1bnNhZmVfYmxpdHMgZHN0IHBvcyBzZXAgc2VwbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBkc3RcbiAgfCBoZCA6OiBbXSAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTsgZHN0XG4gIHwgaGQgOjogdGwgLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7XG4gICAgdW5zYWZlX2JsaXQgc2VwIDAgZHN0IChwb3MgKyBsZW5ndGggaGQpIHNlcGxlbjtcbiAgICB1bnNhZmVfYmxpdHMgZHN0IChwb3MgKyBsZW5ndGggaGQgKyBzZXBsZW4pIHNlcCBzZXBsZW4gdGxcblxubGV0IGNvbmNhdCBzZXAgPSBmdW5jdGlvblxuICAgIFtdIC0+IGVtcHR5XG4gIHwgbCAtPiBsZXQgc2VwbGVuID0gbGVuZ3RoIHNlcCBpblxuICAgICAgICAgIHVuc2FmZV9ibGl0c1xuICAgICAgICAgICAgKGNyZWF0ZSAoc3VtX2xlbmd0aHMgMCBzZXBsZW4gbCkpXG4gICAgICAgICAgICAwIHNlcCBzZXBsZW4gbFxuXG5sZXQgY2F0IHMxIHMyID1cbiAgbGV0IGwxID0gbGVuZ3RoIHMxIGluXG4gIGxldCBsMiA9IGxlbmd0aCBzMiBpblxuICBsZXQgciA9IGNyZWF0ZSAobDEgKyBsMikgaW5cbiAgdW5zYWZlX2JsaXQgczEgMCByIDAgbDE7XG4gIHVuc2FmZV9ibGl0IHMyIDAgciBsMSBsMjtcbiAgclxuXG5cbmV4dGVybmFsIGNoYXJfY29kZTogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBjaGFyX2NocjogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19zcGFjZSA9IGZ1bmN0aW9uXG4gIHwgJyAnIHwgJ1xcMDEyJyB8ICdcXG4nIHwgJ1xccicgfCAnXFx0JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgdHJpbSBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBsZW4gJiYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAhaSkgZG9cbiAgICBpbmNyIGlcbiAgZG9uZTtcbiAgbGV0IGogPSByZWYgKGxlbiAtIDEpIGluXG4gIHdoaWxlICFqID49ICFpICYmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgIWopIGRvXG4gICAgZGVjciBqXG4gIGRvbmU7XG4gIGlmICFqID49ICFpIHRoZW5cbiAgICBzdWIgcyAhaSAoIWogLSAhaSArIDEpXG4gIGVsc2VcbiAgICBlbXB0eVxuXG5sZXQgZXNjYXBlZCBzID1cbiAgbGV0IG4gPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgbiA6PSAhbiArXG4gICAgICAobWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgIHwgJ1xcXCInIHwgJ1xcXFwnIHwgJ1xcbicgfCAnXFx0JyB8ICdcXHInIHwgJ1xcYicgLT4gMlxuICAgICAgIHwgJyAnIC4uICd+JyAtPiAxXG4gICAgICAgfCBfIC0+IDQpXG4gIGRvbmU7XG4gIGlmICFuID0gbGVuZ3RoIHMgdGhlbiBjb3B5IHMgZWxzZSBiZWdpblxuICAgIGxldCBzJyA9IGNyZWF0ZSAhbiBpblxuICAgIG4gOj0gMDtcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgICBiZWdpbiBtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICgnXFxcIicgfCAnXFxcXCcpIGFzIGMgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICduJ1xuICAgICAgfCAnXFx0JyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ3QnXG4gICAgICB8ICdcXHInIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAncidcbiAgICAgIHwgJ1xcYicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICdiJ1xuICAgICAgfCAoJyAnIC4uICd+JykgYXMgYyAtPiB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgYyAtPlxuICAgICAgICAgIGxldCBhID0gY2hhcl9jb2RlIGMgaW5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSAvIDEwMCkpO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyAoYSAvIDEwKSBtb2QgMTApKTtcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSBtb2QgMTApKTtcbiAgICAgIGVuZDtcbiAgICAgIGluY3IgblxuICAgIGRvbmU7XG4gICAgcydcbiAgZW5kXG5cbmxldCBtYXAgZiBzID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBsID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG8gdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgcyBpKSkgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgbWFwaSBmIHMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGwgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IHMgaSkpIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmU7XG4gICFyXG5cbmxldCBmb2xkX3JpZ2h0IGYgYSB4ID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IGxlbmd0aCBhIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAodW5zYWZlX2dldCBhIGkpICFyXG4gIGRvbmU7XG4gICFyXG5cbmxldCBleGlzdHMgcCBzID1cbiAgbGV0IG4gPSBsZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBzIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwgcCBzID1cbiAgbGV0IG4gPSBsZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IHMgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBzID0gbWFwIENoYXIudXBwZXJjYXNlX2FzY2lpIHNcbmxldCBsb3dlcmNhc2VfYXNjaWkgcyA9IG1hcCBDaGFyLmxvd2VyY2FzZV9hc2NpaSBzXG5cbmxldCBhcHBseTEgZiBzID1cbiAgaWYgbGVuZ3RoIHMgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjb3B5IHMgaW5cbiAgICB1bnNhZmVfc2V0IHIgMCAoZih1bnNhZmVfZ2V0IHMgMCkpO1xuICAgIHJcbiAgZW5kXG5cbmxldCBjYXBpdGFsaXplX2FzY2lpIHMgPSBhcHBseTEgQ2hhci51cHBlcmNhc2VfYXNjaWkgc1xubGV0IHVuY2FwaXRhbGl6ZV9hc2NpaSBzID0gYXBwbHkxIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBzdGFydHNfd2l0aCB+cHJlZml4IHMgPVxuICBsZXQgbGVuX3MgPSBsZW5ndGggc1xuICBhbmQgbGVuX3ByZSA9IGxlbmd0aCBwcmVmaXggaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA9IGxlbl9wcmUgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiB1bnNhZmVfZ2V0IHMgaSA8PiB1bnNhZmVfZ2V0IHByZWZpeCBpIHRoZW4gZmFsc2VcbiAgICBlbHNlIGF1eCAoaSArIDEpXG4gIGluIGxlbl9zID49IGxlbl9wcmUgJiYgYXV4IDBcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBlbmRzX3dpdGggfnN1ZmZpeCBzID1cbiAgbGV0IGxlbl9zID0gbGVuZ3RoIHNcbiAgYW5kIGxlbl9zdWYgPSBsZW5ndGggc3VmZml4IGluXG4gIGxldCBkaWZmID0gbGVuX3MgLSBsZW5fc3VmIGluXG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIGkgPSBsZW5fc3VmIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgdW5zYWZlX2dldCBzIChkaWZmICsgaSkgPD4gdW5zYWZlX2dldCBzdWZmaXggaSB0aGVuIGZhbHNlXG4gICAgZWxzZSBhdXggKGkgKyAxKVxuICBpbiBkaWZmID49IDAgJiYgYXV4IDBcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgaW5kZXhfcmVjIHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIGluZGV4X3JlYyBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleCBzIGMgPSBpbmRleF9yZWMgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWNfb3B0IHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIGluZGV4X3JlY19vcHQgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfb3B0IHMgYyA9IGluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbSAvIEJ5dGVzLmluZGV4X2Zyb21cIiBlbHNlXG4gIGluZGV4X3JlYyBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX29wdCAvIEJ5dGVzLmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIGluZGV4X3JlY19vcHQgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjIHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgcmluZGV4X3JlYyBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleCBzIGMgPSByaW5kZXhfcmVjIHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9mcm9tIHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tIC8gQnl0ZXMucmluZGV4X2Zyb21cIlxuICBlbHNlXG4gICAgcmluZGV4X3JlYyBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIHJpbmRleF9yZWNfb3B0IHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X29wdCBzIGMgPSByaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMucmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWNfb3B0IHMgaSBjXG5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBjb250YWluc19mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29udGFpbnNfZnJvbSAvIEJ5dGVzLmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAoaW5kZXhfcmVjIHMgbCBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBjb250YWlucyBzIGMgPSBjb250YWluc19mcm9tIHMgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgMCB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yY29udGFpbnNfZnJvbSAvIEJ5dGVzLnJjb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKHJpbmRleF9yZWMgcyBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cblxudHlwZSB0ID0gYnl0ZXNcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxuZXh0ZXJuYWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbCA9IFwiY2FtbF9ieXRlc19lcXVhbFwiIFtAQG5vYWxsb2NdXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgc3BsaXRfb25fY2hhciBzZXAgcyA9XG4gIGxldCByID0gcmVmIFtdIGluXG4gIGxldCBqID0gcmVmIChsZW5ndGggcykgaW5cbiAgZm9yIGkgPSBsZW5ndGggcyAtIDEgZG93bnRvIDAgZG9cbiAgICBpZiB1bnNhZmVfZ2V0IHMgaSA9IHNlcCB0aGVuIGJlZ2luXG4gICAgICByIDo9IHN1YiBzIChpICsgMSkgKCFqIC0gaSAtIDEpIDo6ICFyO1xuICAgICAgaiA6PSBpXG4gICAgZW5kXG4gIGRvbmU7XG4gIHN1YiBzIDAgIWogOjogIXJcblxuKCogRGVwcmVjYXRlZCBmdW5jdGlvbnMgaW1wbGVtZW50ZWQgdmlhIG90aGVyIGRlcHJlY2F0ZWQgZnVuY3Rpb25zICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5sZXQgdXBwZXJjYXNlIHMgPSBtYXAgQ2hhci51cHBlcmNhc2Ugc1xubGV0IGxvd2VyY2FzZSBzID0gbWFwIENoYXIubG93ZXJjYXNlIHNcblxubGV0IGNhcGl0YWxpemUgcyA9IGFwcGx5MSBDaGFyLnVwcGVyY2FzZSBzXG5sZXQgdW5jYXBpdGFsaXplIHMgPSBhcHBseTEgQ2hhci5sb3dlcmNhc2Ugc1xuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpID0gbGVuZ3RoIHMgdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBnZXQgcyBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBzID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA9IGxlbmd0aCBzIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gZ2V0IHMgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBuID0gcmVmIDAgaW5cbiAgbGV0IGJ1ZiA9IHJlZiAobWFrZSAyNTYgJ1xcMDAwJykgaW5cbiAgbGV0IHJlc2l6ZSAoKSA9XG4gICAgKCogcmVzaXplICopXG4gICAgbGV0IG5ld19sZW4gPSBJbnQubWluICgyICogbGVuZ3RoICFidWYpIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBpblxuICAgIGlmIGxlbmd0aCAhYnVmID0gbmV3X2xlbiB0aGVuIGZhaWx3aXRoIFwiQnl0ZXMub2Zfc2VxOiBjYW5ub3QgZ3JvdyBieXRlc1wiO1xuICAgIGxldCBuZXdfYnVmID0gbWFrZSBuZXdfbGVuICdcXDAwMCcgaW5cbiAgICBibGl0ICFidWYgMCBuZXdfYnVmIDAgIW47XG4gICAgYnVmIDo9IG5ld19idWZcbiAgaW5cbiAgU2VxLml0ZXJcbiAgICAoZnVuIGMgLT5cbiAgICAgICBpZiAhbiA9IGxlbmd0aCAhYnVmIHRoZW4gcmVzaXplKCk7XG4gICAgICAgc2V0ICFidWYgIW4gYztcbiAgICAgICBpbmNyIG4pXG4gICAgaTtcbiAgc3ViICFidWYgMCAhblxuXG4oKiogezYgQmluYXJ5IGVuY29kaW5nL2RlY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG4oKiBUaGUgZ2V0XyBmdW5jdGlvbnMgYXJlIGFsbCBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxuXG5leHRlcm5hbCBnZXRfdWludDggOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCIlYnl0ZXNfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgZ2V0X3VpbnQxNl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcIiVjYW1sX2J5dGVzX2dldDE2XCJcbmV4dGVybmFsIGdldF9pbnQzMl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQzMiA9IFwiJWNhbWxfYnl0ZXNfZ2V0MzJcIlxuZXh0ZXJuYWwgZ2V0X2ludDY0X25lIDogYnl0ZXMgLT4gaW50IC0+IGludDY0ID0gXCIlY2FtbF9ieXRlc19nZXQ2NFwiXG5leHRlcm5hbCBzZXRfaW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbmV4dGVybmFsIHNldF9pbnQxNl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MTZcIlxuZXh0ZXJuYWwgc2V0X2ludDMyX25lIDogYnl0ZXMgLT4gaW50IC0+IGludDMyIC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDMyXCJcbmV4dGVybmFsIHNldF9pbnQ2NF9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQ2NFwiXG5leHRlcm5hbCBzd2FwMTYgOiBpbnQgLT4gaW50ID0gXCIlYnN3YXAxNlwiXG5leHRlcm5hbCBzd2FwMzIgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWJzd2FwX2ludDMyXCJcbmV4dGVybmFsIHN3YXA2NCA6IGludDY0IC0+IGludDY0ID0gXCIlYnN3YXBfaW50NjRcIlxuXG5sZXQgZ2V0X2ludDggYiBpID1cbiAgKChnZXRfdWludDggYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDgpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDgpXG5cbmxldCBnZXRfdWludDE2X2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDE2IChnZXRfdWludDE2X25lIGIgaSlcbiAgZWxzZSBnZXRfdWludDE2X25lIGIgaVxuXG5sZXQgZ2V0X3VpbnQxNl9iZSBiIGkgPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgKGdldF91aW50MTZfbmUgYiBpKVxuICBlbHNlIGdldF91aW50MTZfbmUgYiBpXG5cbmxldCBnZXRfaW50MTZfbmUgYiBpID1cbiAgKChnZXRfdWludDE2X25lIGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSAxNikpIGFzciAoU3lzLmludF9zaXplIC0gMTYpXG5cbmxldCBnZXRfaW50MTZfbGUgYiBpID1cbiAgKChnZXRfdWludDE2X2xlIGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSAxNikpIGFzciAoU3lzLmludF9zaXplIC0gMTYpXG5cbmxldCBnZXRfaW50MTZfYmUgYiBpID1cbiAgKChnZXRfdWludDE2X2JlIGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSAxNikpIGFzciAoU3lzLmludF9zaXplIC0gMTYpXG5cbmxldCBnZXRfaW50MzJfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMzIgKGdldF9pbnQzMl9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDMyX25lIGIgaVxuXG5sZXQgZ2V0X2ludDMyX2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiAoZ2V0X2ludDMyX25lIGIgaSlcbiAgZWxzZSBnZXRfaW50MzJfbmUgYiBpXG5cbmxldCBnZXRfaW50NjRfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwNjQgKGdldF9pbnQ2NF9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDY0X25lIGIgaVxuXG5sZXQgZ2V0X2ludDY0X2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCAoZ2V0X2ludDY0X25lIGIgaSlcbiAgZWxzZSBnZXRfaW50NjRfbmUgYiBpXG5cbmxldCBzZXRfaW50MTZfbGUgYiBpIHggPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuICBlbHNlIHNldF9pbnQxNl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDE2X2JlIGIgaSB4ID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDE2X25lIGIgaSAoc3dhcDE2IHgpXG4gIGVsc2Ugc2V0X2ludDE2X25lIGIgaSB4XG5cbmxldCBzZXRfaW50MzJfbGUgYiBpIHggPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQzMl9uZSBiIGkgKHN3YXAzMiB4KVxuICBlbHNlIHNldF9pbnQzMl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDMyX2JlIGIgaSB4ID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDMyX25lIGIgaSAoc3dhcDMyIHgpXG4gIGVsc2Ugc2V0X2ludDMyX25lIGIgaSB4XG5cbmxldCBzZXRfaW50NjRfbGUgYiBpIHggPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQ2NF9uZSBiIGkgKHN3YXA2NCB4KVxuICBlbHNlIHNldF9pbnQ2NF9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDY0X2JlIGIgaSB4ID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDY0X25lIGIgaSAoc3dhcDY0IHgpXG4gIGVsc2Ugc2V0X2ludDY0X25lIGIgaSB4XG5cbmxldCBzZXRfdWludDggPSBzZXRfaW50OFxubGV0IHNldF91aW50MTZfbmUgPSBzZXRfaW50MTZfbmVcbmxldCBzZXRfdWludDE2X2JlID0gc2V0X2ludDE2X2JlXG5sZXQgc2V0X3VpbnQxNl9sZSA9IHNldF9pbnQxNl9sZVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgR2FsbGl1bSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBTdHJpbmcgb3BlcmF0aW9ucywgYmFzZWQgb24gYnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zICopXG5cbigqIFdBUk5JTkc6IFNvbWUgZnVuY3Rpb25zIGluIHRoaXMgZmlsZSBhcmUgZHVwbGljYXRlZCBpbiBieXRlcy5tbCBmb3JcbiAgIGVmZmljaWVuY3kgcmVhc29ucy4gV2hlbiB5b3UgbW9kaWZ5IHRoZSBvbmUgaW4gdGhpcyBmaWxlIHlvdSBuZWVkIHRvXG4gICBtb2RpZnkgaXRzIGR1cGxpY2F0ZSBpbiBieXRlcy5tbC5cbiAgIFRoZXNlIGZ1bmN0aW9ucyBoYXZlIGEgXCJkdXBsaWNhdGVkXCIgY29tbWVudCBhYm92ZSB0aGVpciBkZWZpbml0aW9uLlxuKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVzdHJpbmdfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9zdHJpbmdcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlc3RyaW5nX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOiBzdHJpbmcgLT4gaW50IC0+ICBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV9maWxsIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiBjaGFyIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2ZpbGxfc3RyaW5nXCIgW0BAbm9hbGxvY11cblxubW9kdWxlIEIgPSBCeXRlc1xuXG5sZXQgYnRzID0gQi51bnNhZmVfdG9fc3RyaW5nXG5sZXQgYm9zID0gQi51bnNhZmVfb2Zfc3RyaW5nXG5cbmxldCBtYWtlIG4gYyA9XG4gIEIubWFrZSBuIGMgfD4gYnRzXG5sZXQgaW5pdCBuIGYgPVxuICBCLmluaXQgbiBmIHw+IGJ0c1xubGV0IGVtcHR5ID0gXCJcIlxubGV0IGNvcHkgcyA9XG4gIEIuY29weSAoYm9zIHMpIHw+IGJ0c1xubGV0IG9mX2J5dGVzID0gQi50b19zdHJpbmdcbmxldCB0b19ieXRlcyA9IEIub2Zfc3RyaW5nXG5sZXQgc3ViIHMgb2ZzIGxlbiA9XG4gIEIuc3ViIChib3Mgcykgb2ZzIGxlbiB8PiBidHNcbmxldCBmaWxsID1cbiAgQi5maWxsXG5sZXQgYmxpdCA9XG4gIEIuYmxpdF9zdHJpbmdcblxubGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29uY2F0XCJcblxubGV0IHJlYyBzdW1fbGVuZ3RocyBhY2Mgc2VwbGVuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2NcbiAgfCBoZCA6OiBbXSAtPiBsZW5ndGggaGQgKyBhY2NcbiAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBzZXBsZW4gKyBhY2MpIGFjYykgc2VwbGVuIHRsXG5cbmxldCByZWMgdW5zYWZlX2JsaXRzIGRzdCBwb3Mgc2VwIHNlcGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZHN0XG4gIHwgaGQgOjogW10gLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7IGRzdFxuICB8IGhkIDo6IHRsIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpO1xuICAgIHVuc2FmZV9ibGl0IHNlcCAwIGRzdCAocG9zICsgbGVuZ3RoIGhkKSBzZXBsZW47XG4gICAgdW5zYWZlX2JsaXRzIGRzdCAocG9zICsgbGVuZ3RoIGhkICsgc2VwbGVuKSBzZXAgc2VwbGVuIHRsXG5cbmxldCBjb25jYXQgc2VwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBcIlwiXG4gIHwgbCAtPiBsZXQgc2VwbGVuID0gbGVuZ3RoIHNlcCBpbiBidHMgQEBcbiAgICAgICAgICB1bnNhZmVfYmxpdHNcbiAgICAgICAgICAgIChCLmNyZWF0ZSAoc3VtX2xlbmd0aHMgMCBzZXBsZW4gbCkpXG4gICAgICAgICAgICAwIHNlcCBzZXBsZW4gbFxuXG5sZXQgY2F0ID0gKCBeIClcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGl0ZXIgZiBzID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkbyBmICh1bnNhZmVfZ2V0IHMgaSkgZG9uZVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaXRlcmkgZiBzID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgcyBpKSBkb25lXG5cbmxldCBtYXAgZiBzID1cbiAgQi5tYXAgZiAoYm9zIHMpIHw+IGJ0c1xubGV0IG1hcGkgZiBzID1cbiAgQi5tYXBpIGYgKGJvcyBzKSB8PiBidHNcbmxldCBmb2xkX3JpZ2h0IGYgeCBhID1cbiAgQi5mb2xkX3JpZ2h0IGYgKGJvcyB4KSBhXG5sZXQgZm9sZF9sZWZ0IGYgYSB4ID1cbiAgQi5mb2xkX2xlZnQgZiBhIChib3MgeClcbmxldCBleGlzdHMgZiBzID1cbiAgQi5leGlzdHMgZiAoYm9zIHMpXG5sZXQgZm9yX2FsbCBmIHMgPVxuICBCLmZvcl9hbGwgZiAoYm9zIHMpXG5cbigqIEJld2FyZTogd2UgY2Fubm90IHVzZSBCLnRyaW0gb3IgQi5lc2NhcGUgYmVjYXVzZSB0aGV5IGFsd2F5cyBtYWtlIGFcbiAgIGNvcHksIGJ1dCBTdHJpbmcubWxpIHNwZWxscyBvdXQgc29tZSBjYXNlcyB3aGVyZSB3ZSBhcmUgbm90IGFsbG93ZWRcbiAgIHRvIG1ha2UgYSBjb3B5LiAqKVxuXG5sZXQgaXNfc3BhY2UgPSBmdW5jdGlvblxuICB8ICcgJyB8ICdcXDAxMicgfCAnXFxuJyB8ICdcXHInIHwgJ1xcdCcgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IHRyaW0gcyA9XG4gIGlmIHMgPSBcIlwiIHRoZW4gc1xuICBlbHNlIGlmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgMCkgfHwgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAobGVuZ3RoIHMgLSAxKSlcbiAgICB0aGVuIGJ0cyAoQi50cmltIChib3MgcykpXG4gIGVsc2Ugc1xuXG5sZXQgZXNjYXBlZCBzID1cbiAgbGV0IHJlYyBlc2NhcGVfaWZfbmVlZGVkIHMgbiBpID1cbiAgICBpZiBpID49IG4gdGhlbiBzIGVsc2VcbiAgICAgIG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgJ1xcXCInIHwgJ1xcXFwnIHwgJ1xcMDAwJy4uJ1xcMDMxJyB8ICdcXDEyNycuLiAnXFwyNTUnIC0+XG4gICAgICAgICAgYnRzIChCLmVzY2FwZWQgKGJvcyBzKSlcbiAgICAgIHwgXyAtPiBlc2NhcGVfaWZfbmVlZGVkIHMgbiAoaSsxKVxuICBpblxuICBlc2NhcGVfaWZfbmVlZGVkIHMgKGxlbmd0aCBzKSAwXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgaW5kZXhfcmVjIHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIGluZGV4X3JlYyBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4IHMgYyA9IGluZGV4X3JlYyBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgaW5kZXhfcmVjX29wdCBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSBpbmRleF9yZWNfb3B0IHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfb3B0IHMgYyA9IGluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tIC8gQnl0ZXMuaW5kZXhfZnJvbVwiIGVsc2VcbiAgICBpbmRleF9yZWMgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX29wdCAvIEJ5dGVzLmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIGluZGV4X3JlY19vcHQgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXggcyBjID0gcmluZGV4X3JlYyBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9mcm9tIHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tIC8gQnl0ZXMucmluZGV4X2Zyb21cIlxuICBlbHNlXG4gICAgcmluZGV4X3JlYyBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9vcHQgcyBjID0gcmluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMucmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWNfb3B0IHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBjb250YWluc19mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29udGFpbnNfZnJvbSAvIEJ5dGVzLmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAoaW5kZXhfcmVjIHMgbCBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBjb250YWlucyBzIGMgPSBjb250YWluc19mcm9tIHMgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBzID1cbiAgQi51cHBlcmNhc2VfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCBsb3dlcmNhc2VfYXNjaWkgcyA9XG4gIEIubG93ZXJjYXNlX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgY2FwaXRhbGl6ZV9hc2NpaSBzID1cbiAgQi5jYXBpdGFsaXplX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgdW5jYXBpdGFsaXplX2FzY2lpIHMgPVxuICBCLnVuY2FwaXRhbGl6ZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgc3RhcnRzX3dpdGggfnByZWZpeCBzID1cbiAgbGV0IGxlbl9zID0gbGVuZ3RoIHNcbiAgYW5kIGxlbl9wcmUgPSBsZW5ndGggcHJlZml4IGluXG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIGkgPSBsZW5fcHJlIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgdW5zYWZlX2dldCBzIGkgPD4gdW5zYWZlX2dldCBwcmVmaXggaSB0aGVuIGZhbHNlXG4gICAgZWxzZSBhdXggKGkgKyAxKVxuICBpbiBsZW5fcyA+PSBsZW5fcHJlICYmIGF1eCAwXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBlbmRzX3dpdGggfnN1ZmZpeCBzID1cbiAgbGV0IGxlbl9zID0gbGVuZ3RoIHNcbiAgYW5kIGxlbl9zdWYgPSBsZW5ndGggc3VmZml4IGluXG4gIGxldCBkaWZmID0gbGVuX3MgLSBsZW5fc3VmIGluXG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIGkgPSBsZW5fc3VmIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgdW5zYWZlX2dldCBzIChkaWZmICsgaSkgPD4gdW5zYWZlX2dldCBzdWZmaXggaSB0aGVuIGZhbHNlXG4gICAgZWxzZSBhdXggKGkgKyAxKVxuICBpbiBkaWZmID49IDAgJiYgYXV4IDBcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHNwbGl0X29uX2NoYXIgc2VwIHMgPVxuICBsZXQgciA9IHJlZiBbXSBpblxuICBsZXQgaiA9IHJlZiAobGVuZ3RoIHMpIGluXG4gIGZvciBpID0gbGVuZ3RoIHMgLSAxIGRvd250byAwIGRvXG4gICAgaWYgdW5zYWZlX2dldCBzIGkgPSBzZXAgdGhlbiBiZWdpblxuICAgICAgciA6PSBzdWIgcyAoaSArIDEpICghaiAtIGkgLSAxKSA6OiAhcjtcbiAgICAgIGogOj0gaVxuICAgIGVuZFxuICBkb25lO1xuICBzdWIgcyAwICFqIDo6ICFyXG5cbigqIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGltcGxlbWVudGVkIHZpYSBvdGhlciBkZXByZWNhdGVkIGZ1bmN0aW9ucyAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubGV0IHVwcGVyY2FzZSBzID1cbiAgQi51cHBlcmNhc2UgKGJvcyBzKSB8PiBidHNcbmxldCBsb3dlcmNhc2UgcyA9XG4gIEIubG93ZXJjYXNlIChib3MgcykgfD4gYnRzXG5sZXQgY2FwaXRhbGl6ZSBzID1cbiAgQi5jYXBpdGFsaXplIChib3MgcykgfD4gYnRzXG5sZXQgdW5jYXBpdGFsaXplIHMgPVxuICBCLnVuY2FwaXRhbGl6ZSAoYm9zIHMpIHw+IGJ0c1xuXG50eXBlIHQgPSBzdHJpbmdcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxuZXh0ZXJuYWwgZXF1YWwgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2wgPSBcImNhbWxfc3RyaW5nX2VxdWFsXCIgW0BAbm9hbGxvY11cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID0gYm9zIHMgfD4gQi50b19zZXFcblxubGV0IHRvX3NlcWkgcyA9IGJvcyBzIHw+IEIudG9fc2VxaVxuXG5sZXQgb2Zfc2VxIGcgPSBCLm9mX3NlcSBnIHw+IGJ0c1xuXG4oKiogezYgQmluYXJ5IGVuY29kaW5nL2RlY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG5leHRlcm5hbCBnZXRfdWludDggOiBzdHJpbmcgLT4gaW50IC0+IGludCA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5leHRlcm5hbCBnZXRfdWludDE2X25lIDogc3RyaW5nIC0+IGludCAtPiBpbnQgPSBcIiVjYW1sX3N0cmluZ19nZXQxNlwiXG5leHRlcm5hbCBnZXRfaW50MzJfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludDMyID0gXCIlY2FtbF9zdHJpbmdfZ2V0MzJcIlxuZXh0ZXJuYWwgZ2V0X2ludDY0X25lIDogc3RyaW5nIC0+IGludCAtPiBpbnQ2NCA9IFwiJWNhbWxfc3RyaW5nX2dldDY0XCJcblxubGV0IGdldF9pbnQ4IHMgaSA9IEIuZ2V0X2ludDggKGJvcyBzKSBpXG5sZXQgZ2V0X3VpbnQxNl9sZSBzIGkgPSBCLmdldF91aW50MTZfbGUgKGJvcyBzKSBpXG5sZXQgZ2V0X3VpbnQxNl9iZSBzIGkgPSBCLmdldF91aW50MTZfYmUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDE2X25lIHMgaSA9IEIuZ2V0X2ludDE2X25lIChib3MgcykgaVxubGV0IGdldF9pbnQxNl9sZSBzIGkgPSBCLmdldF9pbnQxNl9sZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MTZfYmUgcyBpID0gQi5nZXRfaW50MTZfYmUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDMyX2xlIHMgaSA9IEIuZ2V0X2ludDMyX2xlIChib3MgcykgaVxubGV0IGdldF9pbnQzMl9iZSBzIGkgPSBCLmdldF9pbnQzMl9iZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50NjRfbGUgcyBpID0gQi5nZXRfaW50NjRfbGUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDY0X2JlIHMgaSA9IEIuZ2V0X2ludDY0X2JlIChib3MgcykgaVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSB1bml0ID0gKClcblxubGV0IGVxdWFsICgpICgpID0gdHJ1ZVxubGV0IGNvbXBhcmUgKCkgKCkgPSAwXG5sZXQgdG9fc3RyaW5nICgpID0gXCIoKVwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgZXh0ZXJuX2ZsYWdzID1cbiAgICBOb19zaGFyaW5nXG4gIHwgQ2xvc3VyZXNcbiAgfCBDb21wYXRfMzJcbigqIG5vdGU6IHRoaXMgdHlwZSBkZWZpbml0aW9uIGlzIHVzZWQgaW4gJ3J1bnRpbWUvZGVidWdnZXIuYycgKilcblxuZXh0ZXJuYWwgdG9fY2hhbm5lbDogb3V0X2NoYW5uZWwgLT4gJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gdW5pdFxuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZVwiXG5leHRlcm5hbCB0b19ieXRlczogJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gYnl0ZXNcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXNcIlxuZXh0ZXJuYWwgdG9fc3RyaW5nOiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBzdHJpbmdcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nXCJcbmV4dGVybmFsIHRvX2J1ZmZlcl91bnNhZmU6XG4gICAgICBieXRlcyAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IGludFxuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXJcIlxuXG5sZXQgdG9fYnVmZmVyIGJ1ZmYgb2ZzIGxlbiB2IGZsYWdzID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLnRvX2J1ZmZlcjogc3Vic3RyaW5nIG91dCBvZiBib3VuZHNcIlxuICBlbHNlIHRvX2J1ZmZlcl91bnNhZmUgYnVmZiBvZnMgbGVuIHYgZmxhZ3NcblxuKCogVGhlIGZ1bmN0aW9ucyBiZWxvdyB1c2UgYnl0ZSBzZXF1ZW5jZXMgYXMgaW5wdXQsIG5ldmVyIHVzaW5nIGFueVxuICAgbXV0YXRpb24uIEl0IG1ha2VzIHNlbnNlIHRvIHVzZSBub24tbXV0YXRlZCBbYnl0ZXNdIHJhdGhlciB0aGFuXG4gICBbc3RyaW5nXSwgYmVjYXVzZSB3ZSByZWFsbHkgd29yayB3aXRoIHNlcXVlbmNlcyBvZiBieXRlcywgbm90XG4gICBhIHRleHQgcmVwcmVzZW50YXRpb24uXG4qKVxuXG5leHRlcm5hbCBmcm9tX2NoYW5uZWw6IGluX2NoYW5uZWwgLT4gJ2EgPSBcImNhbWxfaW5wdXRfdmFsdWVcIlxuZXh0ZXJuYWwgZnJvbV9ieXRlc191bnNhZmU6IGJ5dGVzIC0+IGludCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzXCJcbmV4dGVybmFsIGRhdGFfc2l6ZV91bnNhZmU6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcImNhbWxfbWFyc2hhbF9kYXRhX3NpemVcIlxuXG5sZXQgaGVhZGVyX3NpemUgPSAyMFxubGV0IGRhdGFfc2l6ZSBidWZmIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBoZWFkZXJfc2l6ZVxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5kYXRhX3NpemVcIlxuICBlbHNlIGRhdGFfc2l6ZV91bnNhZmUgYnVmZiBvZnNcbmxldCB0b3RhbF9zaXplIGJ1ZmYgb2ZzID0gaGVhZGVyX3NpemUgKyBkYXRhX3NpemUgYnVmZiBvZnNcblxubGV0IGZyb21fYnl0ZXMgYnVmZiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gaGVhZGVyX3NpemVcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZnJvbV9ieXRlc1wiXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgbGVuID0gZGF0YV9zaXplX3Vuc2FmZSBidWZmIG9mcyBpblxuICAgIGlmIG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gKGhlYWRlcl9zaXplICsgbGVuKVxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmZyb21fYnl0ZXNcIlxuICAgIGVsc2UgZnJvbV9ieXRlc191bnNhZmUgYnVmZiBvZnNcbiAgZW5kXG5cbmxldCBmcm9tX3N0cmluZyBidWZmIG9mcyA9XG4gICgqIEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgaXMgc2FmZSBoZXJlLCBhcyB0aGUgcHJvZHVjZWQgYnl0ZVxuICAgICBzZXF1ZW5jZSBpcyBuZXZlciBtdXRhdGVkICopXG4gIGZyb21fYnl0ZXMgKEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgYnVmZikgb2ZzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE9wZXJhdGlvbnMgb24gaW50ZXJuYWwgcmVwcmVzZW50YXRpb25zIG9mIHZhbHVlcyAqKVxuXG50eXBlIHRcblxudHlwZSByYXdfZGF0YSA9IG5hdGl2ZWludFxuXG5leHRlcm5hbCByZXByIDogJ2EgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG9iaiA6IHQgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBtYWdpYyA6ICdhIC0+ICdiID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgaXNfaW50IDogdCAtPiBib29sID0gXCIlb2JqX2lzX2ludFwiXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBpc19ibG9jayBhID0gbm90IChpc19pbnQgYSlcbmV4dGVybmFsIHRhZyA6IHQgLT4gaW50ID0gXCJjYW1sX29ial90YWdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2V0X3RhZyA6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3NldF90YWdcIlxuZXh0ZXJuYWwgc2l6ZSA6IHQgLT4gaW50ID0gXCIlb2JqX3NpemVcIlxuZXh0ZXJuYWwgcmVhY2hhYmxlX3dvcmRzIDogdCAtPiBpbnQgPSBcImNhbWxfb2JqX3JlYWNoYWJsZV93b3Jkc1wiXG5leHRlcm5hbCBmaWVsZCA6IHQgLT4gaW50IC0+IHQgPSBcIiVvYmpfZmllbGRcIlxuZXh0ZXJuYWwgc2V0X2ZpZWxkIDogdCAtPiBpbnQgLT4gdCAtPiB1bml0ID0gXCIlb2JqX3NldF9maWVsZFwiXG5leHRlcm5hbCBmbG9hdGFycmF5X2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfZ2V0XCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfc2V0IDpcbiAgICBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfc2V0XCJcbmxldCBbQGlubGluZSBhbHdheXNdIGRvdWJsZV9maWVsZCB4IGkgPSBmbG9hdGFycmF5X2dldCAob2JqIHggOiBmbG9hdGFycmF5KSBpXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBzZXRfZG91YmxlX2ZpZWxkIHggaSB2ID1cbiAgZmxvYXRhcnJheV9zZXQgKG9iaiB4IDogZmxvYXRhcnJheSkgaSB2XG5leHRlcm5hbCByYXdfZmllbGQgOiB0IC0+IGludCAtPiByYXdfZGF0YSA9IFwiY2FtbF9vYmpfcmF3X2ZpZWxkXCJcbmV4dGVybmFsIHNldF9yYXdfZmllbGQgOiB0IC0+IGludCAtPiByYXdfZGF0YSAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9vYmpfc2V0X3Jhd19maWVsZFwiXG5cbmV4dGVybmFsIG5ld19ibG9jayA6IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9vYmpfYmxvY2tcIlxuZXh0ZXJuYWwgZHVwIDogdCAtPiB0ID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial90cnVuY2F0ZVwiXG5leHRlcm5hbCBhZGRfb2Zmc2V0IDogdCAtPiBJbnQzMi50IC0+IHQgPSBcImNhbWxfb2JqX2FkZF9vZmZzZXRcIlxuZXh0ZXJuYWwgd2l0aF90YWcgOiBpbnQgLT4gdCAtPiB0ID0gXCJjYW1sX29ial93aXRoX3RhZ1wiXG5cbmxldCBtYXJzaGFsIChvYmogOiB0KSA9XG4gIE1hcnNoYWwudG9fYnl0ZXMgb2JqIFtdXG5sZXQgdW5tYXJzaGFsIHN0ciBwb3MgPVxuICAoTWFyc2hhbC5mcm9tX2J5dGVzIHN0ciBwb3MsIHBvcyArIE1hcnNoYWwudG90YWxfc2l6ZSBzdHIgcG9zKVxuXG5sZXQgZmlyc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yX3RhZyA9IDBcbmxldCBsYXN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl90YWcgPSAyNDVcblxubGV0IGxhenlfdGFnID0gMjQ2XG5sZXQgY2xvc3VyZV90YWcgPSAyNDdcbmxldCBvYmplY3RfdGFnID0gMjQ4XG5sZXQgaW5maXhfdGFnID0gMjQ5XG5sZXQgZm9yd2FyZF90YWcgPSAyNTBcblxubGV0IG5vX3NjYW5fdGFnID0gMjUxXG5cbmxldCBhYnN0cmFjdF90YWcgPSAyNTFcbmxldCBzdHJpbmdfdGFnID0gMjUyXG5sZXQgZG91YmxlX3RhZyA9IDI1M1xubGV0IGRvdWJsZV9hcnJheV90YWcgPSAyNTRcbmxldCBjdXN0b21fdGFnID0gMjU1XG5sZXQgZmluYWxfdGFnID0gY3VzdG9tX3RhZ1xuXG5cbmxldCBpbnRfdGFnID0gMTAwMFxubGV0IG91dF9vZl9oZWFwX3RhZyA9IDEwMDFcbmxldCB1bmFsaWduZWRfdGFnID0gMTAwMlxuXG5tb2R1bGUgQ2xvc3VyZSA9IHN0cnVjdFxuICB0eXBlIGluZm8gPSB7XG4gICAgYXJpdHk6IGludDtcbiAgICBzdGFydF9lbnY6IGludDtcbiAgfVxuXG4gIGxldCBpbmZvX29mX3JhdyAoaW5mbyA6IG5hdGl2ZWludCkgPVxuICAgIGxldCBvcGVuIE5hdGl2ZWludCBpblxuICAgIGxldCBhcml0eSA9XG4gICAgICAoKiBzaWduZWQ6IG5lZ2F0aXZlIGZvciB0dXBsZWQgZnVuY3Rpb25zICopXG4gICAgICBpZiBTeXMud29yZF9zaXplID0gNjQgdGhlblxuICAgICAgICB0b19pbnQgKHNoaWZ0X3JpZ2h0IGluZm8gNTYpXG4gICAgICBlbHNlXG4gICAgICAgIHRvX2ludCAoc2hpZnRfcmlnaHQgaW5mbyAyNClcbiAgICBpblxuICAgIGxldCBzdGFydF9lbnYgPVxuICAgICAgKCogc3RhcnRfZW52IGlzIHVuc2lnbmVkLCBidXQgd2Uga25vdyBpdCBjYW4gYWx3YXlzIGZpdCBhbiBPQ2FtbFxuICAgICAgICAgaW50ZWdlciBzbyB3ZSB1c2UgW3RvX2ludF0gaW5zdGVhZCBvZiBbdW5zaWduZWRfdG9faW50XS4gKilcbiAgICAgIHRvX2ludCAoc2hpZnRfcmlnaHRfbG9naWNhbCAoc2hpZnRfbGVmdCBpbmZvIDgpIDkpIGluXG4gICAgeyBhcml0eTsgc3RhcnRfZW52IH1cblxuICAoKiBub3RlOiB3ZSBleHBlY3QgYSBjbG9zdXJlLCBub3QgYW4gaW5maXggcG9pbnRlciAqKVxuICBsZXQgaW5mbyAob2JqIDogdCkgPVxuICAgIGFzc2VydCAodGFnIG9iaiA9IGNsb3N1cmVfdGFnKTtcbiAgICBpbmZvX29mX3JhdyAocmF3X2ZpZWxkIG9iaiAxKVxuZW5kXG5cbm1vZHVsZSBFeHRlbnNpb25fY29uc3RydWN0b3IgPVxuc3RydWN0XG4gIHR5cGUgdCA9IGV4dGVuc2lvbl9jb25zdHJ1Y3RvclxuICBsZXQgb2ZfdmFsIHggPVxuICAgIGxldCB4ID0gcmVwciB4IGluXG4gICAgbGV0IHNsb3QgPVxuICAgICAgaWYgKGlzX2Jsb2NrIHgpICYmICh0YWcgeCkgPD4gb2JqZWN0X3RhZyAmJiAoc2l6ZSB4KSA+PSAxIHRoZW4gZmllbGQgeCAwXG4gICAgICBlbHNlIHhcbiAgICBpblxuICAgIGxldCBuYW1lID1cbiAgICAgIGlmIChpc19ibG9jayBzbG90KSAmJiAodGFnIHNsb3QpID0gb2JqZWN0X3RhZyB0aGVuIGZpZWxkIHNsb3QgMFxuICAgICAgZWxzZSBpbnZhbGlkX2FyZyBcIk9iai5leHRlbnNpb25fY29uc3RydWN0b3JcIlxuICAgIGluXG4gICAgICBpZiAodGFnIG5hbWUpID0gc3RyaW5nX3RhZyB0aGVuIChvYmogc2xvdCA6IHQpXG4gICAgICBlbHNlIGludmFsaWRfYXJnIFwiT2JqLmV4dGVuc2lvbl9jb25zdHJ1Y3RvclwiXG5cbiAgbGV0IFtAaW5saW5lIGFsd2F5c10gbmFtZSAoc2xvdCA6IHQpID1cbiAgICAob2JqIChmaWVsZCAocmVwciBzbG90KSAwKSA6IHN0cmluZylcblxuICBsZXQgW0BpbmxpbmUgYWx3YXlzXSBpZCAoc2xvdCA6IHQpID1cbiAgICAob2JqIChmaWVsZCAocmVwciBzbG90KSAxKSA6IGludClcbmVuZFxuXG5sZXQgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yID0gRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm9mX3ZhbFxubGV0IGV4dGVuc2lvbl9uYW1lID0gRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm5hbWVcbmxldCBleHRlbnNpb25faWQgPSBFeHRlbnNpb25fY29uc3RydWN0b3IuaWRcblxubW9kdWxlIEVwaGVtZXJvbiA9IHN0cnVjdFxuICB0eXBlIG9ial90ID0gdFxuXG4gIHR5cGUgdCAoKiogZXBoZW1lcm9uICopXG5cbiAgICgqKiBUbyBjaGFuZ2UgaW4gc3luYyB3aXRoIHdlYWsuaCAqKVxuICBsZXQgYWRkaXRpb25hbF92YWx1ZXMgPSAyXG4gIGxldCBtYXhfZXBoZV9sZW5ndGggPSBTeXMubWF4X2FycmF5X2xlbmd0aCAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IHQgPSBcImNhbWxfZXBoZV9jcmVhdGVcIjs7XG4gIGxldCBjcmVhdGUgbCA9XG4gICAgaWYgbm90ICgwIDw9IGwgJiYgbCA8PSBtYXhfZXBoZV9sZW5ndGgpIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiT2JqLkVwaGVtZXJvbi5jcmVhdGVcIjtcbiAgICBjcmVhdGUgbFxuXG4gIGxldCBsZW5ndGggeCA9IHNpemUocmVwciB4KSAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbiAgbGV0IHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBtc2cgPVxuICAgIGlmIG5vdCAoMCA8PSBvICYmIG8gPCBsZW5ndGggZSkgdGhlblxuICAgICAgaW52YWxpZF9hcmcgbXNnXG5cbiAgZXh0ZXJuYWwgZ2V0X2tleTogdCAtPiBpbnQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2tleVwiXG4gIGxldCBnZXRfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi5nZXRfa2V5XCI7XG4gICAgZ2V0X2tleSBlIG9cblxuICBleHRlcm5hbCBnZXRfa2V5X2NvcHk6IHQgLT4gaW50IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9rZXlfY29weVwiXG4gIGxldCBnZXRfa2V5X2NvcHkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmdldF9rZXlfY29weVwiO1xuICAgIGdldF9rZXlfY29weSBlIG9cblxuICBleHRlcm5hbCBzZXRfa2V5OiB0IC0+IGludCAtPiBvYmpfdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2tleVwiXG4gIGxldCBzZXRfa2V5IGUgbyB4ID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLnNldF9rZXlcIjtcbiAgICBzZXRfa2V5IGUgbyB4XG5cbiAgZXh0ZXJuYWwgdW5zZXRfa2V5OiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfa2V5XCJcbiAgbGV0IHVuc2V0X2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24udW5zZXRfa2V5XCI7XG4gICAgdW5zZXRfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGNoZWNrX2tleTogdCAtPiBpbnQgLT4gYm9vbCA9IFwiY2FtbF9lcGhlX2NoZWNrX2tleVwiXG4gIGxldCBjaGVja19rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmNoZWNrX2tleVwiO1xuICAgIGNoZWNrX2tleSBlIG9cblxuICBleHRlcm5hbCBibGl0X2tleSA6IHQgLT4gaW50IC0+IHQgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgPSBcImNhbWxfZXBoZV9ibGl0X2tleVwiXG5cbiAgbGV0IGJsaXRfa2V5IGUxIG8xIGUyIG8yIGwgPVxuICAgIGlmIGwgPCAwIHx8IG8xIDwgMCB8fCBvMSA+IGxlbmd0aCBlMSAtIGxcbiAgICAgICB8fCBvMiA8IDAgfHwgbzIgPiBsZW5ndGggZTIgLSBsXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIk9iai5FcGhlbWVyb24uYmxpdF9rZXlcIlxuICAgIGVsc2UgaWYgbCA8PiAwIHRoZW4gYmxpdF9rZXkgZTEgbzEgZTIgbzIgbFxuXG4gIGV4dGVybmFsIGdldF9kYXRhOiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhXCJcbiAgZXh0ZXJuYWwgZ2V0X2RhdGFfY29weTogdCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XCJcbiAgZXh0ZXJuYWwgc2V0X2RhdGE6IHQgLT4gb2JqX3QgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9kYXRhXCJcbiAgZXh0ZXJuYWwgdW5zZXRfZGF0YTogdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfZGF0YVwiXG4gIGV4dGVybmFsIGNoZWNrX2RhdGE6IHQgLT4gYm9vbCA9IFwiY2FtbF9lcGhlX2NoZWNrX2RhdGFcIlxuICBleHRlcm5hbCBibGl0X2RhdGEgOiB0IC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX2JsaXRfZGF0YVwiXG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgYXJyYXlzLiAqKVxudHlwZSAnYSB0ID0gJ2EgYXJyYXlcblxuKCogQXJyYXkgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBsZW5ndGggOiAnYSBhcnJheSAtPiBpbnQgPSBcIiVhcnJheV9sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgbWFrZTogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG5leHRlcm5hbCBjcmVhdGU6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgdW5zYWZlX3N1YiA6ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfc3ViXCJcbmV4dGVybmFsIGFwcGVuZF9wcmltIDogJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfYXBwZW5kXCJcbmV4dGVybmFsIGNvbmNhdCA6ICdhIGFycmF5IGxpc3QgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfY29uY2F0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9hcnJheV9ibGl0XCJcbmV4dGVybmFsIHVuc2FmZV9maWxsIDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2FycmF5X2ZpbGxcIlxuZXh0ZXJuYWwgY3JlYXRlX2Zsb2F0OiBpbnQgLT4gZmxvYXQgYXJyYXkgPSBcImNhbWxfbWFrZV9mbG9hdF92ZWN0XCJcbmxldCBtYWtlX2Zsb2F0ID0gY3JlYXRlX2Zsb2F0XG5cbm1vZHVsZSBGbG9hdGFycmF5ID0gc3RydWN0XG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBmbG9hdGFycmF5ID0gXCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgbGVuZ3RoIDogZmxvYXRhcnJheSAtPiBpbnQgPSBcIiVmbG9hdGFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIGdldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXRcbiAgICAgID0gXCIlZmxvYXRhcnJheV91bnNhZmVfc2V0XCJcbmVuZFxuXG5sZXQgaW5pdCBsIGYgPVxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZVxuICBpZiBsIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuaW5pdFwiXG4gICgqIFNlZSAjNjU3NS4gV2UgY291bGQgYWxzbyBjaGVjayBmb3IgbWF4aW11bSBhcnJheSBzaXplLCBidXQgdGhpcyBkZXBlbmRzXG4gICAgIG9uIHdoZXRoZXIgd2UgY3JlYXRlIGEgZmxvYXQgYXJyYXkgb3IgYSByZWd1bGFyIG9uZS4uLiAqKVxuICBlbHNlXG4gICBsZXQgcmVzID0gY3JlYXRlIGwgKGYgMCkgaW5cbiAgIGZvciBpID0gMSB0byBwcmVkIGwgZG9cbiAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgZG9uZTtcbiAgIHJlc1xuXG5sZXQgbWFrZV9tYXRyaXggc3ggc3kgaW5pdCA9XG4gIGxldCByZXMgPSBjcmVhdGUgc3ggW3x8XSBpblxuICBmb3IgeCA9IDAgdG8gcHJlZCBzeCBkb1xuICAgIHVuc2FmZV9zZXQgcmVzIHggKGNyZWF0ZSBzeSBpbml0KVxuICBkb25lO1xuICByZXNcblxubGV0IGNyZWF0ZV9tYXRyaXggPSBtYWtlX21hdHJpeFxuXG5sZXQgY29weSBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpbiBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSB1bnNhZmVfc3ViIGEgMCBsXG5cbmxldCBhcHBlbmQgYTEgYTIgPVxuICBsZXQgbDEgPSBsZW5ndGggYTEgaW5cbiAgaWYgbDEgPSAwIHRoZW4gY29weSBhMlxuICBlbHNlIGlmIGxlbmd0aCBhMiA9IDAgdGhlbiB1bnNhZmVfc3ViIGExIDAgbDFcbiAgZWxzZSBhcHBlbmRfcHJpbSBhMSBhMlxuXG5sZXQgc3ViIGEgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuc3ViXCJcbiAgZWxzZSB1bnNhZmVfc3ViIGEgb2ZzIGxlblxuXG5sZXQgZmlsbCBhIG9mcyBsZW4gdiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuZmlsbFwiXG4gIGVsc2UgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHZcblxubGV0IGJsaXQgYTEgb2ZzMSBhMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IGxlbmd0aCBhMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggYTIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmJsaXRcIlxuICBlbHNlIHVuc2FmZV9ibGl0IGExIG9mczEgYTIgb2ZzMiBsZW5cblxubGV0IGl0ZXIgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBpdGVyMiBmIGEgYiA9XG4gIGlmIGxlbmd0aCBhIDw+IGxlbmd0aCBiIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkFycmF5Lml0ZXIyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2VcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpIGRvbmVcblxubGV0IG1hcCBmIGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCAoZih1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZih1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgbWFwMiBmIGEgYiA9XG4gIGxldCBsYSA9IGxlbmd0aCBhIGluXG4gIGxldCBsYiA9IGxlbmd0aCBiIGluXG4gIGlmIGxhIDw+IGxiIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkFycmF5Lm1hcDI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgZWxzZSBiZWdpblxuICAgIGlmIGxhID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBjcmVhdGUgbGEgKGYgKHVuc2FmZV9nZXQgYSAwKSAodW5zYWZlX2dldCBiIDApKSBpblxuICAgICAgZm9yIGkgPSAxIHRvIGxhIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkpXG4gICAgICBkb25lO1xuICAgICAgclxuICAgIGVuZFxuICBlbmRcblxubGV0IGl0ZXJpIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgbWFwaSBmIGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCAoZiAwICh1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgdG9fbGlzdCBhID1cbiAgbGV0IHJlYyB0b2xpc3QgaSByZXMgPVxuICAgIGlmIGkgPCAwIHRoZW4gcmVzIGVsc2UgdG9saXN0IChpIC0gMSkgKHVuc2FmZV9nZXQgYSBpIDo6IHJlcykgaW5cbiAgdG9saXN0IChsZW5ndGggYSAtIDEpIFtdXG5cbigqIENhbm5vdCB1c2UgTGlzdC5sZW5ndGggaGVyZSBiZWNhdXNlIHRoZSBMaXN0IG1vZHVsZSBkZXBlbmRzIG9uIEFycmF5LiAqKVxubGV0IHJlYyBsaXN0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2N1XG4gIHwgXzo6dCAtPiBsaXN0X2xlbmd0aCAoc3VjYyBhY2N1KSB0XG5cbmxldCBvZl9saXN0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbfHxdXG4gIHwgaGQ6OnRsIGFzIGwgLT5cbiAgICAgIGxldCBhID0gY3JlYXRlIChsaXN0X2xlbmd0aCAwIGwpIGhkIGluXG4gICAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgICAgW10gLT4gYVxuICAgICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaSsxKSB0bCBpblxuICAgICAgZmlsbCAxIHRsXG5cbmxldCBmb2xkX2xlZnQgZiB4IGEgPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lO1xuICAhclxuXG5sZXQgZm9sZF9sZWZ0X21hcCBmIGFjYyBpbnB1dF9hcnJheSA9XG4gIGxldCBsZW4gPSBsZW5ndGggaW5wdXRfYXJyYXkgaW5cbiAgaWYgbGVuID0gMCB0aGVuIChhY2MsIFt8fF0pIGVsc2UgYmVnaW5cbiAgICBsZXQgYWNjLCBlbHQgPSBmIGFjYyAodW5zYWZlX2dldCBpbnB1dF9hcnJheSAwKSBpblxuICAgIGxldCBvdXRwdXRfYXJyYXkgPSBjcmVhdGUgbGVuIGVsdCBpblxuICAgIGxldCBhY2MgPSByZWYgYWNjIGluXG4gICAgZm9yIGkgPSAxIHRvIGxlbiAtIDEgZG9cbiAgICAgIGxldCBhY2MnLCBlbHQgPSBmICFhY2MgKHVuc2FmZV9nZXQgaW5wdXRfYXJyYXkgaSkgaW5cbiAgICAgIGFjYyA6PSBhY2MnO1xuICAgICAgdW5zYWZlX3NldCBvdXRwdXRfYXJyYXkgaSBlbHQ7XG4gICAgZG9uZTtcbiAgICAhYWNjLCBvdXRwdXRfYXJyYXlcbiAgZW5kXG5cbmxldCBmb2xkX3JpZ2h0IGYgYSB4ID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IGxlbmd0aCBhIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAodW5zYWZlX2dldCBhIGkpICFyXG4gIGRvbmU7XG4gICFyXG5cbmxldCBleGlzdHMgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwyIHAgbDEgbDIgPVxuICBsZXQgbjEgPSBsZW5ndGggbDFcbiAgYW5kIG4yID0gbGVuZ3RoIGwyIGluXG4gIGlmIG4xIDw+IG4yIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5mb3JfYWxsMlwiXG4gIGVsc2UgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuMSB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgbDEgaSkgKHVuc2FmZV9nZXQgbDIgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IGV4aXN0czIgcCBsMSBsMiA9XG4gIGxldCBuMSA9IGxlbmd0aCBsMVxuICBhbmQgbjIgPSBsZW5ndGggbDIgaW5cbiAgaWYgbjEgPD4gbjIgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmV4aXN0czJcIlxuICBlbHNlIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbjEgdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBsMSBpKSAodW5zYWZlX2dldCBsMiBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW0geCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhIGkpIHggPSAwIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IG1lbXEgeCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgeCA9PSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZpbmRfb3B0IHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gTm9uZVxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgIGlmIHAgeCB0aGVuIFNvbWUgeFxuICAgICAgZWxzZSBsb29wIChzdWNjIGkpXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgZmluZF9tYXAgZiBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBOb25lXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggZiAodW5zYWZlX2dldCBhIGkpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBsb29wIChzdWNjIGkpXG4gICAgICB8IFNvbWUgXyBhcyByIC0+IHJcbiAgaW5cbiAgbG9vcCAwXG5cbmxldCBzcGxpdCB4ID1cbiAgaWYgeCA9IFt8fF0gdGhlbiBbfHxdLCBbfHxdXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgYTAsIGIwID0gdW5zYWZlX2dldCB4IDAgaW5cbiAgICBsZXQgbiA9IGxlbmd0aCB4IGluXG4gICAgbGV0IGEgPSBjcmVhdGUgbiBhMCBpblxuICAgIGxldCBiID0gY3JlYXRlIG4gYjAgaW5cbiAgICBmb3IgaSA9IDEgdG8gbiAtIDEgZG9cbiAgICAgIGxldCBhaSwgYmkgPSB1bnNhZmVfZ2V0IHggaSBpblxuICAgICAgdW5zYWZlX3NldCBhIGkgYWk7XG4gICAgICB1bnNhZmVfc2V0IGIgaSBiaVxuICAgIGRvbmU7XG4gICAgYSwgYlxuICBlbmRcblxubGV0IGNvbWJpbmUgYSBiID1cbiAgbGV0IG5hID0gbGVuZ3RoIGEgaW5cbiAgbGV0IG5iID0gbGVuZ3RoIGIgaW5cbiAgaWYgbmEgPD4gbmIgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmNvbWJpbmVcIjtcbiAgaWYgbmEgPSAwIHRoZW4gW3x8XVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHggPSBjcmVhdGUgbmEgKHVuc2FmZV9nZXQgYSAwLCB1bnNhZmVfZ2V0IGIgMCkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbmEgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHggaSAodW5zYWZlX2dldCBhIGksIHVuc2FmZV9nZXQgYiBpKVxuICAgIGRvbmU7XG4gICAgeFxuICBlbmRcblxuZXhjZXB0aW9uIEJvdHRvbSBvZiBpbnRcbmxldCBzb3J0IGNtcCBhID1cbiAgbGV0IG1heHNvbiBsIGkgPVxuICAgIGxldCBpMzEgPSBpK2kraSsxIGluXG4gICAgbGV0IHggPSByZWYgaTMxIGluXG4gICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgIGlmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwIHRoZW4geCA6PSBpMzErMTtcbiAgICAgIGlmIGNtcCAoZ2V0IGEgIXgpIChnZXQgYSAoaTMxKzIpKSA8IDAgdGhlbiB4IDo9IGkzMSsyO1xuICAgICAgIXhcbiAgICBlbmQgZWxzZVxuICAgICAgaWYgaTMxKzEgPCBsICYmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwXG4gICAgICB0aGVuIGkzMSsxXG4gICAgICBlbHNlIGlmIGkzMSA8IGwgdGhlbiBpMzEgZWxzZSByYWlzZSAoQm90dG9tIGkpXG4gIGluXG4gIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIGlmIGNtcCAoZ2V0IGEgaikgZSA+IDAgdGhlbiBiZWdpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICB0cmlja2xlZG93biBsIGogZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgbGV0IHJlYyBidWJibGVkb3duIGwgaSA9XG4gICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgYnViYmxlZG93biBsIGpcbiAgaW5cbiAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gIGxldCByZWMgdHJpY2tsZXVwIGkgZSA9XG4gICAgbGV0IGZhdGhlciA9IChpIC0gMSkgLyAzIGluXG4gICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgaWYgY21wIChnZXQgYSBmYXRoZXIpIGUgPCAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGZhdGhlcik7XG4gICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBzZXQgYSBpIGU7XG4gICAgZW5kO1xuICBpblxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgZm9yIGkgPSBsIC0gMSBkb3dudG8gMiBkb1xuICAgIGxldCBlID0gKGdldCBhIGkpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgdHJpY2tsZXVwIChidWJibGUgaSAwKSBlO1xuICBkb25lO1xuICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG5cbmxldCBjdXRvZmYgPSA1XG5sZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICBsZXQgbWVyZ2Ugc3JjMW9mcyBzcmMxbGVuIHNyYzIgc3JjMm9mcyBzcmMybGVuIGRzdCBkc3RvZnMgPVxuICAgIGxldCBzcmMxciA9IHNyYzFvZnMgKyBzcmMxbGVuIGFuZCBzcmMyciA9IHNyYzJvZnMgKyBzcmMybGVuIGluXG4gICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgaWYgY21wIHMxIHMyIDw9IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgZHN0IGQgczE7XG4gICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICBpZiBpMSA8IHNyYzFyIHRoZW5cbiAgICAgICAgICBsb29wIGkxIChnZXQgYSBpMSkgaTIgczIgKGQgKyAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYmxpdCBzcmMyIGkyIGRzdCAoZCArIDEpIChzcmMyciAtIGkyKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICBsZXQgaTIgPSBpMiArIDEgaW5cbiAgICAgICAgaWYgaTIgPCBzcmMyciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgYSBpMSBkc3QgKGQgKyAxKSAoc3JjMXIgLSBpMSlcbiAgICAgIGVuZFxuICAgIGluIGxvb3Agc3JjMW9mcyAoZ2V0IGEgc3JjMW9mcykgc3JjMm9mcyAoZ2V0IHNyYzIgc3JjMm9mcykgZHN0b2ZzO1xuICBpblxuICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSAoc3Jjb2ZzICsgaSkpIGluXG4gICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICB3aGlsZSAoIWogPj0gZHN0b2ZzICYmIGNtcCAoZ2V0IGRzdCAhaikgZSA+IDApIGRvXG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgKGdldCBkc3QgIWopO1xuICAgICAgICBkZWNyIGo7XG4gICAgICBkb25lO1xuICAgICAgc2V0IGRzdCAoIWogKyAxKSBlO1xuICAgIGRvbmU7XG4gIGluXG4gIGxldCByZWMgc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgIGxldCBsMSA9IGxlbiAvIDIgaW5cbiAgICAgIGxldCBsMiA9IGxlbiAtIGwxIGluXG4gICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgIHNvcnR0byBzcmNvZnMgYSAoc3Jjb2ZzICsgbDIpIGwxO1xuICAgICAgbWVyZ2UgKHNyY29mcyArIGwyKSBsMSBkc3QgKGRzdG9mcyArIGwxKSBsMiBkc3QgZHN0b2ZzO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgbGV0IGwxID0gbCAvIDIgaW5cbiAgICBsZXQgbDIgPSBsIC0gbDEgaW5cbiAgICBsZXQgdCA9IG1ha2UgbDIgKGdldCBhIDApIGluXG4gICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICBzb3J0dG8gMCBhIGwyIGwxO1xuICAgIG1lcmdlIGwyIGwxIHQgMCBsMiBhIDA7XG4gIGVuZFxuXG5cbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGEgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICB0aGVuXG4gICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICAgIGVsc2UgU2VxLk5pbFxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBhID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgdGhlblxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gICAgZWxzZSBTZXEuTmlsXG4gIGluXG4gIGF1eCAwXG5cbmxldCBvZl9yZXZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgbGVuID0gbGlzdF9sZW5ndGggMCBsIGluXG4gICAgICBsZXQgYSA9IGNyZWF0ZSBsZW4gaGQgaW5cbiAgICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgICBbXSAtPiBhXG4gICAgICAgIHwgaGQ6OnRsIC0+IHVuc2FmZV9zZXQgYSBpIGhkOyBmaWxsIChpLTEpIHRsXG4gICAgICBpblxuICAgICAgZmlsbCAobGVuLTIpIHRsXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBsID0gU2VxLmZvbGRfbGVmdCAoZnVuIGFjYyB4IC0+IHg6OmFjYykgW10gaSBpblxuICBvZl9yZXZfbGlzdCBsXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50MzJdOiAzMi1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50MzIgLT4gaW50ID0gXCIlaW50MzJfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfb2ZfZmxvYXRcIiBcImNhbWxfaW50MzJfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDMyIC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDMyX3RvX2Zsb2F0XCIgXCJjYW1sX2ludDMyX3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYml0c19vZl9mbG9hdCA6IGZsb2F0IC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcIiBcImNhbWxfaW50MzJfYml0c19vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQzMiAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbmxldCB6ZXJvID0gMGxcbmxldCBvbmUgPSAxbFxubGV0IG1pbnVzX29uZSA9IC0xbFxubGV0IHN1Y2MgbiA9IGFkZCBuIDFsXG5sZXQgcHJlZCBuID0gc3ViIG4gMWxcbmxldCBhYnMgbiA9IGlmIG4gPj0gMGwgdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBtaW5faW50ID0gMHg4MDAwMDAwMGxcbmxldCBtYXhfaW50ID0gMHg3RkZGRkZGRmxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMWwpXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBtYXRjaCBTeXMud29yZF9zaXplIHdpdGhcbiAgfCAzMiAtPlxuICAgICAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgICAgIGZ1biBuIC0+XG4gICAgICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICAgICAgU29tZSAodG9faW50IG4pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBOb25lXG4gIHwgNjQgLT5cbiAgICAgICgqIFNvIHRoYXQgaXQgY29tcGlsZXMgaW4gMzItYml0ICopXG4gICAgICBsZXQgbWFzayA9IDB4RkZGRiBsc2wgMTYgbG9yIDB4RkZGRiBpblxuICAgICAgZnVuIG4gLT4gU29tZSAodG9faW50IG4gbGFuZCBtYXNrKVxuICB8IF8gLT5cbiAgICAgIGFzc2VydCBmYWxzZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBpbnQzMlxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxubGV0IG1pbiB4IHkgOiB0ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5IDogdCA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBwYXJzaW5nIGVuZ2luZSAqKVxuXG5vcGVuIExleGluZ1xuXG4oKiBJbnRlcm5hbCBpbnRlcmZhY2UgdG8gdGhlIHBhcnNpbmcgZW5naW5lICopXG5cbnR5cGUgcGFyc2VyX2VudiA9XG4gIHsgbXV0YWJsZSBzX3N0YWNrIDogaW50IGFycmF5OyAgICAgICAgKCogU3RhdGVzICopXG4gICAgbXV0YWJsZSB2X3N0YWNrIDogT2JqLnQgYXJyYXk7ICAgICAgKCogU2VtYW50aWMgYXR0cmlidXRlcyAqKVxuICAgIG11dGFibGUgc3ltYl9zdGFydF9zdGFjayA6IHBvc2l0aW9uIGFycmF5OyAoKiBTdGFydCBwb3NpdGlvbnMgKilcbiAgICBtdXRhYmxlIHN5bWJfZW5kX3N0YWNrIDogcG9zaXRpb24gYXJyYXk7ICAgKCogRW5kIHBvc2l0aW9ucyAqKVxuICAgIG11dGFibGUgc3RhY2tzaXplIDogaW50OyAgICAgICAgICAgICgqIFNpemUgb2YgdGhlIHN0YWNrcyAqKVxuICAgIG11dGFibGUgc3RhY2tiYXNlIDogaW50OyAgICAgICAgICAgICgqIEJhc2Ugc3AgZm9yIGN1cnJlbnQgcGFyc2UgKilcbiAgICBtdXRhYmxlIGN1cnJfY2hhciA6IGludDsgICAgICAgICAgICAoKiBMYXN0IHRva2VuIHJlYWQgKilcbiAgICBtdXRhYmxlIGx2YWwgOiBPYmoudDsgICAgICAgICAgICAgICAoKiBJdHMgc2VtYW50aWMgYXR0cmlidXRlICopXG4gICAgbXV0YWJsZSBzeW1iX3N0YXJ0IDogcG9zaXRpb247ICAgICAgKCogU3RhcnQgcG9zLiBvZiB0aGUgY3VycmVudCBzeW1ib2wqKVxuICAgIG11dGFibGUgc3ltYl9lbmQgOiBwb3NpdGlvbjsgICAgICAgICgqIEVuZCBwb3MuIG9mIHRoZSBjdXJyZW50IHN5bWJvbCAqKVxuICAgIG11dGFibGUgYXNwIDogaW50OyAgICAgICAgICAgICAgICAgICgqIFRoZSBzdGFjayBwb2ludGVyIGZvciBhdHRyaWJ1dGVzICopXG4gICAgbXV0YWJsZSBydWxlX2xlbiA6IGludDsgICAgICAgICAgICAgKCogTnVtYmVyIG9mIHJocyBpdGVtcyBpbiB0aGUgcnVsZSAqKVxuICAgIG11dGFibGUgcnVsZV9udW1iZXIgOiBpbnQ7ICAgICAgICAgICgqIFJ1bGUgbnVtYmVyIHRvIHJlZHVjZSBieSAqKVxuICAgIG11dGFibGUgc3AgOiBpbnQ7ICAgICAgICAgICAgICAgICAgICgqIFNhdmVkIHNwIGZvciBwYXJzZV9lbmdpbmUgKilcbiAgICBtdXRhYmxlIHN0YXRlIDogaW50OyAgICAgICAgICAgICAgICAoKiBTYXZlZCBzdGF0ZSBmb3IgcGFyc2VfZW5naW5lICopXG4gICAgbXV0YWJsZSBlcnJmbGFnIDogaW50IH0gICAgICAgICAgICAgKCogU2F2ZWQgZXJyb3IgZmxhZyBmb3IgcGFyc2VfZW5naW5lICopXG5bQEB3YXJuaW5nIFwiLXVudXNlZC1maWVsZFwiXVxuXG50eXBlIHBhcnNlX3RhYmxlcyA9XG4gIHsgYWN0aW9ucyA6IChwYXJzZXJfZW52IC0+IE9iai50KSBhcnJheTtcbiAgICB0cmFuc2xfY29uc3QgOiBpbnQgYXJyYXk7XG4gICAgdHJhbnNsX2Jsb2NrIDogaW50IGFycmF5O1xuICAgIGxocyA6IHN0cmluZztcbiAgICBsZW4gOiBzdHJpbmc7XG4gICAgZGVmcmVkIDogc3RyaW5nO1xuICAgIGRnb3RvIDogc3RyaW5nO1xuICAgIHNpbmRleCA6IHN0cmluZztcbiAgICByaW5kZXggOiBzdHJpbmc7XG4gICAgZ2luZGV4IDogc3RyaW5nO1xuICAgIHRhYmxlc2l6ZSA6IGludDtcbiAgICB0YWJsZSA6IHN0cmluZztcbiAgICBjaGVjayA6IHN0cmluZztcbiAgICBlcnJvcl9mdW5jdGlvbiA6IHN0cmluZyAtPiB1bml0O1xuICAgIG5hbWVzX2NvbnN0IDogc3RyaW5nO1xuICAgIG5hbWVzX2Jsb2NrIDogc3RyaW5nIH1cblxuZXhjZXB0aW9uIFlZZXhpdCBvZiBPYmoudFxuZXhjZXB0aW9uIFBhcnNlX2Vycm9yXG5cbnR5cGUgcGFyc2VyX2lucHV0ID1cbiAgICBTdGFydFxuICB8IFRva2VuX3JlYWRcbiAgfCBTdGFja3NfZ3Jvd25fMVxuICB8IFN0YWNrc19ncm93bl8yXG4gIHwgU2VtYW50aWNfYWN0aW9uX2NvbXB1dGVkXG4gIHwgRXJyb3JfZGV0ZWN0ZWRcblxudHlwZSBwYXJzZXJfb3V0cHV0ID1cbiAgICBSZWFkX3Rva2VuXG4gIHwgUmFpc2VfcGFyc2VfZXJyb3JcbiAgfCBHcm93X3N0YWNrc18xXG4gIHwgR3Jvd19zdGFja3NfMlxuICB8IENvbXB1dGVfc2VtYW50aWNfYWN0aW9uXG4gIHwgQ2FsbF9lcnJvcl9mdW5jdGlvblxuXG4oKiB0byBhdm9pZCB3YXJuaW5ncyAqKVxubGV0IF8gPSBbUmVhZF90b2tlbjsgUmFpc2VfcGFyc2VfZXJyb3I7IEdyb3dfc3RhY2tzXzE7IEdyb3dfc3RhY2tzXzI7XG4gICAgICAgICBDb21wdXRlX3NlbWFudGljX2FjdGlvbjsgQ2FsbF9lcnJvcl9mdW5jdGlvbl1cblxuZXh0ZXJuYWwgcGFyc2VfZW5naW5lIDpcbiAgICBwYXJzZV90YWJsZXMgLT4gcGFyc2VyX2VudiAtPiBwYXJzZXJfaW5wdXQgLT4gT2JqLnQgLT4gcGFyc2VyX291dHB1dFxuICAgID0gXCJjYW1sX3BhcnNlX2VuZ2luZVwiXG5cbmV4dGVybmFsIHNldF90cmFjZTogYm9vbCAtPiBib29sXG4gICAgPSBcImNhbWxfc2V0X3BhcnNlcl90cmFjZVwiXG5cbmxldCBlbnYgPVxuICB7IHNfc3RhY2sgPSBBcnJheS5tYWtlIDEwMCAwO1xuICAgIHZfc3RhY2sgPSBBcnJheS5tYWtlIDEwMCAoT2JqLnJlcHIgKCkpO1xuICAgIHN5bWJfc3RhcnRfc3RhY2sgPSBBcnJheS5tYWtlIDEwMCBkdW1teV9wb3M7XG4gICAgc3ltYl9lbmRfc3RhY2sgPSBBcnJheS5tYWtlIDEwMCBkdW1teV9wb3M7XG4gICAgc3RhY2tzaXplID0gMTAwO1xuICAgIHN0YWNrYmFzZSA9IDA7XG4gICAgY3Vycl9jaGFyID0gMDtcbiAgICBsdmFsID0gT2JqLnJlcHIgKCk7XG4gICAgc3ltYl9zdGFydCA9IGR1bW15X3BvcztcbiAgICBzeW1iX2VuZCA9IGR1bW15X3BvcztcbiAgICBhc3AgPSAwO1xuICAgIHJ1bGVfbGVuID0gMDtcbiAgICBydWxlX251bWJlciA9IDA7XG4gICAgc3AgPSAwO1xuICAgIHN0YXRlID0gMDtcbiAgICBlcnJmbGFnID0gMCB9XG5cbmxldCBncm93X3N0YWNrcygpID1cbiAgbGV0IG9sZHNpemUgPSBlbnYuc3RhY2tzaXplIGluXG4gIGxldCBuZXdzaXplID0gb2xkc2l6ZSAqIDIgaW5cbiAgbGV0IG5ld19zID0gQXJyYXkubWFrZSBuZXdzaXplIDBcbiAgYW5kIG5ld192ID0gQXJyYXkubWFrZSBuZXdzaXplIChPYmoucmVwciAoKSlcbiAgYW5kIG5ld19zdGFydCA9IEFycmF5Lm1ha2UgbmV3c2l6ZSBkdW1teV9wb3NcbiAgYW5kIG5ld19lbmQgPSBBcnJheS5tYWtlIG5ld3NpemUgZHVtbXlfcG9zIGluXG4gICAgQXJyYXkuYmxpdCBlbnYuc19zdGFjayAwIG5ld19zIDAgb2xkc2l6ZTtcbiAgICBlbnYuc19zdGFjayA8LSBuZXdfcztcbiAgICBBcnJheS5ibGl0IGVudi52X3N0YWNrIDAgbmV3X3YgMCBvbGRzaXplO1xuICAgIGVudi52X3N0YWNrIDwtIG5ld192O1xuICAgIEFycmF5LmJsaXQgZW52LnN5bWJfc3RhcnRfc3RhY2sgMCBuZXdfc3RhcnQgMCBvbGRzaXplO1xuICAgIGVudi5zeW1iX3N0YXJ0X3N0YWNrIDwtIG5ld19zdGFydDtcbiAgICBBcnJheS5ibGl0IGVudi5zeW1iX2VuZF9zdGFjayAwIG5ld19lbmQgMCBvbGRzaXplO1xuICAgIGVudi5zeW1iX2VuZF9zdGFjayA8LSBuZXdfZW5kO1xuICAgIGVudi5zdGFja3NpemUgPC0gbmV3c2l6ZVxuXG5sZXQgY2xlYXJfcGFyc2VyKCkgPVxuICBBcnJheS5maWxsIGVudi52X3N0YWNrIDAgZW52LnN0YWNrc2l6ZSAoT2JqLnJlcHIgKCkpO1xuICBlbnYubHZhbCA8LSBPYmoucmVwciAoKVxuXG5sZXQgY3VycmVudF9sb29rYWhlYWRfZnVuID0gcmVmIChmdW4gKF8gOiBPYmoudCkgLT4gZmFsc2UpXG5cbmxldCB5eXBhcnNlIHRhYmxlcyBzdGFydCBsZXhlciBsZXhidWYgPVxuICBsZXQgcmVjIGxvb3AgY21kIGFyZyA9XG4gICAgbWF0Y2ggcGFyc2VfZW5naW5lIHRhYmxlcyBlbnYgY21kIGFyZyB3aXRoXG4gICAgICBSZWFkX3Rva2VuIC0+XG4gICAgICAgIGxldCB0ID0gT2JqLnJlcHIobGV4ZXIgbGV4YnVmKSBpblxuICAgICAgICBlbnYuc3ltYl9zdGFydCA8LSBsZXhidWYubGV4X3N0YXJ0X3A7XG4gICAgICAgIGVudi5zeW1iX2VuZCA8LSBsZXhidWYubGV4X2N1cnJfcDtcbiAgICAgICAgbG9vcCBUb2tlbl9yZWFkIHRcbiAgICB8IFJhaXNlX3BhcnNlX2Vycm9yIC0+XG4gICAgICAgIHJhaXNlIFBhcnNlX2Vycm9yXG4gICAgfCBDb21wdXRlX3NlbWFudGljX2FjdGlvbiAtPlxuICAgICAgICBsZXQgKGFjdGlvbiwgdmFsdWUpID1cbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIChTZW1hbnRpY19hY3Rpb25fY29tcHV0ZWQsIHRhYmxlcy5hY3Rpb25zLihlbnYucnVsZV9udW1iZXIpIGVudilcbiAgICAgICAgICB3aXRoIFBhcnNlX2Vycm9yIC0+XG4gICAgICAgICAgICAoRXJyb3JfZGV0ZWN0ZWQsIE9iai5yZXByICgpKSBpblxuICAgICAgICBsb29wIGFjdGlvbiB2YWx1ZVxuICAgIHwgR3Jvd19zdGFja3NfMSAtPlxuICAgICAgICBncm93X3N0YWNrcygpOyBsb29wIFN0YWNrc19ncm93bl8xIChPYmoucmVwciAoKSlcbiAgICB8IEdyb3dfc3RhY2tzXzIgLT5cbiAgICAgICAgZ3Jvd19zdGFja3MoKTsgbG9vcCBTdGFja3NfZ3Jvd25fMiAoT2JqLnJlcHIgKCkpXG4gICAgfCBDYWxsX2Vycm9yX2Z1bmN0aW9uIC0+XG4gICAgICAgIHRhYmxlcy5lcnJvcl9mdW5jdGlvbiBcInN5bnRheCBlcnJvclwiO1xuICAgICAgICBsb29wIEVycm9yX2RldGVjdGVkIChPYmoucmVwciAoKSkgaW5cbiAgbGV0IGluaXRfYXNwID0gZW52LmFzcFxuICBhbmQgaW5pdF9zcCA9IGVudi5zcFxuICBhbmQgaW5pdF9zdGFja2Jhc2UgPSBlbnYuc3RhY2tiYXNlXG4gIGFuZCBpbml0X3N0YXRlID0gZW52LnN0YXRlXG4gIGFuZCBpbml0X2N1cnJfY2hhciA9IGVudi5jdXJyX2NoYXJcbiAgYW5kIGluaXRfbHZhbCA9IGVudi5sdmFsXG4gIGFuZCBpbml0X2VycmZsYWcgPSBlbnYuZXJyZmxhZyBpblxuICBlbnYuc3RhY2tiYXNlIDwtIGVudi5zcCArIDE7XG4gIGVudi5jdXJyX2NoYXIgPC0gc3RhcnQ7XG4gIGVudi5zeW1iX2VuZCA8LSBsZXhidWYubGV4X2N1cnJfcDtcbiAgdHJ5XG4gICAgbG9vcCBTdGFydCAoT2JqLnJlcHIgKCkpXG4gIHdpdGggZXhuIC0+XG4gICAgbGV0IGN1cnJfY2hhciA9IGVudi5jdXJyX2NoYXIgaW5cbiAgICBlbnYuYXNwIDwtIGluaXRfYXNwO1xuICAgIGVudi5zcCA8LSBpbml0X3NwO1xuICAgIGVudi5zdGFja2Jhc2UgPC0gaW5pdF9zdGFja2Jhc2U7XG4gICAgZW52LnN0YXRlIDwtIGluaXRfc3RhdGU7XG4gICAgZW52LmN1cnJfY2hhciA8LSBpbml0X2N1cnJfY2hhcjtcbiAgICBlbnYubHZhbCA8LSBpbml0X2x2YWw7XG4gICAgZW52LmVycmZsYWcgPC0gaW5pdF9lcnJmbGFnO1xuICAgIG1hdGNoIGV4biB3aXRoXG4gICAgICBZWWV4aXQgdiAtPlxuICAgICAgICBPYmoubWFnaWMgdlxuICAgIHwgXyAtPlxuICAgICAgICBjdXJyZW50X2xvb2thaGVhZF9mdW4gOj1cbiAgICAgICAgICAoZnVuIHRvayAtPlxuICAgICAgICAgICAgaWYgT2JqLmlzX2Jsb2NrIHRva1xuICAgICAgICAgICAgdGhlbiB0YWJsZXMudHJhbnNsX2Jsb2NrLihPYmoudGFnIHRvaykgPSBjdXJyX2NoYXJcbiAgICAgICAgICAgIGVsc2UgdGFibGVzLnRyYW5zbF9jb25zdC4oT2JqLm1hZ2ljIHRvaykgPSBjdXJyX2NoYXIpO1xuICAgICAgICByYWlzZSBleG5cblxubGV0IHBlZWtfdmFsIGVudiBuID1cbiAgT2JqLm1hZ2ljIGVudi52X3N0YWNrLihlbnYuYXNwIC0gbilcblxubGV0IHN5bWJvbF9zdGFydF9wb3MgKCkgPVxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA8PSAwIHRoZW4gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwKVxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCBzdCA9IGVudi5zeW1iX3N0YXJ0X3N0YWNrLihlbnYuYXNwIC0gaSArIDEpIGluXG4gICAgICBsZXQgZW4gPSBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3AgLSBpICsgMSkgaW5cbiAgICAgIGlmIHN0IDw+IGVuIHRoZW4gc3QgZWxzZSBsb29wIChpIC0gMSlcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBlbnYucnVsZV9sZW5cblxubGV0IHN5bWJvbF9lbmRfcG9zICgpID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwKVxubGV0IHJoc19zdGFydF9wb3MgbiA9IGVudi5zeW1iX3N0YXJ0X3N0YWNrLihlbnYuYXNwIC0gKGVudi5ydWxlX2xlbiAtIG4pKVxubGV0IHJoc19lbmRfcG9zIG4gPSBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3AgLSAoZW52LnJ1bGVfbGVuIC0gbikpXG5cbmxldCBzeW1ib2xfc3RhcnQgKCkgPSAoc3ltYm9sX3N0YXJ0X3BvcyAoKSkucG9zX2NudW1cbmxldCBzeW1ib2xfZW5kICgpID0gKHN5bWJvbF9lbmRfcG9zICgpKS5wb3NfY251bVxubGV0IHJoc19zdGFydCBuID0gKHJoc19zdGFydF9wb3MgbikucG9zX2NudW1cbmxldCByaHNfZW5kIG4gPSAocmhzX2VuZF9wb3MgbikucG9zX2NudW1cblxubGV0IGlzX2N1cnJlbnRfbG9va2FoZWFkIHRvayA9XG4gICghY3VycmVudF9sb29rYWhlYWRfZnVuKShPYmoucmVwciB0b2spXG5cbmxldCBwYXJzZV9lcnJvciAoXyA6IHN0cmluZykgPSAoKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBTZXRzIG92ZXIgb3JkZXJlZCB0eXBlcyAqKVxuXG5tb2R1bGUgdHlwZSBPcmRlcmVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBlbHRcbiAgICB0eXBlIHRcbiAgICB2YWwgZW1wdHk6IHRcbiAgICB2YWwgaXNfZW1wdHk6IHQgLT4gYm9vbFxuICAgIHZhbCBtZW06IGVsdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgYWRkOiBlbHQgLT4gdCAtPiB0XG4gICAgdmFsIHNpbmdsZXRvbjogZWx0IC0+IHRcbiAgICB2YWwgcmVtb3ZlOiBlbHQgLT4gdCAtPiB0XG4gICAgdmFsIHVuaW9uOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBpbnRlcjogdCAtPiB0IC0+IHRcbiAgICB2YWwgZGlzam9pbnQ6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGRpZmY6IHQgLT4gdCAtPiB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIHN1YnNldDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGVsdCAtPiB1bml0KSAtPiB0IC0+IHVuaXRcbiAgICB2YWwgbWFwOiAoZWx0IC0+IGVsdCkgLT4gdCAtPiB0XG4gICAgdmFsIGZvbGQ6IChlbHQgLT4gJ2EgLT4gJ2EpIC0+IHQgLT4gJ2EgLT4gJ2FcbiAgICB2YWwgZm9yX2FsbDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZXhpc3RzOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gYm9vbFxuICAgIHZhbCBmaWx0ZXI6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiB0XG4gICAgdmFsIGZpbHRlcl9tYXA6IChlbHQgLT4gZWx0IG9wdGlvbikgLT4gdCAtPiB0XG4gICAgdmFsIHBhcnRpdGlvbjogKGVsdCAtPiBib29sKSAtPiB0IC0+IHQgKiB0XG4gICAgdmFsIGNhcmRpbmFsOiB0IC0+IGludFxuICAgIHZhbCBlbGVtZW50czogdCAtPiBlbHQgbGlzdFxuICAgIHZhbCBtaW5fZWx0OiB0IC0+IGVsdFxuICAgIHZhbCBtaW5fZWx0X29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIG1heF9lbHQ6IHQgLT4gZWx0XG4gICAgdmFsIG1heF9lbHRfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgY2hvb3NlOiB0IC0+IGVsdFxuICAgIHZhbCBjaG9vc2Vfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgc3BsaXQ6IGVsdCAtPiB0IC0+IHQgKiBib29sICogdFxuICAgIHZhbCBmaW5kOiBlbHQgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9vcHQ6IGVsdCAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgZmluZF9maXJzdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX2ZpcnN0X29wdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgZmluZF9sYXN0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfbGFzdF9vcHQ6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIG9mX2xpc3Q6IGVsdCBsaXN0IC0+IHRcbiAgICB2YWwgdG9fc2VxX2Zyb20gOiBlbHQgLT4gdCAtPiBlbHQgU2VxLnRcbiAgICB2YWwgdG9fc2VxIDogdCAtPiBlbHQgU2VxLnRcbiAgICB2YWwgdG9fcmV2X3NlcSA6IHQgLT4gZWx0IFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiBlbHQgU2VxLnQgLT4gdCAtPiB0XG4gICAgdmFsIG9mX3NlcSA6IGVsdCBTZXEudCAtPiB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZShPcmQ6IE9yZGVyZWRUeXBlKSA9XG4gIHN0cnVjdFxuICAgIHR5cGUgZWx0ID0gT3JkLnRcbiAgICB0eXBlIHQgPSBFbXB0eSB8IE5vZGUgb2Yge2w6dDsgdjplbHQ7IHI6dDsgaDppbnR9XG5cbiAgICAoKiBTZXRzIGFyZSByZXByZXNlbnRlZCBieSBiYWxhbmNlZCBiaW5hcnkgdHJlZXMgKHRoZSBoZWlnaHRzIG9mIHRoZVxuICAgICAgIGNoaWxkcmVuIGRpZmZlciBieSBhdCBtb3N0IDIgKilcblxuICAgIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2h9IC0+IGhcblxuICAgICgqIENyZWF0ZXMgYSBuZXcgbm9kZSB3aXRoIGxlZnQgc29uIGwsIHZhbHVlIHYgYW5kIHJpZ2h0IHNvbiByLlxuICAgICAgIFdlIG11c3QgaGF2ZSBhbGwgZWxlbWVudHMgb2YgbCA8IHYgPCBhbGwgZWxlbWVudHMgb2Ygci5cbiAgICAgICBsIGFuZCByIG11c3QgYmUgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuXG4gICAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBoZWlnaHQgZm9yIGJldHRlciBzcGVlZC4gKilcblxuICAgIGxldCBjcmVhdGUgbCB2IHIgPVxuICAgICAgbGV0IGhsID0gbWF0Y2ggbCB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBsZXQgaHIgPSBtYXRjaCByIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIE5vZGV7bDsgdjsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUsIGJ1dCBwZXJmb3JtcyBvbmUgc3RlcCBvZiByZWJhbGFuY2luZyBpZiBuZWNlc3NhcnkuXG4gICAgICAgQXNzdW1lcyBsIGFuZCByIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAzLlxuICAgICAgIElubGluZSBleHBhbnNpb24gb2YgY3JlYXRlIGZvciBiZXR0ZXIgc3BlZWQgaW4gdGhlIG1vc3QgZnJlcXVlbnQgY2FzZVxuICAgICAgIHdoZXJlIG5vIHJlYmFsYW5jaW5nIGlzIHJlcXVpcmVkLiAqKVxuXG4gICAgbGV0IGJhbCBsIHYgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgaWYgaGwgPiBociArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1sbDsgdj1sdjsgcj1scn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHIgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgbGwgbHYgKGNyZWF0ZSBsciB2IHIpXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIGxyIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1scmw7IHY9bHJ2OyByPWxycn0tPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbHJsKSBscnYgKGNyZWF0ZSBscnIgdiByKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZSBpZiBociA+IGhsICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPXJsOyB2PXJ2OyByPXJyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybCB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgdiBybCkgcnYgcnJcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggcmwgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPXJsbDsgdj1ybHY7IHI9cmxyfSAtPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IHJsbCkgcmx2IChjcmVhdGUgcmxyIHJ2IHJyKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBOb2Rle2w7IHY7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgICgqIEluc2VydGlvbiBvZiBvbmUgZWxlbWVudCAqKVxuXG4gICAgbGV0IHJlYyBhZGQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vZGV7bD1FbXB0eTsgdj14OyByPUVtcHR5OyBoPTF9XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiB0IGVsc2VcbiAgICAgICAgICBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSBhZGQgeCBsIGluXG4gICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gdCBlbHNlIGJhbCBsbCB2IHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSBhZGQgeCByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gdCBlbHNlIGJhbCBsIHYgcnJcblxuICAgIGxldCBzaW5nbGV0b24geCA9IE5vZGV7bD1FbXB0eTsgdj14OyByPUVtcHR5OyBoPTF9XG5cbiAgICAoKiBCZXdhcmU6IHRob3NlIHR3byBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgdGhlIGFkZGVkIHYgaXMgKnN0cmljdGx5KlxuICAgICAgIHNtYWxsZXIgKG9yIGJpZ2dlcikgdGhhbiBhbGwgdGhlIHByZXNlbnQgZWxlbWVudHMgaW4gdGhlIHRyZWU7IGl0XG4gICAgICAgZG9lcyBub3QgdGVzdCBmb3IgZXF1YWxpdHkgd2l0aCB0aGUgY3VycmVudCBtaW4gKG9yIG1heCkgZWxlbWVudC5cbiAgICAgICBJbmRlZWQsIHRoZXkgYXJlIG9ubHkgdXNlZCBkdXJpbmcgdGhlIFwiam9pblwiIG9wZXJhdGlvbiB3aGljaFxuICAgICAgIHJlc3BlY3RzIHRoaXMgcHJlY29uZGl0aW9uLlxuICAgICopXG5cbiAgICBsZXQgcmVjIGFkZF9taW5fZWxlbWVudCB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgYmFsIChhZGRfbWluX2VsZW1lbnQgeCBsKSB2IHJcblxuICAgIGxldCByZWMgYWRkX21heF9lbGVtZW50IHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24geFxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICBiYWwgbCB2IChhZGRfbWF4X2VsZW1lbnQgeCByKVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUgYW5kIGJhbCwgYnV0IG5vIGFzc3VtcHRpb25zIGFyZSBtYWRlIG9uIHRoZVxuICAgICAgIHJlbGF0aXZlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCByZWMgam9pbiBsIHYgciA9XG4gICAgICBtYXRjaCAobCwgcikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IGFkZF9taW5fZWxlbWVudCB2IHJcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBhZGRfbWF4X2VsZW1lbnQgdiBsXG4gICAgICB8IChOb2Rle2w9bGw7IHY9bHY7IHI9bHI7IGg9bGh9LCBOb2Rle2w9cmw7IHY9cnY7IHI9cnI7IGg9cmh9KSAtPlxuICAgICAgICAgIGlmIGxoID4gcmggKyAyIHRoZW4gYmFsIGxsIGx2IChqb2luIGxyIHYgcikgZWxzZVxuICAgICAgICAgIGlmIHJoID4gbGggKyAyIHRoZW4gYmFsIChqb2luIGwgdiBybCkgcnYgcnIgZWxzZVxuICAgICAgICAgIGNyZWF0ZSBsIHYgclxuXG4gICAgKCogU21hbGxlc3QgYW5kIGdyZWF0ZXN0IGVsZW1lbnQgb2YgYSBzZXQgKilcblxuICAgIGxldCByZWMgbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHZ9IC0+IHZcbiAgICAgIHwgTm9kZXtsfSAtPiBtaW5fZWx0IGxcblxuICAgIGxldCByZWMgbWluX2VsdF9vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgdn0gLT4gU29tZSB2XG4gICAgICB8IE5vZGV7bH0gLT4gbWluX2VsdF9vcHQgbFxuXG4gICAgbGV0IHJlYyBtYXhfZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7djsgcj1FbXB0eX0gLT4gdlxuICAgICAgfCBOb2Rle3J9IC0+IG1heF9lbHQgclxuXG4gICAgbGV0IHJlYyBtYXhfZWx0X29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXt2OyByPUVtcHR5fSAtPiBTb21lIHZcbiAgICAgIHwgTm9kZXtyfSAtPiBtYXhfZWx0X29wdCByXG5cbiAgICAoKiBSZW1vdmUgdGhlIHNtYWxsZXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIHNldCAqKVxuXG4gICAgbGV0IHJlYyByZW1vdmVfbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LnJlbW92ZV9taW5fZWx0XCJcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyByfSAtPiByXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gYmFsIChyZW1vdmVfbWluX2VsdCBsKSB2IHJcblxuICAgICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLlxuICAgICAgIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgICBBc3N1bWUgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi4gKilcblxuICAgIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IGJhbCB0MSAobWluX2VsdCB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCBjb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPiBqb2luIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICAoKiBTcGxpdHRpbmcuICBzcGxpdCB4IHMgcmV0dXJucyBhIHRyaXBsZSAobCwgcHJlc2VudCwgcikgd2hlcmVcbiAgICAgICAgLSBsIGlzIHRoZSBzZXQgb2YgZWxlbWVudHMgb2YgcyB0aGF0IGFyZSA8IHhcbiAgICAgICAgLSByIGlzIHRoZSBzZXQgb2YgZWxlbWVudHMgb2YgcyB0aGF0IGFyZSA+IHhcbiAgICAgICAgLSBwcmVzZW50IGlzIGZhbHNlIGlmIHMgY29udGFpbnMgbm8gZWxlbWVudCBlcXVhbCB0byB4LFxuICAgICAgICAgIG9yIHRydWUgaWYgcyBjb250YWlucyBhbiBlbGVtZW50IGVxdWFsIHRvIHguICopXG5cbiAgICBsZXQgcmVjIHNwbGl0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIChFbXB0eSwgZmFsc2UsIEVtcHR5KVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIChsLCB0cnVlLCByKVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IChsbCwgcHJlcywgcmwpID0gc3BsaXQgeCBsIGluIChsbCwgcHJlcywgam9pbiBybCB2IHIpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsciwgcHJlcywgcnIpID0gc3BsaXQgeCByIGluIChqb2luIGwgdiBsciwgcHJlcywgcnIpXG5cbiAgICAoKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgc2V0IG9wZXJhdGlvbnMgKilcblxuICAgIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvbiBFbXB0eSAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGMgPSAwIHx8IG1lbSB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyByZW1vdmUgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w7IHY7IHJ9IGFzIHQpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgICAgbGV0IGxsID0gcmVtb3ZlIHggbCBpblxuICAgICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gdFxuICAgICAgICAgICAgICBlbHNlIGJhbCBsbCB2IHJcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IHJyID0gcmVtb3ZlIHggciBpblxuICAgICAgICAgICAgICBpZiByID09IHJyIHRoZW4gdFxuICAgICAgICAgICAgICBlbHNlIGJhbCBsIHYgcnJcblxuICAgIGxldCByZWMgdW5pb24gczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIHQyKSAtPiB0MlxuICAgICAgfCAodDEsIEVtcHR5KSAtPiB0MVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxOyBoPWgxfSwgTm9kZXtsPWwyOyB2PXYyOyByPXIyOyBoPWgyfSkgLT5cbiAgICAgICAgICBpZiBoMSA+PSBoMiB0aGVuXG4gICAgICAgICAgICBpZiBoMiA9IDEgdGhlbiBhZGQgdjIgczEgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBsZXQgKGwyLCBfLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjEgKHVuaW9uIHIxIHIyKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgaDEgPSAxIHRoZW4gYWRkIHYxIHMyIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbGV0IChsMSwgXywgcjEpID0gc3BsaXQgdjIgczEgaW5cbiAgICAgICAgICAgICAgam9pbiAodW5pb24gbDEgbDIpIHYyICh1bmlvbiByMSByMilcbiAgICAgICAgICAgIGVuZFxuXG4gICAgbGV0IHJlYyBpbnRlciBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gRW1wdHlcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgbWF0Y2ggc3BsaXQgdjEgdDIgd2l0aFxuICAgICAgICAgICAgKGwyLCBmYWxzZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGNvbmNhdCAoaW50ZXIgbDEgbDIpIChpbnRlciByMSByMilcbiAgICAgICAgICB8IChsMiwgdHJ1ZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGpvaW4gKGludGVyIGwxIGwyKSB2MSAoaW50ZXIgcjEgcjIpXG5cbiAgICAoKiBTYW1lIGFzIHNwbGl0LCBidXQgY29tcHV0ZSB0aGUgbGVmdCBhbmQgcmlnaHQgc3VidHJlZXNcbiAgICAgICBvbmx5IGlmIHRoZSBwaXZvdCBlbGVtZW50IGlzIG5vdCBpbiB0aGUgc2V0LiAgVGhlIHJpZ2h0IHN1YnRyZWVcbiAgICAgICBpcyBjb21wdXRlZCBvbiBkZW1hbmQuICopXG5cbiAgICB0eXBlIHNwbGl0X2JpcyA9XG4gICAgICB8IEZvdW5kXG4gICAgICB8IE5vdEZvdW5kIG9mIHQgKiAodW5pdCAtPiB0KVxuXG4gICAgbGV0IHJlYyBzcGxpdF9iaXMgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm90Rm91bmQgKEVtcHR5LCAoZnVuICgpIC0+IEVtcHR5KSlcbiAgICAgIHwgTm9kZXtsOyB2OyByOyBffSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBGb3VuZFxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbWF0Y2ggc3BsaXRfYmlzIHggbCB3aXRoXG4gICAgICAgICAgICB8IEZvdW5kIC0+IEZvdW5kXG4gICAgICAgICAgICB8IE5vdEZvdW5kIChsbCwgcmwpIC0+IE5vdEZvdW5kIChsbCwgKGZ1biAoKSAtPiBqb2luIChybCAoKSkgdiByKSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXRjaCBzcGxpdF9iaXMgeCByIHdpdGhcbiAgICAgICAgICAgIHwgRm91bmQgLT4gRm91bmRcbiAgICAgICAgICAgIHwgTm90Rm91bmQgKGxyLCBycikgLT4gTm90Rm91bmQgKGpvaW4gbCB2IGxyLCBycilcblxuICAgIGxldCByZWMgZGlzam9pbnQgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIHwgKF8sIEVtcHR5KSAtPiB0cnVlXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBpZiBzMSA9PSBzMiB0aGVuIGZhbHNlXG4gICAgICAgICAgZWxzZSBtYXRjaCBzcGxpdF9iaXMgdjEgdDIgd2l0aFxuICAgICAgICAgICAgICBOb3RGb3VuZChsMiwgcjIpIC0+IGRpc2pvaW50IGwxIGwyICYmIGRpc2pvaW50IHIxIChyMiAoKSlcbiAgICAgICAgICAgIHwgRm91bmQgLT4gZmFsc2VcblxuICAgIGxldCByZWMgZGlmZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gRW1wdHlcbiAgICAgIHwgKHQxLCBFbXB0eSkgLT4gdDFcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIG1hdGNoIHNwbGl0IHYxIHQyIHdpdGhcbiAgICAgICAgICAgIChsMiwgZmFsc2UsIHIyKSAtPlxuICAgICAgICAgICAgICBqb2luIChkaWZmIGwxIGwyKSB2MSAoZGlmZiByMSByMilcbiAgICAgICAgICB8IChsMiwgdHJ1ZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGNvbmNhdCAoZGlmZiBsMSBsMikgKGRpZmYgcjEgcjIpXG5cbiAgICB0eXBlIGVudW1lcmF0aW9uID0gRW5kIHwgTW9yZSBvZiBlbHQgKiB0ICogZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGNvbnNfZW51bSBsIChNb3JlKHYsIHIsIGUpKVxuXG4gICAgbGV0IHJlYyBjb21wYXJlX2F1eCBlMSBlMiA9XG4gICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICB8IChFbmQsIF8pICAtPiAtMVxuICAgICAgfCAoXywgRW5kKSAtPiAxXG4gICAgICB8IChNb3JlKHYxLCByMSwgZTEpLCBNb3JlKHYyLCByMiwgZTIpKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjIDw+IDBcbiAgICAgICAgICB0aGVuIGNcbiAgICAgICAgICBlbHNlIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG5cbiAgICBsZXQgY29tcGFyZSBzMSBzMiA9XG4gICAgICBjb21wYXJlX2F1eCAoY29uc19lbnVtIHMxIEVuZCkgKGNvbnNfZW51bSBzMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgczEgczIgPVxuICAgICAgY29tcGFyZSBzMSBzMiA9IDBcblxuICAgIGxldCByZWMgc3Vic2V0IHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgRW1wdHksIF8gLT5cbiAgICAgICAgICB0cnVlXG4gICAgICB8IF8sIEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgTm9kZSB7bD1sMTsgdj12MTsgcj1yMX0sIChOb2RlIHtsPWwyOyB2PXYyOyByPXIyfSBhcyB0MikgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgc3Vic2V0IGwxIGwyICYmIHN1YnNldCByMSByMlxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgc3Vic2V0IChOb2RlIHtsPWwxOyB2PXYxOyByPUVtcHR5OyBoPTB9KSBsMiAmJiBzdWJzZXQgcjEgdDJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdWJzZXQgKE5vZGUge2w9RW1wdHk7IHY9djE7IHI9cjE7IGg9MH0pIHIyICYmIHN1YnNldCBsMSB0MlxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGl0ZXIgZiBsOyBmIHY7IGl0ZXIgZiByXG5cbiAgICBsZXQgcmVjIGZvbGQgZiBzIGFjY3UgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBmb2xkIGYgciAoZiB2IChmb2xkIGYgbCBhY2N1KSlcblxuICAgIGxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHAgdiAmJiBmb3JfYWxsIHAgbCAmJiBmb3JfYWxsIHAgclxuXG4gICAgbGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gcCB2IHx8IGV4aXN0cyBwIGwgfHwgZXhpc3RzIHAgclxuXG4gICAgbGV0IHJlYyBmaWx0ZXIgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w7IHY7IHJ9KSBhcyB0IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXIgcCBsIGluXG4gICAgICAgICAgbGV0IHB2ID0gcCB2IGluXG4gICAgICAgICAgbGV0IHInID0gZmlsdGVyIHAgciBpblxuICAgICAgICAgIGlmIHB2IHRoZW5cbiAgICAgICAgICAgIGlmIGw9PWwnICYmIHI9PXInIHRoZW4gdCBlbHNlIGpvaW4gbCcgdiByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IChsdCwgbGYpID0gcGFydGl0aW9uIHAgbCBpblxuICAgICAgICAgIGxldCBwdiA9IHAgdiBpblxuICAgICAgICAgIGxldCAocnQsIHJmKSA9IHBhcnRpdGlvbiBwIHIgaW5cbiAgICAgICAgICBpZiBwdlxuICAgICAgICAgIHRoZW4gKGpvaW4gbHQgdiBydCwgY29uY2F0IGxmIHJmKVxuICAgICAgICAgIGVsc2UgKGNvbmNhdCBsdCBydCwgam9pbiBsZiB2IHJmKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZXtsOyByfSAtPiBjYXJkaW5hbCBsICsgMSArIGNhcmRpbmFsIHJcblxuICAgIGxldCByZWMgZWxlbWVudHNfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gZWxlbWVudHNfYXV4ICh2IDo6IGVsZW1lbnRzX2F1eCBhY2N1IHIpIGxcblxuICAgIGxldCBlbGVtZW50cyBzID1cbiAgICAgIGVsZW1lbnRzX2F1eCBbXSBzXG5cbiAgICBsZXQgY2hvb3NlID0gbWluX2VsdFxuXG4gICAgbGV0IGNob29zZV9vcHQgPSBtaW5fZWx0X29wdFxuXG4gICAgbGV0IHJlYyBmaW5kIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiB2XG4gICAgICAgICAgZWxzZSBmaW5kIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3RfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2MCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3QgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHQgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2MCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3QgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHQgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfb3B0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSB2XG4gICAgICAgICAgZWxzZSBmaW5kX29wdCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHRyeV9qb2luIGwgdiByID1cbiAgICAgICgqIFtqb2luIGwgdiByXSBjYW4gb25seSBiZSBjYWxsZWQgd2hlbiAoZWxlbWVudHMgb2YgbCA8IHYgPFxuICAgICAgICAgZWxlbWVudHMgb2Ygcik7IHVzZSBbdHJ5X2pvaW4gbCB2IHJdIHdoZW4gdGhpcyBwcm9wZXJ0eSBtYXlcbiAgICAgICAgIG5vdCBob2xkLCBidXQgeW91IGhvcGUgaXQgZG9lcyBob2xkIGluIHRoZSBjb21tb24gY2FzZSAqKVxuICAgICAgaWYgKGwgPSBFbXB0eSB8fCBPcmQuY29tcGFyZSAobWF4X2VsdCBsKSB2IDwgMClcbiAgICAgICYmIChyID0gRW1wdHkgfHwgT3JkLmNvbXBhcmUgdiAobWluX2VsdCByKSA8IDApXG4gICAgICB0aGVuIGpvaW4gbCB2IHJcbiAgICAgIGVsc2UgdW5pb24gbCAoYWRkIHYgcilcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICgqIGVuZm9yY2UgbGVmdC10by1yaWdodCBldmFsdWF0aW9uIG9yZGVyICopXG4gICAgICAgICBsZXQgbCcgPSBtYXAgZiBsIGluXG4gICAgICAgICBsZXQgdicgPSBmIHYgaW5cbiAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgIGlmIGwgPT0gbCcgJiYgdiA9PSB2JyAmJiByID09IHInIHRoZW4gdFxuICAgICAgICAgZWxzZSB0cnlfam9pbiBsJyB2JyByJ1xuXG4gICAgbGV0IHRyeV9jb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPiB0cnlfam9pbiB0MSAobWluX2VsdCB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuXG4gICAgbGV0IHJlYyBmaWx0ZXJfbWFwIGYgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICgqIGVuZm9yY2UgbGVmdC10by1yaWdodCBldmFsdWF0aW9uIG9yZGVyICopXG4gICAgICAgICBsZXQgbCcgPSBmaWx0ZXJfbWFwIGYgbCBpblxuICAgICAgICAgbGV0IHYnID0gZiB2IGluXG4gICAgICAgICBsZXQgcicgPSBmaWx0ZXJfbWFwIGYgciBpblxuICAgICAgICAgYmVnaW4gbWF0Y2ggdicgd2l0aFxuICAgICAgICAgICB8IFNvbWUgdicgLT5cbiAgICAgICAgICAgICAgaWYgbCA9PSBsJyAmJiB2ID09IHYnICYmIHIgPT0gcicgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgdHJ5X2pvaW4gbCcgdicgcidcbiAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgIHRyeV9jb25jYXQgbCcgcidcbiAgICAgICAgIGVuZFxuXG4gICAgbGV0IG9mX3NvcnRlZF9saXN0IGwgPVxuICAgICAgbGV0IHJlYyBzdWIgbiBsID1cbiAgICAgICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgICAgIHwgMCwgbCAtPiBFbXB0eSwgbFxuICAgICAgICB8IDEsIHgwIDo6IGwgLT4gTm9kZSB7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfSwgbFxuICAgICAgICB8IDIsIHgwIDo6IHgxIDo6IGwgLT5cbiAgICAgICAgICAgIE5vZGV7bD1Ob2Rle2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX07IHY9eDE7IHI9RW1wdHk7IGg9Mn0sIGxcbiAgICAgICAgfCAzLCB4MCA6OiB4MSA6OiB4MiA6OiBsIC0+XG4gICAgICAgICAgICBOb2Rle2w9Tm9kZXtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9OyB2PXgxO1xuICAgICAgICAgICAgICAgICByPU5vZGV7bD1FbXB0eTsgdj14Mjsgcj1FbXB0eTsgaD0xfTsgaD0yfSwgbFxuICAgICAgICB8IG4sIGwgLT5cbiAgICAgICAgICBsZXQgbmwgPSBuIC8gMiBpblxuICAgICAgICAgIGxldCBsZWZ0LCBsID0gc3ViIG5sIGwgaW5cbiAgICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgbWlkIDo6IGwgLT5cbiAgICAgICAgICAgIGxldCByaWdodCwgbCA9IHN1YiAobiAtIG5sIC0gMSkgbCBpblxuICAgICAgICAgICAgY3JlYXRlIGxlZnQgbWlkIHJpZ2h0LCBsXG4gICAgICBpblxuICAgICAgZnN0IChzdWIgKExpc3QubGVuZ3RoIGwpIGwpXG5cbiAgICBsZXQgb2ZfbGlzdCBsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBlbXB0eVxuICAgICAgfCBbeDBdIC0+IHNpbmdsZXRvbiB4MFxuICAgICAgfCBbeDA7IHgxXSAtPiBhZGQgeDEgKHNpbmdsZXRvbiB4MClcbiAgICAgIHwgW3gwOyB4MTsgeDJdIC0+IGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKVxuICAgICAgfCBbeDA7IHgxOyB4MjsgeDNdIC0+IGFkZCB4MyAoYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpKVxuICAgICAgfCBbeDA7IHgxOyB4MjsgeDM7IHg0XSAtPiBhZGQgeDQgKGFkZCB4MyAoYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpKSlcbiAgICAgIHwgXyAtPiBvZl9zb3J0ZWRfbGlzdCAoTGlzdC5zb3J0X3VuaXEgT3JkLmNvbXBhcmUgbClcblxuICAgIGxldCBhZGRfc2VxIGkgbSA9XG4gICAgICBTZXEuZm9sZF9sZWZ0IChmdW4gcyB4IC0+IGFkZCB4IHMpIG0gaVxuXG4gICAgbGV0IG9mX3NlcSBpID0gYWRkX3NlcSBpIGVtcHR5XG5cbiAgICBsZXQgcmVjIHNlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKHgsIHQsIHJlc3QpIC0+IFNlcS5Db25zICh4LCBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3NlcSBjID0gc2VxX29mX2VudW1fIChjb25zX2VudW0gYyBFbmQpXG5cbiAgICBsZXQgcmVjIHNub2NfZW51bSBzIGUgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBzbm9jX2VudW0gciAoTW9yZSh2LCBsLCBlKSlcblxuICAgIGxldCByZWMgcmV2X3NlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKHgsIHQsIHJlc3QpIC0+IFNlcS5Db25zICh4LCByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19yZXZfc2VxIGMgPSByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gYyBFbmQpXG5cbiAgICBsZXQgdG9fc2VxX2Zyb20gbG93IHMgPVxuICAgICAgbGV0IHJlYyBhdXggbG93IHMgYyA9IG1hdGNoIHMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGNcbiAgICAgICAgfCBOb2RlIHtsOyByOyB2OyBffSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggT3JkLmNvbXBhcmUgdiBsb3cgd2l0aFxuICAgICAgICAgICAgICB8IDAgLT4gTW9yZSAodiwgciwgYylcbiAgICAgICAgICAgICAgfCBuIHdoZW4gbjwwIC0+IGF1eCBsb3cgciBjXG4gICAgICAgICAgICAgIHwgXyAtPiBhdXggbG93IGwgKE1vcmUgKHYsIHIsIGMpKVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgc2VxX29mX2VudW1fIChhdXggbG93IHMgRW5kKVxuICBlbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIHR5cGUgT3JkZXJlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAhKydhIHRcbiAgICB2YWwgZW1wdHk6ICdhIHRcbiAgICB2YWwgaXNfZW1wdHk6ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBtZW06ICBrZXkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGFkZDoga2V5IC0+ICdhIC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCB1cGRhdGU6IGtleSAtPiAoJ2Egb3B0aW9uIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHNpbmdsZXRvbjoga2V5IC0+ICdhIC0+ICdhIHRcbiAgICB2YWwgcmVtb3ZlOiBrZXkgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIG1lcmdlOlxuICAgICAgICAgIChrZXkgLT4gJ2Egb3B0aW9uIC0+ICdiIG9wdGlvbiAtPiAnYyBvcHRpb24pIC0+ICdhIHQgLT4gJ2IgdCAtPiAnYyB0XG4gICAgdmFsIHVuaW9uOiAoa2V5IC0+ICdhIC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgY29tcGFyZTogKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZvbGQ6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICB2YWwgZm9yX2FsbDogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgZXhpc3RzOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBmaWx0ZXI6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGZpbHRlcl9tYXA6IChrZXkgLT4gJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgcGFydGl0aW9uOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAqICdhIHRcbiAgICB2YWwgY2FyZGluYWw6ICdhIHQgLT4gaW50XG4gICAgdmFsIGJpbmRpbmdzOiAnYSB0IC0+IChrZXkgKiAnYSkgbGlzdFxuICAgIHZhbCBtaW5fYmluZGluZzogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIG1pbl9iaW5kaW5nX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBtYXhfYmluZGluZzogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIG1heF9iaW5kaW5nX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBjaG9vc2U6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBjaG9vc2Vfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIHNwbGl0OiBrZXkgLT4gJ2EgdCAtPiAnYSB0ICogJ2Egb3B0aW9uICogJ2EgdFxuICAgIHZhbCBmaW5kOiBrZXkgLT4gJ2EgdCAtPiAnYVxuICAgIHZhbCBmaW5kX29wdDoga2V5IC0+ICdhIHQgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGZpbmRfZmlyc3Q6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiBrZXkgKiAnYVxuICAgIHZhbCBmaW5kX2ZpcnN0X29wdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIGZpbmRfbGFzdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IGtleSAqICdhXG4gICAgdmFsIGZpbmRfbGFzdF9vcHQ6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBtYXA6ICgnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIG1hcGk6IChrZXkgLT4gJ2EgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fcmV2X3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19zZXFfZnJvbSA6IGtleSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIE1ha2UoT3JkOiBPcmRlcmVkVHlwZSkgPSBzdHJ1Y3RcblxuICAgIHR5cGUga2V5ID0gT3JkLnRcblxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUgb2Yge2w6J2EgdDsgdjprZXk7IGQ6J2E7IHI6J2EgdDsgaDppbnR9XG5cbiAgICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtofSAtPiBoXG5cbiAgICBsZXQgY3JlYXRlIGwgeCBkIHIgPVxuICAgICAgbGV0IGhsID0gaGVpZ2h0IGwgYW5kIGhyID0gaGVpZ2h0IHIgaW5cbiAgICAgIE5vZGV7bDsgdj14OyBkOyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICBsZXQgc2luZ2xldG9uIHggZCA9IE5vZGV7bD1FbXB0eTsgdj14OyBkOyByPUVtcHR5OyBoPTF9XG5cbiAgICBsZXQgYmFsIGwgeCBkIHIgPVxuICAgICAgbGV0IGhsID0gbWF0Y2ggbCB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBsZXQgaHIgPSBtYXRjaCByIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGlmIGhsID4gaHIgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9bGw7IHY9bHY7IGQ9bGQ7IHI9bHJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgbGwgPj0gaGVpZ2h0IGxyIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIGxsIGx2IGxkIChjcmVhdGUgbHIgeCBkIHIpXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIGxyIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1scmw7IHY9bHJ2OyBkPWxyZDsgcj1scnJ9LT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxkIGxybCkgbHJ2IGxyZCAoY3JlYXRlIGxyciB4IGQgcilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2UgaWYgaHIgPiBobCArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1ybDsgdj1ydjsgZD1yZDsgcj1ycn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCByciA+PSBoZWlnaHQgcmwgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybCkgcnYgcmQgcnJcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggcmwgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPXJsbDsgdj1ybHY7IGQ9cmxkOyByPXJscn0gLT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsbCkgcmx2IHJsZCAoY3JlYXRlIHJsciBydiByZCBycilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2VcbiAgICAgICAgTm9kZXtsOyB2PXg7IGQ7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvbiBFbXB0eSAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBhZGQgeCBkYXRhID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb2Rle2w9RW1wdHk7IHY9eDsgZD1kYXRhOyByPUVtcHR5OyBoPTF9XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IGFzIG0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGlmIGQgPT0gZGF0YSB0aGVuIG0gZWxzZSBOb2Rle2w7IHY9eDsgZD1kYXRhOyByOyBofVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gYWRkIHggZGF0YSBsIGluXG4gICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IGFkZCB4IGRhdGEgciBpblxuICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgZmluZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gZFxuICAgICAgICAgIGVsc2UgZmluZCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdjAgZDAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBkMCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3RfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdjAgZDAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBkMCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX29wdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIFNvbWUgZFxuICAgICAgICAgIGVsc2UgZmluZF9vcHQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBjID0gMCB8fCBtZW0geCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgbWluX2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgdjsgZH0gLT4gKHYsIGQpXG4gICAgICB8IE5vZGUge2x9IC0+IG1pbl9iaW5kaW5nIGxcblxuICAgIGxldCByZWMgbWluX2JpbmRpbmdfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyB2OyBkfSAtPiBTb21lICh2LCBkKVxuICAgICAgfCBOb2RlIHtsfS0+IG1pbl9iaW5kaW5nX29wdCBsXG5cbiAgICBsZXQgcmVjIG1heF9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge3Y7IGQ7IHI9RW1wdHl9IC0+ICh2LCBkKVxuICAgICAgfCBOb2RlIHtyfSAtPiBtYXhfYmluZGluZyByXG5cbiAgICBsZXQgcmVjIG1heF9iaW5kaW5nX29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZSB7djsgZDsgcj1FbXB0eX0gLT4gU29tZSAodiwgZClcbiAgICAgIHwgTm9kZSB7cn0gLT4gbWF4X2JpbmRpbmdfb3B0IHJcblxuICAgIGxldCByZWMgcmVtb3ZlX21pbl9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAucmVtb3ZlX21pbl9lbHRcIlxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyByfSAtPiByXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGJhbCAocmVtb3ZlX21pbl9iaW5kaW5nIGwpIHYgZCByXG5cbiAgICBsZXQgbWVyZ2UgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPlxuICAgICAgICAgIGxldCAoeCwgZCkgPSBtaW5fYmluZGluZyB0MiBpblxuICAgICAgICAgIGJhbCB0MSB4IGQgKHJlbW92ZV9taW5fYmluZGluZyB0MilcblxuICAgIGxldCByZWMgcmVtb3ZlIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IChOb2RlIHtsOyB2OyBkOyByfSBhcyBtKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBtZXJnZSBsIHJcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IHJlbW92ZSB4IGwgaW4gaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSByZW1vdmUgeCByIGluIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIHVwZGF0ZSB4IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIGYgTm9uZSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IEVtcHR5XG4gICAgICAgICAgfCBTb21lIGRhdGEgLT4gTm9kZXtsPUVtcHR5OyB2PXg7IGQ9ZGF0YTsgcj1FbXB0eTsgaD0xfVxuICAgICAgICAgIGVuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSBhcyBtIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIGJlZ2luXG4gICAgICAgICAgICBtYXRjaCBmIChTb21lIGQpIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBtZXJnZSBsIHJcbiAgICAgICAgICAgIHwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgICAgICAgaWYgZCA9PSBkYXRhIHRoZW4gbSBlbHNlIE5vZGV7bDsgdj14OyBkPWRhdGE7IHI7IGh9XG4gICAgICAgICAgZW5kIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gdXBkYXRlIHggZiBsIGluXG4gICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IHVwZGF0ZSB4IGYgciBpblxuICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpdGVyIGYgbDsgZiB2IGQ7IGl0ZXIgZiByXG5cbiAgICBsZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSAtPlxuICAgICAgICAgIGxldCBsJyA9IG1hcCBmIGwgaW5cbiAgICAgICAgICBsZXQgZCcgPSBmIGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBtYXAgZiByIGluXG4gICAgICAgICAgTm9kZXtsPWwnOyB2OyBkPWQnOyByPXInOyBofVxuXG4gICAgbGV0IHJlYyBtYXBpIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IC0+XG4gICAgICAgICAgbGV0IGwnID0gbWFwaSBmIGwgaW5cbiAgICAgICAgICBsZXQgZCcgPSBmIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IG1hcGkgZiByIGluXG4gICAgICAgICAgTm9kZXtsPWwnOyB2OyBkPWQnOyByPXInOyBofVxuXG4gICAgbGV0IHJlYyBmb2xkIGYgbSBhY2N1ID1cbiAgICAgIG1hdGNoIG0gd2l0aFxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgZm9sZCBmIHIgKGYgdiBkIChmb2xkIGYgbCBhY2N1KSlcblxuICAgIGxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBwIHYgZCAmJiBmb3JfYWxsIHAgbCAmJiBmb3JfYWxsIHAgclxuXG4gICAgbGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IHAgdiBkIHx8IGV4aXN0cyBwIGwgfHwgZXhpc3RzIHAgclxuXG4gICAgKCogQmV3YXJlOiB0aG9zZSB0d28gZnVuY3Rpb25zIGFzc3VtZSB0aGF0IHRoZSBhZGRlZCBrIGlzICpzdHJpY3RseSpcbiAgICAgICBzbWFsbGVyIChvciBiaWdnZXIpIHRoYW4gYWxsIHRoZSBwcmVzZW50IGtleXMgaW4gdGhlIHRyZWU7IGl0XG4gICAgICAgZG9lcyBub3QgdGVzdCBmb3IgZXF1YWxpdHkgd2l0aCB0aGUgY3VycmVudCBtaW4gKG9yIG1heCkga2V5LlxuXG4gICAgICAgSW5kZWVkLCB0aGV5IGFyZSBvbmx5IHVzZWQgZHVyaW5nIHRoZSBcImpvaW5cIiBvcGVyYXRpb24gd2hpY2hcbiAgICAgICByZXNwZWN0cyB0aGlzIHByZWNvbmRpdGlvbi5cbiAgICAqKVxuXG4gICAgbGV0IHJlYyBhZGRfbWluX2JpbmRpbmcgayB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIGsgeFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICBiYWwgKGFkZF9taW5fYmluZGluZyBrIHggbCkgdiBkIHJcblxuICAgIGxldCByZWMgYWRkX21heF9iaW5kaW5nIGsgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiBrIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgYmFsIGwgdiBkIChhZGRfbWF4X2JpbmRpbmcgayB4IHIpXG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlXG4gICAgICAgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IHJlYyBqb2luIGwgdiBkIHIgPVxuICAgICAgbWF0Y2ggKGwsIHIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBhZGRfbWluX2JpbmRpbmcgdiBkIHJcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBhZGRfbWF4X2JpbmRpbmcgdiBkIGxcbiAgICAgIHwgKE5vZGV7bD1sbDsgdj1sdjsgZD1sZDsgcj1scjsgaD1saH0sXG4gICAgICAgICBOb2Rle2w9cmw7IHY9cnY7IGQ9cmQ7IHI9cnI7IGg9cmh9KSAtPlxuICAgICAgICAgIGlmIGxoID4gcmggKyAyIHRoZW4gYmFsIGxsIGx2IGxkIChqb2luIGxyIHYgZCByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IGQgcmwpIHJ2IHJkIHJyIGVsc2VcbiAgICAgICAgICBjcmVhdGUgbCB2IGQgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCBjb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPlxuICAgICAgICAgIGxldCAoeCwgZCkgPSBtaW5fYmluZGluZyB0MiBpblxuICAgICAgICAgIGpvaW4gdDEgeCBkIChyZW1vdmVfbWluX2JpbmRpbmcgdDIpXG5cbiAgICBsZXQgY29uY2F0X29yX2pvaW4gdDEgdiBkIHQyID1cbiAgICAgIG1hdGNoIGQgd2l0aFxuICAgICAgfCBTb21lIGQgLT4gam9pbiB0MSB2IGQgdDJcbiAgICAgIHwgTm9uZSAtPiBjb25jYXQgdDEgdDJcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBOb25lLCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIFNvbWUgZCwgcilcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCAobGwsIHByZXMsIHJsKSA9IHNwbGl0IHggbCBpbiAobGwsIHByZXMsIGpvaW4gcmwgdiBkIHIpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsciwgcHJlcywgcnIpID0gc3BsaXQgeCByIGluIChqb2luIGwgdiBkIGxyLCBwcmVzLCBycilcblxuICAgIGxldCByZWMgbWVyZ2UgZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2RlIHtsPWwxOyB2PXYxOyBkPWQxOyByPXIxOyBoPWgxfSwgXykgd2hlbiBoMSA+PSBoZWlnaHQgczIgLT5cbiAgICAgICAgICBsZXQgKGwyLCBkMiwgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICBjb25jYXRfb3Jfam9pbiAobWVyZ2UgZiBsMSBsMikgdjEgKGYgdjEgKFNvbWUgZDEpIGQyKSAobWVyZ2UgZiByMSByMilcbiAgICAgIHwgKF8sIE5vZGUge2w9bDI7IHY9djI7IGQ9ZDI7IHI9cjJ9KSAtPlxuICAgICAgICAgIGxldCAobDEsIGQxLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MiAoZiB2MiBkMSAoU29tZSBkMikpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCBfIC0+XG4gICAgICAgICAgYXNzZXJ0IGZhbHNlXG5cbiAgICBsZXQgcmVjIHVuaW9uIGYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgfCAoRW1wdHksIHMpIHwgKHMsIEVtcHR5KSAtPiBzXG4gICAgICB8IChOb2RlIHtsPWwxOyB2PXYxOyBkPWQxOyByPXIxOyBoPWgxfSxcbiAgICAgICAgIE5vZGUge2w9bDI7IHY9djI7IGQ9ZDI7IHI9cjI7IGg9aDJ9KSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyIHRoZW5cbiAgICAgICAgICAgIGxldCAobDIsIGQyLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgICAgbGV0IGwgPSB1bmlvbiBmIGwxIGwyIGFuZCByID0gdW5pb24gZiByMSByMiBpblxuICAgICAgICAgICAgbWF0Y2ggZDIgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IGpvaW4gbCB2MSBkMSByXG4gICAgICAgICAgICB8IFNvbWUgZDIgLT4gY29uY2F0X29yX2pvaW4gbCB2MSAoZiB2MSBkMSBkMikgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCAobDEsIGQxLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgICAgbGV0IGwgPSB1bmlvbiBmIGwxIGwyIGFuZCByID0gdW5pb24gZiByMSByMiBpblxuICAgICAgICAgICAgbWF0Y2ggZDEgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IGpvaW4gbCB2MiBkMiByXG4gICAgICAgICAgICB8IFNvbWUgZDEgLT4gY29uY2F0X29yX2pvaW4gbCB2MiAoZiB2MiBkMSBkMikgclxuXG4gICAgbGV0IHJlYyBmaWx0ZXIgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IGFzIG0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCBsJyA9IGZpbHRlciBwIGwgaW5cbiAgICAgICAgICBsZXQgcHZkID0gcCB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXIgcCByIGluXG4gICAgICAgICAgaWYgcHZkIHRoZW4gaWYgbD09bCcgJiYgcj09cicgdGhlbiBtIGVsc2Ugam9pbiBsJyB2IGQgcidcbiAgICAgICAgICBlbHNlIGNvbmNhdCBsJyByJ1xuXG4gICAgbGV0IHJlYyBmaWx0ZXJfbWFwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW2ZdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyX21hcCBmIGwgaW5cbiAgICAgICAgICBsZXQgZnZkID0gZiB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXJfbWFwIGYgciBpblxuICAgICAgICAgIGJlZ2luIG1hdGNoIGZ2ZCB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgZCcgLT4gam9pbiBsJyB2IGQnIHInXG4gICAgICAgICAgICB8IE5vbmUgLT4gY29uY2F0IGwnIHInXG4gICAgICAgICAgZW5kXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCAobHQsIGxmKSA9IHBhcnRpdGlvbiBwIGwgaW5cbiAgICAgICAgICBsZXQgcHZkID0gcCB2IGQgaW5cbiAgICAgICAgICBsZXQgKHJ0LCByZikgPSBwYXJ0aXRpb24gcCByIGluXG4gICAgICAgICAgaWYgcHZkXG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IGQgcnQsIGNvbmNhdCBsZiByZilcbiAgICAgICAgICBlbHNlIChjb25jYXQgbHQgcnQsIGpvaW4gbGYgdiBkIHJmKVxuXG4gICAgdHlwZSAnYSBlbnVtZXJhdGlvbiA9IEVuZCB8IE1vcmUgb2Yga2V5ICogJ2EgKiAnYSB0ICogJ2EgZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIG0gZSA9XG4gICAgICBtYXRjaCBtIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBjb25zX2VudW0gbCAoTW9yZSh2LCBkLCByLCBlKSlcblxuICAgIGxldCBjb21wYXJlIGNtcCBtMSBtMiA9XG4gICAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gMVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIGQxIGQyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBjb21wYXJlX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgZXF1YWxfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiB0cnVlXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IGZhbHNlXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gZmFsc2VcbiAgICAgICAgfCAoTW9yZSh2MSwgZDEsIHIxLCBlMSksIE1vcmUodjIsIGQyLCByMiwgZTIpKSAtPlxuICAgICAgICAgICAgT3JkLmNvbXBhcmUgdjEgdjIgPSAwICYmIGNtcCBkMSBkMiAmJlxuICAgICAgICAgICAgZXF1YWxfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBlcXVhbF9hdXggKGNvbnNfZW51bSBtMSBFbmQpIChjb25zX2VudW0gbTIgRW5kKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7bDsgcn0gLT4gY2FyZGluYWwgbCArIDEgKyBjYXJkaW5hbCByXG5cbiAgICBsZXQgcmVjIGJpbmRpbmdzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiaW5kaW5nc19hdXggKCh2LCBkKSA6OiBiaW5kaW5nc19hdXggYWNjdSByKSBsXG5cbiAgICBsZXQgYmluZGluZ3MgcyA9XG4gICAgICBiaW5kaW5nc19hdXggW10gc1xuXG4gICAgbGV0IGNob29zZSA9IG1pbl9iaW5kaW5nXG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9iaW5kaW5nX29wdFxuXG4gICAgbGV0IGFkZF9zZXEgaSBtID1cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBtIChrLHYpIC0+IGFkZCBrIHYgbSkgbSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPSBhZGRfc2VxIGkgZW1wdHlcblxuICAgIGxldCByZWMgc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoayx2LHQscmVzdCkgLT4gU2VxLkNvbnMgKChrLHYpLCBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3NlcSBtID1cbiAgICAgIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIG0gRW5kKVxuXG4gICAgbGV0IHJlYyBzbm9jX2VudW0gcyBlID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGV7bDsgdjsgZDsgcn0gLT4gc25vY19lbnVtIHIgKE1vcmUodiwgZCwgbCwgZSkpXG5cbiAgICBsZXQgcmVjIHJldl9zZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlIChrLHYsdCxyZXN0KSAtPlxuICAgICAgICAgIFNlcS5Db25zICgoayx2KSwgcmV2X3NlcV9vZl9lbnVtXyAoc25vY19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fcmV2X3NlcSBjID1cbiAgICAgIHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSBjIEVuZClcblxuICAgIGxldCB0b19zZXFfZnJvbSBsb3cgbSA9XG4gICAgICBsZXQgcmVjIGF1eCBsb3cgbSBjID0gbWF0Y2ggbSB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gY1xuICAgICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IF99IC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBPcmQuY29tcGFyZSB2IGxvdyB3aXRoXG4gICAgICAgICAgICAgIHwgMCAtPiBNb3JlICh2LCBkLCByLCBjKVxuICAgICAgICAgICAgICB8IG4gd2hlbiBuPDAgLT4gYXV4IGxvdyByIGNcbiAgICAgICAgICAgICAgfCBfIC0+IGF1eCBsb3cgbCAoTW9yZSAodiwgZCwgciwgYykpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGluXG4gICAgICBzZXFfb2ZfZW51bV8gKGF1eCBsb3cgbSBFbmQpXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAnYSB0ID0geyBtdXRhYmxlIGMgOiAnYSBsaXN0OyBtdXRhYmxlIGxlbiA6IGludDsgfVxuXG5leGNlcHRpb24gRW1wdHlcblxubGV0IGNyZWF0ZSAoKSA9IHsgYyA9IFtdOyBsZW4gPSAwOyB9XG5cbmxldCBjbGVhciBzID0gcy5jIDwtIFtdOyBzLmxlbiA8LSAwXG5cbmxldCBjb3B5IHMgPSB7IGMgPSBzLmM7IGxlbiA9IHMubGVuOyB9XG5cbmxldCBwdXNoIHggcyA9IHMuYyA8LSB4IDo6IHMuYzsgcy5sZW4gPC0gcy5sZW4gKyAxXG5cbmxldCBwb3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6OnRsIC0+IHMuYyA8LSB0bDsgcy5sZW4gPC0gcy5sZW4gLSAxOyBoZFxuICB8IFtdICAgICAtPiByYWlzZSBFbXB0eVxuXG5sZXQgcG9wX29wdCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDE7IFNvbWUgaGRcbiAgfCBbXSAgICAgLT4gTm9uZVxuXG5sZXQgdG9wIHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjpfIC0+IGhkXG4gIHwgW10gICAgLT4gcmFpc2UgRW1wdHlcblxubGV0IHRvcF9vcHQgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6Ol8gLT4gU29tZSBoZFxuICB8IFtdICAgIC0+IE5vbmVcblxubGV0IGlzX2VtcHR5IHMgPSAocy5jID0gW10pXG5cbmxldCBsZW5ndGggcyA9IHMubGVuXG5cbmxldCBpdGVyIGYgcyA9IExpc3QuaXRlciBmIHMuY1xuXG5sZXQgZm9sZCBmIGFjYyBzID0gTGlzdC5mb2xkX2xlZnQgZiBhY2Mgcy5jXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9IExpc3QudG9fc2VxIHMuY1xuXG5sZXQgYWRkX3NlcSBxIGkgPSBTZXEuaXRlciAoZnVuIHggLT4gcHVzaCB4IHEpIGlcblxubGV0IG9mX3NlcSBnID1cbiAgbGV0IHMgPSBjcmVhdGUoKSBpblxuICBhZGRfc2VxIHMgZztcbiAgc1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICBGcmFuY29pcyBQb3R0aWVyLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICBKZXJlbWllIERpbWlubywgSmFuZSBTdHJlZXQgRXVyb3BlICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leGNlcHRpb24gRW1wdHlcblxudHlwZSAnYSBjZWxsID1cbiAgfCBOaWxcbiAgfCBDb25zIG9mIHsgY29udGVudDogJ2E7IG11dGFibGUgbmV4dDogJ2EgY2VsbCB9XG5cbnR5cGUgJ2EgdCA9IHtcbiAgbXV0YWJsZSBsZW5ndGg6IGludDtcbiAgbXV0YWJsZSBmaXJzdDogJ2EgY2VsbDtcbiAgbXV0YWJsZSBsYXN0OiAnYSBjZWxsXG59XG5cbmxldCBjcmVhdGUgKCkgPSB7XG4gIGxlbmd0aCA9IDA7XG4gIGZpcnN0ID0gTmlsO1xuICBsYXN0ID0gTmlsXG59XG5cbmxldCBjbGVhciBxID1cbiAgcS5sZW5ndGggPC0gMDtcbiAgcS5maXJzdCA8LSBOaWw7XG4gIHEubGFzdCA8LSBOaWxcblxubGV0IGFkZCB4IHEgPVxuICBsZXQgY2VsbCA9IENvbnMge1xuICAgIGNvbnRlbnQgPSB4O1xuICAgIG5leHQgPSBOaWxcbiAgfSBpblxuICBtYXRjaCBxLmxhc3Qgd2l0aFxuICB8IE5pbCAtPlxuICAgIHEubGVuZ3RoIDwtIDE7XG4gICAgcS5maXJzdCA8LSBjZWxsO1xuICAgIHEubGFzdCA8LSBjZWxsXG4gIHwgQ29ucyBsYXN0IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggKyAxO1xuICAgIGxhc3QubmV4dCA8LSBjZWxsO1xuICAgIHEubGFzdCA8LSBjZWxsXG5cbmxldCBwdXNoID1cbiAgYWRkXG5cbmxldCBwZWVrIHEgPVxuICBtYXRjaCBxLmZpcnN0IHdpdGhcbiAgfCBOaWwgLT4gcmFpc2UgRW1wdHlcbiAgfCBDb25zIHsgY29udGVudCB9IC0+IGNvbnRlbnRcblxubGV0IHBlZWtfb3B0IHEgPVxuICBtYXRjaCBxLmZpcnN0IHdpdGhcbiAgfCBOaWwgLT4gTm9uZVxuICB8IENvbnMgeyBjb250ZW50IH0gLT4gU29tZSBjb250ZW50XG5cbmxldCB0b3AgPVxuICBwZWVrXG5cbmxldCB0YWtlIHEgPVxuICBtYXRjaCBxLmZpcnN0IHdpdGhcbiAgfCBOaWwgLT4gcmFpc2UgRW1wdHlcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IC0+XG4gICAgY2xlYXIgcTtcbiAgICBjb250ZW50XG4gIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgIHEubGVuZ3RoIDwtIHEubGVuZ3RoIC0gMTtcbiAgICBxLmZpcnN0IDwtIG5leHQ7XG4gICAgY29udGVudFxuXG5sZXQgdGFrZV9vcHQgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiBOb25lXG4gIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSAtPlxuICAgIGNsZWFyIHE7XG4gICAgU29tZSBjb250ZW50XG4gIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgIHEubGVuZ3RoIDwtIHEubGVuZ3RoIC0gMTtcbiAgICBxLmZpcnN0IDwtIG5leHQ7XG4gICAgU29tZSBjb250ZW50XG5cbmxldCBwb3AgPVxuICB0YWtlXG5cbmxldCBjb3B5ID1cbiAgbGV0IHJlYyBjb3B5IHFfcmVzIHByZXYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gcV9yZXMubGFzdCA8LSBwcmV2OyBxX3Jlc1xuICAgIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgICAgbGV0IHJlcyA9IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gaW5cbiAgICAgIGJlZ2luIG1hdGNoIHByZXYgd2l0aFxuICAgICAgfCBOaWwgLT4gcV9yZXMuZmlyc3QgPC0gcmVzXG4gICAgICB8IENvbnMgcCAtPiBwLm5leHQgPC0gcmVzXG4gICAgICBlbmQ7XG4gICAgICBjb3B5IHFfcmVzIHJlcyBuZXh0XG4gIGluXG4gIGZ1biBxIC0+IGNvcHkgeyBsZW5ndGggPSBxLmxlbmd0aDsgZmlyc3QgPSBOaWw7IGxhc3QgPSBOaWwgfSBOaWwgcS5maXJzdFxuXG5sZXQgaXNfZW1wdHkgcSA9XG4gIHEubGVuZ3RoID0gMFxuXG5sZXQgbGVuZ3RoIHEgPVxuICBxLmxlbmd0aFxuXG5sZXQgaXRlciA9XG4gIGxldCByZWMgaXRlciBmIGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+ICgpXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBmIGNvbnRlbnQ7XG4gICAgICBpdGVyIGYgbmV4dFxuICBpblxuICBmdW4gZiBxIC0+IGl0ZXIgZiBxLmZpcnN0XG5cbmxldCBmb2xkID1cbiAgbGV0IHJlYyBmb2xkIGYgYWNjdSBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBhY2N1XG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgYWNjdSA9IGYgYWNjdSBjb250ZW50IGluXG4gICAgICBmb2xkIGYgYWNjdSBuZXh0XG4gIGluXG4gIGZ1biBmIGFjY3UgcSAtPiBmb2xkIGYgYWNjdSBxLmZpcnN0XG5cbmxldCB0cmFuc2ZlciBxMSBxMiA9XG4gIGlmIHExLmxlbmd0aCA+IDAgdGhlblxuICAgIG1hdGNoIHEyLmxhc3Qgd2l0aFxuICAgIHwgTmlsIC0+XG4gICAgICBxMi5sZW5ndGggPC0gcTEubGVuZ3RoO1xuICAgICAgcTIuZmlyc3QgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuICAgIHwgQ29ucyBsYXN0IC0+XG4gICAgICBxMi5sZW5ndGggPC0gcTIubGVuZ3RoICsgcTEubGVuZ3RoO1xuICAgICAgbGFzdC5uZXh0IDwtIHExLmZpcnN0O1xuICAgICAgcTIubGFzdCA8LSBxMS5sYXN0O1xuICAgICAgY2xlYXIgcTFcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBxID1cbiAgbGV0IHJlYyBhdXggYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgIHwgTmlsIC0+IFNlcS5OaWxcbiAgICB8IENvbnMgeyBjb250ZW50PXg7IG5leHQ7IH0gLT4gU2VxLkNvbnMgKHgsIGF1eCBuZXh0KVxuICBpblxuICBhdXggcS5maXJzdFxuXG5sZXQgYWRkX3NlcSBxIGkgPSBTZXEuaXRlciAoZnVuIHggLT4gcHVzaCB4IHEpIGlcblxubGV0IG9mX3NlcSBnID1cbiAgbGV0IHEgPSBjcmVhdGUoKSBpblxuICBhZGRfc2VxIHEgZztcbiAgcVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBJbnRlcm5hbHMgb2YgZm9yY2luZyBsYXp5IHZhbHVlcy4gKilcblxudHlwZSAnYSB0ID0gJ2EgbGF6eV90XG5cbmV4Y2VwdGlvbiBVbmRlZmluZWRcblxubGV0IHJhaXNlX3VuZGVmaW5lZCA9IE9iai5yZXByIChmdW4gKCkgLT4gcmFpc2UgVW5kZWZpbmVkKVxuXG5leHRlcm5hbCBtYWtlX2ZvcndhcmQgOiBPYmoudCAtPiBPYmoudCAtPiB1bml0ID0gXCJjYW1sX29ial9tYWtlX2ZvcndhcmRcIlxuXG4oKiBBc3N1bWUgW2Jsa10gaXMgYSBibG9jayB3aXRoIHRhZyBsYXp5ICopXG5sZXQgZm9yY2VfbGF6eV9ibG9jayAoYmxrIDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IGNsb3N1cmUgPSAoT2JqLm9iaiAoT2JqLmZpZWxkIChPYmoucmVwciBibGspIDApIDogdW5pdCAtPiAnYXJnKSBpblxuICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgcmFpc2VfdW5kZWZpbmVkO1xuICB0cnlcbiAgICBsZXQgcmVzdWx0ID0gY2xvc3VyZSAoKSBpblxuICAgIG1ha2VfZm9yd2FyZCAoT2JqLnJlcHIgYmxrKSAoT2JqLnJlcHIgcmVzdWx0KTtcbiAgICByZXN1bHRcbiAgd2l0aCBlIC0+XG4gICAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIChPYmoucmVwciAoZnVuICgpIC0+IHJhaXNlIGUpKTtcbiAgICByYWlzZSBlXG5cblxuKCogQXNzdW1lIFtibGtdIGlzIGEgYmxvY2sgd2l0aCB0YWcgbGF6eSAqKVxubGV0IGZvcmNlX3ZhbF9sYXp5X2Jsb2NrIChibGsgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgY2xvc3VyZSA9IChPYmoub2JqIChPYmouZmllbGQgKE9iai5yZXByIGJsaykgMCkgOiB1bml0IC0+ICdhcmcpIGluXG4gIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCByYWlzZV91bmRlZmluZWQ7XG4gIGxldCByZXN1bHQgPSBjbG9zdXJlICgpIGluXG4gIG1ha2VfZm9yd2FyZCAoT2JqLnJlcHIgYmxrKSAoT2JqLnJlcHIgcmVzdWx0KTtcbiAgcmVzdWx0XG5cblxuKCogW2ZvcmNlXSBpcyBub3QgdXNlZCwgc2luY2UgW0xhenkuZm9yY2VdIGlzIGRlY2xhcmVkIGFzIGEgcHJpbWl0aXZlXG4gICB3aG9zZSBjb2RlIGlubGluZXMgdGhlIHRhZyB0ZXN0cyBvZiBpdHMgYXJndW1lbnQsIGV4Y2VwdCB3aGVuIGFmbFxuICAgaW5zdHJ1bWVudGF0aW9uIGlzIHR1cm5lZCBvbi4gKilcblxubGV0IGZvcmNlIChsenYgOiAnYXJnIGxhenlfdCkgPVxuICAoKiBVc2luZyBbU3lzLm9wYXF1ZV9pZGVudGl0eV0gcHJldmVudHMgdHdvIHBvdGVudGlhbCBwcm9ibGVtczpcbiAgICAgLSBJZiB0aGUgdmFsdWUgaXMga25vd24gdG8gaGF2ZSBGb3J3YXJkX3RhZywgdGhlbiBpdHMgdGFnIGNvdWxkIGhhdmVcbiAgICAgICBjaGFuZ2VkIGR1cmluZyBHQywgc28gdGhhdCBpbmZvcm1hdGlvbiBtdXN0IGJlIGZvcmdvdHRlbiAoc2VlIEdQUiM3MTNcbiAgICAgICBhbmQgaXNzdWUgIzczMDEpXG4gICAgIC0gSWYgdGhlIHZhbHVlIGlzIGtub3duIHRvIGJlIGltbXV0YWJsZSwgdGhlbiBpZiB0aGUgY29tcGlsZXJcbiAgICAgICBjYW5ub3QgcHJvdmUgdGhhdCB0aGUgbGFzdCBicmFuY2ggaXMgbm90IHRha2VuIGl0IHdpbGwgaXNzdWUgYVxuICAgICAgIHdhcm5pbmcgNTkgKG1vZGlmaWNhdGlvbiBvZiBhbiBpbW11dGFibGUgdmFsdWUpICopXG4gIGxldCBsenYgPSBTeXMub3BhcXVlX2lkZW50aXR5IGx6diBpblxuICBsZXQgeCA9IE9iai5yZXByIGx6diBpblxuICBsZXQgdCA9IE9iai50YWcgeCBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHRoZW4gKE9iai5vYmogKE9iai5maWVsZCB4IDApIDogJ2FyZykgZWxzZVxuICBpZiB0IDw+IE9iai5sYXp5X3RhZyB0aGVuIChPYmoub2JqIHggOiAnYXJnKVxuICBlbHNlIGZvcmNlX2xhenlfYmxvY2sgbHp2XG5cblxubGV0IGZvcmNlX3ZhbCAobHp2IDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IHggPSBPYmoucmVwciBsenYgaW5cbiAgbGV0IHQgPSBPYmoudGFnIHggaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB0aGVuIChPYmoub2JqIChPYmouZmllbGQgeCAwKSA6ICdhcmcpIGVsc2VcbiAgaWYgdCA8PiBPYmoubGF6eV90YWcgdGhlbiAoT2JqLm9iaiB4IDogJ2FyZylcbiAgZWxzZSBmb3JjZV92YWxfbGF6eV9ibG9jayBsenZcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtMYXp5XTogZGVmZXJyZWQgY29tcHV0YXRpb25zICopXG5cblxuKCpcbiAgIFdBUk5JTkc6IHNvbWUgcHVycGxlIG1hZ2ljIGlzIGdvaW5nIG9uIGhlcmUuICBEbyBub3QgdGFrZSB0aGlzIGZpbGVcbiAgIGFzIGFuIGV4YW1wbGUgb2YgaG93IHRvIHByb2dyYW0gaW4gT0NhbWwuXG4qKVxuXG5cbigqIFdlIG1ha2UgdXNlIG9mIHR3byBzcGVjaWFsIHRhZ3MgcHJvdmlkZWQgYnkgdGhlIHJ1bnRpbWU6XG4gICBbbGF6eV90YWddIGFuZCBbZm9yd2FyZF90YWddLlxuXG4gICBBIHZhbHVlIG9mIHR5cGUgWydhIExhenkudF0gY2FuIGJlIG9uZSBvZiB0aHJlZSB0aGluZ3M6XG4gICAxLiBBIGJsb2NrIG9mIHNpemUgMSB3aXRoIHRhZyBbbGF6eV90YWddLiAgSXRzIGZpZWxkIGlzIGEgY2xvc3VyZSBvZlxuICAgICAgdHlwZSBbdW5pdCAtPiAnYV0gdGhhdCBjb21wdXRlcyB0aGUgdmFsdWUuXG4gICAyLiBBIGJsb2NrIG9mIHNpemUgMSB3aXRoIHRhZyBbZm9yd2FyZF90YWddLiAgSXRzIGZpZWxkIGlzIHRoZSB2YWx1ZVxuICAgICAgb2YgdHlwZSBbJ2FdIHRoYXQgd2FzIGNvbXB1dGVkLlxuICAgMy4gQW55dGhpbmcgZWxzZSBleGNlcHQgYSBmbG9hdC4gIFRoaXMgaGFzIHR5cGUgWydhXSBhbmQgaXMgdGhlIHZhbHVlXG4gICAgICB0aGF0IHdhcyBjb21wdXRlZC5cbiAgIEV4Y2VwdGlvbnMgYXJlIHN0b3JlZCBpbiBmb3JtYXQgKDEpLlxuICAgVGhlIEdDIHdpbGwgbWFnaWNhbGx5IGNoYW5nZSB0aGluZ3MgZnJvbSAoMikgdG8gKDMpIGFjY29yZGluZyB0byBpdHNcbiAgIGZhbmN5LlxuXG4gICBJZiBPQ2FtbCB3YXMgY29uZmlndXJlZCB3aXRoIHRoZSAtZmxhdC1mbG9hdC1hcnJheSBvcHRpb24gKHdoaWNoIGlzXG4gICBjdXJyZW50bHkgdGhlIGRlZmF1bHQpLCB0aGUgZm9sbG93aW5nIGlzIGFsc28gdHJ1ZTpcbiAgIFdlIGNhbm5vdCB1c2UgcmVwcmVzZW50YXRpb24gKDMpIGZvciBhIFtmbG9hdCBMYXp5LnRdIGJlY2F1c2VcbiAgIFtjYW1sX21ha2VfYXJyYXldIGFzc3VtZXMgdGhhdCBvbmx5IGEgW2Zsb2F0XSB2YWx1ZSBjYW4gaGF2ZSB0YWdcbiAgIFtEb3VibGVfdGFnXS5cblxuICAgV2UgaGF2ZSB0byB1c2UgdGhlIGJ1aWx0LWluIHR5cGUgY29uc3RydWN0b3IgW2xhenlfdF0gdG9cbiAgIGxldCB0aGUgY29tcGlsZXIgaW1wbGVtZW50IHRoZSBzcGVjaWFsIHR5cGluZyBhbmQgY29tcGlsYXRpb25cbiAgIHJ1bGVzIGZvciB0aGUgW2xhenldIGtleXdvcmQuXG4qKVxuXG50eXBlICdhIHQgPSAnYSBDYW1saW50ZXJuYWxMYXp5LnRcblxuZXhjZXB0aW9uIFVuZGVmaW5lZCA9IENhbWxpbnRlcm5hbExhenkuVW5kZWZpbmVkXG5cbmV4dGVybmFsIG1ha2VfZm9yd2FyZCA6ICdhIC0+ICdhIGxhenlfdCA9IFwiY2FtbF9sYXp5X21ha2VfZm9yd2FyZFwiXG5cbmV4dGVybmFsIGZvcmNlIDogJ2EgdCAtPiAnYSA9IFwiJWxhenlfZm9yY2VcIlxuXG5cbmxldCBmb3JjZV92YWwgPSBDYW1saW50ZXJuYWxMYXp5LmZvcmNlX3ZhbFxuXG5sZXQgZnJvbV9mdW4gKGYgOiB1bml0IC0+ICdhcmcpID1cbiAgbGV0IHggPSBPYmoubmV3X2Jsb2NrIE9iai5sYXp5X3RhZyAxIGluXG4gIE9iai5zZXRfZmllbGQgeCAwIChPYmoucmVwciBmKTtcbiAgKE9iai5vYmogeCA6ICdhcmcgdClcblxubGV0IGZyb21fdmFsICh2IDogJ2FyZykgPVxuICBsZXQgdCA9IE9iai50YWcgKE9iai5yZXByIHYpIGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgfHwgdCA9IE9iai5sYXp5X3RhZyB8fCB0ID0gT2JqLmRvdWJsZV90YWcgdGhlbiBiZWdpblxuICAgIG1ha2VfZm9yd2FyZCB2XG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgKE9iai5tYWdpYyB2IDogJ2FyZyB0KVxuICBlbmRcblxuXG5sZXQgaXNfdmFsIChsIDogJ2FyZyB0KSA9IE9iai50YWcgKE9iai5yZXByIGwpIDw+IE9iai5sYXp5X3RhZ1xuXG5sZXQgbGF6eV9mcm9tX2Z1biA9IGZyb21fZnVuXG5cbmxldCBsYXp5X2Zyb21fdmFsID0gZnJvbV92YWxcblxubGV0IGxhenlfaXNfdmFsID0gaXNfdmFsXG5cblxubGV0IG1hcCBmIHggPVxuICBsYXp5IChmIChmb3JjZSB4KSlcblxubGV0IG1hcF92YWwgZiB4ID1cbiAgaWYgaXNfdmFsIHhcbiAgdGhlbiBsYXp5X2Zyb21fdmFsIChmIChmb3JjZSB4KSlcbiAgZWxzZSBsYXp5IChmIChmb3JjZSB4KSlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgRGFuaWVsIGRlIFJhdWdsYXVkcmUsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAnYSB0ID0gJ2EgY2VsbCBvcHRpb25cbmFuZCAnYSBjZWxsID0geyBtdXRhYmxlIGNvdW50IDogaW50OyBtdXRhYmxlIGRhdGEgOiAnYSBkYXRhIH1cbmFuZCAnYSBkYXRhID1cbiAgICBTZW1wdHlcbiAgfCBTY29ucyBvZiAnYSAqICdhIGRhdGFcbiAgfCBTYXBwIG9mICdhIGRhdGEgKiAnYSBkYXRhXG4gIHwgU2xhenkgb2YgJ2EgZGF0YSBMYXp5LnRcbiAgfCBTZ2VuIG9mICdhIGdlblxuICB8IFNidWZmaW8gOiBidWZmaW8gLT4gY2hhciBkYXRhXG5hbmQgJ2EgZ2VuID0geyBtdXRhYmxlIGN1cnIgOiAnYSBvcHRpb24gb3B0aW9uOyBmdW5jIDogaW50IC0+ICdhIG9wdGlvbiB9XG5hbmQgYnVmZmlvID1cbiAgeyBpYyA6IGluX2NoYW5uZWw7IGJ1ZmYgOiBieXRlczsgbXV0YWJsZSBsZW4gOiBpbnQ7IG11dGFibGUgaW5kIDogaW50IH1cblxuZXhjZXB0aW9uIEZhaWx1cmVcbmV4Y2VwdGlvbiBFcnJvciBvZiBzdHJpbmdcblxubGV0IGNvdW50ID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IDBcbiAgfCBTb21lIHsgY291bnQgfSAtPiBjb3VudFxubGV0IGRhdGEgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gU2VtcHR5XG4gIHwgU29tZSB7IGRhdGEgfSAtPiBkYXRhXG5cbmxldCBmaWxsX2J1ZmYgYiA9XG4gIGIubGVuIDwtIGlucHV0IGIuaWMgYi5idWZmIDAgKEJ5dGVzLmxlbmd0aCBiLmJ1ZmYpOyBiLmluZCA8LSAwXG5cblxubGV0IHJlYyBnZXRfZGF0YSA6IHR5cGUgdi4gaW50IC0+IHYgZGF0YSAtPiB2IGRhdGEgPSBmdW4gY291bnQgZCAtPiBtYXRjaCBkIHdpdGhcbiAoKiBSZXR1cm5zIGVpdGhlciBTZW1wdHkgb3IgU2NvbnMoYSwgXykgZXZlbiB3aGVuIGQgaXMgYSBnZW5lcmF0b3JcbiAgICBvciBhIGJ1ZmZlci4gSW4gdGhvc2UgY2FzZXMsIHRoZSBpdGVtIGEgaXMgc2VlbiBhcyBleHRyYWN0ZWQgZnJvbVxuIHRoZSBnZW5lcmF0b3IvYnVmZmVyLlxuIFRoZSBjb3VudCBwYXJhbWV0ZXIgaXMgdXNlZCBmb3IgY2FsbGluZyBgU2dlbi1mdW5jdGlvbnMnLiAgKilcbiAgIFNlbXB0eSB8IFNjb25zIChfLCBfKSAtPiBkXG4gfCBTYXBwIChkMSwgZDIpIC0+XG4gICAgIGJlZ2luIG1hdGNoIGdldF9kYXRhIGNvdW50IGQxIHdpdGhcbiAgICAgICBTY29ucyAoYSwgZDExKSAtPiBTY29ucyAoYSwgU2FwcCAoZDExLCBkMikpXG4gICAgIHwgU2VtcHR5IC0+IGdldF9kYXRhIGNvdW50IGQyXG4gICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgZW5kXG4gfCBTZ2VuIHtjdXJyID0gU29tZSBOb25lfSAtPiBTZW1wdHlcbiB8IFNnZW4gKHtjdXJyID0gU29tZShTb21lIGEpfSBhcyBnKSAtPlxuICAgICBnLmN1cnIgPC0gTm9uZTsgU2NvbnMoYSwgZClcbiB8IFNnZW4gZyAtPlxuICAgICBiZWdpbiBtYXRjaCBnLmZ1bmMgY291bnQgd2l0aFxuICAgICAgIE5vbmUgLT4gZy5jdXJyIDwtIFNvbWUoTm9uZSk7IFNlbXB0eVxuICAgICB8IFNvbWUgYSAtPiBTY29ucyhhLCBkKVxuICAgICAgICAgKCogV2FybmluZzogYW55b25lIHVzaW5nIGcgdGhpbmtzIHRoYXQgYW4gaXRlbSBoYXMgYmVlbiByZWFkICopXG4gICAgIGVuZFxuIHwgU2J1ZmZpbyBiIC0+XG4gICAgIGlmIGIuaW5kID49IGIubGVuIHRoZW4gZmlsbF9idWZmIGI7XG4gICAgIGlmIGIubGVuID09IDAgdGhlbiBTZW1wdHkgZWxzZVxuICAgICAgIGxldCByID0gQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmYgYi5pbmQgaW5cbiAgICAgICAoKiBXYXJuaW5nOiBhbnlvbmUgdXNpbmcgZyB0aGlua3MgdGhhdCBhbiBpdGVtIGhhcyBiZWVuIHJlYWQgKilcbiAgICAgICBiLmluZCA8LSBzdWNjIGIuaW5kOyBTY29ucyhyLCBkKVxuIHwgU2xhenkgZiAtPiBnZXRfZGF0YSBjb3VudCAoTGF6eS5mb3JjZSBmKVxuXG5cbmxldCByZWMgcGVla19kYXRhIDogdHlwZSB2LiB2IGNlbGwgLT4gdiBvcHRpb24gPSBmdW4gcyAtPlxuICgqIGNvbnN1bHQgdGhlIGZpcnN0IGl0ZW0gb2YgcyAqKVxuIG1hdGNoIHMuZGF0YSB3aXRoXG4gICBTZW1wdHkgLT4gTm9uZVxuIHwgU2NvbnMgKGEsIF8pIC0+IFNvbWUgYVxuIHwgU2FwcCAoXywgXykgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZ2V0X2RhdGEgcy5jb3VudCBzLmRhdGEgd2l0aFxuICAgICAgIFNjb25zKGEsIF8pIGFzIGQgLT4gcy5kYXRhIDwtIGQ7IFNvbWUgYVxuICAgICB8IFNlbXB0eSAtPiBOb25lXG4gICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgZW5kXG4gfCBTbGF6eSBmIC0+IHMuZGF0YSA8LSAoTGF6eS5mb3JjZSBmKTsgcGVla19kYXRhIHNcbiB8IFNnZW4ge2N1cnIgPSBTb21lIGF9IC0+IGFcbiB8IFNnZW4gZyAtPiBsZXQgeCA9IGcuZnVuYyBzLmNvdW50IGluIGcuY3VyciA8LSBTb21lIHg7IHhcbiB8IFNidWZmaW8gYiAtPlxuICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gYmVnaW4gcy5kYXRhIDwtIFNlbXB0eTsgTm9uZSBlbmRcbiAgICAgZWxzZSBTb21lIChCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZiBiLmluZClcblxuXG5sZXQgcGVlayA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBzIC0+IHBlZWtfZGF0YSBzXG5cblxubGV0IHJlYyBqdW5rX2RhdGEgOiB0eXBlIHYuIHYgY2VsbCAtPiB1bml0ID0gZnVuIHMgLT5cbiAgbWF0Y2ggcy5kYXRhIHdpdGhcbiAgICBTY29ucyAoXywgZCkgLT4gcy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgcy5kYXRhIDwtIGRcbiAgfCBTZ2VuICh7Y3VyciA9IFNvbWUgX30gYXMgZykgLT4gcy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgZy5jdXJyIDwtIE5vbmVcbiAgfCBTYnVmZmlvIGIgLT5cbiAgICAgIGlmIGIuaW5kID49IGIubGVuIHRoZW4gZmlsbF9idWZmIGI7XG4gICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gcy5kYXRhIDwtIFNlbXB0eVxuICAgICAgZWxzZSAocy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgYi5pbmQgPC0gc3VjYyBiLmluZClcbiAgfCBfIC0+XG4gICAgICBtYXRjaCBwZWVrX2RhdGEgcyB3aXRoXG4gICAgICAgIE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBfIC0+IGp1bmtfZGF0YSBzXG5cblxubGV0IGp1bmsgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGRhdGEgLT4ganVua19kYXRhIGRhdGFcblxubGV0IHJlYyBuZ2V0X2RhdGEgbiBzID1cbiAgaWYgbiA8PSAwIHRoZW4gW10sIHMuZGF0YSwgMFxuICBlbHNlXG4gICAgbWF0Y2ggcGVla19kYXRhIHMgd2l0aFxuICAgICAgU29tZSBhIC0+XG4gICAgICAgIGp1bmtfZGF0YSBzO1xuICAgICAgICBsZXQgKGFsLCBkLCBrKSA9IG5nZXRfZGF0YSAocHJlZCBuKSBzIGluIGEgOjogYWwsIFNjb25zIChhLCBkKSwgc3VjYyBrXG4gICAgfCBOb25lIC0+IFtdLCBzLmRhdGEsIDBcblxuXG5sZXQgbnBlZWtfZGF0YSBuIHMgPVxuICBsZXQgKGFsLCBkLCBsZW4pID0gbmdldF9kYXRhIG4gcyBpblxuICBzLmNvdW50IDwtIChzLmNvdW50IC0gbGVuKTtcbiAgcy5kYXRhIDwtIGQ7XG4gIGFsXG5cblxubGV0IG5wZWVrIG4gPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gW11cbiAgfCBTb21lIGQgLT4gbnBlZWtfZGF0YSBuIGRcblxubGV0IG5leHQgcyA9XG4gIG1hdGNoIHBlZWsgcyB3aXRoXG4gICAgU29tZSBhIC0+IGp1bmsgczsgYVxuICB8IE5vbmUgLT4gcmFpc2UgRmFpbHVyZVxuXG5cbmxldCBlbXB0eSBzID1cbiAgbWF0Y2ggcGVlayBzIHdpdGhcbiAgICBTb21lIF8gLT4gcmFpc2UgRmFpbHVyZVxuICB8IE5vbmUgLT4gKClcblxuXG5sZXQgaXRlciBmIHN0cm0gPVxuICBsZXQgcmVjIGRvX3JlYyAoKSA9XG4gICAgbWF0Y2ggcGVlayBzdHJtIHdpdGhcbiAgICAgIFNvbWUgYSAtPiBqdW5rIHN0cm07IGlnbm9yZShmIGEpOyBkb19yZWMgKClcbiAgICB8IE5vbmUgLT4gKClcbiAgaW5cbiAgZG9fcmVjICgpXG5cblxuKCogU3RyZWFtIGJ1aWxkaW5nIGZ1bmN0aW9ucyAqKVxuXG5sZXQgZnJvbSBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2dlbiB7Y3VyciA9IE5vbmU7IGZ1bmMgPSBmfX1cblxubGV0IG9mX2xpc3QgbCA9XG4gIFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IExpc3QuZm9sZF9yaWdodCAoZnVuIHggbCAtPiBTY29ucyAoeCwgbCkpIGwgU2VtcHR5fVxuXG5cbmxldCBvZl9zdHJpbmcgcyA9XG4gIGxldCBjb3VudCA9IHJlZiAwIGluXG4gIGZyb20gKGZ1biBfIC0+XG4gICAgKCogV2UgY2Fubm90IHVzZSB0aGUgaW5kZXggcGFzc2VkIGJ5IHRoZSBbZnJvbV0gZnVuY3Rpb24gZGlyZWN0bHlcbiAgICAgICBiZWNhdXNlIGl0IHJldHVybnMgdGhlIGN1cnJlbnQgc3RyZWFtIGNvdW50LCB3aXRoIGFic29sdXRlbHkgbm9cbiAgICAgICBndWFyYW50ZWUgdGhhdCBpdCB3aWxsIHN0YXJ0IGZyb20gMC4gRm9yIGV4YW1wbGUsIGluIHRoZSBjYXNlXG4gICAgICAgb2YgW1N0cmVhbS5pY29ucyAnYycgKFN0cmVhbS5mcm9tX3N0cmluZyBcImFiXCIpXSwgdGhlIGZpcnN0XG4gICAgICAgYWNjZXNzIHRvIHRoZSBzdHJpbmcgd2lsbCBiZSBtYWRlIHdpdGggY291bnQgWzFdIGFscmVhZHkuXG4gICAgKilcbiAgICBsZXQgYyA9ICFjb3VudCBpblxuICAgIGlmIGMgPCBTdHJpbmcubGVuZ3RoIHNcbiAgICB0aGVuIChpbmNyIGNvdW50OyBTb21lIHMuW2NdKVxuICAgIGVsc2UgTm9uZSlcblxuXG5sZXQgb2ZfYnl0ZXMgcyA9XG4gIGxldCBjb3VudCA9IHJlZiAwIGluXG4gIGZyb20gKGZ1biBfIC0+XG4gICAgbGV0IGMgPSAhY291bnQgaW5cbiAgICBpZiBjIDwgQnl0ZXMubGVuZ3RoIHNcbiAgICB0aGVuIChpbmNyIGNvdW50OyBTb21lIChCeXRlcy5nZXQgcyBjKSlcbiAgICBlbHNlIE5vbmUpXG5cblxubGV0IG9mX2NoYW5uZWwgaWMgPVxuICBTb21lIHtjb3VudCA9IDA7XG4gICAgICAgIGRhdGEgPSBTYnVmZmlvIHtpYyA9IGljOyBidWZmID0gQnl0ZXMuY3JlYXRlIDQwOTY7IGxlbiA9IDA7IGluZCA9IDB9fVxuXG5cbigqIFN0cmVhbSBleHByZXNzaW9ucyBidWlsZGVycyAqKVxuXG5sZXQgaWFwcCBpIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTYXBwIChkYXRhIGksIGRhdGEgcyl9XG5sZXQgaWNvbnMgaSBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2NvbnMgKGksIGRhdGEgcyl9XG5sZXQgaXNpbmcgaSA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNjb25zIChpLCBTZW1wdHkpfVxuXG5sZXQgbGFwcCBmIHMgPVxuICBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTYXBwIChkYXRhIChmICgpKSwgZGF0YSBzKSkpfVxuXG5sZXQgbGNvbnMgZiBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2NvbnMgKGYgKCksIGRhdGEgcykpKX1cbmxldCBsc2luZyBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2NvbnMgKGYgKCksIFNlbXB0eSkpKX1cblxubGV0IHNlbXB0eSA9IE5vbmVcbmxldCBzbGF6eSBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoZGF0YSAoZiAoKSkpKX1cblxuKCogRm9yIGRlYnVnZ2luZyB1c2UgKilcblxubGV0IHJlYyBkdW1wIDogdHlwZSB2LiAodiAtPiB1bml0KSAtPiB2IHQgLT4gdW5pdCA9IGZ1biBmIHMgLT5cbiAgcHJpbnRfc3RyaW5nIFwie2NvdW50ID0gXCI7XG4gIHByaW50X2ludCAoY291bnQgcyk7XG4gIHByaW50X3N0cmluZyBcIjsgZGF0YSA9IFwiO1xuICBkdW1wX2RhdGEgZiAoZGF0YSBzKTtcbiAgcHJpbnRfc3RyaW5nIFwifVwiO1xuICBwcmludF9uZXdsaW5lICgpXG5hbmQgZHVtcF9kYXRhIDogdHlwZSB2LiAodiAtPiB1bml0KSAtPiB2IGRhdGEgLT4gdW5pdCA9IGZ1biBmIC0+XG4gIGZ1bmN0aW9uXG4gICAgU2VtcHR5IC0+IHByaW50X3N0cmluZyBcIlNlbXB0eVwiXG4gIHwgU2NvbnMgKGEsIGQpIC0+XG4gICAgICBwcmludF9zdHJpbmcgXCJTY29ucyAoXCI7XG4gICAgICBmIGE7XG4gICAgICBwcmludF9zdHJpbmcgXCIsIFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDtcbiAgICAgIHByaW50X3N0cmluZyBcIilcIlxuICB8IFNhcHAgKGQxLCBkMikgLT5cbiAgICAgIHByaW50X3N0cmluZyBcIlNhcHAgKFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDE7XG4gICAgICBwcmludF9zdHJpbmcgXCIsIFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDI7XG4gICAgICBwcmludF9zdHJpbmcgXCIpXCJcbiAgfCBTbGF6eSBfIC0+IHByaW50X3N0cmluZyBcIlNsYXp5XCJcbiAgfCBTZ2VuIF8gLT4gcHJpbnRfc3RyaW5nIFwiU2dlblwiXG4gIHwgU2J1ZmZpbyBfIC0+IHByaW50X3N0cmluZyBcIlNidWZmaW9cIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgUGllcnJlIFdlaXMgYW5kIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5OSBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFeHRlbnNpYmxlIGJ1ZmZlcnMgKilcblxudHlwZSB0ID1cbiB7bXV0YWJsZSBidWZmZXIgOiBieXRlcztcbiAgbXV0YWJsZSBwb3NpdGlvbiA6IGludDtcbiAgbXV0YWJsZSBsZW5ndGggOiBpbnQ7XG4gIGluaXRpYWxfYnVmZmVyIDogYnl0ZXN9XG4oKiBJbnZhcmlhbnRzOiBhbGwgcGFydHMgb2YgdGhlIGNvZGUgcHJlc2VydmUgdGhlIGludmFyaWFudHMgdGhhdDpcbiAgIC0gWzAgPD0gYi5wb3NpdGlvbiA8PSBiLmxlbmd0aF1cbiAgIC0gW2IubGVuZ3RoID0gQnl0ZXMubGVuZ3RoIGIuYnVmZmVyXVxuXG4gICBOb3RlIGluIHBhcnRpY3VsYXIgdGhhdCBbYi5wb3NpdGlvbiA9IGIubGVuZ3RoXSBpcyBsZWdhbCxcbiAgIGl0IG1lYW5zIHRoYXQgdGhlIGJ1ZmZlciBpcyBmdWxsIGFuZCB3aWxsIGhhdmUgdG8gYmUgZXh0ZW5kZWRcbiAgIGJlZm9yZSBhbnkgZnVydGhlciBhZGRpdGlvbi4gKilcblxubGV0IGNyZWF0ZSBuID1cbiBsZXQgbiA9IGlmIG4gPCAxIHRoZW4gMSBlbHNlIG4gaW5cbiBsZXQgbiA9IGlmIG4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiBTeXMubWF4X3N0cmluZ19sZW5ndGggZWxzZSBuIGluXG4gbGV0IHMgPSBCeXRlcy5jcmVhdGUgbiBpblxuIHtidWZmZXIgPSBzOyBwb3NpdGlvbiA9IDA7IGxlbmd0aCA9IG47IGluaXRpYWxfYnVmZmVyID0gc31cblxubGV0IGNvbnRlbnRzIGIgPSBCeXRlcy5zdWJfc3RyaW5nIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxubGV0IHRvX2J5dGVzIGIgPSBCeXRlcy5zdWIgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5cbmxldCBzdWIgYiBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGIucG9zaXRpb24gLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5zdWJcIlxuICBlbHNlIEJ5dGVzLnN1Yl9zdHJpbmcgYi5idWZmZXIgb2ZzIGxlblxuXG5cbmxldCBibGl0IHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IHNyY29mZiA8IDAgfHwgc3Jjb2ZmID4gc3JjLnBvc2l0aW9uIC0gbGVuXG4gICAgICAgICAgICAgfHwgZHN0b2ZmIDwgMCB8fCBkc3RvZmYgPiAoQnl0ZXMubGVuZ3RoIGRzdCkgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5ibGl0XCJcbiAgZWxzZVxuICAgIEJ5dGVzLnVuc2FmZV9ibGl0IHNyYy5idWZmZXIgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuXG5cblxubGV0IG50aCBiIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID49IGIucG9zaXRpb24gdGhlblxuICAgaW52YWxpZF9hcmcgXCJCdWZmZXIubnRoXCJcbiAgZWxzZSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZmVyIG9mc1xuXG5cbmxldCBsZW5ndGggYiA9IGIucG9zaXRpb25cblxubGV0IGNsZWFyIGIgPSBiLnBvc2l0aW9uIDwtIDBcblxubGV0IHJlc2V0IGIgPVxuICBiLnBvc2l0aW9uIDwtIDA7XG4gIGIuYnVmZmVyIDwtIGIuaW5pdGlhbF9idWZmZXI7XG4gIGIubGVuZ3RoIDwtIEJ5dGVzLmxlbmd0aCBiLmJ1ZmZlclxuXG4oKiBbcmVzaXplIGIgbW9yZV0gZW5zdXJlcyB0aGF0IFtiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmxlbmd0aF0gaG9sZHNcbiAgIGJ5IGR5bmFtaWNhbGx5IGV4dGVuZGluZyBbYi5idWZmZXJdIGlmIG5lY2Vzc2FyeSAtLSBhbmQgdGh1c1xuICAgaW5jcmVhc2luZyBbYi5sZW5ndGhdLlxuXG4gICBJbiBwYXJ0aWN1bGFyLCBhZnRlciBbcmVzaXplIGIgbW9yZV0gaXMgY2FsbGVkLCBhIGRpcmVjdCBhY2Nlc3Mgb2ZcbiAgIHNpemUgW21vcmVdIGF0IFtiLnBvc2l0aW9uXSB3aWxsIGFsd2F5cyBiZSBpbi1ib3VuZHMsIHNvIHRoYXRcbiAgICh1bnNhZmVfe2dldCxzZXR9KSBtYXkgYmUgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG4qKVxubGV0IHJlc2l6ZSBiIG1vcmUgPVxuICBsZXQgb2xkX3BvcyA9IGIucG9zaXRpb24gaW5cbiAgbGV0IG9sZF9sZW4gPSBiLmxlbmd0aCBpblxuICBsZXQgbmV3X2xlbiA9IHJlZiBvbGRfbGVuIGluXG4gIHdoaWxlIG9sZF9wb3MgKyBtb3JlID4gIW5ld19sZW4gZG8gbmV3X2xlbiA6PSAyICogIW5ld19sZW4gZG9uZTtcbiAgaWYgIW5ld19sZW4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiBiZWdpblxuICAgIGlmIG9sZF9wb3MgKyBtb3JlIDw9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgIHRoZW4gbmV3X2xlbiA6PSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICBlbHNlIGZhaWx3aXRoIFwiQnVmZmVyLmFkZDogY2Fubm90IGdyb3cgYnVmZmVyXCJcbiAgZW5kO1xuICBsZXQgbmV3X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAhbmV3X2xlbiBpblxuICAoKiBQUiM2MTQ4OiBsZXQncyBrZWVwIHVzaW5nIFtibGl0XSByYXRoZXIgdGhhbiBbdW5zYWZlX2JsaXRdIGluXG4gICAgIHRoaXMgdHJpY2t5IGZ1bmN0aW9uIHRoYXQgaXMgc2xvdyBhbnl3YXkuICopXG4gIEJ5dGVzLmJsaXQgYi5idWZmZXIgMCBuZXdfYnVmZmVyIDAgYi5wb3NpdGlvbjtcbiAgYi5idWZmZXIgPC0gbmV3X2J1ZmZlcjtcbiAgYi5sZW5ndGggPC0gIW5ld19sZW47XG4gIGFzc2VydCAoYi5wb3NpdGlvbiArIG1vcmUgPD0gYi5sZW5ndGgpO1xuICBhc3NlcnQgKG9sZF9wb3MgKyBtb3JlIDw9IGIubGVuZ3RoKTtcbiAgKClcbiAgKCogTm90ZTogdGhlcmUgYXJlIHZhcmlvdXMgc2l0dWF0aW9ucyAocHJlZW1wdGl2ZSB0aHJlYWRzLCBzaWduYWxzIGFuZFxuICAgICBnYyBmaW5hbGl6ZXJzKSB3aGVyZSBPQ2FtbCBjb2RlIG1heSBiZSBydW4gYXN5bmNocm9ub3VzbHk7IGluXG4gICAgIHBhcnRpY3VsYXIsIHRoZXJlIG1heSBiZSBhIHJhY2Ugd2l0aCBhbm90aGVyIHVzZXIgb2YgW2JdLCBjaGFuZ2luZ1xuICAgICBpdHMgbXV0YWJsZSBmaWVsZHMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgW3Jlc2l6ZV0gY2FsbC4gVGhlIEJ1ZmZlclxuICAgICBtb2R1bGUgZG9lcyBub3QgcHJvdmlkZSBhbnkgY29ycmVjdG5lc3MgZ3VhcmFudGVlIGlmIHRoYXQgaGFwcGVucyxcbiAgICAgYnV0IHdlIG11c3Qgc3RpbGwgZW5zdXJlIHRoYXQgdGhlIGRhdGFzdHJ1Y3R1cmUgaW52YXJpYW50cyBob2xkIGZvclxuICAgICBtZW1vcnktc2FmZXR5IC0tIGFzIHdlIHBsYW4gdG8gdXNlIFt1bnNhZmVfe2dldCxzZXR9XS5cblxuICAgICBUaGVyZSBhcmUgdHdvIHBvdGVudGlhbCBhbGxvY2F0aW9uIHBvaW50cyBpbiB0aGlzIGZ1bmN0aW9uLFxuICAgICBbcmVmXSBhbmQgW0J5dGVzLmNyZWF0ZV0sIGJ1dCBhbGwgcmVhZHMgYW5kIHdyaXRlcyB0byB0aGUgZmllbGRzXG4gICAgIG9mIFtiXSBoYXBwZW4gYmVmb3JlIGJvdGggb2YgdGhlbSBvciBhZnRlciBib3RoIG9mIHRoZW0uXG5cbiAgICAgV2UgdGhlcmVmb3JlIGFzc3VtZSB0aGF0IFtiLnBvc2l0aW9uXSBtYXkgY2hhbmdlIGF0IHRoZXNlIGFsbG9jYXRpb25zLFxuICAgICBhbmQgY2hlY2sgdGhhdCB0aGUgW2IucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoXSBwb3N0Y29uZGl0aW9uXG4gICAgIGhvbGRzIGZvciBib3RoIHZhbHVlcyBvZiBbYi5wb3NpdGlvbl0sIGJlZm9yZSBvciBhZnRlciB0aGUgZnVuY3Rpb25cbiAgICAgaXMgY2FsbGVkLiBNb3JlIHByZWNpc2VseSwgdGhlIGZvbGxvd2luZyBpbnZhcmlhbnRzIG11c3QgaG9sZCBpZiB0aGVcbiAgICAgZnVuY3Rpb24gcmV0dXJucyBjb3JyZWN0bHksIGluIGFkZGl0aW9uIHRvIHRoZSB1c3VhbCBidWZmZXIgaW52YXJpYW50czpcbiAgICAgLSBbb2xkKGIucG9zaXRpb24pICsgbW9yZSA8PSBuZXcoYi5sZW5ndGgpXVxuICAgICAtIFtuZXcoYi5wb3NpdGlvbikgKyBtb3JlIDw9IG5ldyhiLmxlbmd0aCldXG4gICAgIC0gW29sZChiLmxlbmd0aCkgPD0gbmV3KGIubGVuZ3RoKV1cblxuICAgICBOb3RlOiBbYi5wb3NpdGlvbiArIG1vcmUgPD0gb2xkKGIubGVuZ3RoKV0gZG9lcyAqbm90KlxuICAgICBob2xkIGluIGdlbmVyYWwsIGFzIGl0IGlzIHByZWNpc2VseSB0aGUgY2FzZSB3aGVyZSB5b3UgbmVlZFxuICAgICB0byBjYWxsIFtyZXNpemVdIHRvIGluY3JlYXNlIFtiLmxlbmd0aF0uXG5cbiAgICAgTm90ZTogW2Fzc2VydF0gYWJvdmUgZG9lcyBub3QgbWVhbiB0aGF0IHdlIGtub3cgdGhlIGNvbmRpdGlvbnNcbiAgICAgYWx3YXlzIGhvbGQsIGJ1dCB0aGF0IHRoZSBmdW5jdGlvbiBtYXkgcmV0dXJuIGNvcnJlY3RseVxuICAgICBvbmx5IGlmIHRoZXkgaG9sZC5cblxuICAgICBOb3RlOiB0aGUgb3RoZXIgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIGRvZXMgbm90IG5lZWRcbiAgICAgdG8gYmUgY2hlY2tlZCB3aXRoIHRoaXMgbGV2ZWwgb2Ygc2NydXRpbnksIGdpdmVuIHRoYXQgdGhleVxuICAgICByZWFkL3dyaXRlIHRoZSBidWZmZXIgaW1tZWRpYXRlbHkgYWZ0ZXIgY2hlY2tpbmcgdGhhdFxuICAgICBbYi5wb3NpdGlvbiArIG1vcmUgPD0gYi5sZW5ndGhdIGhvbGQgb3IgY2FsbGluZyBbcmVzaXplXS5cbiAgKilcblxubGV0IGFkZF9jaGFyIGIgYyA9XG4gIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gIGlmIHBvcyA+PSBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDE7XG4gIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgcG9zIGM7XG4gIGIucG9zaXRpb24gPC0gcG9zICsgMVxuXG4gbGV0IGFkZF91dGZfOF91Y2hhciBiIHUgPSBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gfCB1IHdoZW4gdSA8PSAweDAwN0YgLT5cbiAgICAgYWRkX2NoYXIgYiAoQ2hhci51bnNhZmVfY2hyIHUpXG4gfCB1IHdoZW4gdSA8PSAweDA3RkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgIClcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweEMwIGxvciAodSBsc3IgNikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSlcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAodSBsYW5kIDB4M0YpKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgMlxuIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDMgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDM7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHhFMCBsb3IgKHUgbHNyIDEyKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICgodSBsc3IgNikgbGFuZCAweDNGKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAzXG4gfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyA0ID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4RjAgbG9yICh1IGxzciAxOCkpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSlcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAoKHUgbHNyIDEyKSBsYW5kIDB4M0YpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKCh1IGxzciA2KSBsYW5kIDB4M0YpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDMpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDRcbiB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiBsZXQgYWRkX3V0Zl8xNmJlX3VjaGFyIGIgdSA9IG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAyID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyICh1IGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKHUgbGFuZCAweEZGKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgMlxuIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgbGV0IHUnID0gdSAtIDB4MTAwMDAgaW5cbiAgICAgbGV0IGhpID0gMHhEODAwIGxvciAodScgbHNyIDEwKSBpblxuICAgICBsZXQgbG8gPSAweERDMDAgbG9yICh1JyBsYW5kIDB4M0ZGKSBpblxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyA0ID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyIChoaSBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyIChoaSBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMikgKENoYXIudW5zYWZlX2NociAobG8gbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMykgKENoYXIudW5zYWZlX2NociAobG8gbGFuZCAweEZGKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgNFxuIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuIGxldCBhZGRfdXRmXzE2bGVfdWNoYXIgYiB1ID0gbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDIgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKHUgbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKHUgbHNyIDgpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAyXG4gfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICBsZXQgdScgPSB1IC0gMHgxMDAwMCBpblxuICAgICBsZXQgaGkgPSAweEQ4MDAgbG9yICh1JyBsc3IgMTApIGluXG4gICAgIGxldCBsbyA9IDB4REMwMCBsb3IgKHUnIGxhbmQgMHgzRkYpIGluXG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDQgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyIChoaSBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMykgKENoYXIudW5zYWZlX2NociAobG8gbHNyIDgpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyA0XG4gfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgYWRkX3N1YnN0cmluZyBiIHMgb2Zmc2V0IGxlbiA9XG4gIGlmIG9mZnNldCA8IDAgfHwgbGVuIDwgMCB8fCBvZmZzZXQgPiBTdHJpbmcubGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5hZGRfc3Vic3RyaW5nL2FkZF9zdWJieXRlc1wiO1xuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIGxlbiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIGxlbjtcbiAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIHMgb2Zmc2V0IGIuYnVmZmVyIGIucG9zaXRpb24gbGVuO1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX3N1YmJ5dGVzIGIgcyBvZmZzZXQgbGVuID1cbiAgYWRkX3N1YnN0cmluZyBiIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMpIG9mZnNldCBsZW5cblxubGV0IGFkZF9zdHJpbmcgYiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIGxlbiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIGxlbjtcbiAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIHMgMCBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbjtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9ieXRlcyBiIHMgPSBhZGRfc3RyaW5nIGIgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcylcblxubGV0IGFkZF9idWZmZXIgYiBicyA9XG4gIGFkZF9zdWJieXRlcyBiIGJzLmJ1ZmZlciAwIGJzLnBvc2l0aW9uXG5cbigqIHRoaXMgKHByaXZhdGUpIGZ1bmN0aW9uIGNvdWxkIG1vdmUgaW50byB0aGUgc3RhbmRhcmQgbGlicmFyeSAqKVxubGV0IHJlYWxseV9pbnB1dF91cF90byBpYyBidWYgb2ZzIGxlbiA9XG4gIGxldCByZWMgbG9vcCBpYyBidWYgfmFscmVhZHlfcmVhZCB+b2ZzIH50b19yZWFkID1cbiAgICBpZiB0b19yZWFkID0gMCB0aGVuIGFscmVhZHlfcmVhZFxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gaW5wdXQgaWMgYnVmIG9mcyB0b19yZWFkIGluXG4gICAgICBpZiByID0gMCB0aGVuIGFscmVhZHlfcmVhZFxuICAgICAgZWxzZSBiZWdpblxuICAgICAgICBsZXQgYWxyZWFkeV9yZWFkID0gYWxyZWFkeV9yZWFkICsgciBpblxuICAgICAgICBsZXQgb2ZzID0gb2ZzICsgciBpblxuICAgICAgICBsZXQgdG9fcmVhZCA9IHRvX3JlYWQgLSByIGluXG4gICAgICAgIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQgfm9mcyB+dG9fcmVhZFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGluIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQ6MCB+b2ZzIH50b19yZWFkOmxlblxuXG5cbmxldCB1bnNhZmVfYWRkX2NoYW5uZWxfdXBfdG8gYiBpYyBsZW4gPVxuICBpZiBiLnBvc2l0aW9uICsgbGVuID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIGxldCBuID0gcmVhbGx5X2lucHV0X3VwX3RvIGljIGIuYnVmZmVyIGIucG9zaXRpb24gbGVuIGluXG4gICgqIFRoZSBhc3NlcnRpb24gYmVsb3cgbWF5IGZhaWwgaW4gd2VpcmQgc2NlbmFyaW8gd2hlcmVcbiAgICAgdGhyZWFkZWQvZmluYWxpemVyIGNvZGUsIHJ1biBhc3luY2hyb25vdXNseSBkdXJpbmcgdGhlXG4gICAgIFtyZWFsbHlfaW5wdXRfdXBfdG9dIGNhbGwsIHJhY2VzIG9uIHRoZSBidWZmZXI7IHdlIGRvbid0IGVuc3VyZVxuICAgICBjb3JyZWN0bmVzcyBpbiB0aGlzIGNhc2UsIGJ1dCBuZWVkIHRvIHByZXNlcnZlIHRoZSBpbnZhcmlhbnRzIGZvclxuICAgICBtZW1vcnktc2FmZXR5IChzZWUgZGlzY3Vzc2lvbiBvZiBbcmVzaXplXSkuICopXG4gIGFzc2VydCAoYi5wb3NpdGlvbiArIG4gPD0gYi5sZW5ndGgpO1xuICBiLnBvc2l0aW9uIDwtIGIucG9zaXRpb24gKyBuO1xuICBuXG5cbmxldCBhZGRfY2hhbm5lbCBiIGljIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgbGVuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gICAoKiBQUiM1MDA0ICopXG4gICAgaW52YWxpZF9hcmcgXCJCdWZmZXIuYWRkX2NoYW5uZWxcIjtcbiAgbGV0IG4gPSB1bnNhZmVfYWRkX2NoYW5uZWxfdXBfdG8gYiBpYyBsZW4gaW5cbiAgKCogSXQgaXMgaW50ZW50aW9uYWwgdGhhdCBhIGNvbnN1bWVyIGNhdGNoaW5nIEVuZF9vZl9maWxlXG4gICAgIHdpbGwgc2VlIHRoZSBkYXRhIHdyaXR0ZW4gKHNlZSAjNjcxOSwgIzcxMzYpLiAqKVxuICBpZiBuIDwgbGVuIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGU7XG4gICgpXG5cbmxldCBvdXRwdXRfYnVmZmVyIG9jIGIgPVxuICBvdXRwdXQgb2MgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5cbmxldCBjbG9zaW5nID0gZnVuY3Rpb25cbiAgfCAnKCcgLT4gJyknXG4gIHwgJ3snIC0+ICd9J1xuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbigqIG9wZW5pbmcgYW5kIGNsb3Npbmc6IG9wZW4gYW5kIGNsb3NlIGNoYXJhY3RlcnMsIHR5cGljYWxseSAoIGFuZCApXG4gICBrOiBiYWxhbmNlIG9mIG9wZW5pbmcgYW5kIGNsb3NpbmcgY2hhcnNcbiAgIHM6IHRoZSBzdHJpbmcgd2hlcmUgd2UgYXJlIHNlYXJjaGluZ1xuICAgc3RhcnQ6IHRoZSBpbmRleCB3aGVyZSB3ZSBzdGFydCB0aGUgc2VhcmNoLiAqKVxubGV0IGFkdmFuY2VfdG9fY2xvc2luZyBvcGVuaW5nIGNsb3NpbmcgayBzIHN0YXJ0ID1cbiAgbGV0IHJlYyBhZHZhbmNlIGsgaSBsaW0gPVxuICAgIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgICBpZiBzLltpXSA9IG9wZW5pbmcgdGhlbiBhZHZhbmNlIChrICsgMSkgKGkgKyAxKSBsaW0gZWxzZVxuICAgIGlmIHMuW2ldID0gY2xvc2luZyB0aGVuXG4gICAgICBpZiBrID0gMCB0aGVuIGkgZWxzZSBhZHZhbmNlIChrIC0gMSkgKGkgKyAxKSBsaW1cbiAgICBlbHNlIGFkdmFuY2UgayAoaSArIDEpIGxpbSBpblxuICBhZHZhbmNlIGsgc3RhcnQgKFN0cmluZy5sZW5ndGggcylcblxubGV0IGFkdmFuY2VfdG9fbm9uX2FscGhhIHMgc3RhcnQgPVxuICBsZXQgcmVjIGFkdmFuY2UgaSBsaW0gPVxuICAgIGlmIGkgPj0gbGltIHRoZW4gbGltIGVsc2VcbiAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgfCAnYScgLi4gJ3onIHwgJ0EnIC4uICdaJyB8ICcwJyAuLiAnOScgfCAnXycgLT4gYWR2YW5jZSAoaSArIDEpIGxpbVxuICAgIHwgXyAtPiBpIGluXG4gIGFkdmFuY2Ugc3RhcnQgKFN0cmluZy5sZW5ndGggcylcblxuKCogV2UgYXJlIGp1c3QgYXQgdGhlIGJlZ2lubmluZyBvZiBhbiBpZGVudCBpbiBzLCBzdGFydGluZyBhdCBzdGFydC4gKilcbmxldCBmaW5kX2lkZW50IHMgc3RhcnQgbGltID1cbiAgaWYgc3RhcnQgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgbWF0Y2ggcy5bc3RhcnRdIHdpdGhcbiAgKCogUGFyZW50aGVzaXplZCBpZGVudCA/ICopXG4gIHwgJygnIHwgJ3snIGFzIGMgLT5cbiAgICAgbGV0IG5ld19zdGFydCA9IHN0YXJ0ICsgMSBpblxuICAgICBsZXQgc3RvcCA9IGFkdmFuY2VfdG9fY2xvc2luZyBjIChjbG9zaW5nIGMpIDAgcyBuZXdfc3RhcnQgaW5cbiAgICAgU3RyaW5nLnN1YiBzIG5ld19zdGFydCAoc3RvcCAtIHN0YXJ0IC0gMSksIHN0b3AgKyAxXG4gICgqIFJlZ3VsYXIgaWRlbnQgKilcbiAgfCBfIC0+XG4gICAgIGxldCBzdG9wID0gYWR2YW5jZV90b19ub25fYWxwaGEgcyAoc3RhcnQgKyAxKSBpblxuICAgICBTdHJpbmcuc3ViIHMgc3RhcnQgKHN0b3AgLSBzdGFydCksIHN0b3BcblxuKCogU3Vic3RpdHV0ZSAkaWRlbnQsICQoaWRlbnQpLCBvciAke2lkZW50fSBpbiBzLFxuICAgIGFjY29yZGluZyB0byB0aGUgZnVuY3Rpb24gbWFwcGluZyBmLiAqKVxubGV0IGFkZF9zdWJzdGl0dXRlIGIgZiBzID1cbiAgbGV0IGxpbSA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIHN1YnN0IHByZXZpb3VzIGkgPVxuICAgIGlmIGkgPCBsaW0gdGhlbiBiZWdpblxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnJCcgYXMgY3VycmVudCB3aGVuIHByZXZpb3VzID0gJ1xcXFwnIC0+XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCAnICcgKGkgKyAxKVxuICAgICAgfCAnJCcgLT5cbiAgICAgICAgIGxldCBqID0gaSArIDEgaW5cbiAgICAgICAgIGxldCBpZGVudCwgbmV4dF9pID0gZmluZF9pZGVudCBzIGogbGltIGluXG4gICAgICAgICBhZGRfc3RyaW5nIGIgKGYgaWRlbnQpO1xuICAgICAgICAgc3Vic3QgJyAnIG5leHRfaVxuICAgICAgfCBjdXJyZW50IHdoZW4gcHJldmlvdXMgPT0gJ1xcXFwnIC0+XG4gICAgICAgICBhZGRfY2hhciBiICdcXFxcJztcbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0ICcgJyAoaSArIDEpXG4gICAgICB8ICdcXFxcJyBhcyBjdXJyZW50IC0+XG4gICAgICAgICBzdWJzdCBjdXJyZW50IChpICsgMSlcbiAgICAgIHwgY3VycmVudCAtPlxuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgY3VycmVudCAoaSArIDEpXG4gICAgZW5kIGVsc2VcbiAgICBpZiBwcmV2aW91cyA9ICdcXFxcJyB0aGVuIGFkZF9jaGFyIGIgcHJldmlvdXMgaW5cbiAgc3Vic3QgJyAnIDBcblxubGV0IHRydW5jYXRlIGIgbGVuID1cbiAgICBpZiBsZW4gPCAwIHx8IGxlbiA+IGxlbmd0aCBiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiQnVmZmVyLnRydW5jYXRlXCJcbiAgICBlbHNlXG4gICAgICBiLnBvc2l0aW9uIDwtIGxlblxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGIgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICAoKiBOb3RlIHRoYXQgYi5wb3NpdGlvbiBpcyBub3QgYSBjb25zdGFudCBhbmQgY2Fubm90IGJlIGxpZnRlZCBvdXQgb2YgYXV4ICopXG4gICAgaWYgaSA+PSBiLnBvc2l0aW9uIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmZlciBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBiID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgKCogTm90ZSB0aGF0IGIucG9zaXRpb24gaXMgbm90IGEgY29uc3RhbnQgYW5kIGNhbm5vdCBiZSBsaWZ0ZWQgb3V0IG9mIGF1eCAqKVxuICAgIGlmIGkgPj0gYi5wb3NpdGlvbiB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmZXIgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCBhZGRfc2VxIGIgc2VxID0gU2VxLml0ZXIgKGFkZF9jaGFyIGIpIHNlcVxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgYiA9IGNyZWF0ZSAzMiBpblxuICBhZGRfc2VxIGIgaTtcbiAgYlxuXG4oKiogezYgQmluYXJ5IGVuY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDggOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50MTYgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDE2dVwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDMyIDogYnl0ZXMgLT4gaW50IC0+IGludDMyIC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDMydVwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDY0IDogYnl0ZXMgLT4gaW50IC0+IGludDY0IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDY0dVwiXG5leHRlcm5hbCBzd2FwMTYgOiBpbnQgLT4gaW50ID0gXCIlYnN3YXAxNlwiXG5leHRlcm5hbCBzd2FwMzIgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWJzd2FwX2ludDMyXCJcbmV4dGVybmFsIHN3YXA2NCA6IGludDY0IC0+IGludDY0ID0gXCIlYnN3YXBfaW50NjRcIlxuXG5cbmxldCBhZGRfaW50OCBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDEgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAxO1xuICB1bnNhZmVfc2V0X2ludDggYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDE2X25lIGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgMiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gIHVuc2FmZV9zZXRfaW50MTYgYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDMyX25lIGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgNCBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gIHVuc2FmZV9zZXRfaW50MzIgYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDY0X25lIGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgOCBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDg7XG4gIHVuc2FmZV9zZXRfaW50NjQgYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDE2X2xlIGIgeCA9XG4gIGFkZF9pbnQxNl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQxNl9iZSBiIHggPVxuICBhZGRfaW50MTZfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDE2IHgpXG5cbmxldCBhZGRfaW50MzJfbGUgYiB4ID1cbiAgYWRkX2ludDMyX25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDMyX2JlIGIgeCA9XG4gIGFkZF9pbnQzMl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwMzIgeClcblxubGV0IGFkZF9pbnQ2NF9sZSBiIHggPVxuICBhZGRfaW50NjRfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwNjQgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50NjRfYmUgYiB4ID1cbiAgYWRkX2ludDY0X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXA2NCB4KVxuXG5sZXQgYWRkX3VpbnQ4ID0gYWRkX2ludDhcbmxldCBhZGRfdWludDE2X25lID0gYWRkX2ludDE2X25lXG5sZXQgYWRkX3VpbnQxNl9sZSA9IGFkZF9pbnQxNl9sZVxubGV0IGFkZF91aW50MTZfYmUgPSBhZGRfaW50MTZfYmVcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgWGF2aWVyIExlcm95IGFuZCBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbmxldCBrZnByaW50ZiBrIG8gKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZiAoZnVuIGFjYyAtPiBvdXRwdXRfYWNjIG8gYWNjOyBrIG8pIEVuZF9vZl9hY2MgZm10XG5sZXQga2JwcmludGYgayBiIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGYgKGZ1biBhY2MgLT4gYnVmcHV0X2FjYyBiIGFjYzsgayBiKSBFbmRfb2ZfYWNjIGZtdFxubGV0IGlrZnByaW50ZiBrIG9jIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGsgb2MgZm10XG5sZXQgaWticHJpbnRmID0gaWtmcHJpbnRmXG5cbmxldCBmcHJpbnRmIG9jIGZtdCA9IGtmcHJpbnRmIGlnbm9yZSBvYyBmbXRcbmxldCBicHJpbnRmIGIgZm10ID0ga2JwcmludGYgaWdub3JlIGIgZm10XG5sZXQgaWZwcmludGYgb2MgZm10ID0gaWtmcHJpbnRmIGlnbm9yZSBvYyBmbXRcbmxldCBpYnByaW50ZiBiIGZtdCA9IGlrYnByaW50ZiBpZ25vcmUgYiBmbXRcbmxldCBwcmludGYgZm10ID0gZnByaW50ZiBzdGRvdXQgZm10XG5sZXQgZXByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZGVyciBmbXRcblxubGV0IGtzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgaycgYWNjID1cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSA2NCBpblxuICAgIHN0cnB1dF9hY2MgYnVmIGFjYztcbiAgICBrIChCdWZmZXIuY29udGVudHMgYnVmKSBpblxuICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdFxuXG5sZXQgc3ByaW50ZiBmbXQgPSBrc3ByaW50ZiAoZnVuIHMgLT4gcykgZm10XG5cbmxldCBrcHJpbnRmID0ga3NwcmludGZcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBrZXkgPSBzdHJpbmdcbnR5cGUgZG9jID0gc3RyaW5nXG50eXBlIHVzYWdlX21zZyA9IHN0cmluZ1xudHlwZSBhbm9uX2Z1biA9IChzdHJpbmcgLT4gdW5pdClcblxudHlwZSBzcGVjID1cbiAgfCBVbml0IG9mICh1bml0IC0+IHVuaXQpICAgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHVuaXQgYXJndW1lbnQgKilcbiAgfCBCb29sIG9mIChib29sIC0+IHVuaXQpICAgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgYm9vbCBhcmd1bWVudCAqKVxuICB8IFNldCBvZiBib29sIHJlZiAgICAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRydWUgKilcbiAgfCBDbGVhciBvZiBib29sIHJlZiAgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byBmYWxzZSAqKVxuICB8IFN0cmluZyBvZiAoc3RyaW5nIC0+IHVuaXQpICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBzdHJpbmcgYXJndW1lbnQgKilcbiAgfCBTZXRfc3RyaW5nIG9mIHN0cmluZyByZWYgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgc3RyaW5nIGFyZ3VtZW50ICopXG4gIHwgSW50IG9mIChpbnQgLT4gdW5pdCkgICAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhbiBpbnQgYXJndW1lbnQgKilcbiAgfCBTZXRfaW50IG9mIGludCByZWYgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgaW50IGFyZ3VtZW50ICopXG4gIHwgRmxvYXQgb2YgKGZsb2F0IC0+IHVuaXQpICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIGZsb2F0IGFyZ3VtZW50ICopXG4gIHwgU2V0X2Zsb2F0IG9mIGZsb2F0IHJlZiAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIGZsb2F0IGFyZ3VtZW50ICopXG4gIHwgVHVwbGUgb2Ygc3BlYyBsaXN0ICAgICAgICAgKCogVGFrZSBzZXZlcmFsIGFyZ3VtZW50cyBhY2NvcmRpbmcgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlYyBsaXN0ICopXG4gIHwgU3ltYm9sIG9mIHN0cmluZyBsaXN0ICogKHN0cmluZyAtPiB1bml0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFRha2Ugb25lIG9mIHRoZSBzeW1ib2xzIGFzIGFyZ3VtZW50IGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHN5bWJvbC4gKilcbiAgfCBSZXN0IG9mIChzdHJpbmcgLT4gdW5pdCkgICAoKiBTdG9wIGludGVycHJldGluZyBrZXl3b3JkcyBhbmQgY2FsbCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB3aXRoIGVhY2ggcmVtYWluaW5nIGFyZ3VtZW50ICopXG4gIHwgUmVzdF9hbGwgb2YgKHN0cmluZyBsaXN0IC0+IHVuaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogU3RvcCBpbnRlcnByZXRpbmcga2V5d29yZHMgYW5kIGNhbGwgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gd2l0aCBhbGwgcmVtYWluaW5nIGFyZ3VtZW50cy4gKilcbiAgfCBFeHBhbmQgb2YgKHN0cmluZyAtPiBzdHJpbmcgYXJyYXkpICgqIElmIHRoZSByZW1haW5pbmcgYXJndW1lbnRzIHRvIHByb2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBvZiB0aGUgZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1tcIi1mb29cIjsgXCJhcmdcIl0gQCByZXN0XSB3aGVyZSBcImZvb1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyByZWdpc3RlcmVkIGFzIFtFeHBhbmQgZl0sIHRoZW4gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHMgW2YgXCJhcmdcIiBAIHJlc3RdIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkLiBPbmx5IGFsbG93ZWQgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY10uICopXG5cbmV4Y2VwdGlvbiBCYWQgb2Ygc3RyaW5nXG5leGNlcHRpb24gSGVscCBvZiBzdHJpbmdcblxudHlwZSBlcnJvciA9XG4gIHwgVW5rbm93biBvZiBzdHJpbmdcbiAgfCBXcm9uZyBvZiBzdHJpbmcgKiBzdHJpbmcgKiBzdHJpbmcgICgqIG9wdGlvbiwgYWN0dWFsLCBleHBlY3RlZCAqKVxuICB8IE1pc3Npbmcgb2Ygc3RyaW5nXG4gIHwgTWVzc2FnZSBvZiBzdHJpbmdcblxuZXhjZXB0aW9uIFN0b3Agb2YgZXJyb3IgKCogdXNlZCBpbnRlcm5hbGx5ICopXG5cbm9wZW4gUHJpbnRmXG5cbmxldCByZWMgYXNzb2MzIHggbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8ICh5MSwgeTIsIF8pIDo6IF8gd2hlbiB5MSA9IHggLT4geTJcbiAgfCBfIDo6IHQgLT4gYXNzb2MzIHggdFxuXG5cbmxldCBzcGxpdCBzID1cbiAgbGV0IGkgPSBTdHJpbmcuaW5kZXggcyAnPScgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBTdHJpbmcuc3ViIHMgMCBpLCBTdHJpbmcuc3ViIHMgKGkrMSkgKGxlbi0oaSsxKSlcblxuXG5sZXQgbWFrZV9zeW1saXN0IHByZWZpeCBzZXAgc3VmZml4IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBcIjxub25lPlwiXG4gIHwgaDo6dCAtPiAoTGlzdC5mb2xkX2xlZnQgKGZ1biB4IHkgLT4geCBeIHNlcCBeIHkpIChwcmVmaXggXiBoKSB0KSBeIHN1ZmZpeFxuXG5cbmxldCBwcmludF9zcGVjIGJ1ZiAoa2V5LCBzcGVjLCBkb2MpID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBkb2MgPiAwIHRoZW5cbiAgICBtYXRjaCBzcGVjIHdpdGhcbiAgICB8IFN5bWJvbCAobCwgXykgLT5cbiAgICAgICAgYnByaW50ZiBidWYgXCIgICVzICVzJXNcXG5cIiBrZXkgKG1ha2Vfc3ltbGlzdCBcIntcIiBcInxcIiBcIn1cIiBsKSBkb2NcbiAgICB8IF8gLT5cbiAgICAgICAgYnByaW50ZiBidWYgXCIgICVzICVzXFxuXCIga2V5IGRvY1xuXG5cbmxldCBoZWxwX2FjdGlvbiAoKSA9IHJhaXNlIChTdG9wIChVbmtub3duIFwiLWhlbHBcIikpXG5cbmxldCBhZGRfaGVscCBzcGVjbGlzdCA9XG4gIGxldCBhZGQxID1cbiAgICB0cnkgaWdub3JlIChhc3NvYzMgXCItaGVscFwiIHNwZWNsaXN0KTsgW11cbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgICAgW1wiLWhlbHBcIiwgVW5pdCBoZWxwX2FjdGlvbiwgXCIgRGlzcGxheSB0aGlzIGxpc3Qgb2Ygb3B0aW9uc1wiXVxuICBhbmQgYWRkMiA9XG4gICAgdHJ5IGlnbm9yZSAoYXNzb2MzIFwiLS1oZWxwXCIgc3BlY2xpc3QpOyBbXVxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICBbXCItLWhlbHBcIiwgVW5pdCBoZWxwX2FjdGlvbiwgXCIgRGlzcGxheSB0aGlzIGxpc3Qgb2Ygb3B0aW9uc1wiXVxuICBpblxuICBzcGVjbGlzdCBAIChhZGQxIEAgYWRkMilcblxuXG5sZXQgdXNhZ2VfYiBidWYgc3BlY2xpc3QgZXJybXNnID1cbiAgYnByaW50ZiBidWYgXCIlc1xcblwiIGVycm1zZztcbiAgTGlzdC5pdGVyIChwcmludF9zcGVjIGJ1ZikgKGFkZF9oZWxwIHNwZWNsaXN0KVxuXG5cbmxldCB1c2FnZV9zdHJpbmcgc3BlY2xpc3QgZXJybXNnID1cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDIwMCBpblxuICB1c2FnZV9iIGIgc3BlY2xpc3QgZXJybXNnO1xuICBCdWZmZXIuY29udGVudHMgYlxuXG5cbmxldCB1c2FnZSBzcGVjbGlzdCBlcnJtc2cgPVxuICBlcHJpbnRmIFwiJXNcIiAodXNhZ2Vfc3RyaW5nIHNwZWNsaXN0IGVycm1zZylcblxuXG5sZXQgY3VycmVudCA9IHJlZiAwXG5cbmxldCBib29sX29mX3N0cmluZ19vcHQgeCA9XG4gIHRyeSBTb21lIChib29sX29mX3N0cmluZyB4KVxuICB3aXRoIEludmFsaWRfYXJndW1lbnQgXyAtPiBOb25lXG5cbmxldCBpbnRfb2Zfc3RyaW5nX29wdCB4ID1cbiAgdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgeClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgZmxvYXRfb2Zfc3RyaW5nX29wdCB4ID1cbiAgdHJ5IFNvbWUgKGZsb2F0X29mX3N0cmluZyB4KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXggYWxsb3dfZXhwYW5kIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm1zZyA9XG4gIGxldCBpbml0cG9zID0gIWN1cnJlbnQgaW5cbiAgbGV0IGNvbnZlcnRfZXJyb3IgZXJyb3IgPVxuICAgICgqIGNvbnZlcnQgYW4gaW50ZXJuYWwgZXJyb3IgdG8gYSBCYWQvSGVscCBleGNlcHRpb25cbiAgICAgICAqb3IqIGFkZCB0aGUgcHJvZ3JhbSBuYW1lIGFzIGEgcHJlZml4IGFuZCB0aGUgdXNhZ2UgbWVzc2FnZSBhcyBhIHN1ZmZpeFxuICAgICAgIHRvIGFuIHVzZXItcmFpc2VkIEJhZCBleGNlcHRpb24uXG4gICAgKilcbiAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gICAgbGV0IHByb2duYW1lID1cbiAgICAgIGlmIGluaXRwb3MgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSB0aGVuICFhcmd2Lihpbml0cG9zKSBlbHNlIFwiKD8pXCIgaW5cbiAgICBiZWdpbiBtYXRjaCBlcnJvciB3aXRoXG4gICAgICB8IFVua25vd24gXCItaGVscFwiIC0+ICgpXG4gICAgICB8IFVua25vd24gXCItLWhlbHBcIiAtPiAoKVxuICAgICAgfCBVbmtub3duIHMgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogdW5rbm93biBvcHRpb24gJyVzJy5cXG5cIiBwcm9nbmFtZSBzXG4gICAgICB8IE1pc3NpbmcgcyAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiBvcHRpb24gJyVzJyBuZWVkcyBhbiBhcmd1bWVudC5cXG5cIiBwcm9nbmFtZSBzXG4gICAgICB8IFdyb25nIChvcHQsIGFyZywgZXhwZWN0ZWQpIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IHdyb25nIGFyZ3VtZW50ICclcyc7IG9wdGlvbiAnJXMnIGV4cGVjdHMgJXMuXFxuXCJcbiAgICAgICAgICAgICAgICAgIHByb2duYW1lIGFyZyBvcHQgZXhwZWN0ZWRcbiAgICAgIHwgTWVzc2FnZSBzIC0+ICgqIHVzZXIgZXJyb3IgbWVzc2FnZSAqKVxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiAlcy5cXG5cIiBwcm9nbmFtZSBzXG4gICAgZW5kO1xuICAgIHVzYWdlX2IgYiAhc3BlY2xpc3QgZXJybXNnO1xuICAgIGlmIGVycm9yID0gVW5rbm93biBcIi1oZWxwXCIgfHwgZXJyb3IgPSBVbmtub3duIFwiLS1oZWxwXCJcbiAgICB0aGVuIEhlbHAgKEJ1ZmZlci5jb250ZW50cyBiKVxuICAgIGVsc2UgQmFkIChCdWZmZXIuY29udGVudHMgYilcbiAgaW5cbiAgaW5jciBjdXJyZW50O1xuICB3aGlsZSAhY3VycmVudCA8IChBcnJheS5sZW5ndGggIWFyZ3YpIGRvXG4gICAgYmVnaW4gdHJ5XG4gICAgICBsZXQgcyA9ICFhcmd2LighY3VycmVudCkgaW5cbiAgICAgIGlmIFN0cmluZy5sZW5ndGggcyA+PSAxICYmIHMuWzBdID0gJy0nIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IGFjdGlvbiwgZm9sbG93ID1cbiAgICAgICAgICB0cnkgYXNzb2MzIHMgIXNwZWNsaXN0LCBOb25lXG4gICAgICAgICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIGxldCBrZXl3b3JkLCBhcmcgPSBzcGxpdCBzIGluXG4gICAgICAgICAgICBhc3NvYzMga2V5d29yZCAhc3BlY2xpc3QsIFNvbWUgYXJnXG4gICAgICAgICAgd2l0aCBOb3RfZm91bmQgLT4gcmFpc2UgKFN0b3AgKFVua25vd24gcykpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBub19hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIGFyZyAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJubyBhcmd1bWVudFwiKSkpIGluXG4gICAgICAgIGxldCBnZXRfYXJnICgpID1cbiAgICAgICAgICBtYXRjaCBmb2xsb3cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICBpZiAhY3VycmVudCArIDEgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSB0aGVuICFhcmd2LighY3VycmVudCArIDEpXG4gICAgICAgICAgICAgIGVsc2UgcmFpc2UgKFN0b3AgKE1pc3NpbmcgcykpXG4gICAgICAgICAgfCBTb21lIGFyZyAtPiBhcmdcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGNvbnN1bWVfYXJnICgpID1cbiAgICAgICAgICBtYXRjaCBmb2xsb3cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBpbmNyIGN1cnJlbnRcbiAgICAgICAgICB8IFNvbWUgXyAtPiAoKVxuICAgICAgICBpblxuICAgICAgICBsZXQgcmVjIHRyZWF0X2FjdGlvbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgVW5pdCBmIC0+IG5vX2FyZyAoKTsgZiAoKTtcbiAgICAgICAgfCBCb29sIGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBib29sX29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGJvb2xlYW5cIikpKVxuICAgICAgICAgICAgfCBTb21lIHMgLT4gZiBzXG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXQgciAtPiBub19hcmcgKCk7IHIgOj0gdHJ1ZTtcbiAgICAgICAgfCBDbGVhciByIC0+IG5vX2FyZyAoKTsgciA6PSBmYWxzZTtcbiAgICAgICAgfCBTdHJpbmcgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGYgYXJnO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU3ltYm9sIChzeW1iLCBmKSAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGlmIExpc3QubWVtIGFyZyBzeW1iIHRoZW4gYmVnaW5cbiAgICAgICAgICAgICAgZiBhcmc7XG4gICAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwib25lIG9mOiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXiAobWFrZV9zeW1saXN0IFwiXCIgXCIgXCIgXCJcIiBzeW1iKSkpKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgU2V0X3N0cmluZyByIC0+XG4gICAgICAgICAgICByIDo9IGdldF9hcmcgKCk7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBJbnQgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGludF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYW4gaW50ZWdlclwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiBmIHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldF9pbnQgciAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGludF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYW4gaW50ZWdlclwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiByIDo9IHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IEZsb2F0IGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBmbG9hdF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBmbG9hdFwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiBmIHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldF9mbG9hdCByIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggZmxvYXRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgZmxvYXRcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gciA6PSB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBUdXBsZSBzcGVjcyAtPlxuICAgICAgICAgICAgbm9fYXJnICgpO1xuICAgICAgICAgICAgTGlzdC5pdGVyIHRyZWF0X2FjdGlvbiBzcGVjcztcbiAgICAgICAgfCBSZXN0IGYgLT5cbiAgICAgICAgICAgIG5vX2FyZyAoKTtcbiAgICAgICAgICAgIHdoaWxlICFjdXJyZW50IDwgKEFycmF5Lmxlbmd0aCAhYXJndikgLSAxIGRvXG4gICAgICAgICAgICAgIGYgIWFyZ3YuKCFjdXJyZW50ICsgMSk7XG4gICAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgZG9uZTtcbiAgICAgICAgfCBSZXN0X2FsbCBmIC0+XG4gICAgICAgICAgICBub19hcmcgKCk7XG4gICAgICAgICAgICBsZXQgYWNjID0gcmVmIFtdIGluXG4gICAgICAgICAgICB3aGlsZSAhY3VycmVudCA8IEFycmF5Lmxlbmd0aCAhYXJndiAtIDEgZG9cbiAgICAgICAgICAgICAgYWNjIDo9ICFhcmd2LighY3VycmVudCArIDEpIDo6ICFhY2M7XG4gICAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgZG9uZTtcbiAgICAgICAgICAgIGYgKExpc3QucmV2ICFhY2MpXG4gICAgICAgIHwgRXhwYW5kIGYgLT5cbiAgICAgICAgICAgIGlmIG5vdCBhbGxvd19leHBhbmQgdGhlblxuICAgICAgICAgICAgICByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkFyZy5FeHBhbmQgaXMgaXMgb25seSBhbGxvd2VkIHdpdGggXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFyZy5wYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY1wiKTtcbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBsZXQgbmV3YXJnID0gZiBhcmcgaW5cbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IEFycmF5LnN1YiAhYXJndiAwICghY3VycmVudCArIDEpXG4gICAgICAgICAgICBhbmQgYWZ0ZXIgPVxuICAgICAgICAgICAgICBBcnJheS5zdWIgIWFyZ3YgKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICgoQXJyYXkubGVuZ3RoICFhcmd2KSAtICFjdXJyZW50IC0gMSkgaW5cbiAgICAgICAgICAgIGFyZ3Y6PSBBcnJheS5jb25jYXQgW2JlZm9yZTtuZXdhcmc7YWZ0ZXJdO1xuICAgICAgICBpblxuICAgICAgICB0cmVhdF9hY3Rpb24gYWN0aW9uIGVuZFxuICAgICAgZWxzZSBhbm9uZnVuIHNcbiAgICB3aXRoIHwgQmFkIG0gLT4gcmFpc2UgKGNvbnZlcnRfZXJyb3IgKE1lc3NhZ2UgbSkpO1xuICAgICAgICAgfCBTdG9wIGUgLT4gcmFpc2UgKGNvbnZlcnRfZXJyb3IgZSk7XG4gICAgZW5kO1xuICAgIGluY3IgY3VycmVudFxuICBkb25lXG5cbmxldCBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXggdHJ1ZSBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2dcblxubGV0IHBhcnNlX2FyZ3ZfZHluYW1pYyA/KGN1cnJlbnQ9Y3VycmVudCkgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCBmYWxzZSBjdXJyZW50IChyZWYgYXJndikgc3BlY2xpc3QgYW5vbmZ1blxuICAgIGVycm1zZ1xuXG5cbmxldCBwYXJzZV9hcmd2ID8oY3VycmVudD1jdXJyZW50KSBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYXJndl9keW5hbWljIH5jdXJyZW50OmN1cnJlbnQgYXJndiAocmVmIHNwZWNsaXN0KSBhbm9uZnVuIGVycm1zZ1xuXG5cbmxldCBwYXJzZSBsIGYgbXNnID1cbiAgdHJ5XG4gICAgcGFyc2VfYXJndiBTeXMuYXJndiBsIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5cbmxldCBwYXJzZV9keW5hbWljIGwgZiBtc2cgPVxuICB0cnlcbiAgICBwYXJzZV9hcmd2X2R5bmFtaWMgU3lzLmFyZ3YgbCBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxubGV0IHBhcnNlX2V4cGFuZCBsIGYgbXNnID1cbiAgdHJ5XG4gICAgbGV0IGFyZ3YgPSByZWYgU3lzLmFyZ3YgaW5cbiAgICBsZXQgc3BlYyA9IHJlZiBsIGluXG4gICAgbGV0IGN1cnJlbnQgPSByZWYgKCFjdXJyZW50KSBpblxuICAgIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIGN1cnJlbnQgYXJndiBzcGVjIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5cbmxldCBzZWNvbmRfd29yZCBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgbiA9XG4gICAgaWYgbiA+PSBsZW4gdGhlbiBsZW5cbiAgICBlbHNlIGlmIHMuW25dID0gJyAnIHRoZW4gbG9vcCAobisxKVxuICAgIGVsc2UgblxuICBpblxuICBtYXRjaCBTdHJpbmcuaW5kZXggcyAnXFx0JyB3aXRoXG4gIHwgbiAtPiBsb29wIChuKzEpXG4gIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPlxuICAgICAgYmVnaW4gbWF0Y2ggU3RyaW5nLmluZGV4IHMgJyAnIHdpdGhcbiAgICAgIHwgbiAtPiBsb29wIChuKzEpXG4gICAgICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT4gbGVuXG4gICAgICBlbmRcblxuXG5sZXQgbWF4X2FyZ19sZW4gY3VyIChrd2QsIHNwZWMsIGRvYykgPVxuICBtYXRjaCBzcGVjIHdpdGhcbiAgfCBTeW1ib2wgXyAtPiBJbnQubWF4IGN1ciAoU3RyaW5nLmxlbmd0aCBrd2QpXG4gIHwgXyAtPiBJbnQubWF4IGN1ciAoU3RyaW5nLmxlbmd0aCBrd2QgKyBzZWNvbmRfd29yZCBkb2MpXG5cblxubGV0IHJlcGxhY2VfbGVhZGluZ190YWIgcyA9XG4gIGxldCBzZWVuID0gcmVmIGZhbHNlIGluXG4gIFN0cmluZy5tYXAgKGZ1bmN0aW9uICdcXHQnIHdoZW4gbm90ICFzZWVuIC0+IHNlZW4gOj0gdHJ1ZTsgJyAnIHwgYyAtPiBjKSBzXG5cbmxldCBhZGRfcGFkZGluZyBsZW4ga3NkID1cbiAgbWF0Y2gga3NkIHdpdGhcbiAgfCAoXywgXywgXCJcIikgLT5cbiAgICAgICgqIERvIG5vdCBwYWQgdW5kb2N1bWVudGVkIG9wdGlvbnMsIHNvIHRoYXQgdGhleSBzdGlsbCBkb24ndCBzaG93IHVwIHdoZW5cbiAgICAgICAqIHJ1biB0aHJvdWdoIFt1c2FnZV0gb3IgW3BhcnNlXS4gKilcbiAgICAgIGtzZFxuICB8IChrd2QsIChTeW1ib2wgXyBhcyBzcGVjKSwgbXNnKSAtPlxuICAgICAgbGV0IGN1dGNvbCA9IHNlY29uZF93b3JkIG1zZyBpblxuICAgICAgbGV0IHNwYWNlcyA9IFN0cmluZy5tYWtlICgoSW50Lm1heCAwIChsZW4gLSBjdXRjb2wpKSArIDMpICcgJyBpblxuICAgICAgKGt3ZCwgc3BlYywgXCJcXG5cIiBeIHNwYWNlcyBeIHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKVxuICB8IChrd2QsIHNwZWMsIG1zZykgLT5cbiAgICAgIGxldCBjdXRjb2wgPSBzZWNvbmRfd29yZCBtc2cgaW5cbiAgICAgIGxldCBrd2RfbGVuID0gU3RyaW5nLmxlbmd0aCBrd2QgaW5cbiAgICAgIGxldCBkaWZmID0gbGVuIC0ga3dkX2xlbiAtIGN1dGNvbCBpblxuICAgICAgaWYgZGlmZiA8PSAwIHRoZW5cbiAgICAgICAgKGt3ZCwgc3BlYywgcmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBzcGFjZXMgPSBTdHJpbmcubWFrZSBkaWZmICcgJyBpblxuICAgICAgICBsZXQgcHJlZml4ID0gU3RyaW5nLnN1YiAocmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpIDAgY3V0Y29sIGluXG4gICAgICAgIGxldCBzdWZmaXggPSBTdHJpbmcuc3ViIG1zZyBjdXRjb2wgKFN0cmluZy5sZW5ndGggbXNnIC0gY3V0Y29sKSBpblxuICAgICAgICAoa3dkLCBzcGVjLCBwcmVmaXggXiBzcGFjZXMgXiBzdWZmaXgpXG5cblxubGV0IGFsaWduID8obGltaXQ9bWF4X2ludCkgc3BlY2xpc3QgPVxuICBsZXQgY29tcGxldGVkID0gYWRkX2hlbHAgc3BlY2xpc3QgaW5cbiAgbGV0IGxlbiA9IExpc3QuZm9sZF9sZWZ0IG1heF9hcmdfbGVuIDAgY29tcGxldGVkIGluXG4gIGxldCBsZW4gPSBJbnQubWluIGxlbiBsaW1pdCBpblxuICBMaXN0Lm1hcCAoYWRkX3BhZGRpbmcgbGVuKSBjb21wbGV0ZWRcblxubGV0IHRyaW1fY3IgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgaWYgbGVuID4gMCAmJiBTdHJpbmcuZ2V0IHMgKGxlbiAtIDEpID0gJ1xccicgdGhlblxuICAgIFN0cmluZy5zdWIgcyAwIChsZW4gLSAxKVxuICBlbHNlXG4gICAgc1xuXG5sZXQgcmVhZF9hdXggdHJpbSBzZXAgZmlsZSA9XG4gIGxldCBpYyA9IG9wZW5faW5fYmluIGZpbGUgaW5cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gIGxldCB3b3JkcyA9IHJlZiBbXSBpblxuICBsZXQgc3Rhc2ggKCkgPVxuICAgIGxldCB3b3JkID0gQnVmZmVyLmNvbnRlbnRzIGJ1ZiBpblxuICAgIGxldCB3b3JkID0gaWYgdHJpbSB0aGVuIHRyaW1fY3Igd29yZCBlbHNlIHdvcmQgaW5cbiAgICB3b3JkcyA6PSB3b3JkIDo6ICF3b3JkcztcbiAgICBCdWZmZXIuY2xlYXIgYnVmXG4gIGluXG4gIGJlZ2luXG4gICAgdHJ5IHdoaWxlIHRydWUgZG9cbiAgICAgICAgbGV0IGMgPSBpbnB1dF9jaGFyIGljIGluXG4gICAgICAgIGlmIGMgPSBzZXAgdGhlbiBzdGFzaCAoKSBlbHNlIEJ1ZmZlci5hZGRfY2hhciBidWYgY1xuICAgICAgZG9uZVxuICAgIHdpdGggRW5kX29mX2ZpbGUgLT4gKClcbiAgZW5kO1xuICBpZiBCdWZmZXIubGVuZ3RoIGJ1ZiA+IDAgdGhlbiBzdGFzaCAoKTtcbiAgY2xvc2VfaW4gaWM7XG4gIEFycmF5Lm9mX2xpc3QgKExpc3QucmV2ICF3b3JkcylcblxubGV0IHJlYWRfYXJnID0gcmVhZF9hdXggdHJ1ZSAnXFxuJ1xuXG5sZXQgcmVhZF9hcmcwID0gcmVhZF9hdXggZmFsc2UgJ1xceDAwJ1xuXG5sZXQgd3JpdGVfYXV4IHNlcCBmaWxlIGFyZ3MgPVxuICBsZXQgb2MgPSBvcGVuX291dF9iaW4gZmlsZSBpblxuICBBcnJheS5pdGVyIChmdW4gcyAtPiBmcHJpbnRmIG9jIFwiJXMlY1wiIHMgc2VwKSBhcmdzO1xuICBjbG9zZV9vdXQgb2NcblxubGV0IHdyaXRlX2FyZyA9IHdyaXRlX2F1eCAnXFxuJ1xuXG5sZXQgd3JpdGVfYXJnMCA9IHdyaXRlX2F1eCAnXFx4MDAnXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIGlkIDogJ2EgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5sZXQgY29uc3QgYyBfID0gY1xubGV0IGZsaXAgZiB4IHkgPSBmIHkgeFxubGV0IG5lZ2F0ZSBwIHYgPSBub3QgKHAgdilcblxuZXhjZXB0aW9uIEZpbmFsbHlfcmFpc2VkIG9mIGV4blxuXG5sZXQgKCkgPSBQcmludGV4Yy5yZWdpc3Rlcl9wcmludGVyIEBAIGZ1bmN0aW9uXG58IEZpbmFsbHlfcmFpc2VkIGV4biAtPiBTb21lIChcIkZ1bi5GaW5hbGx5X3JhaXNlZDogXCIgXiBQcmludGV4Yy50b19zdHJpbmcgZXhuKVxufCBfIC0+IE5vbmVcblxubGV0IHByb3RlY3QgfihmaW5hbGx5IDogdW5pdCAtPiB1bml0KSB3b3JrID1cbiAgbGV0IGZpbmFsbHlfbm9fZXhuICgpID1cbiAgICB0cnkgZmluYWxseSAoKSB3aXRoIGUgLT5cbiAgICAgIGxldCBidCA9IFByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICBQcmludGV4Yy5yYWlzZV93aXRoX2JhY2t0cmFjZSAoRmluYWxseV9yYWlzZWQgZSkgYnRcbiAgaW5cbiAgbWF0Y2ggd29yayAoKSB3aXRoXG4gIHwgcmVzdWx0IC0+IGZpbmFsbHlfbm9fZXhuICgpIDsgcmVzdWx0XG4gIHwgZXhjZXB0aW9uIHdvcmtfZXhuIC0+XG4gICAgICBsZXQgd29ya19idCA9IFByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICBmaW5hbGx5X25vX2V4biAoKSA7XG4gICAgICBQcmludGV4Yy5yYWlzZV93aXRoX2JhY2t0cmFjZSB3b3JrX2V4biB3b3JrX2J0XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgIEphY3F1ZXMtSGVucmkgSm91cmRhbiwgcHJvamV0IEdhbGxpdW0sIElOUklBIFBhcmlzICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2LTIwMTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSAgICopXG4oKiAgICAgZXQgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgc3RhdCA9IHtcbiAgbWlub3Jfd29yZHMgOiBmbG9hdDtcbiAgcHJvbW90ZWRfd29yZHMgOiBmbG9hdDtcbiAgbWFqb3Jfd29yZHMgOiBmbG9hdDtcbiAgbWlub3JfY29sbGVjdGlvbnMgOiBpbnQ7XG4gIG1ham9yX2NvbGxlY3Rpb25zIDogaW50O1xuICBoZWFwX3dvcmRzIDogaW50O1xuICBoZWFwX2NodW5rcyA6IGludDtcbiAgbGl2ZV93b3JkcyA6IGludDtcbiAgbGl2ZV9ibG9ja3MgOiBpbnQ7XG4gIGZyZWVfd29yZHMgOiBpbnQ7XG4gIGZyZWVfYmxvY2tzIDogaW50O1xuICBsYXJnZXN0X2ZyZWUgOiBpbnQ7XG4gIGZyYWdtZW50cyA6IGludDtcbiAgY29tcGFjdGlvbnMgOiBpbnQ7XG4gIHRvcF9oZWFwX3dvcmRzIDogaW50O1xuICBzdGFja19zaXplIDogaW50O1xuICBmb3JjZWRfbWFqb3JfY29sbGVjdGlvbnM6IGludDtcbn1cblxudHlwZSBjb250cm9sID0ge1xuICBtdXRhYmxlIG1pbm9yX2hlYXBfc2l6ZSA6IGludDtcbiAgbXV0YWJsZSBtYWpvcl9oZWFwX2luY3JlbWVudCA6IGludDtcbiAgbXV0YWJsZSBzcGFjZV9vdmVyaGVhZCA6IGludDtcbiAgbXV0YWJsZSB2ZXJib3NlIDogaW50O1xuICBtdXRhYmxlIG1heF9vdmVyaGVhZCA6IGludDtcbiAgbXV0YWJsZSBzdGFja19saW1pdCA6IGludDtcbiAgbXV0YWJsZSBhbGxvY2F0aW9uX3BvbGljeSA6IGludDtcbiAgd2luZG93X3NpemUgOiBpbnQ7XG4gIGN1c3RvbV9tYWpvcl9yYXRpbyA6IGludDtcbiAgY3VzdG9tX21pbm9yX3JhdGlvIDogaW50O1xuICBjdXN0b21fbWlub3JfbWF4X3NpemUgOiBpbnQ7XG59XG5cbmV4dGVybmFsIHN0YXQgOiB1bml0IC0+IHN0YXQgPSBcImNhbWxfZ2Nfc3RhdFwiXG5leHRlcm5hbCBxdWlja19zdGF0IDogdW5pdCAtPiBzdGF0ID0gXCJjYW1sX2djX3F1aWNrX3N0YXRcIlxuZXh0ZXJuYWwgY291bnRlcnMgOiB1bml0IC0+IChmbG9hdCAqIGZsb2F0ICogZmxvYXQpID0gXCJjYW1sX2djX2NvdW50ZXJzXCJcbmV4dGVybmFsIG1pbm9yX3dvcmRzIDogdW5pdCAtPiAoZmxvYXQgW0B1bmJveGVkXSlcbiAgPSBcImNhbWxfZ2NfbWlub3Jfd29yZHNcIiBcImNhbWxfZ2NfbWlub3Jfd29yZHNfdW5ib3hlZFwiXG5leHRlcm5hbCBnZXQgOiB1bml0IC0+IGNvbnRyb2wgPSBcImNhbWxfZ2NfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGNvbnRyb2wgLT4gdW5pdCA9IFwiY2FtbF9nY19zZXRcIlxuZXh0ZXJuYWwgbWlub3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfbWlub3JcIlxuZXh0ZXJuYWwgbWFqb3Jfc2xpY2UgOiBpbnQgLT4gaW50ID0gXCJjYW1sX2djX21ham9yX3NsaWNlXCJcbmV4dGVybmFsIG1ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21ham9yXCJcbmV4dGVybmFsIGZ1bGxfbWFqb3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfZnVsbF9tYWpvclwiXG5leHRlcm5hbCBjb21wYWN0IDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX2NvbXBhY3Rpb25cIlxuZXh0ZXJuYWwgZ2V0X21pbm9yX2ZyZWUgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nZXRfbWlub3JfZnJlZVwiXG5leHRlcm5hbCBnZXRfYnVja2V0IDogaW50IC0+IGludCA9IFwiY2FtbF9nZXRfbWFqb3JfYnVja2V0XCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGdldF9jcmVkaXQgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nZXRfbWFqb3JfY3JlZGl0XCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGh1Z2VfZmFsbGJhY2tfY291bnQgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50XCJcbmV4dGVybmFsIGV2ZW50bG9nX3BhdXNlIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2V2ZW50bG9nX3BhdXNlXCJcbmV4dGVybmFsIGV2ZW50bG9nX3Jlc3VtZSA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9ldmVudGxvZ19yZXN1bWVcIlxuXG5vcGVuIFByaW50ZlxuXG5sZXQgcHJpbnRfc3RhdCBjID1cbiAgbGV0IHN0ID0gc3RhdCAoKSBpblxuICBmcHJpbnRmIGMgXCJtaW5vcl9jb2xsZWN0aW9uczogICAgICAlZFxcblwiIHN0Lm1pbm9yX2NvbGxlY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJtYWpvcl9jb2xsZWN0aW9uczogICAgICAlZFxcblwiIHN0Lm1ham9yX2NvbGxlY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJjb21wYWN0aW9uczogICAgICAgICAgICAlZFxcblwiIHN0LmNvbXBhY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJmb3JjZWRfbWFqb3JfY29sbGVjdGlvbnM6ICVkXFxuXCIgc3QuZm9yY2VkX21ham9yX2NvbGxlY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgbGV0IGwxID0gU3RyaW5nLmxlbmd0aCAoc3ByaW50ZiBcIiUuMGZcIiBzdC5taW5vcl93b3JkcykgaW5cbiAgZnByaW50ZiBjIFwibWlub3Jfd29yZHM6ICAgICUqLjBmXFxuXCIgbDEgc3QubWlub3Jfd29yZHM7XG4gIGZwcmludGYgYyBcInByb21vdGVkX3dvcmRzOiAlKi4wZlxcblwiIGwxIHN0LnByb21vdGVkX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJtYWpvcl93b3JkczogICAgJSouMGZcXG5cIiBsMSBzdC5tYWpvcl93b3JkcztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGxldCBsMiA9IFN0cmluZy5sZW5ndGggKHNwcmludGYgXCIlZFwiIHN0LnRvcF9oZWFwX3dvcmRzKSBpblxuICBmcHJpbnRmIGMgXCJ0b3BfaGVhcF93b3JkczogJSpkXFxuXCIgbDIgc3QudG9wX2hlYXBfd29yZHM7XG4gIGZwcmludGYgYyBcImhlYXBfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5oZWFwX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJsaXZlX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QubGl2ZV93b3JkcztcbiAgZnByaW50ZiBjIFwiZnJlZV93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmZyZWVfd29yZHM7XG4gIGZwcmludGYgYyBcImxhcmdlc3RfZnJlZTogICAlKmRcXG5cIiBsMiBzdC5sYXJnZXN0X2ZyZWU7XG4gIGZwcmludGYgYyBcImZyYWdtZW50czogICAgICAlKmRcXG5cIiBsMiBzdC5mcmFnbWVudHM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBmcHJpbnRmIGMgXCJsaXZlX2Jsb2NrczogJWRcXG5cIiBzdC5saXZlX2Jsb2NrcztcbiAgZnByaW50ZiBjIFwiZnJlZV9ibG9ja3M6ICVkXFxuXCIgc3QuZnJlZV9ibG9ja3M7XG4gIGZwcmludGYgYyBcImhlYXBfY2h1bmtzOiAlZFxcblwiIHN0LmhlYXBfY2h1bmtzXG5cblxubGV0IGFsbG9jYXRlZF9ieXRlcyAoKSA9XG4gIGxldCAobWksIHBybywgbWEpID0gY291bnRlcnMgKCkgaW5cbiAgKG1pICsuIG1hIC0uIHBybykgKi4gZmxvYXRfb2ZfaW50IChTeXMud29yZF9zaXplIC8gOClcblxuXG5leHRlcm5hbCBmaW5hbGlzZSA6ICgnYSAtPiB1bml0KSAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2ZpbmFsX3JlZ2lzdGVyXCJcbmV4dGVybmFsIGZpbmFsaXNlX2xhc3QgOiAodW5pdCAtPiB1bml0KSAtPiAnYSAtPiB1bml0ID1cbiAgXCJjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlXCJcbmV4dGVybmFsIGZpbmFsaXNlX3JlbGVhc2UgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZmluYWxfcmVsZWFzZVwiXG5cblxudHlwZSBhbGFybSA9IGJvb2wgcmVmXG50eXBlIGFsYXJtX3JlYyA9IHthY3RpdmUgOiBhbGFybTsgZiA6IHVuaXQgLT4gdW5pdH1cblxubGV0IHJlYyBjYWxsX2FsYXJtIGFyZWMgPVxuICBpZiAhKGFyZWMuYWN0aXZlKSB0aGVuIGJlZ2luXG4gICAgZmluYWxpc2UgY2FsbF9hbGFybSBhcmVjO1xuICAgIGFyZWMuZiAoKTtcbiAgZW5kXG5cblxubGV0IGNyZWF0ZV9hbGFybSBmID1cbiAgbGV0IGFyZWMgPSB7IGFjdGl2ZSA9IHJlZiB0cnVlOyBmID0gZiB9IGluXG4gIGZpbmFsaXNlIGNhbGxfYWxhcm0gYXJlYztcbiAgYXJlYy5hY3RpdmVcblxuXG5sZXQgZGVsZXRlX2FsYXJtIGEgPSBhIDo9IGZhbHNlXG5cbm1vZHVsZSBNZW1wcm9mID1cbiAgc3RydWN0XG4gICAgdHlwZSBhbGxvY2F0aW9uX3NvdXJjZSA9IE5vcm1hbCB8IE1hcnNoYWwgfCBDdXN0b21cbiAgICB0eXBlIGFsbG9jYXRpb24gPVxuICAgICAgeyBuX3NhbXBsZXMgOiBpbnQ7XG4gICAgICAgIHNpemUgOiBpbnQ7XG4gICAgICAgIHNvdXJjZSA6IGFsbG9jYXRpb25fc291cmNlO1xuICAgICAgICBjYWxsc3RhY2sgOiBQcmludGV4Yy5yYXdfYmFja3RyYWNlIH1cblxuICAgIHR5cGUgKCdtaW5vciwgJ21ham9yKSB0cmFja2VyID0ge1xuICAgICAgYWxsb2NfbWlub3I6IGFsbG9jYXRpb24gLT4gJ21pbm9yIG9wdGlvbjtcbiAgICAgIGFsbG9jX21ham9yOiBhbGxvY2F0aW9uIC0+ICdtYWpvciBvcHRpb247XG4gICAgICBwcm9tb3RlOiAnbWlub3IgLT4gJ21ham9yIG9wdGlvbjtcbiAgICAgIGRlYWxsb2NfbWlub3I6ICdtaW5vciAtPiB1bml0O1xuICAgICAgZGVhbGxvY19tYWpvcjogJ21ham9yIC0+IHVuaXQ7XG4gICAgfVxuXG4gICAgbGV0IG51bGxfdHJhY2tlciA9IHtcbiAgICAgIGFsbG9jX21pbm9yID0gKGZ1biBfIC0+IE5vbmUpO1xuICAgICAgYWxsb2NfbWFqb3IgPSAoZnVuIF8gLT4gTm9uZSk7XG4gICAgICBwcm9tb3RlID0gKGZ1biBfIC0+IE5vbmUpO1xuICAgICAgZGVhbGxvY19taW5vciA9IChmdW4gXyAtPiAoKSk7XG4gICAgICBkZWFsbG9jX21ham9yID0gKGZ1biBfIC0+ICgpKTtcbiAgICB9XG5cbiAgICBleHRlcm5hbCBjX3N0YXJ0IDpcbiAgICAgIGZsb2F0IC0+IGludCAtPiAoJ21pbm9yLCAnbWFqb3IpIHRyYWNrZXIgLT4gdW5pdFxuICAgICAgPSBcImNhbWxfbWVtcHJvZl9zdGFydFwiXG5cbiAgICBsZXQgc3RhcnRcbiAgICAgIH5zYW1wbGluZ19yYXRlXG4gICAgICA/KGNhbGxzdGFja19zaXplID0gbWF4X2ludClcbiAgICAgIHRyYWNrZXIgPVxuICAgICAgY19zdGFydCBzYW1wbGluZ19yYXRlIGNhbGxzdGFja19zaXplIHRyYWNrZXJcblxuICAgIGV4dGVybmFsIHN0b3AgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfbWVtcHJvZl9zdG9wXCJcbiAgZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1lc3NhZ2UgZGlnZXN0IChNRDUpICopXG5cbnR5cGUgdCA9IHN0cmluZ1xuXG5sZXQgY29tcGFyZSA9IFN0cmluZy5jb21wYXJlXG5sZXQgZXF1YWwgPSBTdHJpbmcuZXF1YWxcblxuZXh0ZXJuYWwgdW5zYWZlX3N0cmluZzogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9tZDVfc3RyaW5nXCJcbmV4dGVybmFsIGNoYW5uZWw6IGluX2NoYW5uZWwgLT4gaW50IC0+IHQgPSBcImNhbWxfbWQ1X2NoYW5cIlxuXG5sZXQgc3RyaW5nIHN0ciA9XG4gIHVuc2FmZV9zdHJpbmcgc3RyIDAgKFN0cmluZy5sZW5ndGggc3RyKVxuXG5sZXQgYnl0ZXMgYiA9IHN0cmluZyAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiKVxuXG5sZXQgc3Vic3RyaW5nIHN0ciBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IFN0cmluZy5sZW5ndGggc3RyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3Quc3Vic3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfc3RyaW5nIHN0ciBvZnMgbGVuXG5cbmxldCBzdWJieXRlcyBiIG9mcyBsZW4gPSBzdWJzdHJpbmcgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYikgb2ZzIGxlblxuXG5sZXQgZmlsZSBmaWxlbmFtZSA9XG4gIGxldCBpYyA9IG9wZW5faW5fYmluIGZpbGVuYW1lIGluXG4gIG1hdGNoIGNoYW5uZWwgaWMgKC0xKSB3aXRoXG4gICAgfCBkIC0+IGNsb3NlX2luIGljOyBkXG4gICAgfCBleGNlcHRpb24gZSAtPiBjbG9zZV9pbiBpYzsgcmFpc2UgZVxuXG5sZXQgb3V0cHV0IGNoYW4gZGlnZXN0ID1cbiAgb3V0cHV0X3N0cmluZyBjaGFuIGRpZ2VzdFxuXG5sZXQgaW5wdXQgY2hhbiA9IHJlYWxseV9pbnB1dF9zdHJpbmcgY2hhbiAxNlxuXG5sZXQgY2hhcl9oZXggbiA9XG4gIENoYXIudW5zYWZlX2NociAobiArIGlmIG4gPCAxMCB0aGVuIENoYXIuY29kZSAnMCcgZWxzZSAoQ2hhci5jb2RlICdhJyAtIDEwKSlcblxubGV0IHRvX2hleCBkID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBkIDw+IDE2IHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3QudG9faGV4XCI7XG4gIGxldCByZXN1bHQgPSBCeXRlcy5jcmVhdGUgMzIgaW5cbiAgZm9yIGkgPSAwIHRvIDE1IGRvXG4gICAgbGV0IHggPSBDaGFyLmNvZGUgZC5baV0gaW5cbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlc3VsdCAoaSoyKSAoY2hhcl9oZXggKHggbHNyIDQpKTtcbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlc3VsdCAoaSoyKzEpIChjaGFyX2hleCAoeCBsYW5kIDB4MGYpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXN1bHRcblxubGV0IGZyb21faGV4IHMgPVxuICBpZiBTdHJpbmcubGVuZ3RoIHMgPD4gMzIgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5mcm9tX2hleFwiO1xuICBsZXQgZGlnaXQgYyA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnMCcuLic5JyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnMCdcbiAgICB8ICdBJy4uJ0YnIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICdBJyArIDEwXG4gICAgfCAnYScuLidmJyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnYScgKyAxMFxuICAgIHwgXyAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkRpZ2VzdC5mcm9tX2hleFwiKVxuICBpblxuICBsZXQgYnl0ZSBpID0gZGlnaXQgcy5baV0gbHNsIDQgKyBkaWdpdCBzLltpKzFdIGluXG4gIGxldCByZXN1bHQgPSBCeXRlcy5jcmVhdGUgMTYgaW5cbiAgZm9yIGkgPSAwIHRvIDE1IGRvXG4gICAgQnl0ZXMuc2V0IHJlc3VsdCBpIChDaGFyLmNociAoYnl0ZSAoMiAqIGkpKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzdWx0XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEhhc2ggdGFibGVzICopXG5cbigqIFdlIGRvIGR5bmFtaWMgaGFzaGluZywgYW5kIHJlc2l6ZSB0aGUgdGFibGUgYW5kIHJlaGFzaCB0aGUgZWxlbWVudHNcbiAgIHdoZW4gYnVja2V0cyBiZWNvbWUgdG9vIGxvbmcuICopXG5cbnR5cGUgKCdhLCAnYikgdCA9XG4gIHsgbXV0YWJsZSBzaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgKCogbnVtYmVyIG9mIGVudHJpZXMgKilcbiAgICBtdXRhYmxlIGRhdGE6ICgnYSwgJ2IpIGJ1Y2tldGxpc3QgYXJyYXk7ICAoKiB0aGUgYnVja2V0cyAqKVxuICAgIHNlZWQ6IGludDsgICAgICAgICAgICAgICAgICAgICAgICAoKiBmb3IgcmFuZG9taXphdGlvbiAqKVxuICAgIG11dGFibGUgaW5pdGlhbF9zaXplOiBpbnQ7ICAgICAgICAgICAgICAgICgqIGluaXRpYWwgYXJyYXkgc2l6ZSAqKVxuICB9XG5cbmFuZCAoJ2EsICdiKSBidWNrZXRsaXN0ID1cbiAgICBFbXB0eVxuICB8IENvbnMgb2YgeyBtdXRhYmxlIGtleTogJ2E7XG4gICAgICAgICAgICAgIG11dGFibGUgZGF0YTogJ2I7XG4gICAgICAgICAgICAgIG11dGFibGUgbmV4dDogKCdhLCAnYikgYnVja2V0bGlzdCB9XG5cbigqIFRoZSBzaWduIG9mIGluaXRpYWxfc2l6ZSBlbmNvZGVzIHRoZSBmYWN0IHRoYXQgYSB0cmF2ZXJzYWwgaXNcbiAgIG9uZ29pbmcgb3Igbm90LlxuXG4gICBUaGlzIGRpc2FibGVzIHRoZSBlZmZpY2llbnQgaW4gcGxhY2UgaW1wbGVtZW50YXRpb24gb2YgcmVzaXppbmcuXG4qKVxuXG5sZXQgb25nb2luZ190cmF2ZXJzYWwgaCA9XG4gIE9iai5zaXplIChPYmoucmVwciBoKSA8IDQgKCogY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBoYXNoIHRhYmxlcyAqKVxuICB8fCBoLmluaXRpYWxfc2l6ZSA8IDBcblxubGV0IGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaCA9XG4gIGguaW5pdGlhbF9zaXplIDwtIC0gaC5pbml0aWFsX3NpemVcblxuKCogVG8gcGljayByYW5kb20gc2VlZHMgaWYgcmVxdWVzdGVkICopXG5cbmxldCByYW5kb21pemVkX2RlZmF1bHQgPVxuICBsZXQgcGFyYW1zID1cbiAgICB0cnkgU3lzLmdldGVudiBcIk9DQU1MUlVOUEFSQU1cIiB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiQ0FNTFJVTlBBUkFNXCIgd2l0aCBOb3RfZm91bmQgLT4gXCJcIiBpblxuICBTdHJpbmcuY29udGFpbnMgcGFyYW1zICdSJ1xuXG5sZXQgcmFuZG9taXplZCA9IHJlZiByYW5kb21pemVkX2RlZmF1bHRcblxubGV0IHJhbmRvbWl6ZSAoKSA9IHJhbmRvbWl6ZWQgOj0gdHJ1ZVxubGV0IGlzX3JhbmRvbWl6ZWQgKCkgPSAhcmFuZG9taXplZFxuXG5sZXQgcHJuZyA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCgpKVxuXG4oKiBGdW5jdGlvbnMgd2hpY2ggYXBwZWFyIGJlZm9yZSB0aGUgZnVuY3RvcmlhbCBpbnRlcmZhY2UgbXVzdCBlaXRoZXIgYmVcbiAgIGluZGVwZW5kZW50IG9mIHRoZSBoYXNoIGZ1bmN0aW9uIG9yIHRha2UgaXQgYXMgYSBwYXJhbWV0ZXIgKHNlZSAjMjIwMiBhbmRcbiAgIGNvZGUgYmVsb3cgdGhlIGZ1bmN0b3IgZGVmaW5pdGlvbnMuICopXG5cbigqIENyZWF0aW5nIGEgZnJlc2gsIGVtcHR5IHRhYmxlICopXG5cbmxldCByZWMgcG93ZXJfMl9hYm92ZSB4IG4gPVxuICBpZiB4ID49IG4gdGhlbiB4XG4gIGVsc2UgaWYgeCAqIDIgPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIHhcbiAgZWxzZSBwb3dlcl8yX2Fib3ZlICh4ICogMikgblxuXG5sZXQgY3JlYXRlID8ocmFuZG9tID0gIXJhbmRvbWl6ZWQpIGluaXRpYWxfc2l6ZSA9XG4gIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgbGV0IHNlZWQgPSBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSBlbHNlIDAgaW5cbiAgeyBpbml0aWFsX3NpemUgPSBzOyBzaXplID0gMDsgc2VlZCA9IHNlZWQ7IGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHkgfVxuXG5sZXQgY2xlYXIgaCA9XG4gIGlmIGguc2l6ZSA+IDAgdGhlbiBiZWdpblxuICAgIGguc2l6ZSA8LSAwO1xuICAgIEFycmF5LmZpbGwgaC5kYXRhIDAgKEFycmF5Lmxlbmd0aCBoLmRhdGEpIEVtcHR5XG4gIGVuZFxuXG5sZXQgcmVzZXQgaCA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA8IDQgKCogY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBoYXNoIHRhYmxlcyAqKVxuICAgIHx8IGxlbiA9IGFicyBoLmluaXRpYWxfc2l6ZSB0aGVuXG4gICAgY2xlYXIgaFxuICBlbHNlIGJlZ2luXG4gICAgaC5zaXplIDwtIDA7XG4gICAgaC5kYXRhIDwtIEFycmF5Lm1ha2UgKGFicyBoLmluaXRpYWxfc2l6ZSkgRW1wdHlcbiAgZW5kXG5cbmxldCBjb3B5X2J1Y2tldGxpc3QgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IEVtcHR5XG4gIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgbGV0IHJlYyBsb29wIHByZWMgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgICAgbGV0IHIgPSBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICB8IENvbnMgcHJlYyAtPiAgcHJlYy5uZXh0IDwtIHJcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGxvb3AgciBuZXh0XG4gICAgICBpblxuICAgICAgbGV0IHIgPSBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGluXG4gICAgICBsb29wIHIgbmV4dDtcbiAgICAgIHJcblxubGV0IGNvcHkgaCA9IHsgaCB3aXRoIGRhdGEgPSBBcnJheS5tYXAgY29weV9idWNrZXRsaXN0IGguZGF0YSB9XG5cbmxldCBsZW5ndGggaCA9IGguc2l6ZVxuXG5sZXQgaW5zZXJ0X2FsbF9idWNrZXRzIGluZGV4ZnVuIGlucGxhY2Ugb2RhdGEgbmRhdGEgPVxuICBsZXQgbnNpemUgPSBBcnJheS5sZW5ndGggbmRhdGEgaW5cbiAgbGV0IG5kYXRhX3RhaWwgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gIGxldCByZWMgaW5zZXJ0X2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSBhcyBjZWxsIC0+XG4gICAgICAgIGxldCBjZWxsID1cbiAgICAgICAgICBpZiBpbnBsYWNlIHRoZW4gY2VsbFxuICAgICAgICAgIGVsc2UgQ29ucyB7a2V5OyBkYXRhOyBuZXh0ID0gRW1wdHl9XG4gICAgICAgIGluXG4gICAgICAgIGxldCBuaWR4ID0gaW5kZXhmdW4ga2V5IGluXG4gICAgICAgIGJlZ2luIG1hdGNoIG5kYXRhX3RhaWwuKG5pZHgpIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBuZGF0YS4obmlkeCkgPC0gY2VsbDtcbiAgICAgICAgfCBDb25zIHRhaWwgLT4gdGFpbC5uZXh0IDwtIGNlbGw7XG4gICAgICAgIGVuZDtcbiAgICAgICAgbmRhdGFfdGFpbC4obmlkeCkgPC0gY2VsbDtcbiAgICAgICAgaW5zZXJ0X2J1Y2tldCBuZXh0XG4gIGluXG4gIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggb2RhdGEgLSAxIGRvXG4gICAgaW5zZXJ0X2J1Y2tldCBvZGF0YS4oaSlcbiAgZG9uZTtcbiAgaWYgaW5wbGFjZSB0aGVuXG4gICAgZm9yIGkgPSAwIHRvIG5zaXplIC0gMSBkb1xuICAgICAgbWF0Y2ggbmRhdGFfdGFpbC4oaSkgd2l0aFxuICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgfCBDb25zIHRhaWwgLT4gdGFpbC5uZXh0IDwtIEVtcHR5XG4gICAgZG9uZVxuXG5sZXQgcmVzaXplIGluZGV4ZnVuIGggPVxuICBsZXQgb2RhdGEgPSBoLmRhdGEgaW5cbiAgbGV0IG9zaXplID0gQXJyYXkubGVuZ3RoIG9kYXRhIGluXG4gIGxldCBuc2l6ZSA9IG9zaXplICogMiBpblxuICBpZiBuc2l6ZSA8IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4gYmVnaW5cbiAgICBsZXQgbmRhdGEgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgbGV0IGlucGxhY2UgPSBub3QgKG9uZ29pbmdfdHJhdmVyc2FsIGgpIGluXG4gICAgaC5kYXRhIDwtIG5kYXRhOyAgICAgICAgICAoKiBzbyB0aGF0IGluZGV4ZnVuIHNlZXMgdGhlIG5ldyBidWNrZXQgY291bnQgKilcbiAgICBpbnNlcnRfYWxsX2J1Y2tldHMgKGluZGV4ZnVuIGgpIGlucGxhY2Ugb2RhdGEgbmRhdGFcbiAgZW5kXG5cbmxldCBpdGVyIGYgaCA9XG4gIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+XG4gICAgICAgICgpXG4gICAgfCBDb25ze2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgZiBrZXkgZGF0YTsgZG9fYnVja2V0IG5leHQgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgZG9fYnVja2V0IGQuKGkpXG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIEVtcHR5XG4gICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gRW1wdHlcbiAgICAgIGVuZFxuICB8IChDb25zICh7a2V5OyBkYXRhOyBuZXh0fSBhcyBjKSkgYXMgc2xvdCAtPlxuICAgICAgYmVnaW4gbWF0Y2ggZiBrZXkgZGF0YSB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHByZWMgbmV4dFxuICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gc2xvdFxuICAgICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBzbG90XG4gICAgICAgICAgZW5kO1xuICAgICAgICAgIGMuZGF0YSA8LSBkYXRhO1xuICAgICAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgc2xvdCBuZXh0XG4gICAgICBlbmRcblxubGV0IGZpbHRlcl9tYXBfaW5wbGFjZSBmIGggPVxuICBsZXQgZCA9IGguZGF0YSBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBFbXB0eSBoLmRhdGEuKGkpXG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGhcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbmxldCBmb2xkIGYgaCBpbml0ID1cbiAgbGV0IHJlYyBkb19idWNrZXQgYiBhY2N1ID1cbiAgICBtYXRjaCBiIHdpdGhcbiAgICAgIEVtcHR5IC0+XG4gICAgICAgIGFjY3VcbiAgICB8IENvbnN7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBkb19idWNrZXQgbmV4dCAoZiBrZXkgZGF0YSBhY2N1KSBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICBsZXQgYWNjdSA9IHJlZiBpbml0IGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgYWNjdSA6PSBkb19idWNrZXQgZC4oaSkgIWFjY3VcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICAhYWNjdVxuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxudHlwZSBzdGF0aXN0aWNzID0ge1xuICBudW1fYmluZGluZ3M6IGludDtcbiAgbnVtX2J1Y2tldHM6IGludDtcbiAgbWF4X2J1Y2tldF9sZW5ndGg6IGludDtcbiAgYnVja2V0X2hpc3RvZ3JhbTogaW50IGFycmF5XG59XG5cbmxldCByZWMgYnVja2V0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhY2N1XG4gIHwgQ29uc3tuZXh0fSAtPiBidWNrZXRfbGVuZ3RoIChhY2N1ICsgMSkgbmV4dFxuXG5sZXQgc3RhdHMgaCA9XG4gIGxldCBtYmwgPVxuICAgIEFycmF5LmZvbGRfbGVmdCAoZnVuIG0gYiAtPiBJbnQubWF4IG0gKGJ1Y2tldF9sZW5ndGggMCBiKSkgMCBoLmRhdGEgaW5cbiAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICBBcnJheS5pdGVyXG4gICAgKGZ1biBiIC0+XG4gICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGggMCBiIGluXG4gICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICBoLmRhdGE7XG4gIHsgbnVtX2JpbmRpbmdzID0gaC5zaXplO1xuICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHRibCA9XG4gICgqIGNhcHR1cmUgY3VycmVudCBhcnJheSwgc28gdGhhdCBldmVuIGlmIHRoZSB0YWJsZSBpcyByZXNpemVkIHdlXG4gICAgIGtlZXAgaXRlcmF0aW5nIG9uIHRoZSBzYW1lIGFycmF5ICopXG4gIGxldCB0YmxfZGF0YSA9IHRibC5kYXRhIGluXG4gICgqIHN0YXRlOiBpbmRleCAqIG5leHQgYnVja2V0IHRvIHRyYXZlcnNlICopXG4gIGxldCByZWMgYXV4IGkgYnVjayAoKSA9IG1hdGNoIGJ1Y2sgd2l0aFxuICAgIHwgRW1wdHkgLT5cbiAgICAgICAgaWYgaSA9IEFycmF5Lmxlbmd0aCB0YmxfZGF0YVxuICAgICAgICB0aGVuIFNlcS5OaWxcbiAgICAgICAgZWxzZSBhdXgoaSsxKSB0YmxfZGF0YS4oaSkgKClcbiAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgU2VxLkNvbnMgKChrZXksIGRhdGEpLCBhdXggaSBuZXh0KVxuICBpblxuICBhdXggMCBFbXB0eVxuXG5sZXQgdG9fc2VxX2tleXMgbSA9IFNlcS5tYXAgZnN0ICh0b19zZXEgbSlcblxubGV0IHRvX3NlcV92YWx1ZXMgbSA9IFNlcS5tYXAgc25kICh0b19zZXEgbSlcblxuKCogRnVuY3RvcmlhbCBpbnRlcmZhY2UgKilcblxubW9kdWxlIHR5cGUgSGFzaGVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaGFzaDogdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFNlZWRlZEhhc2hlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGhhc2g6IGludCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAhJ2EgdFxuICAgIHZhbCBjcmVhdGU6IGludCAtPiAnYSB0XG4gICAgdmFsIGNsZWFyIDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIHJlc2V0IDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIGNvcHk6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBhZGQ6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgcmVtb3ZlOiAnYSB0IC0+IGtleSAtPiB1bml0XG4gICAgdmFsIGZpbmQ6ICdhIHQgLT4ga2V5IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9hbGw6ICdhIHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmaWx0ZXJfbWFwX2lucGxhY2U6IChrZXkgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBsZW5ndGg6ICdhIHQgLT4gaW50XG4gICAgdmFsIHN0YXRzOiAnYSB0IC0+IHN0YXRpc3RpY3NcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9rZXlzIDogXyB0IC0+IGtleSBTZXEudFxuICAgIHZhbCB0b19zZXFfdmFsdWVzIDogJ2EgdCAtPiAnYSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgcmVwbGFjZV9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFNlZWRlZFMgPVxuICBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgISdhIHRcbiAgICB2YWwgY3JlYXRlIDogP3JhbmRvbTpib29sIC0+IGludCAtPiAnYSB0XG4gICAgdmFsIGNsZWFyIDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIHJlc2V0IDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIGNvcHkgOiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgYWRkIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmUgOiAnYSB0IC0+IGtleSAtPiB1bml0XG4gICAgdmFsIGZpbmQgOiAnYSB0IC0+IGtleSAtPiAnYVxuICAgIHZhbCBmaW5kX29wdDogJ2EgdCAtPiBrZXkgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGZpbmRfYWxsIDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXIgOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmaWx0ZXJfbWFwX2lucGxhY2U6IChrZXkgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZCA6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIE1ha2VTZWVkZWQoSDogU2VlZGVkSGFzaGVkVHlwZSk6IChTZWVkZWRTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgdHlwZSBrZXkgPSBILnRcbiAgICB0eXBlICdhIGhhc2h0YmwgPSAoa2V5LCAnYSkgdFxuICAgIHR5cGUgJ2EgdCA9ICdhIGhhc2h0YmxcbiAgICBsZXQgY3JlYXRlID0gY3JlYXRlXG4gICAgbGV0IGNsZWFyID0gY2xlYXJcbiAgICBsZXQgcmVzZXQgPSByZXNldFxuICAgIGxldCBjb3B5ID0gY29weVxuXG4gICAgbGV0IGtleV9pbmRleCBoIGtleSA9XG4gICAgICAoSC5oYXNoIGguc2VlZCBrZXkpIGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuXG4gICAgbGV0IGFkZCBoIGtleSBkYXRhID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICBsZXQgYnVja2V0ID0gQ29uc3trZXk7IGRhdGE7IG5leHQ9aC5kYXRhLihpKX0gaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9idWNrZXQgaCBpIGtleSBwcmVjID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAoKVxuICAgICAgfCAoQ29ucyB7a2V5PWs7IG5leHR9KSBhcyBjIC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIG5leHRcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxuICAgIGxldCByZW1vdmUgaCBrZXkgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjIGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgayB0aGVuIGRhdGEgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dFxuXG4gICAgbGV0IGZpbmQgaCBrZXkgPVxuICAgICAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsxIHRoZW4gZDEgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsyIHRoZW4gZDIgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMyB0aGVuIGQzIGVsc2UgZmluZF9yZWMga2V5IG5leHQzXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbiAgICBsZXQgZmluZF9vcHQgaCBrZXkgPVxuICAgICAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMSB0aGVuIFNvbWUgZDEgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMiB0aGVuIFNvbWUgZDIgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazMgdGhlbiBTb21lIGQzIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0M1xuXG4gICAgbGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgICAgIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIFtdXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE9ZDsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiBkIDo6IGZpbmRfaW5fYnVja2V0IG5leHRcbiAgICAgICAgICBlbHNlIGZpbmRfaW5fYnVja2V0IG5leHQgaW5cbiAgICAgIGZpbmRfaW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG4gICAgbGV0IHJlYyByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgfCBDb25zICh7a2V5PWs7IG5leHR9IGFzIHNsb3QpIC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gKHNsb3Qua2V5IDwtIGtleTsgc2xvdC5kYXRhIDwtIGRhdGE7IGZhbHNlKVxuICAgICAgICAgIGVsc2UgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbmV4dFxuXG4gICAgbGV0IHJlcGxhY2UgaCBrZXkgZGF0YSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgbGV0IGwgPSBoLmRhdGEuKGkpIGluXG4gICAgICBpZiByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBsIHRoZW4gYmVnaW5cbiAgICAgICAgaC5kYXRhLihpKSA8LSBDb25ze2tleTsgZGF0YTsgbmV4dD1sfTtcbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcbiAgICAgIGVuZFxuXG4gICAgbGV0IG1lbSBoIGtleSA9XG4gICAgICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnN7a2V5PWs7IG5leHR9IC0+XG4gICAgICAgICAgSC5lcXVhbCBrIGtleSB8fCBtZW1faW5fYnVja2V0IG5leHQgaW5cbiAgICAgIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbiAgICBsZXQgYWRkX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IGFkZCB0YmwgayB2KSBpXG5cbiAgICBsZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiByZXBsYWNlIHRibCBrIHYpIGlcblxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuXG4gICAgbGV0IGl0ZXIgPSBpdGVyXG4gICAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSA9IGZpbHRlcl9tYXBfaW5wbGFjZVxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgc3RhdHMgPSBzdGF0c1xuICAgIGxldCB0b19zZXEgPSB0b19zZXFcbiAgICBsZXQgdG9fc2VxX2tleXMgPSB0b19zZXFfa2V5c1xuICAgIGxldCB0b19zZXFfdmFsdWVzID0gdG9fc2VxX3ZhbHVlc1xuICBlbmRcblxubW9kdWxlIE1ha2UoSDogSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuXG4oKiBQb2x5bW9ycGhpYyBoYXNoIGZ1bmN0aW9uLWJhc2VkIHRhYmxlcyAqKVxuKCogQ29kZSBpbmNsdWRlZCBiZWxvdyB0aGUgZnVuY3RvcmlhbCBpbnRlcmZhY2UgdG8gZ3VhcmQgYWdhaW5zdCBhY2NpZGVudGFsXG4gICB1c2UgLSBzZWUgIzIyMDIgKilcblxuZXh0ZXJuYWwgc2VlZGVkX2hhc2hfcGFyYW0gOlxuICBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiBpbnQgPSBcImNhbWxfaGFzaFwiIFtAQG5vYWxsb2NdXG5cbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG5sZXQgaGFzaF9wYXJhbSBuMSBuMiB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gbjEgbjIgMCB4XG5sZXQgc2VlZGVkX2hhc2ggc2VlZCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIHNlZWQgeFxuXG5sZXQga2V5X2luZGV4IGgga2V5ID1cbiAgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpID49IDRcbiAgdGhlbiAoc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIGguc2VlZCBrZXkpIGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuICBlbHNlIGludmFsaWRfYXJnIFwiSGFzaHRibDogdW5zdXBwb3J0ZWQgaGFzaCB0YWJsZSBmb3JtYXRcIlxuXG5sZXQgYWRkIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgYnVja2V0ID0gQ29uc3trZXk7IGRhdGE7IG5leHQ9aC5kYXRhLihpKX0gaW5cbiAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG5cbmxldCByZWMgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IHByZWMgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICAoKVxuICB8IChDb25zIHtrZXk9azsgbmV4dH0pIGFzIGMgLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIGJlZ2luXG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIG5leHRcbiAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIG5leHRcbiAgICAgIGVuZFxuICAgICAgZWxzZSByZW1vdmVfYnVja2V0IGggaSBrZXkgYyBuZXh0XG5cbmxldCByZW1vdmUgaCBrZXkgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICByZW1vdmVfYnVja2V0IGggaSBrZXkgRW1wdHkgaC5kYXRhLihpKVxuXG5sZXQgcmVjIGZpbmRfcmVjIGtleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIGRhdGEgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dFxuXG5sZXQgZmluZCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrMSA9IDAgdGhlbiBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMiA9IDAgdGhlbiBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgaWYgY29tcGFyZSBrZXkgazMgPSAwIHRoZW4gZDMgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dDNcblxubGV0IHJlYyBmaW5kX3JlY19vcHQga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgTm9uZVxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIFNvbWUgZGF0YSBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dFxuXG5sZXQgZmluZF9vcHQgaCBrZXkgPVxuICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICB8IEVtcHR5IC0+IE5vbmVcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIFNvbWUgZDEgZWxzZVxuICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIFNvbWUgZDIgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBTb21lIGQzIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0M1xuXG5sZXQgZmluZF9hbGwgaCBrZXkgPVxuICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgW11cbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gZGF0YSA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICBlbHNlIGZpbmRfaW5fYnVja2V0IG5leHQgaW5cbiAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gKHNsb3Qua2V5IDwtIGtleTsgc2xvdC5kYXRhIDwtIGRhdGE7IGZhbHNlKVxuICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbmxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgaC5kYXRhLihpKSA8LSBDb25ze2tleTsgZGF0YTsgbmV4dD1sfTtcbiAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gIGVuZFxuXG5sZXQgbWVtIGgga2V5ID1cbiAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgY29tcGFyZSBrIGtleSA9IDAgfHwgbWVtX2luX2J1Y2tldCBuZXh0IGluXG4gIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCBhZGRfc2VxIHRibCBpID1cbiAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG5sZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gIHJlcGxhY2Vfc2VxIHRibCBpO1xuICB0YmxcblxubGV0IHJlYnVpbGQgPyhyYW5kb20gPSAhcmFuZG9taXplZCkgaCA9XG4gIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiAoQXJyYXkubGVuZ3RoIGguZGF0YSkgaW5cbiAgbGV0IHNlZWQgPVxuICAgIGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpXG4gICAgZWxzZSBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPj0gNCB0aGVuIGguc2VlZFxuICAgIGVsc2UgMCBpblxuICBsZXQgaCcgPSB7XG4gICAgc2l6ZSA9IGguc2l6ZTtcbiAgICBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5O1xuICAgIHNlZWQgPSBzZWVkO1xuICAgIGluaXRpYWxfc2l6ZSA9IGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSA0IHRoZW4gaC5pbml0aWFsX3NpemUgZWxzZSBzXG4gIH0gaW5cbiAgaW5zZXJ0X2FsbF9idWNrZXRzIChrZXlfaW5kZXggaCcpIGZhbHNlIGguZGF0YSBoJy5kYXRhO1xuICBoJ1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiogV2VhayBhcnJheSBvcGVyYXRpb25zICopXG5cbnR5cGUgISdhIHRcblxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+ICdhIHQgPSBcImNhbWxfd2Vha19jcmVhdGVcIlxuXG5sZXQgY3JlYXRlIGwgPVxuICBpZiBub3QgKDAgPD0gbCAmJiBsIDw9IE9iai5FcGhlbWVyb24ubWF4X2VwaGVfbGVuZ3RoKSB0aGVuXG4gICAgaW52YWxpZF9hcmcoXCJXZWFrLmNyZWF0ZVwiKTtcbiAgY3JlYXRlIGxcblxuKCoqIG51bWJlciBvZiBhZGRpdGlvbmFsIHZhbHVlcyBpbiBhIHdlYWsgcG9pbnRlciAqKVxubGV0IGFkZGl0aW9uYWxfdmFsdWVzID0gMlxuXG5sZXQgbGVuZ3RoIHggPSBPYmouc2l6ZShPYmoucmVwciB4KSAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbmxldCByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gbXNnID1cbiAgaWYgbm90ICgwIDw9IG8gJiYgbyA8IGxlbmd0aCBlKSB0aGVuXG4gICAgaW52YWxpZF9hcmcobXNnKVxuXG5leHRlcm5hbCBzZXQnIDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9rZXlcIlxuZXh0ZXJuYWwgdW5zZXQgOiAnYSB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfa2V5XCJcbmxldCBzZXQgZSBvIHggPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLnNldFwiO1xuICBtYXRjaCB4IHdpdGhcbiAgfCBOb25lIC0+IHVuc2V0IGUgb1xuICB8IFNvbWUgeCAtPiBzZXQnIGUgbyB4XG5cbmV4dGVybmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvbiA9IFwiY2FtbF93ZWFrX2dldFwiXG5sZXQgZ2V0IGUgbyA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuZ2V0XCI7XG4gIGdldCBlIG9cblxuZXh0ZXJuYWwgZ2V0X2NvcHkgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gPSBcImNhbWxfd2Vha19nZXRfY29weVwiXG5sZXQgZ2V0X2NvcHkgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5nZXRfY29weVwiO1xuICBnZXRfY29weSBlIG9cblxuZXh0ZXJuYWwgY2hlY2sgOiAnYSB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX3dlYWtfY2hlY2tcIlxubGV0IGNoZWNrIGUgbyA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuY2hlY2tcIjtcbiAgY2hlY2sgZSBvXG5cbmV4dGVybmFsIGJsaXQgOiAnYSB0IC0+IGludCAtPiAnYSB0IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF93ZWFrX2JsaXRcIlxuXG4oKiBibGl0OiBzcmMgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuICopXG5sZXQgYmxpdCBlMSBvMSBlMiBvMiBsID1cbiAgaWYgbCA8IDAgfHwgbzEgPCAwIHx8IG8xID4gbGVuZ3RoIGUxIC0gbFxuICAgICB8fCBvMiA8IDAgfHwgbzIgPiBsZW5ndGggZTIgLSBsXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJXZWFrLmJsaXRcIlxuICBlbHNlIGlmIGwgPD4gMCB0aGVuIGJsaXQgZTEgbzEgZTIgbzIgbFxuXG5sZXQgZmlsbCBhciBvZnMgbGVuIHggPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGFyIC0gbGVuXG4gIHRoZW4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJXZWFrLmZpbGxcIilcbiAgZWxzZSBiZWdpblxuICAgIGZvciBpID0gb2ZzIHRvIChvZnMgKyBsZW4gLSAxKSBkb1xuICAgICAgc2V0IGFyIGkgeFxuICAgIGRvbmVcbiAgZW5kXG5cblxuKCoqIFdlYWsgaGFzaCB0YWJsZXMgKilcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIGRhdGFcbiAgdHlwZSB0XG4gIHZhbCBjcmVhdGUgOiBpbnQgLT4gdFxuICB2YWwgY2xlYXIgOiB0IC0+IHVuaXRcbiAgdmFsIG1lcmdlIDogdCAtPiBkYXRhIC0+IGRhdGFcbiAgdmFsIGFkZCA6IHQgLT4gZGF0YSAtPiB1bml0XG4gIHZhbCByZW1vdmUgOiB0IC0+IGRhdGEgLT4gdW5pdFxuICB2YWwgZmluZCA6IHQgLT4gZGF0YSAtPiBkYXRhXG4gIHZhbCBmaW5kX29wdCA6IHQgLT4gZGF0YSAtPiBkYXRhIG9wdGlvblxuICB2YWwgZmluZF9hbGwgOiB0IC0+IGRhdGEgLT4gZGF0YSBsaXN0XG4gIHZhbCBtZW0gOiB0IC0+IGRhdGEgLT4gYm9vbFxuICB2YWwgaXRlciA6IChkYXRhIC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICB2YWwgZm9sZCA6IChkYXRhIC0+ICdhIC0+ICdhKSAtPiB0IC0+ICdhIC0+ICdhXG4gIHZhbCBjb3VudCA6IHQgLT4gaW50XG4gIHZhbCBzdGF0cyA6IHQgLT4gaW50ICogaW50ICogaW50ICogaW50ICogaW50ICogaW50XG5lbmRcblxubW9kdWxlIE1ha2UgKEggOiBIYXNodGJsLkhhc2hlZFR5cGUpIDogKFMgd2l0aCB0eXBlIGRhdGEgPSBILnQpID0gc3RydWN0XG5cbiAgdHlwZSAnYSB3ZWFrX3QgPSAnYSB0XG4gIGxldCB3ZWFrX2NyZWF0ZSA9IGNyZWF0ZVxuICBsZXQgZW1wdHlidWNrZXQgPSB3ZWFrX2NyZWF0ZSAwXG5cbiAgdHlwZSBkYXRhID0gSC50XG5cbiAgdHlwZSB0ID0ge1xuICAgIG11dGFibGUgdGFibGUgOiBkYXRhIHdlYWtfdCBhcnJheTtcbiAgICBtdXRhYmxlIGhhc2hlcyA6IGludCBhcnJheSBhcnJheTtcbiAgICBtdXRhYmxlIGxpbWl0IDogaW50OyAgICAgICAgICAgICAgICgqIGJ1Y2tldCBzaXplIGxpbWl0ICopXG4gICAgbXV0YWJsZSBvdmVyc2l6ZSA6IGludDsgICAgICAgICAgICAoKiBudW1iZXIgb2Ygb3ZlcnNpemUgYnVja2V0cyAqKVxuICAgIG11dGFibGUgcm92ZXIgOiBpbnQ7ICAgICAgICAgICAgICAgKCogZm9yIGludGVybmFsIGJvb2trZWVwaW5nICopXG4gIH1cblxuICBsZXQgZ2V0X2luZGV4IHQgaCA9IChoIGxhbmQgbWF4X2ludCkgbW9kIChBcnJheS5sZW5ndGggdC50YWJsZSlcblxuICBsZXQgbGltaXQgPSA3XG4gIGxldCBvdmVyX2xpbWl0ID0gMlxuXG4gIGxldCBjcmVhdGUgc3ogPVxuICAgIGxldCBzeiA9IGlmIHN6IDwgNyB0aGVuIDcgZWxzZSBzeiBpblxuICAgIGxldCBzeiA9IGlmIHN6ID4gU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiBTeXMubWF4X2FycmF5X2xlbmd0aCBlbHNlIHN6IGluXG4gICAge1xuICAgICAgdGFibGUgPSBBcnJheS5tYWtlIHN6IGVtcHR5YnVja2V0O1xuICAgICAgaGFzaGVzID0gQXJyYXkubWFrZSBzeiBbfCB8XTtcbiAgICAgIGxpbWl0ID0gbGltaXQ7XG4gICAgICBvdmVyc2l6ZSA9IDA7XG4gICAgICByb3ZlciA9IDA7XG4gICAgfVxuXG4gIGxldCBjbGVhciB0ID1cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxIGRvXG4gICAgICB0LnRhYmxlLihpKSA8LSBlbXB0eWJ1Y2tldDtcbiAgICAgIHQuaGFzaGVzLihpKSA8LSBbfCB8XTtcbiAgICBkb25lO1xuICAgIHQubGltaXQgPC0gbGltaXQ7XG4gICAgdC5vdmVyc2l6ZSA8LSAwXG5cblxuICBsZXQgZm9sZCBmIHQgaW5pdCA9XG4gICAgbGV0IHJlYyBmb2xkX2J1Y2tldCBpIGIgYWNjdSA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gYWNjdSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICAgIHwgU29tZSB2IC0+IGZvbGRfYnVja2V0IChpKzEpIGIgKGYgdiBhY2N1KVxuICAgICAgfCBOb25lIC0+IGZvbGRfYnVja2V0IChpKzEpIGIgYWNjdVxuICAgIGluXG4gICAgQXJyYXkuZm9sZF9yaWdodCAoZm9sZF9idWNrZXQgMCkgdC50YWJsZSBpbml0XG5cblxuICBsZXQgaXRlciBmIHQgPVxuICAgIGxldCByZWMgaXRlcl9idWNrZXQgaSBiID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiAoKSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICAgIHwgU29tZSB2IC0+IGYgdjsgaXRlcl9idWNrZXQgKGkrMSkgYlxuICAgICAgfCBOb25lIC0+IGl0ZXJfYnVja2V0IChpKzEpIGJcbiAgICBpblxuICAgIEFycmF5Lml0ZXIgKGl0ZXJfYnVja2V0IDApIHQudGFibGVcblxuXG4gIGxldCBpdGVyX3dlYWsgZiB0ID1cbiAgICBsZXQgcmVjIGl0ZXJfYnVja2V0IGkgaiBiID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiAoKSBlbHNlXG4gICAgICBtYXRjaCBjaGVjayBiIGkgd2l0aFxuICAgICAgfCB0cnVlIC0+IGYgYiB0Lmhhc2hlcy4oaikgaTsgaXRlcl9idWNrZXQgKGkrMSkgaiBiXG4gICAgICB8IGZhbHNlIC0+IGl0ZXJfYnVja2V0IChpKzEpIGogYlxuICAgIGluXG4gICAgQXJyYXkuaXRlcmkgKGl0ZXJfYnVja2V0IDApIHQudGFibGVcblxuXG4gIGxldCByZWMgY291bnRfYnVja2V0IGkgYiBhY2N1ID1cbiAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gYWNjdSBlbHNlXG4gICAgY291bnRfYnVja2V0IChpKzEpIGIgKGFjY3UgKyAoaWYgY2hlY2sgYiBpIHRoZW4gMSBlbHNlIDApKVxuXG5cbiAgbGV0IGNvdW50IHQgPVxuICAgIEFycmF5LmZvbGRfcmlnaHQgKGNvdW50X2J1Y2tldCAwKSB0LnRhYmxlIDBcblxuXG4gIGxldCBuZXh0X3N6IG4gPSBJbnQubWluICgzICogbiAvIDIgKyAzKSBTeXMubWF4X2FycmF5X2xlbmd0aFxuICBsZXQgcHJldl9zeiBuID0gKChuIC0gMykgKiAyICsgMikgLyAzXG5cbiAgbGV0IHRlc3Rfc2hyaW5rX2J1Y2tldCB0ID1cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4odC5yb3ZlcikgaW5cbiAgICBsZXQgaGJ1Y2tldCA9IHQuaGFzaGVzLih0LnJvdmVyKSBpblxuICAgIGxldCBsZW4gPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHByZXZfbGVuID0gcHJldl9zeiBsZW4gaW5cbiAgICBsZXQgbGl2ZSA9IGNvdW50X2J1Y2tldCAwIGJ1Y2tldCAwIGluXG4gICAgaWYgbGl2ZSA8PSBwcmV2X2xlbiB0aGVuIGJlZ2luXG4gICAgICBsZXQgcmVjIGxvb3AgaSBqID1cbiAgICAgICAgaWYgaiA+PSBwcmV2X2xlbiB0aGVuIGJlZ2luXG4gICAgICAgICAgaWYgY2hlY2sgYnVja2V0IGkgdGhlbiBsb29wIChpICsgMSkgalxuICAgICAgICAgIGVsc2UgaWYgY2hlY2sgYnVja2V0IGogdGhlbiBiZWdpblxuICAgICAgICAgICAgYmxpdCBidWNrZXQgaiBidWNrZXQgaSAxO1xuICAgICAgICAgICAgaGJ1Y2tldC4oaSkgPC0gaGJ1Y2tldC4oaik7XG4gICAgICAgICAgICBsb29wIChpICsgMSkgKGogLSAxKTtcbiAgICAgICAgICBlbmQgZWxzZSBsb29wIGkgKGogLSAxKTtcbiAgICAgICAgZW5kO1xuICAgICAgaW5cbiAgICAgIGxvb3AgMCAobGVuZ3RoIGJ1Y2tldCAtIDEpO1xuICAgICAgaWYgcHJldl9sZW4gPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgdC50YWJsZS4odC5yb3ZlcikgPC0gZW1wdHlidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLih0LnJvdmVyKSA8LSBbfCB8XTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBuZXdidWNrZXQgPSB3ZWFrX2NyZWF0ZSBwcmV2X2xlbiBpblxuICAgICAgICBibGl0IGJ1Y2tldCAwIG5ld2J1Y2tldCAwIHByZXZfbGVuO1xuICAgICAgICB0LnRhYmxlLih0LnJvdmVyKSA8LSBuZXdidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLih0LnJvdmVyKSA8LSBBcnJheS5zdWIgaGJ1Y2tldCAwIHByZXZfbGVuXG4gICAgICBlbmQ7XG4gICAgICBpZiBsZW4gPiB0LmxpbWl0ICYmIHByZXZfbGVuIDw9IHQubGltaXQgdGhlbiB0Lm92ZXJzaXplIDwtIHQub3ZlcnNpemUgLSAxO1xuICAgIGVuZDtcbiAgICB0LnJvdmVyIDwtICh0LnJvdmVyICsgMSkgbW9kIChBcnJheS5sZW5ndGggdC50YWJsZSlcblxuXG4gIGxldCByZWMgcmVzaXplIHQgPVxuICAgIGxldCBvbGRsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBuZXdsZW4gPSBuZXh0X3N6IG9sZGxlbiBpblxuICAgIGlmIG5ld2xlbiA+IG9sZGxlbiB0aGVuIGJlZ2luXG4gICAgICBsZXQgbmV3dCA9IGNyZWF0ZSBuZXdsZW4gaW5cbiAgICAgIGxldCBhZGRfd2VhayBvYiBvaCBvaSA9XG4gICAgICAgIGxldCBzZXR0ZXIgbmIgbmkgXyA9IGJsaXQgb2Igb2kgbmIgbmkgMSBpblxuICAgICAgICBsZXQgaCA9IG9oLihvaSkgaW5cbiAgICAgICAgYWRkX2F1eCBuZXd0IHNldHRlciBOb25lIGggKGdldF9pbmRleCBuZXd0IGgpO1xuICAgICAgaW5cbiAgICAgIGl0ZXJfd2VhayBhZGRfd2VhayB0O1xuICAgICAgdC50YWJsZSA8LSBuZXd0LnRhYmxlO1xuICAgICAgdC5oYXNoZXMgPC0gbmV3dC5oYXNoZXM7XG4gICAgICB0LmxpbWl0IDwtIG5ld3QubGltaXQ7XG4gICAgICB0Lm92ZXJzaXplIDwtIG5ld3Qub3ZlcnNpemU7XG4gICAgICB0LnJvdmVyIDwtIHQucm92ZXIgbW9kIEFycmF5Lmxlbmd0aCBuZXd0LnRhYmxlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICB0LmxpbWl0IDwtIG1heF9pbnQ7ICAgICAgICAgICAgICgqIG1heGltdW0gc2l6ZSBhbHJlYWR5IHJlYWNoZWQgKilcbiAgICAgIHQub3ZlcnNpemUgPC0gMDtcbiAgICBlbmRcblxuICBhbmQgYWRkX2F1eCB0IHNldHRlciBkIGggaW5kZXggPVxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IG5ld3N6ID1cbiAgICAgICAgICBJbnQubWluICgzICogc3ogLyAyICsgMykgKFN5cy5tYXhfYXJyYXlfbGVuZ3RoIC0gYWRkaXRpb25hbF92YWx1ZXMpXG4gICAgICAgIGluXG4gICAgICAgIGlmIG5ld3N6IDw9IHN6IHRoZW4gZmFpbHdpdGggXCJXZWFrLk1ha2U6IGhhc2ggYnVja2V0IGNhbm5vdCBncm93IG1vcmVcIjtcbiAgICAgICAgbGV0IG5ld2J1Y2tldCA9IHdlYWtfY3JlYXRlIG5ld3N6IGluXG4gICAgICAgIGxldCBuZXdoYXNoZXMgPSBBcnJheS5tYWtlIG5ld3N6IDAgaW5cbiAgICAgICAgYmxpdCBidWNrZXQgMCBuZXdidWNrZXQgMCBzejtcbiAgICAgICAgQXJyYXkuYmxpdCBoYXNoZXMgMCBuZXdoYXNoZXMgMCBzejtcbiAgICAgICAgc2V0dGVyIG5ld2J1Y2tldCBzeiBkO1xuICAgICAgICBuZXdoYXNoZXMuKHN6KSA8LSBoO1xuICAgICAgICB0LnRhYmxlLihpbmRleCkgPC0gbmV3YnVja2V0O1xuICAgICAgICB0Lmhhc2hlcy4oaW5kZXgpIDwtIG5ld2hhc2hlcztcbiAgICAgICAgaWYgc3ogPD0gdC5saW1pdCAmJiBuZXdzeiA+IHQubGltaXQgdGhlbiBiZWdpblxuICAgICAgICAgIHQub3ZlcnNpemUgPC0gdC5vdmVyc2l6ZSArIDE7XG4gICAgICAgICAgZm9yIF9pID0gMCB0byBvdmVyX2xpbWl0IGRvIHRlc3Rfc2hyaW5rX2J1Y2tldCB0IGRvbmU7XG4gICAgICAgIGVuZDtcbiAgICAgICAgaWYgdC5vdmVyc2l6ZSA+IEFycmF5Lmxlbmd0aCB0LnRhYmxlIC8gb3Zlcl9saW1pdCB0aGVuIHJlc2l6ZSB0O1xuICAgICAgZW5kIGVsc2UgaWYgY2hlY2sgYnVja2V0IGkgdGhlbiBiZWdpblxuICAgICAgICBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldHRlciBidWNrZXQgaSBkO1xuICAgICAgICBoYXNoZXMuKGkpIDwtIGg7XG4gICAgICBlbmQ7XG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBhZGQgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgYWRkX2F1eCB0IHNldCAoU29tZSBkKSBoIChnZXRfaW5kZXggdCBoKVxuXG5cbiAgbGV0IGZpbmRfb3IgdCBkIGlmbm90Zm91bmQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBpZm5vdGZvdW5kIGggaW5kZXhcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gdlxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IG1lcmdlIHQgZCA9XG4gICAgZmluZF9vciB0IGQgKGZ1biBoIGluZGV4IC0+IGFkZF9hdXggdCBzZXQgKFNvbWUgZCkgaCBpbmRleDsgZClcblxuXG4gIGxldCBmaW5kIHQgZCA9IGZpbmRfb3IgdCBkIChmdW4gX2ggX2luZGV4IC0+IHJhaXNlIE5vdF9mb3VuZClcblxuICBsZXQgZmluZF9vcHQgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gTm9uZVxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgXyBhcyB2IC0+IHZcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBmaW5kX3NoYWRvdyB0IGQgaWZmb3VuZCBpZm5vdGZvdW5kID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gaWZub3Rmb3VuZFxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZCAtPiBpZmZvdW5kIGJ1Y2tldCBpXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgcmVtb3ZlIHQgZCA9IGZpbmRfc2hhZG93IHQgZCAoZnVuIHcgaSAtPiBzZXQgdyBpIE5vbmUpICgpXG5cblxuICBsZXQgbWVtIHQgZCA9IGZpbmRfc2hhZG93IHQgZCAoZnVuIF93IF9pIC0+IHRydWUpIGZhbHNlXG5cblxuICBsZXQgZmluZF9hbGwgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSBhY2N1ID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBhY2N1XG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSB2IC0+IGxvb3AgKGkgKyAxKSAodiA6OiBhY2N1KVxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpIGFjY3VcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSkgYWNjdVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpIGFjY3VcbiAgICBpblxuICAgIGxvb3AgMCBbXVxuXG5cbiAgbGV0IHN0YXRzIHQgPVxuICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBsZW5zID0gQXJyYXkubWFwIGxlbmd0aCB0LnRhYmxlIGluXG4gICAgQXJyYXkuc29ydCBjb21wYXJlIGxlbnM7XG4gICAgbGV0IHRvdGxlbiA9IEFycmF5LmZvbGRfbGVmdCAoICsgKSAwIGxlbnMgaW5cbiAgICAobGVuLCBjb3VudCB0LCB0b3RsZW4sIGxlbnMuKDApLCBsZW5zLihsZW4vMiksIGxlbnMuKGxlbi0xKSlcblxuXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQSBwcmV0dHktcHJpbnRpbmcgZmFjaWxpdHkgYW5kIGRlZmluaXRpb24gb2YgZm9ybWF0dGVycyBmb3IgJ3BhcmFsbGVsJ1xuICAgKGkuZS4gdW5yZWxhdGVkIG9yIGluZGVwZW5kZW50KSBwcmV0dHktcHJpbnRpbmcgb24gbXVsdGlwbGUgb3V0IGNoYW5uZWxzLiAqKVxuXG4oKlxuICAgVGhlIHByZXR0eS1wcmludGluZyBlbmdpbmUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuKilcblxubGV0IGlkIHggPSB4XG5cbigqIEEgZGV2b3RlZCB0eXBlIGZvciBzaXplcyB0byBhdm9pZCBjb25mdXNpb25cbiAgIGJldHdlZW4gc2l6ZXMgYW5kIG1lcmUgaW50ZWdlcnMuICopXG5tb2R1bGUgU2l6ZSA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgdG9faW50IDogdCAtPiBpbnRcbiAgdmFsIG9mX2ludCA6IGludCAtPiB0XG4gIHZhbCB6ZXJvIDogdFxuICB2YWwgdW5rbm93biA6IHRcbiAgdmFsIGlzX2tub3duIDogdCAtPiBib29sXG5lbmQgID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCB0b19pbnQgPSBpZFxuICBsZXQgb2ZfaW50ID0gaWRcbiAgbGV0IHplcm8gPSAwXG4gIGxldCB1bmtub3duID0gLTFcbiAgbGV0IGlzX2tub3duIG4gPSBuID49IDBcbmVuZFxuXG5cblxuKCogVGhlIHByZXR0eS1wcmludGluZyBib3hlcyBkZWZpbml0aW9uOlxuICAgYSBwcmV0dHktcHJpbnRpbmcgYm94IGlzIGVpdGhlclxuICAgLSBoYm94OiBob3Jpem9udGFsIGJveCAobm8gbGluZSBzcGxpdHRpbmcpXG4gICAtIHZib3g6IHZlcnRpY2FsIGJveCAoZXZlcnkgYnJlYWsgaGludCBzcGxpdHMgdGhlIGxpbmUpXG4gICAtIGh2Ym94OiBob3Jpem9udGFsL3ZlcnRpY2FsIGJveFxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgYm94IGlmIGl0IGZpdHMgb25cbiAgICAgIHRoZSBjdXJyZW50IGxpbmUsIG90aGVyd2lzZSB0aGUgYm94IGJlaGF2ZXMgYXMgYSB2ZXJ0aWNhbCBib3gpXG4gICAtIGhvdmJveDogaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjb21wYWN0aW5nIGJveFxuICAgICAodGhlIGJveCBpcyBjb21wYWN0aW5nIG1hdGVyaWFsLCBwcmludGluZyBhcyBtdWNoIG1hdGVyaWFsIGFzIHBvc3NpYmxlXG4gICAgICBvbiBldmVyeSBsaW5lcylcbiAgIC0gYm94OiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGNvbXBhY3RpbmcgYm94IHdpdGggZW5oYW5jZWQgYm94IHN0cnVjdHVyZVxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgb3IgdmVydGljYWwgYm94IGJ1dCBicmVhayBoaW50cyBzcGxpdFxuICAgICAgdGhlIGxpbmUgaWYgc3BsaXR0aW5nIHdvdWxkIG1vdmUgdG8gdGhlIGxlZnQpXG4qKVxudHlwZSBib3hfdHlwZSA9IENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5ibG9ja190eXBlID1cbiAgfCBQcF9oYm94IHwgUHBfdmJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IHwgUHBfZml0c1xuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRpbmcgdG9rZW5zIGRlZmluaXRpb246XG4gICBhcmUgZWl0aGVyIHRleHQgdG8gcHJpbnQgb3IgcHJldHR5IHByaW50aW5nXG4gICBlbGVtZW50cyB0aGF0IGRyaXZlIGluZGVudGF0aW9uIGFuZCBsaW5lIHNwbGl0dGluZy4gKilcbnR5cGUgcHBfdG9rZW4gPVxuICB8IFBwX3RleHQgb2Ygc3RyaW5nICAgICAgICAgICgqIG5vcm1hbCB0ZXh0ICopXG4gIHwgUHBfYnJlYWsgb2YgeyAgICAgICAgICAgICAgKCogY29tcGxldGUgYnJlYWsgKilcbiAgICAgIGZpdHM6IHN0cmluZyAqIGludCAqIHN0cmluZzsgICAoKiBsaW5lIGlzIG5vdCBzcGxpdCAqKVxuICAgICAgYnJlYWtzOiBzdHJpbmcgKiBpbnQgKiBzdHJpbmc7ICgqIGxpbmUgaXMgc3BsaXQgKilcbiAgICB9XG4gIHwgUHBfdGJyZWFrIG9mIGludCAqIGludCAgICAgKCogZ28gdG8gbmV4dCB0YWJ1bGF0aW9uICopXG4gIHwgUHBfc3RhYiAgICAgICAgICAgICAgICAgICAgKCogc2V0IGEgdGFidWxhdGlvbiAqKVxuICB8IFBwX2JlZ2luIG9mIGludCAqIGJveF90eXBlICgqIGJlZ2lubmluZyBvZiBhIGJveCAqKVxuICB8IFBwX2VuZCAgICAgICAgICAgICAgICAgICAgICgqIGVuZCBvZiBhIGJveCAqKVxuICB8IFBwX3RiZWdpbiBvZiB0Ym94ICAgICAgICAgICgqIGJlZ2lubmluZyBvZiBhIHRhYnVsYXRpb24gYm94ICopXG4gIHwgUHBfdGVuZCAgICAgICAgICAgICAgICAgICAgKCogZW5kIG9mIGEgdGFidWxhdGlvbiBib3ggKilcbiAgfCBQcF9uZXdsaW5lICAgICAgICAgICAgICAgICAoKiB0byBmb3JjZSBhIG5ld2xpbmUgaW5zaWRlIGEgYm94ICopXG4gIHwgUHBfaWZfbmV3bGluZSAgICAgICAgICAgICAgKCogdG8gZG8gc29tZXRoaW5nIG9ubHkgaWYgdGhpcyB2ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSBoYXMgYmVlbiBicm9rZW4gKilcbiAgfCBQcF9vcGVuX3RhZyBvZiBzdGFnICAgICAgICAgKCogb3BlbmluZyBhIHRhZyBuYW1lICopXG4gIHwgUHBfY2xvc2VfdGFnICAgICAgICAgICAgICAgKCogY2xvc2luZyB0aGUgbW9zdCByZWNlbnRseSBvcGVuIHRhZyAqKVxuXG5hbmQgc3RhZyA9IC4uXG5cbmFuZCB0Ym94ID0gUHBfdGJveCBvZiBpbnQgbGlzdCByZWYgICgqIFRhYnVsYXRpb24gYm94ICopXG5cbnR5cGUgdGFnID0gc3RyaW5nXG50eXBlIHN0YWcgKz0gU3RyaW5nX3RhZyBvZiB0YWdcblxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWU6XG4gICBwcmV0dHktcHJpbnRpbmcgbWF0ZXJpYWwgaXMgbm90IHdyaXR0ZW4gaW4gdGhlIG91dHB1dCBhcyBzb29uIGFzIGVtaXR0ZWQ7XG4gICBpbnN0ZWFkLCB0aGUgbWF0ZXJpYWwgaXMgc2ltcGx5IHJlY29yZGVkIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSxcbiAgIHVudGlsIHRoZSBlbmNsb3NpbmcgYm94IGhhcyBhIGtub3duIGNvbXB1dGVkIHNpemUgYW5kIHByb3BlciBzcGxpdHRpbmdcbiAgIGRlY2lzaW9ucyBjYW4gYmUgbWFkZS5cblxuICAgVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGNvbnRhaW5zIGZvcm1hdHRpbmcgZWxlbWVudHMgdG8gYmUgcHJpbnRlZC5cbiAgIEVhY2ggZm9ybWF0dGluZyBlbGVtZW50IGlzIGEgdHVwbGUgKHNpemUsIHRva2VuLCBsZW5ndGgpLCB3aGVyZVxuICAgLSBsZW5ndGggaXMgdGhlIGRlY2xhcmVkIGxlbmd0aCBvZiB0aGUgdG9rZW4sXG4gICAtIHNpemUgaXMgZWZmZWN0aXZlIHNpemUgb2YgdGhlIHRva2VuIHdoZW4gaXQgaXMgcHJpbnRlZFxuICAgICAoc2l6ZSBpcyBzZXQgd2hlbiB0aGUgc2l6ZSBvZiB0aGUgYm94IGlzIGtub3duLCBzbyB0aGF0IHNpemUgb2YgYnJlYWtcbiAgICAgIGhpbnRzIGFyZSBkZWZpbml0aXZlKS4gKilcbnR5cGUgcHBfcXVldWVfZWxlbSA9IHtcbiAgbXV0YWJsZSBzaXplIDogU2l6ZS50O1xuICB0b2tlbiA6IHBwX3Rva2VuO1xuICBsZW5ndGggOiBpbnQ7XG59XG5cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGRlZmluaXRpb24uICopXG50eXBlIHBwX3F1ZXVlID0gcHBfcXVldWVfZWxlbSBRdWV1ZS50XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay4gKilcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrOiBzY2FubmluZyBlbGVtZW50IGRlZmluaXRpb24uICopXG50eXBlIHBwX3NjYW5fZWxlbSA9IHtcbiAgbGVmdF90b3RhbCA6IGludDsgKCogVmFsdWUgb2YgcHBfbGVmdF90b3RhbCB3aGVuIHRoZSBlbGVtZW50IHdhcyBlbnF1ZXVlZC4gKilcbiAgcXVldWVfZWxlbSA6IHBwX3F1ZXVlX2VsZW1cbn1cblxuKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2s6XG4gICB0aGUgZm9ybWF0dGluZyBzdGFjayBjb250YWlucyB0aGUgZGVzY3JpcHRpb24gb2YgYWxsIHRoZSBjdXJyZW50bHkgYWN0aXZlXG4gICBib3hlczsgdGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2sgaXMgdXNlZCB0byBzcGxpdCB0aGUgbGluZXNcbiAgIHdoaWxlIHByaW50aW5nIHRva2Vucy4gKilcblxuKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2s6IGZvcm1hdHRpbmcgc3RhY2sgZWxlbWVudCBkZWZpbml0aW9uLlxuICAgRWFjaCBzdGFjayBlbGVtZW50IGRlc2NyaWJlcyBhIHByZXR0eS1wcmludGluZyBib3guICopXG50eXBlIHBwX2Zvcm1hdF9lbGVtID0geyBib3hfdHlwZSA6IGJveF90eXBlOyB3aWR0aCA6IGludCB9XG5cbigqIFRoZSBmb3JtYXR0ZXIgZGVmaW5pdGlvbi5cbiAgIEVhY2ggZm9ybWF0dGVyIHZhbHVlIGlzIGEgcHJldHR5LXByaW50ZXIgaW5zdGFuY2Ugd2l0aCBhbGwgaXRzXG4gICBtYWNoaW5lcnkuICopXG50eXBlIGZvcm1hdHRlciA9IHtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLiAqKVxuICBwcF9zY2FuX3N0YWNrIDogcHBfc2Nhbl9lbGVtIFN0YWNrLnQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrLiAqKVxuICBwcF9mb3JtYXRfc3RhY2sgOiBwcF9mb3JtYXRfZWxlbSBTdGFjay50O1xuICBwcF90Ym94X3N0YWNrIDogdGJveCBTdGFjay50O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgc2VtYW50aWNzIHRhZyBzdGFjay4gKilcbiAgcHBfdGFnX3N0YWNrIDogc3RhZyBTdGFjay50O1xuICBwcF9tYXJrX3N0YWNrIDogc3RhZyBTdGFjay50O1xuICAoKiBWYWx1ZSBvZiByaWdodCBtYXJnaW4uICopXG4gIG11dGFibGUgcHBfbWFyZ2luIDogaW50O1xuICAoKiBNaW5pbWFsIHNwYWNlIGxlZnQgYmVmb3JlIG1hcmdpbiwgd2hlbiBvcGVuaW5nIGEgYm94LiAqKVxuICBtdXRhYmxlIHBwX21pbl9zcGFjZV9sZWZ0IDogaW50O1xuICAoKiBNYXhpbXVtIHZhbHVlIG9mIGluZGVudGF0aW9uOlxuICAgICBubyBib3ggY2FuIGJlIG9wZW5lZCBmdXJ0aGVyLiAqKVxuICBtdXRhYmxlIHBwX21heF9pbmRlbnQgOiBpbnQ7XG4gICgqIFNwYWNlIHJlbWFpbmluZyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxuICBtdXRhYmxlIHBwX3NwYWNlX2xlZnQgOiBpbnQ7XG4gICgqIEN1cnJlbnQgdmFsdWUgb2YgaW5kZW50YXRpb24uICopXG4gIG11dGFibGUgcHBfY3VycmVudF9pbmRlbnQgOiBpbnQ7XG4gICgqIFRydWUgd2hlbiB0aGUgbGluZSBoYXMgYmVlbiBicm9rZW4gYnkgdGhlIHByZXR0eS1wcmludGVyLiAqKVxuICBtdXRhYmxlIHBwX2lzX25ld19saW5lIDogYm9vbDtcbiAgKCogVG90YWwgd2lkdGggb2YgdG9rZW5zIGFscmVhZHkgcHJpbnRlZC4gKilcbiAgbXV0YWJsZSBwcF9sZWZ0X3RvdGFsIDogaW50O1xuICAoKiBUb3RhbCB3aWR0aCBvZiB0b2tlbnMgZXZlciBwdXQgaW4gcXVldWUuICopXG4gIG11dGFibGUgcHBfcmlnaHRfdG90YWwgOiBpbnQ7XG4gICgqIEN1cnJlbnQgbnVtYmVyIG9mIG9wZW4gYm94ZXMuICopXG4gIG11dGFibGUgcHBfY3Vycl9kZXB0aCA6IGludDtcbiAgKCogTWF4aW11bSBudW1iZXIgb2YgYm94ZXMgd2hpY2ggY2FuIGJlIHNpbXVsdGFuZW91c2x5IG9wZW4uICopXG4gIG11dGFibGUgcHBfbWF4X2JveGVzIDogaW50O1xuICAoKiBFbGxpcHNpcyBzdHJpbmcuICopXG4gIG11dGFibGUgcHBfZWxsaXBzaXMgOiBzdHJpbmc7XG4gICgqIE91dHB1dCBmdW5jdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9vdXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdDtcbiAgKCogRmx1c2hpbmcgZnVuY3Rpb24uICopXG4gIG11dGFibGUgcHBfb3V0X2ZsdXNoIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgbmV3IGxpbmVzLiAqKVxuICBtdXRhYmxlIHBwX291dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgYnJlYWsgaGludHMgc3BhY2VzLiAqKVxuICBtdXRhYmxlIHBwX291dF9zcGFjZXMgOiBpbnQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfaW5kZW50IDogaW50IC0+IHVuaXQ7XG4gICgqIEFyZSB0YWdzIHByaW50ZWQgPyAqKVxuICBtdXRhYmxlIHBwX3ByaW50X3RhZ3MgOiBib29sO1xuICAoKiBBcmUgdGFncyBtYXJrZWQgPyAqKVxuICBtdXRhYmxlIHBwX21hcmtfdGFncyA6IGJvb2w7XG4gICgqIEZpbmQgb3BlbmluZyBhbmQgY2xvc2luZyBtYXJrZXJzIG9mIHRhZ3MuICopXG4gIG11dGFibGUgcHBfbWFya19vcGVuX3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtdXRhYmxlIHBwX21hcmtfY2xvc2VfdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIG11dGFibGUgcHBfcHJpbnRfb3Blbl90YWcgOiBzdGFnIC0+IHVuaXQ7XG4gIG11dGFibGUgcHBfcHJpbnRfY2xvc2VfdGFnIDogc3RhZyAtPiB1bml0O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG4gIHBwX3F1ZXVlIDogcHBfcXVldWU7XG59XG5cblxuKCogVGhlIGZvcm1hdHRlciBzcGVjaWZpYyB0YWcgaGFuZGxpbmcgZnVuY3Rpb25zLiAqKVxudHlwZSBmb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgPSB7XG4gIG1hcmtfb3Blbl9zdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIG1hcmtfY2xvc2Vfc3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBwcmludF9vcGVuX3N0YWcgOiBzdGFnIC0+IHVuaXQ7XG4gIHByaW50X2Nsb3NlX3N0YWcgOiBzdGFnIC0+IHVuaXQ7XG59XG5cblxuKCogVGhlIGZvcm1hdHRlciBmdW5jdGlvbnMgdG8gb3V0cHV0IG1hdGVyaWFsLiAqKVxudHlwZSBmb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9IHtcbiAgb3V0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXQ7XG4gIG91dF9mbHVzaCA6IHVuaXQgLT4gdW5pdDtcbiAgb3V0X25ld2xpbmUgOiB1bml0IC0+IHVuaXQ7XG4gIG91dF9zcGFjZXMgOiBpbnQgLT4gdW5pdDtcbiAgb3V0X2luZGVudCA6IGludCAtPiB1bml0O1xufVxuXG5cbigqXG5cbiAgQXV4aWxpYXJpZXMgYW5kIGJhc2ljIGZ1bmN0aW9ucy5cblxuKilcblxuKCogRW50ZXIgYSB0b2tlbiBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG5sZXQgcHBfZW5xdWV1ZSBzdGF0ZSB0b2tlbiA9XG4gIHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgdG9rZW4ubGVuZ3RoO1xuICBRdWV1ZS5hZGQgdG9rZW4gc3RhdGUucHBfcXVldWVcblxuXG5sZXQgcHBfY2xlYXJfcXVldWUgc3RhdGUgPVxuICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIDE7IHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIDE7XG4gIFF1ZXVlLmNsZWFyIHN0YXRlLnBwX3F1ZXVlXG5cblxuKCogUHBfaW5maW5pdHk6IGxhcmdlIHZhbHVlIGZvciBkZWZhdWx0IHRva2VucyBzaXplLlxuXG4gICBQcF9pbmZpbml0eSBpcyBkb2N1bWVudGVkIGFzIGJlaW5nIGdyZWF0ZXIgdGhhbiAxZTEwOyB0byBhdm9pZFxuICAgY29uZnVzaW9uIGFib3V0IHRoZSB3b3JkICdncmVhdGVyJywgd2UgY2hvb3NlIHBwX2luZmluaXR5IGdyZWF0ZXJcbiAgIHRoYW4gMWUxMCArIDE7IGZvciBjb3JyZWN0IGhhbmRsaW5nIG9mIHRlc3RzIGluIHRoZSBhbGdvcml0aG0sXG4gICBwcF9pbmZpbml0eSBtdXN0IGJlIGV2ZW4gb25lIG1vcmUgdGhhbiAxZTEwICsgMTsgbGV0J3Mgc3RhbmQgb24gdGhlXG4gICBzYWZlIHNpZGUgYnkgY2hvb3NpbmcgMS5lMTArMTAuXG5cbiAgIFBwX2luZmluaXR5IGNvdWxkIHByb2JhYmx5IGJlIDEwNzM3NDE4MjMgdGhhdCBpcyAyXjMwIC0gMSwgdGhhdCBpc1xuICAgdGhlIG1pbmltYWwgdXBwZXIgYm91bmQgZm9yIGludGVnZXJzOyBub3cgdGhhdCBtYXhfaW50IGlzIGRlZmluZWQsXG4gICB0aGlzIGxpbWl0IGNvdWxkIGFsc28gYmUgZGVmaW5lZCBhcyBtYXhfaW50IC0gMS5cblxuICAgSG93ZXZlciwgYmVmb3JlIHNldHRpbmcgcHBfaW5maW5pdHkgdG8gc29tZXRoaW5nIGFyb3VuZCBtYXhfaW50LCB3ZVxuICAgbXVzdCBjYXJlZnVsbHkgZG91YmxlLWNoZWNrIGFsbCB0aGUgaW50ZWdlciBhcml0aG1ldGljIG9wZXJhdGlvbnNcbiAgIHRoYXQgaW52b2x2ZSBwcF9pbmZpbml0eSwgc2luY2UgYW55IG92ZXJmbG93IHdvdWxkIHdyZWNrIGhhdm9jIHRoZVxuICAgcHJldHR5LXByaW50aW5nIGFsZ29yaXRobSdzIGludmFyaWFudHMuIEdpdmVuIHRoYXQgdGhpcyBhcml0aG1ldGljXG4gICBjb3JyZWN0bmVzcyBjaGVjayBpcyBkaWZmaWN1bHQgYW5kIGVycm9yIHByb25lIGFuZCBnaXZlbiB0aGF0IDFlMTBcbiAgICsgMSBpcyBpbiBwcmFjdGljZSBsYXJnZSBlbm91Z2gsIHRoZXJlIGlzIG5vIG5lZWQgdG8gYXR0ZW1wdCB0byBzZXRcbiAgIHBwX2luZmluaXR5IHRvIHRoZSB0aGVvcmV0aWNhbGx5IG1heGltdW0gbGltaXQuIEl0IGlzIG5vdCB3b3J0aCB0aGVcbiAgIGJ1cmRlbiAhICopXG5sZXQgcHBfaW5maW5pdHkgPSAxMDAwMDAwMDEwXG5cbigqIE91dHB1dCBmdW5jdGlvbnMgZm9yIHRoZSBmb3JtYXR0ZXIuICopXG5sZXQgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBzID0gc3RhdGUucHBfb3V0X3N0cmluZyBzIDAgKFN0cmluZy5sZW5ndGggcylcbmFuZCBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZSA9IHN0YXRlLnBwX291dF9uZXdsaW5lICgpXG5hbmQgcHBfb3V0cHV0X3NwYWNlcyBzdGF0ZSBuID0gc3RhdGUucHBfb3V0X3NwYWNlcyBuXG5hbmQgcHBfb3V0cHV0X2luZGVudCBzdGF0ZSBuID0gc3RhdGUucHBfb3V0X2luZGVudCBuXG5cbigqIEZvcm1hdCBhIHRleHR1YWwgdG9rZW4gKilcbmxldCBmb3JtYXRfcHBfdGV4dCBzdGF0ZSBzaXplIHRleHQgPVxuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgLSBzaXplO1xuICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIHRleHQ7XG4gIHN0YXRlLnBwX2lzX25ld19saW5lIDwtIGZhbHNlXG5cbigqIEZvcm1hdCBhIHN0cmluZyBieSBpdHMgbGVuZ3RoLCBpZiBub3QgZW1wdHkgKilcbmxldCBmb3JtYXRfc3RyaW5nIHN0YXRlIHMgPVxuICBpZiBzIDw+IFwiXCIgdGhlbiBmb3JtYXRfcHBfdGV4dCBzdGF0ZSAoU3RyaW5nLmxlbmd0aCBzKSBzXG5cbigqIFRvIGZvcm1hdCBhIGJyZWFrLCBpbmRlbnRpbmcgYSBuZXcgbGluZS4gKilcbmxldCBicmVha19uZXdfbGluZSBzdGF0ZSAoYmVmb3JlLCBvZmZzZXQsIGFmdGVyKSB3aWR0aCA9XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYmVmb3JlO1xuICBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZTtcbiAgc3RhdGUucHBfaXNfbmV3X2xpbmUgPC0gdHJ1ZTtcbiAgbGV0IGluZGVudCA9IHN0YXRlLnBwX21hcmdpbiAtIHdpZHRoICsgb2Zmc2V0IGluXG4gICgqIERvbid0IGluZGVudCBtb3JlIHRoYW4gcHBfbWF4X2luZGVudC4gKilcbiAgbGV0IHJlYWxfaW5kZW50ID0gSW50Lm1pbiBzdGF0ZS5wcF9tYXhfaW5kZW50IGluZGVudCBpblxuICBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCA8LSByZWFsX2luZGVudDtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9jdXJyZW50X2luZGVudDtcbiAgcHBfb3V0cHV0X2luZGVudCBzdGF0ZSBzdGF0ZS5wcF9jdXJyZW50X2luZGVudDtcbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBhZnRlclxuXG5cbigqIFRvIGZvcmNlIGEgbGluZSBicmVhayBpbnNpZGUgYSBib3g6IG5vIG9mZnNldCBpcyBhZGRlZC4gKilcbmxldCBicmVha19saW5lIHN0YXRlIHdpZHRoID0gYnJlYWtfbmV3X2xpbmUgc3RhdGUgKFwiXCIsIDAsIFwiXCIpIHdpZHRoXG5cbigqIFRvIGZvcm1hdCBhIGJyZWFrIHRoYXQgZml0cyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxubGV0IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSAoYmVmb3JlLCB3aWR0aCwgYWZ0ZXIpID1cbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBiZWZvcmU7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIHdpZHRoO1xuICBwcF9vdXRwdXRfc3BhY2VzIHN0YXRlIHdpZHRoO1xuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGFmdGVyXG5cblxuKCogVG8gaW5kZW50IG5vIG1vcmUgdGhhbiBwcF9tYXhfaW5kZW50LCBpZiBvbmUgdHJpZXMgdG8gb3BlbiBhIGJveFxuICAgYmV5b25kIHBwX21heF9pbmRlbnQsIHRoZW4gdGhlIGJveCBpcyByZWplY3RlZCBvbiB0aGUgbGVmdFxuICAgYnkgc2ltdWxhdGluZyBhIGJyZWFrLiAqKVxubGV0IHBwX2ZvcmNlX2JyZWFrX2xpbmUgc3RhdGUgPVxuICBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gIHwgTm9uZSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZVxuICB8IFNvbWUgeyBib3hfdHlwZTsgd2lkdGggfSAtPlxuICAgIGlmIHdpZHRoID4gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuXG4gICAgICBtYXRjaCBib3hfdHlwZSB3aXRoXG4gICAgICB8IFBwX2ZpdHMgfCBQcF9oYm94IC0+ICgpXG4gICAgICB8IFBwX3Zib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCAtPiBicmVha19saW5lIHN0YXRlIHdpZHRoXG5cblxuKCogVG8gc2tpcCBhIHRva2VuLCBpZiB0aGUgcHJldmlvdXMgbGluZSBoYXMgYmVlbiBicm9rZW4uICopXG5sZXQgcHBfc2tpcF90b2tlbiBzdGF0ZSA9XG4gIG1hdGNoIFF1ZXVlLnRha2Vfb3B0IHN0YXRlLnBwX3F1ZXVlIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIHByaW50X2lmX25ld2xpbmUgbXVzdCBoYXZlIGJlZW4gdGhlIGxhc3QgcHJpbnRpbmcgY29tbWFuZCAqKVxuICB8IFNvbWUgeyBzaXplOyBsZW5ndGg7IF8gfSAtPlxuICAgIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gc3RhdGUucHBfbGVmdF90b3RhbCAtIGxlbmd0aDtcbiAgICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgKyBTaXplLnRvX2ludCBzaXplXG5cblxuKCpcblxuICBUaGUgbWFpbiBwcmV0dHkgcHJpbnRpbmcgZnVuY3Rpb25zLlxuXG4qKVxuXG4oKiBGb3JtYXR0aW5nIGEgdG9rZW4gd2l0aCBhIGdpdmVuIHNpemUuICopXG5sZXQgZm9ybWF0X3BwX3Rva2VuIHN0YXRlIHNpemUgPSBmdW5jdGlvblxuXG4gIHwgUHBfdGV4dCBzIC0+XG4gICAgZm9ybWF0X3BwX3RleHQgc3RhdGUgc2l6ZSBzXG5cbiAgfCBQcF9iZWdpbiAob2ZmLCB0eSkgLT5cbiAgICBsZXQgaW5zZXJ0aW9uX3BvaW50ID0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCBpblxuICAgIGlmIGluc2VydGlvbl9wb2ludCA+IHN0YXRlLnBwX21heF9pbmRlbnQgdGhlblxuICAgICAgKCogY2FuIG5vdCBvcGVuIGEgYm94IHJpZ2h0IHRoZXJlLiAqKVxuICAgICAgYmVnaW4gcHBfZm9yY2VfYnJlYWtfbGluZSBzdGF0ZSBlbmQ7XG4gICAgbGV0IHdpZHRoID0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIG9mZiBpblxuICAgIGxldCBib3hfdHlwZSA9XG4gICAgICBtYXRjaCB0eSB3aXRoXG4gICAgICB8IFBwX3Zib3ggLT4gUHBfdmJveFxuICAgICAgfCBQcF9oYm94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggfCBQcF9maXRzIC0+XG4gICAgICAgIGlmIHNpemUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW4gdHkgZWxzZSBQcF9maXRzIGluXG4gICAgU3RhY2sucHVzaCB7IGJveF90eXBlOyB3aWR0aCB9IHN0YXRlLnBwX2Zvcm1hdF9zdGFja1xuXG4gIHwgUHBfZW5kIC0+XG4gICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgfD4gaWdub3JlXG5cbiAgfCBQcF90YmVnaW4gKFBwX3Rib3ggXyBhcyB0Ym94KSAtPlxuICAgIFN0YWNrLnB1c2ggdGJveCBzdGF0ZS5wcF90Ym94X3N0YWNrXG5cbiAgfCBQcF90ZW5kIC0+XG4gICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHw+IGlnbm9yZVxuXG4gIHwgUHBfc3RhYiAtPlxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gdGFidWxhdGlvbiBib3guICopXG4gICAgfCBTb21lIChQcF90Ym94IHRhYnMpIC0+XG4gICAgICBsZXQgcmVjIGFkZF90YWIgbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgW10gLT4gW25dXG4gICAgICAgIHwgeCA6OiBsIGFzIGxzIC0+IGlmIG4gPCB4IHRoZW4gbiA6OiBscyBlbHNlIHggOjogYWRkX3RhYiBuIGwgaW5cbiAgICAgIHRhYnMgOj0gYWRkX3RhYiAoc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCkgIXRhYnNcbiAgICBlbmRcblxuICB8IFBwX3RicmVhayAobiwgb2ZmKSAtPlxuICAgIGxldCBpbnNlcnRpb25fcG9pbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IGluXG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiB0YWJ1bGF0aW9uIGJveC4gKilcbiAgICB8IFNvbWUgKFBwX3Rib3ggdGFicykgLT5cbiAgICAgIGxldCB0YWIgPVxuICAgICAgICBtYXRjaCAhdGFicyB3aXRoXG4gICAgICAgIHwgW10gLT4gaW5zZXJ0aW9uX3BvaW50XG4gICAgICAgIHwgZmlyc3QgOjogXyAtPlxuICAgICAgICAgIGxldCByZWMgZmluZCA9IGZ1bmN0aW9uXG4gICAgICAgICAgICB8IGhlYWQgOjogdGFpbCAtPlxuICAgICAgICAgICAgICBpZiBoZWFkID49IGluc2VydGlvbl9wb2ludCB0aGVuIGhlYWQgZWxzZSBmaW5kIHRhaWxcbiAgICAgICAgICAgIHwgW10gLT4gZmlyc3QgaW5cbiAgICAgICAgICBmaW5kICF0YWJzIGluXG4gICAgICBsZXQgb2Zmc2V0ID0gdGFiIC0gaW5zZXJ0aW9uX3BvaW50IGluXG4gICAgICBpZiBvZmZzZXQgPj0gMFxuICAgICAgdGhlbiBicmVha19zYW1lX2xpbmUgc3RhdGUgKFwiXCIsIG9mZnNldCArIG4sIFwiXCIpXG4gICAgICBlbHNlIGJyZWFrX25ld19saW5lIHN0YXRlIChcIlwiLCB0YWIgKyBvZmYsIFwiXCIpIHN0YXRlLnBwX21hcmdpblxuICAgIGVuZFxuXG4gIHwgUHBfbmV3bGluZSAtPlxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGUgKCogTm8gb3BlbiBib3guICopXG4gICAgfCBTb21lIHsgd2lkdGg7IF99IC0+IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGhcbiAgICBlbmRcblxuICB8IFBwX2lmX25ld2xpbmUgLT5cbiAgICBpZiBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCAhPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgdGhlbiBwcF9za2lwX3Rva2VuIHN0YXRlXG5cbiAgfCBQcF9icmVhayB7IGZpdHM7IGJyZWFrcyB9IC0+XG4gICAgbGV0IGJlZm9yZSwgb2ZmLCBfID0gYnJlYWtzIGluXG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIGJveC4gKilcbiAgICB8IFNvbWUgeyBib3hfdHlwZTsgd2lkdGggfSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggYm94X3R5cGUgd2l0aFxuICAgICAgfCBQcF9ob3Zib3ggLT5cbiAgICAgICAgaWYgc2l6ZSArIFN0cmluZy5sZW5ndGggYmVmb3JlID4gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgICBlbHNlIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX2JveCAtPlxuICAgICAgICAoKiBIYXZlIHRoZSBsaW5lIGp1c3QgYmVlbiBicm9rZW4gaGVyZSA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2lzX25ld19saW5lIHRoZW4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHMgZWxzZVxuICAgICAgICBpZiBzaXplICsgU3RyaW5nLmxlbmd0aCBiZWZvcmUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGggZWxzZVxuICAgICAgICAoKiBicmVhayB0aGUgbGluZSBoZXJlIGxlYWRzIHRvIG5ldyBpbmRlbnRhdGlvbiA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50ID4gc3RhdGUucHBfbWFyZ2luIC0gd2lkdGggKyBvZmZcbiAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgICAgZWxzZSBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgfCBQcF9odmJveCAtPiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgIHwgUHBfZml0cyAtPiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgfCBQcF92Ym94IC0+IGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgfCBQcF9oYm94IC0+IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgfCBQcF9vcGVuX3RhZyB0YWdfbmFtZSAtPlxuICAgICBsZXQgbWFya2VyID0gc3RhdGUucHBfbWFya19vcGVuX3RhZyB0YWdfbmFtZSBpblxuICAgICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIG1hcmtlcjtcbiAgICAgU3RhY2sucHVzaCB0YWdfbmFtZSBzdGF0ZS5wcF9tYXJrX3N0YWNrXG5cbiAgIHwgUHBfY2xvc2VfdGFnIC0+XG4gICAgIGJlZ2luIG1hdGNoIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfbWFya19zdGFjayB3aXRoXG4gICAgIHwgTm9uZSAtPiAoKSAoKiBObyBtb3JlIHRhZyB0byBjbG9zZS4gKilcbiAgICAgfCBTb21lIHRhZ19uYW1lIC0+XG4gICAgICAgbGV0IG1hcmtlciA9IHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIHRhZ19uYW1lIGluXG4gICAgICAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBtYXJrZXJcbiAgICAgZW5kXG5cblxuKCogUHJpbnQgaWYgdG9rZW4gc2l6ZSBpcyBrbm93biBlbHNlIHByaW50aW5nIGlzIGRlbGF5ZWQuXG4gICBQcmludGluZyBpcyBkZWxheWVkIHdoZW4gdGhlIHRleHQgd2FpdGluZyBpbiB0aGUgcXVldWUgcmVxdWlyZXNcbiAgIG1vcmUgcm9vbSB0byBmb3JtYXQgdGhhbiBleGlzdHMgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbmxldCByZWMgYWR2YW5jZV9sZWZ0IHN0YXRlID1cbiAgbWF0Y2ggUXVldWUucGVla19vcHQgc3RhdGUucHBfcXVldWUgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogTm8gdG9rZW5zIHRvIHByaW50ICopXG4gIHwgU29tZSB7IHNpemU7IHRva2VuOyBsZW5ndGggfSAtPlxuICAgIGxldCBwZW5kaW5nX2NvdW50ID0gc3RhdGUucHBfcmlnaHRfdG90YWwgLSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIGluXG4gICAgaWYgU2l6ZS5pc19rbm93biBzaXplIHx8IHBlbmRpbmdfY291bnQgPj0gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuIGJlZ2luXG4gICAgICBRdWV1ZS50YWtlIHN0YXRlLnBwX3F1ZXVlIHw+IGlnbm9yZTsgKCogTm90IGVtcHR5OiB3ZSBwZWVrIGludG8gaXQgKilcbiAgICAgIGxldCBzaXplID0gaWYgU2l6ZS5pc19rbm93biBzaXplIHRoZW4gU2l6ZS50b19pbnQgc2l6ZSBlbHNlIHBwX2luZmluaXR5IGluXG4gICAgICBmb3JtYXRfcHBfdG9rZW4gc3RhdGUgc2l6ZSB0b2tlbjtcbiAgICAgIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gbGVuZ3RoICsgc3RhdGUucHBfbGVmdF90b3RhbDtcbiAgICAgIChhZHZhbmNlX2xlZnQgW0B0YWlsY2FsbF0pIHN0YXRlXG4gICAgZW5kXG5cblxuKCogVG8gZW5xdWV1ZSBhIHRva2VuIDogdHJ5IHRvIGFkdmFuY2UuICopXG5sZXQgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHRvayA9IHBwX2VucXVldWUgc3RhdGUgdG9rOyBhZHZhbmNlX2xlZnQgc3RhdGVcblxuXG4oKiBUbyBlbnF1ZXVlIHN0cmluZ3MuICopXG5sZXQgZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgc2l6ZSBzID1cbiAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHsgc2l6ZTsgdG9rZW4gPSBQcF90ZXh0IHM7IGxlbmd0aCA9IFNpemUudG9faW50IHNpemUgfVxuXG5cbmxldCBlbnF1ZXVlX3N0cmluZyBzdGF0ZSBzID1cbiAgZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgKFNpemUub2ZfaW50IChTdHJpbmcubGVuZ3RoIHMpKSBzXG5cblxuKCogUm91dGluZXMgZm9yIHNjYW4gc3RhY2tcbiAgIGRldGVybWluZSBzaXplIG9mIGJveGVzLiAqKVxuXG4oKiBUaGUgc2Nhbl9zdGFjayBpcyBuZXZlciBlbXB0eS4gKilcbmxldCBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhY2sgPVxuICBTdGFjay5jbGVhciBzdGFjaztcbiAgbGV0IHF1ZXVlX2VsZW0gPSB7IHNpemUgPSBTaXplLnVua25vd247IHRva2VuID0gUHBfdGV4dCBcIlwiOyBsZW5ndGggPSAwIH0gaW5cbiAgU3RhY2sucHVzaCB7IGxlZnRfdG90YWwgPSAtMTsgcXVldWVfZWxlbSB9IHN0YWNrXG5cbigqIFNldHRpbmcgdGhlIHNpemUgb2YgYm94ZXMgb24gc2NhbiBzdGFjazpcbiAgIGlmIHR5ID0gdHJ1ZSB0aGVuIHNpemUgb2YgYnJlYWsgaXMgc2V0IGVsc2Ugc2l6ZSBvZiBib3ggaXMgc2V0O1xuICAgaW4gZWFjaCBjYXNlIHBwX3NjYW5fc3RhY2sgaXMgcG9wcGVkLlxuXG4gICBOb3RlOlxuICAgUGF0dGVybiBtYXRjaGluZyBvbiBzY2FuIHN0YWNrIGlzIGV4aGF1c3RpdmUsIHNpbmNlIHNjYW5fc3RhY2sgaXMgbmV2ZXJcbiAgIGVtcHR5LlxuICAgUGF0dGVybiBtYXRjaGluZyBvbiB0b2tlbiBpbiBzY2FuIHN0YWNrIGlzIGFsc28gZXhoYXVzdGl2ZSxcbiAgIHNpbmNlIHNjYW5fcHVzaCBpcyB1c2VkIG9uIGJyZWFrcyBhbmQgb3BlbmluZyBvZiBib3hlcy4gKilcbmxldCBzZXRfc2l6ZSBzdGF0ZSB0eSA9XG4gIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxuICB8IFNvbWUgeyBsZWZ0X3RvdGFsOyBxdWV1ZV9lbGVtIH0gLT5cbiAgICBsZXQgc2l6ZSA9IFNpemUudG9faW50IHF1ZXVlX2VsZW0uc2l6ZSBpblxuICAgICgqIHRlc3QgaWYgc2NhbiBzdGFjayBjb250YWlucyBhbnkgZGF0YSB0aGF0IGlzIG5vdCBvYnNvbGV0ZS4gKilcbiAgICBpZiBsZWZ0X3RvdGFsIDwgc3RhdGUucHBfbGVmdF90b3RhbCB0aGVuXG4gICAgICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhdGUucHBfc2Nhbl9zdGFja1xuICAgIGVsc2VcbiAgICAgIG1hdGNoIHF1ZXVlX2VsZW0udG9rZW4gd2l0aFxuICAgICAgfCBQcF9icmVhayBfIHwgUHBfdGJyZWFrIChfLCBfKSAtPlxuICAgICAgICBpZiB0eSB0aGVuIGJlZ2luXG4gICAgICAgICAgcXVldWVfZWxlbS5zaXplIDwtIFNpemUub2ZfaW50IChzdGF0ZS5wcF9yaWdodF90b3RhbCArIHNpemUpO1xuICAgICAgICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB8PiBpZ25vcmVcbiAgICAgICAgZW5kXG4gICAgICB8IFBwX2JlZ2luIChfLCBfKSAtPlxuICAgICAgICBpZiBub3QgdHkgdGhlbiBiZWdpblxuICAgICAgICAgIHF1ZXVlX2VsZW0uc2l6ZSA8LSBTaXplLm9mX2ludCAoc3RhdGUucHBfcmlnaHRfdG90YWwgKyBzaXplKTtcbiAgICAgICAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3NjYW5fc3RhY2sgfD4gaWdub3JlXG4gICAgICAgIGVuZFxuICAgICAgfCBQcF90ZXh0IF8gfCBQcF9zdGFiIHwgUHBfdGJlZ2luIF8gfCBQcF90ZW5kIHwgUHBfZW5kXG4gICAgICB8IFBwX25ld2xpbmUgfCBQcF9pZl9uZXdsaW5lIHwgUHBfb3Blbl90YWcgXyB8IFBwX2Nsb3NlX3RhZyAtPlxuICAgICAgICAoKSAoKiBzY2FuX3B1c2ggaXMgb25seSB1c2VkIGZvciBicmVha3MgYW5kIGJveGVzLiAqKVxuXG5cbigqIFB1c2ggYSB0b2tlbiBvbiBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay5cbiAgIElmIGIgaXMgdHJ1ZSBzZXRfc2l6ZSBpcyBjYWxsZWQuICopXG5sZXQgc2Nhbl9wdXNoIHN0YXRlIGIgdG9rZW4gPVxuICBwcF9lbnF1ZXVlIHN0YXRlIHRva2VuO1xuICBpZiBiIHRoZW4gc2V0X3NpemUgc3RhdGUgdHJ1ZTtcbiAgbGV0IGVsZW0gPSB7IGxlZnRfdG90YWwgPSBzdGF0ZS5wcF9yaWdodF90b3RhbDsgcXVldWVfZWxlbSA9IHRva2VuIH0gaW5cbiAgU3RhY2sucHVzaCBlbGVtIHN0YXRlLnBwX3NjYW5fc3RhY2tcblxuXG4oKiBUbyBvcGVuIGEgbmV3IGJveCA6XG4gICB0aGUgdXNlciBtYXkgc2V0IHRoZSBkZXB0aCBib3VuZCBwcF9tYXhfYm94ZXNcbiAgIGFueSB0ZXh0IG5lc3RlZCBkZWVwZXIgaXMgcHJpbnRlZCBhcyB0aGUgZWxsaXBzaXMgc3RyaW5nLiAqKVxubGV0IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgYnJfdHkgPVxuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggKyAxO1xuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUub2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX2JlZ2luIChpbmRlbnQsIGJyX3R5KTsgbGVuZ3RoID0gMCB9IGluXG4gICAgc2Nhbl9wdXNoIHN0YXRlIGZhbHNlIGVsZW0gZWxzZVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoID0gc3RhdGUucHBfbWF4X2JveGVzXG4gIHRoZW4gZW5xdWV1ZV9zdHJpbmcgc3RhdGUgc3RhdGUucHBfZWxsaXBzaXNcblxuXG4oKiBUaGUgYm94IHdoaWNoIGlzIGFsd2F5cyBvcGVuLiAqKVxubGV0IHBwX29wZW5fc3lzX2JveCBzdGF0ZSA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSAwIFBwX2hvdmJveFxuXG4oKiBDbG9zZSBhIGJveCwgc2V0dGluZyBzaXplcyBvZiBpdHMgc3ViIGJveGVzLiAqKVxubGV0IHBwX2Nsb3NlX2JveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBiZWdpblxuICAgICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfZW5kOyBsZW5ndGggPSAwIH07XG4gICAgICBzZXRfc2l6ZSBzdGF0ZSB0cnVlOyBzZXRfc2l6ZSBzdGF0ZSBmYWxzZVxuICAgIGVuZDtcbiAgICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggLSAxO1xuICBlbmRcblxuXG4oKiBPcGVuIGEgdGFnLCBwdXNoaW5nIGl0IG9uIHRoZSB0YWcgc3RhY2suICopXG5sZXQgcHBfb3Blbl9zdGFnIHN0YXRlIHRhZ19uYW1lID1cbiAgaWYgc3RhdGUucHBfcHJpbnRfdGFncyB0aGVuXG4gIGJlZ2luXG4gICAgU3RhY2sucHVzaCB0YWdfbmFtZSBzdGF0ZS5wcF90YWdfc3RhY2s7XG4gICAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgdGFnX25hbWVcbiAgZW5kO1xuICBpZiBzdGF0ZS5wcF9tYXJrX3RhZ3MgdGhlblxuICAgIGxldCB0b2tlbiA9IFBwX29wZW5fdGFnIHRhZ19uYW1lIGluXG4gICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuOyBsZW5ndGggPSAwIH1cblxuXG4oKiBDbG9zZSBhIHRhZywgcG9wcGluZyBpdCBmcm9tIHRoZSB0YWcgc3RhY2suICopXG5sZXQgcHBfY2xvc2Vfc3RhZyBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX21hcmtfdGFncyB0aGVuXG4gICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfY2xvc2VfdGFnOyBsZW5ndGggPSAwIH07XG4gIGlmIHN0YXRlLnBwX3ByaW50X3RhZ3MgdGhlblxuICAgIG1hdGNoIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfdGFnX3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gbW9yZSB0YWcgdG8gY2xvc2UuICopXG4gICAgfCBTb21lIHRhZ19uYW1lIC0+XG4gICAgICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgdGFnX25hbWVcblxubGV0IHBwX29wZW5fdGFnIHN0YXRlIHMgPSBwcF9vcGVuX3N0YWcgc3RhdGUgKFN0cmluZ190YWcgcylcbmxldCBwcF9jbG9zZV90YWcgc3RhdGUgKCkgPSBwcF9jbG9zZV9zdGFnIHN0YXRlICgpXG5cbmxldCBwcF9zZXRfcHJpbnRfdGFncyBzdGF0ZSBiID0gc3RhdGUucHBfcHJpbnRfdGFncyA8LSBiXG5sZXQgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiID0gc3RhdGUucHBfbWFya190YWdzIDwtIGJcbmxldCBwcF9nZXRfcHJpbnRfdGFncyBzdGF0ZSAoKSA9IHN0YXRlLnBwX3ByaW50X3RhZ3NcbmxldCBwcF9nZXRfbWFya190YWdzIHN0YXRlICgpID0gc3RhdGUucHBfbWFya190YWdzXG5sZXQgcHBfc2V0X3RhZ3Mgc3RhdGUgYiA9XG4gIHBwX3NldF9wcmludF90YWdzIHN0YXRlIGI7IHBwX3NldF9tYXJrX3RhZ3Mgc3RhdGUgYlxuXG5cbigqIEhhbmRsaW5nIHRhZyBoYW5kbGluZyBmdW5jdGlvbnM6IGdldC9zZXQgZnVuY3Rpb25zLiAqKVxubGV0IHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RhdGUgKCkgPSB7XG4gIG1hcmtfb3Blbl9zdGFnID0gc3RhdGUucHBfbWFya19vcGVuX3RhZztcbiAgbWFya19jbG9zZV9zdGFnID0gc3RhdGUucHBfbWFya19jbG9zZV90YWc7XG4gIHByaW50X29wZW5fc3RhZyA9IHN0YXRlLnBwX3ByaW50X29wZW5fdGFnO1xuICBwcmludF9jbG9zZV9zdGFnID0gc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnO1xufVxuXG5cbmxldCBwcF9zZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgbWFya19vcGVuX3N0YWcgPSBtb3Q7XG4gICAgIG1hcmtfY2xvc2Vfc3RhZyA9IG1jdDtcbiAgICAgcHJpbnRfb3Blbl9zdGFnID0gcG90O1xuICAgICBwcmludF9jbG9zZV9zdGFnID0gcGN0O1xuICB9ID1cbiAgc3RhdGUucHBfbWFya19vcGVuX3RhZyA8LSBtb3Q7XG4gIHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIDwtIG1jdDtcbiAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgPC0gcG90O1xuICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgPC0gcGN0XG5cblxuKCogSW5pdGlhbGl6ZSBwcmV0dHktcHJpbnRlci4gKilcbmxldCBwcF9yaW5pdCBzdGF0ZSA9XG4gIHBwX2NsZWFyX3F1ZXVlIHN0YXRlO1xuICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhdGUucHBfc2Nhbl9zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfZm9ybWF0X3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF90Ym94X3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF90YWdfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX21hcmtfc3RhY2s7XG4gIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50IDwtIDA7XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gMDtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9tYXJnaW47XG4gIHBwX29wZW5fc3lzX2JveCBzdGF0ZVxuXG5sZXQgY2xlYXJfdGFnX3N0YWNrIHN0YXRlID1cbiAgU3RhY2suaXRlciAoZnVuIF8gLT4gcHBfY2xvc2VfdGFnIHN0YXRlICgpKSBzdGF0ZS5wcF90YWdfc3RhY2tcblxuXG4oKiBGbHVzaGluZyBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbmxldCBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSBiID1cbiAgY2xlYXJfdGFnX3N0YWNrIHN0YXRlO1xuICB3aGlsZSBzdGF0ZS5wcF9jdXJyX2RlcHRoID4gMSBkb1xuICAgIHBwX2Nsb3NlX2JveCBzdGF0ZSAoKVxuICBkb25lO1xuICBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSBwcF9pbmZpbml0eTtcbiAgYWR2YW5jZV9sZWZ0IHN0YXRlO1xuICBpZiBiIHRoZW4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGU7XG4gIHBwX3Jpbml0IHN0YXRlXG5cbigqXG5cbiAgUHJvY2VkdXJlcyB0byBmb3JtYXQgdmFsdWVzIGFuZCB1c2UgYm94ZXMuXG5cbiopXG5cbigqIFRvIGZvcm1hdCBhIHN0cmluZy4gKilcbmxldCBwcF9wcmludF9hc19zaXplIHN0YXRlIHNpemUgcyA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXNcbiAgdGhlbiBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSBzaXplIHNcblxuXG5sZXQgcHBfcHJpbnRfYXMgc3RhdGUgaXNpemUgcyA9XG4gIHBwX3ByaW50X2FzX3NpemUgc3RhdGUgKFNpemUub2ZfaW50IGlzaXplKSBzXG5cblxubGV0IHBwX3ByaW50X3N0cmluZyBzdGF0ZSBzID1cbiAgcHBfcHJpbnRfYXMgc3RhdGUgKFN0cmluZy5sZW5ndGggcykgc1xuXG5sZXQgcHBfcHJpbnRfYnl0ZXMgc3RhdGUgcyA9XG4gIHBwX3ByaW50X2FzIHN0YXRlIChCeXRlcy5sZW5ndGggcykgKEJ5dGVzLnRvX3N0cmluZyBzKVxuXG4oKiBUbyBmb3JtYXQgYW4gaW50ZWdlci4gKilcbmxldCBwcF9wcmludF9pbnQgc3RhdGUgaSA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoSW50LnRvX3N0cmluZyBpKVxuXG4oKiBUbyBmb3JtYXQgYSBmbG9hdC4gKilcbmxldCBwcF9wcmludF9mbG9hdCBzdGF0ZSBmID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChzdHJpbmdfb2ZfZmxvYXQgZilcblxuKCogVG8gZm9ybWF0IGEgYm9vbGVhbi4gKilcbmxldCBwcF9wcmludF9ib29sIHN0YXRlIGIgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKHN0cmluZ19vZl9ib29sIGIpXG5cbigqIFRvIGZvcm1hdCBhIGNoYXIuICopXG5sZXQgcHBfcHJpbnRfY2hhciBzdGF0ZSBjID1cbiAgcHBfcHJpbnRfYXMgc3RhdGUgMSAoU3RyaW5nLm1ha2UgMSBjKVxuXG5cbigqIE9wZW5pbmcgYm94ZXMuICopXG5sZXQgcHBfb3Blbl9oYm94IHN0YXRlICgpID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIDAgUHBfaGJveFxuYW5kIHBwX29wZW5fdmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX3Zib3hcblxuYW5kIHBwX29wZW5faHZib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF9odmJveFxuYW5kIHBwX29wZW5faG92Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfaG92Ym94XG5hbmQgcHBfb3Blbl9ib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF9ib3hcblxuXG4oKiBQcmludGluZyBxdWV1ZWQgdGV4dC5cblxuICAgW3BwX3ByaW50X2ZsdXNoXSBwcmludHMgYWxsIHBlbmRpbmcgaXRlbXMgaW4gdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGFuZFxuICAgdGhlbiBmbHVzaGVzIHRoZSBsb3cgbGV2ZWwgb3V0cHV0IGRldmljZSBvZiB0aGUgZm9ybWF0dGVyIHRvIGFjdHVhbGx5XG4gICBkaXNwbGF5IHByaW50aW5nIG1hdGVyaWFsLlxuXG4gICBbcHBfcHJpbnRfbmV3bGluZV0gYmVoYXZlcyBhcyBbcHBfcHJpbnRfZmx1c2hdIGFmdGVyIHByaW50aW5nIGFuIGFkZGl0aW9uYWxcbiAgIG5ldyBsaW5lLiAqKVxubGV0IHBwX3ByaW50X25ld2xpbmUgc3RhdGUgKCkgPVxuICBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSB0cnVlOyBzdGF0ZS5wcF9vdXRfZmx1c2ggKClcbmFuZCBwcF9wcmludF9mbHVzaCBzdGF0ZSAoKSA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIGZhbHNlOyBzdGF0ZS5wcF9vdXRfZmx1c2ggKClcblxuXG4oKiBUbyBnZXQgYSBuZXdsaW5lIHdoZW4gb25lIGRvZXMgbm90IHdhbnQgdG8gY2xvc2UgdGhlIGN1cnJlbnQgYm94LiAqKVxubGV0IHBwX2ZvcmNlX25ld2xpbmUgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX25ld2xpbmU7IGxlbmd0aCA9IDAgfVxuXG5cbigqIFRvIGZvcm1hdCBzb21ldGhpbmcsIG9ubHkgaW4gY2FzZSB0aGUgbGluZSBoYXMganVzdCBiZWVuIGJyb2tlbi4gKilcbmxldCBwcF9wcmludF9pZl9uZXdsaW5lIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlXG4gICAgICB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfaWZfbmV3bGluZTsgbGVuZ3RoID0gMCB9XG5cblxuKCogR2VuZXJhbGl6ZWQgYnJlYWsgaGludCB0aGF0IGFsbG93cyBwcmludGluZyBzdHJpbmdzIGJlZm9yZS9hZnRlclxuICAgc2FtZS1saW5lIG9mZnNldCAod2lkdGgpIG9yIG5ldy1saW5lIG9mZnNldCAqKVxubGV0IHBwX3ByaW50X2N1c3RvbV9icmVhayBzdGF0ZSB+Zml0cyB+YnJlYWtzID1cbiAgbGV0IGJlZm9yZSwgd2lkdGgsIGFmdGVyID0gZml0cyBpblxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUub2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSBpblxuICAgIGxldCB0b2tlbiA9IFBwX2JyZWFrIHsgZml0czsgYnJlYWtzIH0gaW5cbiAgICBsZXQgbGVuZ3RoID0gU3RyaW5nLmxlbmd0aCBiZWZvcmUgKyB3aWR0aCArIFN0cmluZy5sZW5ndGggYWZ0ZXIgaW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZTsgdG9rZW47IGxlbmd0aCB9IGluXG4gICAgc2Nhbl9wdXNoIHN0YXRlIHRydWUgZWxlbVxuXG4oKiBQcmludGluZyBicmVhayBoaW50czpcbiAgIEEgYnJlYWsgaGludCBpbmRpY2F0ZXMgd2hlcmUgYSBib3ggbWF5IGJlIGJyb2tlbi5cbiAgIElmIGxpbmUgaXMgYnJva2VuIHRoZW4gb2Zmc2V0IGlzIGFkZGVkIHRvIHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgY3VycmVudFxuICAgYm94IGVsc2UgKHRoZSB2YWx1ZSBvZikgd2lkdGggYmxhbmtzIGFyZSBwcmludGVkLiAqKVxubGV0IHBwX3ByaW50X2JyZWFrIHN0YXRlIHdpZHRoIG9mZnNldCA9XG4gIHBwX3ByaW50X2N1c3RvbV9icmVhayBzdGF0ZVxuICAgIH5maXRzOihcIlwiLCB3aWR0aCwgXCJcIikgfmJyZWFrczooXCJcIiwgb2Zmc2V0LCBcIlwiKVxuXG5cbigqIFByaW50IGEgc3BhY2UgOlxuICAgYSBzcGFjZSBpcyBhIGJyZWFrIGhpbnQgdGhhdCBwcmludHMgYSBzaW5nbGUgc3BhY2UgaWYgdGhlIGJyZWFrIGRvZXMgbm90XG4gICBzcGxpdCB0aGUgbGluZTtcbiAgIGEgY3V0IGlzIGEgYnJlYWsgaGludCB0aGF0IHByaW50cyBub3RoaW5nIGlmIHRoZSBicmVhayBkb2VzIG5vdCBzcGxpdCB0aGVcbiAgIGxpbmUuICopXG5sZXQgcHBfcHJpbnRfc3BhY2Ugc3RhdGUgKCkgPSBwcF9wcmludF9icmVhayBzdGF0ZSAxIDBcbmFuZCBwcF9wcmludF9jdXQgc3RhdGUgKCkgPSBwcF9wcmludF9icmVhayBzdGF0ZSAwIDBcblxuXG4oKiBUYWJ1bGF0aW9uIGJveGVzLiAqKVxubGV0IHBwX29wZW5fdGJveCBzdGF0ZSAoKSA9XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCArIDE7XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS56ZXJvIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuID0gUHBfdGJlZ2luIChQcF90Ym94IChyZWYgW10pKTsgbGVuZ3RoID0gMCB9IGluXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIGVsZW1cblxuXG4oKiBDbG9zZSBhIHRhYnVsYXRpb24gYm94LiAqKVxubGV0IHBwX2Nsb3NlX3Rib3ggc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoID4gMSB0aGVuXG4gIGJlZ2luXG4gICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICAgbGV0IGVsZW0gPSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfdGVuZDsgbGVuZ3RoID0gMCB9IGluXG4gICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtO1xuICAgICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggLSAxXG4gIGVuZFxuXG5cbigqIFByaW50IGEgdGFidWxhdGlvbiBicmVhay4gKilcbmxldCBwcF9wcmludF90YnJlYWsgc3RhdGUgd2lkdGggb2Zmc2V0ID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLm9mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkgaW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZTsgdG9rZW4gPSBQcF90YnJlYWsgKHdpZHRoLCBvZmZzZXQpOyBsZW5ndGggPSB3aWR0aCB9IGluXG4gICAgc2Nhbl9wdXNoIHN0YXRlIHRydWUgZWxlbVxuXG5cbmxldCBwcF9wcmludF90YWIgc3RhdGUgKCkgPSBwcF9wcmludF90YnJlYWsgc3RhdGUgMCAwXG5cbmxldCBwcF9zZXRfdGFiIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IGVsZW0gPSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfc3RhYjsgbGVuZ3RoID0gMCB9IGluXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIGVsZW1cblxuXG4oKlxuXG4gIFByb2NlZHVyZXMgdG8gY29udHJvbCB0aGUgcHJldHR5LXByaW50ZXJzXG5cbiopXG5cbigqIFNldF9tYXhfYm94ZXMuICopXG5sZXQgcHBfc2V0X21heF9ib3hlcyBzdGF0ZSBuID0gaWYgbiA+IDEgdGhlbiBzdGF0ZS5wcF9tYXhfYm94ZXMgPC0gblxuXG4oKiBUbyBrbm93IHRoZSBjdXJyZW50IG1heGltdW0gbnVtYmVyIG9mIGJveGVzIGFsbG93ZWQuICopXG5sZXQgcHBfZ2V0X21heF9ib3hlcyBzdGF0ZSAoKSA9IHN0YXRlLnBwX21heF9ib3hlc1xuXG5sZXQgcHBfb3Zlcl9tYXhfYm94ZXMgc3RhdGUgKCkgPSBzdGF0ZS5wcF9jdXJyX2RlcHRoID0gc3RhdGUucHBfbWF4X2JveGVzXG5cbigqIEVsbGlwc2lzLiAqKVxubGV0IHBwX3NldF9lbGxpcHNpc190ZXh0IHN0YXRlIHMgPSBzdGF0ZS5wcF9lbGxpcHNpcyA8LSBzXG5hbmQgcHBfZ2V0X2VsbGlwc2lzX3RleHQgc3RhdGUgKCkgPSBzdGF0ZS5wcF9lbGxpcHNpc1xuXG5cbigqIFRvIHNldCB0aGUgbWFyZ2luIG9mIHByZXR0eS1wcmludGVyLiAqKVxubGV0IHBwX2xpbWl0IG4gPVxuICBpZiBuIDwgcHBfaW5maW5pdHkgdGhlbiBuIGVsc2UgcHJlZCBwcF9pbmZpbml0eVxuXG5cbigqIEludGVybmFsIHByZXR0eS1wcmludGVyIGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfbWluX3NwYWNlX2xlZnQgc3RhdGUgbiA9XG4gIGlmIG4gPj0gMSB0aGVuXG4gICAgbGV0IG4gPSBwcF9saW1pdCBuIGluXG4gICAgc3RhdGUucHBfbWluX3NwYWNlX2xlZnQgPC0gbjtcbiAgICBzdGF0ZS5wcF9tYXhfaW5kZW50IDwtIHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0O1xuICAgIHBwX3Jpbml0IHN0YXRlXG5cblxuKCogSW5pdGlhbGx5LCB3ZSBoYXZlIDpcbiAgIHBwX21heF9pbmRlbnQgPSBwcF9tYXJnaW4gLSBwcF9taW5fc3BhY2VfbGVmdCwgYW5kXG4gICBwcF9zcGFjZV9sZWZ0ID0gcHBfbWFyZ2luLiAqKVxubGV0IHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG4gPVxuICBpZiBuID4gMSB0aGVuXG4gICAgcHBfc2V0X21pbl9zcGFjZV9sZWZ0IHN0YXRlIChzdGF0ZS5wcF9tYXJnaW4gLSBuKVxuXG5cbmxldCBwcF9nZXRfbWF4X2luZGVudCBzdGF0ZSAoKSA9IHN0YXRlLnBwX21heF9pbmRlbnRcblxubGV0IHBwX3NldF9tYXJnaW4gc3RhdGUgbiA9XG4gIGlmIG4gPj0gMSB0aGVuXG4gICAgbGV0IG4gPSBwcF9saW1pdCBuIGluXG4gICAgc3RhdGUucHBfbWFyZ2luIDwtIG47XG4gICAgbGV0IG5ld19tYXhfaW5kZW50ID1cbiAgICAgICgqIFRyeSB0byBtYWludGFpbiBtYXhfaW5kZW50IHRvIGl0cyBhY3R1YWwgdmFsdWUuICopXG4gICAgICBpZiBzdGF0ZS5wcF9tYXhfaW5kZW50IDw9IHN0YXRlLnBwX21hcmdpblxuICAgICAgdGhlbiBzdGF0ZS5wcF9tYXhfaW5kZW50IGVsc2VcbiAgICAgICgqIElmIHBvc3NpYmxlIG1haW50YWluIHBwX21pbl9zcGFjZV9sZWZ0IHRvIGl0cyBhY3R1YWwgdmFsdWUsXG4gICAgICAgICBpZiB0aGlzIGxlYWRzIHRvIGEgdG9vIHNtYWxsIG1heF9pbmRlbnQsIHRha2UgaGFsZiBvZiB0aGVcbiAgICAgICAgIG5ldyBtYXJnaW4sIGlmIGl0IGlzIGdyZWF0ZXIgdGhhbiAxLiAqKVxuICAgICAgIEludC5tYXggKEludC5tYXggKHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0KVxuICAgICAgICAgICAgICAgIChzdGF0ZS5wcF9tYXJnaW4gLyAyKSkgMSBpblxuICAgICgqIFJlYnVpbGQgaW52YXJpYW50cy4gKilcbiAgICBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBuZXdfbWF4X2luZGVudFxuXG5cbigqKiBHZW9tZXRyeSBmdW5jdGlvbnMgYW5kIHR5cGVzICopXG50eXBlIGdlb21ldHJ5ID0geyBtYXhfaW5kZW50OmludDsgbWFyZ2luOiBpbnR9XG5cbmxldCB2YWxpZGF0ZV9nZW9tZXRyeSB7bWFyZ2luOyBtYXhfaW5kZW50fSA9XG4gIGlmIG1heF9pbmRlbnQgPCAyIHRoZW5cbiAgICBFcnJvciBcIm1heF9pbmRlbnQgPCAyXCJcbiAgZWxzZSBpZiBtYXJnaW4gPD0gbWF4X2luZGVudCB0aGVuXG4gICAgRXJyb3IgXCJtYXJnaW4gPD0gbWF4X2luZGVudFwiXG4gIGVsc2UgT2sgKClcblxubGV0IGNoZWNrX2dlb21ldHJ5IGdlb21ldHJ5ID1cbiAgbWF0Y2ggdmFsaWRhdGVfZ2VvbWV0cnkgZ2VvbWV0cnkgd2l0aFxuICB8IE9rICgpIC0+IHRydWVcbiAgfCBFcnJvciBfIC0+IGZhbHNlXG5cbmxldCBwcF9nZXRfbWFyZ2luIHN0YXRlICgpID0gc3RhdGUucHBfbWFyZ2luXG5cbmxldCBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSB7bWFyZ2luOyBtYXhfaW5kZW50fSA9XG4gIHBwX3NldF9tYXJnaW4gc3RhdGUgbWFyZ2luO1xuICBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBtYXhfaW5kZW50O1xuICAoKVxuXG5sZXQgcHBfc2V0X2dlb21ldHJ5IHN0YXRlIH5tYXhfaW5kZW50IH5tYXJnaW4gPVxuICBsZXQgZ2VvbWV0cnkgPSB7IG1heF9pbmRlbnQ7IG1hcmdpbiB9IGluXG4gIG1hdGNoIHZhbGlkYXRlX2dlb21ldHJ5IGdlb21ldHJ5IHdpdGhcbiAgfCBFcnJvciBtc2cgLT5cbiAgICByYWlzZSAoSW52YWxpZF9hcmd1bWVudCAoXCJGb3JtYXQucHBfc2V0X2dlb21ldHJ5OiBcIiBeIG1zZykpXG4gIHwgT2sgKCkgLT5cbiAgICBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSBnZW9tZXRyeVxuXG5sZXQgcHBfc2FmZV9zZXRfZ2VvbWV0cnkgc3RhdGUgfm1heF9pbmRlbnQgfm1hcmdpbiA9XG4gIGxldCBnZW9tZXRyeSA9IHsgbWF4X2luZGVudDsgbWFyZ2luIH0gaW5cbiAgbWF0Y2ggdmFsaWRhdGVfZ2VvbWV0cnkgZ2VvbWV0cnkgd2l0aFxuICB8IEVycm9yIF9tc2cgLT5cbiAgICAgKClcbiAgfCBPayAoKSAtPlxuICAgIHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlIGdlb21ldHJ5XG5cbmxldCBwcF9nZXRfZ2VvbWV0cnkgc3RhdGUgKCkgPVxuICB7IG1hcmdpbiA9IHBwX2dldF9tYXJnaW4gc3RhdGUgKCk7IG1heF9pbmRlbnQgPSBwcF9nZXRfbWF4X2luZGVudCBzdGF0ZSAoKSB9XG5cbmxldCBwcF91cGRhdGVfZ2VvbWV0cnkgc3RhdGUgdXBkYXRlID1cbiAgbGV0IGdlb21ldHJ5ID0gcHBfZ2V0X2dlb21ldHJ5IHN0YXRlICgpIGluXG4gIHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlICh1cGRhdGUgZ2VvbWV0cnkpXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RhdGUge1xuICAgICAgb3V0X3N0cmluZyA9IGY7XG4gICAgICBvdXRfZmx1c2ggPSBnO1xuICAgICAgb3V0X25ld2xpbmUgPSBoO1xuICAgICAgb3V0X3NwYWNlcyA9IGk7XG4gICAgICBvdXRfaW5kZW50ID0gajtcbiAgICB9ID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBmO1xuICBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gZztcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gaDtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBpO1xuICBzdGF0ZS5wcF9vdXRfaW5kZW50IDwtIGpcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGF0ZSAoKSA9IHtcbiAgb3V0X3N0cmluZyA9IHN0YXRlLnBwX291dF9zdHJpbmc7XG4gIG91dF9mbHVzaCA9IHN0YXRlLnBwX291dF9mbHVzaDtcbiAgb3V0X25ld2xpbmUgPSBzdGF0ZS5wcF9vdXRfbmV3bGluZTtcbiAgb3V0X3NwYWNlcyA9IHN0YXRlLnBwX291dF9zcGFjZXM7XG4gIG91dF9pbmRlbnQgPSBzdGF0ZS5wcF9vdXRfaW5kZW50O1xufVxuXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgc3RyaW5nIG91dHB1dCBhbmQgZmx1c2ggZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSBmIGcgPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIGY7IHN0YXRlLnBwX291dF9mbHVzaCA8LSBnXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgKCkgPVxuICAoc3RhdGUucHBfb3V0X3N0cmluZywgc3RhdGUucHBfb3V0X2ZsdXNoKVxuXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBuZXcgbGluZXMuICopXG5sZXQgZGlzcGxheV9uZXdsaW5lIHN0YXRlICgpID0gc3RhdGUucHBfb3V0X3N0cmluZyBcIlxcblwiIDAgIDFcblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IHNwYWNlcy4gKilcbmxldCBibGFua19saW5lID0gU3RyaW5nLm1ha2UgODAgJyAnXG5sZXQgcmVjIGRpc3BsYXlfYmxhbmtzIHN0YXRlIG4gPVxuICBpZiBuID4gMCB0aGVuXG4gIGlmIG4gPD0gODAgdGhlbiBzdGF0ZS5wcF9vdXRfc3RyaW5nIGJsYW5rX2xpbmUgMCBuIGVsc2VcbiAgYmVnaW5cbiAgICBzdGF0ZS5wcF9vdXRfc3RyaW5nIGJsYW5rX2xpbmUgMCA4MDtcbiAgICBkaXNwbGF5X2JsYW5rcyBzdGF0ZSAobiAtIDgwKVxuICBlbmRcblxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgaW5kZW50YXRpb24gb2YgbmV3IGxpbmVzLiAqKVxubGV0IGRpc3BsYXlfaW5kZW50ID0gZGlzcGxheV9ibGFua3NcblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zIGFzIHByaW50aW5nIHRvIGEgZ2l2ZW5cbiAgIFtQZXJ2YXNpdmUub3V0X2NoYW5uZWxdIHZhbHVlLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgc3RhdGUgb2MgPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIG91dHB1dF9zdWJzdHJpbmcgb2M7XG4gIHN0YXRlLnBwX291dF9mbHVzaCA8LSAoZnVuICgpIC0+IGZsdXNoIG9jKTtcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gZGlzcGxheV9uZXdsaW5lIHN0YXRlO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGRpc3BsYXlfYmxhbmtzIHN0YXRlO1xuICBzdGF0ZS5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHN0YXRlXG5cbigqXG5cbiAgRGVmaW5pbmcgc3BlY2lmaWMgZm9ybWF0dGVyc1xuXG4qKVxuXG5sZXQgZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnID0gZnVuY3Rpb25cbiAgfCBTdHJpbmdfdGFnIHMgLT4gXCI8XCIgXiBzIF4gXCI+XCJcbiAgfCBfIC0+IFwiXCJcbmxldCBkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnID0gZnVuY3Rpb25cbiAgfCBTdHJpbmdfdGFnIHMgLT4gXCI8L1wiIF4gcyBeIFwiPlwiXG4gIHwgXyAtPiBcIlwiXG5cbmxldCBkZWZhdWx0X3BwX3ByaW50X29wZW5fdGFnID0gaWdub3JlXG5sZXQgZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWcgPSBpZ25vcmVcblxuKCogQnVpbGRpbmcgYSBmb3JtYXR0ZXIgZ2l2ZW4gaXRzIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMuXG4gICBPdGhlciBmaWVsZHMgZ2V0IHJlYXNvbmFibGUgZGVmYXVsdCB2YWx1ZXMuICopXG5sZXQgcHBfbWFrZV9mb3JtYXR0ZXIgZiBnIGggaSBqID1cbiAgKCogVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIGZvcm1hdHRlciBjb250YWlucyBhIGR1bW15IGJveC4gKilcbiAgbGV0IHBwX3F1ZXVlID0gUXVldWUuY3JlYXRlICgpIGluXG4gIGxldCBzeXNfdG9rID1cbiAgICB7IHNpemUgPSBTaXplLnVua25vd247IHRva2VuID0gUHBfYmVnaW4gKDAsIFBwX2hvdmJveCk7IGxlbmd0aCA9IDAgfSBpblxuICBRdWV1ZS5hZGQgc3lzX3RvayBwcF9xdWV1ZTtcbiAgbGV0IHNjYW5fc3RhY2sgPSBTdGFjay5jcmVhdGUgKCkgaW5cbiAgaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIHNjYW5fc3RhY2s7XG4gIFN0YWNrLnB1c2ggeyBsZWZ0X3RvdGFsID0gMTsgcXVldWVfZWxlbSA9IHN5c190b2sgfSBzY2FuX3N0YWNrO1xuICBsZXQgcHBfbWFyZ2luID0gNzhcbiAgYW5kIHBwX21pbl9zcGFjZV9sZWZ0ID0gMTAgaW5cbiAge1xuICAgIHBwX3NjYW5fc3RhY2sgPSBzY2FuX3N0YWNrO1xuICAgIHBwX2Zvcm1hdF9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF90Ym94X3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX3RhZ19zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF9tYXJrX3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX21hcmdpbiA9IHBwX21hcmdpbjtcbiAgICBwcF9taW5fc3BhY2VfbGVmdCA9IHBwX21pbl9zcGFjZV9sZWZ0O1xuICAgIHBwX21heF9pbmRlbnQgPSBwcF9tYXJnaW4gLSBwcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9zcGFjZV9sZWZ0ID0gcHBfbWFyZ2luO1xuICAgIHBwX2N1cnJlbnRfaW5kZW50ID0gMDtcbiAgICBwcF9pc19uZXdfbGluZSA9IHRydWU7XG4gICAgcHBfbGVmdF90b3RhbCA9IDE7XG4gICAgcHBfcmlnaHRfdG90YWwgPSAxO1xuICAgIHBwX2N1cnJfZGVwdGggPSAxO1xuICAgIHBwX21heF9ib3hlcyA9IG1heF9pbnQ7XG4gICAgcHBfZWxsaXBzaXMgPSBcIi5cIjtcbiAgICBwcF9vdXRfc3RyaW5nID0gZjtcbiAgICBwcF9vdXRfZmx1c2ggPSBnO1xuICAgIHBwX291dF9uZXdsaW5lID0gaDtcbiAgICBwcF9vdXRfc3BhY2VzID0gaTtcbiAgICBwcF9vdXRfaW5kZW50ID0gajtcbiAgICBwcF9wcmludF90YWdzID0gZmFsc2U7XG4gICAgcHBfbWFya190YWdzID0gZmFsc2U7XG4gICAgcHBfbWFya19vcGVuX3RhZyA9IGRlZmF1bHRfcHBfbWFya19vcGVuX3RhZztcbiAgICBwcF9tYXJrX2Nsb3NlX3RhZyA9IGRlZmF1bHRfcHBfbWFya19jbG9zZV90YWc7XG4gICAgcHBfcHJpbnRfb3Blbl90YWcgPSBkZWZhdWx0X3BwX3ByaW50X29wZW5fdGFnO1xuICAgIHBwX3ByaW50X2Nsb3NlX3RhZyA9IGRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnO1xuICAgIHBwX3F1ZXVlID0gcHBfcXVldWU7XG4gIH1cblxuXG4oKiBCdWlsZCBhIGZvcm1hdHRlciBvdXQgb2YgaXRzIG91dCBmdW5jdGlvbnMuICopXG5sZXQgZm9ybWF0dGVyX29mX291dF9mdW5jdGlvbnMgb3V0X2Z1bnMgPVxuICBwcF9tYWtlX2Zvcm1hdHRlclxuICAgIG91dF9mdW5zLm91dF9zdHJpbmdcbiAgICBvdXRfZnVucy5vdXRfZmx1c2hcbiAgICBvdXRfZnVucy5vdXRfbmV3bGluZVxuICAgIG91dF9mdW5zLm91dF9zcGFjZXNcbiAgICBvdXRfZnVucy5vdXRfaW5kZW50XG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3aXRoIGRlZmF1bHQgZnVuY3Rpb25zIHRvIG91dHB1dCBzcGFjZXMsXG4gIGluZGVudGF0aW9uLCBhbmQgbmV3IGxpbmVzLiAqKVxubGV0IG1ha2VfZm9ybWF0dGVyIG91dHB1dCBmbHVzaCA9XG4gIGxldCBwcGYgPSBwcF9tYWtlX2Zvcm1hdHRlciBvdXRwdXQgZmx1c2ggaWdub3JlIGlnbm9yZSBpZ25vcmUgaW5cbiAgcHBmLnBwX291dF9uZXdsaW5lIDwtIGRpc3BsYXlfbmV3bGluZSBwcGY7XG4gIHBwZi5wcF9vdXRfc3BhY2VzIDwtIGRpc3BsYXlfYmxhbmtzIHBwZjtcbiAgcHBmLnBwX291dF9pbmRlbnQgPC0gZGlzcGxheV9pbmRlbnQgcHBmO1xuICBwcGZcblxuXG4oKiBNYWtlIGEgZm9ybWF0dGVyIHdyaXRpbmcgdG8gYSBnaXZlbiBbUGVydmFzaXZlLm91dF9jaGFubmVsXSB2YWx1ZS4gKilcbmxldCBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgb2MgPVxuICBtYWtlX2Zvcm1hdHRlciAob3V0cHV0X3N1YnN0cmluZyBvYykgKGZ1biAoKSAtPiBmbHVzaCBvYylcblxuXG4oKiBNYWtlIGEgZm9ybWF0dGVyIHdyaXRpbmcgdG8gYSBnaXZlbiBbQnVmZmVyLnRdIHZhbHVlLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9idWZmZXIgYiA9XG4gIG1ha2VfZm9ybWF0dGVyIChCdWZmZXIuYWRkX3N1YnN0cmluZyBiKSBpZ25vcmVcblxuXG4oKiBBbGxvY2F0aW5nIGJ1ZmZlciBmb3IgcHJldHR5LXByaW50aW5nIHB1cnBvc2VzLlxuICAgRGVmYXVsdCBidWZmZXIgc2l6ZSBpcyBwcF9idWZmZXJfc2l6ZSBvciA1MTIuXG4qKVxubGV0IHBwX2J1ZmZlcl9zaXplID0gNTEyXG5sZXQgcHBfbWFrZV9idWZmZXIgKCkgPSBCdWZmZXIuY3JlYXRlIHBwX2J1ZmZlcl9zaXplXG5cbigqIFRoZSBzdGFuZGFyZCAoc2hhcmVkKSBidWZmZXIuICopXG5sZXQgc3RkYnVmID0gcHBfbWFrZV9idWZmZXIgKClcblxuKCogUHJlZGVmaW5lZCBmb3JtYXR0ZXJzIHN0YW5kYXJkIGZvcm1hdHRlciB0byBwcmludFxuICAgdG8gW1N0ZGxpYi5zdGRvdXRdLCBbU3RkbGliLnN0ZGVycl0sIGFuZCB7IXN0ZGJ1Zn0uICopXG5sZXQgc3RkX2Zvcm1hdHRlciA9IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBTdGRsaWIuc3Rkb3V0XG5hbmQgZXJyX2Zvcm1hdHRlciA9IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBTdGRsaWIuc3RkZXJyXG5hbmQgc3RyX2Zvcm1hdHRlciA9IGZvcm1hdHRlcl9vZl9idWZmZXIgc3RkYnVmXG5cblxuKCogW2ZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgYnVmIHBwZl0gZmx1c2hlcyBmb3JtYXR0ZXIgW3BwZl0sXG4gICB0aGVuIHJldHVybnMgdGhlIGNvbnRlbnRzIG9mIGJ1ZmZlciBbYnVmXSB0aGF0IGlzIHJlc2V0LlxuICAgRm9ybWF0dGVyIFtwcGZdIGlzIHN1cHBvc2VkIHRvIHByaW50IHRvIGJ1ZmZlciBbYnVmXSwgb3RoZXJ3aXNlIHRoaXNcbiAgIGZ1bmN0aW9uIGlzIG5vdCByZWFsbHkgdXNlZnVsLiAqKVxubGV0IGZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgYnVmIHBwZiA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHBwZiBmYWxzZTtcbiAgbGV0IHMgPSBCdWZmZXIuY29udGVudHMgYnVmIGluXG4gIEJ1ZmZlci5yZXNldCBidWY7XG4gIHNcblxuXG4oKiBGbHVzaCBbc3RyX2Zvcm1hdHRlcl0gYW5kIGdldCB0aGUgY29udGVudHMgb2YgW3N0ZGJ1Zl0uICopXG5sZXQgZmx1c2hfc3RyX2Zvcm1hdHRlciAoKSA9IGZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgc3RkYnVmIHN0cl9mb3JtYXR0ZXJcblxuKCpcbiAgU3ltYm9saWMgcHJldHR5LXByaW50aW5nXG4qKVxuXG4oKlxuICBTeW1ib2xpYyBwcmV0dHktcHJpbnRpbmcgaXMgcHJldHR5LXByaW50aW5nIHdpdGggbm8gbG93IGxldmVsIG91dHB1dC5cblxuICBXaGVuIHVzaW5nIGEgc3ltYm9saWMgZm9ybWF0dGVyLCBhbGwgcmVndWxhciBwcmV0dHktcHJpbnRpbmcgYWN0aXZpdGllc1xuICBvY2N1ciBidXQgb3V0cHV0IG1hdGVyaWFsIGlzIHN5bWJvbGljIGFuZCBzdG9yZWQgaW4gYSBidWZmZXIgb2Ygb3V0cHV0XG4gIGl0ZW1zLiBBdCB0aGUgZW5kIG9mIHByZXR0eS1wcmludGluZywgZmx1c2hpbmcgdGhlIG91dHB1dCBidWZmZXIgYWxsb3dzXG4gIHBvc3QtcHJvY2Vzc2luZyBvZiBzeW1ib2xpYyBvdXRwdXQgYmVmb3JlIGxvdyBsZXZlbCBvdXRwdXQgb3BlcmF0aW9ucy5cbiopXG5cbnR5cGUgc3ltYm9saWNfb3V0cHV0X2l0ZW0gPVxuICB8IE91dHB1dF9mbHVzaFxuICB8IE91dHB1dF9uZXdsaW5lXG4gIHwgT3V0cHV0X3N0cmluZyBvZiBzdHJpbmdcbiAgfCBPdXRwdXRfc3BhY2VzIG9mIGludFxuICB8IE91dHB1dF9pbmRlbnQgb2YgaW50XG5cbnR5cGUgc3ltYm9saWNfb3V0cHV0X2J1ZmZlciA9IHtcbiAgbXV0YWJsZSBzeW1ib2xpY19vdXRwdXRfY29udGVudHMgOiBzeW1ib2xpY19vdXRwdXRfaXRlbSBsaXN0O1xufVxuXG5sZXQgbWFrZV9zeW1ib2xpY19vdXRwdXRfYnVmZmVyICgpID1cbiAgeyBzeW1ib2xpY19vdXRwdXRfY29udGVudHMgPSBbXSB9XG5cbmxldCBjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHMgPC0gW11cblxubGV0IGdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIExpc3QucmV2IHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHNcblxubGV0IGZsdXNoX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgbGV0IGl0ZW1zID0gZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iIGluXG4gIGNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iO1xuICBpdGVtc1xuXG5sZXQgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBpdGVtID1cbiAgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50cyA8LSBpdGVtIDo6IHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHNcblxubGV0IGZvcm1hdHRlcl9vZl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIGxldCBzeW1ib2xpY19mbHVzaCBzb2IgKCkgPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgT3V0cHV0X2ZsdXNoXG4gIGFuZCBzeW1ib2xpY19uZXdsaW5lIHNvYiAoKSA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBPdXRwdXRfbmV3bGluZVxuICBhbmQgc3ltYm9saWNfc3RyaW5nIHNvYiBzIGkgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X3N0cmluZyAoU3RyaW5nLnN1YiBzIGkgbikpXG4gIGFuZCBzeW1ib2xpY19zcGFjZXMgc29iIG4gPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgKE91dHB1dF9zcGFjZXMgbilcbiAgYW5kIHN5bWJvbGljX2luZGVudCBzb2IgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X2luZGVudCBuKSBpblxuXG4gIGxldCBmID0gc3ltYm9saWNfc3RyaW5nIHNvYlxuICBhbmQgZyA9IHN5bWJvbGljX2ZsdXNoIHNvYlxuICBhbmQgaCA9IHN5bWJvbGljX25ld2xpbmUgc29iXG4gIGFuZCBpID0gc3ltYm9saWNfc3BhY2VzIHNvYlxuICBhbmQgaiA9IHN5bWJvbGljX2luZGVudCBzb2IgaW5cbiAgcHBfbWFrZV9mb3JtYXR0ZXIgZiBnIGggaSBqXG5cbigqXG5cbiAgQmFzaWMgZnVuY3Rpb25zIG9uIHRoZSAnc3RhbmRhcmQnIGZvcm1hdHRlclxuICAodGhlIGZvcm1hdHRlciB0aGF0IHByaW50cyB0byBbU3RkbGliLnN0ZG91dF0pLlxuXG4qKVxuXG5sZXQgb3Blbl9oYm94ID0gcHBfb3Blbl9oYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3Zib3ggPSBwcF9vcGVuX3Zib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5faHZib3ggPSBwcF9vcGVuX2h2Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2hvdmJveCA9IHBwX29wZW5faG92Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2JveCA9IHBwX29wZW5fYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV9ib3ggPSBwcF9jbG9zZV9ib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fdGFnID0gcHBfb3Blbl90YWcgc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3RhZyA9IHBwX2Nsb3NlX3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9zdGFnID0gcHBfb3Blbl9zdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV9zdGFnID0gcHBfY2xvc2Vfc3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYXMgPSBwcF9wcmludF9hcyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfc3RyaW5nID0gcHBfcHJpbnRfc3RyaW5nIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9ieXRlcyA9IHBwX3ByaW50X2J5dGVzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9pbnQgPSBwcF9wcmludF9pbnQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2Zsb2F0ID0gcHBfcHJpbnRfZmxvYXQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2NoYXIgPSBwcF9wcmludF9jaGFyIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9ib29sID0gcHBfcHJpbnRfYm9vbCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYnJlYWsgPSBwcF9wcmludF9icmVhayBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfY3V0ID0gcHBfcHJpbnRfY3V0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9zcGFjZSA9IHBwX3ByaW50X3NwYWNlIHN0ZF9mb3JtYXR0ZXJcbmFuZCBmb3JjZV9uZXdsaW5lID0gcHBfZm9yY2VfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfZmx1c2ggPSBwcF9wcmludF9mbHVzaCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfbmV3bGluZSA9IHBwX3ByaW50X25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2lmX25ld2xpbmUgPSBwcF9wcmludF9pZl9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIG9wZW5fdGJveCA9IHBwX29wZW5fdGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfdGJveCA9IHBwX2Nsb3NlX3Rib3ggc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3RicmVhayA9IHBwX3ByaW50X3RicmVhayBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfdGFiID0gcHBfc2V0X3RhYiBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfdGFiID0gcHBfcHJpbnRfdGFiIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXJnaW4gPSBwcF9zZXRfbWFyZ2luIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWFyZ2luID0gcHBfZ2V0X21hcmdpbiBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWF4X2luZGVudCA9IHBwX3NldF9tYXhfaW5kZW50IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWF4X2luZGVudCA9IHBwX2dldF9tYXhfaW5kZW50IHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9nZW9tZXRyeSA9IHBwX3NldF9nZW9tZXRyeSBzdGRfZm9ybWF0dGVyXG5hbmQgc2FmZV9zZXRfZ2VvbWV0cnkgPSBwcF9zYWZlX3NldF9nZW9tZXRyeSBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2dlb21ldHJ5ID0gcHBfZ2V0X2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcbmFuZCB1cGRhdGVfZ2VvbWV0cnkgPSBwcF91cGRhdGVfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21heF9ib3hlcyA9IHBwX3NldF9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXhfYm94ZXMgPSBwcF9nZXRfbWF4X2JveGVzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBvdmVyX21heF9ib3hlcyA9IHBwX292ZXJfbWF4X2JveGVzIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9lbGxpcHNpc190ZXh0ID0gcHBfc2V0X2VsbGlwc2lzX3RleHQgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9lbGxpcHNpc190ZXh0ID0gcHBfZ2V0X2VsbGlwc2lzX3RleHQgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfcHJpbnRfdGFncyA9XG4gIHBwX3NldF9wcmludF90YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfcHJpbnRfdGFncyA9XG4gIHBwX2dldF9wcmludF90YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfbWFya190YWdzID1cbiAgcHBfc2V0X21hcmtfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21hcmtfdGFncyA9XG4gIHBwX2dldF9tYXJrX3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF90YWdzID1cbiAgcHBfc2V0X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuXG5cbigqIENvbnZlbmllbmNlIGZ1bmN0aW9ucyAqKVxuXG4oKiBUbyBmb3JtYXQgYSBsaXN0ICopXG5sZXQgcmVjIHBwX3ByaW50X2xpc3QgPyhwcF9zZXAgPSBwcF9wcmludF9jdXQpIHBwX3YgcHBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAoKVxuICB8IFt2XSAtPiBwcF92IHBwZiB2XG4gIHwgdiA6OiB2cyAtPlxuICAgIHBwX3YgcHBmIHY7XG4gICAgcHBfc2VwIHBwZiAoKTtcbiAgICBwcF9wcmludF9saXN0IH5wcF9zZXAgcHBfdiBwcGYgdnNcblxuKCogVG8gZm9ybWF0IGEgc2VxdWVuY2UgKilcbmxldCByZWMgcHBfcHJpbnRfc2VxX2luIH5wcF9zZXAgcHBfdiBwcGYgc2VxID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBTZXEuTmlsIC0+ICgpXG4gIHwgU2VxLkNvbnMgKHYsIHNlcSkgLT5cbiAgICBwcF9zZXAgcHBmICgpO1xuICAgIHBwX3YgcHBmIHY7XG4gICAgcHBfcHJpbnRfc2VxX2luIH5wcF9zZXAgcHBfdiBwcGYgc2VxXG5cbmxldCBwcF9wcmludF9zZXEgPyhwcF9zZXAgPSBwcF9wcmludF9jdXQpIHBwX3YgcHBmIHNlcSA9XG4gIG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgU2VxLk5pbCAtPiAoKVxuICB8IFNlcS5Db25zICh2LCBzZXEpIC0+XG4gICAgcHBfdiBwcGYgdjtcbiAgICBwcF9wcmludF9zZXFfaW4gfnBwX3NlcCBwcF92IHBwZiBzZXFcblxuKCogVG8gZm9ybWF0IGZyZWUtZmxvd2luZyB0ZXh0ICopXG5sZXQgcHBfcHJpbnRfdGV4dCBwcGYgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGxlZnQgPSByZWYgMCBpblxuICBsZXQgcmlnaHQgPSByZWYgMCBpblxuICBsZXQgZmx1c2ggKCkgPVxuICAgIHBwX3ByaW50X3N0cmluZyBwcGYgKFN0cmluZy5zdWIgcyAhbGVmdCAoIXJpZ2h0IC0gIWxlZnQpKTtcbiAgICBpbmNyIHJpZ2h0OyBsZWZ0IDo9ICFyaWdodDtcbiAgaW5cbiAgd2hpbGUgKCFyaWdodCA8PiBsZW4pIGRvXG4gICAgbWF0Y2ggcy5bIXJpZ2h0XSB3aXRoXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgIGZsdXNoICgpO1xuICAgICAgICBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgZmx1c2ggKCk7IHBwX3ByaW50X3NwYWNlIHBwZiAoKVxuICAgICAgKCogdGhlcmUgaXMgbm8gc3BlY2lmaWMgc3VwcG9ydCBmb3IgJ1xcdCdcbiAgICAgICAgIGFzIGl0IGlzIHVuY2xlYXIgd2hhdCBhIHJpZ2h0IHNlbWFudGljcyB3b3VsZCBiZSAqKVxuICAgICAgfCBfIC0+IGluY3IgcmlnaHRcbiAgZG9uZTtcbiAgaWYgIWxlZnQgPD4gbGVuIHRoZW4gZmx1c2ggKClcblxubGV0IHBwX3ByaW50X29wdGlvbiA/KG5vbmUgPSBmdW4gXyAoKSAtPiAoKSkgcHBfdiBwcGYgPSBmdW5jdGlvblxufCBOb25lIC0+IG5vbmUgcHBmICgpXG58IFNvbWUgdiAtPiBwcF92IHBwZiB2XG5cbmxldCBwcF9wcmludF9yZXN1bHQgfm9rIH5lcnJvciBwcGYgPSBmdW5jdGlvblxufCBPayB2IC0+IG9rIHBwZiB2XG58IEVycm9yIGUgLT4gZXJyb3IgcHBmIGVcblxubGV0IHBwX3ByaW50X2VpdGhlciB+bGVmdCB+cmlnaHQgcHBmID0gZnVuY3Rpb25cbnwgRWl0aGVyLkxlZnQgbCAtPiBsZWZ0IHBwZiBsXG58IEVpdGhlci5SaWdodCByIC0+IHJpZ2h0IHBwZiByXG5cbiAoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmxldCBjb21wdXRlX3RhZyBvdXRwdXQgdGFnX2FjYyA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDE2IGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGJ1ZiBpblxuICBvdXRwdXQgcHBmIHRhZ19hY2M7XG4gIHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgbGV0IGxlbiA9IEJ1ZmZlci5sZW5ndGggYnVmIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBCdWZmZXIuY29udGVudHMgYnVmXG4gIGVsc2UgQnVmZmVyLnN1YiBidWYgMSAobGVuIC0gMilcblxuICgqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIERlZmluaW5nIGNvbnRpbnVhdGlvbnMgdG8gYmUgcGFzc2VkIGFzIGFyZ3VtZW50cyBvZlxuICBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuXG5cbiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG4oKiBJbnRlcnByZXQgYSBmb3JtYXR0aW5nIGVudGl0eSBvbiBhIGZvcm1hdHRlci4gKilcbmxldCBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGZtdGluZ19saXQgPSBtYXRjaCBmbXRpbmdfbGl0IHdpdGhcbiAgfCBDbG9zZV9ib3ggICAgICAgICAgICAgICAgIC0+IHBwX2Nsb3NlX2JveCBwcGYgKClcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAgICAgIC0+IHBwX2Nsb3NlX3RhZyBwcGYgKClcbiAgfCBCcmVhayAoXywgd2lkdGgsIG9mZnNldCkgIC0+IHBwX3ByaW50X2JyZWFrIHBwZiB3aWR0aCBvZmZzZXRcbiAgfCBGRmx1c2ggICAgICAgICAgICAgICAgICAgIC0+IHBwX3ByaW50X2ZsdXNoIHBwZiAoKVxuICB8IEZvcmNlX25ld2xpbmUgICAgICAgICAgICAgLT4gcHBfZm9yY2VfbmV3bGluZSBwcGYgKClcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAgICAgIC0+IHBwX3ByaW50X25ld2xpbmUgcHBmICgpXG4gIHwgTWFnaWNfc2l6ZSAoXywgXykgICAgICAgICAtPiAoKVxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJ0AnXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnJSdcbiAgfCBTY2FuX2luZGljIGMgICAgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICdAJzsgcHBfcHJpbnRfY2hhciBwcGYgY1xuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGFuIG91dHB1dF9zdHJlYW0uICopXG4oKiBEaWZmZXIgZnJvbSBQcmludGYub3V0cHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgZm9ybWF0dGluZy4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBvdXRwdXRfYWNjIHBwZiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIChTdHJpbmcubWFrZSAxIGMpO1xuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZikgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZjtcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfb3Blbl9zdGFnIHBwZiAoU3RyaW5nX3RhZyAoY29tcHV0ZV90YWcgb3V0cHV0X2FjYyBhY2MnKSlcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgbGV0IChpbmRlbnQsIGJ0eSkgPSBvcGVuX2JveF9vZl9zdHJpbmcgKGNvbXB1dGVfdGFnIG91dHB1dF9hY2MgYWNjJykgaW5cbiAgICBwcF9vcGVuX2JveF9nZW4gcHBmIGluZGVudCBidHlcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9jaGFyIHBwZiBjO1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBmIHBwZjtcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBvdXRwdXRfYWNjIHBwZiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBEaWZmZXIgZnJvbSBQcmludGYuYnVmcHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgZm9ybWF0dGluZy4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBzdHJwdXRfYWNjIHBwZiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIChTdHJpbmcubWFrZSAxIGMpO1xuICB8IEFjY19kZWxheSAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGYpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKGYgKCkpO1xuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZikgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZjtcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfb3Blbl9zdGFnIHBwZiAoU3RyaW5nX3RhZyAoY29tcHV0ZV90YWcgc3RycHV0X2FjYyBhY2MnKSlcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgbGV0IChpbmRlbnQsIGJ0eSkgPSBvcGVuX2JveF9vZl9zdHJpbmcgKGNvbXB1dGVfdGFnIHN0cnB1dF9hY2MgYWNjJykgaW5cbiAgICBwcF9vcGVuX2JveF9nZW4gcHBmIGluZGVudCBidHlcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9jaGFyIHBwZiBjO1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIChmICgpKTtcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBzdHJwdXRfYWNjIHBwZiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqXG5cbiAgRGVmaW5pbmcgW2ZwcmludGZdIGFuZCB2YXJpb3VzIGZsYXZvcnMgb2YgW2ZwcmludGZdLlxuXG4qKVxuXG5sZXQga2ZwcmludGYgayBwcGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZlxuICAgIChmdW4gYWNjIC0+IG91dHB1dF9hY2MgcHBmIGFjYzsgayBwcGYpXG4gICAgRW5kX29mX2FjYyBmbXRcblxuYW5kIGlrZnByaW50ZiBrIHBwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBrIHBwZiBmbXRcblxubGV0IGlmcHJpbnRmIF9wcGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgaWdub3JlICgpIGZtdFxuXG5sZXQgZnByaW50ZiBwcGYgPSBrZnByaW50ZiBpZ25vcmUgcHBmXG5sZXQgcHJpbnRmIGZtdCA9IGZwcmludGYgc3RkX2Zvcm1hdHRlciBmbXRcbmxldCBlcHJpbnRmIGZtdCA9IGZwcmludGYgZXJyX2Zvcm1hdHRlciBmbXRcblxubGV0IGtkcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZlxuICAgIChmdW4gYWNjIC0+IGsgKGZ1biBwcGYgLT4gb3V0cHV0X2FjYyBwcGYgYWNjKSlcbiAgICBFbmRfb2ZfYWNjIGZtdFxuXG5sZXQgZHByaW50ZiBmbXQgPSBrZHByaW50ZiAoZnVuIGkgLT4gaSkgZm10XG5cbmxldCBrc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGIgPSBwcF9tYWtlX2J1ZmZlciAoKSBpblxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gIGxldCBrIGFjYyA9XG4gICAgc3RycHV0X2FjYyBwcGYgYWNjO1xuICAgIGsgKGZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgYiBwcGYpIGluXG4gIG1ha2VfcHJpbnRmIGsgRW5kX29mX2FjYyBmbXRcblxuXG5sZXQgc3ByaW50ZiBmbXQgPSBrc3ByaW50ZiBpZCBmbXRcblxubGV0IGthc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGIgPSBwcF9tYWtlX2J1ZmZlciAoKSBpblxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gIGxldCBrIGFjYyA9XG4gICAgb3V0cHV0X2FjYyBwcGYgYWNjO1xuICAgIGsgKGZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgYiBwcGYpIGluXG4gIG1ha2VfcHJpbnRmIGsgRW5kX29mX2FjYyBmbXRcblxuXG5sZXQgYXNwcmludGYgZm10ID0ga2FzcHJpbnRmIGlkIGZtdFxuXG4oKiBGbHVzaGluZyBzdGFuZGFyZCBmb3JtYXR0ZXJzIGF0IGVuZCBvZiBleGVjdXRpb24uICopXG5cbmxldCBmbHVzaF9zdGFuZGFyZF9mb3JtYXR0ZXJzICgpID1cbiAgcHBfcHJpbnRfZmx1c2ggc3RkX2Zvcm1hdHRlciAoKTtcbiAgcHBfcHJpbnRfZmx1c2ggZXJyX2Zvcm1hdHRlciAoKVxuXG5sZXQgKCkgPSBhdF9leGl0IGZsdXNoX3N0YW5kYXJkX2Zvcm1hdHRlcnNcblxuKCpcblxuICBEZXByZWNhdGVkIHN0dWZmLlxuXG4qKVxuXG4oKiBEZXByZWNhdGVkIDogc3Vic3VtZWQgYnkgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zICopXG5sZXQgcHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZVxuICAgIH5vdXQ6ZiB+Zmx1c2g6ZyB+bmV3bGluZTpoIH5zcGFjZXM6aSA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSBmIGc7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGg7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gaVxuXG4oKiBEZXByZWNhdGVkIDogc3Vic3VtZWQgYnkgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zICopXG5sZXQgcHBfZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSAoKSA9XG4gIChzdGF0ZS5wcF9vdXRfc3RyaW5nLCBzdGF0ZS5wcF9vdXRfZmx1c2gsXG4gICBzdGF0ZS5wcF9vdXRfbmV3bGluZSwgc3RhdGUucHBfb3V0X3NwYWNlcylcblxuXG4oKiBEZXByZWNhdGVkIDogc3Vic3VtZWQgYnkgc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zICopXG5sZXQgc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBnZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBnZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cblxuKCogRGVwcmVjYXRlZCA6IGVycm9yIHByb25lIGZ1bmN0aW9uLCBkbyBub3QgdXNlIGl0LlxuICAgVGhpcyBmdW5jdGlvbiBpcyBuZWl0aGVyIGNvbXBvc2l0aW9uYWwgbm9yIGluY3JlbWVudGFsLCBzaW5jZSBpdCBmbHVzaGVzXG4gICB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUgYXQgZWFjaCBjYWxsLlxuICAgVG8gZ2V0IHRoZSBzYW1lIGZ1bmN0aW9uYWxpdHksIGRlZmluZSBhIGZvcm1hdHRlciBvZiB5b3VyIG93biB3cml0aW5nIHRvXG4gICB0aGUgYnVmZmVyIGFyZ3VtZW50LCBhcyBpblxuICAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYlxuICAgdGhlbiB1c2UgeyFmcHJpbnRmIHBwZn0gYXMgdXN1YWwuICopXG5sZXQgYnByaW50ZiBiIChGb3JtYXQgKGZtdCwgXykgOiAoJ2EsIGZvcm1hdHRlciwgdW5pdCkgZm9ybWF0KSA9XG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID0gb3V0cHV0X2FjYyBwcGYgYWNjOyBwcF9mbHVzaF9xdWV1ZSBwcGYgZmFsc2UgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbigqIERlcHJlY2F0ZWQgOiBhbGlhcyBmb3Iga3NwcmludGYuICopXG5sZXQga3ByaW50ZiA9IGtzcHJpbnRmXG5cblxuXG4oKiBEZXByZWNhdGVkIHRhZyBmdW5jdGlvbnMgKilcblxudHlwZSBmb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyA9IHtcbiAgbWFya19vcGVuX3RhZyA6IHRhZyAtPiBzdHJpbmc7XG4gIG1hcmtfY2xvc2VfdGFnIDogdGFnIC0+IHN0cmluZztcbiAgcHJpbnRfb3Blbl90YWcgOiB0YWcgLT4gdW5pdDtcbiAgcHJpbnRfY2xvc2VfdGFnIDogdGFnIC0+IHVuaXQ7XG59XG5cblxubGV0IHBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBzdGF0ZSB7XG4gICAgIG1hcmtfb3Blbl90YWcgPSBtb3Q7XG4gICAgIG1hcmtfY2xvc2VfdGFnID0gbWN0O1xuICAgICBwcmludF9vcGVuX3RhZyA9IHBvdDtcbiAgICAgcHJpbnRfY2xvc2VfdGFnID0gcGN0O1xuICAgfSA9XG4gIGxldCBzdHJpbmdpZnkgZiBlID0gZnVuY3Rpb24gU3RyaW5nX3RhZyBzIC0+IGYgcyB8IF8gLT4gZSBpblxuICBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIDwtIHN0cmluZ2lmeSBtb3QgXCJcIjtcbiAgc3RhdGUucHBfbWFya19jbG9zZV90YWcgPC0gc3RyaW5naWZ5IG1jdCBcIlwiO1xuICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyA8LSBzdHJpbmdpZnkgcG90ICgpO1xuICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgPC0gc3RyaW5naWZ5IHBjdCAoKVxuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIGZtdCAoKSA9XG4gIGxldCBmdW5zID0gcHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBmbXQgKCkgaW5cbiAgbGV0IG1hcmtfb3Blbl90YWcgcyA9IGZ1bnMubWFya19vcGVuX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAgbGV0IG1hcmtfY2xvc2VfdGFnIHMgPSBmdW5zLm1hcmtfY2xvc2Vfc3RhZyAoU3RyaW5nX3RhZyBzKSBpblxuICBsZXQgcHJpbnRfb3Blbl90YWcgcyA9IGZ1bnMucHJpbnRfb3Blbl9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIGxldCBwcmludF9jbG9zZV90YWcgcyA9IGZ1bnMucHJpbnRfY2xvc2Vfc3RhZyAoU3RyaW5nX3RhZyBzKSBpblxuICB7bWFya19vcGVuX3RhZzsgbWFya19jbG9zZV90YWc7IHByaW50X29wZW5fdGFnOyBwcmludF9jbG9zZV90YWd9XG5cbmxldCBzZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG4oKiBhbGlhcyB0byBhdm9pZCB3YXJuaW5nIGZvciBhbWJpZ3VpdHkgYmV0d2VlblxuICAgU3RkbGliLmZvcm1hdDZcbiAgIGFuZCBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NlxuXG4gICAodGhlIGZvcm1lciBpcyBpbiBmYWN0IGFuIGFsaWFzIGZvciB0aGUgbGF0dGVyLFxuICAgIGJ1dCB0aGUgYW1iaWd1aXR5IHdhcm5pbmcgZG9lc24ndCBjYXJlKVxuKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPVxuICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgU3RkbGliLmZvcm1hdDZcblxuXG4oKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3Igc2Nhbm5lcnMuICopXG5cbigqIFNjYW5uaW5nIGJ1ZmZlcnMuICopXG5tb2R1bGUgdHlwZSBTQ0FOTklORyA9IHNpZ1xuXG4gIHR5cGUgaW5fY2hhbm5lbFxuXG4gIHR5cGUgc2NhbmJ1ZiA9IGluX2NoYW5uZWxcblxuICB0eXBlIGZpbGVfbmFtZSA9IHN0cmluZ1xuXG4gIHZhbCBzdGRpbiA6IGluX2NoYW5uZWxcbiAgKCogVGhlIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGZyb20gW1N0ZGxpYi5zdGRpbl0uXG4gICAgIFtzdGRpYl0gaXMgZXF1aXZhbGVudCB0byBbU2Nhbm5pbmcuZnJvbV9jaGFubmVsIFN0ZGxpYi5zdGRpbl0uICopXG5cbiAgdmFsIHN0ZGliIDogaW5fY2hhbm5lbFxuICAoKiBBbiBhbGlhcyBmb3IgW1NjYW5mLnN0ZGluXSwgdGhlIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGZyb21cbiAgICAgW1N0ZGxpYi5zdGRpbl0uICopXG5cbiAgdmFsIG5leHRfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBbU2Nhbm5pbmcubmV4dF9jaGFyIGliXSBhZHZhbmNlIHRoZSBzY2FubmluZyBidWZmZXIgZm9yXG4gICAgIG9uZSBjaGFyYWN0ZXIuXG4gICAgIElmIG5vIG1vcmUgY2hhcmFjdGVyIGNhbiBiZSByZWFkLCBzZXRzIGEgZW5kIG9mIGZpbGUgY29uZGl0aW9uIGFuZFxuICAgICByZXR1cm5zICdcXDAwMCcuICopXG5cbiAgdmFsIGludmFsaWRhdGVfY3VycmVudF9jaGFyIDogc2NhbmJ1ZiAtPiB1bml0XG4gICgqIFtTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYl0gbWFyayB0aGUgY3VycmVudF9jaGFyIGFzIGFscmVhZHlcbiAgICAgc2Nhbm5lZC4gKilcblxuICB2YWwgcGVla19jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFtTY2FubmluZy5wZWVrX2NoYXIgaWJdIHJldHVybnMgdGhlIGN1cnJlbnQgY2hhciBhdmFpbGFibGUgaW5cbiAgICAgdGhlIGJ1ZmZlciBvciByZWFkcyBvbmUgaWYgbmVjZXNzYXJ5ICh3aGVuIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpc1xuICAgICBhbHJlYWR5IHNjYW5uZWQpLlxuICAgICBJZiBubyBjaGFyYWN0ZXIgY2FuIGJlIHJlYWQsIHNldHMgYW4gZW5kIG9mIGZpbGUgY29uZGl0aW9uIGFuZFxuICAgICByZXR1cm5zICdcXDAwMCcuICopXG5cbiAgdmFsIGNoZWNrZWRfcGVla19jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFNhbWUgYXMgW1NjYW5uaW5nLnBlZWtfY2hhcl0gYWJvdmUgYnV0IGFsd2F5cyByZXR1cm5zIGEgdmFsaWQgY2hhciBvclxuICAgICBmYWlsczogaW5zdGVhZCBvZiByZXR1cm5pbmcgYSBudWxsIGNoYXIgd2hlbiB0aGUgcmVhZGluZyBtZXRob2Qgb2YgdGhlXG4gICAgIGlucHV0IGJ1ZmZlciBoYXMgcmVhY2hlZCBhbiBlbmQgb2YgZmlsZSwgdGhlIGZ1bmN0aW9uIHJhaXNlcyBleGNlcHRpb25cbiAgICAgW0VuZF9vZl9maWxlXS4gKilcblxuICB2YWwgc3RvcmVfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGNoYXIgLT4gaW50XG4gICgqIFtTY2FubmluZy5zdG9yZV9jaGFyIGxpbSBpYiBjXSBhZGRzIFtjXSB0byB0aGUgdG9rZW4gYnVmZmVyXG4gICAgIG9mIHRoZSBzY2FubmluZyBidWZmZXIgW2liXS4gSXQgYWxzbyBhZHZhbmNlcyB0aGUgc2Nhbm5pbmcgYnVmZmVyIGZvclxuICAgICBvbmUgY2hhcmFjdGVyIGFuZCByZXR1cm5zIFtsaW0gLSAxXSwgaW5kaWNhdGluZyB0aGUgbmV3IGxpbWl0IGZvciB0aGVcbiAgICAgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IHRva2VuLiAqKVxuXG4gIHZhbCBza2lwX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnNraXBfY2hhciBsaW0gaWJdIGlnbm9yZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLiAqKVxuXG4gIHZhbCBpZ25vcmVfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuaWdub3JlX2NoYXIgaWIgbGltXSBpZ25vcmVzIHRoZSBjdXJyZW50IGNoYXJhY3RlciBhbmRcbiAgICAgZGVjcmVtZW50cyB0aGUgbGltaXQuICopXG5cbiAgdmFsIHRva2VuIDogc2NhbmJ1ZiAtPiBzdHJpbmdcbiAgKCogW1NjYW5uaW5nLnRva2VuIGliXSByZXR1cm5zIHRoZSBzdHJpbmcgc3RvcmVkIGludG8gdGhlIHRva2VuXG4gICAgIGJ1ZmZlciBvZiB0aGUgc2Nhbm5pbmcgYnVmZmVyOiBpdCByZXR1cm5zIHRoZSB0b2tlbiBtYXRjaGVkIGJ5IHRoZVxuICAgICBmb3JtYXQuICopXG5cbiAgdmFsIHJlc2V0X3Rva2VuIDogc2NhbmJ1ZiAtPiB1bml0XG4gICgqIFtTY2FubmluZy5yZXNldF90b2tlbiBpYl0gcmVzZXRzIHRoZSB0b2tlbiBidWZmZXIgb2ZcbiAgICAgdGhlIGdpdmVuIHNjYW5uaW5nIGJ1ZmZlci4gKilcblxuICB2YWwgY2hhcl9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5jaGFyX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuICAgICByZWFkIHNvIGZhciBmcm9tIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIGxpbmVfY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcubGluZV9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIG5ldyBsaW5lXG4gICAgIGNoYXJhY3RlcnMgcmVhZCBzbyBmYXIgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCB0b2tlbl9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy50b2tlbl9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIHRva2VucyByZWFkXG4gICAgIHNvIGZhciBmcm9tIFtpYl0uICopXG5cbiAgdmFsIGVvZiA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuZW9mIGliXSByZXR1cm5zIHRoZSBlbmQgb2YgaW5wdXQgY29uZGl0aW9uXG4gICAgIG9mIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIGVuZF9vZl9pbnB1dCA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliXSB0ZXN0cyB0aGUgZW5kIG9mIGlucHV0IGNvbmRpdGlvblxuICAgICBvZiB0aGUgZ2l2ZW4gYnVmZmVyIChpZiBubyBjaGFyIGhhcyBldmVyIGJlZW4gcmVhZCwgYW4gYXR0ZW1wdCB0b1xuICAgICByZWFkIG9uZSBpcyBwZXJmb3JtZWQpLiAqKVxuXG4gIHZhbCBiZWdpbm5pbmdfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmJlZ2lubmluZ19vZl9pbnB1dCBpYl0gdGVzdHMgdGhlIGJlZ2lubmluZyBvZiBpbnB1dFxuICAgICBjb25kaXRpb24gb2YgdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgbmFtZV9vZl9pbnB1dCA6IHNjYW5idWYgLT4gc3RyaW5nXG4gICgqIFtTY2FubmluZy5uYW1lX29mX2lucHV0IGliXSByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjaGFyYWN0ZXJcbiAgICAgc291cmNlIGZvciBpbnB1dCBidWZmZXIgW2liXS4gKilcblxuICB2YWwgb3Blbl9pbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBvcGVuX2luX2JpbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2ZpbGUgOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9maWxlX2JpbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX3N0cmluZyA6IHN0cmluZyAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2Z1bmN0aW9uIDogKHVuaXQgLT4gY2hhcikgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9jaGFubmVsIDogU3RkbGliLmluX2NoYW5uZWwgLT4gaW5fY2hhbm5lbFxuXG4gIHZhbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdFxuXG4gIHZhbCBtZW1vX2Zyb21fY2hhbm5lbCA6IFN0ZGxpYi5pbl9jaGFubmVsIC0+IGluX2NoYW5uZWxcbiAgKCogT2Jzb2xldGUuICopXG5cbmVuZFxuXG5cbm1vZHVsZSBTY2FubmluZyA6IFNDQU5OSU5HID0gc3RydWN0XG5cbiAgKCogVGhlIHJ1bi10aW1lIGxpYnJhcnkgZm9yIHNjYW5mLiAqKVxuXG4gIHR5cGUgZmlsZV9uYW1lID0gc3RyaW5nXG5cbiAgdHlwZSBpbl9jaGFubmVsX25hbWUgPVxuICAgIHwgRnJvbV9jaGFubmVsIG9mIFN0ZGxpYi5pbl9jaGFubmVsXG4gICAgfCBGcm9tX2ZpbGUgb2YgZmlsZV9uYW1lICogU3RkbGliLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZnVuY3Rpb25cbiAgICB8IEZyb21fc3RyaW5nXG5cblxuICB0eXBlIGluX2NoYW5uZWwgPSB7XG4gICAgbXV0YWJsZSBpY19lb2YgOiBib29sO1xuICAgIG11dGFibGUgaWNfY3VycmVudF9jaGFyIDogY2hhcjtcbiAgICBtdXRhYmxlIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA6IGJvb2w7XG4gICAgbXV0YWJsZSBpY19jaGFyX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfbGluZV9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX3Rva2VuX2NvdW50IDogaW50O1xuICAgIGljX2dldF9uZXh0X2NoYXIgOiB1bml0IC0+IGNoYXI7XG4gICAgaWNfdG9rZW5fYnVmZmVyIDogQnVmZmVyLnQ7XG4gICAgaWNfaW5wdXRfbmFtZSA6IGluX2NoYW5uZWxfbmFtZTtcbiAgfVxuXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIGxldCBudWxsX2NoYXIgPSAnXFwwMDAnXG5cbiAgKCogUmVhZHMgYSBuZXcgY2hhcmFjdGVyIGZyb20gaW5wdXQgYnVmZmVyLlxuICAgICBOZXh0X2NoYXIgbmV2ZXIgZmFpbHMsIGV2ZW4gaW4gY2FzZSBvZiBlbmQgb2YgaW5wdXQ6XG4gICAgIGl0IHRoZW4gc2ltcGx5IHNldHMgdGhlIGVuZCBvZiBmaWxlIGNvbmRpdGlvbi4gKilcbiAgbGV0IG5leHRfY2hhciBpYiA9XG4gICAgdHJ5XG4gICAgICBsZXQgYyA9IGliLmljX2dldF9uZXh0X2NoYXIgKCkgaW5cbiAgICAgIGliLmljX2N1cnJlbnRfY2hhciA8LSBjO1xuICAgICAgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIHRydWU7XG4gICAgICBpYi5pY19jaGFyX2NvdW50IDwtIHN1Y2MgaWIuaWNfY2hhcl9jb3VudDtcbiAgICAgIGlmIGMgPSAnXFxuJyB0aGVuIGliLmljX2xpbmVfY291bnQgPC0gc3VjYyBpYi5pY19saW5lX2NvdW50O1xuICAgICAgYyB3aXRoXG4gICAgfCBFbmRfb2ZfZmlsZSAtPlxuICAgICAgbGV0IGMgPSBudWxsX2NoYXIgaW5cbiAgICAgIGliLmljX2N1cnJlbnRfY2hhciA8LSBjO1xuICAgICAgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIGZhbHNlO1xuICAgICAgaWIuaWNfZW9mIDwtIHRydWU7XG4gICAgICBjXG5cblxuICBsZXQgcGVla19jaGFyIGliID1cbiAgICBpZiBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWRcbiAgICB0aGVuIGliLmljX2N1cnJlbnRfY2hhclxuICAgIGVsc2UgbmV4dF9jaGFyIGliXG5cblxuICAoKiBSZXR1cm5zIGEgdmFsaWQgY3VycmVudCBjaGFyIGZvciB0aGUgaW5wdXQgYnVmZmVyLiBJbiBwYXJ0aWN1bGFyXG4gICAgIG5vIGlycmVsZXZhbnQgbnVsbCBjaGFyYWN0ZXIgKGFzIHNldCBieSBbbmV4dF9jaGFyXSBpbiBjYXNlIG9mIGVuZFxuICAgICBvZiBpbnB1dCkgaXMgcmV0dXJuZWQsIHNpbmNlIFtFbmRfb2ZfZmlsZV0gaXMgcmFpc2VkIHdoZW5cbiAgICAgW25leHRfY2hhcl0gc2V0cyB0aGUgZW5kIG9mIGZpbGUgY29uZGl0aW9uIHdoaWxlIHRyeWluZyB0byByZWFkIGFcbiAgICAgbmV3IGNoYXJhY3Rlci4gKilcbiAgbGV0IGNoZWNrZWRfcGVla19jaGFyIGliID1cbiAgICBsZXQgYyA9IHBlZWtfY2hhciBpYiBpblxuICAgIGlmIGliLmljX2VvZiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlO1xuICAgIGNcblxuXG4gIGxldCBlbmRfb2ZfaW5wdXQgaWIgPVxuICAgIGlnbm9yZSAocGVla19jaGFyIGliKTtcbiAgICBpYi5pY19lb2ZcblxuXG4gIGxldCBlb2YgaWIgPSBpYi5pY19lb2ZcblxuICBsZXQgYmVnaW5uaW5nX29mX2lucHV0IGliID0gaWIuaWNfY2hhcl9jb3VudCA9IDBcblxuICBsZXQgbmFtZV9vZl9pbnB1dCBpYiA9XG4gICAgbWF0Y2ggaWIuaWNfaW5wdXRfbmFtZSB3aXRoXG4gICAgfCBGcm9tX2NoYW5uZWwgX2ljIC0+IFwidW5uYW1lZCBTdGRsaWIgaW5wdXQgY2hhbm5lbFwiXG4gICAgfCBGcm9tX2ZpbGUgKGZuYW1lLCBfaWMpIC0+IGZuYW1lXG4gICAgfCBGcm9tX2Z1bmN0aW9uIC0+IFwidW5uYW1lZCBmdW5jdGlvblwiXG4gICAgfCBGcm9tX3N0cmluZyAtPiBcInVubmFtZWQgY2hhcmFjdGVyIHN0cmluZ1wiXG5cblxuICBsZXQgY2hhcl9jb3VudCBpYiA9XG4gICAgaWYgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkXG4gICAgdGhlbiBpYi5pY19jaGFyX2NvdW50IC0gMVxuICAgIGVsc2UgaWIuaWNfY2hhcl9jb3VudFxuXG5cbiAgbGV0IGxpbmVfY291bnQgaWIgPSBpYi5pY19saW5lX2NvdW50XG5cbiAgbGV0IHJlc2V0X3Rva2VuIGliID0gQnVmZmVyLnJlc2V0IGliLmljX3Rva2VuX2J1ZmZlclxuXG4gIGxldCBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiA9IGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSBmYWxzZVxuXG4gIGxldCB0b2tlbiBpYiA9XG4gICAgbGV0IHRva2VuX2J1ZmZlciA9IGliLmljX3Rva2VuX2J1ZmZlciBpblxuICAgIGxldCB0b2sgPSBCdWZmZXIuY29udGVudHMgdG9rZW5fYnVmZmVyIGluXG4gICAgQnVmZmVyLmNsZWFyIHRva2VuX2J1ZmZlcjtcbiAgICBpYi5pY190b2tlbl9jb3VudCA8LSBzdWNjIGliLmljX3Rva2VuX2NvdW50O1xuICAgIHRva1xuXG5cbiAgbGV0IHRva2VuX2NvdW50IGliID0gaWIuaWNfdG9rZW5fY291bnRcblxuICBsZXQgc2tpcF9jaGFyIHdpZHRoIGliID1cbiAgICBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjtcbiAgICB3aWR0aFxuXG5cbiAgbGV0IGlnbm9yZV9jaGFyIHdpZHRoIGliID0gc2tpcF9jaGFyICh3aWR0aCAtIDEpIGliXG5cbiAgbGV0IHN0b3JlX2NoYXIgd2lkdGggaWIgYyA9XG4gICAgQnVmZmVyLmFkZF9jaGFyIGliLmljX3Rva2VuX2J1ZmZlciBjO1xuICAgIGlnbm9yZV9jaGFyIHdpZHRoIGliXG5cblxuICBsZXQgZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZSA9IDEwMjRcblxuICBsZXQgY3JlYXRlIGluYW1lIG5leHQgPSB7XG4gICAgaWNfZW9mID0gZmFsc2U7XG4gICAgaWNfY3VycmVudF9jaGFyID0gbnVsbF9jaGFyO1xuICAgIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA9IGZhbHNlO1xuICAgIGljX2NoYXJfY291bnQgPSAwO1xuICAgIGljX2xpbmVfY291bnQgPSAwO1xuICAgIGljX3Rva2VuX2NvdW50ID0gMDtcbiAgICBpY19nZXRfbmV4dF9jaGFyID0gbmV4dDtcbiAgICBpY190b2tlbl9idWZmZXIgPSBCdWZmZXIuY3JlYXRlIGRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemU7XG4gICAgaWNfaW5wdXRfbmFtZSA9IGluYW1lO1xuICB9XG5cblxuICBsZXQgZnJvbV9zdHJpbmcgcyA9XG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA+PSBsZW4gdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlXG4gICAgICBsZXQgYyA9IHMuWyFpXSBpblxuICAgICAgaW5jciBpO1xuICAgICAgYyBpblxuICAgIGNyZWF0ZSBGcm9tX3N0cmluZyBuZXh0XG5cblxuICBsZXQgZnJvbV9mdW5jdGlvbiA9IGNyZWF0ZSBGcm9tX2Z1bmN0aW9uXG5cbiAgKCogU2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsLiAqKVxuXG4gICgqIFBvc2l0aW9uIG9mIHRoZSBwcm9ibGVtOlxuXG4gICAgIFdlIGNhbm5vdCBwcmV2ZW50IHRoZSBzY2FubmluZyBtZWNoYW5pc20gdG8gdXNlIG9uZSBsb29rYWhlYWQgY2hhcmFjdGVyLFxuICAgICBpZiBuZWVkZWQgYnkgdGhlIHNlbWFudGljcyBvZiB0aGUgZm9ybWF0IHN0cmluZyBzcGVjaWZpY2F0aW9ucyAoZS5nLiBhXG4gICAgIHRyYWlsaW5nICdza2lwIHNwYWNlJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBmb3JtYXQgc3RyaW5nKTsgaW4gdGhpcyBjYXNlLFxuICAgICB0aGUgbWFuZGF0b3J5IGxvb2thaGVhZCBjaGFyYWN0ZXIgaXMgaW5kZWVkIHJlYWQgZnJvbSB0aGUgaW5wdXQgYW5kIG5vdFxuICAgICB1c2VkIHRvIHJldHVybiB0aGUgdG9rZW4gcmVhZC4gSXQgaXMgdGh1cyBtYW5kYXRvcnkgdG8gYmUgYWJsZSB0byBzdG9yZVxuICAgICBhbiB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBzb21ld2hlcmUgdG8gZ2V0IGl0IGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgb2YgdGhlIG5leHQgc2Nhbi5cblxuICAgICBUbyBjaXJjdW12ZW50IHRoaXMgcHJvYmxlbSwgYWxsIHRoZSBzY2FubmluZyBmdW5jdGlvbnMgZ2V0IGEgbG93IGxldmVsXG4gICAgIGlucHV0IGJ1ZmZlciBhcmd1bWVudCB3aGVyZSB0aGV5IHN0b3JlIHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyIHdoZW5cbiAgICAgbmVlZGVkOyBhZGRpdGlvbmFsbHksIHRoZSBpbnB1dCBidWZmZXIgaXMgdGhlIG9ubHkgc291cmNlIG9mIGNoYXJhY3RlciBvZlxuICAgICBhIHNjYW5uZXIuIFRoZSBbc2NhbmJ1Zl0gaW5wdXQgYnVmZmVycyBhcmUgZGVmaW5lZCBpbiBtb2R1bGUgeyFTY2FubmluZ30uXG5cbiAgICAgTm93IHdlIHVuZGVyc3RhbmQgdGhhdCBpdCBpcyBleHRyZW1lbHkgaW1wb3J0YW50IHRoYXQgcmVsYXRlZCBhbmRcbiAgICAgc3VjY2Vzc2l2ZSBjYWxscyB0byBzY2FubmVycyBpbmRlZWQgcmVhZCBmcm9tIHRoZSBzYW1lIGlucHV0IGJ1ZmZlci5cbiAgICAgSW4gZWZmZWN0LCBpZiBhIHNjYW5uZXIgW3NjYW4xXSBpcyByZWFkaW5nIGZyb20gW2liMV0gYW5kIHN0b3JlcyBhblxuICAgICB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBbYzFdIGludG8gaXRzIGlucHV0IGJ1ZmZlciBbaWIxXSwgdGhlblxuICAgICBhbm90aGVyIHNjYW5uZXIgW3NjYW4yXSBub3QgcmVhZGluZyBmcm9tIHRoZSBzYW1lIGJ1ZmZlciBbaWIxXSB3aWxsIG1pc3NcbiAgICAgdGhlIGNoYXJhY3RlciBbYzFdLCBzZWVtaW5nbHkgdmFuaXNoZWQgaW4gdGhlIGFpciBmcm9tIHRoZSBwb2ludCBvZiB2aWV3XG4gICAgIG9mIFtzY2FuMl0uXG5cbiAgICAgVGhpcyBtZWNoYW5pc20gd29ya3MgcGVyZmVjdGx5IHRvIHJlYWQgZnJvbSBzdHJpbmdzLCBmcm9tIGZpbGVzLCBhbmQgZnJvbVxuICAgICBmdW5jdGlvbnMsIHNpbmNlIGluIHRob3NlIGNhc2VzLCBhbGxvY2F0aW5nIHR3byBidWZmZXJzIHJlYWRpbmcgZnJvbSB0aGVcbiAgICAgc2FtZSBzb3VyY2UgaXMgdW5uYXR1cmFsLlxuXG4gICAgIFN0aWxsLCB0aGVyZSBpcyBhIGRpZmZpY3VsdHkgaW4gdGhlIGNhc2Ugb2Ygc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dFxuICAgICBjaGFubmVsLiBJbiBlZmZlY3QsIHdoZW4gc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsIFtpY10sIHRoaXMgY2hhbm5lbFxuICAgICBtYXkgbm90IGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB3aXRoaW4gdGhpcyBsaWJyYXJ5LiBIZW5jZSwgaXQgbWF5IGJlXG4gICAgIHNoYXJlZCAodHdvIGZ1bmN0aW9ucyBvZiB0aGUgdXNlcidzIHByb2dyYW0gbWF5IHN1Y2Nlc3NpdmVseSByZWFkIGZyb21cbiAgICAgW2ljXSkuIFRoaXMgaXMgaGlnaGx5IGVycm9yIHByb25lIHNpbmNlLCBvbmUgb2YgdGhlIGZ1bmN0aW9uIG1heSBzZWVrIHRoZVxuICAgICBpbnB1dCBjaGFubmVsLCB3aGlsZSB0aGUgb3RoZXIgZnVuY3Rpb24gaGFzIHN0aWxsIGFuIHVudXNlZCBsb29rYWhlYWRcbiAgICAgY2hhcmFjdGVyIGluIGl0cyBpbnB1dCBidWZmZXIuIEluIGNvbmNsdXNpb24sIHlvdSBzaG91bGQgbmV2ZXIgbWl4IGRpcmVjdFxuICAgICBsb3cgbGV2ZWwgcmVhZGluZyBhbmQgaGlnaCBsZXZlbCBzY2FubmluZyBmcm9tIHRoZSBzYW1lIGlucHV0IGNoYW5uZWwuXG5cbiAgKilcblxuICAoKiBQZXJmb3JtIGJ1ZmZlcml6ZWQgaW5wdXQgdG8gaW1wcm92ZSBlZmZpY2llbmN5LiAqKVxuICBsZXQgZmlsZV9idWZmZXJfc2l6ZSA9IHJlZiAxMDI0XG5cbiAgKCogVGhlIHNjYW5uZXIgY2xvc2VzIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dC4gKilcbiAgbGV0IHNjYW5fY2xvc2VfYXRfZW5kIGljID0gU3RkbGliLmNsb3NlX2luIGljOyByYWlzZSBFbmRfb2ZfZmlsZVxuXG4gICgqIFRoZSBzY2FubmVyIGRvZXMgbm90IGNsb3NlIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dDpcbiAgICAgaXQganVzdCByYWlzZXMgW0VuZF9vZl9maWxlXS4gKilcbiAgbGV0IHNjYW5fcmFpc2VfYXRfZW5kIF9pYyA9IHJhaXNlIEVuZF9vZl9maWxlXG5cbiAgbGV0IGZyb21faWMgc2Nhbl9jbG9zZV9pYyBpbmFtZSBpYyA9XG4gICAgbGV0IGxlbiA9ICFmaWxlX2J1ZmZlcl9zaXplIGluXG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGxpbSA9IHJlZiAwIGluXG4gICAgbGV0IGVvZiA9IHJlZiBmYWxzZSBpblxuICAgIGxldCBuZXh0ICgpID1cbiAgICAgIGlmICFpIDwgIWxpbSB0aGVuIGJlZ2luIGxldCBjID0gQnl0ZXMuZ2V0IGJ1ZiAhaSBpbiBpbmNyIGk7IGMgZW5kIGVsc2VcbiAgICAgIGlmICFlb2YgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlIGJlZ2luXG4gICAgICAgIGxpbSA6PSBpbnB1dCBpYyBidWYgMCBsZW47XG4gICAgICAgIGlmICFsaW0gPSAwIHRoZW4gYmVnaW4gZW9mIDo9IHRydWU7IHNjYW5fY2xvc2VfaWMgaWMgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICBpIDo9IDE7XG4gICAgICAgICAgQnl0ZXMuZ2V0IGJ1ZiAwXG4gICAgICAgIGVuZFxuICAgICAgZW5kIGluXG4gICAgY3JlYXRlIGluYW1lIG5leHRcblxuXG4gIGxldCBmcm9tX2ljX2Nsb3NlX2F0X2VuZCA9IGZyb21faWMgc2Nhbl9jbG9zZV9hdF9lbmRcbiAgbGV0IGZyb21faWNfcmFpc2VfYXRfZW5kID0gZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuXG4gICgqIFRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLlxuICAgICBPbmUgY291bGQgdHJ5IHRvIGRlZmluZSBbc3RkaWJdIGFzIGEgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgYSBjaGFyYWN0ZXJcbiAgICAgYXQgYSB0aW1lIChubyBidWZmZXJpemF0aW9uIGF0IGFsbCksIGJ1dCB1bmZvcnR1bmF0ZWx5IHRoZSB0b3AtbGV2ZWxcbiAgICAgaW50ZXJhY3Rpb24gd291bGQgYmUgd3JvbmcuIFRoaXMgaXMgZHVlIHRvIHNvbWUga2luZCBvZlxuICAgICAncmFjZSBjb25kaXRpb24nIHdoZW4gcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLFxuICAgICBzaW5jZSB0aGUgaW50ZXJhY3RpdmUgY29tcGlsZXIgYW5kIFtTY2FuZi5zY2FuZl0gd2lsbCBzaW11bHRhbmVvdXNseVxuICAgICByZWFkIHRoZSBtYXRlcmlhbCB0aGV5IG5lZWQgZnJvbSBbU3RkbGliLnN0ZGluXTsgdGhlbiwgY29uZnVzaW9uXG4gICAgIHdpbGwgcmVzdWx0IGZyb20gd2hhdCBzaG91bGQgYmUgcmVhZCBieSB0aGUgdG9wLWxldmVsIGFuZCB3aGF0IHNob3VsZCBiZVxuICAgICByZWFkIGJ5IFtTY2FuZi5zY2FuZl0uXG4gICAgIFRoaXMgaXMgZXZlbiBtb3JlIGNvbXBsaWNhdGVkIGJ5IHRoZSBvbmUgY2hhcmFjdGVyIGxvb2thaGVhZCB0aGF0XG4gICAgIFtTY2FuZi5zY2FuZl0gaXMgc29tZXRpbWVzIG9ibGlnZWQgdG8gbWFpbnRhaW46IHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyXG4gICAgIHdpbGwgYmUgYXZhaWxhYmxlIGZvciB0aGUgbmV4dCBbU2NhbmYuc2NhbmZdIGVudHJ5LCBzZWVtaW5nbHkgY29taW5nIGZyb21cbiAgICAgbm93aGVyZS5cbiAgICAgQWxzbyBubyBbRW5kX29mX2ZpbGVdIGlzIHJhaXNlZCB3aGVuIHJlYWRpbmcgZnJvbSBzdGRpbjogaWYgbm90IGVub3VnaFxuICAgICBjaGFyYWN0ZXJzIGhhdmUgYmVlbiByZWFkLCB3ZSBzaW1wbHkgYXNrIHRvIHJlYWQgbW9yZS4gKilcbiAgbGV0IHN0ZGluID1cbiAgICBmcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG4gICAgICAoRnJvbV9maWxlIChcIi1cIiwgU3RkbGliLnN0ZGluKSkgU3RkbGliLnN0ZGluXG5cblxuICBsZXQgc3RkaWIgPSBzdGRpblxuXG4gIGxldCBvcGVuX2luX2ZpbGUgb3Blbl9pbiBmbmFtZSA9XG4gICAgbWF0Y2ggZm5hbWUgd2l0aFxuICAgIHwgXCItXCIgLT4gc3RkaW5cbiAgICB8IGZuYW1lIC0+XG4gICAgICBsZXQgaWMgPSBvcGVuX2luIGZuYW1lIGluXG4gICAgICBmcm9tX2ljX2Nsb3NlX2F0X2VuZCAoRnJvbV9maWxlIChmbmFtZSwgaWMpKSBpY1xuXG5cbiAgbGV0IG9wZW5faW4gPSBvcGVuX2luX2ZpbGUgU3RkbGliLm9wZW5faW5cbiAgbGV0IG9wZW5faW5fYmluID0gb3Blbl9pbl9maWxlIFN0ZGxpYi5vcGVuX2luX2JpblxuXG4gIGxldCBmcm9tX2ZpbGUgPSBvcGVuX2luXG4gIGxldCBmcm9tX2ZpbGVfYmluID0gb3Blbl9pbl9iaW5cblxuICBsZXQgZnJvbV9jaGFubmVsIGljID1cbiAgICBmcm9tX2ljX3JhaXNlX2F0X2VuZCAoRnJvbV9jaGFubmVsIGljKSBpY1xuXG5cbiAgbGV0IGNsb3NlX2luIGliID1cbiAgICBtYXRjaCBpYi5pY19pbnB1dF9uYW1lIHdpdGhcbiAgICB8IEZyb21fY2hhbm5lbCBpYyAtPlxuICAgICAgU3RkbGliLmNsb3NlX2luIGljXG4gICAgfCBGcm9tX2ZpbGUgKF9mbmFtZSwgaWMpIC0+IFN0ZGxpYi5jbG9zZV9pbiBpY1xuICAgIHwgRnJvbV9mdW5jdGlvbiB8IEZyb21fc3RyaW5nIC0+ICgpXG5cblxuICAoKlxuICAgICBPYnNvbGV0ZTogYSBtZW1vIFtmcm9tX2NoYW5uZWxdIHZlcnNpb24gdG8gYnVpbGQgYSBbU2Nhbm5pbmcuaW5fY2hhbm5lbF1cbiAgICAgc2Nhbm5pbmcgYnVmZmVyIG91dCBvZiBhIFtTdGRsaWIuaW5fY2hhbm5lbF0uXG4gICAgIFRoaXMgZnVuY3Rpb24gd2FzIHVzZWQgdG8gdHJ5IHRvIHByZXNlcnZlIHRoZSBzY2FubmluZ1xuICAgICBzZW1hbnRpY3MgZm9yIHRoZSAobm93IG9ic29sZXRlKSBmdW5jdGlvbiBbZnNjYW5mXS5cbiAgICAgR2l2ZW4gdGhhdCBhbGwgc2Nhbm5lciBtdXN0IHJlYWQgZnJvbSBhIFtTY2FubmluZy5pbl9jaGFubmVsXSBzY2FubmluZ1xuICAgICBidWZmZXIsIFtmc2NhbmZdIG11c3QgcmVhZCBmcm9tIG9uZSFcbiAgICAgTW9yZSBwcmVjaXNlbHksIGdpdmVuIFtpY10sIGFsbCBzdWNjZXNzaXZlIGNhbGxzIFtmc2NhbmYgaWNdIG11c3QgcmVhZFxuICAgICBmcm9tIHRoZSBzYW1lIHNjYW5uaW5nIGJ1ZmZlci5cbiAgICAgVGhpcyBvYmxpZ2VkIHRoaXMgbGlicmFyeSB0byBhbGxvY2F0ZWQgc2Nhbm5pbmcgYnVmZmVycyB0aGF0IHdlcmVcbiAgICAgbm90IHByb3Blcmx5IGdhcmJhZ2UgY29sbGVjdGFibGUsIGhlbmNlIGxlYWRpbmcgdG8gbWVtb3J5IGxlYWtzLlxuICAgICBJZiB5b3UgbmVlZCB0byByZWFkIGZyb20gYSBbU3RkbGliLmluX2NoYW5uZWxdIGlucHV0IGNoYW5uZWxcbiAgICAgW2ljXSwgc2ltcGx5IGRlZmluZSBhIFtTY2FubmluZy5pbl9jaGFubmVsXSBmb3JtYXR0ZWQgaW5wdXQgY2hhbm5lbCBhcyBpblxuICAgICBbbGV0IGliID0gU2Nhbm5pbmcuZnJvbV9jaGFubmVsIGljXSwgdGhlbiB1c2UgW1NjYW5mLmJzY2FuZiBpYl0gYXMgdXN1YWwuXG4gICopXG4gIGxldCBtZW1vX2Zyb21faWMgPVxuICAgIGxldCBtZW1vID0gcmVmIFtdIGluXG4gICAgKGZ1biBzY2FuX2Nsb3NlX2ljIGljIC0+XG4gICAgIHRyeSBMaXN0LmFzc3EgaWMgIW1lbW8gd2l0aFxuICAgICB8IE5vdF9mb3VuZCAtPlxuICAgICAgIGxldCBpYiA9XG4gICAgICAgICBmcm9tX2ljIHNjYW5fY2xvc2VfaWMgKEZyb21fY2hhbm5lbCBpYykgaWMgaW5cbiAgICAgICBtZW1vIDo9IChpYywgaWIpIDo6ICFtZW1vO1xuICAgICAgIGliKVxuXG5cbiAgKCogT2Jzb2xldGU6IHNlZSB7IW1lbW9fZnJvbV9pY30gYWJvdmUuICopXG4gIGxldCBtZW1vX2Zyb21fY2hhbm5lbCA9IG1lbW9fZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuXG5lbmRcblxuXG4oKiBGb3JtYXR0ZWQgaW5wdXQgZnVuY3Rpb25zLiAqKVxuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgc2Nhbm5lciA9XG4gICAgICgnYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgJ2IsICdjLCAnYSAtPiAnZCwgJ2QpIGZvcm1hdDYgLT4gJ2NcblxuXG4oKiBSZXBvcnRpbmcgZXJyb3JzLiAqKVxuZXhjZXB0aW9uIFNjYW5fZmFpbHVyZSBvZiBzdHJpbmdcblxubGV0IGJhZF9pbnB1dCBzID0gcmFpc2UgKFNjYW5fZmFpbHVyZSBzKVxuXG5sZXQgYmFkX2lucHV0X2VzY2FwZSBjID1cbiAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImlsbGVnYWwgZXNjYXBlIGNoYXJhY3RlciAlQ1wiIGMpXG5cblxubGV0IGJhZF90b2tlbl9sZW5ndGggbWVzc2FnZSA9XG4gIGJhZF9pbnB1dFxuICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgIFwic2Nhbm5pbmcgb2YgJXMgZmFpbGVkOiBcXFxuICAgICAgICB0aGUgc3BlY2lmaWVkIGxlbmd0aCB3YXMgdG9vIHNob3J0IGZvciB0b2tlblwiXG4gICAgICAgbWVzc2FnZSlcblxuXG5sZXQgYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlID1cbiAgYmFkX2lucHV0XG4gICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgXCJzY2FubmluZyBvZiAlcyBmYWlsZWQ6IFxcXG4gICAgICAgIHByZW1hdHVyZSBlbmQgb2YgZmlsZSBvY2N1cnJlZCBiZWZvcmUgZW5kIG9mIHRva2VuXCJcbiAgICAgICBtZXNzYWdlKVxuXG5cbmxldCBiYWRfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJubyBkb3Qgb3IgZXhwb25lbnQgcGFydCBmb3VuZCBpbiBmbG9hdCB0b2tlblwiXG5cblxubGV0IGJhZF9oZXhfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJub3QgYSB2YWxpZCBmbG9hdCBpbiBoZXhhZGVjaW1hbCBub3RhdGlvblwiXG5cblxubGV0IGNoYXJhY3Rlcl9taXNtYXRjaF9lcnIgYyBjaSA9XG4gIFByaW50Zi5zcHJpbnRmIFwibG9va2luZyBmb3IgJUMsIGZvdW5kICVDXCIgYyBjaVxuXG5cbmxldCBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaSA9XG4gIGJhZF9pbnB1dCAoY2hhcmFjdGVyX21pc21hdGNoX2VyciBjIGNpKVxuXG5cbmxldCByZWMgc2tpcF93aGl0ZXMgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlbiBiZWdpblxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+XG4gICAgICBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjsgc2tpcF93aGl0ZXMgaWJcbiAgICB8IF8gLT4gKClcbiAgZW5kXG5cblxuKCogQ2hlY2tpbmcgdGhhdCBbY10gaXMgaW5kZWVkIGluIHRoZSBpbnB1dCwgdGhlbiBza2lwcyBpdC5cbiAgIEluIHRoaXMgY2FzZSwgdGhlIGNoYXJhY3RlciBbY10gaGFzIGJlZW4gZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gdGhlXG4gICBmb3JtYXQgYXMgYmVpbmcgbWFuZGF0b3J5IGluIHRoZSBpbnB1dDsgaGVuY2Ugd2Ugc2hvdWxkIGZhaWwgd2l0aFxuICAgW0VuZF9vZl9maWxlXSBpbiBjYXNlIG9mIGVuZF9vZl9pbnB1dC5cbiAgIChSZW1lbWJlciB0aGF0IFtTY2FuX2ZhaWx1cmVdIGlzIHJhaXNlZCBvbmx5IHdoZW4gKHdlIGNhbiBwcm92ZSBieVxuICAgZXZpZGVuY2UpIHRoYXQgdGhlIGlucHV0IGRvZXMgbm90IG1hdGNoIHRoZSBmb3JtYXQgc3RyaW5nIGdpdmVuLiBXZSBtdXN0XG4gICB0aHVzIGRpZmZlcmVudGlhdGUgW0VuZF9vZl9maWxlXSBhcyBhbiBlcnJvciBkdWUgdG8gbGFjayBvZiBpbnB1dCwgYW5kXG4gICBbU2Nhbl9mYWlsdXJlXSB3aGljaCBpcyBkdWUgdG8gcHJvdmFibHkgd3JvbmcgaW5wdXQuIEkgYW0gbm90IHN1cmUgdGhpcyBpc1xuICAgd29ydGggdGhlIGJ1cmRlbjogaXQgaXMgY29tcGxleCBhbmQgc29tZWhvdyBzdWJsaW1pbmFsOyBzaG91bGQgYmUgY2xlYXJlclxuICAgdG8gZmFpbCB3aXRoIFNjYW5fZmFpbHVyZSBcIk5vdCBlbm91Z2ggaW5wdXQgdG8gY29tcGxldGUgc2Nhbm5pbmdcIiEpXG5cbiAgIFRoYXQncyB3aHksIHdhaXRpbmcgZm9yIGEgYmV0dGVyIHNvbHV0aW9uLCB3ZSB1c2UgY2hlY2tlZF9wZWVrX2NoYXIgaGVyZS5cbiAgIFdlIGFyZSBhbHNvIGNhcmVmdWwgdG8gdHJlYXQgXCJcXHJcXG5cIiBpbiB0aGUgaW5wdXQgYXMgYW4gZW5kIG9mIGxpbmUgbWFya2VyOlxuICAgaXQgYWx3YXlzIG1hdGNoZXMgYSAnXFxuJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBpbnB1dCBmb3JtYXQgc3RyaW5nLiAqKVxubGV0IHJlYyBjaGVja19jaGFyIGliIGMgPVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnICcgLT4gc2tpcF93aGl0ZXMgaWJcbiAgfCAnXFxuJyAtPiBjaGVja19uZXdsaW5lIGliXG4gIHwgYyAtPiBjaGVja190aGlzX2NoYXIgaWIgY1xuXG5hbmQgY2hlY2tfdGhpc19jaGFyIGliIGMgPVxuICBsZXQgY2kgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBpZiBjaSA9IGMgdGhlbiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiBlbHNlXG4gIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cbmFuZCBjaGVja19uZXdsaW5lIGliID1cbiAgbGV0IGNpID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggY2kgd2l0aFxuICB8ICdcXG4nIC0+IFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gIHwgJ1xccicgLT4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7IGNoZWNrX3RoaXNfY2hhciBpYiAnXFxuJ1xuICB8IF8gLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXG4nIGNpXG5cblxuKCogRXh0cmFjdGluZyB0b2tlbnMgZnJvbSB0aGUgb3V0cHV0IHRva2VuIGJ1ZmZlci4gKilcblxubGV0IHRva2VuX2NoYXIgaWIgPSAoU2Nhbm5pbmcudG9rZW4gaWIpLlswXVxuXG5sZXQgdG9rZW5fc3RyaW5nID0gU2Nhbm5pbmcudG9rZW5cblxubGV0IHRva2VuX2Jvb2wgaWIgPVxuICBtYXRjaCBTY2FubmluZy50b2tlbiBpYiB3aXRoXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IHMgLT4gYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImludmFsaWQgYm9vbGVhbiAnJXMnXCIgcylcblxuXG4oKiBUaGUgdHlwZSBvZiBpbnRlZ2VyIGNvbnZlcnNpb25zLiAqKVxudHlwZSBpbnRlZ2VyX2NvbnZlcnNpb24gPVxuICB8IEJfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBiaW5hcnkgY29udmVyc2lvbiAqKVxuICB8IERfY29udmVyc2lvbiAoKiBTaWduZWQgZGVjaW1hbCBjb252ZXJzaW9uICopXG4gIHwgSV9jb252ZXJzaW9uICgqIFNpZ25lZCBpbnRlZ2VyIGNvbnZlcnNpb24gKilcbiAgfCBPX2NvbnZlcnNpb24gKCogVW5zaWduZWQgb2N0YWwgY29udmVyc2lvbiAqKVxuICB8IFVfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBkZWNpbWFsIGNvbnZlcnNpb24gKilcbiAgfCBYX2NvbnZlcnNpb24gKCogVW5zaWduZWQgaGV4YWRlY2ltYWwgY29udmVyc2lvbiAqKVxuXG5cbmxldCBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciA9IGZ1bmN0aW9uXG4gIHwgJ2InIC0+IEJfY29udmVyc2lvblxuICB8ICdkJyAtPiBEX2NvbnZlcnNpb25cbiAgfCAnaScgLT4gSV9jb252ZXJzaW9uXG4gIHwgJ28nIC0+IE9fY29udmVyc2lvblxuICB8ICd1JyAtPiBVX2NvbnZlcnNpb25cbiAgfCAneCcgfCAnWCcgLT4gWF9jb252ZXJzaW9uXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuXG4oKiBFeHRyYWN0IGFuIGludGVnZXIgbGl0ZXJhbCB0b2tlbi5cbiAgIFNpbmNlIHRoZSBmdW5jdGlvbnMgU3RkbGliLippbnQqX29mX3N0cmluZyBkbyBub3QgYWNjZXB0IGEgbGVhZGluZyArLFxuICAgd2Ugc2tpcCBpdCBpZiBuZWNlc3NhcnkuICopXG5sZXQgdG9rZW5faW50X2xpdGVyYWwgY29udiBpYiA9XG4gIGxldCB0b2sgPVxuICAgIG1hdGNoIGNvbnYgd2l0aFxuICAgIHwgRF9jb252ZXJzaW9uIHwgSV9jb252ZXJzaW9uIC0+IFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBVX2NvbnZlcnNpb24gLT4gXCIwdVwiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IE9fY29udmVyc2lvbiAtPiBcIjBvXCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgWF9jb252ZXJzaW9uIC0+IFwiMHhcIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBCX2NvbnZlcnNpb24gLT4gXCIwYlwiIF4gU2Nhbm5pbmcudG9rZW4gaWIgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHRvayBpblxuICBpZiBsID0gMCB8fCB0b2suWzBdIDw+ICcrJyB0aGVuIHRvayBlbHNlIFN0cmluZy5zdWIgdG9rIDEgKGwgLSAxKVxuXG5cbigqIEFsbCB0aGUgZnVuY3Rpb25zIHRoYXQgY29udmVydCBhIHN0cmluZyB0byBhIG51bWJlciByYWlzZSB0aGUgZXhjZXB0aW9uXG4gICBGYWlsdXJlIHdoZW4gdGhlIGNvbnZlcnNpb24gaXMgbm90IHBvc3NpYmxlLlxuICAgVGhpcyBleGNlcHRpb24gaXMgdGhlbiB0cmFwcGVkIGluIFtrc2NhbmZdLiAqKVxubGV0IHRva2VuX2ludCBjb252IGliID0gaW50X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcblxubGV0IHRva2VuX2Zsb2F0IGliID0gZmxvYXRfb2Zfc3RyaW5nIChTY2FubmluZy50b2tlbiBpYilcblxuKCogVG8gc2NhbiBuYXRpdmUgaW50cywgaW50MzIgYW5kIGludDY0IGludGVnZXJzLlxuICAgV2UgY2Fubm90IGFjY2VzcyB0byBjb252ZXJzaW9ucyB0by9mcm9tIHN0cmluZ3MgZm9yIHRob3NlIHR5cGVzLFxuICAgTmF0aXZlaW50Lm9mX3N0cmluZywgSW50MzIub2Zfc3RyaW5nLCBhbmQgSW50NjQub2Zfc3RyaW5nLFxuICAgc2luY2UgdGhvc2UgbW9kdWxlcyBhcmUgbm90IGF2YWlsYWJsZSB0byBbU2NhbmZdLlxuICAgSG93ZXZlciwgd2UgY2FuIGJpbmQgYW5kIHVzZSB0aGUgY29ycmVzcG9uZGluZyBwcmltaXRpdmVzIHRoYXQgYXJlXG4gICBhdmFpbGFibGUgaW4gdGhlIHJ1bnRpbWUuICopXG5leHRlcm5hbCBuYXRpdmVpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IG5hdGl2ZWludFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgaW50MzJfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIGludDY0X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9vZl9zdHJpbmdcIlxuXG5cbmxldCB0b2tlbl9uYXRpdmVpbnQgY29udiBpYiA9IG5hdGl2ZWludF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5sZXQgdG9rZW5faW50MzIgY29udiBpYiA9IGludDMyX29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcbmxldCB0b2tlbl9pbnQ2NCBjb252IGliID0gaW50NjRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxuXG4oKiBTY2FubmluZyBudW1iZXJzLiAqKVxuXG4oKiBEaWdpdHMgc2Nhbm5pbmcgZnVuY3Rpb25zIHN1cHBvc2UgdGhhdCBvbmUgY2hhcmFjdGVyIGhhcyBiZWVuIGNoZWNrZWQgYW5kXG4gICBpcyBhdmFpbGFibGUsIHNpbmNlIHRoZXkgcmV0dXJuIGF0IGVuZCBvZiBmaWxlIHdpdGggdGhlIGN1cnJlbnRseSBmb3VuZFxuICAgdG9rZW4gc2VsZWN0ZWQuXG5cbiAgIFB1dCBpdCBpbiBhbm90aGVyIHdheSwgdGhlIGRpZ2l0cyBzY2FubmluZyBmdW5jdGlvbnMgc2NhbiBmb3IgYSBwb3NzaWJseVxuICAgZW1wdHkgc2VxdWVuY2Ugb2YgZGlnaXRzLCAoaGVuY2UsIGEgc3VjY2Vzc2Z1bCBzY2FubmluZyBmcm9tIG9uZSBvZiB0aG9zZVxuICAgZnVuY3Rpb25zIGRvZXMgbm90IGltcGx5IHRoYXQgdGhlIHRva2VuIGlzIGEgd2VsbC1mb3JtZWQgbnVtYmVyOiB0byBnZXQgYVxuICAgdHJ1ZSBudW1iZXIsIGl0IGlzIG1hbmRhdG9yeSB0byBjaGVjayB0aGF0IGF0IGxlYXN0IG9uZSB2YWxpZCBkaWdpdCBpc1xuICAgYXZhaWxhYmxlIGJlZm9yZSBjYWxsaW5nIG9uZSBvZiB0aGUgZGlnaXQgc2Nhbm5pbmcgZnVuY3Rpb25zKS4gKilcblxuKCogVGhlIGRlY2ltYWwgY2FzZSBpcyB0cmVhdGVkIGVzcGVjaWFsbHkgZm9yIG9wdGltaXphdGlvbiBwdXJwb3Nlcy4gKilcbmxldCByZWMgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCAnXycgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYiBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbmxldCBzY2FuX2RlY2ltYWxfZGlnaXRfcGx1cyB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJkZWNpbWFsIGRpZ2l0c1wiIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCBjIC0+XG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImNoYXJhY3RlciAlQyBpcyBub3QgYSBkZWNpbWFsIGRpZ2l0XCIgYylcblxuXG4oKiBUbyBzY2FuIG51bWJlcnMgZnJvbSBvdGhlciBiYXNlcywgd2UgdXNlIGEgcHJlZGljYXRlIGFyZ3VtZW50IHRvXG4gICBzY2FuIGRpZ2l0cy4gKilcbmxldCBzY2FuX2RpZ2l0X3N0YXIgZGlnaXRwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBzY2FuX2RpZ2l0cyB3aWR0aCBpYiA9XG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgYyB3aGVuIGRpZ2l0cCBjIC0+XG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgIHNjYW5fZGlnaXRzIHdpZHRoIGliXG4gICAgfCAnXycgLT5cbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliIGluXG4gICAgICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuICAgIHwgXyAtPiB3aWR0aCBpblxuICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX2RpZ2l0X3BsdXMgYmFzaXMgZGlnaXRwIHdpZHRoIGliID1cbiAgKCogRW5zdXJlIHdlIGhhdmUgZ290IGVub3VnaCB3aWR0aCBsZWZ0LFxuICAgICBhbmQgcmVhZCBhdCBsZWFzdCBvbmUgZGlnaXQuICopXG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJkaWdpdHNcIiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgaWYgZGlnaXRwIGMgdGhlblxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGlnaXRfc3RhciBkaWdpdHAgd2lkdGggaWJcbiAgZWxzZVxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJjaGFyYWN0ZXIgJUMgaXMgbm90IGEgdmFsaWQgJXMgZGlnaXRcIiBjIGJhc2lzKVxuXG5cbmxldCBpc19iaW5hcnlfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnMScgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9iaW5hcnlfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwiYmluYXJ5XCIgaXNfYmluYXJ5X2RpZ2l0XG5cbmxldCBpc19vY3RhbF9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc3JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX29jdGFsX2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcIm9jdGFsXCIgaXNfb2N0YWxfZGlnaXRcblxubGV0IGlzX2hleGFfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX2hleGFkZWNpbWFsX2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcImhleGFkZWNpbWFsXCIgaXNfaGV4YV9kaWdpdFxuXG4oKiBTY2FuIGEgZGVjaW1hbCBpbnRlZ2VyLiAqKVxubGV0IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgPSBzY2FuX2RlY2ltYWxfZGlnaXRfcGx1c1xuXG5sZXQgc2Nhbl9zaWduIHdpZHRoIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnKycgLT4gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjXG4gIHwgJy0nIC0+IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgY1xuICB8IF8gLT4gd2lkdGhcblxuXG5sZXQgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG5cblxuKCogU2NhbiBhbiB1bnNpZ25lZCBpbnRlZ2VyIHRoYXQgY291bGQgYmUgZ2l2ZW4gaW4gYW55IChjb21tb24pIGJhc2lzLlxuICAgSWYgZGlnaXRzIGFyZSBwcmVmaXhlZCBieSBvbmUgb2YgMHgsIDBYLCAwbywgb3IgMGIsIHRoZSBudW1iZXIgaXNcbiAgIGFzc3VtZWQgdG8gYmUgd3JpdHRlbiByZXNwZWN0aXZlbHkgaW4gaGV4YWRlY2ltYWwsIGhleGFkZWNpbWFsLFxuICAgb2N0YWwsIG9yIGJpbmFyeS4gKilcbmxldCBzY2FuX3Vuc2lnbmVkX2ludCB3aWR0aCBpYiA9XG4gIG1hdGNoIFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICBiZWdpbiBtYXRjaCBjIHdpdGhcbiAgICB8ICd4JyB8ICdYJyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgJ28nIC0+IHNjYW5fb2N0YWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCAnYicgLT4gc2Nhbl9iaW5hcnlfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCBfIC0+IHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliIGVuZFxuICB8IF8gLT4gc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2ludCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX3Vuc2lnbmVkX2ludCB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX2ludF9jb252ZXJzaW9uIGNvbnYgd2lkdGggaWIgPVxuICBtYXRjaCBjb252IHdpdGhcbiAgfCBCX2NvbnZlcnNpb24gLT4gc2Nhbl9iaW5hcnlfaW50IHdpZHRoIGliXG4gIHwgRF9jb252ZXJzaW9uIC0+IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgfCBJX2NvbnZlcnNpb24gLT4gc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9pbnQgd2lkdGggaWJcbiAgfCBPX2NvbnZlcnNpb24gLT4gc2Nhbl9vY3RhbF9pbnQgd2lkdGggaWJcbiAgfCBVX2NvbnZlcnNpb24gLT4gc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICB8IFhfY29udmVyc2lvbiAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbigqIFNjYW5uaW5nIGZsb2F0aW5nIHBvaW50IG51bWJlcnMuICopXG5cbigqIEZyYWN0aW9uYWwgcGFydCBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlZHVjZWQgdG8gMCBkaWdpdHMuICopXG5sZXQgc2Nhbl9mcmFjdGlvbmFsX3BhcnQgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxuKCogRXhwIHBhcnQgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZWR1Y2VkIHRvIDAgZGlnaXRzLiAqKVxubGV0IHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnZScgfCAnRScgYXMgYyAtPlxuICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxuKCogU2NhbiB0aGUgaW50ZWdlciBwYXJ0IG9mIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLCAobm90IHVzaW5nIHRoZVxuICAgT0NhbWwgbGV4aWNhbCBjb252ZW50aW9uIHNpbmNlIHRoZSBpbnRlZ2VyIHBhcnQgY2FuIGJlIGVtcHR5KTpcbiAgIGFuIG9wdGlvbmFsIHNpZ24sIGZvbGxvd2VkIGJ5IGEgcG9zc2libHkgZW1wdHkgc2VxdWVuY2Ugb2YgZGVjaW1hbFxuICAgZGlnaXRzIChlLmcuIC0uMSkuICopXG5sZXQgc2Nhbl9pbnRlZ2VyX3BhcnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcblxuXG4oKlxuICAgRm9yIHRoZSB0aW1lIGJlaW5nIHdlIGhhdmUgKGFzIGZvdW5kIGluIHNjYW5mLm1saSk6XG4gICB0aGUgZmllbGQgd2lkdGggaXMgY29tcG9zZWQgb2YgYW4gb3B0aW9uYWwgaW50ZWdlciBsaXRlcmFsXG4gICBpbmRpY2F0aW5nIHRoZSBtYXhpbWFsIHdpZHRoIG9mIHRoZSB0b2tlbiB0byByZWFkLlxuICAgVW5mb3J0dW5hdGVseSwgdGhlIHR5cGUtY2hlY2tlciBsZXQgdGhlIHVzZXIgd3JpdGUgYW4gb3B0aW9uYWwgcHJlY2lzaW9uLFxuICAgc2luY2UgdGhpcyBpcyB2YWxpZCBmb3IgcHJpbnRmIGZvcm1hdCBzdHJpbmdzLlxuXG4gICBUaHVzLCB0aGUgbmV4dCBzdGVwIGZvciBTY2FuZiBpcyB0byBzdXBwb3J0IGEgZnVsbCB3aWR0aCBhbmQgcHJlY2lzaW9uXG4gICBpbmRpY2F0aW9uLCBtb3JlIG9yIGxlc3Mgc2ltaWxhciB0byB0aGUgb25lIGZvciBwcmludGYsIHBvc3NpYmx5IGV4dGVuZGVkXG4gICB0byB0aGUgc3BlY2lmaWNhdGlvbiBvZiBhIFttYXgsIG1pbl0gcmFuZ2UgZm9yIHRoZSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZFxuICAgZm9yIHN0cmluZ3MuIFNvbWV0aGluZyBsaWtlIHRoZSBmb2xsb3dpbmcgc3BlYyBmb3Igc2NhbmYubWxpOlxuXG4gICBUaGUgb3B0aW9uYWwgW3dpZHRoXSBpcyBhbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG1heGltYWxcbiAgIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLiBGb3IgaW5zdGFuY2UsIFslNmRdIHJlYWRzIGFuIGludGVnZXIsXG4gICBoYXZpbmcgYXQgbW9zdCA2IGNoYXJhY3RlcnMuXG5cbiAgIFRoZSBvcHRpb25hbCBbcHJlY2lzaW9uXSBpcyBhIGRvdCBbLl0gZm9sbG93ZWQgYnkgYW4gaW50ZWdlcjpcblxuICAgLSBpbiB0aGUgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGNvbnZlcnNpb25zIChbJWZdLCBbJWVdLCBbJWddLCBbJUZdLCBbJUVdLFxuICAgYW5kIFslRl0gY29udmVyc2lvbnMsIHRoZSBbcHJlY2lzaW9uXSBpbmRpY2F0ZXMgdGhlIG1heGltdW0gbnVtYmVyIG9mXG4gICBkaWdpdHMgdGhhdCBtYXkgZm9sbG93IHRoZSBkZWNpbWFsIHBvaW50LiBGb3IgaW5zdGFuY2UsIFslLjRmXSByZWFkcyBhXG4gICBbZmxvYXRdIHdpdGggYXQgbW9zdCA0IGZyYWN0aW9uYWwgZGlnaXRzLFxuXG4gICAtIGluIHRoZSBzdHJpbmcgY29udmVyc2lvbnMgKFslc10sIFslU10sIFslXFxbIHJhbmdlIFxcXV0pLCBhbmQgaW4gdGhlXG4gICBpbnRlZ2VyIG51bWJlciBjb252ZXJzaW9ucyAoWyVpXSwgWyVkXSwgWyV1XSwgWyV4XSwgWyVvXSwgYW5kIHRoZWlyXG4gICBbaW50MzJdLCBbaW50NjRdLCBhbmQgW25hdGl2ZV9pbnRdIGNvcnJlc3BvbmRlbnQpLCB0aGUgW3ByZWNpc2lvbl1cbiAgIGluZGljYXRlcyB0aGUgcmVxdWlyZWQgbWluaW11bSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZCxcblxuICAgLSBvbiBhbGwgb3RoZXIgY29udmVyc2lvbnMsIHRoZSB3aWR0aCBhbmQgcHJlY2lzaW9uIHNwZWNpZnkgdGhlIFttYXgsIG1pbl1cbiAgIHJhbmdlIGZvciB0aGUgd2lkdGggb2YgdGhlIHRva2VuIHJlYWQuXG4qKVxubGV0IHNjYW5fZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9pbnRlZ2VyX3BhcnQgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGgsIHByZWNpc2lvbiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoLCBwcmVjaXNpb24gZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnLicgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBsZXQgcHJlY2lzaW9uID0gSW50Lm1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIpIGluXG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cbiAgfCBfIC0+XG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cblxuXG5sZXQgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgZXJyb3Igc3RyID1cbiAgbGV0IGxvd2VyY2FzZSBjID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICdBJyAuLiAnWicgLT5cbiAgICAgIGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ0EnICsgaW50X29mX2NoYXIgJ2EnKVxuICAgIHwgXyAtPiBjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgd2lkdGggPSByZWYgd2lkdGggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIGxvd2VyY2FzZSBjIDw+IGxvd2VyY2FzZSBzdHIuW2ldIHRoZW4gZXJyb3IgKCk7XG4gICAgaWYgIXdpZHRoID0gMCB0aGVuIGVycm9yICgpO1xuICAgIHdpZHRoIDo9IFNjYW5uaW5nLnN0b3JlX2NoYXIgIXdpZHRoIGliIGM7XG4gIGRvbmU7XG4gICF3aWR0aFxuXG5cbmxldCBzY2FuX2hleF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+IChcbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBsZXQgd2lkdGggPSBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwieFwiIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJy4nIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYiBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IEludC5taW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgICAgICAgICAgICAgd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgcHJlY2lzaW9uIGliKVxuICAgICAgICAgIClcbiAgICAgICAgICB8IF8gLT4gd2lkdGggaW5cbiAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgIHwgJ3AnIHwgJ1AnIGFzIGMgLT5cbiAgICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgICAgICAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gICAgICAgICAgfCBfIC0+IHdpZHRoXG4gIClcbiAgfCAnbicgfCAnTicgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJhblwiXG4gIHwgJ2knIHwgJ0knIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwibmZpbml0eVwiXG4gIHwgXyAtPiBiYWRfaGV4X2Zsb2F0ICgpXG5cblxubGV0IHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCB3aWR0aCA9IHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcuJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICgqIFRoZSBlZmZlY3RpdmUgd2lkdGggYXZhaWxhYmxlIGZvciBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IGlzXG4gICAgICAgdGhlIG1pbmltdW0gb2YgZGVjbGFyZWQgcHJlY2lzaW9uIGFuZCB3aWR0aCBsZWZ0LiAqKVxuICAgIGxldCBwcmVjaXNpb24gPSBJbnQubWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICgqIEFmdGVyIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgd2l0aCBbcHJlY2lzaW9uXSBwcm92aXNpb25hbCB3aWR0aCxcbiAgICAgICBbd2lkdGhfcHJlY2lzaW9uXSBpcyBsZWZ0LiAqKVxuICAgIGxldCB3aWR0aF9wcmVjaXNpb24gPSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIgaW5cbiAgICAoKiBIZW5jZSwgc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCB0b29rIGV4YWN0bHlcbiAgICAgICBbcHJlY2lzaW9uIC0gd2lkdGhfcHJlY2lzaW9uXSBjaGFycy4gKilcbiAgICBsZXQgZnJhY193aWR0aCA9IHByZWNpc2lvbiAtIHdpZHRoX3ByZWNpc2lvbiBpblxuICAgICgqIEFuZCBuZXcgcHJvdmlzaW9uYWwgd2lkdGggaXMgW3dpZHRoIC0gd2lkdGhfcHJlY2lzaW9uLiAqKVxuICAgIGxldCB3aWR0aCA9IHdpZHRoIC0gZnJhY193aWR0aCBpblxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYlxuICB8ICdlJyB8ICdFJyAtPlxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYlxuICB8IF8gLT4gYmFkX2Zsb2F0ICgpXG5cblxubGV0IHNjYW5fY2FtbF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPiAoXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ3gnIHwgJ1gnIGFzIGMgLT4gKFxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgICAgbGV0IHdpZHRoID0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWIgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IEludC5taW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgICAgICAgICAgIHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5faGV4YWRlY2ltYWxfaW50IHByZWNpc2lvbiBpYilcbiAgICAgICAgKVxuICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gYmFkX2Zsb2F0ICgpIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICdwJyB8ICdQJyBhcyBjIC0+XG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgICAgICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICAgICAgICB8IF8gLT4gd2lkdGhcbiAgICApXG4gICAgfCBfIC0+XG4gICAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbiAgKVxuICB8ICcxJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliXG4oKiBTcGVjaWFsIGNhc2Ugb2YgbmFuIGFuZCBpbmZpbml0eTpcbiAgfCAnaScgLT5cbiAgfCAnbicgLT5cbiopXG4gIHwgXyAtPiBiYWRfZmxvYXQgKClcblxuXG4oKiBTY2FuIGEgcmVndWxhciBzdHJpbmc6XG4gICBzdG9wcyB3aGVuIGVuY291bnRlcmluZyBhIHNwYWNlLCBpZiBubyBzY2FubmluZyBpbmRpY2F0aW9uIGhhcyBiZWVuIGdpdmVuO1xuICAgb3RoZXJ3aXNlLCBzdG9wcyB3aGVuIGVuY291bnRlcmluZyB0aGUgY2hhcmFjdGVycyBpbiB0aGUgc2Nhbm5pbmdcbiAgIGluZGljYXRpb24gW3N0cF0uXG4gICBJdCBhbHNvIHN0b3BzIGF0IGVuZCBvZiBmaWxlIG9yIHdoZW4gdGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgaGFzXG4gICBiZWVuIHJlYWQuICopXG5sZXQgc2Nhbl9zdHJpbmcgc3RwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBsb29wIHdpZHRoID1cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICBtYXRjaCBzdHAgd2l0aFxuICAgICAgfCBTb21lIGMnIHdoZW4gYyA9IGMnIC0+IFNjYW5uaW5nLnNraXBfY2hhciB3aWR0aCBpYlxuICAgICAgfCBTb21lIF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIHwgJ1xcbicgfCAnXFxyJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpblxuICBsb29wIHdpZHRoXG5cblxuKCogU2NhbiBhIGNoYXI6IHBlZWsgc3RyaWN0bHkgb25lIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQsIHdoYXRzb2V2ZXIuICopXG5sZXQgc2Nhbl9jaGFyIHdpZHRoIGliID1cbiAgKCogVGhlIGNhc2Ugd2lkdGggPSAwIGNvdWxkIG5vdCBoYXBwZW4gaGVyZSwgc2luY2UgaXQgaXMgdGVzdGVkIGJlZm9yZVxuICAgICBjYWxsaW5nIHNjYW5fY2hhciwgaW4gdGhlIG1haW4gc2Nhbm5pbmcgZnVuY3Rpb24uXG4gICAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImEgY2hhcmFjdGVyXCIgZWxzZSAqKVxuICBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIChTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYilcblxuXG5sZXQgY2hhcl9mb3JfYmFja3NsYXNoID0gZnVuY3Rpb25cbiAgfCAnbicgLT4gJ1xcMDEwJ1xuICB8ICdyJyAtPiAnXFwwMTMnXG4gIHwgJ2InIC0+ICdcXDAwOCdcbiAgfCAndCcgLT4gJ1xcMDA5J1xuICB8IGMgLT4gY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYyA9IGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnMCdcblxubGV0IGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxMDAgKiBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzAgK1xuICAgICAxMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICAgZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgICBcImJhZCBjaGFyYWN0ZXIgZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlYyVjXCIgYzAgYzEgYzIpIGVsc2VcbiAgY2hhcl9vZl9pbnQgY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBoZXhhZGVjaW1hbCBkaWdpdCBjaGFyYWN0ZXIuICopXG5sZXQgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID1cbiAgbGV0IGQgPSBpbnRfb2ZfY2hhciBjIGluXG4gICgqIENvdWxkIGFsc28gYmU6XG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnOScgdGhlbiBkIC0gaW50X29mX2NoYXIgJzAnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdGJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdBJyBlbHNlXG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnZicgdGhlbiAxMCArIGQgLSBpbnRfb2ZfY2hhciAnYScgZWxzZSBhc3NlcnQgZmFsc2VcbiAgKilcbiAgaWYgZCA+PSBpbnRfb2ZfY2hhciAnYScgdGhlblxuICAgIGQgLSA4NyAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnYScgKikgZWxzZVxuICBpZiBkID49IGludF9vZl9jaGFyICdBJyB0aGVuXG4gICAgZCAtIDU1ICAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKikgZWxzZVxuICAgIGQgLSBpbnRfb2ZfY2hhciAnMCdcblxuXG5sZXQgY2hhcl9mb3JfaGV4YWRlY2ltYWxfY29kZSBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxNiAqIGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzEgK1xuICAgICAgICAgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMiBpblxuICBpZiBjIDwgMCB8fCBjID4gMjU1IHRoZW5cbiAgICBiYWRfaW5wdXRcbiAgICAgIChQcmludGYuc3ByaW50ZiBcImJhZCBjaGFyYWN0ZXIgaGV4YWRlY2ltYWwgZW5jb2RpbmcgXFxcXCVjJWNcIiBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogQ2FsbGVkIGluIHBhcnRpY3VsYXIgd2hlbiBlbmNvdW50ZXJpbmcgJ1xcXFwnIGFzIHN0YXJ0ZXIgb2YgYSBjaGFyLlxuICAgU3RvcHMgYmVmb3JlIHRoZSBjb3JyZXNwb25kaW5nICdcXCcnLiAqKVxubGV0IGNoZWNrX25leHRfY2hhciBtZXNzYWdlIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBtZXNzYWdlIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlIGVsc2VcbiAgY1xuXG5cbmxldCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgPSBjaGVja19uZXh0X2NoYXIgXCJhIENoYXJcIlxubGV0IGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nID0gY2hlY2tfbmV4dF9jaGFyIFwiYSBTdHJpbmdcIlxuXG5sZXQgc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYiA9XG4gIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gIHwgJ1xcXFwnIHwgJ1xcJycgfCAnXFxcIicgfCAnbicgfCAndCcgfCAnYicgfCAncicgYXMgYyAtPlxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKGNoYXJfZm9yX2JhY2tzbGFzaCBjKVxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCBnZXRfZGlnaXQgKCkgPVxuICAgICAgbGV0IGMgPSBTY2FubmluZy5uZXh0X2NoYXIgaWIgaW5cbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMCA9IGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9kZWNpbWFsX2NvZGUgYzAgYzEgYzIpXG4gIHwgJ3gnIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIHwgJ2EnIC4uICdmJyBhcyBjIC0+IGNcbiAgICAgIHwgYyAtPiBiYWRfaW5wdXRfZXNjYXBlIGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyKVxuICB8IGMgLT5cbiAgICBiYWRfaW5wdXRfZXNjYXBlIGNcblxuXG4oKiBTY2FuIGEgY2hhcmFjdGVyIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX2NoYXIgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcJycgLT4gZmluZF9jaGFyIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXCcnIGNcblxuICBhbmQgZmluZF9jaGFyIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXFwnIC0+XG4gICAgICBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKSBpYilcbiAgICB8IGMgLT5cbiAgICAgIGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgYyBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgZGVsaW1pdGVkIHN0cmluZyAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFxcIicgY1xuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXFwiJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgJ1xcXFwnIC0+IHNjYW5fYmFja3NsYXNoIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIHNjYW5fYmFja3NsYXNoIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxyJyAtPiBza2lwX25ld2xpbmUgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgd2lkdGggaWIpXG5cbiAgYW5kIHNraXBfbmV3bGluZSB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgJ1xccicpXG5cbiAgYW5kIHNraXBfc3BhY2VzIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnICcgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3Agd2lkdGggaW5cblxuICBmaW5kX3N0YXJ0IHdpZHRoXG5cblxuKCogU2NhbiBhIGJvb2xlYW4gKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2Jvb2wgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGxldCBtID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICd0JyAtPiA0XG4gICAgfCAnZicgLT4gNVxuICAgIHwgYyAtPlxuICAgICAgYmFkX2lucHV0XG4gICAgICAgIChQcmludGYuc3ByaW50ZiBcInRoZSBjaGFyYWN0ZXIgJUMgY2Fubm90IHN0YXJ0IGEgYm9vbGVhblwiIGMpIGluXG4gIHNjYW5fc3RyaW5nIE5vbmUgbSBpYlxuXG5cbigqIFNjYW4gYSBzdHJpbmcgY29udGFpbmluZyBlbGVtZW50cyBpbiBjaGFyX3NldCBhbmQgdGVybWluYXRlZCBieSBzY2FuX2luZGljXG4gICBpZiBwcm92aWRlZC4gKilcbmxldCBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IHNjYW5faW5kaWMgd2lkdGggaWIgPVxuICBsZXQgcmVjIHNjYW5fY2hhcnMgaSBzdHAgPVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgaSA+IDAgJiYgbm90IChTY2FubmluZy5lb2YgaWIpICYmXG4gICAgICAgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyAmJlxuICAgICAgIGludF9vZl9jaGFyIGMgPD4gc3RwIHRoZW5cbiAgICAgIGxldCBfID0gU2Nhbm5pbmcuc3RvcmVfY2hhciBtYXhfaW50IGliIGMgaW5cbiAgICAgIHNjYW5fY2hhcnMgKGkgLSAxKSBzdHAgaW5cbiAgbWF0Y2ggc2Nhbl9pbmRpYyB3aXRoXG4gIHwgTm9uZSAtPiBzY2FuX2NoYXJzIHdpZHRoICgtMSk7XG4gIHwgU29tZSBjIC0+XG4gICAgc2Nhbl9jaGFycyB3aWR0aCAoaW50X29mX2NoYXIgYyk7XG4gICAgaWYgbm90IChTY2FubmluZy5lb2YgaWIpIHRoZW5cbiAgICAgIGxldCBjaSA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgICAgaWYgYyA9IGNpXG4gICAgICB0aGVuIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gICAgICBlbHNlIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cblxuKCogVGhlIGdsb2JhbCBlcnJvciByZXBvcnQgZnVuY3Rpb24gZm9yIFtTY2FuZl0uICopXG5sZXQgc2NhbmZfYmFkX2lucHV0IGliID0gZnVuY3Rpb25cbiAgfCBTY2FuX2ZhaWx1cmUgcyB8IEZhaWx1cmUgcyAtPlxuICAgIGxldCBpID0gU2Nhbm5pbmcuY2hhcl9jb3VudCBpYiBpblxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJzY2FuZjogYmFkIGlucHV0IGF0IGNoYXIgbnVtYmVyICVpOiAlc1wiIGkgcylcbiAgfCB4IC0+IHJhaXNlIHhcblxuXG4oKiBHZXQgdGhlIGNvbnRlbnQgb2YgYSBjb3VudGVyIGZyb20gYW4gaW5wdXQgYnVmZmVyLiAqKVxubGV0IGdldF9jb3VudGVyIGliIGNvdW50ZXIgPVxuICBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgLT4gU2Nhbm5pbmcubGluZV9jb3VudCBpYlxuICB8IENoYXJfY291bnRlciAtPiBTY2FubmluZy5jaGFyX2NvdW50IGliXG4gIHwgVG9rZW5fY291bnRlciAtPiBTY2FubmluZy50b2tlbl9jb3VudCBpYlxuXG5cbigqIENvbXB1dGUgdGhlIHdpZHRoIG9mIGEgcGFkZGluZyBvcHRpb24gKHNlZSBcIiU0MntcIiBhbmQgXCIlMTIzKFwiKS4gKilcbmxldCB3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IG1heF9pbnRcbiAgfCBTb21lIHdpZHRoIC0+IHdpZHRoXG5cblxubGV0IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nID1cbiAgaWYgZm10aW5nID0gRXNjYXBlZF9wZXJjZW50IHRoZW4gJyUnLCBcIlwiIGVsc2VcbiAgICBsZXQgc3RyID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZyBpblxuICAgIGxldCBzdHAgPSBzdHIuWzFdIGluXG4gICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciAyIChTdHJpbmcubGVuZ3RoIHN0ciAtIDIpIGluXG4gICAgc3RwLCBzdWJfc3RyXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFJlYWRlciBtYW5hZ2VtZW50ICopXG5cbigqIEEgY2FsbCB0byB0YWtlX2Zvcm1hdF9yZWFkZXJzIG9uIGEgZm9ybWF0IGlzIGV2YWx1YXRlZCBpbnRvIGZ1bmN0aW9uc1xuICAgdGFraW5nIHJlYWRlcnMgYXMgYXJndW1lbnRzIGFuZCBhZ2dyZWdhdGUgdGhlbSBpbnRvIGFuIGhldGVyb2dlbmVvdXMgbGlzdCAqKVxuKCogV2hlbiBhbGwgcmVhZGVycyBhcmUgdGFrZW4sIGZpbmFsbHkgcGFzcyB0aGUgbGlzdCBvZiB0aGUgcmVhZGVycyB0byB0aGVcbiAgIGNvbnRpbnVhdGlvbiBrLiAqKVxubGV0IHJlYyB0YWtlX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgZCA9XG5mdW4gayBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdFxuICB8IENoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENhbWxfc3RyaW5nIChfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQzMiAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IE5hdGl2ZWludCAoXywgXywgXywgcmVzdCkgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50NjQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGbG9hdCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEJvb2wgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQWxwaGEgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsdXNoIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEN1c3RvbSAoXywgXywgcmVzdCkgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSwgcmVzdCkgLT5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdCBmbXQgcmVzdClcblxuICB8IEZvcm1hdF9hcmcgKF8sIF8sIHJlc3QpICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgICAgLT5cbiAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKSByZXN0XG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgICAgICAgLT4gdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIGsgaWduIHJlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgICAgICAgIC0+IGsgTmlsXG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGZtdHR5IGNvbWluZyBmcm9tIGEgRm9ybWF0X3N1YnN0IFwiJSguLi4lKVwiLiAqKVxuYW5kIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIHggeSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgeCwgeSkgZm10dHkgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBmbXR0eSBmbXQgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IFJlYWRlcl90eSBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0IGZtdFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBBbHBoYV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFueV90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRW5kX29mX2ZtdHR5ICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10dHkgdHkgcmVzdCkgZm10XG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGlnbm9yZWQgcGFyYW1ldGVyLiAqKVxuYW5kIHRha2VfaWdub3JlZF9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBpZ25vcmVkIC0+XG4gICAgICAoeSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgeCwgZSwgZikgZm10IC0+IGQgPVxuZnVuIGsgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfcmVhZGVyIC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10XG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgZm10dHkgZm10XG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEdlbmVyaWMgc2Nhbm5pbmcgKilcblxuKCogTWFrZSBhIGdlbmVyaWMgc2Nhbm5pbmcgZnVuY3Rpb24uICopXG4oKiBTY2FuIGEgc3RyZWFtIGFjY29yZGluZyB0byBhIGZvcm1hdCBhbmQgcmVhZGVycyBvYnRhaW5lZCBieVxuICAgdGFrZV9mb3JtYXRfcmVhZGVycywgYW5kIGFnZ3JlZ2F0ZSBzY2FubmVkIHZhbHVlcyBpbnRvIGFuXG4gICBoZXRlcm9nZW5lb3VzIGxpc3QuICopXG4oKiBSZXR1cm4gdGhlIGhldGVyb2dlbmVvdXMgbGlzdCBvZiBzY2FubmVkIHZhbHVlcy4gKilcbmxldCByZWMgbWFrZV9zY2FuZiA6IHR5cGUgYSBjIGQgZSBmLlxuICAgIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKGQsIGUpIGhldGVyX2xpc3QgLT4gKGEsIGYpIGhldGVyX2xpc3QgPVxuZnVuIGliIGZtdCByZWFkZXJzIC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgQ2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NoYXIgMCBpYiBpblxuICAgIGxldCBjID0gdG9rZW5fY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpKSAtPlxuICAgIGxldCBzdHAsIHN0ciA9IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSBzdHApIHdpZHRoIGliIGluXG4gICAgbGV0IHN0cl9yZXN0ID0gU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiBzdHJfcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICd7Jykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpKSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSAnWycpIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhblxuICAgICAgICAgICAgICAgICAgIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyBOb25lIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcblxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50IGMpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludDMyIGMpXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9uYXRpdmVpbnQgYylcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50NjQgYylcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9GIHwgRmxvYXRfQ0YpKSwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2NhbWxfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfRykpLFxuICAgICAgICAgICBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5fZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9oIHwgRmxvYXRfSCkpLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5faGV4X2Zsb2F0IHRva2VuX2Zsb2F0XG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIF8gXyBpYiA9IHNjYW5fYm9vbCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fYm9vbFxuICB8IEFscGhhIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJWFcXFwiXCJcbiAgfCBUaGV0YSBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiV0XFxcIlwiXG4gIHwgQ3VzdG9tIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJT9cXFwiIChjdXN0b20gY29udmVydGVyKVwiXG4gIHwgUmVhZGVyIGZtdF9yZXN0IC0+XG4gICAgYmVnaW4gbWF0Y2ggcmVhZGVycyB3aXRoXG4gICAgfCBDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkgLT5cbiAgICAgICAgbGV0IHggPSByZWFkZXIgaWIgaW5cbiAgICAgICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXRfcmVzdCByZWFkZXJzX3Jlc3QpXG4gICAgfCBOaWwgLT5cbiAgICAgICAgaW52YWxpZF9hcmcgXCJzY2FuZjogbWlzc2luZyByZWFkZXJcIlxuICAgIGVuZFxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBpZiBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICAgIGVsc2UgYmFkX2lucHV0IFwiZW5kIG9mIGlucHV0IG5vdCBmb3VuZFwiXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIFN0cmluZy5pdGVyIChjaGVja19jaGFyIGliKSBzdHI7XG4gICAgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliIGNocjtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuXG4gIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nICh3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQpIGliIGluXG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10ID1cbiAgICAgIHRyeSBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHMgZm10dHlcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZ1xuICAgIGluXG4gICAgQ29ucyAoZm10LCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyAod2lkdGhfb2ZfcGFkX29wdCBwYWRfb3B0KSBpYiBpblxuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCwgZm10JyA9XG4gICAgICB0cnlcbiAgICAgICAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgcyBpblxuICAgICAgICBsZXQgRm10X0VCQiBmbXQnID0gZm10X2ViYl9vZl9zdHJpbmcgcyBpblxuICAgICAgICAoKiBUT0RPOiBmaW5kIGEgd2F5IHRvIGF2b2lkIHJlcGFyc2luZyB0d2ljZSAqKVxuXG4gICAgICAgICgqIFRPRE86IHRoZXNlIHR5cGUtY2hlY2tzIGJlbG93ICpjYW4qIGZhaWwgYmVjYXVzZSBvZiB0eXBlXG4gICAgICAgICAgIGFtYmlndWl0eSBpbiBwcmVzZW5jZSBvZiBpZ25vcmVkLXJlYWRlcnM6IFwiJV9yJWRcIiBhbmQgXCIlZCVfclwiXG4gICAgICAgICAgIGFyZSB0eXBlZCBpbiB0aGUgc2FtZSB3YXkuXG5cbiAgICAgICAgICAgIyBTY2FuZi5zc2NhbmYgXCJcXFwiJV9yJWRcXFwiM1wiIFwiJSglZCVfciUpXCIgaWdub3JlXG4gICAgICAgICAgICAgKGZ1biBmbXQgbiAtPiBzdHJpbmdfb2ZfZm9ybWF0IGZtdCwgbilcbiAgICAgICAgICAgRXhjZXB0aW9uOiBDYW1saW50ZXJuYWxGb3JtYXQuVHlwZV9taXNtYXRjaC5cblxuICAgICAgICAgICBXZSBzaG91bGQgcHJvcGVybHkgY2F0Y2ggdGhpcyBleGNlcHRpb24uXG4gICAgICAgICopXG4gICAgICAgIHR5cGVfZm9ybWF0IGZtdCAoZXJhc2VfcmVsIGZtdHR5KSxcbiAgICAgICAgdHlwZV9mb3JtYXQgZm10JyAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSlcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZ1xuICAgIGluXG4gICAgQ29ucyAoRm9ybWF0IChmbXQsIHMpLFxuICAgICAgICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzKVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpKSAtPlxuICAgIGxldCBzdHAsIHN0ciA9IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGxldCB3aWR0aCA9IHdpZHRoX29mX3BhZF9vcHQgd2lkdGhfb3B0IGluXG4gICAgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCAoU29tZSBzdHApIHdpZHRoIGliO1xuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IHN0cl9yZXN0ID0gU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgaW5cbiAgICBDb25zIChzLCBtYWtlX3NjYW5mIGliIHN0cl9yZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICBsZXQgd2lkdGggPSB3aWR0aF9vZl9wYWRfb3B0IHdpZHRoX29wdCBpblxuICAgIHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgTm9uZSB3aWR0aCBpYjtcbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIENvbnMgKHMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgbGV0IGNvdW50ID0gZ2V0X2NvdW50ZXIgaWIgY291bnRlciBpblxuICAgIENvbnMgKGNvdW50LCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCByZXN0KSAtPlxuICAgIFN0cmluZy5pdGVyIChjaGVja19jaGFyIGliKSAoc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZvcm1hdHRpbmdfbGl0KTtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgY2hlY2tfY2hhciBpYiAnQCc7IGNoZWNrX2NoYXIgaWIgJ3snO1xuICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliICdAJzsgY2hlY2tfY2hhciBpYiAnWyc7XG4gICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnNcblxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBsZXQgUGFyYW1fZm9ybWF0X0VCQiBmbXQnID0gcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0IGluXG4gICAgYmVnaW4gbWF0Y2ggbWFrZV9zY2FuZiBpYiBmbXQnIHJlYWRlcnMgd2l0aFxuICAgIHwgQ29ucyAoXywgYXJnX3Jlc3QpIC0+IGFyZ19yZXN0XG4gICAgfCBOaWwgLT4gYXNzZXJ0IGZhbHNlXG4gICAgZW5kXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgTmlsXG5cbigqIENhc2UgYW5hbHlzaXMgb24gcGFkZGluZyBhbmQgcHJlY2lzaW9uLiAqKVxuKCogUmVqZWN0IGZvcm1hdHMgY29udGFpbmluZyBcIiUqXCIgb3IgXCIlLipcIi4gKilcbigqIFBhc3MgcGFkZGluZyBhbmQgcHJlY2lzaW9uIHRvIHRoZSBnZW5lcmljIHNjYW5uZXIgYHNjYW4nLiAqKVxuYW5kIHBhZF9wcmVjX3NjYW5mIDogdHlwZSBhIGMgZCBlIGYgeCB5IHogdCAuXG4gICAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoZCwgZSkgaGV0ZXJfbGlzdCAtPiAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT5cbiAgICAgIChpbnQgLT4gaW50IC0+IFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gdCkgLT5cbiAgICAgIChTY2FubmluZy5pbl9jaGFubmVsIC0+IHopIC0+XG4gICAgICAoeCwgZikgaGV0ZXJfbGlzdCA9XG5mdW4gaWIgZm10IHJlYWRlcnMgcGFkIHByZWMgc2NhbiB0b2tlbiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGxldCBfID0gc2NhbiBtYXhfaW50IG1heF9pbnQgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBsZXQgXyA9IHNjYW4gbWF4X2ludCBwIGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGxldCBfID0gc2NhbiB3IG1heF9pbnQgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgbGV0IF8gPSBzY2FuIHcgcCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nIChMZWZ0LCBfKSwgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlLVxcXCJcIlxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIF8pLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG4gIHwgQXJnX3BhZGRpbmcgXywgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICgqIERlZmluaW5nIFtzY2FuZl0gYW5kIHZhcmlvdXMgZmxhdm9ycyBvZiBbc2NhbmZdICopXG5cbnR5cGUgJ2Ega3NjYW5mX3Jlc3VsdCA9IEFyZ3Mgb2YgJ2EgfCBFeGMgb2YgZXhuXG5cbmxldCBrc2NhbmYgaWIgZWYgKEZvcm1hdCAoZm10LCBzdHIpKSA9XG4gIGxldCByZWMgYXBwbHkgOiB0eXBlIGEgYiAuIGEgLT4gKGEsIGIpIGhldGVyX2xpc3QgLT4gYiA9XG4gICAgZnVuIGYgYXJncyAtPiBtYXRjaCBhcmdzIHdpdGhcbiAgICB8IENvbnMgKHgsIHIpIC0+IGFwcGx5IChmIHgpIHJcbiAgICB8IE5pbCAtPiBmXG4gIGluXG4gIGxldCBrIHJlYWRlcnMgZiA9XG4gICAgU2Nhbm5pbmcucmVzZXRfdG9rZW4gaWI7XG4gICAgbWF0Y2ggdHJ5IEFyZ3MgKG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpIHdpdGhcbiAgICAgIHwgKFNjYW5fZmFpbHVyZSBfIHwgRmFpbHVyZSBfIHwgRW5kX29mX2ZpbGUpIGFzIGV4YyAtPiBFeGMgZXhjXG4gICAgICB8IEludmFsaWRfYXJndW1lbnQgbXNnIC0+XG4gICAgICAgIGludmFsaWRfYXJnIChtc2cgXiBcIiBpbiBmb3JtYXQgXFxcIlwiIF4gU3RyaW5nLmVzY2FwZWQgc3RyIF4gXCJcXFwiXCIpXG4gICAgd2l0aFxuICAgICAgfCBBcmdzIGFyZ3MgLT4gYXBwbHkgZiBhcmdzXG4gICAgICB8IEV4YyBleGMgLT4gZWYgaWIgZXhjXG4gIGluXG4gIHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcblxuKCoqKilcblxubGV0IGtic2NhbmYgPSBrc2NhbmZcbmxldCBic2NhbmYgaWIgZm10ID0ga2JzY2FuZiBpYiBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbmxldCBrc3NjYW5mIHMgZWYgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgZWYgZm10XG5sZXQgc3NjYW5mIHMgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG5sZXQgc2NhbmYgZm10ID0ga3NjYW5mIFNjYW5uaW5nLnN0ZGliIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxuKCoqKilcblxuKCogU2Nhbm5pbmcgZm9ybWF0IHN0cmluZ3MuICopXG5sZXQgYnNjYW5mX2Zvcm1hdCA6XG4gIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAgKCgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICdnKSAtPiAnZyA9XG4gIGZ1biBpYiBmb3JtYXQgZiAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyBtYXhfaW50IGliIGluXG4gICAgbGV0IHN0ciA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQnID1cbiAgICAgIHRyeSBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgZm9ybWF0XG4gICAgICB3aXRoIEZhaWx1cmUgbXNnIC0+IGJhZF9pbnB1dCBtc2cgaW5cbiAgICBmIGZtdCdcblxuXG5sZXQgc3NjYW5mX2Zvcm1hdCA6XG4gIHN0cmluZyAtPiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gJ2cpIC0+ICdnID1cbiAgZnVuIHMgZm9ybWF0IGYgLT4gYnNjYW5mX2Zvcm1hdCAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgZm9ybWF0IGZcblxuXG5sZXQgZm9ybWF0X2Zyb21fc3RyaW5nIHMgZm10ID1cbiAgc3NjYW5mX2Zvcm1hdCAoXCJcXFwiXCIgXiBTdHJpbmcuZXNjYXBlZCBzIF4gXCJcXFwiXCIpIGZtdCAoZnVuIHggLT4geClcblxuXG5sZXQgdW5lc2NhcGVkIHMgPVxuICBzc2NhbmYgKFwiXFxcIlwiIF4gcyBeIFwiXFxcIlwiKSBcIiVTJSFcIiAoZnVuIHggLT4geClcblxuXG4oKiBEZXByZWNhdGVkICopXG5sZXQga2ZzY2FuZiBpYyBlZiBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5tZW1vX2Zyb21fY2hhbm5lbCBpYykgZWYgZm10XG5sZXQgZnNjYW5mIGljIGZtdCA9IGtzY2FuZiAoU2Nhbm5pbmcubWVtb19mcm9tX2NoYW5uZWwgaWMpIHNjYW5mX2JhZF9pbnB1dCBmbXRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUmVnaXN0ZXJpbmcgT0NhbWwgdmFsdWVzIHdpdGggdGhlIEMgcnVudGltZSBmb3IgbGF0ZXIgY2FsbGJhY2tzICopXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+IE9iai50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0IHJlZ2lzdGVyIG5hbWUgdiA9XG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIG5hbWUgKE9iai5yZXByIHYpXG5cbmxldCByZWdpc3Rlcl9leGNlcHRpb24gbmFtZSAoZXhuIDogZXhuKSA9XG4gIGxldCBleG4gPSBPYmoucmVwciBleG4gaW5cbiAgbGV0IHNsb3QgPSBpZiBPYmoudGFnIGV4biA9IE9iai5vYmplY3RfdGFnIHRoZW4gZXhuIGVsc2UgT2JqLmZpZWxkIGV4biAwIGluXG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIG5hbWUgc2xvdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgSmVyb21lIFZvdWlsbG9uLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIE9ialxuXG4oKioqKiBPYmplY3QgcmVwcmVzZW50YXRpb24gKioqKilcblxuZXh0ZXJuYWwgc2V0X2lkOiAnYSAtPiAnYSA9IFwiY2FtbF9zZXRfb29faWRcIiBbQEBub2FsbG9jXVxuXG4oKioqKiBPYmplY3QgY29weSAqKioqKVxuXG5sZXQgY29weSBvID1cbiAgbGV0IG8gPSAoT2JqLm9iaiAoT2JqLmR1cCAoT2JqLnJlcHIgbykpKSBpblxuICBzZXRfaWQgb1xuXG4oKioqKiBDb21wcmVzc2lvbiBvcHRpb25zICoqKiopXG4oKiBQYXJhbWV0ZXJzICopXG50eXBlIHBhcmFtcyA9IHtcbiAgICBtdXRhYmxlIGNvbXBhY3RfdGFibGUgOiBib29sO1xuICAgIG11dGFibGUgY29weV9wYXJlbnQgOiBib29sO1xuICAgIG11dGFibGUgY2xlYW5fd2hlbl9jb3B5aW5nIDogYm9vbDtcbiAgICBtdXRhYmxlIHJldHJ5X2NvdW50IDogaW50O1xuICAgIG11dGFibGUgYnVja2V0X3NtYWxsX3NpemUgOiBpbnRcbiAgfVxuXG5sZXQgcGFyYW1zID0ge1xuICBjb21wYWN0X3RhYmxlID0gdHJ1ZTtcbiAgY29weV9wYXJlbnQgPSB0cnVlO1xuICBjbGVhbl93aGVuX2NvcHlpbmcgPSB0cnVlO1xuICByZXRyeV9jb3VudCA9IDM7XG4gIGJ1Y2tldF9zbWFsbF9zaXplID0gMTZcbn1cblxuKCoqKiogUGFyYW1ldGVycyAqKioqKVxuXG5sZXQgaW5pdGlhbF9vYmplY3Rfc2l6ZSA9IDJcblxuKCoqKiogSXRlbXMgKioqKilcblxudHlwZSBpdGVtID0gRHVtbXlBIHwgRHVtbXlCIHwgRHVtbXlDIG9mIGludFxubGV0IF8gPSBbRHVtbXlBOyBEdW1teUI7IER1bW15QyAwXSAoKiB0byBhdm9pZCB3YXJuaW5ncyAqKVxuXG5sZXQgZHVtbXlfaXRlbSA9IChtYWdpYyAoKSA6IGl0ZW0pXG5cbigqKioqIFR5cGVzICoqKiopXG5cbnR5cGUgdGFnXG50eXBlIGxhYmVsID0gaW50XG50eXBlIGNsb3N1cmUgPSBpdGVtXG50eXBlIHQgPSBEdW1teUEgfCBEdW1teUIgfCBEdW1teUMgb2YgaW50XG5sZXQgXyA9IFtEdW1teUE7IER1bW15QjsgRHVtbXlDIDBdICgqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5cbnR5cGUgb2JqID0gdCBhcnJheVxuZXh0ZXJuYWwgcmV0IDogKG9iaiAtPiAnYSkgLT4gY2xvc3VyZSA9IFwiJWlkZW50aXR5XCJcblxuKCoqKiogTGFiZWxzICoqKiopXG5cbmxldCBwdWJsaWNfbWV0aG9kX2xhYmVsIHMgOiB0YWcgPVxuICBsZXQgYWNjdSA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgYWNjdSA6PSAyMjMgKiAhYWNjdSArIENoYXIuY29kZSBzLltpXVxuICBkb25lO1xuICAoKiByZWR1Y2UgdG8gMzEgYml0cyAqKVxuICBhY2N1IDo9ICFhY2N1IGxhbmQgKDEgbHNsIDMxIC0gMSk7XG4gICgqIG1ha2UgaXQgc2lnbmVkIGZvciA2NCBiaXRzIGFyY2hpdGVjdHVyZXMgKilcbiAgbGV0IHRhZyA9IGlmICFhY2N1ID4gMHgzRkZGRkZGRiB0aGVuICFhY2N1IC0gKDEgbHNsIDMxKSBlbHNlICFhY2N1IGluXG4gICgqIFByaW50Zi5lcHJpbnRmIFwiJXMgPSAlZFxcblwiIHMgdGFnOyBmbHVzaCBzdGRlcnI7ICopXG4gIG1hZ2ljIHRhZ1xuXG4oKioqKiBTcGFyc2UgYXJyYXkgKioqKilcblxubW9kdWxlIFZhcnMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gc3RyaW5nIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIHZhcnMgPSBpbnQgVmFycy50XG5cbm1vZHVsZSBNZXRocyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBzdHJpbmcgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgbWV0aHMgPSBsYWJlbCBNZXRocy50XG5tb2R1bGUgTGFicyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBsYWJlbCBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSBsYWJzID0gYm9vbCBMYWJzLnRcblxuKCogVGhlIGNvbXBpbGVyIGFzc3VtZXMgdGhhdCB0aGUgZmlyc3QgZmllbGQgb2YgdGhpcyBzdHJ1Y3R1cmUgaXMgW3NpemVdLiAqKVxudHlwZSB0YWJsZSA9XG4geyBtdXRhYmxlIHNpemU6IGludDtcbiAgIG11dGFibGUgbWV0aG9kczogY2xvc3VyZSBhcnJheTtcbiAgIG11dGFibGUgbWV0aG9kc19ieV9uYW1lOiBtZXRocztcbiAgIG11dGFibGUgbWV0aG9kc19ieV9sYWJlbDogbGFicztcbiAgIG11dGFibGUgcHJldmlvdXNfc3RhdGVzOlxuICAgICAobWV0aHMgKiBsYWJzICogKGxhYmVsICogaXRlbSkgbGlzdCAqIHZhcnMgKlxuICAgICAgbGFiZWwgbGlzdCAqIHN0cmluZyBsaXN0KSBsaXN0O1xuICAgbXV0YWJsZSBoaWRkZW5fbWV0aHM6IChsYWJlbCAqIGl0ZW0pIGxpc3Q7XG4gICBtdXRhYmxlIHZhcnM6IHZhcnM7XG4gICBtdXRhYmxlIGluaXRpYWxpemVyczogKG9iaiAtPiB1bml0KSBsaXN0IH1cblxubGV0IGR1bW15X3RhYmxlID1cbiAgeyBtZXRob2RzID0gW3wgZHVtbXlfaXRlbSB8XTtcbiAgICBtZXRob2RzX2J5X25hbWUgPSBNZXRocy5lbXB0eTtcbiAgICBtZXRob2RzX2J5X2xhYmVsID0gTGFicy5lbXB0eTtcbiAgICBwcmV2aW91c19zdGF0ZXMgPSBbXTtcbiAgICBoaWRkZW5fbWV0aHMgPSBbXTtcbiAgICB2YXJzID0gVmFycy5lbXB0eTtcbiAgICBpbml0aWFsaXplcnMgPSBbXTtcbiAgICBzaXplID0gMCB9XG5cbmxldCB0YWJsZV9jb3VudCA9IHJlZiAwXG5cbigqIGR1bW15X21ldCBzaG91bGQgYmUgYSBwb2ludGVyLCBzbyB1c2UgYW4gYXRvbSAqKVxubGV0IGR1bW15X21ldCA6IGl0ZW0gPSBvYmogKE9iai5uZXdfYmxvY2sgMCAwKVxuKCogaWYgZGVidWdnaW5nIGlzIG5lZWRlZCwgdGhpcyBjb3VsZCBiZSBhIGdvb2QgaWRlYTogKilcbigqIGxldCBkdW1teV9tZXQgKCkgPSBmYWlsd2l0aCBcIlVuZGVmaW5lZCBtZXRob2RcIiAqKVxuXG5sZXQgcmVjIGZpdF9zaXplIG4gPVxuICBpZiBuIDw9IDIgdGhlbiBuIGVsc2VcbiAgZml0X3NpemUgKChuKzEpLzIpICogMlxuXG5sZXQgbmV3X3RhYmxlIHB1Yl9sYWJlbHMgPVxuICBpbmNyIHRhYmxlX2NvdW50O1xuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIHB1Yl9sYWJlbHMgaW5cbiAgbGV0IG1ldGhvZHMgPSBBcnJheS5tYWtlIChsZW4qMisyKSBkdW1teV9tZXQgaW5cbiAgbWV0aG9kcy4oMCkgPC0gbWFnaWMgbGVuO1xuICBtZXRob2RzLigxKSA8LSBtYWdpYyAoZml0X3NpemUgbGVuICogU3lzLndvcmRfc2l6ZSAvIDggLSAxKTtcbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG8gbWV0aG9kcy4oaSoyKzMpIDwtIG1hZ2ljIHB1Yl9sYWJlbHMuKGkpIGRvbmU7XG4gIHsgbWV0aG9kcyA9IG1ldGhvZHM7XG4gICAgbWV0aG9kc19ieV9uYW1lID0gTWV0aHMuZW1wdHk7XG4gICAgbWV0aG9kc19ieV9sYWJlbCA9IExhYnMuZW1wdHk7XG4gICAgcHJldmlvdXNfc3RhdGVzID0gW107XG4gICAgaGlkZGVuX21ldGhzID0gW107XG4gICAgdmFycyA9IFZhcnMuZW1wdHk7XG4gICAgaW5pdGlhbGl6ZXJzID0gW107XG4gICAgc2l6ZSA9IGluaXRpYWxfb2JqZWN0X3NpemUgfVxuXG5sZXQgcmVzaXplIGFycmF5IG5ld19zaXplID1cbiAgbGV0IG9sZF9zaXplID0gQXJyYXkubGVuZ3RoIGFycmF5Lm1ldGhvZHMgaW5cbiAgaWYgbmV3X3NpemUgPiBvbGRfc2l6ZSB0aGVuIGJlZ2luXG4gICAgbGV0IG5ld19idWNrID0gQXJyYXkubWFrZSBuZXdfc2l6ZSBkdW1teV9tZXQgaW5cbiAgICBBcnJheS5ibGl0IGFycmF5Lm1ldGhvZHMgMCBuZXdfYnVjayAwIG9sZF9zaXplO1xuICAgIGFycmF5Lm1ldGhvZHMgPC0gbmV3X2J1Y2tcbiBlbmRcblxubGV0IHB1dCBhcnJheSBsYWJlbCBlbGVtZW50ID1cbiAgcmVzaXplIGFycmF5IChsYWJlbCArIDEpO1xuICBhcnJheS5tZXRob2RzLihsYWJlbCkgPC0gZWxlbWVudFxuXG4oKioqKiBDbGFzc2VzICoqKiopXG5cbmxldCBtZXRob2RfY291bnQgPSByZWYgMFxubGV0IGluc3RfdmFyX2NvdW50ID0gcmVmIDBcblxuKCogdHlwZSB0ICopXG50eXBlIG1ldGggPSBpdGVtXG5cbmxldCBuZXdfbWV0aG9kIHRhYmxlID1cbiAgbGV0IGluZGV4ID0gQXJyYXkubGVuZ3RoIHRhYmxlLm1ldGhvZHMgaW5cbiAgcmVzaXplIHRhYmxlIChpbmRleCArIDEpO1xuICBpbmRleFxuXG5sZXQgZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSBuYW1lID1cbiAgdHJ5XG4gICAgTWV0aHMuZmluZCBuYW1lIHRhYmxlLm1ldGhvZHNfYnlfbmFtZVxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGxldCBsYWJlbCA9IG5ld19tZXRob2QgdGFibGUgaW5cbiAgICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gTWV0aHMuYWRkIG5hbWUgbGFiZWwgdGFibGUubWV0aG9kc19ieV9uYW1lO1xuICAgIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gTGFicy5hZGQgbGFiZWwgdHJ1ZSB0YWJsZS5tZXRob2RzX2J5X2xhYmVsO1xuICAgIGxhYmVsXG5cbmxldCBnZXRfbWV0aG9kX2xhYmVscyB0YWJsZSBuYW1lcyA9XG4gIEFycmF5Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgbmFtZXNcblxubGV0IHNldF9tZXRob2QgdGFibGUgbGFiZWwgZWxlbWVudCA9XG4gIGluY3IgbWV0aG9kX2NvdW50O1xuICBpZiBMYWJzLmZpbmQgbGFiZWwgdGFibGUubWV0aG9kc19ieV9sYWJlbCB0aGVuXG4gICAgcHV0IHRhYmxlIGxhYmVsIGVsZW1lbnRcbiAgZWxzZVxuICAgIHRhYmxlLmhpZGRlbl9tZXRocyA8LSAobGFiZWwsIGVsZW1lbnQpIDo6IHRhYmxlLmhpZGRlbl9tZXRoc1xuXG5sZXQgZ2V0X21ldGhvZCB0YWJsZSBsYWJlbCA9XG4gIHRyeSBMaXN0LmFzc29jIGxhYmVsIHRhYmxlLmhpZGRlbl9tZXRoc1xuICB3aXRoIE5vdF9mb3VuZCAtPiB0YWJsZS5tZXRob2RzLihsYWJlbClcblxubGV0IHRvX2xpc3QgYXJyID1cbiAgaWYgYXJyID09IG1hZ2ljIDAgdGhlbiBbXSBlbHNlIEFycmF5LnRvX2xpc3QgYXJyXG5cbmxldCBuYXJyb3cgdGFibGUgdmFycyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzID1cbiAgbGV0IHZhcnMgPSB0b19saXN0IHZhcnNcbiAgYW5kIHZpcnRfbWV0aHMgPSB0b19saXN0IHZpcnRfbWV0aHNcbiAgYW5kIGNvbmNyX21ldGhzID0gdG9fbGlzdCBjb25jcl9tZXRocyBpblxuICBsZXQgdmlydF9tZXRoX2xhYnMgPSBMaXN0Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgdmlydF9tZXRocyBpblxuICBsZXQgY29uY3JfbWV0aF9sYWJzID0gTGlzdC5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIGNvbmNyX21ldGhzIGluXG4gIHRhYmxlLnByZXZpb3VzX3N0YXRlcyA8LVxuICAgICAodGFibGUubWV0aG9kc19ieV9uYW1lLCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsLCB0YWJsZS5oaWRkZW5fbWV0aHMsXG4gICAgICB0YWJsZS52YXJzLCB2aXJ0X21ldGhfbGFicywgdmFycylcbiAgICAgOjogdGFibGUucHJldmlvdXNfc3RhdGVzO1xuICB0YWJsZS52YXJzIDwtXG4gICAgVmFycy5mb2xkXG4gICAgICAoZnVuIGxhYiBpbmZvIHR2YXJzIC0+XG4gICAgICAgIGlmIExpc3QubWVtIGxhYiB2YXJzIHRoZW4gVmFycy5hZGQgbGFiIGluZm8gdHZhcnMgZWxzZSB0dmFycylcbiAgICAgIHRhYmxlLnZhcnMgVmFycy5lbXB0eTtcbiAgbGV0IGJ5X25hbWUgPSByZWYgTWV0aHMuZW1wdHkgaW5cbiAgbGV0IGJ5X2xhYmVsID0gcmVmIExhYnMuZW1wdHkgaW5cbiAgTGlzdC5pdGVyMlxuICAgIChmdW4gbWV0IGxhYmVsIC0+XG4gICAgICAgYnlfbmFtZSA6PSBNZXRocy5hZGQgbWV0IGxhYmVsICFieV9uYW1lO1xuICAgICAgIGJ5X2xhYmVsIDo9XG4gICAgICAgICAgTGFicy5hZGQgbGFiZWxcbiAgICAgICAgICAgICh0cnkgTGFicy5maW5kIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgd2l0aCBOb3RfZm91bmQgLT4gdHJ1ZSlcbiAgICAgICAgICAgICFieV9sYWJlbClcbiAgICBjb25jcl9tZXRocyBjb25jcl9tZXRoX2xhYnM7XG4gIExpc3QuaXRlcjJcbiAgICAoZnVuIG1ldCBsYWJlbCAtPlxuICAgICAgIGJ5X25hbWUgOj0gTWV0aHMuYWRkIG1ldCBsYWJlbCAhYnlfbmFtZTtcbiAgICAgICBieV9sYWJlbCA6PSBMYWJzLmFkZCBsYWJlbCBmYWxzZSAhYnlfbGFiZWwpXG4gICAgdmlydF9tZXRocyB2aXJ0X21ldGhfbGFicztcbiAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtICFieV9uYW1lO1xuICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtICFieV9sYWJlbDtcbiAgdGFibGUuaGlkZGVuX21ldGhzIDwtXG4gICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgIChmdW4gKChsYWIsIF8pIGFzIG1ldCkgaG0gLT5cbiAgICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmlydF9tZXRoX2xhYnMgdGhlbiBobSBlbHNlIG1ldDo6aG0pXG4gICAgICAgdGFibGUuaGlkZGVuX21ldGhzXG4gICAgICAgW11cblxubGV0IHdpZGVuIHRhYmxlID1cbiAgbGV0IChieV9uYW1lLCBieV9sYWJlbCwgc2F2ZWRfaGlkZGVuX21ldGhzLCBzYXZlZF92YXJzLCB2aXJ0X21ldGhzLCB2YXJzKSA9XG4gICAgTGlzdC5oZCB0YWJsZS5wcmV2aW91c19zdGF0ZXNcbiAgaW5cbiAgdGFibGUucHJldmlvdXNfc3RhdGVzIDwtIExpc3QudGwgdGFibGUucHJldmlvdXNfc3RhdGVzO1xuICB0YWJsZS52YXJzIDwtXG4gICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAgKGZ1biBzIHYgLT4gVmFycy5hZGQgdiAoVmFycy5maW5kIHYgdGFibGUudmFycykgcylcbiAgICAgICBzYXZlZF92YXJzIHZhcnM7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSBieV9uYW1lO1xuICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIGJ5X2xhYmVsO1xuICB0YWJsZS5oaWRkZW5fbWV0aHMgPC1cbiAgICAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgICAgKGZ1biAoKGxhYiwgXykgYXMgbWV0KSBobSAtPlxuICAgICAgICAgIGlmIExpc3QubWVtIGxhYiB2aXJ0X21ldGhzIHRoZW4gaG0gZWxzZSBtZXQ6OmhtKVxuICAgICAgIHRhYmxlLmhpZGRlbl9tZXRoc1xuICAgICAgIHNhdmVkX2hpZGRlbl9tZXRoc1xuXG5sZXQgbmV3X3Nsb3QgdGFibGUgPVxuICBsZXQgaW5kZXggPSB0YWJsZS5zaXplIGluXG4gIHRhYmxlLnNpemUgPC0gaW5kZXggKyAxO1xuICBpbmRleFxuXG5sZXQgbmV3X3ZhcmlhYmxlIHRhYmxlIG5hbWUgPVxuICB0cnkgVmFycy5maW5kIG5hbWUgdGFibGUudmFyc1xuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGxldCBpbmRleCA9IG5ld19zbG90IHRhYmxlIGluXG4gICAgaWYgbmFtZSA8PiBcIlwiIHRoZW4gdGFibGUudmFycyA8LSBWYXJzLmFkZCBuYW1lIGluZGV4IHRhYmxlLnZhcnM7XG4gICAgaW5kZXhcblxubGV0IHRvX2FycmF5IGFyciA9XG4gIGlmIGFyciA9IE9iai5tYWdpYyAwIHRoZW4gW3x8XSBlbHNlIGFyclxuXG5sZXQgbmV3X21ldGhvZHNfdmFyaWFibGVzIHRhYmxlIG1ldGhzIHZhbHMgPVxuICBsZXQgbWV0aHMgPSB0b19hcnJheSBtZXRocyBpblxuICBsZXQgbm1ldGhzID0gQXJyYXkubGVuZ3RoIG1ldGhzIGFuZCBudmFscyA9IEFycmF5Lmxlbmd0aCB2YWxzIGluXG4gIGxldCByZXMgPSBBcnJheS5tYWtlIChubWV0aHMgKyBudmFscykgMCBpblxuICBmb3IgaSA9IDAgdG8gbm1ldGhzIC0gMSBkb1xuICAgIHJlcy4oaSkgPC0gZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSBtZXRocy4oaSlcbiAgZG9uZTtcbiAgZm9yIGkgPSAwIHRvIG52YWxzIC0gMSBkb1xuICAgIHJlcy4oaStubWV0aHMpIDwtIG5ld192YXJpYWJsZSB0YWJsZSB2YWxzLihpKVxuICBkb25lO1xuICByZXNcblxubGV0IGdldF92YXJpYWJsZSB0YWJsZSBuYW1lID1cbiAgdHJ5IFZhcnMuZmluZCBuYW1lIHRhYmxlLnZhcnMgd2l0aCBOb3RfZm91bmQgLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBnZXRfdmFyaWFibGVzIHRhYmxlIG5hbWVzID1cbiAgQXJyYXkubWFwIChnZXRfdmFyaWFibGUgdGFibGUpIG5hbWVzXG5cbmxldCBhZGRfaW5pdGlhbGl6ZXIgdGFibGUgZiA9XG4gIHRhYmxlLmluaXRpYWxpemVycyA8LSBmOjp0YWJsZS5pbml0aWFsaXplcnNcblxuKCpcbm1vZHVsZSBLZXlzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHRhZyBhcnJheSBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxubGV0IGtleV9tYXAgPSByZWYgS2V5cy5lbXB0eVxubGV0IGdldF9rZXkgdGFncyA6IGl0ZW0gPVxuICB0cnkgbWFnaWMgKEtleXMuZmluZCB0YWdzICFrZXlfbWFwIDogdGFnIGFycmF5KVxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGtleV9tYXAgOj0gS2V5cy5hZGQgdGFncyB0YWdzICFrZXlfbWFwO1xuICAgIG1hZ2ljIHRhZ3NcbiopXG5cbmxldCBjcmVhdGVfdGFibGUgcHVibGljX21ldGhvZHMgPVxuICBpZiBwdWJsaWNfbWV0aG9kcyA9PSBtYWdpYyAwIHRoZW4gbmV3X3RhYmxlIFt8fF0gZWxzZVxuICAoKiBbcHVibGljX21ldGhvZHNdIG11c3QgYmUgaW4gYXNjZW5kaW5nIG9yZGVyIGZvciBieXRlY29kZSAqKVxuICBsZXQgdGFncyA9IEFycmF5Lm1hcCBwdWJsaWNfbWV0aG9kX2xhYmVsIHB1YmxpY19tZXRob2RzIGluXG4gIGxldCB0YWJsZSA9IG5ld190YWJsZSB0YWdzIGluXG4gIEFycmF5Lml0ZXJpXG4gICAgKGZ1biBpIG1ldCAtPlxuICAgICAgbGV0IGxhYiA9IGkqMisyIGluXG4gICAgICB0YWJsZS5tZXRob2RzX2J5X25hbWUgIDwtIE1ldGhzLmFkZCBtZXQgbGFiIHRhYmxlLm1ldGhvZHNfYnlfbmFtZTtcbiAgICAgIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gTGFicy5hZGQgbGFiIHRydWUgdGFibGUubWV0aG9kc19ieV9sYWJlbClcbiAgICBwdWJsaWNfbWV0aG9kcztcbiAgdGFibGVcblxubGV0IGluaXRfY2xhc3MgdGFibGUgPVxuICBpbnN0X3Zhcl9jb3VudCA6PSAhaW5zdF92YXJfY291bnQgKyB0YWJsZS5zaXplIC0gMTtcbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIExpc3QucmV2IHRhYmxlLmluaXRpYWxpemVycztcbiAgcmVzaXplIHRhYmxlICgzICsgbWFnaWMgdGFibGUubWV0aG9kcy4oMSkgKiAxNiAvIFN5cy53b3JkX3NpemUpXG5cbmxldCBpbmhlcml0cyBjbGEgdmFscyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzIChfLCBzdXBlciwgXywgZW52KSB0b3AgPVxuICBuYXJyb3cgY2xhIHZhbHMgdmlydF9tZXRocyBjb25jcl9tZXRocztcbiAgbGV0IGluaXQgPVxuICAgIGlmIHRvcCB0aGVuIHN1cGVyIGNsYSBlbnYgZWxzZSBPYmoucmVwciAoc3VwZXIgY2xhKSBpblxuICB3aWRlbiBjbGE7XG4gIEFycmF5LmNvbmNhdFxuICAgIFtbfCByZXByIGluaXQgfF07XG4gICAgIG1hZ2ljIChBcnJheS5tYXAgKGdldF92YXJpYWJsZSBjbGEpICh0b19hcnJheSB2YWxzKSA6IGludCBhcnJheSk7XG4gICAgIEFycmF5Lm1hcFxuICAgICAgIChmdW4gbm0gLT4gcmVwciAoZ2V0X21ldGhvZCBjbGEgKGdldF9tZXRob2RfbGFiZWwgY2xhIG5tKSA6IGNsb3N1cmUpKVxuICAgICAgICh0b19hcnJheSBjb25jcl9tZXRocykgXVxuXG5sZXQgbWFrZV9jbGFzcyBwdWJfbWV0aHMgY2xhc3NfaW5pdCA9XG4gIGxldCB0YWJsZSA9IGNyZWF0ZV90YWJsZSBwdWJfbWV0aHMgaW5cbiAgbGV0IGVudl9pbml0ID0gY2xhc3NfaW5pdCB0YWJsZSBpblxuICBpbml0X2NsYXNzIHRhYmxlO1xuICAoZW52X2luaXQgKE9iai5yZXByIDApLCBjbGFzc19pbml0LCBlbnZfaW5pdCwgT2JqLnJlcHIgMClcblxudHlwZSBpbml0X3RhYmxlID0geyBtdXRhYmxlIGVudl9pbml0OiB0OyBtdXRhYmxlIGNsYXNzX2luaXQ6IHRhYmxlIC0+IHQgfVxuW0BAd2FybmluZyBcIi11bnVzZWQtZmllbGRcIl1cblxubGV0IG1ha2VfY2xhc3Nfc3RvcmUgcHViX21ldGhzIGNsYXNzX2luaXQgaW5pdF90YWJsZSA9XG4gIGxldCB0YWJsZSA9IGNyZWF0ZV90YWJsZSBwdWJfbWV0aHMgaW5cbiAgbGV0IGVudl9pbml0ID0gY2xhc3NfaW5pdCB0YWJsZSBpblxuICBpbml0X2NsYXNzIHRhYmxlO1xuICBpbml0X3RhYmxlLmNsYXNzX2luaXQgPC0gY2xhc3NfaW5pdDtcbiAgaW5pdF90YWJsZS5lbnZfaW5pdCA8LSBlbnZfaW5pdFxuXG5sZXQgZHVtbXlfY2xhc3MgbG9jID1cbiAgbGV0IHVuZGVmID0gZnVuIF8gLT4gcmFpc2UgKFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlIGxvYykgaW5cbiAgKE9iai5tYWdpYyB1bmRlZiwgdW5kZWYsIHVuZGVmLCBPYmoucmVwciAwKVxuXG4oKioqKiBPYmplY3RzICoqKiopXG5cbmxldCBjcmVhdGVfb2JqZWN0IHRhYmxlID1cbiAgKCogWFhYIEFwcGVsIGRlIFtvYmpfYmxvY2tdIHwgQ2FsbCB0byBbb2JqX2Jsb2NrXSAgKilcbiAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAoKiBYWFggQXBwZWwgZGUgW2NhbWxfbW9kaWZ5XSB8IENhbGwgdG8gW2NhbWxfbW9kaWZ5XSAqKVxuICBPYmouc2V0X2ZpZWxkIG9iaiAwIChPYmoucmVwciB0YWJsZS5tZXRob2RzKTtcbiAgT2JqLm9iaiAoc2V0X2lkIG9iailcblxubGV0IGNyZWF0ZV9vYmplY3Rfb3B0IG9ial8wIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqXzAgZWxzZSBiZWdpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbb2JqX2Jsb2NrXSB8IENhbGwgdG8gW29ial9ibG9ja10gICopXG4gICAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbY2FtbF9tb2RpZnldIHwgQ2FsbCB0byBbY2FtbF9tb2RpZnldICopXG4gICAgT2JqLnNldF9maWVsZCBvYmogMCAoT2JqLnJlcHIgdGFibGUubWV0aG9kcyk7XG4gICAgT2JqLm9iaiAoc2V0X2lkIG9iailcbiAgZW5kXG5cbmxldCByZWMgaXRlcl9mIG9iaiA9XG4gIGZ1bmN0aW9uXG4gICAgW10gICAtPiAoKVxuICB8IGY6OmwgLT4gZiBvYmo7IGl0ZXJfZiBvYmogbFxuXG5sZXQgcnVuX2luaXRpYWxpemVycyBvYmogdGFibGUgPVxuICBsZXQgaW5pdHMgPSB0YWJsZS5pbml0aWFsaXplcnMgaW5cbiAgaWYgaW5pdHMgPD4gW10gdGhlblxuICAgIGl0ZXJfZiBvYmogaW5pdHNcblxubGV0IHJ1bl9pbml0aWFsaXplcnNfb3B0IG9ial8wIG9iaiB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9iaiBlbHNlIGJlZ2luXG4gICAgbGV0IGluaXRzID0gdGFibGUuaW5pdGlhbGl6ZXJzIGluXG4gICAgaWYgaW5pdHMgPD4gW10gdGhlbiBpdGVyX2Ygb2JqIGluaXRzO1xuICAgIG9ialxuICBlbmRcblxubGV0IGNyZWF0ZV9vYmplY3RfYW5kX3J1bl9pbml0aWFsaXplcnMgb2JqXzAgdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmpfMCBlbHNlIGJlZ2luXG4gICAgbGV0IG9iaiA9IGNyZWF0ZV9vYmplY3QgdGFibGUgaW5cbiAgICBydW5faW5pdGlhbGl6ZXJzIG9iaiB0YWJsZTtcbiAgICBvYmpcbiAgZW5kXG5cbigqIEVxdWl2YWxlbnQgcHJpbWl0aXZlIGJlbG93XG5sZXQgc2VuZHNlbGYgb2JqIGxhYiA9XG4gIChtYWdpYyBvYmogOiAob2JqIC0+IHQpIGFycmF5IGFycmF5KS4oMCkuKGxhYikgb2JqXG4qKVxuZXh0ZXJuYWwgc2VuZCA6IG9iaiAtPiB0YWcgLT4gJ2EgPSBcIiVzZW5kXCJcbmV4dGVybmFsIHNlbmRjYWNoZSA6IG9iaiAtPiB0YWcgLT4gdCAtPiBpbnQgLT4gJ2EgPSBcIiVzZW5kY2FjaGVcIlxuZXh0ZXJuYWwgc2VuZHNlbGYgOiBvYmogLT4gbGFiZWwgLT4gJ2EgPSBcIiVzZW5kc2VsZlwiXG5leHRlcm5hbCBnZXRfcHVibGljX21ldGhvZCA6IG9iaiAtPiB0YWcgLT4gY2xvc3VyZVxuICAgID0gXCJjYW1sX2dldF9wdWJsaWNfbWV0aG9kXCIgW0BAbm9hbGxvY11cblxuKCoqKiogdGFibGUgY29sbGVjdGlvbiBhY2Nlc3MgKioqKilcblxudHlwZSB0YWJsZXMgPVxuICB8IEVtcHR5XG4gIHwgQ29ucyBvZiB7a2V5IDogY2xvc3VyZTsgbXV0YWJsZSBkYXRhOiB0YWJsZXM7IG11dGFibGUgbmV4dDogdGFibGVzfVxuXG5sZXQgc2V0X2RhdGEgdGFibGVzIHYgPSBtYXRjaCB0YWJsZXMgd2l0aFxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5kYXRhIDwtIHZcbmxldCBzZXRfbmV4dCB0YWJsZXMgdiA9IG1hdGNoIHRhYmxlcyB3aXRoXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHQgPC0gdlxubGV0IGdldF9rZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5rZXlcbmxldCBnZXRfZGF0YSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmRhdGFcbmxldCBnZXRfbmV4dCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHRcblxubGV0IGJ1aWxkX3BhdGggbiBrZXlzIHRhYmxlcyA9XG4gIGxldCByZXMgPSBDb25zIHtrZXkgPSBPYmoubWFnaWMgMDsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gIGxldCByID0gcmVmIHJlcyBpblxuICBmb3IgaSA9IDAgdG8gbiBkb1xuICAgIHIgOj0gQ29ucyB7a2V5ID0ga2V5cy4oaSk7IGRhdGEgPSAhcjsgbmV4dCA9IEVtcHR5fVxuICBkb25lO1xuICBzZXRfZGF0YSB0YWJsZXMgIXI7XG4gIHJlc1xuXG5sZXQgcmVjIGxvb2t1cF9rZXlzIGkga2V5cyB0YWJsZXMgPVxuICBpZiBpIDwgMCB0aGVuIHRhYmxlcyBlbHNlXG4gIGxldCBrZXkgPSBrZXlzLihpKSBpblxuICBsZXQgcmVjIGxvb2t1cF9rZXkgKHRhYmxlczp0YWJsZXMpID1cbiAgICBpZiBnZXRfa2V5IHRhYmxlcyA9PSBrZXkgdGhlblxuICAgICAgbWF0Y2ggZ2V0X2RhdGEgdGFibGVzIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IENvbnMgXyBhcyB0YWJsZXNfZGF0YSAtPlxuICAgICAgICAgIGxvb2t1cF9rZXlzIChpLTEpIGtleXMgdGFibGVzX2RhdGFcbiAgICBlbHNlXG4gICAgICBtYXRjaCBnZXRfbmV4dCB0YWJsZXMgd2l0aFxuICAgICAgfCBDb25zIF8gYXMgbmV4dCAtPiBsb29rdXBfa2V5IG5leHRcbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBsZXQgbmV4dCA6IHRhYmxlcyA9IENvbnMge2tleTsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gICAgICAgICAgc2V0X25leHQgdGFibGVzIG5leHQ7XG4gICAgICAgICAgYnVpbGRfcGF0aCAoaS0xKSBrZXlzIG5leHRcbiAgaW5cbiAgbG9va3VwX2tleSB0YWJsZXNcblxubGV0IGxvb2t1cF90YWJsZXMgcm9vdCBrZXlzID1cbiAgbWF0Y2ggZ2V0X2RhdGEgcm9vdCB3aXRoXG4gIHwgQ29ucyBfIGFzIHJvb3RfZGF0YSAtPlxuICAgIGxvb2t1cF9rZXlzIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdF9kYXRhXG4gIHwgRW1wdHkgLT5cbiAgICBidWlsZF9wYXRoIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdFxuXG4oKioqKiBidWlsdGluIG1ldGhvZHMgKioqKilcblxubGV0IGdldF9jb25zdCB4ID0gcmV0IChmdW4gX29iaiAtPiB4KVxubGV0IGdldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIC0+IEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pXG5sZXQgZ2V0X2VudiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKVxubGV0IGdldF9tZXRoIG4gID0gcmV0IChmdW4gb2JqIC0+IHNlbmRzZWxmIG9iaiBuKVxubGV0IHNldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIHggLT4gQXJyYXkudW5zYWZlX3NldCBvYmogbiB4KVxubGV0IGFwcF9jb25zdCBmIHggPSByZXQgKGZ1biBfb2JqIC0+IGYgeClcbmxldCBhcHBfdmFyIGYgbiAgID0gcmV0IChmdW4gb2JqIC0+IGYgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9lbnYgZiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSlcbmxldCBhcHBfbWV0aCBmIG4gID0gcmV0IChmdW4gb2JqIC0+IGYgKHNlbmRzZWxmIG9iaiBuKSlcbmxldCBhcHBfY29uc3RfY29uc3QgZiB4IHkgPSByZXQgKGZ1biBfb2JqIC0+IGYgeCB5KVxubGV0IGFwcF9jb25zdF92YXIgZiB4IG4gICA9IHJldCAoZnVuIG9iaiAtPiBmIHggKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9jb25zdF9tZXRoIGYgeCBuID0gcmV0IChmdW4gb2JqIC0+IGYgeCAoc2VuZHNlbGYgb2JqIG4pKVxubGV0IGFwcF92YXJfY29uc3QgZiBuIHggPSByZXQgKGZ1biBvYmogLT4gZiAoQXJyYXkudW5zYWZlX2dldCBvYmogbikgeClcbmxldCBhcHBfbWV0aF9jb25zdCBmIG4geCA9IHJldCAoZnVuIG9iaiAtPiBmIChzZW5kc2VsZiBvYmogbikgeClcbmxldCBhcHBfY29uc3RfZW52IGYgeCBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIHggKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pKVxubGV0IGFwcF9lbnZfY29uc3QgZiBlIG4geCA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pIHgpXG5sZXQgbWV0aF9hcHBfY29uc3QgbiB4ID0gcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgeClcbmxldCBtZXRoX2FwcF92YXIgbiBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG0pKVxubGV0IG1ldGhfYXBwX2VudiBuIGUgbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pXG4gICAgICAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbSkpXG5sZXQgbWV0aF9hcHBfbWV0aCBuIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSAoc2VuZHNlbGYgb2JqIG0pKVxubGV0IHNlbmRfY29uc3QgbSB4IGMgPVxuICByZXQgKGZ1biBvYmogLT4gc2VuZGNhY2hlIHggbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX3ZhciBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSA6IG9iaikgbVxuICAgICAgKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF9lbnYgbSBlIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZVxuICAgICAgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldFxuICAgICAgICAgICAgICAgICAgICAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikgOiBvYmopXG4gICAgICBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfbWV0aCBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoc2VuZHNlbGYgb2JqIG4pIG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgbmV3X2NhY2hlIHRhYmxlID1cbiAgbGV0IG4gPSBuZXdfbWV0aG9kIHRhYmxlIGluXG4gIGxldCBuID1cbiAgICBpZiBuIG1vZCAyID0gMCB8fCBuID4gMiArIG1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplXG4gICAgdGhlbiBuIGVsc2UgbmV3X21ldGhvZCB0YWJsZVxuICBpblxuICB0YWJsZS5tZXRob2RzLihuKSA8LSBPYmoubWFnaWMgMDtcbiAgblxuXG50eXBlIGltcGwgPVxuICAgIEdldENvbnN0XG4gIHwgR2V0VmFyXG4gIHwgR2V0RW52XG4gIHwgR2V0TWV0aFxuICB8IFNldFZhclxuICB8IEFwcENvbnN0XG4gIHwgQXBwVmFyXG4gIHwgQXBwRW52XG4gIHwgQXBwTWV0aFxuICB8IEFwcENvbnN0Q29uc3RcbiAgfCBBcHBDb25zdFZhclxuICB8IEFwcENvbnN0RW52XG4gIHwgQXBwQ29uc3RNZXRoXG4gIHwgQXBwVmFyQ29uc3RcbiAgfCBBcHBFbnZDb25zdFxuICB8IEFwcE1ldGhDb25zdFxuICB8IE1ldGhBcHBDb25zdFxuICB8IE1ldGhBcHBWYXJcbiAgfCBNZXRoQXBwRW52XG4gIHwgTWV0aEFwcE1ldGhcbiAgfCBTZW5kQ29uc3RcbiAgfCBTZW5kVmFyXG4gIHwgU2VuZEVudlxuICB8IFNlbmRNZXRoXG4gIHwgQ2xvc3VyZSBvZiBjbG9zdXJlXG5cbmxldCBtZXRob2RfaW1wbCB0YWJsZSBpIGFyciA9XG4gIGxldCBuZXh0ICgpID0gaW5jciBpOyBtYWdpYyBhcnIuKCFpKSBpblxuICBtYXRjaCBuZXh0KCkgd2l0aFxuICAgIEdldENvbnN0IC0+IGxldCB4IDogdCA9IG5leHQoKSBpbiBnZXRfY29uc3QgeFxuICB8IEdldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIGdldF92YXIgblxuICB8IEdldEVudiAgIC0+IGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGdldF9lbnYgZSBuXG4gIHwgR2V0TWV0aCAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X21ldGggblxuICB8IFNldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIHNldF92YXIgblxuICB8IEFwcENvbnN0IC0+IGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGFwcF9jb25zdCBmIHhcbiAgfCBBcHBWYXIgICAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gYXBwX3ZhciBmIG5cbiAgfCBBcHBFbnYgICAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gIGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfZW52IGYgZSBuXG4gIHwgQXBwTWV0aCAgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIGFwcF9tZXRoIGYgblxuICB8IEFwcENvbnN0Q29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCB5ID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfY29uc3QgZiB4IHlcbiAgfCBBcHBDb25zdFZhciAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF92YXIgZiB4IG5cbiAgfCBBcHBDb25zdEVudiAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0ICgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfZW52IGYgeCBlIG5cbiAgfCBBcHBDb25zdE1ldGggLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfbWV0aCBmIHggblxuICB8IEFwcFZhckNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX3Zhcl9jb25zdCBmIG4geFxuICB8IEFwcEVudkNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQgKCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9lbnZfY29uc3QgZiBlIG4geFxuICB8IEFwcE1ldGhDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9tZXRoX2NvbnN0IGYgbiB4XG4gIHwgTWV0aEFwcENvbnN0IC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBtZXRoX2FwcF9jb25zdCBuIHhcbiAgfCBNZXRoQXBwVmFyIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF92YXIgbiBtXG4gIHwgTWV0aEFwcEVudiAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW5cbiAgICAgIG1ldGhfYXBwX2VudiBuIGUgbVxuICB8IE1ldGhBcHBNZXRoIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF9tZXRoIG4gbVxuICB8IFNlbmRDb25zdCAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gc2VuZF9jb25zdCBtIHggKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kVmFyIC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gc2VuZF92YXIgbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZEVudiAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIHNlbmRfZW52IG0gZSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZE1ldGggLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBzZW5kX21ldGggbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgQ2xvc3VyZSBfIGFzIGNsbyAtPiBtYWdpYyBjbG9cblxubGV0IHNldF9tZXRob2RzIHRhYmxlIG1ldGhvZHMgPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIG1ldGhvZHMgaW4gbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiBkb1xuICAgIGxldCBsYWJlbCA9IG1ldGhvZHMuKCFpKSBpbiBsZXQgY2xvID0gbWV0aG9kX2ltcGwgdGFibGUgaSBtZXRob2RzIGluXG4gICAgc2V0X21ldGhvZCB0YWJsZSBsYWJlbCBjbG87XG4gICAgaW5jciBpXG4gIGRvbmVcblxuKCoqKiogU3RhdGlzdGljcyAqKioqKVxuXG50eXBlIHN0YXRzID1cbiAgeyBjbGFzc2VzOiBpbnQ7IG1ldGhvZHM6IGludDsgaW5zdF92YXJzOiBpbnQ7IH1cblxubGV0IHN0YXRzICgpID1cbiAgeyBjbGFzc2VzID0gIXRhYmxlX2NvdW50O1xuICAgIG1ldGhvZHMgPSAhbWV0aG9kX2NvdW50OyBpbnN0X3ZhcnMgPSAhaW5zdF92YXJfY291bnQ7IH1cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBzaGFwZSA9XG4gIHwgRnVuY3Rpb25cbiAgfCBMYXp5XG4gIHwgQ2xhc3NcbiAgfCBNb2R1bGUgb2Ygc2hhcGUgYXJyYXlcbiAgfCBWYWx1ZSBvZiBPYmoudFxuXG5sZXQgcmVjIGluaXRfbW9kX2ZpZWxkIG1vZHUgaSBsb2Mgc2hhcGUgPVxuICBsZXQgaW5pdCA9XG4gICAgbWF0Y2ggc2hhcGUgd2l0aFxuICAgIHwgRnVuY3Rpb24gLT5cbiAgICAgICBsZXQgcmVjIGZuICh4IDogJ2EpID1cbiAgICAgICAgIGxldCBmbicgOiAnYSAtPiAnYiA9IE9iai5vYmogKE9iai5maWVsZCBtb2R1IGkpIGluXG4gICAgICAgICBpZiBmbiA9PSBmbicgdGhlblxuICAgICAgICAgICByYWlzZSAoVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgbG9jKVxuICAgICAgICAgZWxzZVxuICAgICAgICAgICBmbicgeCBpblxuICAgICAgIE9iai5yZXByIGZuXG4gICAgfCBMYXp5IC0+XG4gICAgICAgbGV0IHJlYyBsID1cbiAgICAgICAgIGxhenkgKFxuICAgICAgICAgICBsZXQgbCcgPSBPYmoub2JqIChPYmouZmllbGQgbW9kdSBpKSBpblxuICAgICAgICAgICBpZiBsID09IGwnIHRoZW5cbiAgICAgICAgICAgICByYWlzZSAoVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgbG9jKVxuICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgTGF6eS5mb3JjZSBsJykgaW5cbiAgICAgICBPYmoucmVwciBsXG4gICAgfCBDbGFzcyAtPlxuICAgICAgIE9iai5yZXByIChDYW1saW50ZXJuYWxPTy5kdW1teV9jbGFzcyBsb2MpXG4gICAgfCBNb2R1bGUgY29tcHMgLT5cbiAgICAgICBPYmoucmVwciAoaW5pdF9tb2RfYmxvY2sgbG9jIGNvbXBzKVxuICAgIHwgVmFsdWUgdiAtPiB2XG4gIGluXG4gIE9iai5zZXRfZmllbGQgbW9kdSBpIGluaXRcblxuYW5kIGluaXRfbW9kX2Jsb2NrIGxvYyBjb21wcyA9XG4gIGxldCBsZW5ndGggPSBBcnJheS5sZW5ndGggY29tcHMgaW5cbiAgbGV0IG1vZHUgPSBPYmoubmV3X2Jsb2NrIDAgbGVuZ3RoIGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggLSAxIGRvXG4gICAgaW5pdF9tb2RfZmllbGQgbW9kdSBpIGxvYyBjb21wcy4oaSlcbiAgZG9uZTtcbiAgbW9kdVxuXG5sZXQgaW5pdF9tb2QgbG9jIHNoYXBlID1cbiAgbWF0Y2ggc2hhcGUgd2l0aFxuICB8IE1vZHVsZSBjb21wcyAtPlxuICAgICBPYmoucmVwciAoaW5pdF9tb2RfYmxvY2sgbG9jIGNvbXBzKVxuICB8IF8gLT4gZmFpbHdpdGggXCJDYW1saW50ZXJuYWxNb2QuaW5pdF9tb2Q6IG5vdCBhIG1vZHVsZVwiXG5cbmxldCByZWMgdXBkYXRlX21vZF9maWVsZCBtb2R1IGkgc2hhcGUgbiA9XG4gIG1hdGNoIHNoYXBlIHdpdGhcbiAgfCBGdW5jdGlvbiB8IExhenkgLT5cbiAgICAgT2JqLnNldF9maWVsZCBtb2R1IGkgblxuICB8IFZhbHVlIF8gLT5cbiAgICAgKCkgKCogdGhlIHZhbHVlIGlzIGFscmVhZHkgdGhlcmUgKilcbiAgfCBDbGFzcyAtPlxuICAgICBhc3NlcnQgKE9iai50YWcgbiA9IDAgJiYgT2JqLnNpemUgbiA9IDQpO1xuICAgICBsZXQgY2wgPSBPYmouZmllbGQgbW9kdSBpIGluXG4gICAgIGZvciBqID0gMCB0byAzIGRvXG4gICAgICAgT2JqLnNldF9maWVsZCBjbCBqIChPYmouZmllbGQgbiBqKVxuICAgICBkb25lXG4gIHwgTW9kdWxlIGNvbXBzIC0+XG4gICAgIHVwZGF0ZV9tb2RfYmxvY2sgY29tcHMgKE9iai5maWVsZCBtb2R1IGkpIG5cblxuYW5kIHVwZGF0ZV9tb2RfYmxvY2sgY29tcHMgbyBuID1cbiAgYXNzZXJ0IChPYmoudGFnIG4gPSAwICYmIE9iai5zaXplIG4gPj0gQXJyYXkubGVuZ3RoIGNvbXBzKTtcbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBjb21wcyAtIDEgZG9cbiAgICB1cGRhdGVfbW9kX2ZpZWxkIG8gaSBjb21wcy4oaSkgKE9iai5maWVsZCBuIGkpXG4gIGRvbmVcblxubGV0IHVwZGF0ZV9tb2Qgc2hhcGUgbyBuID1cbiAgbWF0Y2ggc2hhcGUgd2l0aFxuICB8IE1vZHVsZSBjb21wcyAtPlxuICAgICB1cGRhdGVfbW9kX2Jsb2NrIGNvbXBzIG8gblxuICB8IF8gLT4gZmFpbHdpdGggXCJDYW1saW50ZXJuYWxNb2QudXBkYXRlX21vZDogbm90IGEgbW9kdWxlXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0b2tlbiA9XG4gICAgS3dkIG9mIHN0cmluZ1xuICB8IElkZW50IG9mIHN0cmluZ1xuICB8IEludCBvZiBpbnRcbiAgfCBGbG9hdCBvZiBmbG9hdFxuICB8IFN0cmluZyBvZiBzdHJpbmdcbiAgfCBDaGFyIG9mIGNoYXJcblxuKCogVGhlIHN0cmluZyBidWZmZXJpbmcgbWFjaGluZXJ5ICopXG5cbmxldCBpbml0aWFsX2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAzMlxuXG5sZXQgYnVmZmVyID0gcmVmIGluaXRpYWxfYnVmZmVyXG5sZXQgYnVmcG9zID0gcmVmIDBcblxubGV0IHJlc2V0X2J1ZmZlciAoKSA9IGJ1ZmZlciA6PSBpbml0aWFsX2J1ZmZlcjsgYnVmcG9zIDo9IDBcblxubGV0IHN0b3JlIGMgPVxuICBpZiAhYnVmcG9zID49IEJ5dGVzLmxlbmd0aCAhYnVmZmVyIHRoZW4gYmVnaW5cbiAgICBsZXQgbmV3YnVmZmVyID0gQnl0ZXMuY3JlYXRlICgyICogIWJ1ZnBvcykgaW5cbiAgICBCeXRlcy5ibGl0ICFidWZmZXIgMCBuZXdidWZmZXIgMCAhYnVmcG9zO1xuICAgIGJ1ZmZlciA6PSBuZXdidWZmZXJcbiAgZW5kO1xuICBCeXRlcy5zZXQgIWJ1ZmZlciAhYnVmcG9zIGM7XG4gIGluY3IgYnVmcG9zXG5cbmxldCBnZXRfc3RyaW5nICgpID1cbiAgbGV0IHMgPSBCeXRlcy5zdWJfc3RyaW5nICFidWZmZXIgMCAhYnVmcG9zIGluIGJ1ZmZlciA6PSBpbml0aWFsX2J1ZmZlcjsgc1xuXG4oKiBUaGUgbGV4ZXIgKilcblxubGV0IG1ha2VfbGV4ZXIga2V5d29yZHMgPVxuICBsZXQga3dkX3RhYmxlID0gSGFzaHRibC5jcmVhdGUgMTcgaW5cbiAgTGlzdC5pdGVyIChmdW4gcyAtPiBIYXNodGJsLmFkZCBrd2RfdGFibGUgcyAoS3dkIHMpKSBrZXl3b3JkcztcbiAgbGV0IGlkZW50X29yX2tleXdvcmQgaWQgPVxuICAgIHRyeSBIYXNodGJsLmZpbmQga3dkX3RhYmxlIGlkIHdpdGhcbiAgICAgIE5vdF9mb3VuZCAtPiBJZGVudCBpZFxuICBhbmQga2V5d29yZF9vcl9lcnJvciBjID1cbiAgICBsZXQgcyA9IFN0cmluZy5tYWtlIDEgYyBpblxuICAgIHRyeSBIYXNodGJsLmZpbmQga3dkX3RhYmxlIHMgd2l0aFxuICAgICAgTm90X2ZvdW5kIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgKFwiSWxsZWdhbCBjaGFyYWN0ZXIgXCIgXiBzKSlcbiAgaW5cbiAgbGV0IHJlYyBuZXh0X3Rva2VuIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcgJyB8ICdcXDAxMCcgfCAnXFwwMTMnIHwgJ1xcMDA5JyB8ICdcXDAyNicgfCAnXFwwMTInKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IG5leHRfdG9rZW4gc3RybV9fXG4gICAgfCBTb21lICgnQScuLidaJyB8ICdhJy4uJ3onIHwgJ18nIHwgJ1xcMTkyJy4uJ1xcMjU1JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgaWRlbnQgc1xuICAgIHwgU29tZVxuICAgICAgICAoJyEnIHwgJyUnIHwgJyYnIHwgJyQnIHwgJyMnIHwgJysnIHwgJy8nIHwgJzonIHwgJzwnIHwgJz0nIHwgJz4nIHxcbiAgICAgICAgICc/JyB8ICdAJyB8ICdcXFxcJyB8ICd+JyB8ICdeJyB8ICd8JyB8ICcqJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgaWRlbnQyIHNcbiAgICB8IFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgU29tZSAnXFwnJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBjID1cbiAgICAgICAgICB0cnkgY2hhciBzdHJtX18gd2l0aFxuICAgICAgICAgICAgU3RyZWFtLkZhaWx1cmUgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBpblxuICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgIFNvbWUgJ1xcJycgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBTb21lIChDaGFyIGMpXG4gICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSAnXFxcIicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IFNvbWUgKFN0cmluZyAoc3RyaW5nIHMpKVxuICAgIHwgU29tZSAnLScgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBuZWdfbnVtYmVyIHN0cm1fX1xuICAgIHwgU29tZSAnKCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgU29tZSAoa2V5d29yZF9vcl9lcnJvciBjKVxuICAgIHwgXyAtPiBOb25lXG4gIGFuZCBpZGVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lXG4gICAgICAgICgnQScuLidaJyB8ICdhJy4uJ3onIHwgJ1xcMTkyJy4uJ1xcMjU1JyB8ICcwJy4uJzknIHwgJ18nIHwgJ1xcJycgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBpZGVudCBzXG4gICAgfCBfIC0+IFNvbWUgKGlkZW50X29yX2tleXdvcmQgKGdldF9zdHJpbmcgKCkpKVxuICBhbmQgaWRlbnQyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWVcbiAgICAgICAgKCchJyB8ICclJyB8ICcmJyB8ICckJyB8ICcjJyB8ICcrJyB8ICctJyB8ICcvJyB8ICc6JyB8ICc8JyB8ICc9JyB8XG4gICAgICAgICAnPicgfCAnPycgfCAnQCcgfCAnXFxcXCcgfCAnficgfCAnXicgfCAnfCcgfCAnKicgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBpZGVudDIgc1xuICAgIHwgXyAtPiBTb21lIChpZGVudF9vcl9rZXl3b3JkIChnZXRfc3RyaW5nICgpKSlcbiAgYW5kIG5lZ19udW1iZXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlICctJzsgc3RvcmUgYzsgbnVtYmVyIHNcbiAgICB8IF8gLT4gbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSAnLSc7IGlkZW50MiBzXG4gIGFuZCBudW1iZXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgU29tZSAnLicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnLic7IGRlY2ltYWxfcGFydCBzXG4gICAgfCBTb21lICgnZScgfCAnRScpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJ0UnOyBleHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoSW50IChpbnRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBkZWNpbWFsX3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBkZWNpbWFsX3BhcnQgc1xuICAgIHwgU29tZSAoJ2UnIHwgJ0UnKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICdFJzsgZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEZsb2F0IChmbG9hdF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIGV4cG9uZW50X3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJysnIHwgJy0nIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZW5kX2V4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBlbmRfZXhwb25lbnRfcGFydCBzdHJtX19cbiAgYW5kIGVuZF9leHBvbmVudF9wYXJ0IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZW5kX2V4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChGbG9hdCAoZmxvYXRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBzdHJpbmcgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnXFxcIicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBnZXRfc3RyaW5nICgpXG4gICAgfCBTb21lICdcXFxcJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBjID1cbiAgICAgICAgICB0cnkgZXNjYXBlIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IHN0cmluZyBzXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBzdHJpbmcgc1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgY2hhciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICdcXFxcJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGJlZ2luIHRyeSBlc2NhcGUgc3RybV9fIHdpdGhcbiAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgZXNjYXBlIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ24nIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xcbidcbiAgICB8IFNvbWUgJ3InIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xccidcbiAgICB8IFNvbWUgJ3QnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xcdCdcbiAgICB8IFNvbWUgKCcwJy4uJzknIGFzIGMxKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU29tZSAoJzAnLi4nOScgYXMgYzIpIC0+XG4gICAgICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgICAgICBTb21lICgnMCcuLic5JyBhcyBjMykgLT5cbiAgICAgICAgICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgICAgICAgICAgQ2hhci5jaHJcbiAgICAgICAgICAgICAgICAgICgoQ2hhci5jb2RlIGMxIC0gNDgpICogMTAwICsgKENoYXIuY29kZSBjMiAtIDQ4KSAqIDEwICtcbiAgICAgICAgICAgICAgICAgICAgIChDaGFyLmNvZGUgYzMgLSA0OCkpXG4gICAgICAgICAgICB8IF8gLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcqJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIGNvbW1lbnQgczsgbmV4dF90b2tlbiBzXG4gICAgfCBfIC0+IFNvbWUgKGtleXdvcmRfb3JfZXJyb3IgJygnKVxuICBhbmQgY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcoJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX25lc3RlZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9lbmRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9uZXN0ZWRfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIGNvbW1lbnQgczsgY29tbWVudCBzXG4gICAgfCBTb21lIF8gLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjb21tZW50IHN0cm1fX1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfZW5kX2NvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKScgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAoKVxuICAgIHwgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9lbmRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGluXG4gIGZ1biBpbnB1dCAtPiBTdHJlYW0uZnJvbSAoZnVuIF9jb3VudCAtPiBuZXh0X3Rva2VuIGlucHV0KVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgdHlwZSBTZWVkZWRTID0gc2lnXG4gIGluY2x1ZGUgSGFzaHRibC5TZWVkZWRTXG4gIHZhbCBjbGVhbjogJ2EgdCAtPiB1bml0XG4gIHZhbCBzdGF0c19hbGl2ZTogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgICAoKiogc2FtZSBhcyB7IXN0YXRzfSBidXQgb25seSBjb3VudCB0aGUgYWxpdmUgYmluZGluZ3MgKilcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIGluY2x1ZGUgSGFzaHRibC5TXG4gIHZhbCBjbGVhbjogJ2EgdCAtPiB1bml0XG4gIHZhbCBzdGF0c19hbGl2ZTogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgICAoKiogc2FtZSBhcyB7IXN0YXRzfSBidXQgb25seSBjb3VudCB0aGUgYWxpdmUgYmluZGluZ3MgKilcbmVuZFxuXG5tb2R1bGUgR2VuSGFzaFRhYmxlID0gc3RydWN0XG5cbiAgdHlwZSBlcXVhbCA9XG4gIHwgRVRydWUgfCBFRmFsc2VcbiAgfCBFRGVhZCAoKiogdGhlIGdhcmJhZ2UgY29sbGVjdG9yIHJlY2xhaW1lZCB0aGUgZGF0YSAqKVxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkKEg6IHNpZ1xuICAgIHR5cGUgdFxuICAgIHR5cGUgJ2EgY29udGFpbmVyXG4gICAgdmFsIGNyZWF0ZTogdCAtPiAnYSAtPiAnYSBjb250YWluZXJcbiAgICB2YWwgaGFzaDogaW50IC0+IHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAnYSBjb250YWluZXIgLT4gdCAtPiBlcXVhbFxuICAgIHZhbCBnZXRfZGF0YTogJ2EgY29udGFpbmVyIC0+ICdhIG9wdGlvblxuICAgIHZhbCBnZXRfa2V5OiAnYSBjb250YWluZXIgLT4gdCBvcHRpb25cbiAgICB2YWwgc2V0X2tleV9kYXRhOiAnYSBjb250YWluZXIgLT4gdCAtPiAnYSAtPiB1bml0XG4gICAgdmFsIGNoZWNrX2tleTogJ2EgY29udGFpbmVyIC0+IGJvb2xcbiAgZW5kKSA6IFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudFxuICA9IHN0cnVjdFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgbXV0YWJsZSBzaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogbnVtYmVyIG9mIGVudHJpZXMgKilcbiAgICAgICAgbXV0YWJsZSBkYXRhOiAnYSBidWNrZXRsaXN0IGFycmF5OyAgKCogdGhlIGJ1Y2tldHMgKilcbiAgICAgICAgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICAgKCogZm9yIHJhbmRvbWl6YXRpb24gKilcbiAgICAgICAgaW5pdGlhbF9zaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gICAgICB9XG5cbiAgICBhbmQgJ2EgYnVja2V0bGlzdCA9XG4gICAgfCBFbXB0eVxuICAgIHwgQ29ucyBvZiBpbnQgKCogaGFzaCBvZiB0aGUga2V5ICopICogJ2EgSC5jb250YWluZXIgKiAnYSBidWNrZXRsaXN0XG5cbiAgICAoKiogdGhlIGhhc2ggb2YgdGhlIGtleSBpcyBrZXB0IGluIG9yZGVyIHRvIHRlc3QgdGhlIGVxdWFsaXR5IG9mIHRoZSBoYXNoXG4gICAgICBiZWZvcmUgdGhlIGtleS4gU2FtZSByZWFzb24gYXMgZm9yIFdlYWsuTWFrZSAqKVxuXG4gICAgdHlwZSBrZXkgPSBILnRcblxuICAgIGxldCByZWMgcG93ZXJfMl9hYm92ZSB4IG4gPVxuICAgICAgaWYgeCA+PSBuIHRoZW4geFxuICAgICAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICAgICAgZWxzZSBwb3dlcl8yX2Fib3ZlICh4ICogMikgblxuXG4gICAgbGV0IHBybmcgPSBsYXp5IChSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQoKSlcblxuICAgIGxldCBjcmVhdGUgPyhyYW5kb20gPSAoSGFzaHRibC5pc19yYW5kb21pemVkICgpKSkgaW5pdGlhbF9zaXplID1cbiAgICAgIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgICAgIGxldCBzZWVkID0gaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZykgZWxzZSAwIGluXG4gICAgICB7IGluaXRpYWxfc2l6ZSA9IHM7IHNpemUgPSAwOyBzZWVkID0gc2VlZDsgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eSB9XG5cbiAgICBsZXQgY2xlYXIgaCA9XG4gICAgICBoLnNpemUgPC0gMDtcbiAgICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgICBoLmRhdGEuKGkpIDwtIEVtcHR5XG4gICAgICBkb25lXG5cbiAgICBsZXQgcmVzZXQgaCA9XG4gICAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICAgICAgaWYgbGVuID0gaC5pbml0aWFsX3NpemUgdGhlblxuICAgICAgICBjbGVhciBoXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGguc2l6ZSA8LSAwO1xuICAgICAgICBoLmRhdGEgPC0gQXJyYXkubWFrZSBoLmluaXRpYWxfc2l6ZSBFbXB0eVxuICAgICAgZW5kXG5cbiAgICBsZXQgY29weSBoID0geyBoIHdpdGggZGF0YSA9IEFycmF5LmNvcHkgaC5kYXRhIH1cblxuICAgIGxldCBrZXlfaW5kZXggaCBoa2V5ID1cbiAgICAgIGhrZXkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG5cbiAgICBsZXQgY2xlYW4gaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIEVtcHR5XG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSB3aGVuIG5vdCAoSC5jaGVja19rZXkgYykgLT5cbiAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgfCBDb25zKGhrZXksIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBDb25zKGhrZXksIGMsIGRvX2J1Y2tldCByZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGQuKGkpIDwtIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgKCoqIHJlc2l6ZSBpcyB0aGUgb25seSBmdW5jdGlvbiB0byBkbyB0aGUgYWN0dWFsIGNsZWFuaW5nIG9mIGRlYWQga2V5c1xuICAgICAgICAocmVtb3ZlIGRvZXMgaXQganVzdCBiZWNhdXNlIGl0IGNvdWxkKS5cblxuICAgICAgICBUaGUgZ29hbCBpcyB0bzpcblxuICAgICAgICAtIG5vdCByZXNpemUgaW5maW5pdGVseSB3aGVuIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGFsaXZlIGtleXMgaXNcbiAgICAgICAgYm91bmRlZCBidXQga2V5cyBhcmUgY29udGludW91c2x5IGFkZGVkLiBUaGF0IHdvdWxkIGhhcHBlbiBpZlxuICAgICAgICB0aGlzIGZ1bmN0aW9uIGFsd2F5cyByZXNpemUuXG4gICAgICAgIC0gbm90IGNhbGwgdGhpcyBmdW5jdGlvbiBhZnRlciBlYWNoIGFkZGl0aW9uLCB0aGF0IHdvdWxkIGhhcHBlbiBpZiB0aGlzXG4gICAgICAgIGZ1bmN0aW9uIGRvbid0IHJlc2l6ZSBldmVuIHdoZW4gb25seSBvbmUga2V5IGlzIGRlYWQuXG5cbiAgICAgICAgU28gdGhlIGFsZ29yaXRobTpcbiAgICAgICAgLSBjbGVhbiB0aGUga2V5cyBiZWZvcmUgcmVzaXppbmdcbiAgICAgICAgLSBpZiB0aGUgbnVtYmVyIG9mIHJlbWFpbmluZyBrZXlzIGlzIGxlc3MgdGhhbiBoYWxmIHRoZSBzaXplIG9mIHRoZVxuICAgICAgICBhcnJheSwgZG9uJ3QgcmVzaXplLlxuICAgICAgICAtIGlmIGl0IGlzIG1vcmUsIHJlc2l6ZS5cblxuICAgICAgICBUaGUgc2Vjb25kIHByb2JsZW0gcmVtYWlucyBpZiB0aGUgdGFibGUgcmVhY2hlcyB7IVN5cy5tYXhfYXJyYXlfbGVuZ3RofS5cblxuICAgICopXG4gICAgbGV0IHJlc2l6ZSBoID1cbiAgICAgIGxldCBvZGF0YSA9IGguZGF0YSBpblxuICAgICAgbGV0IG9zaXplID0gQXJyYXkubGVuZ3RoIG9kYXRhIGluXG4gICAgICBsZXQgbnNpemUgPSBvc2l6ZSAqIDIgaW5cbiAgICAgIGNsZWFuIGg7XG4gICAgICBpZiBuc2l6ZSA8IFN5cy5tYXhfYXJyYXlfbGVuZ3RoICYmIGguc2l6ZSA+PSBvc2l6ZSBsc3IgMSB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBuZGF0YSA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICAgICAgaC5kYXRhIDwtIG5kYXRhOyAgICAgICAoKiBzbyB0aGF0IGtleV9pbmRleCBzZWVzIHRoZSBuZXcgYnVja2V0IGNvdW50ICopXG4gICAgICAgIGxldCByZWMgaW5zZXJ0X2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgICAgIHwgQ29ucyhoa2V5LCBkYXRhLCByZXN0KSAtPlxuICAgICAgICAgICAgICBpbnNlcnRfYnVja2V0IHJlc3Q7ICgqIHByZXNlcnZlIG9yaWdpbmFsIG9yZGVyIG9mIGVsZW1lbnRzICopXG4gICAgICAgICAgICAgIGxldCBuaWR4ID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgICAgICAgICBuZGF0YS4obmlkeCkgPC0gQ29ucyhoa2V5LCBkYXRhLCBuZGF0YS4obmlkeCkpIGluXG4gICAgICAgIGZvciBpID0gMCB0byBvc2l6ZSAtIDEgZG9cbiAgICAgICAgICBpbnNlcnRfYnVja2V0IG9kYXRhLihpKVxuICAgICAgICBkb25lXG4gICAgICBlbmRcblxuICAgIGxldCBhZGQgaCBrZXkgaW5mbyA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGxldCBjb250YWluZXIgPSBILmNyZWF0ZSBrZXkgaW5mbyBpblxuICAgICAgbGV0IGJ1Y2tldCA9IENvbnMoaGtleSwgY29udGFpbmVyLCBoLmRhdGEuKGkpKSBpblxuICAgICAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUgaFxuXG4gICAgbGV0IHJlbW92ZSBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIHJlbW92ZV9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICAgIHwgQ29ucyhoaywgYywgbmV4dCkgd2hlbiBoa2V5ID0gaGsgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgICAgfCBFVHJ1ZSAtPiBoLnNpemUgPC0gaC5zaXplIC0gMTsgbmV4dFxuICAgICAgICAgICAgfCBFRmFsc2UgLT4gQ29ucyhoaywgYywgcmVtb3ZlX2J1Y2tldCBuZXh0KVxuICAgICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICAgICgqIFRoZSBkZWFkIGtleSBpcyBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuIEl0IGlzIGFjY2VwdGFibGVcbiAgICAgICAgICAgICAgICAgICAgZm9yIHRoaXMgZnVuY3Rpb24gc2luY2UgaXQgYWxyZWFkeSByZW1vdmVzIGEgYmluZGluZyAqKVxuICAgICAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgICAgIHJlbW92ZV9idWNrZXQgbmV4dFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgQ29ucyhoayxjLG5leHQpIC0+IENvbnMoaGssIGMsIHJlbW92ZV9idWNrZXQgbmV4dCkgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgaC5kYXRhLihpKSA8LSByZW1vdmVfYnVja2V0IGguZGF0YS4oaSlcblxuICAgICgqKiB7IWZpbmR9IGRvbid0IHJlbW92ZSBkZWFkIGtleXMgYmVjYXVzZSBpdCB3b3VsZCBiZSBzdXJwcmlzaW5nIGZvclxuICAgICAgICB0aGUgdXNlciB0aGF0IGEgcmVhZC1vbmx5IGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHN0YXRlIChlZy4gY29uY3VycmVudFxuICAgICAgICBhY2Nlc3MpLiBTYW1lIGZvciB7IWl0ZXJ9LCB7IWZvbGR9LCB7IW1lbX0uXG4gICAgKilcbiAgICBsZXQgcmVjIGZpbmRfcmVjIGtleSBoa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPlxuICAgICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICgqIFRoaXMgY2FzZSBpcyBub3QgaW1wb3NzaWJsZSBiZWNhdXNlIHRoZSBnYyBjYW4gcnVuIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICBILmVxdWFsIGFuZCBILmdldF9kYXRhICopXG4gICAgICAgICAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBkIC0+IGRcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuXG4gICAgbGV0IGZpbmQgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgKCogVE9ETyBpbmxpbmUgMyBpdGVyYXRpb25zICopXG4gICAgICBmaW5kX3JlYyBrZXkgaGtleSAoaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KSlcblxuICAgIGxldCByZWMgZmluZF9yZWNfb3B0IGtleSBoa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT5cbiAgICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAoKiBUaGlzIGNhc2UgaXMgbm90IGltcG9zc2libGUgYmVjYXVzZSB0aGUgZ2MgY2FuIHJ1biBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgICAgSC5lcXVhbCBhbmQgSC5nZXRfZGF0YSAqKVxuICAgICAgICAgICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIF8gYXMgZCAtPiBkXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcblxuICAgIGxldCBmaW5kX29wdCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICAoKiBUT0RPIGlubGluZSAzIGl0ZXJhdGlvbnMgKilcbiAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSAoaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KSlcblxuICAgIGxldCBmaW5kX2FsbCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gW11cbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPiBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIGQgLT4gZDo6ZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdCBpblxuICAgICAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KVxuXG5cbiAgICBsZXQgcmVwbGFjZSBoIGtleSBpbmZvID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgcmVwbGFjZV9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICB8IENvbnMoaGssIGMsIG5leHQpIHdoZW4gaGtleSA9IGhrIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICAgIHwgRVRydWUgLT4gSC5zZXRfa2V5X2RhdGEgYyBrZXkgaW5mb1xuICAgICAgICAgICAgfCBFRmFsc2UgfCBFRGVhZCAtPiByZXBsYWNlX2J1Y2tldCBuZXh0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBDb25zKF8sXyxuZXh0KSAtPiByZXBsYWNlX2J1Y2tldCBuZXh0XG4gICAgICBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgICAgIHRyeVxuICAgICAgICByZXBsYWNlX2J1Y2tldCBsXG4gICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICBsZXQgY29udGFpbmVyID0gSC5jcmVhdGUga2V5IGluZm8gaW5cbiAgICAgICAgaC5kYXRhLihpKSA8LSBDb25zKGhrZXksIGNvbnRhaW5lciwgbCk7XG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGhcblxuICAgIGxldCBtZW0gaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrID0gaGtleSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT4gdHJ1ZVxuICAgICAgICAgIHwgRUZhbHNlIHwgRURlYWQgLT4gbWVtX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoX2hrLCBfYywgcmVzdCkgLT4gbWVtX2luX2J1Y2tldCByZXN0IGluXG4gICAgICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGggaGtleSlcblxuICAgIGxldCBpdGVyIGYgaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgICgpXG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+ICgpXG4gICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+IGYgayBkXG4gICAgICAgICAgICBlbmQ7IGRvX2J1Y2tldCByZXN0IGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgIGxldCBmb2xkIGYgaCBpbml0ID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0IGIgYWNjdSA9XG4gICAgICAgIG1hdGNoIGIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgICBhY2N1XG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgbGV0IGFjY3UgPSBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBhY2N1XG4gICAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT4gZiBrIGQgYWNjdVxuICAgICAgICAgICAgZW5kIGluXG4gICAgICAgICAgICBkb19idWNrZXQgcmVzdCBhY2N1ICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgYWNjdSA6PSBkb19idWNrZXQgZC4oaSkgIWFjY3VcbiAgICAgIGRvbmU7XG4gICAgICAhYWNjdVxuXG4gICAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSBmIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBFbXB0eVxuICAgICAgICB8IENvbnMoaGssIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT5cbiAgICAgICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPlxuICAgICAgICAgICAgICAgIG1hdGNoIGYgayBkIHdpdGhcbiAgICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgICAgICAgICB8IFNvbWUgbmV3X2QgLT5cbiAgICAgICAgICAgICAgICAgICAgSC5zZXRfa2V5X2RhdGEgYyBrIG5ld19kO1xuICAgICAgICAgICAgICAgICAgICBDb25zKGhrLCBjLCBkb19idWNrZXQgcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkLihpKSA8LSBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgIGxldCBsZW5ndGggaCA9IGguc2l6ZVxuXG4gICAgbGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT4gYnVja2V0X2xlbmd0aCAoYWNjdSArIDEpIHJlc3RcblxuICAgIGxldCBzdGF0cyBoID1cbiAgICAgIGxldCBtYmwgPVxuICAgICAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gSW50Lm1heCBtIChidWNrZXRfbGVuZ3RoIDAgYikpIDAgaC5kYXRhIGluXG4gICAgICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gICAgICBBcnJheS5pdGVyXG4gICAgICAgIChmdW4gYiAtPlxuICAgICAgICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGggMCBiIGluXG4gICAgICAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgICAgICBoLmRhdGE7XG4gICAgICB7IEhhc2h0YmwubnVtX2JpbmRpbmdzID0gaC5zaXplO1xuICAgICAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgICAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4gICAgbGV0IHJlYyBidWNrZXRfbGVuZ3RoX2FsaXZlIGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IENvbnMoXywgYywgcmVzdCkgd2hlbiBILmNoZWNrX2tleSBjIC0+XG4gICAgICAgICAgYnVja2V0X2xlbmd0aF9hbGl2ZSAoYWNjdSArIDEpIHJlc3RcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPiBidWNrZXRfbGVuZ3RoX2FsaXZlIGFjY3UgcmVzdFxuXG4gICAgbGV0IHN0YXRzX2FsaXZlIGggPVxuICAgICAgbGV0IHNpemUgPSByZWYgMCBpblxuICAgICAgbGV0IG1ibCA9XG4gICAgICAgIEFycmF5LmZvbGRfbGVmdFxuICAgICAgICAgIChmdW4gbSBiIC0+IEludC5tYXggbSAoYnVja2V0X2xlbmd0aF9hbGl2ZSAwIGIpKSAwIGguZGF0YVxuICAgICAgaW5cbiAgICAgIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgICAgIEFycmF5Lml0ZXJcbiAgICAgICAgKGZ1biBiIC0+XG4gICAgICAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aF9hbGl2ZSAwIGIgaW5cbiAgICAgICAgICAgc2l6ZSA6PSAhc2l6ZSArIGw7XG4gICAgICAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgICAgICBoLmRhdGE7XG4gICAgICB7IEhhc2h0YmwubnVtX2JpbmRpbmdzID0gIXNpemU7XG4gICAgICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICAgICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbiAgICBsZXQgdG9fc2VxIHRibCA9XG4gICAgICAoKiBjYXB0dXJlIGN1cnJlbnQgYXJyYXksIHNvIHRoYXQgZXZlbiBpZiB0aGUgdGFibGUgaXMgcmVzaXplZCB3ZVxuICAgICAgICAga2VlcCBpdGVyYXRpbmcgb24gdGhlIHNhbWUgYXJyYXkgKilcbiAgICAgIGxldCB0YmxfZGF0YSA9IHRibC5kYXRhIGluXG4gICAgICAoKiBzdGF0ZTogaW5kZXggKiBuZXh0IGJ1Y2tldCB0byB0cmF2ZXJzZSAqKVxuICAgICAgbGV0IHJlYyBhdXggaSBidWNrICgpID0gbWF0Y2ggYnVjayB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIGlmIGkgPSBBcnJheS5sZW5ndGggdGJsX2RhdGFcbiAgICAgICAgICAgIHRoZW4gU2VxLk5pbFxuICAgICAgICAgICAgZWxzZSBhdXgoaSsxKSB0YmxfZGF0YS4oaSkgKClcbiAgICAgICAgfCBDb25zIChfLCBjLCBuZXh0KSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gYXV4IGkgbmV4dCAoKVxuICAgICAgICAgICAgICB8IFNvbWUga2V5LCBTb21lIGRhdGEgLT5cbiAgICAgICAgICAgICAgICAgIFNlcS5Db25zICgoa2V5LCBkYXRhKSwgYXV4IGkgbmV4dClcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIGF1eCAwIEVtcHR5XG5cbiAgICBsZXQgdG9fc2VxX2tleXMgbSA9IFNlcS5tYXAgZnN0ICh0b19zZXEgbSlcblxuICAgIGxldCB0b19zZXFfdmFsdWVzIG0gPSBTZXEubWFwIHNuZCAodG9fc2VxIG0pXG5cbiAgICBsZXQgYWRkX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IGFkZCB0YmwgayB2KSBpXG5cbiAgICBsZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiByZXBsYWNlIHRibCBrIHYpIGlcblxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBPYmpFcGggPSBPYmouRXBoZW1lcm9uXG5cbmxldCBfb2JqX29wdCA6IE9iai50IG9wdGlvbiAtPiAnYSBvcHRpb24gPSBmdW4geCAtPlxuICBtYXRjaCB4IHdpdGhcbiAgfCBOb25lIC0+IHhcbiAgfCBTb21lIHYgLT4gU29tZSAoT2JqLm9iaiB2KVxuXG4oKiogVGhlIHByZXZpb3VzIGZ1bmN0aW9uIGlzIHR5cGVkIHNvIHRoaXMgb25lIGlzIGFsc28gY29ycmVjdCAqKVxubGV0IG9ial9vcHQgOiBPYmoudCBvcHRpb24gLT4gJ2Egb3B0aW9uID0gZnVuIHggLT4gT2JqLm1hZ2ljIHhcblxuXG5tb2R1bGUgSzEgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgKCkgOiAoJ2ssJ2QpIHQgPSBPYmpFcGguY3JlYXRlIDFcblxuICBsZXQgZ2V0X2tleSAodDooJ2ssJ2QpIHQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAwKVxuICBsZXQgZ2V0X2tleV9jb3B5ICh0OignaywnZCkgdCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMClcbiAgbGV0IHNldF9rZXkgKHQ6KCdrLCdkKSB0KSAoazonaykgOiB1bml0ID0gT2JqRXBoLnNldF9rZXkgdCAwIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5ICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDBcbiAgbGV0IGNoZWNrX2tleSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAwXG5cbiAgbGV0IGJsaXRfa2V5ICh0MTooJ2ssJ2QpIHQpICh0MjooJ2ssJ2QpIHQpOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMCB0MiAwIDFcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgZ2V0X2RhdGFfY29weSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignaywnZCkgdCkgKGQ6J2QpIDogdW5pdCA9IE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfZGF0YSB0XG4gIGxldCBibGl0X2RhdGEgKHQxOihfLCdkKSB0KSAodDI6KF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBtb2R1bGUgTWFrZVNlZWRlZCAoSDpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSC50XG4gICAgICBsZXQgY3JlYXRlIGsgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlICgpIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgc2V0X2tleSBjIGs7XG4gICAgICAgIGNcbiAgICAgIGxldCBoYXNoID0gSC5oYXNoXG4gICAgICBsZXQgZXF1YWwgYyBrID1cbiAgICAgICAgKCogeyFnZXRfa2V5X2NvcHl9IGlzIG5vdCB1c2VkIGJlY2F1c2UgdGhlIGVxdWFsaXR5IG9mIHRoZSB1c2VyIGNhbiBiZVxuICAgICAgICAgICAgdGhlIHBoeXNpY2FsIGVxdWFsaXR5ICopXG4gICAgICAgIG1hdGNoIGdldF9rZXkgYyB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgfCBTb21lIGsnIC0+XG4gICAgICAgICAgICBpZiBILmVxdWFsIGsgaycgdGhlbiBHZW5IYXNoVGFibGUuRVRydWUgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IGdldF9rZXkgPSBnZXRfa2V5XG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgayBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBzZXRfa2V5IGMgaztcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5ID0gY2hlY2tfa2V5XG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEg6IEhhc2h0YmwuSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuXG5lbmRcblxubW9kdWxlIEsyID0gc3RydWN0XG4gIHR5cGUgKCdrMSwgJ2syLCAnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSAoKSA6ICgnazEsJ2syLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSAyXG5cbiAgbGV0IGdldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSA6ICdrMSBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDApXG4gIGxldCBnZXRfa2V5MV9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdrMSBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAwKVxuICBsZXQgc2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIChrOidrMSkgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IDAgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMFxuICBsZXQgY2hlY2tfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDBcblxuICBsZXQgZ2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2syIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMSlcbiAgbGV0IGdldF9rZXkyX2NvcHkgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2syIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IDEpXG4gIGxldCBzZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgKGs6J2syKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgMSAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCAxXG4gIGxldCBjaGVja19rZXkyICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMVxuXG5cbiAgbGV0IGJsaXRfa2V5MSAodDE6KCdrMSxfLF8pIHQpICh0MjooJ2sxLF8sXykgdCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMCB0MiAwIDFcbiAgbGV0IGJsaXRfa2V5MiAodDE6KF8sJ2syLF8pIHQpICh0MjooXywnazIsXykgdCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMSB0MiAxIDFcbiAgbGV0IGJsaXRfa2V5MTIgKHQxOignazEsJ2syLF8pIHQpICh0MjooJ2sxLCdrMixfKSB0KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMlxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IGdldF9kYXRhX2NvcHkgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2Qgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIChkOidkKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2RhdGEgdFxuICBsZXQgYmxpdF9kYXRhICh0MTooXyxfLCdkKSB0KSAodDI6KF8sXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkXG4gICAgICAoSDE6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKVxuICAgICAgKEgyOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSDEudCxIMi50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBIMS50ICogSDIudFxuICAgICAgbGV0IGNyZWF0ZSAoazEsazIpIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIHNldF9rZXkxIGMgazE7IHNldF9rZXkyIGMgazI7XG4gICAgICAgIGNcbiAgICAgIGxldCBoYXNoIHNlZWQgKGsxLGsyKSA9XG4gICAgICAgIEgxLmhhc2ggc2VlZCBrMSArIEgyLmhhc2ggc2VlZCBrMiAqIDY1NTk5XG4gICAgICBsZXQgZXF1YWwgYyAoazEsazIpID1cbiAgICAgICAgbWF0Y2ggZ2V0X2tleTEgYywgZ2V0X2tleTIgYyB3aXRoXG4gICAgICAgIHwgTm9uZSwgXyB8IF8gLCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICB8IFNvbWUgazEnLCBTb21lIGsyJyAtPlxuICAgICAgICAgICAgaWYgSDEuZXF1YWwgazEgazEnICYmIEgyLmVxdWFsIGsyIGsyJ1xuICAgICAgICAgICAgdGhlbiBHZW5IYXNoVGFibGUuRVRydWUgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IGdldF9rZXkgYyA9XG4gICAgICAgIG1hdGNoIGdldF9rZXkxIGMsIGdldF9rZXkyIGMgd2l0aFxuICAgICAgICB8IE5vbmUsIF8gfCBfICwgTm9uZSAtPiBOb25lXG4gICAgICAgIHwgU29tZSBrMScsIFNvbWUgazInIC0+IFNvbWUgKGsxJywgazInKVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIChrMSxrMikgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgc2V0X2tleTEgYyBrMTsgc2V0X2tleTIgYyBrMjtcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5IGMgPSBjaGVja19rZXkxIGMgJiYgY2hlY2tfa2V5MiBjXG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEgxOiBIYXNodGJsLkhhc2hlZFR5cGUpKEgyOiBIYXNodGJsLkhhc2hlZFR5cGUpOlxuICAgIChTIHdpdGggdHlwZSBrZXkgPSBIMS50ICogSDIudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWRcbiAgICAgICAgKHN0cnVjdFxuICAgICAgICAgIHR5cGUgdCA9IEgxLnRcbiAgICAgICAgICBsZXQgZXF1YWwgPSBIMS5lcXVhbFxuICAgICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSDEuaGFzaCB4XG4gICAgICAgIGVuZClcbiAgICAgICAgKHN0cnVjdFxuICAgICAgICAgIHR5cGUgdCA9IEgyLnRcbiAgICAgICAgICBsZXQgZXF1YWwgPSBIMi5lcXVhbFxuICAgICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSDIuaGFzaCB4XG4gICAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbmVuZFxuXG5tb2R1bGUgS24gPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgbiA6ICgnaywnZCkgdCA9IE9iakVwaC5jcmVhdGUgblxuICBsZXQgbGVuZ3RoIChrOignaywnZCkgdCkgOiBpbnQgPSBPYmpFcGgubGVuZ3RoIGtcblxuICBsZXQgZ2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IG4pXG4gIGxldCBnZXRfa2V5X2NvcHkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogJ2sgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgbilcbiAgbGV0IHNldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIChrOidrKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgbiAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IG5cbiAgbGV0IGNoZWNrX2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IG5cblxuICBsZXQgYmxpdF9rZXkgKHQxOignaywnZCkgdCkgKG8xOmludCkgKHQyOignaywnZCkgdCkgKG8yOmludCkgKGw6aW50KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSBvMSB0MiBvMiBsXG5cbiAgbGV0IGdldF9kYXRhICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IGdldF9kYXRhX2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YV9jb3B5IHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2ssJ2QpIHQpIChkOidkKSA6IHVuaXQgPSBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG4gIGxldCBjaGVja19kYXRhICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2RhdGEgdFxuICBsZXQgYmxpdF9kYXRhICh0MTooXywnZCkgdCkgKHQyOihfLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGguYmxpdF9kYXRhIHQxIHQyXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQgKEg6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChILnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgudCBhcnJheVxuICAgICAgbGV0IGNyZWF0ZSBrIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoQXJyYXkubGVuZ3RoIGspIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIHNldF9rZXkgYyBpIGsuKGkpO1xuICAgICAgICBkb25lO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCBzZWVkIGsgPVxuICAgICAgICBsZXQgaCA9IHJlZiAwIGluXG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBoIDo9IEguaGFzaCBzZWVkIGsuKGkpICogNjU1OTkgKyAhaDtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgIWhcbiAgICAgIGxldCBlcXVhbCBjIGsgPVxuICAgICAgICBsZXQgbGVuICA9IEFycmF5Lmxlbmd0aCBrIGluXG4gICAgICAgIGxldCBsZW4nID0gbGVuZ3RoIGMgaW5cbiAgICAgICAgaWYgbGVuICE9IGxlbicgdGhlbiBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgcmVjIGVxdWFsX2FycmF5IGsgYyBpID1cbiAgICAgICAgICAgIGlmIGkgPCAwIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyBpIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICAgICAgICB8IFNvbWUga2kgLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwgay4oaSkga2lcbiAgICAgICAgICAgICAgICAgIHRoZW4gZXF1YWxfYXJyYXkgayBjIChpLTEpXG4gICAgICAgICAgICAgICAgICBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgICAgICBpblxuICAgICAgICAgIGVxdWFsX2FycmF5IGsgYyAobGVuLTEpXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IGdldF9rZXkgYyA9XG4gICAgICAgIGxldCBsZW4gPSBsZW5ndGggYyBpblxuICAgICAgICBpZiBsZW4gPSAwIHRoZW4gU29tZSBbfHxdXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgMCB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICB8IFNvbWUgazAgLT5cbiAgICAgICAgICAgICAgbGV0IHJlYyBmaWxsIGEgaSA9XG4gICAgICAgICAgICAgICAgaWYgaSA8IDEgdGhlbiBTb21lIGFcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgaSB3aXRoXG4gICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgICAgICAgICAgfCBTb21lIGtpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgYS4oaSkgPC0ga2k7XG4gICAgICAgICAgICAgICAgICAgICAgZmlsbCBhIChpLTEpXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIGxldCBhID0gQXJyYXkubWFrZSBsZW4gazAgaW5cbiAgICAgICAgICAgICAgZmlsbCBhIChsZW4tMSlcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyBrIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBzZXRfa2V5IGMgaSBrLihpKTtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5IGMgPVxuICAgICAgICBsZXQgcmVjIGNoZWNrIGMgaSA9XG4gICAgICAgICAgaSA8IDAgfHwgKGNoZWNrX2tleSBjIGkgJiYgY2hlY2sgYyAoaS0xKSkgaW5cbiAgICAgICAgY2hlY2sgYyAobGVuZ3RoIGMgLSAxKVxuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIOiBIYXNodGJsLkhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50IGFycmF5KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIE1hbnVlbCBTZXJyYW5vIGV0IFhhdmllciBMZXJveSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0JpZ2FycmF5XTogbGFyZ2UsIG11bHRpLWRpbWVuc2lvbmFsLCBudW1lcmljYWwgYXJyYXlzICopXG5cbigqIFRoZXNlIHR5cGVzIGluIG11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIHRhYmxlcyBpblxuICAgLi4vdHlwaW5nL3R5cGVvcHQubWwgKilcblxudHlwZSBmbG9hdDMyX2VsdCA9IEZsb2F0MzJfZWx0XG50eXBlIGZsb2F0NjRfZWx0ID0gRmxvYXQ2NF9lbHRcbnR5cGUgaW50OF9zaWduZWRfZWx0ID0gSW50OF9zaWduZWRfZWx0XG50eXBlIGludDhfdW5zaWduZWRfZWx0ID0gSW50OF91bnNpZ25lZF9lbHRcbnR5cGUgaW50MTZfc2lnbmVkX2VsdCA9IEludDE2X3NpZ25lZF9lbHRcbnR5cGUgaW50MTZfdW5zaWduZWRfZWx0ID0gSW50MTZfdW5zaWduZWRfZWx0XG50eXBlIGludDMyX2VsdCA9IEludDMyX2VsdFxudHlwZSBpbnQ2NF9lbHQgPSBJbnQ2NF9lbHRcbnR5cGUgaW50X2VsdCA9IEludF9lbHRcbnR5cGUgbmF0aXZlaW50X2VsdCA9IE5hdGl2ZWludF9lbHRcbnR5cGUgY29tcGxleDMyX2VsdCA9IENvbXBsZXgzMl9lbHRcbnR5cGUgY29tcGxleDY0X2VsdCA9IENvbXBsZXg2NF9lbHRcblxudHlwZSAoJ2EsICdiKSBraW5kID1cbiAgICBGbG9hdDMyIDogKGZsb2F0LCBmbG9hdDMyX2VsdCkga2luZFxuICB8IEZsb2F0NjQgOiAoZmxvYXQsIGZsb2F0NjRfZWx0KSBraW5kXG4gIHwgSW50OF9zaWduZWQgOiAoaW50LCBpbnQ4X3NpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQ4X3Vuc2lnbmVkIDogKGludCwgaW50OF91bnNpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQxNl9zaWduZWQgOiAoaW50LCBpbnQxNl9zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50MTZfdW5zaWduZWQgOiAoaW50LCBpbnQxNl91bnNpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQzMiA6IChpbnQzMiwgaW50MzJfZWx0KSBraW5kXG4gIHwgSW50NjQgOiAoaW50NjQsIGludDY0X2VsdCkga2luZFxuICB8IEludCA6IChpbnQsIGludF9lbHQpIGtpbmRcbiAgfCBOYXRpdmVpbnQgOiAobmF0aXZlaW50LCBuYXRpdmVpbnRfZWx0KSBraW5kXG4gIHwgQ29tcGxleDMyIDogKENvbXBsZXgudCwgY29tcGxleDMyX2VsdCkga2luZFxuICB8IENvbXBsZXg2NCA6IChDb21wbGV4LnQsIGNvbXBsZXg2NF9lbHQpIGtpbmRcbiAgfCBDaGFyIDogKGNoYXIsIGludDhfdW5zaWduZWRfZWx0KSBraW5kXG5cbnR5cGUgY19sYXlvdXQgPSBDX2xheW91dF90eXBcbnR5cGUgZm9ydHJhbl9sYXlvdXQgPSBGb3J0cmFuX2xheW91dF90eXAgKCoqKVxuXG50eXBlICdhIGxheW91dCA9XG4gICAgQ19sYXlvdXQ6IGNfbGF5b3V0IGxheW91dFxuICB8IEZvcnRyYW5fbGF5b3V0OiBmb3J0cmFuX2xheW91dCBsYXlvdXRcblxuKCogS2VlcCB0aG9zZSBjb25zdGFudHMgaW4gc3luYyB3aXRoIHRoZSBjYW1sX2JhX2tpbmQgZW51bWVyYXRpb25cbiAgIGluIGJpZ2FycmF5LmggKilcblxubGV0IGZsb2F0MzIgPSBGbG9hdDMyXG5sZXQgZmxvYXQ2NCA9IEZsb2F0NjRcbmxldCBpbnQ4X3NpZ25lZCA9IEludDhfc2lnbmVkXG5sZXQgaW50OF91bnNpZ25lZCA9IEludDhfdW5zaWduZWRcbmxldCBpbnQxNl9zaWduZWQgPSBJbnQxNl9zaWduZWRcbmxldCBpbnQxNl91bnNpZ25lZCA9IEludDE2X3Vuc2lnbmVkXG5sZXQgaW50MzIgPSBJbnQzMlxubGV0IGludDY0ID0gSW50NjRcbmxldCBpbnQgPSBJbnRcbmxldCBuYXRpdmVpbnQgPSBOYXRpdmVpbnRcbmxldCBjb21wbGV4MzIgPSBDb21wbGV4MzJcbmxldCBjb21wbGV4NjQgPSBDb21wbGV4NjRcbmxldCBjaGFyID0gQ2hhclxuXG5sZXQga2luZF9zaXplX2luX2J5dGVzIDogdHlwZSBhIGIuIChhLCBiKSBraW5kIC0+IGludCA9IGZ1bmN0aW9uXG4gIHwgRmxvYXQzMiAtPiA0XG4gIHwgRmxvYXQ2NCAtPiA4XG4gIHwgSW50OF9zaWduZWQgLT4gMVxuICB8IEludDhfdW5zaWduZWQgLT4gMVxuICB8IEludDE2X3NpZ25lZCAtPiAyXG4gIHwgSW50MTZfdW5zaWduZWQgLT4gMlxuICB8IEludDMyIC0+IDRcbiAgfCBJbnQ2NCAtPiA4XG4gIHwgSW50IC0+IFN5cy53b3JkX3NpemUgLyA4XG4gIHwgTmF0aXZlaW50IC0+IFN5cy53b3JkX3NpemUgLyA4XG4gIHwgQ29tcGxleDMyIC0+IDhcbiAgfCBDb21wbGV4NjQgLT4gMTZcbiAgfCBDaGFyIC0+IDFcblxuKCogS2VlcCB0aG9zZSBjb25zdGFudHMgaW4gc3luYyB3aXRoIHRoZSBjYW1sX2JhX2xheW91dCBlbnVtZXJhdGlvblxuICAgaW4gYmlnYXJyYXkuaCAqKVxuXG5sZXQgY19sYXlvdXQgPSBDX2xheW91dFxubGV0IGZvcnRyYW5fbGF5b3V0ID0gRm9ydHJhbl9sYXlvdXRcblxubW9kdWxlIEdlbmFycmF5ID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHRcbiAgZXh0ZXJuYWwgY3JlYXRlOiAoJ2EsICdiKSBraW5kIC0+ICdjIGxheW91dCAtPiBpbnQgYXJyYXkgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICAgPSBcImNhbWxfYmFfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgYXJyYXkgLT4gJ2FcbiAgICAgPSBcImNhbWxfYmFfZ2V0X2dlbmVyaWNcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCBhcnJheSAtPiAnYSAtPiB1bml0XG4gICAgID0gXCJjYW1sX2JhX3NldF9nZW5lcmljXCJcblxuICBsZXQgcmVjIGNsb29wIGFyciBpZHggZiBjb2wgbWF4ID1cbiAgICBpZiBjb2wgPSBBcnJheS5sZW5ndGggaWR4IHRoZW4gc2V0IGFyciBpZHggKGYgaWR4KVxuICAgIGVsc2UgZm9yIGogPSAwIHRvIHByZWQgbWF4Lihjb2wpIGRvXG4gICAgICAgICAgIGlkeC4oY29sKSA8LSBqO1xuICAgICAgICAgICBjbG9vcCBhcnIgaWR4IGYgKHN1Y2MgY29sKSBtYXhcbiAgICAgICAgIGRvbmVcbiAgbGV0IHJlYyBmbG9vcCBhcnIgaWR4IGYgY29sIG1heCA9XG4gICAgaWYgY29sIDwgMCB0aGVuIHNldCBhcnIgaWR4IChmIGlkeClcbiAgICBlbHNlIGZvciBqID0gMSB0byBtYXguKGNvbCkgZG9cbiAgICAgICAgICAgaWR4Lihjb2wpIDwtIGo7XG4gICAgICAgICAgIGZsb29wIGFyciBpZHggZiAocHJlZCBjb2wpIG1heFxuICAgICAgICAgZG9uZVxuICBsZXQgaW5pdCAodHlwZSB0KSBraW5kIChsYXlvdXQgOiB0IGxheW91dCkgZGltcyBmID1cbiAgICBsZXQgYXJyID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbXMgaW5cbiAgICBtYXRjaCBBcnJheS5sZW5ndGggZGltcywgbGF5b3V0IHdpdGhcbiAgICB8IDAsIF8gLT4gYXJyXG4gICAgfCBkbGVuLCBDX2xheW91dCAtPiBjbG9vcCBhcnIgKEFycmF5Lm1ha2UgZGxlbiAwKSBmIDAgZGltczsgYXJyXG4gICAgfCBkbGVuLCBGb3J0cmFuX2xheW91dCAtPiBmbG9vcCBhcnIgKEFycmF5Lm1ha2UgZGxlbiAxKSBmIChwcmVkIGRsZW4pIGRpbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJcblxuICBleHRlcm5hbCBudW1fZGltczogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCJjYW1sX2JhX251bV9kaW1zXCJcbiAgZXh0ZXJuYWwgbnRoX2RpbTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCA9IFwiY2FtbF9iYV9kaW1cIlxuICBsZXQgZGltcyBhID1cbiAgICBsZXQgbiA9IG51bV9kaW1zIGEgaW5cbiAgICBsZXQgZCA9IEFycmF5Lm1ha2UgbiAwIGluXG4gICAgZm9yIGkgPSAwIHRvIG4tMSBkbyBkLihpKSA8LSBudGhfZGltIGEgaSBkb25lO1xuICAgIGRcblxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKEFycmF5LmZvbGRfbGVmdCAoICogKSAxIChkaW1zIGFycikpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHNsaWNlX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCBhcnJheSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zbGljZVwiXG4gIGV4dGVybmFsIHNsaWNlX3JpZ2h0OiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgYXJyYXkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc2xpY2VcIlxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0XG4gICAgID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuZW5kXG5cbm1vZHVsZSBBcnJheTAgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfHxdXG4gIGxldCBnZXQgYXJyID0gR2VuYXJyYXkuZ2V0IGFyciBbfHxdXG4gIGxldCBzZXQgYXJyID0gR2VuYXJyYXkuc2V0IGFyciBbfHxdXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID0ga2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycilcblxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuXG4gIGxldCBvZl92YWx1ZSBraW5kIGxheW91dCB2ID1cbiAgICBsZXQgYSA9IGNyZWF0ZSBraW5kIGxheW91dCBpblxuICAgIHNldCBhIHY7XG4gICAgYVxuICBsZXQgaW5pdCA9IG9mX3ZhbHVlXG5lbmRcblxubW9kdWxlIEFycmF5MSA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0gPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbXxdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfMVwiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVjYW1sX2JhX3NldF8xXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzFcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8xXCJcbiAgZXh0ZXJuYWwgZGltOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoZGltIGFycilcblxuICBleHRlcm5hbCBzdWI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgJ2MpIHQgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlICh0eXBlIHQpIChhIDogKF8sIF8sIHQpIEdlbmFycmF5LnQpIG4gPVxuICAgIG1hdGNoIGxheW91dCBhIHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IChHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF0gOiAoXywgXywgdCkgR2VuYXJyYXkudClcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IChHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdOiAoXywgXywgdCkgR2VuYXJyYXkudClcbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IGNfaW5pdCBhcnIgZGltIGYgPVxuICAgIGZvciBpID0gMCB0byBwcmVkIGRpbSBkbyB1bnNhZmVfc2V0IGFyciBpIChmIGkpIGRvbmVcbiAgbGV0IGZvcnRyYW5faW5pdCBhcnIgZGltIGYgPVxuICAgIGZvciBpID0gMSB0byBkaW0gZG8gdW5zYWZlX3NldCBhcnIgaSAoZiBpKSBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW0gZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0gaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY19pbml0IGFyciBkaW0gZjsgYXJyXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiBmb3J0cmFuX2luaXQgYXJyIGRpbSBmOyBhcnJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCAoQXJyYXkubGVuZ3RoIGRhdGEpIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZGF0YSAtIDEgZG8gdW5zYWZlX3NldCBiYSAoaSArIG9mcykgZGF0YS4oaSkgZG9uZTtcbiAgICBiYVxuZW5kXG5cbm1vZHVsZSBBcnJheTIgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW0xOyBkaW0yfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfMlwiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlY2FtbF9iYV9zZXRfMlwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2FcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfMlwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8yXCJcbiAgZXh0ZXJuYWwgZGltMTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMVwiXG4gIGV4dGVybmFsIGRpbTI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzJcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0xIGFycikgKiAoZGltMiBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OlxuICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlX2xlZnQgYSBuID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdXG4gIGxldCBzbGljZV9yaWdodCBhIG4gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBjX2luaXQgYXJyIGRpbTEgZGltMiBmID1cbiAgICBmb3IgaSA9IDAgdG8gcHJlZCBkaW0xIGRvXG4gICAgICBmb3IgaiA9IDAgdG8gcHJlZCBkaW0yIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiAoZiBpIGopXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZiA9XG4gICAgZm9yIGogPSAxIHRvIGRpbTIgZG9cbiAgICAgIGZvciBpID0gMSB0byBkaW0xIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiAoZiBpIGopXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgaW5pdCAodHlwZSB0KSBraW5kIChsYXlvdXQgOiB0IGxheW91dCkgZGltMSBkaW0yIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGluXG4gICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IGNfaW5pdCBhcnIgZGltMSBkaW0yIGY7IGFyclxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZjsgYXJyXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgZGltMSA9IEFycmF5Lmxlbmd0aCBkYXRhIGluXG4gICAgbGV0IGRpbTIgPSBpZiBkaW0xID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkgaW5cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBkaW0xIC0gMSBkb1xuICAgICAgbGV0IHJvdyA9IGRhdGEuKGkpIGluXG4gICAgICBpZiBBcnJheS5sZW5ndGggcm93IDw+IGRpbTIgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyhcIkJpZ2FycmF5LkFycmF5Mi5vZl9hcnJheTogbm9uLXJlY3Rhbmd1bGFyIGRhdGFcIik7XG4gICAgICBmb3IgaiA9IDAgdG8gZGltMiAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCBiYSAoaSArIG9mcykgKGogKyBvZnMpIHJvdy4oailcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIGJhXG5lbmRcblxubW9kdWxlIEFycmF5MyA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltMTsgZGltMjsgZGltM3xdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8zXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV9zZXRfM1wiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhXG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzNcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzNcIlxuICBleHRlcm5hbCBkaW0xOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwgZGltMjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMlwiXG4gIGV4dGVybmFsIGRpbTM6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzNcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0xIGFycikgKiAoZGltMiBhcnIpICogKGRpbTMgYXJyKVxuXG4gIGV4dGVybmFsIHN1Yl9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHN1Yl9yaWdodDpcbiAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2VfbGVmdF8xIGEgbiBtID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bjsgbXxdXG4gIGxldCBzbGljZV9yaWdodF8xIGEgbiBtID0gR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG47IG18XVxuICBsZXQgc2xpY2VfbGVmdF8yIGEgbiA9IEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XVxuICBsZXQgc2xpY2VfcmlnaHRfMiBhIG4gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBjX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGYgPVxuICAgIGZvciBpID0gMCB0byBwcmVkIGRpbTEgZG9cbiAgICAgIGZvciBqID0gMCB0byBwcmVkIGRpbTIgZG9cbiAgICAgICAgZm9yIGsgPSAwIHRvIHByZWQgZGltMyBkb1xuICAgICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiBrIChmIGkgaiBrKVxuICAgICAgICBkb25lXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmID1cbiAgICBmb3IgayA9IDEgdG8gZGltMyBkb1xuICAgICAgZm9yIGogPSAxIHRvIGRpbTIgZG9cbiAgICAgICAgZm9yIGkgPSAxIHRvIGRpbTEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IGFyciBpIGogayAoZiBpIGogaylcbiAgICAgICAgZG9uZVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgbGV0IGluaXQgKHR5cGUgdCkga2luZCAobGF5b3V0IDogdCBsYXlvdXQpIGRpbTEgZGltMiBkaW0zIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGRpbTMgaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY19pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmOyBhcnJcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IGZvcnRyYW5faW5pdCBhcnIgZGltMSBkaW0yIGRpbTMgZjsgYXJyXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgZGltMSA9IEFycmF5Lmxlbmd0aCBkYXRhIGluXG4gICAgbGV0IGRpbTIgPSBpZiBkaW0xID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkgaW5cbiAgICBsZXQgZGltMyA9IGlmIGRpbTIgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKS4oMCkgaW5cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGRpbTMgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIGRpbTEgLSAxIGRvXG4gICAgICBsZXQgcm93ID0gZGF0YS4oaSkgaW5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCByb3cgPD4gZGltMiB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkzLm9mX2FycmF5OiBub24tY3ViaWMgZGF0YVwiKTtcbiAgICAgIGZvciBqID0gMCB0byBkaW0yIC0gMSBkb1xuICAgICAgICBsZXQgY29sID0gcm93LihqKSBpblxuICAgICAgICBpZiBBcnJheS5sZW5ndGggY29sIDw+IGRpbTMgdGhlblxuICAgICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkzLm9mX2FycmF5OiBub24tY3ViaWMgZGF0YVwiKTtcbiAgICAgICAgZm9yIGsgPSAwIHRvIGRpbTMgLSAxIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBiYSAoaSArIG9mcykgKGogKyBvZnMpIChrICsgb2ZzKSBjb2wuKGspXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIGJhXG5lbmRcblxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkwOiAoJ2EsICdiLCAnYykgQXJyYXkwLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkxOiAoJ2EsICdiLCAnYykgQXJyYXkxLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkyOiAoJ2EsICdiLCAnYykgQXJyYXkyLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkzOiAoJ2EsICdiLCAnYykgQXJyYXkzLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxubGV0IGFycmF5MF9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDAgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTBfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5MV9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDEgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTFfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5Ml9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDIgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTJfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5M19vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDMgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTNfb2ZfZ2VuYXJyYXlcIlxuXG5leHRlcm5hbCByZXNoYXBlOlxuICAgKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnQgLT4gaW50IGFycmF5IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiY2FtbF9iYV9yZXNoYXBlXCJcbmxldCByZXNoYXBlXzAgYSA9IHJlc2hhcGUgYSBbfHxdXG5sZXQgcmVzaGFwZV8xIGEgZGltMSA9IHJlc2hhcGUgYSBbfGRpbTF8XVxubGV0IHJlc2hhcGVfMiBhIGRpbTEgZGltMiA9IHJlc2hhcGUgYSBbfGRpbTE7ZGltMnxdXG5sZXQgcmVzaGFwZV8zIGEgZGltMSBkaW0yIGRpbTMgPSByZXNoYXBlIGEgW3xkaW0xO2RpbTI7ZGltM3xdXG5cbigqIEZvcmNlIGNhbWxfYmFfZ2V0X3sxLDIsMyxOfSB0byBiZSBsaW5rZWQgaW4sIHNpbmNlIHdlIGRvbid0IHJlZmVyXG4gICB0byB0aG9zZSBwcmltaXRpdmVzIGRpcmVjdGx5IGluIHRoaXMgZmlsZSAqKVxuXG5sZXQgXyA9XG4gIGxldCBfID0gR2VuYXJyYXkuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkxLmdldCBpblxuICBsZXQgXyA9IEFycmF5Mi5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTMuZ2V0IGluXG4gICgpXG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTMyXCJdXG5leHRlcm5hbCBnZXQxOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzFcIlxuZXh0ZXJuYWwgZ2V0MjogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8yXCJcbmV4dGVybmFsIGdldDM6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfM1wiXG5leHRlcm5hbCBzZXQxOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzFcIlxuZXh0ZXJuYWwgc2V0MjogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8yXCJcbmV4dGVybmFsIHNldDM6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfM1wiXG4iLCIoKiogSHlwZXJncmFwaHMuICopXG5cbm1vZHVsZSB0eXBlIFQgPSBzaWdcbiAgKCoqIFZlcnRpY2VzLiAqKVxuICBtb2R1bGUgViA6IEFscGhhYmV0LlRcblxuICAoKiogRWRnZXMuICopXG4gIG1vZHVsZSBFIDogQWxwaGFiZXQuVFxuXG4gICgqKiBTb3VyY2UuICopXG4gIHZhbCBzcmMgOiBFLnQgLT4gVi50IGxpc3RcblxuICAoKiogVGFyZ2V0LiAqKVxuICB2YWwgdGd0IDogRS50IC0+IFYudCBsaXN0XG5lbmRcblxubW9kdWxlIEZ1bGwgKFYgOiBBbHBoYWJldC5UKSAoRSA6IEFscGhhYmV0LlQpID0gc3RydWN0XG4gIG1vZHVsZSBWID0gc3RydWN0XG4gICAgdHlwZSB0ID0geyBsYWJlbCA6IFYudCB9XG5cbiAgICBsZXQgbGFiZWwgeCA9IHgubGFiZWxcblxuICAgIGxldCBlcSB4IHkgPSB4ID09IHlcblxuICAgIGxldCBjb21wYXJlIHggeSA9IFYuY29tcGFyZSAobGFiZWwgeCkgKGxhYmVsIHkpXG5cbiAgICBsZXQgdG9fc3RyaW5nIHggPSBWLnRvX3N0cmluZyAobGFiZWwgeClcbiAgZW5kXG5cbiAgbW9kdWxlIFZMID0gQWxwaGFiZXQuTGlzdChWKVxuXG4gIG1vZHVsZSBFID0gc3RydWN0XG4gICAgKCogQWxwaGFiZXQuUHJvZChFKShBbHBoYWJldC5Qcm9kKEFscGhhYmV0Lkxpc3QoVikpKEFscGhhYmV0Lkxpc3QoVikpKSAqKVxuXG4gICAgdHlwZSB0ID0geyBsYWJlbCA6IEUudDsgc3JjIDogVi50IGxpc3Q7IHRndCA6IFYudCBsaXN0IH1cblxuICAgIGxldCBlcSBmIGcgPSBmID09IGdcblxuICAgIGxldCBjb21wYXJlIGYgZyA9IGNvbXBhcmUgZiBnXG5cbiAgICBsZXQgdG9fc3RyaW5nIGYgPSBFLnRvX3N0cmluZyBmLmxhYmVsIF4gXCIgOiBcIiBeIFZMLnRvX3N0cmluZyBmLnNyYyBeIFwiIC0+IFwiIF4gVkwudG9fc3RyaW5nIGYudGd0XG5cbiAgICBsZXQgbGFiZWwgZiA9IGYubGFiZWxcblxuICAgIGxldCBzcmMgZiA9IGYuc3JjXG5cbiAgICBsZXQgdGd0IGYgPSBmLnRndFxuXG4gICAgbGV0IG1ha2UgbCBzIHQgPSB7IGxhYmVsID0gbDsgc3JjID0gczsgdGd0ID0gdH1cbiAgZW5kXG5cbiAgbGV0IHNyYyA9IEUuc3JjXG5cbiAgbGV0IHRndCA9IEUudGd0XG5lbmRcblxuKCoqIFByZXNlbnRhdGlvbiBvZiBhbiBoeXBlcmdyYXBoLiAqKVxubW9kdWxlIFByZXMgKFYgOiBBbHBoYWJldC5UKSAoRSA6IEFscGhhYmV0LlQpID0gc3RydWN0XG4gIGluY2x1ZGUgRnVsbChWKShFKVxuXG4gIHR5cGUgdCA9XG4gICAge1xuICAgICAgdmVydGljZXMgOiBWLnQgbGlzdDtcbiAgICAgIGVkZ2VzIDogRS50IGxpc3Q7XG4gICAgfVxuXG4gIGxldCB2ZXJ0aWNlcyBnID0gZy52ZXJ0aWNlc1xuXG4gIGxldCBlZGdlcyBnID0gZy5lZGdlc1xuXG4gIGxldCBlbXB0eSA9IHsgdmVydGljZXMgPSBbXTsgZWRnZXMgPSBbXSB9XG5cbiAgbGV0IGFkZF92ZXJ0ZXggZyB4ID0geyBnIHdpdGggdmVydGljZXMgPSB4OjoodmVydGljZXMgZykgfVxuXG4gIGxldCBhZGRfZWRnZSBnIGUgPSB7IGcgd2l0aCBlZGdlcyA9IGU6OihlZGdlcyBnKSB9XG5cbiAgbGV0IHZlcnRleF9wcmVkIGcgdiA9XG4gICAgYXNzZXJ0IChMaXN0Lm1lbXEgdiAodmVydGljZXMgZykpO1xuICAgIExpc3QuZmlsdGVyIChmdW4gZSAtPiBMaXN0Lm1lbXEgdiAodGd0IGUpKSAoZWRnZXMgZylcblxuICBsZXQgdmVydGV4X3N1Y2MgZyB2ID1cbiAgICBhc3NlcnQgKExpc3QubWVtcSB2ICh2ZXJ0aWNlcyBnKSk7XG4gICAgTGlzdC5maWx0ZXIgKGZ1biBlIC0+IExpc3QubWVtcSB2IChzcmMgZSkpIChlZGdlcyBnKVxuXG4gIGxldCBlZGdlX3ByZWQgZyBlID0gc3JjIGVcblxuICBsZXQgZWRnZV9zdWNjIGcgZSA9IHRndCBlXG5lbmRcblxubW9kdWxlIE1hcCAoViA6IEFscGhhYmV0LlQpIChFIDogQWxwaGFiZXQuVCkgPSBzdHJ1Y3RcbiAgbW9kdWxlIE1WID0gTWFwLk1ha2UoVilcbiAgbW9kdWxlIE1FID0gTWFwLk1ha2UoRSlcbmVuZFxuIiwiKCoqIEdyYXBocy4gKilcblxuKCoqIEEgZ3JhcGguICopXG5tb2R1bGUgdHlwZSBUID0gc2lnXG4gICgqKiBWZXJ0aWNlcy4gKilcbiAgbW9kdWxlIFYgOiBBbHBoYWJldC5UXG5cbiAgKCoqIEVkZ2VzLiAqKVxuICBtb2R1bGUgRSA6IEFscGhhYmV0LlRcblxuICAoKiogU291cmNlLiAqKVxuICB2YWwgc3JjIDogRS50IC0+IFYudFxuXG4gICgqKiBUYXJnZXQuICopXG4gIHZhbCB0Z3QgOiBFLnQgLT4gVi50XG5lbmRcblxuKCoqIFRoZSB0ZXJtaW5hbCBncmFwaC4gKilcbm1vZHVsZSBUZXJtaW5hbCA6IFQgPSBzdHJ1Y3RcbiAgbW9kdWxlIFYgPSBBbHBoYWJldC5Vbml0XG4gIG1vZHVsZSBFID0gQWxwaGFiZXQuVW5pdFxuICBsZXQgc3JjICgpID0gKClcbiAgbGV0IHRndCAoKSA9ICgpXG5lbmRcblxubW9kdWxlIEZ1bGwgKFYgOiBBbHBoYWJldC5UKSAoRSA6IEFscGhhYmV0LlQpID0gc3RydWN0XG4gIG1vZHVsZSBWID0gVlxuXG4gIG1vZHVsZSBFID0gc3RydWN0XG4gICAgaW5jbHVkZSBBbHBoYWJldC5Qcm9kKEUpKEFscGhhYmV0LlByb2QoVikoVikpXG4gICAgbGV0IHRvX3N0cmluZyAoZiwoeCx5KSkgPSBFLnRvX3N0cmluZyBmXG4gIGVuZFxuXG4gIGxldCBzcmMgKGYsKHgseSkpID0geFxuXG4gIGxldCB0Z3QgKGYsKHgseSkpID0geVxuZW5kXG5cbigqKiBQcmVzZW50YXRpb24gb2YgYSBncmFwaC4gKilcbm1vZHVsZSBQcmVzIChWIDogQWxwaGFiZXQuVCkgKEUgOiBBbHBoYWJldC5UKSA9IHN0cnVjdFxuICBtb2R1bGUgR3JhcGggPSBGdWxsKFYpKEUpXG5cbiAgdHlwZSB0ID1cbiAgICB7XG4gICAgICB2ZXJ0aWNlcyA6IFYudCBsaXN0O1xuICAgICAgZWRnZXMgOiBHcmFwaC5FLnQgbGlzdDtcbiAgICB9XG5cbiAgbGV0IGVtcHR5ID0geyB2ZXJ0aWNlcyA9IFtdOyBlZGdlcyA9IFtdIH1cblxuICBsZXQgYWRkX3ZlcnRleCBwIHggPSB7IHAgd2l0aCB2ZXJ0aWNlcyA9IHg6OnAudmVydGljZXMgfVxuXG4gIGxldCBhZGRfZWRnZSBwIGYgKCh4OlYudCksKHk6Vi50KSkgPSB7IHAgd2l0aCBlZGdlcyA9IChmLCh4LHkpKTo6cC5lZGdlcyB9XG5cbiAgbGV0IGVkZ2UgcCBmIDogR3JhcGguRS50ID1cbiAgICBsZXQgeCx5ID0gTGlzdC5hc3NvYyBmIHAuZWRnZXMgaW5cbiAgICBmLCh4LHkpXG5cbiAgbGV0IGhhc192ZXJ0ZXggcCB4ID0gTGlzdC5leGlzdHMgKGZ1biB5IC0+IFYuZXEgeCB5KSBwLnZlcnRpY2VzXG5cbiAgbGV0IHRvX3N0cmluZyBnID1cbiAgICBsZXQgdmVydGljZXMgPSBMaXN0Lm1hcCBWLnRvX3N0cmluZyBnLnZlcnRpY2VzIGluXG4gICAgbGV0IHZlcnRpY2VzID0gU3RyaW5nLmNvbmNhdCBcIiAsIFwiIHZlcnRpY2VzIGluXG4gICAgbGV0IGVkZ2VzID0gTGlzdC5tYXAgKGZ1biAoZiwoeCx5KSkgLT4gRS50b19zdHJpbmcgZiBeIFwiOlwiIF4gVi50b19zdHJpbmcgeCBeIFwiLT5cIiBeIFYudG9fc3RyaW5nIHkpIGcuZWRnZXMgaW5cbiAgICBsZXQgZWRnZXMgPSBTdHJpbmcuY29uY2F0IFwiICwgXCIgZWRnZXMgaW5cbiAgICB2ZXJ0aWNlcyBeIFwiXFxuXCIgXiBlZGdlc1xuZW5kXG4iLCIoKiogR2l2ZSBpbnRlZ2VyIG5hbWVzLiAqKVxubGV0IG5hbWVyIGVxID1cbiAgbGV0IG4gPSByZWYgMCBpblxuICBsZXQgbmFtZXMgPSByZWYgW10gaW5cbiAgZnVuIGUgLT5cbiAgICBpZiBub3QgKExpc3QuZXhpc3RzIChmdW4gKGUnLF8pIC0+IGVxIGUgZScpICFuYW1lcykgdGhlblxuICAgICAgKFxuICAgICAgICBuYW1lcyA6PSAoZSwhbikgOjogIW5hbWVzO1xuICAgICAgICBpbmNyIG5cbiAgICAgICk7XG4gICAgc25kIChMaXN0LmZpbmQgKGZ1biAoZScsXykgLT4gZXEgZSBlJykgIW5hbWVzKVxuXG4iLCJsZXQgaWQgeCA9IHhcblxubGV0IHBhaXIgeCB5ID0geCwgeVxuXG5sZXQgdW5wYWlyIGYgKHgseSkgPSBmIHggeVxuXG5sZXQgKHw+KSB4IGYgPSBmIHhcblxubW9kdWxlIEludCA9IHN0cnVjdFxuICBsZXQgbW9kdWxvIHggeSA9XG4gICAgbGV0IGFucyA9IHggbW9kIHkgaW5cbiAgICBpZiBhbnMgPj0gMCB0aGVuIGFuc1xuICAgIGVsc2UgYW5zICsgeVxuZW5kXG5cbm1vZHVsZSBMaXN0ID0gc3RydWN0XG4gIGluY2x1ZGUgTGlzdFxuXG4gICgqKiBGaXJzdCBpbmRleCB3aGVyZSBhIHByZWRpY2F0ZSBpcyBzYXRpc2ZpZWQuICopXG4gIGxldCBpbmRleCBwIGwgPVxuICAgIGxldCByZWMgYXV4IG4gPSBmdW5jdGlvblxuICAgICAgfCB4OjpsIC0+IGlmIHAgeCB0aGVuIG4gZWxzZSBhdXggKG4rMSkgbFxuICAgICAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICBpblxuICAgIGF1eCAwIGxcblxuICAoKiogUmVwbGFjZSB0aGUgbnRoIGVsZW1lbnQgb2YgYSBsaXN0LiAqKVxuICBsZXQgcmVwbGFjZV9udGggbCBuIHggPVxuICAgIGxldCByZWMgYXV4IG4gayA9IGZ1bmN0aW9uXG4gICAgICB8IHk6OmwgLT5cbiAgICAgICAgaWYgbiA9IDAgdGhlbiBrICh4OjpsKVxuICAgICAgICBlbHNlIGF1eCAobi0xKSAoZnVuIGwgLT4gayAoeTo6bCkpIGxcbiAgICAgIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgaW5cbiAgICBhdXggbiBpZCBsXG5cbiAgbGV0IHJlcGxhY2VfYXNzb2MgayB2IGwgPVxuICAgIExpc3QubWFwIChmdW4gKGsnLHYnKSAtPiBpZiBrID0gaycgdGhlbiBrLCB2IGVsc2UgaycsIHYnKSBsXG5cbiAgbGV0IHJlYyBzdWIgbCBvZnMgbGVuID1cbiAgICBpZiBvZnMgPSAwICYmIGxlbiA9IDAgdGhlbiBbXVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCB4OjpsIC0+XG4gICAgICAgIGlmIG9mcyA9IDAgdGhlbiB4Ojooc3ViIGwgb2ZzIChsZW4tMSkpXG4gICAgICAgIGVsc2Ugc3ViIGwgKG9mcy0xKSBsZW5cbiAgICAgIHwgW10gLT4gaW52YWxpZF9hcmcgXCJMaXN0LnN1YlwiXG5lbmRcblxubW9kdWxlIFN0cmluZyA9IHN0cnVjdFxuICBpbmNsdWRlIFN0cmluZ1xuXG4gICgqKiBGaW5kIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG1hdGNoaW5nIGEgcHJlZGljYXRlLiAqKVxuICBsZXQgZmluZCBwIHMgPVxuICAgIGxldCBhbnMgPSByZWYgKC0xKSBpblxuICAgIHRyeVxuICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgICAgaWYgcCBzLltpXSB0aGVuXG4gICAgICAgICAgKFxuICAgICAgICAgICAgYW5zIDo9IGk7XG4gICAgICAgICAgICByYWlzZSBFeGl0XG4gICAgICAgICAgKVxuICAgICAgZG9uZTtcbiAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgIHdpdGhcbiAgICB8IEV4aXQgLT4gIWFuc1xuXG4gIGxldCByZWMgc3BsaXRfb25fcHJlZGljYXRlIHAgcyA9XG4gICAgdHJ5XG4gICAgICBsZXQgbiA9IGZpbmQgcCBzIGluXG4gICAgICAoU3RyaW5nLnN1YiBzIDAgbik6OihzcGxpdF9vbl9wcmVkaWNhdGUgcCAoU3RyaW5nLnN1YiBzIChuKzEpIChTdHJpbmcubGVuZ3RoIHMgLSAobisxKSkpKVxuICAgIHdpdGggTm90X2ZvdW5kIC0+IFtzXVxuZW5kXG4iLCIoKiogVGVybSByZXdyaXRpbmcgc3lzdGVtcy4gKilcblxub3BlbiBFeHRsaWJcblxuKCoqIE9wZXJhdGlvbnMuICopXG5tb2R1bGUgT3AgPSBzdHJ1Y3RcbiAgKCoqIEFuIG9wZXJhdGlvbi4gKilcbiAgdHlwZSB0ID1cbiAgICB7XG4gICAgICB3ZWlnaHQgOiBpbnQ7XG4gICAgICBuYW1lIDogc3RyaW5nO1xuICAgICAgYXJpdHkgOiBpbnQ7XG4gICAgICB0b19zdHJpbmcgOiBzdHJpbmcgbGlzdCAtPiBzdHJpbmc7XG4gICAgfVxuXG4gIGxldCBuYW1lIGYgPSBmLm5hbWVcblxuICBsZXQgd2VpZ2h0IGYgPSBmLndlaWdodFxuXG4gIGxldCBhcml0eSBmID0gZi5hcml0eVxuXG4gICgqKiBDcmVhdGUgYW4gb3BlcmF0aW9uIHdpdGggZ2l2ZW4gbmFtZSBhbmQgYXJpdHkuICopXG4gIGxldCBtYWtlID90b19zdHJpbmcgPyh3ZWlnaHQ9MCkgbmFtZSBhcml0eSA6IHQgPVxuICAgIGxldCB0b19zdHJpbmcgPVxuICAgICAgbWF0Y2ggdG9fc3RyaW5nIHdpdGhcbiAgICAgIHwgU29tZSB0b19zdHJpbmcgLT4gdG9fc3RyaW5nXG4gICAgICB8IE5vbmUgLT4gZnVuIGEgLT4gbmFtZSBeIFwiKFwiIF4gU3RyaW5nLmNvbmNhdCBcIixcIiBhIF4gXCIpXCJcbiAgICBpblxuICAgIHsgd2VpZ2h0OyBuYW1lOyBhcml0eTsgdG9fc3RyaW5nIH1cblxuICAoKiogQ29tcGFyZSB0d28gb3BlcmF0aW9ucyBmb3IgZXF1YWxpdHkuICopXG4gIGxldCBlcSBmMSBmMiA9XG4gICAgZjEubmFtZSA9IGYyLm5hbWUgJiYgZjEuYXJpdHkgPSBmMi5hcml0eSAmJiBmMS53ZWlnaHQgPSBmMi53ZWlnaHRcblxuICBsZXQgdG9fc3RyaW5nIGYgYSA9IGYudG9fc3RyaW5nIGFcbmVuZFxuXG4oKiogVmFyaWFibGVzLiAqKVxubW9kdWxlIFZhciA9IHN0cnVjdFxuICAoKiogQSB2YXJpYWJsZS4gKilcbiAgdHlwZSB0ID0gdW5pdCByZWZcblxuICAoKiogQ3JlYXRlIGEgZnJlc2ggdmFyaWFibGUuICopXG4gIGxldCBmcmVzaCAoKSA6IHQgPSByZWYgKClcblxuICAoKiogRXF1YWxpdHkgYmV0d2VlbiB2YXJpYWJsZXMuICopXG4gIGxldCBlcSAoeDp0KSAoeTp0KSA9IHggPT0geVxuXG4gICgqKiBDcmVhdGUgYSBmdW5jdGlvbiB3aGljaCB3aWxsIGFzc2lnbiBuYW1lcyB0byB2YXJpYWJsZXMuICopXG4gIGxldCBuYW1lciAoKSA9XG4gICAgbGV0IGYgPSBVdGlscy5uYW1lciBlcSBpblxuICAgIGZ1biB4IC0+IFwieFwiIF4gc3RyaW5nX29mX2ludCAoZiB4KVxuXG4gIGxldCBuYW1lcl9uYXR1cmFsICgpID1cbiAgICBsZXQgZiA9IFV0aWxzLm5hbWVyIGVxIGluXG4gICAgbGV0IG5hbWUgPSBbfFwieFwiOyBcInlcIjsgXCJ6XCI7IFwidFwiOyBcInVcIjsgXCJ2XCI7IFwid1wifF0gaW5cbiAgICBmdW4geCAtPiBuYW1lLihmIHgpXG5cbiAgKCoqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZhcmlhYmxlLiAqKVxuICBsZXQgdG9fc3RyaW5nID0gbmFtZXIgKClcbmVuZFxuXG4oKiogQSB2YXJpYWJsZS4gKilcbnR5cGUgdmFyID0gVmFyLnRcblxuKCoqIEEgdGVybS4gKilcbnR5cGUgdCA9XG4gICAgfCBBcHAgb2YgT3AudCAqIHQgbGlzdCAoKiogYXBwbGljYXRpb24gKilcbiAgICB8IFZhciBvZiB2YXIgKCoqIHZhcmlhYmxlICopXG5cbnR5cGUgdGVybSA9IHRcblxuKCoqIENyZWF0ZSBhIGZyZXNoIHZhcmlhYmxlIHRlcm0uICopXG5sZXQgdmFyICgpID0gVmFyIChWYXIuZnJlc2ggKCkpXG5cbigqKiBDcmVhdGUgYW4gYXBwbGljYXRpb24uICopXG5sZXQgYXBwIGYgYSA9XG4gIGFzc2VydCAoTGlzdC5sZW5ndGggYSA9IE9wLmFyaXR5IGYpO1xuICBBcHAgKGYsYSlcblxuKCoqIFNpbXBsZSBwYXJzZXIgZm9yIHRlcm1zIGFuZCBhcHBsaWNhdGlvbnMuICopXG5sZXQgcGFyc2VyIHMgPVxuICBsZXQgcmVjIHRlcm0gcyA9XG4gICAgbGV0IHMgPSBTdHJpbmcudHJpbSBzIGluXG4gICAgdHJ5XG4gICAgICBsZXQgbiA9IFN0cmluZy5pbmRleCBzICcoJyBpblxuICAgICAgbGV0IGYgPSBTdHJpbmcuc3ViIHMgMCBuIGluXG4gICAgICBhc3NlcnQgKHMuW1N0cmluZy5sZW5ndGggcyAtIDFdID0gJyknKTtcbiAgICAgIGxldCBhID0gU3RyaW5nLnN1YiBzIChuKzEpIChTdHJpbmcubGVuZ3RoIHMgLSAobisxKSAtIDEpIGluXG4gICAgICBsZXQgYSA9XG4gICAgICAgIGlmIGEgPSBcIlwiIHRoZW4gW10gZWxzZVxuICAgICAgICAgIGxldCBrID0gcmVmIDAgaW5cbiAgICAgICAgICBsZXQgcCA9IGZ1bmN0aW9uXG4gICAgICAgICAgICB8ICcoJyAtPiBpbmNyIGs7IGZhbHNlXG4gICAgICAgICAgICB8ICcpJyAtPiBkZWNyIGs7IGZhbHNlXG4gICAgICAgICAgICB8ICcsJyAtPiAhayA9IDBcbiAgICAgICAgICAgIHwgXyAtPiBmYWxzZVxuICAgICAgICAgIGluXG4gICAgICAgICAgU3RyaW5nLnNwbGl0X29uX3ByZWRpY2F0ZSBwIGFcbiAgICAgIGluXG4gICAgICBsZXQgYSA9IExpc3QubWFwIHRlcm0gYSBpblxuICAgICAgYEFwcCAoZiwgYSlcbiAgICB3aXRoXG4gICAgfCBOb3RfZm91bmQgLT4gYFZhciBzXG4gIGluXG4gIGxldCBzdGVwIHMgPVxuICAgIGxldCBzID0gU3RyaW5nLnRyaW0gcyBpblxuICAgIGlmIHMuW1N0cmluZy5sZW5ndGggcyAtIDFdID0gJy0nIHRoZW4gYEludiAodGVybSAoU3RyaW5nLnN1YiBzIDAgKFN0cmluZy5sZW5ndGggcyAtIDEpKSlcbiAgICBlbHNlIHRlcm0gc1xuICBpblxuICBsZXQgbCA9IFN0cmluZy5zcGxpdF9vbl9jaGFyICcuJyBzIGluXG4gIGlmIExpc3QubGVuZ3RoIGwgPSAxIHRoZW4gc3RlcCAoTGlzdC5oZCBsKVxuICBlbHNlIGBTZXEgKExpc3QubWFwIHN0ZXAgbClcblxubGV0IHBhcnNlX3ZhciA9XG4gIGxldCB2YXJzID0gcmVmIFtdIGluXG4gIGZ1biB4IC0+XG4gICAgaWYgbm90IChMaXN0Lm1lbV9hc3NvYyB4ICF2YXJzKSB0aGVuIHZhcnMgOj0gKHgsIFZhci5mcmVzaCAoKSkgOjogIXZhcnM7XG4gICAgTGlzdC5hc3NvYyB4ICF2YXJzXG5cbigqKiBQYXJzZSBhIHRlcm0uICopXG5sZXQgcGFyc2Ugb3BzIHMgPVxuICBsZXQgcmVjIGF1eCA9IGZ1bmN0aW9uXG4gICAgfCBgQXBwIChmLCBhKSAtPlxuICAgICAgbGV0IGYgPSBMaXN0LmZpbmQgKGZ1biBvIC0+IE9wLm5hbWUgbyA9IGYpIG9wcyBpblxuICAgICAgbGV0IGEgPSBMaXN0Lm1hcCBhdXggYSBpblxuICAgICAgYXBwIGYgYVxuICAgIHwgYFZhciB4IC0+XG4gICAgICBWYXIgKHBhcnNlX3ZhciB4KVxuICAgIHwgYFNlcSBfIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgYEludiBfIC0+IGFzc2VydCBmYWxzZVxuICBpblxuICBhdXggKHBhcnNlciBzKVxuXG4oKiogRXF1YWxpdHkgYmV0d2VlbiB0ZXJtcy4gKilcbmxldCByZWMgZXEgdDEgdDIgPVxuICBtYXRjaCB0MSwgdDIgd2l0aFxuICB8IFZhciB4LCBWYXIgeSAtPiBWYXIuZXEgeCB5XG4gIHwgQXBwIChmMSwgYTEpLCBBcHAgKGYyLCBhMikgLT5cbiAgICBPcC5lcSBmMSBmMiAmJlxuICAgIExpc3QubGVuZ3RoIGExID0gTGlzdC5sZW5ndGggYTIgJiZcbiAgICBMaXN0LmZvcl9hbGwyIGVxIGExIGEyXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgZXFfdGVybSA9IGVxXG5cbigqKiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB0ZXJtLiAqKVxubGV0IHJlYyB0b19zdHJpbmcgPyh2YXI9VmFyLnRvX3N0cmluZykgPSBmdW5jdGlvblxuICB8IEFwcCAoZiwgYSkgLT4gT3AudG9fc3RyaW5nIGYgKExpc3QubWFwICh0b19zdHJpbmcgfnZhcikgYSlcbiAgfCBWYXIgeCAtPiB2YXIgeFxuXG5sZXQgc3RyaW5nX29mX3Rlcm0gP3ZhciA9IHRvX3N0cmluZyA/dmFyXG5cbigqKiBJcyBhIHRlcm0gYSB2YXJpYWJsZT8gKilcbmxldCBpc192YXIgPSBmdW5jdGlvblxuICB8IFZhciBfIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCBnZXRfdmFyID0gZnVuY3Rpb25cbiAgfCBWYXIgeCAtPiB4XG4gIHwgXyAtPiByYWlzZSBOb3RfZm91bmRcblxuKCoqIFZhcmlhYmxlcyBpbiBhIHRlcm0uICopXG5sZXQgdmFycyB0ID1cbiAgbGV0IHJlYyBhdXggdmFycyA9IGZ1bmN0aW9uXG4gICAgfCBBcHAgKF8sIGEpIC0+XG4gICAgICBMaXN0LmZvbGRfbGVmdCAoZnVuIHZhcnMgdCAtPiBhdXggdmFycyB0KSB2YXJzIGFcbiAgICB8IFZhciB4IC0+XG4gICAgICBpZiBMaXN0LmV4aXN0cyAoVmFyLmVxIHgpIHZhcnMgdGhlbiB2YXJzXG4gICAgICBlbHNlIHg6OnZhcnNcbiAgaW5cbiAgTGlzdC5yZXYgKGF1eCBbXSB0KVxuXG4oKiogV2hldGhlciBhIHZhcmlhYmxlIG9jY3VycyBpbiBhIHRlcm0uICopXG5sZXQgcmVjIG9jY3VycyB4ID0gZnVuY3Rpb25cbiAgfCBBcHAgKF8sIGEpIC0+IExpc3QuZXhpc3RzIChvY2N1cnMgeCkgYVxuICB8IFZhciB5IC0+IFZhci5lcSB4IHlcblxuKCoqIExleGljb2dyYXBoaWMgcGF0aCBvcmRlciBvbiB0ZXJtcy4gKilcbm1vZHVsZSBMUE8gPSBzdHJ1Y3RcbiAgbGV0IHJlYyBndCBnZV9vcCB0IHUgPVxuICAgICgqIFByaW50Zi5wcmludGYgXCIlcyA+ICVzID9cXG4lIVwiICh0b19zdHJpbmcgdCkgKHRvX3N0cmluZyB1KTsgKilcbiAgICBtYXRjaCB0LCB1IHdpdGhcbiAgICB8IHQsIFZhciB4IC0+IG5vdCAoZXEgdCB1KSAmJiBvY2N1cnMgeCB0XG4gICAgfCBBcHAgKGYsYSksIEFwcCAoZywgYikgLT5cbiAgICAgIGlmIExpc3QuZXhpc3RzIChmdW4gdCAtPiBnZSBnZV9vcCB0IHUpIGEgdGhlbiB0cnVlIGVsc2VcbiAgICAgIGlmIE9wLmVxIGYgZyB0aGVuXG4gICAgICAgICgqIGxleGljb2dyYXBoaWMgPiAqKVxuICAgICAgICBsZXQgcmVjIGxleCBsMSBsMiA9XG4gICAgICAgICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICAgICAgICB8IHgxOjpsMSwgeDI6OmwyIHdoZW4gZXEgeDEgeDIgLT4gbGV4IGwxIGwyXG4gICAgICAgICAgfCB4MTo6bDEsIHgyOjpsMiB3aGVuIGd0IGdlX29wIHgxIHgyIC0+IHRydWVcbiAgICAgICAgICB8IF8sIF8gLT4gZmFsc2VcbiAgICAgICAgaW5cbiAgICAgICAgTGlzdC5mb3JfYWxsIChmdW4gdSAtPiBndCBnZV9vcCB0IHUpIGIgJiZcbiAgICAgICAgbGV4IGEgYlxuICAgICAgZWxzZSBpZiBnZV9vcCBmIGcgdGhlbiBMaXN0LmZvcl9hbGwgKGZ1biB1IC0+IGd0IGdlX29wIHQgdSkgYlxuICAgICAgZWxzZSBmYWxzZVxuICAgIHwgXyAtPiBmYWxzZVxuICBhbmQgZ2UgZ2Vfb3AgdCB1ID1cbiAgICBlcSB0IHUgfHwgZ3QgZ2Vfb3AgdCB1XG5lbmRcblxuKCoqIFN1YnN0aXR1dGlvbnMuICopXG5tb2R1bGUgU3Vic3RpdHV0aW9uID0gc3RydWN0XG4gICgqKiBBIHN1YnN0aXR1dGlvbi4gKilcbiAgdHlwZSB0ID0gKHZhciAqIHRlcm0pIGxpc3RcblxuICBsZXQgdG9fc3RyaW5nID92YXIgcyA9XG4gICAgXCJbXCIgXiBTdHJpbmcuY29uY2F0IFwiLFwiIChMaXN0Lm1hcCAoZnVuICh4LHQpIC0+IHRvX3N0cmluZyA/dmFyIHQgXiBcIi9cIiBeIHRvX3N0cmluZyA/dmFyIChWYXIgeCkpIHMpIF4gXCJdXCJcblxuICAoKiogRW10cHkgc3Vic3RpdHV0aW9uLiAqKVxuICBsZXQgZW1wdHkgOiB0ID0gW11cblxuICAoKiogSWRlbnRpdHkgc3Vic3RpdGlvbi4gKilcbiAgbGV0IGlkIHZhcnMgOiB0ID1cbiAgICBMaXN0Lm1hcCAoZnVuIHggLT4geCwgVmFyIHgpIHZhcnNcblxuICAoKiogUmVuYW1pbmcgb2YgdmFyaWFibGVzLiAqKVxuICBsZXQgcmVuYW1lIHZhcnMgOiB0ID1cbiAgICBMaXN0Lm1hcCAoZnVuIHggLT4geCwgVmFyIChWYXIuZnJlc2ggKCkpKSB2YXJzXG5cbiAgbGV0IHNpbXBsZSB4IHQgOiB0ID0gW3gsdF1cblxuICBsZXQgYWRkIHMgeCB0IDogdCA9ICh4LHQpOjpzXG5cbiAgKCoqIEZpbmQgdGhlIHZhbHVlIGFzc29jaWF0ZWQgdG8gYSB2YXJpYWJsZS4gKilcbiAgbGV0IHJlYyBmaW5kIChzOnQpIHggPVxuICAgIG1hdGNoIHMgd2l0aFxuICAgIHwgKHksdCk6OnMgLT4gaWYgVmFyLmVxIHggeSB0aGVuIHQgZWxzZSBmaW5kIHMgeFxuICAgIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG5cbiAgKCoqIEFwcGx5IGEgc3Vic3RpdHV0aW9uIHRvIGEgdGVybS4gKilcbiAgbGV0IHJlYyBhcHAgKHM6dCkgPSBmdW5jdGlvblxuICAgIHwgQXBwIChnLCBhKSAtPiBBcHAgKGcsIExpc3QubWFwIChhcHAgcykgYSlcbiAgICB8IFZhciB4IC0+XG4gICAgICB0cnkgZmluZCBzIHhcbiAgICAgIHdpdGggTm90X2ZvdW5kIC0+IFZhciB4XG5cbiAgKCoqIENvbXBvc2Ugc3Vic3RpdHV0aW9ucy4gKilcbiAgbGV0IGNvbXBvc2UgKHM6dCkgKHMnOnQpIDogdCA9XG4gICAgTGlzdC5tYXAgKGZ1biAoeCx0KSAtPiB4LCBhcHAgcycgdCkgc1xuXG4gICgqKiBFcXVhbGl0eSBvZiBzdWJzdGl0dXRpb25zLiAqKVxuICBsZXQgZXEgczEgczIgPVxuICAgIGxldCBpbmNsdWRlZCAoczE6dCkgKHMyOnQpID1cbiAgICAgIExpc3QuZm9yX2FsbCAoZnVuICh4LHQpIC0+IGVxIHQgKGFwcCBzMiAoVmFyIHgpKSkgczFcbiAgICBpblxuICAgIGluY2x1ZGVkIHMxIHMyICYmIGluY2x1ZGVkIHMyIHMxXG5cbiAgKCoqIElzIGEgc3Vic3RpdHV0aW9uIGEgcmVuYW1pbmcgb2YgdmFyaWFibGVzPyAqKVxuICBsZXQgaXNfcmVuYW1pbmcgKHM6dCkgPVxuICAgIExpc3QuZm9yX2FsbCAoZnVuICh4LHQpIC0+IGlzX3ZhciB0KSBzXG5cbiAgbGV0IGlzX2luamVjdGl2ZV9yZW5hbWluZyAoczp0KSA9XG4gICAgbGV0IHJlYyBhdXggdmFycyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHRydWVcbiAgICAgIHwgKF8sdCk6OnMgLT5cbiAgICAgICAgaWYgaXNfdmFyIHQgdGhlblxuICAgICAgICAgIGxldCB4ID0gZ2V0X3ZhciB0IGluXG4gICAgICAgICAgaWYgTGlzdC5leGlzdHMgKFZhci5lcSB4KSB2YXJzIHRoZW4gZmFsc2VcbiAgICAgICAgICBlbHNlIGF1eCAoeDo6dmFycykgc1xuICAgICAgICBlbHNlIGZhbHNlXG4gICAgaW5cbiAgICBhdXggW10gc1xuXG4gICgqKiBJbnZlcnNlIG9mIGEgcmVuYW1pbmcuICopXG4gIGxldCBpbnYgKHM6dCkgOiB0ID1cbiAgICBMaXN0Lm1hcFxuICAgICAgKGZ1biAoeCx0KSAtPlxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBWYXIgeSAtPiB5LCBWYXIgeFxuICAgICAgICB8IF8gLT4gZmFpbHdpdGggXCJOb3QgaW52ZXJzaWJsZS5cIlxuICAgICAgKSBzXG5cbiAgKCoqIERvbWFpbiBvZiBhIHN1YnN0aXR1dGlvbi4gKilcbiAgbGV0IGRvbWFpbiAoczp0KSA9XG4gICAgTGlzdC5tYXAgZnN0IHNcblxuICBsZXQgaW5fZG9tIChzOnQpIHggPVxuICAgIExpc3QuZXhpc3RzIChmdW4gKHksXykgLT4gVmFyLmVxIHkgeCkgc1xuXG4gICgqKiBSZXN0cmljdCB0aGUgZG9tYWluIG9mIGEgc3Vic3RpdHV0aW9uLiAqKVxuICBsZXQgcmVzdHJpY3QgdmFycyAoczp0KSA6IHQgPVxuICAgIExpc3QuZmlsdGVyIChmdW4gKHgsXykgLT4gTGlzdC5leGlzdHMgKFZhci5lcSB4KSB2YXJzKSBzXG5lbmRcblxubW9kdWxlIFN1YnN0ID0gU3Vic3RpdHV0aW9uXG5cbnR5cGUgc3Vic3QgPSBTdWJzdC50XG5cbmV4Y2VwdGlvbiBOb3RfdW5pZmlhYmxlXG5cbigqKiBNb3N0IGdlbmVyYWwgdW5pZmllci4gKilcbmxldCB1bmlmeSB0MSB0MiA9XG4gICgqIFByaW50Zi5wcmludGYgXCJVTklGWSAlcyBXSVRIICVzXFxuJSFcIiAodG9fc3RyaW5nIHQxKSAodG9fc3RyaW5nIHQyKTsgKilcbiAgbGV0IHJlYyBhdXggcSBzID1cbiAgICBtYXRjaCBxIHdpdGhcbiAgICB8IFtdIC0+IHNcbiAgICB8IHA6OnEgLT5cbiAgICAgICBtYXRjaCBwIHdpdGhcbiAgICAgICB8IFZhciB4LCB0IC0+XG4gICAgICAgICAgaWYgb2NjdXJzIHggdCB0aGVuIHJhaXNlIE5vdF91bmlmaWFibGU7XG4gICAgICAgICAgbGV0IHMnID0gU3Vic3Quc2ltcGxlIHggdCBpblxuICAgICAgICAgIGxldCBmID0gU3Vic3QuYXBwIHMnIGluXG4gICAgICAgICAgbGV0IHEgPSBMaXN0Lm1hcCAoZnVuICh0MSx0MikgLT4gZiB0MSwgZiB0MikgcSBpblxuICAgICAgICAgIGxldCBzID0gU3Vic3QuY29tcG9zZSBzIHMnIGluXG4gICAgICAgICAgYXV4IHEgKFN1YnN0LmFkZCBzIHggdClcbiAgICAgICB8IHQsIFZhciB4IC0+IGF1eCAoKFZhciB4LHQpOjpxKSBzXG4gICAgICAgfCBBcHAgKGYxLGExKSwgQXBwIChmMixhMikgLT5cbiAgICAgICAgICBpZiBub3QgKE9wLmVxIGYxIGYyKSB0aGVuIHJhaXNlIE5vdF91bmlmaWFibGU7XG4gICAgICAgICAgbGV0IHEgPSAoTGlzdC5tYXAyIHBhaXIgYTEgYTIpIEAgcSBpblxuICAgICAgICAgIGF1eCBxIHNcbiAgaW5cbiAgbGV0IHMgPSBhdXggW3QxLHQyXSBTdWJzdC5lbXB0eSBpblxuICBhc3NlcnQgKGVxIChTdWJzdC5hcHAgcyB0MSkgKFN1YnN0LmFwcCBzIHQyKSk7XG4gIHNcblxuKCpcbmxldCB1bmlmeSB0MSB0MiA9XG4gIGxldCBzID0gdW5pZnkgdDEgdDIgaW5cbiAgbGV0IHZhciA9IFZhci5uYW1lciAoKSBpblxuICBsZXQgdDEgPSB0b19zdHJpbmcgfnZhciB0MSBpblxuICBsZXQgdDIgPSB0b19zdHJpbmcgfnZhciB0MiBpblxuICBsZXQgc3MgPSBTdWJzdC50b19zdHJpbmcgfnZhciBzIGluXG4gIFByaW50Zi5wcmludGYgXCJVTklGWSAlcyBXSVRIICVzIElTICVzXFxuJSFcIiB0MSB0MiBzcztcbiAgc1xuKilcblxuKCoqIFdoZXRoZXIgYSBwYXR0ZXJuIG1hdGNoZXMgYSB0ZXJtLiAqKVxubGV0IG1hdGNoZXMgdDEgdDIgPVxuICBsZXQgcmVjIGF1eCBxIHMgPVxuICAgIG1hdGNoIHEgd2l0aFxuICAgIHwgW10gLT4gc1xuICAgIHwgcDo6cSAtPlxuICAgICAgbWF0Y2ggcCB3aXRoXG4gICAgICB8IFZhciB4LCB0IC0+XG4gICAgICAgIGlmIFN1YnN0LmluX2RvbSBzIHggdGhlbiAoaWYgZXEgKFN1YnN0LmFwcCBzIChWYXIgeCkpIHQgdGhlbiBhdXggcSBzIGVsc2UgcmFpc2UgTm90X3VuaWZpYWJsZSlcbiAgICAgICAgZWxzZSBhdXggcSAoU3Vic3QuYWRkIHMgeCB0KVxuICAgICAgfCBfLCBWYXIgXyAtPiByYWlzZSBOb3RfdW5pZmlhYmxlXG4gICAgICB8IEFwcCAoZjEsYTEpLCBBcHAgKGYyLGEyKSAtPlxuICAgICAgICBpZiBub3QgKE9wLmVxIGYxIGYyKSB0aGVuIHJhaXNlIE5vdF91bmlmaWFibGU7XG4gICAgICAgIGxldCBxID0gKExpc3QubWFwMiBwYWlyIGExIGEyKUBxIGluXG4gICAgICAgIGF1eCBxIHNcbiAgaW5cbiAgYXV4IFt0MSx0Ml0gU3Vic3QuZW1wdHlcblxuKCpcbmxldCBtYXRjaGVzIHQxIHQyID1cbiAgbGV0IHMgPSBtYXRjaGVzIHQxIHQyIGluXG4gIFByaW50Zi5wcmludGYgXCJNQVRDSCAlcyBXSVRIICVzIElTICVzXFxuJSFcIiAodG9fc3RyaW5nIHQxKSAodG9fc3RyaW5nIHQyKSAoU3Vic3QudG9fc3RyaW5nIHMpO1xuICBzXG4gKilcblxuKCoqIFdoZXRoZXIgdHdvIHRlcm1zIGFyZSBhbHBoYS1lcXVpdmFsZW50ICopXG5sZXQgZXF1aXZhbGVudCA/KHM9U3Vic3QuZW1wdHkpICh0MTp0KSAodDI6dCkgPVxuICBsZXQgcmVjIGF1eCBxIHMgPVxuICAgIG1hdGNoIHEgd2l0aFxuICAgIHwgW10gLT4gc1xuICAgIHwgcDo6cSAtPlxuICAgICAgbWF0Y2ggcCB3aXRoXG4gICAgICB8IFZhciB4LCBWYXIgeSAtPlxuICAgICAgICBpZiBTdWJzdC5pbl9kb20gcyB4IHRoZW4gKGlmIGVxIChTdWJzdC5hcHAgcyAoVmFyIHgpKSAoVmFyIHkpIHRoZW4gYXV4IHEgcyBlbHNlIHJhaXNlIE5vdF91bmlmaWFibGUpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgcyA9IFN1YnN0LmFkZCBzIHggKFZhciB5KSBpblxuICAgICAgICAgIGF1eCBxIHNcbiAgICAgIHwgXywgVmFyIF8gfCBWYXIgXywgXyAtPiByYWlzZSBOb3RfdW5pZmlhYmxlXG4gICAgICB8IEFwcCAoZjEsYTEpLCBBcHAgKGYyLGEyKSAtPlxuICAgICAgICBpZiBub3QgKE9wLmVxIGYxIGYyKSB0aGVuIHJhaXNlIE5vdF91bmlmaWFibGU7XG4gICAgICAgIGxldCBxID0gKExpc3QubWFwMiBwYWlyIGExIGEyKUBxIGluXG4gICAgICAgIGF1eCBxIHNcbiAgaW5cbiAgdHJ5IGlnbm9yZSAoYXV4IFt0MSx0Ml0gcyk7IHRydWVcbiAgd2l0aCBOb3RfdW5pZmlhYmxlIC0+IGZhbHNlXG5cbigqKiBSZXdyaXRpbmcgc3lzdGVtcy4gKilcbm1vZHVsZSBSUyA9IHN0cnVjdFxuICBsZXQgbGlzdF9yZW1vdmVfbnRoIG4gbCA9XG4gICAgbGV0IHJlYyBhdXggbiBwID0gZnVuY3Rpb25cbiAgICAgIHwgeDo6bCAtPiBpZiBuID0gMCB0aGVuIExpc3QucmV2IHAsIGwgZWxzZSBhdXggKG4tMSkgKHg6OnApIGxcbiAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgaW5cbiAgICBhdXggbiBbXSBsXG5cbiAgKCoqIFJld3JpdGluZyBydWxlcy4gKilcbiAgbW9kdWxlIFJ1bGUgPSBzdHJ1Y3RcbiAgICAoKiogQSByZXdyaXRpbmcgcnVsZS4gKilcbiAgICB0eXBlIHQgPSBzdHJpbmcgKiB0ZXJtICogdGVybVxuXG4gICAgbGV0IG1ha2UgciBzIHQgOiB0ID0gKHIscyx0KVxuXG4gICAgbGV0IG9mX3N0cmluZyBvcHMgciBzIHQgPVxuICAgICAgbGV0IHMgPSBwYXJzZSBvcHMgcyBpblxuICAgICAgbGV0IHQgPSBwYXJzZSBvcHMgdCBpblxuICAgICAgbWFrZSByIHMgdFxuXG4gICAgbGV0IG5hbWUgKChyLHMsdCk6dCkgPSByXG5cbiAgICBsZXQgc291cmNlICgocixzLHQpOnQpID0gc1xuXG4gICAgbGV0IHRhcmdldCAoKHIscyx0KTp0KSA9IHRcblxuICAgICgqKiBWYXJpYWJsZXMgb2YgdGhlIHJ1bGUuICopXG4gICAgbGV0IHZhcnMgciA9IHZhcnMgKHNvdXJjZSByKVxuXG4gICAgKCoqIEFyaXR5IG9mIHRoZSBydWxlLiAqKVxuICAgIGxldCBhcml0eSByID0gTGlzdC5sZW5ndGggKHZhcnMgcilcblxuICAgICgqKiBBcmd1bWVudHMgb2YgYSBydWxlLCBzb3J0ZWQgYWNjb3JkaW5nIHRvIGl0cyB2YXJpYWJsZXMuICopXG4gICAgbGV0IGFyZ3MgciBzID1cbiAgICAgIGxldCB2YXJzID0gdmFycyByIGluXG4gICAgICBsZXQgYXJncyA9IExpc3Quc29ydCAoZnVuICh4LHQpICh5LHUpIC0+IExpc3QuaW5kZXggKGZ1biB6IC0+IFZhci5lcSB6IHgpIHZhcnMgLSBMaXN0LmluZGV4IChmdW4geiAtPiBWYXIuZXEgeiB5KSB2YXJzKSBzIGluXG4gICAgICBMaXN0Lm1hcCBzbmQgYXJnc1xuXG4gICAgKCoqIFN1YnN0aXR1dGlvbiBmcm9tIGFyZ3VtZW50cy4gKilcbiAgICBsZXQgYXJnc19zdWJzdCByIGEgOiBTdWJzdC50ID1cbiAgICAgIExpc3QubWFwMiAoZnVuIHggdCAtPiB4LHQpICh2YXJzIHIpIGFcblxuICAgICgqKiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBydWxlLiAqKVxuICAgIGxldCB0b19zdHJpbmcgP3ZhciByID1cbiAgICAgIGxldCBzID0gdG9fc3RyaW5nID92YXIgKHNvdXJjZSByKSBpblxuICAgICAgbGV0IHQgPSB0b19zdHJpbmcgP3ZhciAodGFyZ2V0IHIpIGluXG4gICAgICBuYW1lIHIgXiBcIiA6IFwiIF4gcyBeIFwiIC0+IFwiIF4gdFxuXG4gICAgKCoqIEVxdWFsaXR5IG9mIHJ1bGVzLiAqKVxuICAgICgqXG4gICAgbGV0IGVxIChyMTp0KSAocjI6dCkgPVxuICAgICAgKCogUHJpbnRmLnByaW50ZiBcIkVRICVzIFdJVEggJXNcXG4lIVwiICh0b19zdHJpbmcgcjEpICh0b19zdHJpbmcgcjIpOyAqKVxuICAgICAgaWYgbmFtZSByMSA8PiBuYW1lIHIyIHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICB0cnlcbiAgICAgICAgICBsZXQgcyA9IGVxdWl2YWxlbnQgKHNvdXJjZSByMSkgKHNvdXJjZSByMikgaW5cbiAgICAgICAgICBlcSAoU3Vic3QuYXBwIHMgKHRhcmdldCByMSkpICh0YXJnZXQgcjIpXG4gICAgICAgIHdpdGhcbiAgICAgICAgfCBOb3RfdW5pZmlhYmxlIC0+IGZhbHNlXG4gICAgKilcbiAgICBsZXQgZXEgcjEgcjIgPSBuYW1lIHIxID0gbmFtZSByMlxuICBlbmRcblxuICB0eXBlIHJ1bGUgPSBSdWxlLnRcblxuICAoKiogQSByZXdyaXRpbmcgc3lzdGVtLiAqKVxuICB0eXBlIHQgPVxuICAgIHtcbiAgICAgIG9wZXJhdGlvbnMgOiBPcC50IGxpc3Q7XG4gICAgICBydWxlcyA6IHJ1bGUgbGlzdFxuICAgIH1cbiAgdHlwZSBycyA9IHRcblxuICBsZXQgb3BlcmF0aW9ucyBycyA9IHJzLm9wZXJhdGlvbnNcblxuICBsZXQgcnVsZXMgcnMgPSBycy5ydWxlc1xuXG4gIGxldCBtYWtlIG9wZXJhdGlvbnMgcnVsZXMgPVxuICAgIHsgb3BlcmF0aW9uczsgcnVsZXMgfVxuXG4gICgqKiBFbXB0eSByZXdyaXRpbmcgc3lzdGVtLiAqKVxuICBsZXQgZW1wdHkgb3BzID0gbWFrZSBvcHMgW11cblxuICBsZXQgdG9fc3RyaW5nID8odmFyPVZhci5uYW1lcikgcnMgPVxuICAgIFN0cmluZy5jb25jYXQgXCJcXG5cIiAoTGlzdC5tYXAgKGZ1biByIC0+IFJ1bGUudG9fc3RyaW5nIH52YXI6KHZhcigpKSByKSAocnVsZXMgcnMpKVxuXG4gICgqKiBGaW5kIHRoZSBydWxlIHdpdGggZ2l2ZW4gbmFtZS4gKilcbiAgbGV0IGZpbmQgcnMgciA9XG4gICAgTGlzdC5maW5kIChmdW4gcicgLT4gUnVsZS5uYW1lIHInID0gcikgKHJ1bGVzIHJzKVxuXG4gICgqKiBSZXdyaXRpbmcgc3RlcHMuICopXG4gIG1vZHVsZSBTdGVwID0gc3RydWN0XG4gICAgKCoqIEEgcmV3cml0aW5nIHN0ZXAuICopXG4gICAgdHlwZSB0ID1cbiAgICAgIHwgVEFwcCBvZiBPcC50ICogdGVybSBsaXN0ICogdCAqIHRlcm0gbGlzdCAoKiogVGVybSBhcHBsaWNhdGlvbi4gKilcbiAgICAgIHwgUkFwcCBvZiBSdWxlLnQgKiBTdWJzdC50ICgqKiBSdWxlIGFwcGxpY2F0aW9uLiAqKVxuXG4gICAgbGV0IG9mX3Rlcm0gXyA9IGFzc2VydCBmYWxzZVxuXG4gICAgbGV0IHRhcHAgZiBhMSBzIGEyID1cbiAgICAgIGFzc2VydCAoTGlzdC5sZW5ndGggYTEgKyAxICsgTGlzdC5sZW5ndGggYTIgPSBPcC5hcml0eSBmKTtcbiAgICAgIFRBcHAgKGYsIGExLCBzLCBhMilcblxuICAgIGxldCByYXBwIHIgcyA9XG4gICAgICAoKiBQcmludGYucHJpbnRmIFwicmFwcDogJXMgdG8gJXNcXG4lIVwiIChSdWxlLnRvX3N0cmluZyByKSAoU3Vic3QudG9fc3RyaW5nIHMpOyAqKVxuICAgICAgbGV0IHZyID0gUnVsZS52YXJzIHIgaW5cbiAgICAgIGxldCB2cyA9IFN1YnN0LmRvbWFpbiBzIGluXG4gICAgICBhc3NlcnQgKExpc3QuZm9yX2FsbCAoZnVuIHggLT4gTGlzdC5leGlzdHMgKFZhci5lcSB4KSB2cykgdnIpO1xuICAgICAgYXNzZXJ0IChMaXN0LmZvcl9hbGwgKGZ1biB4IC0+IExpc3QuZXhpc3RzIChWYXIuZXEgeCkgdnIpIHZzKTtcbiAgICAgIFJBcHAgKHIsIHMpXG5cbiAgICAoKiogQXBwbHkgYSBzdWJzdGl0dXRpb24uICopXG4gICAgbGV0IHJlYyBzdWJzdCBzID0gZnVuY3Rpb25cbiAgICAgIHwgVEFwcCAoZiwgYTEsIHN0LCBhMikgLT4gdGFwcCBmIChMaXN0Lm1hcCAoU3Vic3QuYXBwIHMpIGExKSAoc3Vic3QgcyBzdCkgKExpc3QubWFwIChTdWJzdC5hcHAgcykgYTIpXG4gICAgICB8IFJBcHAgKHIsIHMnKSAtPiByYXBwIHIgKFN1YnN0LmNvbXBvc2UgcycgcylcblxuICAgICgqKiBTb3VyY2UuICopXG4gICAgbGV0IHJlYyBzb3VyY2UgPSBmdW5jdGlvblxuICAgICAgfCBUQXBwIChmLCBhMSwgcywgYTIpIC0+IGFwcCBmIChhMUBbc291cmNlIHNdQGEyKVxuICAgICAgfCBSQXBwIChyLCBzKSAtPiBTdWJzdC5hcHAgcyAoUnVsZS5zb3VyY2UgcilcblxuICAgICgqKiBUYXJnZXQuICopXG4gICAgbGV0IHJlYyB0YXJnZXQgPSBmdW5jdGlvblxuICAgICAgfCBUQXBwIChmLCBhMSwgcywgYTIpIC0+IGFwcCBmIChhMUBbdGFyZ2V0IHNdQGEyKVxuICAgICAgfCBSQXBwIChyLCBzKSAtPiBTdWJzdC5hcHAgcyAoUnVsZS50YXJnZXQgcilcblxuICAgIGxldCByZWMgbGFiZWwgPyh2YXI9VmFyLnRvX3N0cmluZykgPSBmdW5jdGlvblxuICAgICAgfCBUQXBwIChmLCBhMSwgcywgYTIpIC0+XG4gICAgICAgIGxldCBhMSA9IExpc3QubWFwIChzdHJpbmdfb2ZfdGVybSB+dmFyKSBhMSBpblxuICAgICAgICBsZXQgYTIgPSBMaXN0Lm1hcCAoc3RyaW5nX29mX3Rlcm0gfnZhcikgYTIgaW5cbiAgICAgICAgbGV0IGEgPSBhMUBbbGFiZWwgfnZhciBzXUBhMiBpblxuICAgICAgICBPcC50b19zdHJpbmcgZiBhXG4gICAgICB8IFJBcHAgKHIsIHMpIC0+XG4gICAgICAgIGxldCBhID0gUnVsZS5hcmdzIHIgcyBpblxuICAgICAgICBsZXQgYSA9IExpc3QubWFwIChzdHJpbmdfb2ZfdGVybSB+dmFyKSBhIGluXG4gICAgICAgIGxldCBhID0gU3RyaW5nLmNvbmNhdCBcIixcIiBhIGluXG4gICAgICAgIFJ1bGUubmFtZSByIF4gXCIoXCIgXiBhIF4gXCIpXCJcblxuICAgIGxldCB0b19zdHJpbmcgP3ZhciBzID1cbiAgICAgIHN0cmluZ19vZl90ZXJtID92YXIgKHNvdXJjZSBzKSBeIFwiIC1cIiBeIGxhYmVsID92YXIgcyBeIFwiLT4gXCIgXiBzdHJpbmdfb2ZfdGVybSA/dmFyICh0YXJnZXQgcylcblxuICAgIGxldCByZWMgcnVsZSA9IGZ1bmN0aW9uXG4gICAgICB8IFRBcHAgKGYsIGExLCBzLCBhMikgLT4gcnVsZSBzXG4gICAgICB8IFJBcHAgKHIsIF8pIC0+IHJcblxuICAgIGxldCBoYXNfY29udGV4dCA9IGZ1bmN0aW9uXG4gICAgICB8IFRBcHAgXyAtPiB0cnVlXG4gICAgICB8IFJBcHAgKHIsIHMpIC0+IG5vdCAoU3Vic3QuaXNfaW5qZWN0aXZlX3JlbmFtaW5nIHMpXG5cbiAgICBsZXQgcmVjIGVxIHMxIHMyID1cbiAgICAgICgqIFByaW50Zi5wcmludGYgXCJlcTogJXMgdnMgJXNcXG4lIVwiICh0b19zdHJpbmcgczEpICh0b19zdHJpbmcgczIpOyAqKVxuICAgICAgbWF0Y2ggczEsczIgd2l0aFxuICAgICAgfCBUQXBwIChmLCBhMSwgcywgYTIpLCBUQXBwIChmJywgYTEnLCBzJywgYTInKSAtPlxuICAgICAgICBPcC5lcSBmIGYnICYmXG4gICAgICAgIExpc3QubGVuZ3RoIGExID0gTGlzdC5sZW5ndGggYTEnICYmXG4gICAgICAgIExpc3QubGVuZ3RoIGEyID0gTGlzdC5sZW5ndGggYTInICYmXG4gICAgICAgIExpc3QuZm9yX2FsbDIgZXFfdGVybSBhMSBhMScgJiZcbiAgICAgICAgZXEgcyBzJyAmJlxuICAgICAgICBMaXN0LmZvcl9hbGwyIGVxX3Rlcm0gYTIgYTInXG4gICAgICB8IFJBcHAgKHIsIHMpLCBSQXBwIChyJywgcycpIC0+IFJ1bGUuZXEgciByJyAmJiBTdWJzdC5lcSBzIHMnXG4gICAgICB8IF8gLT4gZmFsc2VcbiAgICBcbiAgICAoKiogV2hldGhlciBhIHJ1bGUgb2NjdXJzIGluIGEgc3RlcC4gKilcbiAgICBsZXQgcmVjIGhhc19ydWxlIHIgPSBmdW5jdGlvblxuICAgICAgfCBUQXBwIChfLCBfLCBzLCBfKSAtPiBoYXNfcnVsZSByIHNcbiAgICAgIHwgUkFwcCAocicsIF8pIC0+IFJ1bGUuZXEgciByJ1xuICBlbmRcblxuICB0eXBlIHN0ZXAgPSBTdGVwLnRcblxuICAoKiogQWxsIHBvc3NpYmxlIHJld3JpdGluZyBzdGVwcy4gKilcbiAgbGV0IHN0ZXBzIChyczp0KSB0IDogc3RlcCBsaXN0ID1cbiAgICBsZXQgcmVjIGF1eCByIGN0eCA9IGZ1bmN0aW9uXG4gICAgICB8IFZhciB4IC0+IFtdXG4gICAgICB8IEFwcCAoZixhKSBhcyB0IC0+XG4gICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgIHRyeVxuICAgICAgICAgICAgIGxldCBzID0gbWF0Y2hlcyAoUnVsZS5zb3VyY2UgcikgdCBpblxuICAgICAgICAgICAgIFtjdHggKFN0ZXAucmFwcCByIHMpXVxuICAgICAgICAgICB3aXRoXG4gICAgICAgICAgIHwgTm90X3VuaWZpYWJsZSAtPiBbXVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBzJyA9XG4gICAgICAgICAgIExpc3QubWFwaVxuICAgICAgICAgICAgIChmdW4gaSB0IC0+XG4gICAgICAgICAgICAgICAgbGV0IGExLCBhMiA9IGxpc3RfcmVtb3ZlX250aCBpIGEgaW5cbiAgICAgICAgICAgICAgICBsZXQgY3R4IHQgPSBjdHggKFN0ZXAudGFwcCBmIGExIHQgYTIpIGluXG4gICAgICAgICAgICAgICAgYXV4IHIgY3R4IHRcbiAgICAgICAgICAgICApIGFcbiAgICAgICAgIGluXG4gICAgICAgICBsZXQgcycgPSBMaXN0LmZsYXR0ZW4gcycgaW5cbiAgICAgICAgIHMnIEAgc1xuICAgIGluXG4gICAgTGlzdC5mbGF0dGVuIChMaXN0Lm1hcCAoZnVuIHIgLT4gYXV4IHIgaWQgdCkgKHJ1bGVzIHJzKSlcblxuICAoKiogUmV3cml0aW5nIHBhdGhzLiAqKVxuICBtb2R1bGUgUGF0aCA9IHN0cnVjdCAgICBcbiAgICAoKiogQSByZXdyaXRpbmcgcGF0aC4gKilcbiAgICB0eXBlIHQgPVxuICAgICAgfCBFbXB0eSBvZiB0ZXJtXG4gICAgICB8IFN0ZXAgb2YgdCAqIHN0ZXBcblxuICAgIGxldCBlbXB0eSB0ID0gRW1wdHkgdFxuXG4gICAgbGV0IHJlYyBzb3VyY2UgPSBmdW5jdGlvblxuICAgICAgfCBTdGVwIChwLF8pIC0+IHNvdXJjZSBwXG4gICAgICB8IEVtcHR5IHQgLT4gdFxuXG4gICAgbGV0IHRhcmdldCA9IGZ1bmN0aW9uXG4gICAgICB8IFN0ZXAgKF8scykgLT4gU3RlcC50YXJnZXQgc1xuICAgICAgfCBFbXB0eSB0IC0+IHRcblxuICAgIGxldCBzdGVwIHMgPVxuICAgICAgU3RlcCAoRW1wdHkgKFN0ZXAuc291cmNlIHMpLCBzKVxuIFxuICAgIGxldCBhcHBlbmRfc3RlcCBwIHMgPVxuICAgICAgYXNzZXJ0IChlcSAodGFyZ2V0IHApIChTdGVwLnNvdXJjZSBzKSk7XG4gICAgICBTdGVwIChwLHMpXG5cbiAgICBsZXQgcmVjIHRvX3N0cmluZyA/dmFyID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgdCAtPiBzdHJpbmdfb2ZfdGVybSA/dmFyIHRcbiAgICAgIHwgU3RlcCAocCxzKSAtPlxuICAgICAgICBsZXQgc3JjID0gdG9fc3RyaW5nID92YXIgcCBpblxuICAgICAgICBsZXQgbGJsID0gU3RlcC5sYWJlbCA/dmFyIHMgaW5cbiAgICAgICAgbGV0IHRndCA9IHN0cmluZ19vZl90ZXJtID92YXIgKFN0ZXAudGFyZ2V0IHMpIGluXG4gICAgICAgIHNyYyBeIFwiIC1cIiBeIGxibCBeIFwiLT4gXCIgXiB0Z3RcblxuICAgIGxldCByZWMgYXBwZW5kIHAgPSBmdW5jdGlvblxuICAgICAgfCBTdGVwIChxLCBzKSAtPiBTdGVwIChhcHBlbmQgcCBxLCBzKVxuICAgICAgfCBFbXB0eSB0IC0+XG4gICAgICAgICBhc3NlcnQgKGVxICh0YXJnZXQgcCkgdCk7XG4gICAgICAgICBwXG5cbiAgICAoKiogUnVsZXMgd2hpY2ggYXJlIHVzZWQgd2l0aG91dCBjb250ZXh0LiAqKVxuICAgIGxldCByZWMgdG9wbGV2ZWxfcnVsZXMgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSB0IC0+IFtdXG4gICAgICB8IFN0ZXAgKHAscykgLT4gKHRvcGxldmVsX3J1bGVzIHApQChpZiBTdGVwLmhhc19jb250ZXh0IHMgdGhlbiBbXSBlbHNlIFtTdGVwLnJ1bGUgc10pXG5cbiAgICBsZXQgcmVjIGVxIHAgcCcgPVxuICAgICAgbWF0Y2ggcCxwJyB3aXRoXG4gICAgICB8IFN0ZXAgKHAscyksIFN0ZXAgKHAnLHMnKSAtPiBlcSBwIHAnICYmIFN0ZXAuZXEgcyBzJ1xuICAgICAgfCBFbXB0eSB0LCBFbXB0eSB0JyAtPiBlcV90ZXJtIHQgdCdcbiAgICAgIHwgXyAtPiBmYWxzZVxuXG4gICAgKCoqIFJ1bGVzIG9jY3VycmluZyBpbiBhIHN0ZXAuICopXG4gICAgbGV0IHJlYyBydWxlcyA9IGZ1bmN0aW9uXG4gICAgICB8IFN0ZXAgKHAscykgLT5cbiAgICAgICAgbGV0IHIgPSBTdGVwLnJ1bGUgcyBpblxuICAgICAgICBsZXQgcnIgPSBydWxlcyBwIGluXG4gICAgICAgIGlmIExpc3QuZXhpc3RzIChSdWxlLmVxIHIpIHJyIHRoZW4gcnJcbiAgICAgICAgZWxzZSByOjpyclxuICAgICAgfCBFbXB0eSBfIC0+IFtdXG5cbiAgICAoKiogTGVuZ3RoIG9mIGEgcGF0aC4gKilcbiAgICBsZXQgcmVjIGxlbmd0aCA9IGZ1bmN0aW9uXG4gICAgICB8IFN0ZXAgKHAsIF8pIC0+IDEgKyBsZW5ndGggcFxuICAgICAgfCBFbXB0eSBfIC0+IDBcblxuICAgICgqKiBudGggc3RlcCBpbiBhIHBhdGguICopXG4gICAgbGV0IG50aF9zdGVwIG4gcCA9XG4gICAgICBsZXQgcmVjIGF1eCBuID0gZnVuY3Rpb25cbiAgICAgICAgfCBTdGVwIChwLCBzKSAtPlxuICAgICAgICAgIGlmIG4gPSAwIHRoZW4gcyBlbHNlIGF1eCAobi0xKSBwXG4gICAgICAgIHwgRW1wdHkgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIGluXG4gICAgICBhdXggKGxlbmd0aCBwIC0gMSAtIG4pIHBcblxuICAgICgqKiBudGggdGVybSBpbiBhIHBhdGguICopXG4gICAgbGV0IG50aF90ZXJtIG4gcCA9XG4gICAgICBsZXQgcmVjIGF1eCBuID0gZnVuY3Rpb25cbiAgICAgICAgfCBTdGVwIChwLCBzKSAtPlxuICAgICAgICAgIGlmIG4gPSAwIHRoZW4gU3RlcC50YXJnZXQgcyBlbHNlIGF1eCAobi0xKSBwXG4gICAgICAgIHwgRW1wdHkgdCAtPlxuICAgICAgICAgIGlmIG4gPSAwIHRoZW4gdCBlbHNlIGFzc2VydCBmYWxzZVxuICAgICAgaW5cbiAgICAgIGF1eCAobGVuZ3RoIHAgLSBuKSBwXG4gIGVuZFxuXG4gICgqKiBOb3JtYWxpemUgYSB0ZXJtLiAqKVxuICBsZXQgbm9ybWFsaXplIHJzIHQgPVxuICAgIGxldCByZWMgYXV4IHAgPVxuICAgICAgbGV0IHMgPSBzdGVwcyBycyAoUGF0aC50YXJnZXQgcCkgaW5cbiAgICAgIGlmIHMgPSBbXSB0aGVuIHAgZWxzZSBhdXggKFBhdGguYXBwZW5kX3N0ZXAgcCAoTGlzdC5oZCBzKSlcbiAgICBpblxuICAgIGF1eCAoUGF0aC5lbXB0eSB0KVxuXG4gICgqKiBVbmlmeSB0aGUgc291cmNlIG9mIFtyMl0gd2l0aCBhIHN1YnRlcm0gb2YgdGhlIHNvdXJjZSBvZiBbcjFdLiAqKVxuICBsZXQgY3JpdGljYWxfcnVsZXMgcjEgcjIgPVxuICAgIGxldCByZWMgYXV4IGN0eCB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBWYXIgeCAtPiBbXVxuICAgICAgfCBBcHAgKGYsYSkgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbGV0IHQyID0gUnVsZS5zb3VyY2UgcjIgaW5cbiAgICAgICAgICAgICgqIFdlIHJlbmFtZSBydWxlIDIgYmVmb3JlIHVuaWZpY2F0aW9uLiBOb3RlIHRoYXQgd2UgY2Fubm90IHJlbmFtZVxuICAgICAgICAgICAgICAgcnVsZSAxIGJlY2F1c2Ugc29tZSBvZiBpdHMgdmFyaWFibGVzIGNhbiBvY2N1ciBpbiB0aGUgY29udGV4dC4gKilcbiAgICAgICAgICAgIGxldCBuMiA9IFN1YnN0LnJlbmFtZSAoUnVsZS52YXJzIHIyKSBpblxuICAgICAgICAgICAgbGV0IHMgPSB1bmlmeSB0IChTdWJzdC5hcHAgbjIgdDIpIGluXG4gICAgICAgICAgICAoKiBFeHRlbmQgdGhlIGRvbWFpbiBvZiBkZWZpbml0aW9uLiAqKVxuICAgICAgICAgICAgbGV0IHN0ZXAxID0gU3RlcC5yYXBwIHIxIChTdWJzdC5jb21wb3NlIChTdWJzdC5pZCAoUnVsZS52YXJzIHIxKSkgcykgaW5cbiAgICAgICAgICAgIGxldCBzdGVwMiA9IFN0ZXAuc3Vic3QgcyAoY3R4IChTdGVwLnJhcHAgcjIgbjIpKSBpblxuICAgICAgICAgICAgYXNzZXJ0IChlcXVpdmFsZW50IChTdGVwLnNvdXJjZSBzdGVwMSkgKFN0ZXAuc291cmNlIHN0ZXAyKSk7XG4gICAgICAgICAgICBpZiBSdWxlLmVxIHIxIHIyICYmIG5vdCAoU3RlcC5oYXNfY29udGV4dCBzdGVwMSkgJiYgbm90IChTdGVwLmhhc19jb250ZXh0IHN0ZXAyKSB0aGVuIFtdIGVsc2UgW3N0ZXAxLHN0ZXAyXVxuICAgICAgICAgIHdpdGhcbiAgICAgICAgICB8IE5vdF91bmlmaWFibGUgLT4gW11cbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHMnID1cbiAgICAgICAgICBMaXN0Lm1hcGlcbiAgICAgICAgICAgIChmdW4gaSB0IC0+XG4gICAgICAgICAgICAgICBsZXQgYTEsIGEyID0gbGlzdF9yZW1vdmVfbnRoIGkgYSBpblxuICAgICAgICAgICAgICAgbGV0IGN0eCB0ID0gY3R4IChTdGVwLnRhcHAgZiBhMSB0IGEyKSBpblxuICAgICAgICAgICAgICAgYXV4IGN0eCB0KSBhXG4gICAgICAgIGluXG4gICAgICAgIGxldCBzJyA9IExpc3QuZmxhdHRlbiBzJyBpblxuICAgICAgICBzIEAgcydcbiAgICBpblxuICAgIGF1eCBpZCAoUnVsZS5zb3VyY2UgcjEpXG5cbiAgKCoqIENyaXRpY2FsIGJyYW5jaGluZ3MuICopXG4gIGxldCBjcml0aWNhbCAocnM6dCkgPVxuICAgIGxldCBzdGVwcyA9IExpc3QuZmxhdHRlbiAoTGlzdC5mbGF0dGVuIChMaXN0Lm1hcCAoZnVuIHIxIC0+IExpc3QubWFwIChmdW4gcjIgLT4gY3JpdGljYWxfcnVsZXMgcjEgcjIpIChydWxlcyBycykpIChydWxlcyBycykpKSBpblxuICAgICgqIFJlbW92ZSBzeW1tZXRyaWMgcGFpcnMuICopXG4gICAgbGV0IHJlYyBzeW0gPSBmdW5jdGlvblxuICAgICAgfCAoczEsczIpOjpzdGVwcyAtPlxuICAgICAgICAgbGV0IHN0ZXBzID0gTGlzdC5maWx0ZXIgKGZ1biAoczInLHMxJykgLT4gbm90IChTdGVwLmVxIHMxIHMxJyAmJiBTdGVwLmVxIHMyIHMyJykpIHN0ZXBzIGluXG4gICAgICAgICAoczEsczIpOjooc3ltIHN0ZXBzKVxuICAgICAgfCBbXSAtPiBbXVxuICAgIGluXG4gICAgc3ltIHN0ZXBzXG5cbiAgKCoqIE9yaWVudCBydWxlcyBhY2NvcmRpbmcgdG8gYSBwYXJ0aWN1bGFyIG9yZGVyLiAqKVxuICBsZXQgb3JpZW50IH5ndCBycyA9XG4gICAgbGV0IHJ1bGVzID0gTGlzdC5tYXAgKGZ1biAobix0LHUpIC0+IGlmIG5vdCAoZ3QgdCB1KSB0aGVuIChuLHUsdCkgZWxzZSAobix0LHUpKSAocnVsZXMgcnMpIGluXG4gICAgeyBvcGVyYXRpb25zID0gcnMub3BlcmF0aW9uczsgcnVsZXMgfVxuXG4gICgqKiBLbnV0aC1CZW5kaXggY29tcGxldGlvbi4gW2d0XSBpcyB0aGUgc3RyaWN0IG9yZGVyIG9uIHRlcm1zLCBbY2FsbGJhY2tdIGlzXG4gICAgICBhIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCByZWd1bGFybHkgd2l0aCB0aGUgY3VycmVudCByZXdyaXRpbmcgc3lzdGVtIGFzXG4gICAgICBhcmd1bWVudCAodXNlZnVsIHRvIGRpc3BsYXkgZHVyaW5nIHRoZSBjb21wbGV0aW9uKS4gKilcbiAgbGV0IGtudXRoX2JlbmRpeCA/KGd0PUxQTy5ndCAoPj0pKSA/bmFtZXIgPyhjYWxsYmFjaz1mdW4gXyAtPiAoKSkgcnMgPVxuICAgIGxldCBycyA9IG9yaWVudCB+Z3QgcnMgaW5cbiAgICAoKiBOYW1lIGZvciBuZXcgcnVsZXMuICopXG4gICAgbGV0IG5hbWVyID1cbiAgICAgIG1hdGNoIG5hbWVyIHdpdGhcbiAgICAgIHwgU29tZSBuYW1lciAtPiBuYW1lclxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIGxldCBuID0gcmVmICgtMSkgaW5cbiAgICAgICAgZnVuICgpIC0+IGluY3IgbjsgXCJLXCJec3RyaW5nX29mX2ludCAhblxuICAgIGluXG4gICAgKCogUnVsZXMgdG8gaGFuZGxlLiAqKVxuICAgIGxldCBxdWV1ZSA9IHJlZiBycy5ydWxlcyBpblxuICAgICgqIFByb2R1Y2VkIHJld3JpdGluZyBzeXN0ZW0uICopXG4gICAgbGV0IHJ1bGVzID0gcmVmIHJzLnJ1bGVzIGluXG4gICAgbGV0IGFkZCAocjpSdWxlLnQpID1cbiAgICAgICgqIFByaW50Zi5wcmludGYgXCJhZGQgJXNcXG4lIVwiIChSdWxlLnRvX3N0cmluZyByKTsgKilcbiAgICAgIHJ1bGVzIDo9IHIgOjogIXJ1bGVzO1xuICAgICAgKCogTm9ybWFsaXplIHRoZSBydWxlcyAqKVxuICAgICAgcnVsZXMgOj1cbiAgICAgICAgTGlzdC5tYXBcbiAgICAgICAgICAoZnVuICgobixzLHQpIGFzIHIpIC0+XG4gICAgICAgICAgICAgKCogVE9ETzogcHJvcGVyIHJlY3Vyc2l2ZSBmdW5jdGlvbiBpbnN0ZWFkIG9mIHRoaXMgZmlsdGVyICopXG4gICAgICAgICAgICAgbGV0IHJ1bGVzID0gTGlzdC5maWx0ZXIgKGZ1biByJyAtPiBub3QgKFJ1bGUuZXEgciByJykpICFydWxlcyBpblxuICAgICAgICAgICAgIGxldCBycyA9IHsgcnMgd2l0aCBydWxlcyB9IGluXG4gICAgICAgICAgICAgbiwgUGF0aC50YXJnZXQgKG5vcm1hbGl6ZSBycyBzKSwgUGF0aC50YXJnZXQgKG5vcm1hbGl6ZSBycyB0KVxuICAgICAgICAgICkgIXJ1bGVzO1xuICAgICAgcnVsZXMgOj0gTGlzdC5maWx0ZXIgKGZ1biAobixzLHQpIC0+IG5vdCAoZXEgcyB0KSkgIXJ1bGVzO1xuICAgICAgcXVldWUgOj0gIXF1ZXVlQFtyXVxuICAgICAgKCogcXVldWUgOj0gciA6OiAhcXVldWUgKilcbiAgICBpblxuICAgIHdoaWxlICFxdWV1ZSA8PiBbXSBkb1xuICAgICAgbGV0IHIgPSBMaXN0LmhkICFxdWV1ZSBpblxuICAgICAgcXVldWUgOj0gTGlzdC50bCAhcXVldWU7XG4gICAgICBsZXQgY3AgPSBMaXN0LmZsYXR0ZW4gKExpc3QubWFwIChmdW4gcyAtPiAoY3JpdGljYWxfcnVsZXMgciBzKUAoY3JpdGljYWxfcnVsZXMgcyByKSkgIXJ1bGVzKSBpblxuICAgICAgTGlzdC5pdGVyXG4gICAgICAgIChmdW4gKHMxLCBzMikgLT5cbiAgICAgICAgICAgbGV0IHJzID0geyBycyB3aXRoIHJ1bGVzID0gIXJ1bGVzIH0gaW5cbiAgICAgICAgICAgbGV0IHAxID0gUGF0aC5hcHBlbmQgKFBhdGguc3RlcCBzMSkgKG5vcm1hbGl6ZSBycyAoU3RlcC50YXJnZXQgczEpKSBpblxuICAgICAgICAgICBsZXQgcDIgPSBQYXRoLmFwcGVuZCAoUGF0aC5zdGVwIHMyKSAobm9ybWFsaXplIHJzIChTdGVwLnRhcmdldCBzMikpIGluXG4gICAgICAgICAgIGxldCB0MSA9IFBhdGgudGFyZ2V0IHAxIGluXG4gICAgICAgICAgIGxldCB0MiA9IFBhdGgudGFyZ2V0IHAyIGluXG4gICAgICAgICAgIGlmIG5vdCAoZXEgdDEgdDIpIHRoZW5cbiAgICAgICAgICAgICBsZXQgdDEsIHQyID0gaWYgZ3QgdDEgdDIgdGhlbiB0MSwgdDIgZWxzZSB0MiwgdDEgaW5cbiAgICAgICAgICAgICBsZXQgciA9IChuYW1lciAoKSwgdDEsIHQyKSBpblxuICAgICAgICAgICAgIFByaW50Zi5wcmludGYgXCJhZGQgJXNcXG4lc1xcbiVzXFxuXFxuJSFcIiAoUnVsZS50b19zdHJpbmcgcikgKFBhdGgudG9fc3RyaW5nIHAxKSAoUGF0aC50b19zdHJpbmcgcDIpO1xuICAgICAgICAgICAgIGFkZCByXG4gICAgICAgICkgY3A7XG4gICAgICBjYWxsYmFjayB7IHJzIHdpdGggcnVsZXMgPSAhcnVsZXMgfVxuICAgIGRvbmU7XG4gICAgeyBycyB3aXRoIHJ1bGVzID0gIXJ1bGVzIH1cblxuICAoKiogUmFpc2VkIHdoZW4gdGhlIHN5c3RlbSBpcyBub3QgY29uZmx1ZW50LiAqKVxuICBleGNlcHRpb24gTm90X2NvbmZsdWVudFxuXG4gICgqKiBTcXVpZXIgY29tcGxldGlvbi4gKilcbiAgbGV0IHNxdWllciBycyA9XG4gICAgTGlzdC5tYXBcbiAgICAgIChmdW4gKHMxLHMyKSAtPlxuICAgICAgICAgKCogUHJpbnRmLnByaW50ZiBcImJyYW5jaGluZ1xcbiVzXFxuJXNcXG5cXG4lIVwiIChTdGVwLnRvX3N0cmluZyBzMSkgKFN0ZXAudG9fc3RyaW5nIHMyKTsgKilcbiAgICAgICAgIGxldCBwMSA9IFBhdGguYXBwZW5kIChQYXRoLnN0ZXAgczEpIChub3JtYWxpemUgcnMgKFN0ZXAudGFyZ2V0IHMxKSkgaW5cbiAgICAgICAgIGxldCBwMiA9IFBhdGguYXBwZW5kIChQYXRoLnN0ZXAgczIpIChub3JtYWxpemUgcnMgKFN0ZXAudGFyZ2V0IHMyKSkgaW5cbiAgICAgICAgIGlmIG5vdCAoZXEgKFBhdGgudGFyZ2V0IHAxKSAoUGF0aC50YXJnZXQgcDIpKSB0aGVuXG4gICAgICAgICAgIChcbiAgICAgICAgICAgICBQcmludGYucHJpbnRmIFwibm90IGNvbmZsdWVudDpcXG4lc1xcbiVzXFxuJSFcIiAoUGF0aC50b19zdHJpbmcgcDEpIChQYXRoLnRvX3N0cmluZyBwMik7XG4gICAgICAgICAgICAgcmFpc2UgTm90X2NvbmZsdWVudFxuICAgICAgICAgICApO1xuICAgICAgICAgcDEsIHAyXG4gICAgICApXG4gICAgICAoY3JpdGljYWwgcnMpXG5cbiAgKCoqIFJld3JpdGluZyB6aWd6YWdzLiAqKVxuICBtb2R1bGUgWmlnemFnID0gc3RydWN0XG4gICAgKCoqIEEgcmV3cml0aW5nIHppZ3phZy4gKilcbiAgICB0eXBlIHQgPVxuICAgICAgfCBTdGVwIG9mIFN0ZXAudFxuICAgICAgfCBDb21wIG9mIHQgKiB0XG4gICAgICB8IElkIG9mIHRlcm1cbiAgICAgIHwgSW52IG9mIHRcblxuICAgICgqKiBTdHJpbmcgcmVwcmVzZW50YXRpb24uICopXG4gICAgbGV0IHJlYyB0b19zdHJpbmcgPyhwYT1mYWxzZSkgP3ZhciA9IGZ1bmN0aW9uXG4gICAgICB8IFN0ZXAgcyAtPiBTdGVwLmxhYmVsID92YXIgc1xuICAgICAgfCBDb21wIChwMSxwMikgLT5cbiAgICAgICAgbGV0IHMgPSB0b19zdHJpbmcgfnBhOnRydWUgP3ZhciBwMSBeIFwiLlwiIF4gdG9fc3RyaW5nID92YXIgcDIgaW5cbiAgICAgICAgaWYgcGEgdGhlbiBcIihcIiBeIHMgXiBcIilcIiBlbHNlIHNcbiAgICAgIHwgSWQgdCAtPiBzdHJpbmdfb2ZfdGVybSA/dmFyIHRcbiAgICAgIHwgSW52IHAgLT4gdG9fc3RyaW5nIH5wYTp0cnVlID92YXIgcCBeIFwiLVwiXG5cbiAgICBsZXQgcmVjIHNvdXJjZSA9IGZ1bmN0aW9uXG4gICAgICB8IFN0ZXAgcyAtPiBTdGVwLnNvdXJjZSBzXG4gICAgICB8IENvbXAgKHAsIF8pIC0+IHNvdXJjZSBwXG4gICAgICB8IElkIHQgLT4gdFxuICAgICAgfCBJbnYgcCAtPiB0YXJnZXQgcFxuICAgIGFuZCB0YXJnZXQgPSBmdW5jdGlvblxuICAgICAgfCBTdGVwIHMgLT4gU3RlcC50YXJnZXQgc1xuICAgICAgfCBDb21wIChfLCBwKSAtPiB0YXJnZXQgcFxuICAgICAgfCBJZCB0IC0+IHRcbiAgICAgIHwgSW52IHAgLT4gc291cmNlIHBcblxuICAgICgqKiBQYXRoIHJlZHVjZWQgdG8gb25lIHN0ZXAuICopXG4gICAgbGV0IHN0ZXAgcyA9IFN0ZXAgc1xuXG4gICAgKCoqIENvbmNhdGVuYXRpb24gb2YgdHdvIHBhdGhzLiAqKVxuICAgIGxldCBjb21wIHAxIHAyID1cbiAgICAgICgqIFByaW50Zi5wcmludGYgXCJjb21wb3NlICVzIHdpdGggJXNcXG4lIVwiICh0b19zdHJpbmcgcDEpICh0b19zdHJpbmcgcDIpOyAqKVxuICAgICAgKCogUHJpbnRmLnByaW50ZiBcIiVzIHZzICVzXFxuJSFcIiAoc3RyaW5nX29mX3Rlcm0gKHRhcmdldCBwMSkpIChzdHJpbmdfb2ZfdGVybSAoc291cmNlIHAyKSk7ICopXG4gICAgICBhc3NlcnQgKGVxICh0YXJnZXQgcDEpIChzb3VyY2UgcDIpKTtcbiAgICAgIENvbXAgKHAxLCBwMilcblxuICAgIGxldCBhcHBlbmQgcDEgcDIgPSBjb21wIHAxIHAyXG5cbiAgICAoKiogQ29uY2F0ZW5hdGlvbiBvZiBhIGxpc3Qgb2YgcGF0aHMuICopXG4gICAgbGV0IHJlYyBjb25jYXQgPSBmdW5jdGlvblxuICAgICAgfCBbcF0gLT4gcFxuICAgICAgfCBwOjpsIC0+IGFwcGVuZCBwIChjb25jYXQgbClcbiAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgICAoKiogSW52ZXJzZSBvZiBhIHBhdGguICopXG4gICAgbGV0IGludiBwID0gSW52IHBcblxuICAgICgqKiBFcXVhbGl0eSBiZXR3ZWVuIHBhdGhzLiAqKVxuICAgIGxldCByZWMgZXEgcCBwJyA9XG4gICAgICBtYXRjaCBwLCBwJyB3aXRoXG4gICAgICB8IFN0ZXAgcywgU3RlcCBzJyAtPiBTdGVwLmVxIHMgcydcbiAgICAgIHwgQ29tcCAocCwgcSksIENvbXAgKHAnLCBxJykgLT4gZXEgcCBwJyAmJiBlcSBxIHEnXG4gICAgICB8IElkIHQsIElkIHQnIC0+IGVxX3Rlcm0gdCB0J1xuICAgICAgfCBJbnYgcCwgSW52IHAnIC0+IGVxIHAgcCdcbiAgICAgIHwgXyAtPiBmYWxzZVxuXG4gICAgKCoqIE51bWJlciBvZiBzdGVwcyBpbiBhIHBhdGguICopXG4gICAgbGV0IHJlYyBsZW5ndGggPSBmdW5jdGlvblxuICAgICAgfCBTdGVwIF8gLT4gMVxuICAgICAgfCBDb21wIChwLCBxKSAtPiBsZW5ndGggcCArIGxlbmd0aCBxXG4gICAgICB8IElkIF8gLT4gMFxuICAgICAgfCBJbnYgcCAtPiBsZW5ndGggcFxuXG4gICAgKCoqIENyZWF0ZSBhIHppZ3phZyBmcm9tIGEgcGF0aC4gKilcbiAgICBsZXQgcmVjIG9mX3BhdGggcCA9XG4gICAgICBtYXRjaCBwIHdpdGhcbiAgICAgIHwgUGF0aC5FbXB0eSB0IC0+IElkIHRcbiAgICAgIHwgU3RlcCAocCwgcykgLT4gY29tcCAob2ZfcGF0aCBwKSAoc3RlcCBzKVxuXG4gICAgKCoqIEFwcGx5IGEgY29udGV4dCBmdW5jdGlvbiB0byBhIHBhdGguIEluIG5lZWQgdG8gaGF2ZSB0d28gZnVuY3Rpb24gYmVjYXVzZVxuICAgICAgICBvZiB0eXBpbmcgaXNzdWVzICh2YXJpYW5jZSBhbmQgcG9seW1vcnBoaWMgdmFyaWFudHMuLi4pLCBidXQgdGhleSB3aWxsXG4gICAgICAgIGFsd2F5cyBiZSB0aGUgc2FtZSBpbiBwcmFjdGljZS4gKilcbiAgICBsZXQgcmVjIG1hcCB0bSBycyA9IGZ1bmN0aW9uXG4gICAgICB8IFN0ZXAgcyAtPiBTdGVwIChycyBzKVxuICAgICAgfCBDb21wIChwLCBxKSAtPiBDb21wIChtYXAgdG0gcnMgcCwgbWFwIHRtIHJzIHEpXG4gICAgICB8IElkIHQgLT4gSWQgKHRtIHQpXG4gICAgICB8IEludiBwIC0+IEludiAobWFwIHRtIHJzIHApXG5cbiAgICAoKiogQXBwbHkgYSBzdWJzdGl0dXRpb24uICopXG4gICAgbGV0IHJlYyBzdWJzdCBzID0gZnVuY3Rpb25cbiAgICAgIHwgU3RlcCB0IC0+IFN0ZXAgKFN0ZXAuc3Vic3QgcyB0KVxuICAgICAgfCBDb21wIChwMSwgcDIpIC0+IENvbXAgKHN1YnN0IHMgcDEsIHN1YnN0IHMgcDIpXG4gICAgICB8IElkIHQgLT4gSWQgKFN1YnN0LmFwcCBzIHQpXG4gICAgICB8IEludiBwIC0+IEludiAoc3Vic3QgcyBwKVxuXG4gICAgKCoqIE51bWJlciBvZiBvY2N1cmVuY2VzIG9mIGEgZ2l2ZW4gcnVsZSBpbiBhIHBhdGguICopXG4gICAgbGV0IHJlYyBydWxlX29jY3VyZW5jZXMgciA9IGZ1bmN0aW9uXG4gICAgICB8IFN0ZXAgcyAtPiBpZiBTdGVwLmhhc19ydWxlIHIgcyB0aGVuIDEgZWxzZSAwXG4gICAgICB8IENvbXAgKHAsIHEpIC0+IHJ1bGVfb2NjdXJlbmNlcyByIHAgKyBydWxlX29jY3VyZW5jZXMgciBxXG4gICAgICB8IElkIF8gLT4gMFxuICAgICAgfCBJbnYgcCAtPiBydWxlX29jY3VyZW5jZXMgciBwXG5cbiAgICAoKiogTnVtYmVyIG9mIG9jY3VyZW5jZXMgb2YgYSBnaXZlbiBydWxlIGluIGEgcGF0aCwgY291bnRlZCBuZWdhdGl2ZWx5IHdoZW4gaW52ZXJ0ZWQuICopXG4gICAgbGV0IHJlYyBydWxlX2FsZ2VicmFpY19vY2N1cmVuY2VzIHIgPSBmdW5jdGlvblxuICAgICAgfCBTdGVwIHMgLT4gaWYgU3RlcC5oYXNfcnVsZSByIHMgdGhlbiAxIGVsc2UgMFxuICAgICAgfCBDb21wIChwLCBxKSAtPiBydWxlX2FsZ2VicmFpY19vY2N1cmVuY2VzIHIgcCArIHJ1bGVfYWxnZWJyYWljX29jY3VyZW5jZXMgciBxXG4gICAgICB8IElkIF8gLT4gMFxuICAgICAgfCBJbnYgcCAtPiAtIHJ1bGVfYWxnZWJyYWljX29jY3VyZW5jZXMgciBwXG5cbiAgICBsZXQgaXNfaWQgPSBmdW5jdGlvblxuICAgICAgfCBJZCBfIC0+IHRydWVcbiAgICAgIHwgXyAtPiBmYWxzZVxuXG4gICAgbGV0IGlzX2ludiA9IGZ1bmN0aW9uXG4gICAgICB8IEludiBfIC0+IHRydWVcbiAgICAgIHwgXyAtPiBmYWxzZVxuXG4gICAgKCoqIFdoZXRoZXIgYSBwYXRoIGNvbnRhaW5zIGEgcnVsZS4gKilcbiAgICBsZXQgaGFzX3J1bGUgciBwID0gcnVsZV9vY2N1cmVuY2VzIHIgcCA+IDBcblxuICAgICgqKiBQdXQgcGF0aCBpbiBjYW5vbmljYWwgZm9ybS4gKilcbiAgICBsZXQgcmVjIGNhbm9uaXplIHAgPVxuICAgICAgKCogUHJpbnRmLnByaW50ZiBcImNhbm9uaXplOiAlc1xcbiUhXCIgKHRvX3N0cmluZyBwKTsgKilcbiAgICAgIG1hdGNoIHAgd2l0aFxuICAgICAgfCBDb21wIChJZCBfLCBwKSAtPiBjYW5vbml6ZSBwXG4gICAgICB8IENvbXAgKHAsIElkIF8pIC0+IGNhbm9uaXplIHBcbiAgICAgIHwgQ29tcCAoQ29tcCAocCwgcSksIHIpIC0+IGNhbm9uaXplIChDb21wIChwLCBDb21wIChxLCByKSkpXG4gICAgICB8IENvbXAgKFN0ZXAgcywgcCkgLT5cbiAgICAgICAgKFxuICAgICAgICAgIG1hdGNoIGNhbm9uaXplIHAgd2l0aFxuICAgICAgICAgIHwgSW52IChTdGVwIHMnKSB3aGVuIFN0ZXAuZXEgcyBzJyAtPiBJZCAoU3RlcC5zb3VyY2UgcylcbiAgICAgICAgICB8IENvbXAgKEludiAoU3RlcCBzJyksIHApIHdoZW4gU3RlcC5lcSBzIHMnIC0+IHBcbiAgICAgICAgICB8IElkIF8gLT4gU3RlcCBzXG4gICAgICAgICAgfCBwIC0+IENvbXAgKFN0ZXAgcywgcClcbiAgICAgICAgKVxuICAgICAgfCBDb21wIChJbnYgKFN0ZXAgcyksIHApIC0+XG4gICAgICAgIChcbiAgICAgICAgICBtYXRjaCBjYW5vbml6ZSBwIHdpdGhcbiAgICAgICAgICB8IFN0ZXAgcycgd2hlbiBTdGVwLmVxIHMgcycgLT4gSWQgKFN0ZXAudGFyZ2V0IHMnKVxuICAgICAgICAgIHwgQ29tcCAoU3RlcCBzJywgcCkgd2hlbiBTdGVwLmVxIHMgcycgLT4gcFxuICAgICAgICAgIHwgSWQgXyAtPiBJbnYgKFN0ZXAgcylcbiAgICAgICAgICB8IHAgLT4gQ29tcCAoSW52IChTdGVwIHMpLCBwKVxuICAgICAgICApXG4gICAgICB8IENvbXAgKHAsIHEpIC0+IGNhbm9uaXplIChDb21wIChjYW5vbml6ZSBwLCBxKSlcbiAgICAgIHwgSW52IChJbnYgcCkgLT4gY2Fub25pemUgcFxuICAgICAgfCBJbnYgKENvbXAgKHAsIHEpKSAtPiBjYW5vbml6ZSAoQ29tcCAoSW52IHEsIEludiBwKSlcbiAgICAgIHwgSW52IChJZCB0KSAtPiBJZCB0XG4gICAgICB8IEludiAoU3RlcCBzKSAtPiBJbnYgKFN0ZXAgcylcbiAgICAgIHwgSWQgdCAtPiBJZCB0XG4gICAgICB8IFN0ZXAgcyAtPiBTdGVwIHNcblxuICAgICgqKiBFeHByZXNzIGEgcnVsZSBhcyBhIHppZ3phZyBpbiBhIGNlbGwuICopXG4gICAgbGV0IHZhbHVlIHIgcCA9XG4gICAgICBsZXQgcCA9IGNhbm9uaXplIHAgaW5cbiAgICAgICgqIFByaW50Zi5wcmludGYgXCJ2YWx1ZSBvZiAlcyBpbiAlc1xcbiUhXCIgKFJ1bGUubmFtZSByKSAodG9fc3RyaW5nIHApOyAqKVxuICAgICAgYXNzZXJ0IChydWxlX29jY3VyZW5jZXMgciBwID0gMSk7XG4gICAgICBsZXQgcCA9IGlmIHJ1bGVfYWxnZWJyYWljX29jY3VyZW5jZXMgciBwID0gLSAxIHRoZW4gY2Fub25pemUgKGludiBwKSBlbHNlIHAgaW5cbiAgICAgIGxldCByZWMgYXV4IHByZWZpeCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgQ29tcCAoU3RlcCAoUkFwcCAocicsIHMpKSwgcCkgd2hlbiBSdWxlLmVxIHIgcictPlxuICAgICAgICAgIGFzc2VydCAobm90IChoYXNfcnVsZSByIHApKTtcbiAgICAgICAgICBhc3NlcnQgKFN1YnN0LmlzX3JlbmFtaW5nIHMpO1xuICAgICAgICAgIGxldCBwcmVmaXggPSBjb25jYXQgKExpc3QucmV2IHByZWZpeCkgaW5cbiAgICAgICAgICBzdWJzdCAoU3Vic3QuaW52IHMpIChjb25jYXQgW2ludiBwcmVmaXg7IGludiBwXSlcbiAgICAgICAgfCBDb21wIChTdGVwIF8gYXMgcywgcCkgfCBDb21wIChJbnYgKFN0ZXAgXykgYXMgcywgcCkgLT4gYXV4IChzOjpwcmVmaXgpIHBcbiAgICAgICAgfCBTdGVwIF8gfCBJbnYgKFN0ZXAgXykgYXMgcyAtPiBhdXggcHJlZml4IChDb21wIChzLCBJZCAodGFyZ2V0IHMpKSlcbiAgICAgICAgfCBJZCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICBpblxuICAgICAgbGV0IHYgPSBjYW5vbml6ZSAoYXV4IFtJZCAoc291cmNlIHApXSBwKSBpblxuICAgICAgYXNzZXJ0IChlcV90ZXJtIChzb3VyY2UgdikgKFJ1bGUuc291cmNlIHIpKTtcbiAgICAgIGFzc2VydCAoZXFfdGVybSAodGFyZ2V0IHYpIChSdWxlLnRhcmdldCByKSk7XG4gICAgICB2XG5cbiAgICAoKiogUmVwbGFjZSBhIHJ1bGUgYnkgYSBwYXRoIGluIGEgcGF0aC4gKilcbiAgICBsZXQgcmVjIHJlcGxhY2VfcnVsZSByIChwcjp0KSAocDp0KSA9XG4gICAgICAoKiBQcmludGYucHJpbnRmIFwicmVwbGFjZV9ydWxlOiAlc1xcbiUhXCIgKHRvX3N0cmluZyBwKTsgKilcbiAgICAgIGxldCByZWMgcmVwbGFjZV9zdGVwIHRtX2N0eCByc19jdHggPSBmdW5jdGlvblxuICAgICAgICB8IFN0ZXAuVEFwcCAoZiwgYTEsIHMsIGEyKSAtPlxuICAgICAgICAgIGxldCB0bV9jdHggdCA9IHRtX2N0eCAoYXBwIGYgKGExQFt0XUBhMikpIGluXG4gICAgICAgICAgbGV0IHJzX2N0eCBzID0gcnNfY3R4IChTdGVwLnRhcHAgZiBhMSBzIGEyKSBpblxuICAgICAgICAgIHJlcGxhY2Vfc3RlcCB0bV9jdHggcnNfY3R4IHNcbiAgICAgICAgfCBSQXBwIChyJywgcykgd2hlbiBSdWxlLmVxIHIgcicgLT4gbWFwIHRtX2N0eCByc19jdHggKHN1YnN0IHMgcHIpXG4gICAgICAgIHwgUkFwcCAociwgcykgLT4gc3RlcCAocnNfY3R4IChTdGVwLnJhcHAgciBzKSlcbiAgICAgIGluXG4gICAgICBsZXQgcmVwbGFjZV9zdGVwID0gcmVwbGFjZV9zdGVwIGlkIGlkIGluXG4gICAgICBtYXRjaCBwIHdpdGhcbiAgICAgIHwgU3RlcCBzIC0+IHJlcGxhY2Vfc3RlcCBzXG4gICAgICB8IENvbXAgKHAsIHEpIC0+IGNvbXAgKHJlcGxhY2VfcnVsZSByIHByIHApIChyZXBsYWNlX3J1bGUgciBwciBxKVxuICAgICAgfCBJZCB0IC0+IElkIHRcbiAgICAgIHwgSW52IHAgLT4gSW52IChyZXBsYWNlX3J1bGUgciBwciBwKVxuXG4gICAgKCoqIG50aCBzdGVwIGluIGEgcGF0aCBzdXBwb3NlZCB0byBiZSBpbiBjYW5vbmljYWwgZm9ybS4gKilcbiAgICBsZXQgcmVjIG50aF9zdGVwIG4gPSBmdW5jdGlvblxuICAgICAgfCBTdGVwIHMgd2hlbiBuID0gMCAtPiB0cnVlLCBzXG4gICAgICB8IEludiAoU3RlcCBzKSB3aGVuIG4gPSAwIC0+IGZhbHNlLCBzXG4gICAgICB8IENvbXAgKFN0ZXAgcywgcCkgLT4gaWYgbiA9IDAgdGhlbiB0cnVlLCBzIGVsc2UgbnRoX3N0ZXAgKG4tMSkgcFxuICAgICAgfCBDb21wIChJbnYgKFN0ZXAgcyksIHApIC0+IGlmIG4gPSAwIHRoZW4gZmFsc2UsIHMgZWxzZSBudGhfc3RlcCAobi0xKSBwXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgICAoKiogbnRoIHRlcm0gaW4gYSBwYXRoIHN1cHBvc2VkIHRvIGJlIGluIGNhbm9uaWNhbCBmb3JtLiAqKVxuICAgIGxldCByZWMgbnRoX3Rlcm0gbiA9IGZ1bmN0aW9uXG4gICAgICB8IFN0ZXAgXyB8IEludiAoU3RlcCBfKSBhcyBwIC0+XG4gICAgICAgIGlmIG4gPSAwIHRoZW4gc291cmNlIHBcbiAgICAgICAgZWxzZSBpZiBuID0gMSB0aGVuIHRhcmdldCBwXG4gICAgICAgIGVsc2UgYXNzZXJ0IGZhbHNlXG4gICAgICB8IENvbXAgKFN0ZXAgXyBhcyBwLCBxKSB8IENvbXAgKEludiAoU3RlcCBfKSBhcyBwLCBxKSAtPlxuICAgICAgICBpZiBuID0gMCB0aGVuIHNvdXJjZSBwIGVsc2UgbnRoX3Rlcm0gKG4tMSkgcVxuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICAgKCoqIExpc3Qub2Zfc3RlcHMgaW4gYSBwYXRoLiAqKVxuICAgIGxldCByZWMgdG9fbGlzdCA9IGZ1bmN0aW9uXG4gICAgICB8IFN0ZXAgcyAtPiBbU3RlcCBzXVxuICAgICAgfCBDb21wIChwLCBxKSAtPiAodG9fbGlzdCBwKUAodG9fbGlzdCBxKVxuICAgICAgfCBJZCBfIC0+IFtdXG4gICAgICB8IEludiBwIC0+IExpc3QubWFwIChmdW4gcCAtPiBJbnYgcCkgKExpc3QucmV2ICh0b19saXN0IHApKVxuXG4gICAgbGV0IHBhcnNlIHJzIHMgPVxuICAgICAgbGV0IHVuaWQgPSBmdW5jdGlvblxuICAgICAgICB8IElkIHQgLT4gdFxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICBpblxuICAgICAgbGV0IHJlYyBhdXggPSBmdW5jdGlvblxuICAgICAgICB8IGBBcHAgKGYsIGEpIC0+XG4gICAgICAgICAgKFxuICAgICAgICAgICAgbGV0IGEgPSBMaXN0Lm1hcCBhdXggYSBpblxuICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgICgqIFByaW50Zi5wcmludGYgXCJvcDogJXNcXG4lIVwiIGY7ICopXG4gICAgICAgICAgICAgIGxldCBmID0gTGlzdC5maW5kIChmdW4gbyAtPiBPcC5uYW1lIG8gPSBmKSAob3BlcmF0aW9ucyBycykgaW5cbiAgICAgICAgICAgICAgKCogTGlzdC5pdGVyIChmdW4gcCAtPiBQcmludGYucHJpbnRmIFwiJXNcXG4lIVwiICh0b19zdHJpbmcgcCkpIGE7ICopXG4gICAgICAgICAgICAgIGlmIExpc3QuZm9yX2FsbCBpc19pZCBhIHRoZW5cbiAgICAgICAgICAgICAgICBsZXQgYSA9IExpc3QubWFwIHVuaWQgYSBpblxuICAgICAgICAgICAgICAgIGxldCB0ID0gYXBwIGYgYSBpblxuICAgICAgICAgICAgICAgIElkIHRcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxldCBuID0gdHJ5IExpc3QuaW5kZXggKGZ1biBwIC0+IG5vdCAoaXNfaWQgcCkpIGEgd2l0aCBOb3RfZm91bmQgLT4gYXNzZXJ0IGZhbHNlIGluXG4gICAgICAgICAgICAgICAgbGV0IHQgPSBMaXN0Lm50aCBhIG4gaW5cbiAgICAgICAgICAgICAgICBsZXQgYTEsIGEyID0gbGlzdF9yZW1vdmVfbnRoIG4gYSBpblxuICAgICAgICAgICAgICAgIGxldCBhMSA9IExpc3QubWFwIHVuaWQgYTEgaW5cbiAgICAgICAgICAgICAgICBsZXQgYTIgPSBMaXN0Lm1hcCB1bmlkIGEyIGluXG4gICAgICAgICAgICAgICAgbGV0IHRtX2N0eCB0ID0gYXBwIGYgKGExQFt0XUBhMikgaW5cbiAgICAgICAgICAgICAgICBsZXQgcnNfY3R4IHQgPSBTdGVwLnRhcHAgZiBhMSB0IGEyIGluXG4gICAgICAgICAgICAgICAgbWFwIHRtX2N0eCByc19jdHggdFxuICAgICAgICAgICAgd2l0aFxuICAgICAgICAgICAgfCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgICAgbGV0IHIgPSBmaW5kIHJzIGYgaW5cbiAgICAgICAgICAgICAgbGV0IGEgPSBMaXN0Lm1hcCB1bmlkIGEgaW5cbiAgICAgICAgICAgICAgbGV0IHMgPSBMaXN0Lm1hcDIgcGFpciAoUnVsZS52YXJzIHIpIGEgaW5cbiAgICAgICAgICAgICAgU3RlcCAoU3RlcC5yYXBwIHIgcylcbiAgICAgICAgICApXG4gICAgICAgIHwgYEludiBwIC0+IGludiAoYXV4IHApXG4gICAgICAgIHwgYFNlcSBsIC0+IGNvbmNhdCAoTGlzdC5tYXAgYXV4IGwpXG4gICAgICAgIHwgYFZhciB4IC0+XG4gICAgICAgICAgbGV0IHggPSBwYXJzZV92YXIgeCBpblxuICAgICAgICAgIElkIChWYXIgeClcbiAgICAgIGluXG4gICAgICBhdXggKHBhcnNlciBzKVxuICBlbmRcblxuICAoKiogTG9vcHMuICopXG4gIG1vZHVsZSBMb29wID0gc3RydWN0XG4gICAgKCoqIEEgKHBvaW50ZWQpIGxvb3AuICopXG4gICAgdHlwZSB0ID0gWmlnemFnLnRcblxuICAgIGxldCBtYWtlIChwOlppZ3phZy50KSA6IHQgPVxuICAgICAgYXNzZXJ0IChlcV90ZXJtIChaaWd6YWcuc291cmNlIHApIChaaWd6YWcudGFyZ2V0IHApKTtcbiAgICAgIHBcblxuICAgIGxldCB0b19zdHJpbmcgPSBaaWd6YWcudG9fc3RyaW5nXG5cbiAgICBsZXQgY29tcCA9IFppZ3phZy5jb21wXG5cbiAgICBsZXQgaW52ID0gWmlnemFnLmludlxuXG4gICAgbGV0IG9mX2NlbGwgcDEgcDIgPVxuICAgICAgYXNzZXJ0IChlcV90ZXJtIChaaWd6YWcuc291cmNlIHAxKSAoWmlnemFnLnNvdXJjZSBwMikpO1xuICAgICAgYXNzZXJ0IChlcV90ZXJtIChaaWd6YWcudGFyZ2V0IHAxKSAoWmlnemFnLnRhcmdldCBwMikpO1xuICAgICAgY29tcCBwMSAoaW52IHAyKVxuXG4gICAgbGV0IGNhbm9uaXplID0gWmlnemFnLmNhbm9uaXplXG5cbiAgICBsZXQgdmFsdWUgPSBaaWd6YWcudmFsdWVcblxuICAgIGxldCByZXBsYWNlX3J1bGUgPSBaaWd6YWcucmVwbGFjZV9ydWxlXG5cbiAgICBsZXQgbGVuZ3RoID0gWmlnemFnLmxlbmd0aFxuXG4gICAgbGV0IHJvdGF0ZSBrIHAgPVxuICAgICAgbGV0IG4gPSBsZW5ndGggcCBpblxuICAgICAgbGV0IGsgPSBJbnQubW9kdWxvIGsgbiBpblxuICAgICAgbGV0IGwgPSBaaWd6YWcudG9fbGlzdCBwIGluXG4gICAgICBsZXQgbDEgPSBMaXN0LnN1YiBsIDAgayBpblxuICAgICAgbGV0IGwyID0gTGlzdC5zdWIgbCBrIChuLWspIGluXG4gICAgICBsZXQgbDEgPSBaaWd6YWcuY29uY2F0IGwxIGluXG4gICAgICBsZXQgbDIgPSBaaWd6YWcuY29uY2F0IGwyIGluXG4gICAgICBaaWd6YWcuY29tcCBsMiBsMVxuICBlbmRcblxuICAoKiogQ29oZXJlbmNlIGNlbGxzLiAqKVxuICBtb2R1bGUgQ29oZXJlbmNlID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHtcbiAgICAgICAgbmFtZSA6IHN0cmluZztcbiAgICAgICAgbG9vcCA6IExvb3AudDtcbiAgICAgIH1cblxuICAgIGxldCBuYW1lIGMgPSBjLm5hbWVcblxuICAgIGxldCBsb29wIGMgPSBjLmxvb3BcblxuICAgIGxldCBtYWtlIG5hbWUgbG9vcCA9XG4gICAgICB7IG5hbWU7IGxvb3AgfVxuXG4gICAgbGV0IHRvX3N0cmluZyB+dmFyIGMgPVxuICAgICAgbGV0IHAgPSBMb29wLmNhbm9uaXplIChsb29wIGMpIGluXG4gICAgICBQcmludGYuc3ByaW50ZiBcIiVzOiAlc1xcblwiIChuYW1lIGMpIChMb29wLnRvX3N0cmluZyB+dmFyIHApXG5cbiAgICBsZXQgcm90YXRlIG4gYyA9XG4gICAgICB7IGMgd2l0aCBsb29wID0gTG9vcC5yb3RhdGUgbiAobG9vcCBjKSB9XG5cbiAgICBsZXQgdmFsdWUgciBjID1cbiAgICAgIExvb3AudmFsdWUgciAobG9vcCBjKVxuXG4gICAgbGV0IHJlcGxhY2VfcnVsZSByIHYgYyA9XG4gICAgICB7IGMgd2l0aCBsb29wID0gTG9vcC5yZXBsYWNlX3J1bGUgciB2IChsb29wIGMpIH1cblxuICAgIG1vZHVsZSBQYXRoID0gc3RydWN0XG4gICAgZW5kXG4gIGVuZFxuXG4gICgqKiBDb2hlcmVudCBwcmVzZW50YXRpb25zLiAqKVxuICBtb2R1bGUgQ29oZXJlbnQgPSBzdHJ1Y3RcbiAgICAoKiogQSBjb2hlcmVudCBwcmVzZW50YXRpb24uICopXG4gICAgdHlwZSB0ID1cbiAgICAgIHtcbiAgICAgICAgcnMgOiBycztcbiAgICAgICAgY29oZXJlbmNlIDogQ29oZXJlbmNlLnQgbGlzdDtcbiAgICAgIH1cblxuICAgIHR5cGUgY3JzID0gdFxuXG4gICAgKCoqIFVuZGVybHlpbmcgcmV3cml0aW5nIHN5c3RlbS4gKilcbiAgICBsZXQgcnMgY3JzID0gY3JzLnJzXG5cbiAgICBsZXQgcnVsZXMgY3JzID0gcnVsZXMgKHJzIGNycylcblxuICAgIGxldCBjb2hlcmVuY2UgY3JzID0gY3JzLmNvaGVyZW5jZVxuXG4gICAgbGV0IHNldF9ydWxlcyBjcnMgcnVsZXMgPSB7IGNycyB3aXRoIHJzID0geyBjcnMucnMgd2l0aCBydWxlcyB9IH1cblxuICAgIGxldCB0b19zdHJpbmcgPyh2YXI9VmFyLm5hbWVyKSBjcnMgPVxuICAgICAgbGV0IGNvaGVyZW5jZSA9XG4gICAgICAgIExpc3QubWFwXG4gICAgICAgICAgKGZ1biBjIC0+XG4gICAgICAgICAgICAgQ29oZXJlbmNlLnRvX3N0cmluZyB+dmFyOih2YXIgKCkpIGNcbiAgICAgICAgICApIGNycy5jb2hlcmVuY2VcbiAgICAgIGluXG4gICAgICBsZXQgY29oZXJlbmNlID0gU3RyaW5nLmNvbmNhdCBcIlxcblwiIGNvaGVyZW5jZSBpblxuICAgICAgY29oZXJlbmNlXG5cbiAgICBsZXQgdG9fdGV4ID8odmFyPVZhci5uYW1lcl9uYXR1cmFsKSBjcnMgPVxuICAgICAgbGV0IGFucyA9IHJlZiBcIlwiIGluXG4gICAgICBsZXQgcHJpbnQgcyA9IFByaW50Zi5rc3ByaW50ZiAoZnVuIHMgLT4gYW5zIDo9ICFhbnMgXiBzKSBzOyBpblxuICAgICAgcHJpbnQgXCJcXFxcZG9jdW1lbnRjbGFzc1thNHBhcGVyLDlwdF17ZXh0YXJ0aWNsZX1cXG5cXFxuICAgICAgICAgICAgIFxcXFx1c2VwYWNrYWdlW3V0Zjh4XXtpbnB1dGVuY31cXG5cXFxuICAgICAgICAgICAgIFxcXFx1c2VwYWNrYWdle2Ftc21hdGh9XFxuXFxcbiAgICAgICAgICAgICBcXFxcdXNlcGFja2FnZXt0aWt6LWNkfVxcblxcXG4gICAgICAgICAgICAgXFxcXHVzZXBhY2thZ2VbbWFyZ2luPTFjbSxpbmNsdWRlZm9vdF17Z2VvbWV0cnl9XFxuXFxcbiAgICAgICAgICAgICBcXFxcdGl0bGV7Q29oZXJlbnQgcHJlc2VudGF0aW9ufVxcblxcXG4gICAgICAgICAgICAgXFxcXGF1dGhvcntvY2FtbC1hbGd9XFxuXFxuXFxcbiAgICAgICAgICAgICBcXFxcYmVnaW57ZG9jdW1lbnR9XFxuXFxcbiAgICAgICAgICAgICBcXFxcbWFrZXRpdGxlXFxuXFxuXCI7XG4gICAgICBsZXQgcnVsZXMgPVxuICAgICAgICBMaXN0Lm1hcFxuICAgICAgICAgIChmdW4gciAtPlxuICAgICAgICAgICAgIGxldCB2YXIgPSB2YXIgKCkgaW5cbiAgICAgICAgICAgICBsZXQgcyA9IHN0cmluZ19vZl90ZXJtIH52YXIgKFJ1bGUuc291cmNlIHIpIGluXG4gICAgICAgICAgICAgbGV0IHQgPSBzdHJpbmdfb2ZfdGVybSB+dmFyIChSdWxlLnRhcmdldCByKSBpblxuICAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwiJXMgJjogJXMgXFxcXHRvICVzXFxcXFxcXFxcIiAoUnVsZS5uYW1lIHIpIHMgdFxuICAgICAgICAgICkgKHJ1bGVzIGNycylcbiAgICAgIGluXG4gICAgICBsZXQgcnVsZXMgPSBTdHJpbmcuY29uY2F0IFwiXFxuXCIgcnVsZXMgaW5cbiAgICAgIHByaW50IFwiXFxcXHNlY3Rpb257UnVsZXN9XFxuXFxcbiAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgIFxcXFxiZWdpbnthbGlnbip9XFxuXFxcbiAgICAgICAgICAgICAlc1xcblxcXG4gICAgICAgICAgICAgXFxcXGVuZHthbGlnbip9XFxuXFxcbiAgICAgICAgICAgICBcXG5cIiBydWxlcztcbiAgICAgIHByaW50IFwiXFxcXHNlY3Rpb257Q29oZXJlbmNlfVxcblxcblwiO1xuICAgICAgTGlzdC5pdGVyXG4gICAgICAgIChmdW4gYyAtPlxuICAgICAgICAgICBsZXQgcCA9IExvb3AuY2Fub25pemUgKENvaGVyZW5jZS5sb29wIGMpIGluXG4gICAgICAgICAgIFByaW50Zi5wcmludGYgXCJwcmludCAlczogJXNcXG4lIVwiIChDb2hlcmVuY2UubmFtZSBjKSAoTG9vcC50b19zdHJpbmcgcCk7XG4gICAgICAgICAgIGxldCBwMSwgcDIgPVxuICAgICAgICAgICAgIGxldCBsID0gWmlnemFnLnRvX2xpc3QgcCBpblxuICAgICAgICAgICAgIGlmIGwgPD4gW10gdGhlbiBpZ25vcmUgKFppZ3phZy5jb25jYXQgbCk7ICgqIHRlc3QgKilcbiAgICAgICAgICAgICBsZXQgbiA9IExpc3QubGVuZ3RoIGwgaW5cbiAgICAgICAgICAgICBpZiBuID0gMCB0aGVuIHAsIHAgZWxzZVxuICAgICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgICAgICgqIFRyeSB0byBzcGxpdCBmb3J3YXJkIC8gYmFja3dhcmQuICopXG4gICAgICAgICAgICAgICAgIGxldCBrID0gTGlzdC5pbmRleCBaaWd6YWcuaXNfaW52IGwgaW5cbiAgICAgICAgICAgICAgICAgaWYgayA9IDAgdGhlbiByYWlzZSBFeGl0O1xuICAgICAgICAgICAgICAgICBsZXQgbDEgPSBMaXN0LnN1YiBsIDAgayBpblxuICAgICAgICAgICAgICAgICBsZXQgbDIgPSBMaXN0LnN1YiBsIGsgKG4taykgaW5cbiAgICAgICAgICAgICAgICAgaWYgbm90IChMaXN0LmZvcl9hbGwgWmlnemFnLmlzX2ludiBsMikgdGhlbiByYWlzZSBFeGl0O1xuICAgICAgICAgICAgICAgICBsZXQgcDEgPSBaaWd6YWcuY29uY2F0IGwxIGluXG4gICAgICAgICAgICAgICAgIGxldCBwMiA9IFppZ3phZy5jYW5vbml6ZSAoWmlnemFnLmludiAoWmlnemFnLmNvbmNhdCBsMikpIGluXG4gICAgICAgICAgICAgICAgIGxldCBwMSwgcDIgPVxuICAgICAgICAgICAgICAgICAgIGlmIExpc3QubGVuZ3RoIGwxID4gTGlzdC5sZW5ndGggbDIgdGhlblxuICAgICAgICAgICAgICAgICAgICAgcDIsIHAxXG4gICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgcDEsIHAyXG4gICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgIFppZ3phZy5jYW5vbml6ZSBwMSwgWmlnemFnLmNhbm9uaXplIHAyXG4gICAgICAgICAgICAgICB3aXRoXG4gICAgICAgICAgICAgICB8IEV4aXQgfCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgICAgICAgKCogQnkgZGVmYXVsdCwgc3BsaXQgaW4gay9rIG9yIGsvaysxLiAqKVxuICAgICAgICAgICAgICAgICBsZXQgbDEgPSBMaXN0LnN1YiBsIDAgKG4vMikgaW5cbiAgICAgICAgICAgICAgICAgbGV0IGwyID0gTGlzdC5zdWIgbCAobi8yKSAobi1uLzIpIGluXG4gICAgICAgICAgICAgICAgIFppZ3phZy5jb25jYXQgbDEsIFppZ3phZy5jYW5vbml6ZSAoWmlnemFnLmludiAoWmlnemFnLmNvbmNhdCBsMikpXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIFByaW50Zi5wcmludGYgXCJzcGxpdDogJXMgLyAlc1xcbiUhXCIgKFppZ3phZy50b19zdHJpbmcgcDEpIChaaWd6YWcudG9fc3RyaW5nIHAyKTtcbiAgICAgICAgICAgbGV0IHZhciA9IHZhciAoKSBpblxuICAgICAgICAgICBsZXQgc3QgbiBwID1cbiAgICAgICAgICAgICBsZXQgZCwgcyA9IFppZ3phZy5udGhfc3RlcCBuIHAgaW5cbiAgICAgICAgICAgICBsZXQgZCA9IGlmIGQgdGhlbiBcIlwiIGVsc2UgXCI8LSxcIiBpblxuICAgICAgICAgICAgIGxldCBzID0gU3RlcC5sYWJlbCB+dmFyIHMgaW5cbiAgICAgICAgICAgICBkIF4gXCJcXFwie1wiIF4gcyBeIFwifVxcXCJcIlxuICAgICAgICAgICBpblxuICAgICAgICAgICBsZXQgdG0gbiBwID0gc3RyaW5nX29mX3Rlcm0gfnZhciAoWmlnemFnLm50aF90ZXJtIG4gcCkgaW5cbiAgICAgICAgICAgbGV0IGNkICgpID1cbiAgICAgICAgICAgICBtYXRjaCBaaWd6YWcubGVuZ3RoIHAxLCBaaWd6YWcubGVuZ3RoIHAyIHdpdGhcbiAgICAgICAgICAgICB8IDEsIDEgLT5cbiAgICAgICAgICAgICAgIHByaW50IFwiJXNcXFxcYXJbZCxiZW5kIHJpZ2h0LCVzJ11cXFxcYXJbZCxiZW5kIGxlZnQsJXNdXFxcXFxcXFxcXG4lc1wiXG4gICAgICAgICAgICAgICAgICh0bSAwIHAxKSAoc3QgMCBwMSkgKHN0IDAgcDIpICh0bSAxIHAxKVxuICAgICAgICAgICAgIHwgMSwgMiAtPlxuICAgICAgICAgICAgICAgcHJpbnQgXCIlc1xcXFxhcltkciwlcyddXFxcXGFyW3IsJXNdJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG4mJXNcIlxuICAgICAgICAgICAgICAgICAodG0gMCBwMSkgKHN0IDAgcDEpIChzdCAwIHAyKSAodG0gMSBwMikgKHN0IDEgcDIpICh0bSAyIHAyKVxuICAgICAgICAgICAgIHwgMSwgMyAtPlxuICAgICAgICAgICAgICAgcHJpbnQgXCIlc1xcXFxhcltkcnIsJXMnXVxcXFxhcltyLCVzXSYlc1xcXFxhcltyLCVzXSYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuJiYlc1wiXG4gICAgICAgICAgICAgICAgICh0bSAwIHAxKSAoc3QgMCBwMSkgKHN0IDAgcDIpICh0bSAxIHAyKSAoc3QgMSBwMikgKHRtIDIgcDIpIChzdCAyIHAyKSAodG0gMyBwMilcbiAgICAgICAgICAgICB8IDEsIDQgLT5cbiAgICAgICAgICAgICAgIHByaW50IFwiJXNcXFxcYXJbZGRyciwlcyddXFxcXGFyW3IsJXNdJiVzXFxcXGFyW3IsJXNdJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG4mJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG4mJiVzXCJcbiAgICAgICAgICAgICAgICAgKHRtIDAgcDEpIChzdCAwIHAxKSAoc3QgMCBwMikgKHRtIDEgcDIpIChzdCAxIHAyKSAodG0gMiBwMikgKHN0IDIgcDIpICh0bSAzIHAyKSAoc3QgMyBwMikgKHRtIDQgcDIpXG4gICAgICAgICAgICAgfCAxLCA1IC0+XG4gICAgICAgICAgICAgICBwcmludCBcIiVzXFxcXGFyW2RkZHJyLCVzJ11cXFxcYXJbciwlc10mJXNcXFxcYXJbciwlc10mJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcbiYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcbiYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcbiYmJXNcIlxuICAgICAgICAgICAgICAgICAodG0gMCBwMSkgKHN0IDAgcDEpIChzdCAwIHAyKSAodG0gMSBwMikgKHN0IDEgcDIpICh0bSAyIHAyKSAoc3QgMiBwMikgKHRtIDMgcDIpIChzdCAzIHAyKSAodG0gNCBwMikgKHN0IDQgcDIpICh0bSA1IHAyKVxuICAgICAgICAgICAgIHwgMSwgNiAtPlxuICAgICAgICAgICAgICAgcHJpbnQgXCIlc1xcXFxhcltkZGRkcnIsJXMnXVxcXFxhcltyLCVzXSYlc1xcXFxhcltyLCVzXSYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuJiYlc1wiXG4gICAgICAgICAgICAgICAgICh0bSAwIHAxKSAoc3QgMCBwMSkgKHN0IDAgcDIpICh0bSAxIHAyKSAoc3QgMSBwMikgKHRtIDIgcDIpIChzdCAyIHAyKSAodG0gMyBwMikgKHN0IDMgcDIpICh0bSA0IHAyKSAoc3QgNCBwMikgKHRtIDUgcDIpIChzdCA1IHAyKSAodG0gNiBwMilcbiAgICAgICAgICAgICB8IDIsIDIgLT5cbiAgICAgICAgICAgICAgIHByaW50IFwiJXNcXFxcYXJbZCwlcyddXFxcXGFyW3IsJXNdJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG4lc1xcXFxhcltyLCVzJ10mJXNcIlxuICAgICAgICAgICAgICAgICAodG0gMCBwMSkgKHN0IDAgcDEpIChzdCAwIHAyKSAodG0gMSBwMikgKHN0IDEgcDIpICh0bSAxIHAxKSAoc3QgMSBwMSkgKHRtIDIgcDEpXG4gICAgICAgICAgICAgfCAyLCAzIC0+XG4gICAgICAgICAgICAgICBwcmludCBcIiVzXFxcXGFyW2QsJXMnXVxcXFxhcltyLCVzXSYlc1xcXFxhcltyLCVzXSYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuJXNcXFxcYXJbcnIsJXMnXSYmJXNcIlxuICAgICAgICAgICAgICAgICAodG0gMCBwMSkgKHN0IDAgcDEpIChzdCAwIHAyKSAodG0gMSBwMikgKHN0IDEgcDIpICh0bSAyIHAyKSAoc3QgMiBwMikgKHRtIDEgcDEpIChzdCAxIHAxKSAodG0gMiBwMSlcbiAgICAgICAgICAgICB8IDIsIDQgLT5cbiAgICAgICAgICAgICAgIHByaW50IFwiJXNcXFxcYXJbZCwlcyddXFxcXGFyW3IsJXNdJiVzXFxcXGFyW3IsJXNdJiVzXFxcXGFyW3IsJXNdJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG4lc1xcXFxhcltycnIsJXMnXSYmJiVzXCJcbiAgICAgICAgICAgICAgICAgKHRtIDAgcDEpIChzdCAwIHAxKSAoc3QgMCBwMikgKHRtIDEgcDIpIChzdCAxIHAyKSAodG0gMiBwMikgKHN0IDIgcDIpICh0bSAzIHAyKSAoc3QgMyBwMikgKHRtIDEgcDEpIChzdCAxIHAxKSAodG0gMiBwMSlcbiAgICAgICAgICAgICAoKlxuICAgICAgICAgICAgIHwgMywgMyAtPlxuICAgICAgICAgICAgICAgcHJpbnQgXCIlc1xcXFxhcltkLCVzJ11cXFxcYXJbciwlc10mJXNcXFxcYXJbciwlc10mJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJXNcXFxcYXJbciwlcyddJiVzXFxcXGFyW3IsJXMnXSYlc1wiXG4gICAgICAgICAgICAgICAgICh0bSAwIHAxKSAoc3QgMCBwMSkgKHN0IDAgcDIpICh0bSAxIHAyKSAoc3QgMSBwMikgKHRtIDIgcDIpIChzdCAyIHAyKSAodG0gMSBwMSkgKHN0IDEgcDEpICh0bSAyIHAxKSAoc3QgMiBwMSkgKHRtIDMgcDEpXG4gICAgICAgICAgICAgfCAzLCA0IC0+XG4gICAgICAgICAgICAgICBwcmludCBcIiVzXFxcXGFyW2RkLCVzJ11cXFxcYXJbciwlc10mJXNcXFxcYXJbciwlc10mJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlc1xcXFxhcltyLCVzJ10mJXNcXFxcYXJbciwlcyddJiVzXCJcbiAgICAgICAgICAgICAgICAgKHRtIDAgcDEpIChzdCAwIHAxKSAoc3QgMCBwMikgKHRtIDEgcDIpIChzdCAxIHAyKSAodG0gMiBwMikgKHN0IDIgcDIpICh0bSAzIHAyKSAoc3QgMyBwMikgKHRtIDEgcDEpIChzdCAxIHAxKSAodG0gMiBwMSkgKHN0IDIgcDEpICh0bSAzIHAxKVxuICAgICAgICAgICAgICopXG4gICAgICAgICAgICAgfCAzLCA1IC0+XG4gICAgICAgICAgICAgICBwcmludCBcIiVzXFxcXGFyW2RkZCwlcyddXFxcXGFyW3IsJXNdJiVzXFxcXGFyW3IsJXNdJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlc1xcXFxhcltyLCVzJ10mJXNcXFxcYXJbciwlcyddJiVzXCJcbiAgICAgICAgICAgICAgICAgKHRtIDAgcDEpIChzdCAwIHAxKSAoc3QgMCBwMikgKHRtIDEgcDIpIChzdCAxIHAyKSAodG0gMiBwMikgKHN0IDIgcDIpICh0bSAzIHAyKSAoc3QgMyBwMikgKHRtIDQgcDIpIChzdCA0IHAyKSAodG0gMSBwMSkgKHN0IDEgcDEpICh0bSAyIHAxKSAoc3QgMiBwMSkgKHRtIDMgcDEpXG4gICAgICAgICAgICAgfCAzLCA4IC0+XG4gICAgICAgICAgICAgICBwcmludCBcIiVzXFxcXGFyW2RkZGRkZCwlcyddXFxcXGFyW3IsJXNdJiVzXFxcXGFyW3IsJXNdJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlc1xcXFxhcltyLCVzJ10mJXNcXFxcYXJbciwlcyddJiVzXCJcbiAgICAgICAgICAgICAgICAgKHRtIDAgcDEpIChzdCAwIHAxKSAoc3QgMCBwMikgKHRtIDEgcDIpIChzdCAxIHAyKSAodG0gMiBwMikgKHN0IDIgcDIpICh0bSAzIHAyKSAoc3QgMyBwMikgKHRtIDQgcDIpIChzdCA0IHAyKSAodG0gNSBwMikgKHN0IDUgcDIpICh0bSA2IHAyKSAoc3QgNiBwMikgKHRtIDcgcDIpIChzdCA3IHAyKSAodG0gMSBwMSkgKHN0IDEgcDEpICh0bSAyIHAxKSAoc3QgMiBwMSkgKHRtIDMgcDEpXG4gICAgICAgICAgICAgfCAzLCA5IC0+XG4gICAgICAgICAgICAgICBwcmludCBcIiVzXFxcXGFyW2RkZGRkZGQsJXMnXVxcXFxhcltyLCVzXSYlc1xcXFxhcltyLCVzXSYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlc1xcXFxhcltyLCVzJ10mJXNcXFxcYXJbciwlcyddJiVzXCJcbiAgICAgICAgICAgICAgICAgKHRtIDAgcDEpIChzdCAwIHAxKSAoc3QgMCBwMikgKHRtIDEgcDIpIChzdCAxIHAyKSAodG0gMiBwMikgKHN0IDIgcDIpICh0bSAzIHAyKSAoc3QgMyBwMikgKHRtIDQgcDIpIChzdCA0IHAyKSAodG0gNSBwMikgKHN0IDUgcDIpICh0bSA2IHAyKSAoc3QgNiBwMikgKHRtIDcgcDIpIChzdCA3IHAyKSAodG0gOCBwMikgKHN0IDggcDIpICh0bSAxIHAxKSAoc3QgMSBwMSkgKHRtIDIgcDEpIChzdCAyIHAxKSAodG0gMyBwMSlcbiAgICAgICAgICAgICB8IDMsIDEwIC0+XG4gICAgICAgICAgICAgICBwcmludCBcIiVzXFxcXGFyW2RkZGRkZGRkLCVzJ11cXFxcYXJbciwlc10mJXNcXFxcYXJbciwlc10mJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlc1xcXFxhcltyLCVzJ10mJXNcXFxcYXJbciwlcyddJiVzXCJcbiAgICAgICAgICAgICAgICAgKHRtIDAgcDEpIChzdCAwIHAxKSAoc3QgMCBwMikgKHRtIDEgcDIpIChzdCAxIHAyKSAodG0gMiBwMikgKHN0IDIgcDIpICh0bSAzIHAyKSAoc3QgMyBwMikgKHRtIDQgcDIpIChzdCA0IHAyKSAodG0gNSBwMikgKHN0IDUgcDIpICh0bSA2IHAyKSAoc3QgNiBwMikgKHRtIDcgcDIpIChzdCA3IHAyKSAodG0gOCBwMikgKHN0IDggcDIpICh0bSA5IHAyKSAoc3QgOSBwMikgKHRtIDEgcDEpIChzdCAxIHAxKSAodG0gMiBwMSkgKHN0IDIgcDEpICh0bSAzIHAxKVxuICAgICAgICAgICAgICgqXG4gICAgICAgICAgICAgfCA1LCA2IC0+XG4gICAgICAgICAgICAgICBwcmludCBcIiVzXFxcXGFyW2QsJXMnXVxcXFxhcltyLCVzXSYlc1xcXFxhcltyLCVzXSYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlc1xcXFxhcltkLCVzJ10mJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICVzXFxcXGFyW2QsJXMnXSYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJXNcXFxcYXJbZCwlcyddJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlc1xcXFxhcltyciwlcyddJiYlc1wiXG4gICAgICAgICAgICAgICAgICh0bSAwIHAxKSAoc3QgMCBwMSkgKHN0IDAgcDIpICh0bSAxIHAyKSAoc3QgMSBwMikgKHRtIDIgcDIpIChzdCAyIHAyKVxuICAgICAgICAgICAgICAgICAodG0gMSBwMSkgKHN0IDEgcDEpICh0bSAzIHAyKSAoc3QgMyBwMilcbiAgICAgICAgICAgICAgICAgKHRtIDIgcDEpIChzdCAyIHAxKSAodG0gNCBwMikgKHN0IDQgcDIpXG4gICAgICAgICAgICAgICAgICh0bSAzIHAxKSAoc3QgMyBwMSkgKHRtIDUgcDIpIChzdCA1IHAyKVxuICAgICAgICAgICAgICAgICAodG0gNCBwMSkgKHN0IDQgcDEpICh0bSA2IHAyKVxuICAgICAgICAgICAgICopXG4gICAgICAgICAgICAgfCBsMSwgbDIgd2hlbiBsMSA+PSAyICYmIGwyID0gbDEgKyAxIC0+XG4gICAgICAgICAgICAgICBwcmludCBcIiVzXFxcXGFyW2QsJXMnXVxcXFxhcltyLCVzXSYlc1xcXFxhcltyLCVzXSYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXCIgKHRtIDAgcDEpIChzdCAwIHAxKSAoc3QgMCBwMikgKHRtIDEgcDIpIChzdCAxIHAyKSAodG0gMiBwMikgKHN0IDIgcDIpO1xuICAgICAgICAgICAgICAgZm9yIGkgPSAxIHRvIGwxIC0gMiBkb1xuICAgICAgICAgICAgICAgICBwcmludCBcIiVzXFxcXGFyW2QsJXMnXSYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblwiICh0bSBpIHAxKSAoc3QgaSBwMSkgKHRtIChpKzIpIHAyKSAoc3QgKGkrMikgcDIpXG4gICAgICAgICAgICAgICBkb25lO1xuICAgICAgICAgICAgICAgbGV0IGkgPSBsMSAtIDEgaW5cbiAgICAgICAgICAgICAgIHByaW50IFwiJXNcXFxcYXJbcnIsJXMnXSYmJXNcIiAodG0gaSBwMSkgKHN0IGkgcDEpICh0bSAoaSsyKSBwMilcbiAgICAgICAgICAgICB8IGwxLCBsMiB3aGVuIGwxID49IDMgJiYgbDIgPSBsMSAtPlxuICAgICAgICAgICAgICAgcHJpbnQgXCIlc1xcXFxhcltkLCVzJ11cXFxcYXJbciwlc10mJXNcXFxcYXJbciwlc10mJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblwiICh0bSAwIHAxKSAoc3QgMCBwMSkgKHN0IDAgcDIpICh0bSAxIHAyKSAoc3QgMSBwMikgKHRtIDIgcDIpIChzdCAyIHAyKTtcbiAgICAgICAgICAgICAgIGZvciBpID0gMSB0byBsMSAtIDMgZG9cbiAgICAgICAgICAgICAgICAgcHJpbnQgXCIlc1xcXFxhcltkLCVzJ10mJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cIiAodG0gaSBwMSkgKHN0IGkgcDEpICh0bSAoaSsyKSBwMikgKHN0IChpKzIpIHAyKVxuICAgICAgICAgICAgICAgZG9uZTtcbiAgICAgICAgICAgICAgIGxldCBpID0gbDEgLSAyIGluXG4gICAgICAgICAgICAgICBwcmludCBcIiVzXFxcXGFyW3IsJXMnXSYlc1xcXFxhcltyLCVzJ10mJXNcIiAodG0gaSBwMSkgKHN0IGkgcDEpICh0bSAoaSsxKSBwMSkgKHN0IChpKzEpIHAxKSAodG0gKGkrMikgcDIpXG4gICAgICAgICAgICAgfCBsMSwgbDIgLT5cbiAgICAgICAgICAgICAgIGxldCBwID0gWmlnemFnLmNhbm9uaXplIChaaWd6YWcuYXBwZW5kIHAxIChaaWd6YWcuaW52IHAyKSkgaW5cbiAgICAgICAgICAgICAgIFByaW50Zi5wcmludGYgXCJUT0RPOiAlZCwgJWRcXG5cIiBsMSBsMjtcbiAgICAgICAgICAgICAgIGlmIFppZ3phZy5pc19pZCBwIHRoZW4gcHJpbnQgXCIlc1wiIChaaWd6YWcudG9fc3RyaW5nIH52YXIgcCkgZWxzZVxuICAgICAgICAgICAgICAgICBsZXQgbCA9IFppZ3phZy5sZW5ndGggcCBpblxuICAgICAgICAgICAgICAgICBQcmludGYucHJpbnRmIFwienpsZW46ICVkXFxuJSFcIiBsO1xuICAgICAgICAgICAgICAgICBsZXQgbiA9IDIgaW5cbiAgICAgICAgICAgICAgICAgZm9yIGkgPSAwIHRvIChsLTEpL24gZG9cbiAgICAgICAgICAgICAgICAgICBwcmludCBcIiVzXCIgKHRtIChpKm4pIHApO1xuICAgICAgICAgICAgICAgICAgIGZvciBqID0gMCB0byBtaW4gbiAobCAtIGkqbikgLSAxIGRvXG4gICAgICAgICAgICAgICAgICAgICBwcmludCBcIlxcXFxhcltyLCVzXSYlc1wiIChzdCAoaSpuK2opIHApICh0bSAoaSpuK2orMSkgcClcbiAgICAgICAgICAgICAgICAgICBkb25lO1xuICAgICAgICAgICAgICAgICAgIHByaW50IFwiXFxcXFxcXFxcIlxuICAgICAgICAgICAgICAgICBkb25lXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIHByaW50IFwiXFxcXG5vaW5kZW50XFxuXFxcXHN1YnNlY3Rpb24qeyVzfVxcblwiIChDb2hlcmVuY2UubmFtZSBjKTtcbiAgICAgICAgICAgKCogcHJpbnQgXCJcXFxcdnNwYWNley04ZXh9XFxuXCI7ICopXG4gICAgICAgICAgIHByaW50IFwiXFxcXFtcXG5cXFxcYmVnaW57dGlremNkfVxcblwiO1xuICAgICAgICAgICBjZCAoKTtcbiAgICAgICAgICAgcHJpbnQgXCJcXG5cXFxcZW5ke3Rpa3pjZH1cXG5cXFxcXVxcblxcblwiXG4gICAgICAgICkgKGNvaGVyZW5jZSBjcnMpO1xuICAgICAgcHJpbnQgXCJcXFxcZW5ke2RvY3VtZW50fVxcblwiO1xuICAgICAgIWFuc1xuXG4gICAgbGV0IHZpZXdfcGRmID92YXIgcnMgPVxuICAgICAgbGV0IGZuYW1lLCBvYyA9IEZpbGVuYW1lLm9wZW5fdGVtcF9maWxlIFwib2NhbWwtYWxnXCIgXCIudGV4XCIgaW5cbiAgICAgIG91dHB1dF9zdHJpbmcgb2MgKHRvX3RleCA/dmFyIHJzKTtcbiAgICAgIGNsb3NlX291dCBvYztcbiAgICAgIGxldCBjbWQgPSBQcmludGYuc3ByaW50ZiBcImNkICVzICYmIHBkZmxhdGV4ICVzICYmIGV2aW5jZSBgYmFzZW5hbWUgJXMgLnRleGAucGRmXCIgKEZpbGVuYW1lLmdldF90ZW1wX2Rpcl9uYW1lICgpKSBmbmFtZSBmbmFtZSBpblxuICAgICAgYXNzZXJ0IChTeXMuY29tbWFuZCBjbWQgPSAwKVxuXG4gICAgbGV0IG1ha2UgcnMgY29oZXJlbmNlID1cbiAgICAgIHsgcnM7IGNvaGVyZW5jZSB9XG5cbiAgICBsZXQgZmluZF9ydWxlIGNycyByID1cbiAgICAgIGZpbmQgKHJzIGNycykgclxuXG4gICAgKCoqIEZpbmQgY29oZXJlbmNlIHdpdGggZ2l2ZW4gbmFtZS4gKilcbiAgICBsZXQgZmluZCBycyBjcnMgPVxuICAgICAgTGlzdC5maW5kIChmdW4gYyAtPiBDb2hlcmVuY2UubmFtZSBjID0gY3JzKSBycy5jb2hlcmVuY2VcblxuICAgIGxldCBhZGRfY29oZXJlbmNlIGNycyBjIHAgPVxuICAgICAgKCogUHJpbnRmLnByaW50ZiBcImFkZF9jb2hlcmVuY2U6ICVzIC8gJXNcXG4lIVwiIChaaWd6YWcudG9fc3RyaW5nIHAxKSAoWmlnemFnLnRvX3N0cmluZyBwMik7ICopXG4gICAgICBhc3NlcnQgKGVxX3Rlcm0gKFppZ3phZy5zb3VyY2UgcCkgKFppZ3phZy50YXJnZXQgcCkpO1xuICAgICAgbGV0IGNvaGVyZW5jZSA9IChjb2hlcmVuY2UgY3JzKUBbQ29oZXJlbmNlLm1ha2UgYyBwXSBpblxuICAgICAgeyBjcnMgd2l0aCBjb2hlcmVuY2UgfVxuXG4gICAgKCoqIFJvdGF0ZSBhIGNvaGVyZW5jZS4gKilcbiAgICBsZXQgcm90YXRlIGNycyBjbmFtZSBuID1cbiAgICAgIGxldCBjb2hlcmVuY2UgPSBMaXN0Lm1hcCAoZnVuIGMgLT4gaWYgQ29oZXJlbmNlLm5hbWUgYyA9IGNuYW1lIHRoZW4gQ29oZXJlbmNlLnJvdGF0ZSBuIGMgZWxzZSBjKSBjcnMuY29oZXJlbmNlIGluXG4gICAgICB7IGNycyB3aXRoIGNvaGVyZW5jZSB9XG5cbiAgICAoKiogRWxpbWluYXRlIGEgcnVsZSB3aXRoIGEgY29oZXJlbmNlLiAqKVxuICAgIGxldCBlbGltX3J1bGUgY3JzIHIgYyA9XG4gICAgICBsZXQgciA9IGZpbmRfcnVsZSBjcnMgciBpblxuICAgICAgKCogbGV0IGNuYW1lID0gYyBpbiAqKVxuICAgICAgbGV0IGMgPSBmaW5kIGNycyBjIGluXG4gICAgICBsZXQgdiA9IENvaGVyZW5jZS52YWx1ZSByIGMgaW5cbiAgICAgIGxldCB2YXIgPSBWYXIubmFtZXJfbmF0dXJhbCAoKSBpbiBQcmludGYucHJpbnRmIFwiXFxuZWxpbSBydWxlOiBbJXNdID0+ICVzXFxuJSFcIiAoUnVsZS50b19zdHJpbmcgfnZhciByKSAoWmlnemFnLnRvX3N0cmluZyB+dmFyIHYpO1xuICAgICAgbGV0IHJ1bGVzID0gTGlzdC5maWx0ZXIgKGZ1biByJyAtPiBub3QgKFJ1bGUuZXEgciByJykpIChydWxlcyBjcnMpIGluXG4gICAgICBsZXQgY29oZXJlbmNlID0gTGlzdC5tYXAgKGZ1biBjIC0+IENvaGVyZW5jZS5yZXBsYWNlX3J1bGUgciB2IGMpIChjb2hlcmVuY2UgY3JzKSBpblxuICAgICAgKCogbGV0IGNvaGVyZW5jZSA9IExpc3QuZmlsdGVyIChmdW4gKGMsXykgLT4gYyA8PiBjbmFtZSkgY29oZXJlbmNlIGluICopXG4gICAgICB7IHJzID0geyBjcnMucnMgd2l0aCBydWxlcyB9OyBjb2hlcmVuY2UgfVxuXG4gICAgKCoqIE1vcnBoaXNtcyBiZXR3ZWVuIGNvaGVyZW50IHByZXNlbnRhdGlvbnMuICopXG4gICAgbW9kdWxlIE1vcnBoaXNtID0gc3RydWN0XG4gICAgICB0eXBlIHQgPVxuICAgICAgICB7XG4gICAgICAgICAgc291cmNlIDogY3JzO1xuICAgICAgICAgIHRhcmdldCA6IGNycztcbiAgICAgICAgICBtdXRhYmxlIHJ1bGVzIDogKFJ1bGUudCAqIFppZ3phZy50KSBsaXN0O1xuICAgICAgICAgICgqIG11bGFibGUgY29oZXJlbmNlcyA6IChDb2hlcmVuY2UudCAqICkgKilcbiAgICAgICAgfVxuICAgIGVuZFxuICBlbmRcbmVuZFxuIiwiKCoqIEFscGhhYmV0cy4gKilcblxuKCoqIEFuIGFscGhhYmV0IGlzIHNpbXBseSBhbm90aGVyIG5hbWUgZm9yIGEgc2V0LCBidXQgdGhlIG1vZHVsZSBbU2V0XSBhbHJlYWR5XG4gICAgZXhpc3RzLiAqKVxuXG4oKiogQW4gYWxwaGFiZXQuICopXG5tb2R1bGUgdHlwZSBUID0gc2lnXG4gICgqKiBBIGxldHRlci4gKilcbiAgdHlwZSB0XG5cbiAgdmFsIGVxIDogdCAtPiB0IC0+IGJvb2xcblxuICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcblxuICB2YWwgY29tcGFyZSA6IHQgLT4gdCAtPiBpbnRcbmVuZFxuXG4oKiogVGhlIGFscGhhYmV0IG9mIGNoYXJhY3RlcnMuICopXG5tb2R1bGUgQ2hhciA9IHN0cnVjdFxuICB0eXBlIHQgPSBjaGFyXG5cbiAgbGV0IGVxIGMgZCA9IChjOmNoYXIpID0gKGQ6Y2hhcilcblxuICBsZXQgdG9fc3RyaW5nIGMgPSBTdHJpbmcubWFrZSAxIGNcblxuICBsZXQgY29tcGFyZSBjIGQgPSBjb21wYXJlIChjOmNoYXIpIChkOmNoYXIpXG5cbiAgbGV0IGxlcSBjIGQgPSAoYzpjaGFyKSA8PSAoZDpjaGFyKVxuXG4gIGxldCBnZXEgYyBkID0gKGM6Y2hhcikgPj0gKGQ6Y2hhcilcbmVuZFxubW9kdWxlIENoYXJBbHBoYWJldCA6IChUIHdpdGggdHlwZSB0ID0gY2hhcikgPSBDaGFyXG5cbigqIEJhY2t1cCBzaW5jZSB3ZSBuZWVkIGl0IGFmdGVyd2FyZC4gKilcbm1vZHVsZSBTdHIgPSBTdHJpbmdcblxubW9kdWxlIFN0cmluZyA6IChUIHdpdGggdHlwZSB0ID0gc3RyaW5nKSA9IHN0cnVjdFxuICB0eXBlIHQgPSBzdHJpbmdcbiAgbGV0IGVxIHMgdCA9IChzOnN0cmluZykgPSAodDpzdHJpbmcpXG5cbiAgbGV0IHRvX3N0cmluZyBzID0gc1xuXG4gIGxldCBjb21wYXJlIHMgIHQgPSBjb21wYXJlIChzOnN0cmluZykgKHQ6c3RyaW5nKVxuZW5kXG5cbigqKiBUaGUgYWxwaGFiZXQgb2YgaW50ZWdlcnMuICopXG5tb2R1bGUgSW50ID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuICBsZXQgZXEgaSBqID0gKGk6aW50KSA9IChqOmludClcblxuICBsZXQgdG9fc3RyaW5nID0gc3RyaW5nX29mX2ludFxuXG4gIGxldCBjb21wYXJlIGkgaiA9IGNvbXBhcmUgKGk6aW50KSAoajppbnQpXG5cbiAgbGV0IGxlcSBpIGogPSAoaTppbnQpIDw9IChqOmludClcblxuICBsZXQgZ2VxIGkgaiA9IChpOmludCkgPj0gKGo6aW50KVxuZW5kXG5tb2R1bGUgSW50QWxwaGFiZXQgOiAoVCB3aXRoIHR5cGUgdCA9IGludCkgPSBJbnRcblxuKCoqIFRoZSBhbHBoYWJldCB3aXRoIG9uZSBlbGVtZW50LiAqKVxubW9kdWxlIFVuaXQgOiBUIHdpdGggdHlwZSB0ID0gdW5pdCA9IHN0cnVjdFxuICB0eXBlIHQgPSB1bml0XG5cbiAgbGV0IGVxICgpICgpID0gdHJ1ZVxuXG4gIGxldCBjb21wYXJlICgpICgpID0gMFxuXG4gIGxldCB0b19zdHJpbmcgKCkgPSBcIipcIlxuZW5kXG5cbigqKiBQcm9kdWN0IG9mIGFscGhhYmV0cy4gKilcbm1vZHVsZSBQcm9kIChBOlQpIChCOlQpIDogKFQgd2l0aCB0eXBlIHQgPSBBLnQgKiBCLnQpID0gc3RydWN0XG4gIHR5cGUgdCA9IEEudCAqIEIudFxuXG4gIGxldCBlcSAoYSxiKSAoYScsYicpID1cbiAgICBBLmVxIGEgYScgJiYgQi5lcSBiIGInXG5cbiAgbGV0IGNvbXBhcmUgKGEsYikgKGEnLGInKSA9XG4gICAgbGV0IGMgPSBBLmNvbXBhcmUgYSBhJyBpblxuICAgIGlmIGMgPSAwIHRoZW4gQi5jb21wYXJlIGIgYidcbiAgICBlbHNlIGNcblxuICBsZXQgdG9fc3RyaW5nIChhLGIpID1cbiAgICBcIihcIiBeIEEudG9fc3RyaW5nIGEgXiBcIixcIiBeIEIudG9fc3RyaW5nIGIgXiBcIilcIlxuZW5kXG5cbigqKiBUcmlwbGUgcHJvZHVjdCBvZiBhbHBoYWJldHMuICopXG5tb2R1bGUgUHJvZDMgKEE6VCkgKEI6VCkgKEM6VCkgOiAoVCB3aXRoIHR5cGUgdCA9IEEudCAqIEIudCAqIEMudCkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gQS50ICogQi50ICogQy50XG5cbiAgbGV0IGVxIChhLGIsYykgKGEnLGInLGMnKSA9XG4gICAgQS5lcSBhIGEnICYmIEIuZXEgYiBiJyAmJiBDLmVxIGMgYydcblxuICBsZXQgY29tcGFyZSAoYSxiLGMpIChhJyxiJyxjJykgPVxuICAgIGxldCBjb21wID0gQS5jb21wYXJlIGEgYScgaW5cbiAgICBpZiBjb21wIDw+IDAgdGhlbiBjb21wIGVsc2VcbiAgICAgIGxldCBjb21wID0gQi5jb21wYXJlIGIgYicgaW5cbiAgICAgIGlmIGNvbXAgPD4gMCB0aGVuIGNvbXAgZWxzZVxuICAgICAgICBDLmNvbXBhcmUgYyBjJ1xuXG4gIGxldCB0b19zdHJpbmcgKGEsYixjKSA9XG4gICAgXCIoXCIgXiBBLnRvX3N0cmluZyBhIF4gXCIsXCIgXiBCLnRvX3N0cmluZyBiIF4gXCIsXCIgXiBDLnRvX3N0cmluZyBjIF4gXCIpXCJcbmVuZFxuXG4oKiogUG93ZXJzZXQuICopXG5tb2R1bGUgUG93IChBOlQpID0gc3RydWN0XG4gIG1vZHVsZSBTID0gU2V0Lk1ha2UoQSlcbiAgdHlwZSB0ID0gUy50XG4gIGxldCBlcSAodTp0KSAodjp0KSA9IFMuZXF1YWwgdSB2XG4gIGxldCBjb21wYXJlICh1OnQpICh2OnQpID0gUy5jb21wYXJlIHUgdlxuICBsZXQgdG9fc3RyaW5nICh1OnQpID1cbiAgICBsZXQgcyA9IFMuZm9sZCAoZnVuIHggcyAtPiBpZiBzID0gXCJcIiB0aGVuIEEudG9fc3RyaW5nIHggZWxzZSBzIF4gXCIsXCIgXiBBLnRvX3N0cmluZyB4KSB1IFwiXCIgaW5cbiAgICBcIntcIiBeIHMgXiBcIn1cIlxuICBsZXQgZW1wdHkgOiB0ID0gUy5lbXB0eVxuICBsZXQgb2ZfbGlzdCBsIDogdCA9IFMub2ZfbGlzdCBsXG4gIGxldCBhZGQgKHU6dCkgKHg6QS50KSA9IFMuYWRkIHggdVxuICBsZXQgbWVtICh1OnQpICh4OkEudCkgPSBTLm1lbSB4IHVcbiAgbGV0IGl0ZXIgKGY6QS50LT51bml0KSAodTp0KSA9IFMuaXRlciBmIHVcbmVuZFxubW9kdWxlIFBvd0FscGhhYmV0IChBOlQpIDogVCA9IFBvdyhBKVxuXG4oKiogRnJlZSBtb25vaWQgbW9uYWQuICopXG5tb2R1bGUgTGlzdCAoQTpUKSA9IHN0cnVjdFxuICB0eXBlIHQgPSBBLnQgbGlzdFxuXG4gIGxldCBlcSB1IHYgPVxuICAgIHRyeVxuICAgICAgTGlzdC5mb3JfYWxsMiAoZnVuIHggeSAtPiBBLmVxIHggeSkgdSB2XG4gICAgd2l0aFxuICAgIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+IGZhbHNlXG5cbiAgbGV0IHRvX3N0cmluZyB1ID1cbiAgICBTdHIuY29uY2F0IFwiXCIgKExpc3QubWFwIEEudG9fc3RyaW5nIHUpXG5cbiAgbGV0IHJlYyBjb21wYXJlIHUgdiA9XG4gICAgbWF0Y2ggdSx2IHdpdGhcbiAgICB8IHg6OnUsIHk6OnYgLT5cbiAgICAgICBsZXQgYyA9IEEuY29tcGFyZSB4IHkgaW5cbiAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2UgY29tcGFyZSB1IHZcbiAgICB8IFtdLCBbXSAtPiAwXG4gICAgfCBbXSwgXyAtPiAtMVxuICAgIHwgXywgW10gLT4gMVxuZW5kXG5tb2R1bGUgTGlzdEFscGhhYmV0IChBOlQpIDogVCA9IExpc3QoQSlcblxuKCoqIEZ1bmN0aW9ucyBiZXR3ZWVuIGFscGhhYmV0cy4gKilcbm1vZHVsZSBNYXAgKEE6VCkgKEI6VCkgPSBzdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNYXAuTWFrZShBKVxuXG4gIHR5cGUgdCA9IEIudCBNLnRcblxuICBsZXQgZW1wdHkgOiB0ID0gTS5lbXB0eVxuXG4gIGxldCBhcHAgKGY6dCkgKHg6QS50KSA9IE0uZmluZCB4IGZcblxuICBsZXQgYWRkIChmOnQpICh4OkEudCkgdiA6IHQgPSBNLmFkZCB4IHYgZlxuXG4gICgqKiBJcyBhbiBlbGVtZW50IGluIHRoZSBkb21haW4/ICopXG4gIGxldCBtZW0gKGY6dCkgKHg6QS50KSA9IE0ubWVtIHggZlxuXG4gIGxldCBpdGVyID0gTS5pdGVyXG5lbmRcbiIsIigqKiBTaW1wbGljaWFsIHNldHMuICopXG5cbigqKiBBIHNpbXBsaWNpYWwgc2V0LiAqKVxubW9kdWxlIHR5cGUgVCA9IHNpZ1xuICAoKiogQSBzaW1wbGV4LiAqKVxuICB0eXBlIHRcblxuICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcblxuICAoKiogRGltZW5zaW9uIG9mIGEgc2ltcGxleC4gKilcbiAgdmFsIGRpbSA6IHQgLT4gaW50XG5cbiAgKCoqIEZhY2VzIG9mIGEgc2ltcGxleC4gKilcbiAgdmFsIGZhY2UgOiB0IC0+IGludCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgUHJlcyAoWCA6IEFscGhhYmV0LlQpID0gc3RydWN0XG5lbmRcbiIsIigqKiBSaW5ncy4gKilcblxuKCoqIEEgcmluZy4gKilcbm1vZHVsZSB0eXBlIFQgPSBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIGVxIDogdCAtPiB0IC0+IGJvb2xcblxuICB2YWwgYWRkIDogdCAtPiB0IC0+IHRcblxuICB2YWwgemVybyA6IHRcblxuICB2YWwgbmVnIDogdCAtPiB0XG5cbiAgdmFsIG11bCA6IHQgLT4gdCAtPiB0XG5cbiAgdmFsIG9uZSA6IHRcblxuICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbmVuZFxuXG4oKiogQW4gZXVjbGlkZWFuIGRvbWFpbi4gKilcbm1vZHVsZSB0eXBlIEV1Y2xpZGVhbiA9IHNpZ1xuICBpbmNsdWRlIFRcblxuICB2YWwgZGl2IDogdCAtPiB0IC0+ICh0ICogdClcbmVuZFxuXG4oKiogVGhlIHJpbmcgb2YgYm9vbGVhbnMuICopXG5tb2R1bGUgQm9vbCA6IChUIHdpdGggdHlwZSB0ID0gYm9vbCkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gYm9vbFxuXG4gIGxldCBlcSB4IHkgPSAoeDpib29sKSA9ICh5OmJvb2wpXG5cbiAgbGV0IGFkZCB4IHkgPSAoeCB8fCB5KSAmJiBub3QgKHggJiYgeSlcblxuICBsZXQgemVybyA9IGZhbHNlXG5cbiAgbGV0IG5lZyB4ID0geFxuXG4gIGxldCBtdWwgeCB5ID0geCAmJiB5XG5cbiAgbGV0IG9uZSA9IHRydWVcblxuICBsZXQgdG9fc3RyaW5nIHggPVxuICAgIGlmIHggdGhlbiBcIlRcIiBlbHNlIFwiRlwiXG5lbmRcblxuKCoqIFRoZSByaW5nIG9mIGludGVnZXJzLiAqKVxubW9kdWxlIEludCA6IChUIHdpdGggdHlwZSB0ID0gaW50KSA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgZXEgeCB5ID0gKHg6aW50KSA9ICh5OmludClcblxuICBsZXQgYWRkID0gKCArIClcblxuICBsZXQgemVybyA9IDBcblxuICBsZXQgbmVnIHggPSAtIHhcblxuICBsZXQgbXVsID0gKCAqIClcblxuICBsZXQgb25lID0gMVxuXG4gIGxldCB0b19zdHJpbmcgPSBzdHJpbmdfb2ZfaW50XG5lbmRcblxuKCoqIFRoZSByaW5nIG9mIGZsb2F0cy4gKilcbm1vZHVsZSBGbG9hdCA6IChUIHdpdGggdHlwZSB0ID0gZmxvYXQpID0gc3RydWN0XG4gIHR5cGUgdCA9IGZsb2F0XG5cbiAgbGV0IGVxICh4OnQpICh5OnQpID0geCA9IHlcblxuICBsZXQgYWRkID0gKCArLiApXG5cbiAgbGV0IHplcm8gPSAwLlxuXG4gIGxldCBuZWcgeCA9IC0uIHhcblxuICBsZXQgbXVsID0gKCAqLiApXG5cbiAgbGV0IG9uZSA9IDEuXG5cbiAgbGV0IHRvX3N0cmluZyA9IHN0cmluZ19vZl9mbG9hdFxuZW5kXG5cbigqKiBQb2x5bm9taWFsIHJpbmcgb3ZlciBhIHJpbmcuICopXG5tb2R1bGUgUG9seW5vbWlhbCAoUiA6IFQpID0gc3RydWN0XG4gICgqKiBBIHBvbHlub21pYWwuICopXG4gIHR5cGUgdCA9IFIudCBhcnJheVxuXG4gIGxldCBsZW5ndGggKHA6dCkgPSBBcnJheS5sZW5ndGggcFxuXG4gICgqKiBEZWdyZWUgb2YgYSBwb2x5bm9taWFsLiAqKVxuICBsZXQgZGVncmVlIChwOnQpID1cbiAgICBsZXQgYW5zID0gcmVmIDAgaW5cbiAgICB0cnlcbiAgICAgIGZvciBpID0gbGVuZ3RoIHAgLSAxIGRvd250byAwIGRvXG4gICAgICAgIGlmIG5vdCAoUi5lcSBSLnplcm8gcC4oaSkpIHRoZW5cbiAgICAgICAgICAoXG4gICAgICAgICAgICBhbnMgOj0gaTtcbiAgICAgICAgICAgIHJhaXNlIEV4aXRcbiAgICAgICAgICApXG4gICAgICBkb25lO1xuICAgICAgbWluX2ludFxuICAgIHdpdGhcbiAgICB8IEV4aXQgLT4gIWFuc1xuXG4gIGxldCBlcSAocDp0KSAocTp0KSA9XG4gICAgbGV0IGRwID0gZGVncmVlIHAgaW5cbiAgICBsZXQgZHEgPSBkZWdyZWUgcSBpblxuICAgIHRyeVxuICAgICAgaWYgZHAgPD4gZHEgdGhlbiByYWlzZSBFeGl0O1xuICAgICAgZm9yIGkgPSAwIHRvIGRwIC0gMSBkb1xuICAgICAgICBpZiBub3QgKFIuZXEgcC4oaSkgcS4oaSkpIHRoZW4gcmFpc2UgRXhpdFxuICAgICAgICBkb25lO1xuICAgICAgICB0cnVlXG4gICAgd2l0aFxuICAgIHwgRXhpdCAtPiBmYWxzZVxuXG4gIGxldCBjb21wYWN0IHAgOiB0ID1cbiAgICBBcnJheS5pbml0IChkZWdyZWUgcCkgKGZ1biBpIC0+IHAuKGkpKVxuXG4gIGxldCBjb2VmZiBwIGkgPVxuICAgIGlmIGkgPCBsZW5ndGggcCB0aGVuIHAuKGkpIGVsc2UgUi56ZXJvXG5cbiAgbGV0IGluaXQgbiBmIDogdCA9XG4gICAgQXJyYXkuaW5pdCBuIGZcblxuICBsZXQgcmVjIGFkZCBwIHEgPVxuICAgIGxldCBwbCA9IGxlbmd0aCBwIGluXG4gICAgbGV0IHFsID0gbGVuZ3RoIHEgaW5cbiAgICBpZiBwbCA+IHFsIHRoZW4gYWRkIHEgcCBlbHNlXG4gICAgICBpbml0IHFsIChmdW4gaSAtPiBpZiBpIDwgcGwgdGhlbiBSLmFkZCBwLihpKSBxLihpKSBlbHNlIHEuKGkpKVxuXG4gIGxldCB6ZXJvID0gW3x8XVxuXG4gIGxldCBjbXVsIGEgKHA6dCkgOiB0ID1cbiAgICBBcnJheS5tYXAgKFIubXVsIGEpIHBcblxuICBsZXQgbmVnIHAgPSBjbXVsIChSLm5lZyBSLm9uZSkgcFxuXG4gIGxldCBzdWIgcCBxID1cbiAgICBhZGQgcCAobmVnIHEpXG5cbiAgbGV0IG11bCBwIHEgPVxuICAgIGluaXQgKGRlZ3JlZSBwICsgZGVncmVlIHEpIChmdW4gbiAtPlxuICAgICAgbGV0IGFucyA9IHJlZiBSLnplcm8gaW5cbiAgICAgIGZvciBpID0gMCB0byBuIGRvXG4gICAgICAgIGFucyA6PSBSLmFkZCAhYW5zIChSLm11bCAoY29lZmYgcCBpKSAoY29lZmYgcSAobi1pKSkpXG4gICAgICBkb25lO1xuICAgICAgIWFuc1xuICAgIClcblxuICBsZXQgb25lID0gW3xSLm9uZXxdXG5cbiAgbGV0IHRvX3N0cmluZyAocDp0KSA9XG4gICAgbGV0IGFucyA9IHJlZiBcIlwiIGluXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBwIC0gMSBkb1xuICAgICAgYW5zIDo9ICFhbnNcbiAgICAgIF4gKGlmIGkgPD4gMCB0aGVuIFwiK1wiIGVsc2UgXCJcIilcbiAgICAgIF4gKGlmIFIuZXEgUi56ZXJvIHAuKGkpIHRoZW4gXCJcIiBlbHNlIFIudG9fc3RyaW5nIHAuKGkpIF4gaWYgaSA9IDAgdGhlbiBcIlwiIGVsc2UgKFwiWF5cIiBeIHN0cmluZ19vZl9pbnQgaSkpXG4gICAgZG9uZTtcbiAgICAhYW5zXG5cbiAgbGV0IG1vbm9taWFsIGMgbiA9XG4gICAgbGV0IGFucyA9IEFycmF5Lm1ha2UgKG4rMSkgUi56ZXJvIGluXG4gICAgYW5zLihuKSA8LSBjO1xuICAgIGFuc1xuZW5kXG5tb2R1bGUgUG9seW5vbWlhbFJpbmcgKFIgOiBUKSA9IChQb2x5bm9taWFsKFIpIDogVClcblxuKCoqIE9wcG9zaXRlIHJpbmcuICopXG5tb2R1bGUgT3AgKFIgOiBUKSA6IChUIHdpdGggdHlwZSB0ID0gUi50KSA9IHN0cnVjdFxuICBpbmNsdWRlIFJcblxuICBsZXQgbXVsIHggeSA9IG11bCB5IHhcbmVuZFxuIiwiKCoqIEZpZWxkcy4gKilcblxuKCoqIEEgZmllbGQuICopXG5tb2R1bGUgdHlwZSBUID0gc2lnXG4gIGluY2x1ZGUgUmluZy5UXG5cbiAgKCoqIEludmVyc2UuICopXG4gIHZhbCBpbnYgOiB0IC0+IHRcbmVuZFxuXG4oKiogVGhlIGZpZWxkIHdpdGggdHdvIGVsZW1lbnRzLiAqKVxubW9kdWxlIEJvb2wgOiAoVCB3aXRoIHR5cGUgdCA9IGJvb2wpID0gc3RydWN0XG4gIGluY2x1ZGUgUmluZy5Cb29sXG5cbiAgbGV0IGludiAoeDp0KSA9IHhcbmVuZFxuXG4oKiogVGhlIGZpZWxkIG9mIGZsb2F0cy4gKilcbm1vZHVsZSBGbG9hdCA6IChUIHdpdGggdHlwZSB0ID0gZmxvYXQpID0gc3RydWN0XG4gIGluY2x1ZGUgUmluZy5GbG9hdFxuXG4gIGxldCBpbnYgKHg6dCkgOiB0ID0gMS4gLy4geFxuZW5kXG5cbigqKiBUaGUgXCJmaWVsZFwiIG9mIGludGVnZXJzLiAqKVxubW9kdWxlIEludCA9IHN0cnVjdFxuICBpbmNsdWRlIFJpbmcuSW50XG5cbiAgbGV0IGludiB4ID1cbiAgICBpZiBlcSBvbmUgeCB0aGVuIG9uZVxuICAgIGVsc2UgaWYgZXEgKG5lZyBvbmUpIHggdGhlbiAobmVnIG9uZSlcbiAgICBlbHNlXG4gICAgICBmYWlsd2l0aCAoXCJDYW5ub3QgaW52ZXJ0IFwiXnN0cmluZ19vZl9pbnQgeF5cIi5cIilcbmVuZFxuXG4oKiogRmllbGQgb2YgZnJhY3Rpb25zIG92ZXIgYW4gZXVjbGlkZWFuIGRvbWFpbi4gKilcbm1vZHVsZSBGcmFjdGlvbnMgKFIgOiBSaW5nLkV1Y2xpZGVhbikgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gUi50ICogUi50XG5cbiAgKCoqIEdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yLiAqKVxuICBsZXQgcmVjIGdjZCBhIGIgPVxuICAgIGxldCByZW0gYSBiID0gc25kIChSLmRpdiBhIGIpIGluXG4gICAgaWYgUi5lcSBSLnplcm8gYiB0aGVuIGEgZWxzZSBnY2QgYiAocmVtIGEgYilcblxuICBsZXQgY2Fub25pemUgKChhLGIpOnQpIDogdCA9XG4gICAgbGV0IGQgPSBnY2QgYSBiIGluXG4gICAgbGV0IGEsXyA9IFIuZGl2IGEgZCBpblxuICAgIGxldCBiLF8gPSBSLmRpdiBhIGQgaW5cbiAgICAoYSxiKVxuXG4gIGxldCBlcSAoKGEsYik6dCkgKChjLGQpOnQpID1cbiAgICBsZXQgKGEsYikgPSBjYW5vbml6ZSAoYSxiKSBpblxuICAgIGxldCAoYyxkKSA9IGNhbm9uaXplIChjLGQpIGluXG4gICAgKFIuZXEgYSBjICYmIFIuZXEgYiBkKSB8fCAoUi5lcSAoUi5uZWcgYSkgYyAmJiBSLmVxIChSLm5lZyBiKSBkKVxuXG4gIGxldCBhZGQgKChhLGIpOnQpICgoYyxkKTp0KSA6IHQgPSAoUi5hZGQgKFIubXVsIGEgZCkgKFIubXVsIGIgYyksIFIubXVsIGMgZClcblxuICBsZXQgemVybyA6IHQgPSAoUi56ZXJvLCBSLm9uZSlcblxuICBsZXQgbmVnICgoYSxiKTp0KSA6IHQgPSAoUi5uZWcgYSwgYilcblxuICBsZXQgbXVsICgoYSxiKTp0KSAoKGMsZCk6dCkgOiB0ID0gKFIubXVsIGEgYywgUi5tdWwgYyBkKVxuXG4gIGxldCBvbmUgOiB0ID0gKFIub25lLCBSLm9uZSlcblxuICBsZXQgaW52ICgoYSxiKTp0KSA6IHQgPSAoYixhKVxuXG4gIGxldCB0b19zdHJpbmcgKChhLGIpOnQpID1cbiAgICBcIihcIiBeIFIudG9fc3RyaW5nIGEgXiBcIikvKFwiIF4gUi50b19zdHJpbmcgYiBeIFwiKVwiXG5lbmRcblxubW9kdWxlIEZyYWN0aW9uc0ZpZWxkIChSIDogUmluZy5FdWNsaWRlYW4pIDogVCA9IEZyYWN0aW9ucyhSKVxuXG4oKiogRmllbGQgb2YgcmF0aW9uYWwgZnJhY3Rpb25zLiAqKVxubW9kdWxlIFJhdGlvbmFsRnJhY3Rpb25zIChGIDogVCkgPSBzdHJ1Y3RcbiAgICgqKiBSaW5nIG9mIHBvbHlub21pYWxzIG92ZXIgYSBmaWVsZC4gKilcbiAgbW9kdWxlIFBvbHlub21pYWwgKEYgOiBUKSA6IFJpbmcuRXVjbGlkZWFuIHdpdGggdHlwZSB0ID0gUmluZy5Qb2x5bm9taWFsKEYpLnQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFJpbmcuUG9seW5vbWlhbChGKVxuXG4gICAgKCoqIEV1Y2xpZGVhbiBkaXZpc2lvbi4gKilcbiAgICBsZXQgZGl2IGEgYiA9XG4gICAgICBsZXQgZGIgPSBkZWdyZWUgYiBpblxuICAgICAgYXNzZXJ0IChkYiA+PSAwKTtcbiAgICAgIGxldCBxID0gcmVmIHplcm8gaW5cbiAgICAgIGxldCByID0gcmVmIGEgaW5cbiAgICAgIGxldCBkciA9IHJlZiAoZGVncmVlICFyKSBpblxuICAgICAgd2hpbGUgIWRyID49IGRiIGRvXG4gICAgICAgICgqIHF1b3RpZW50IG9mIGxlYWRpbmcgbW9ub21pYWxzIG9mIHIgYW5kIGIgKilcbiAgICAgICAgbGV0IHQgPSBtb25vbWlhbCAoRi5tdWwgIXIuKCFkcikgKEYuaW52IGIuKGRiKSkpICghZHIgLSBkYikgaW5cbiAgICAgICAgcSA6PSBhZGQgIXEgdDtcbiAgICAgICAgciA6PSBzdWIgIXIgKG11bCB0IGIpO1xuICAgICAgICBkciA6PSBkZWdyZWUgIXJcbiAgICAgIGRvbmU7XG4gICAgICAhcSwgIXIgICAgXG4gIGVuZFxuXG4gIGluY2x1ZGUgRnJhY3Rpb25zKFBvbHlub21pYWwoRikpXG5lbmRcblxubW9kdWxlIFJhdGlvbmFsRnJhY3Rpb25zRmllbGQgKEYgOiBUKSA6IFQgPSBSYXRpb25hbEZyYWN0aW9ucyhGKVxuXG4oKiogVW5kZXJseWluZyByaW5nIG9mIGEgZmllbGQuICopXG5tb2R1bGUgUmluZyAoRiA6IFQpIDogUmluZy5UID0gc3RydWN0XG4gIGluY2x1ZGUgRlxuZW5kXG4iLCIoKiogRm9ybWFsIHNlcmllcy4gKilcblxuKCoqIEZvcm1hbCBzZXJpZXMgb3ZlciBhIGdpdmVuIGZpZWxkLiAqKVxubW9kdWxlIE1ha2UgKEsgOiBGaWVsZC5UKSA9IHN0cnVjdFxuICAoKiogQSBmb3JtYWwgc2VyaWVzLiAqKVxuICB0eXBlIHQgPSAoSy50IFdlYWsudCByZWYgKiAoaW50IC0+IEsudCkpXG5cbiAgKCoqIEVxdWFsaXR5LiAqKVxuICBsZXQgZXEgKGE6dCkgKGI6dCkgPSBmYWlsd2l0aCBcIkNhbm5vdCBpbXBsZW1lbnQgdGhpcy5cIlxuXG4gICgqKiBHZXQgYSBjb2VmZmljaWVudC4gKilcbiAgbGV0IGdldCAoYTp0KSBuID1cbiAgICBsZXQgYXcsIGFmID0gYSBpblxuICAgIGxldCBhd2wgPSBXZWFrLmxlbmd0aCAhYXcgaW5cbiAgICBsZXQgeCA9IGlmIG4gPCBhd2wgdGhlbiBXZWFrLmdldCAhYXcgbiBlbHNlIE5vbmUgaW5cbiAgICBtYXRjaCB4IHdpdGhcbiAgICB8IFNvbWUgeCAtPiB4XG4gICAgfCBOb25lIC0+XG4gICAgICAgbGV0IHggPSBhZiBuIGluXG4gICAgICAgaWYgbiA+PSBhd2wgdGhlblxuICAgICAgICAgKFxuICAgICAgICAgICBsZXQgYXcnID0gV2Vhay5jcmVhdGUgKG4rMSkgaW5cbiAgICAgICAgICAgV2Vhay5ibGl0IGF3JyAwICFhdyAwIGF3bDtcbiAgICAgICAgICAgYXcgOj0gYXcnXG4gICAgICAgICApO1xuICAgICAgIFdlYWsuc2V0ICFhdyBuIChTb21lIHgpO1xuICAgICAgIHhcblxuICBsZXQgY29lZmYgPSBnZXRcblxuICBsZXQgdG9fc3RyaW5nIGEgPVxuICAgIGxldCBhbnMgPSByZWYgKEsudG9fc3RyaW5nIChnZXQgYSAwKSkgaW5cbiAgICBmb3IgaSA9IDEgdG8gOCBkb1xuICAgICAgbGV0IGFpID0gZ2V0IGEgaSBpblxuICAgICAgaWYgbm90IChLLmVxIGFpIEsuemVybykgdGhlblxuICAgICAgICBhbnMgOj1cbiAgICAgICAgICAhYW5zXG4gICAgICAgICAgXiBcIitcIlxuICAgICAgICAgIF4gKGlmIEsuZXEgYWkgSy5vbmUgdGhlbiBcIlwiIGVsc2UgSy50b19zdHJpbmcgYWkpXG4gICAgICAgICAgXiAoaWYgaSA9IDEgdGhlbiBcInpcIiBlbHNlIFwiel5cIiBeIHN0cmluZ19vZl9pbnQgaSlcbiAgICBkb25lO1xuICAgIGFucyA6PSAhYW5zIF4gXCIrLi4uXCI7XG4gICAgIWFuc1xuXG4gIGxldCBtYWtlIGYgOiB0ID0gKHJlZiAoV2Vhay5jcmVhdGUgMCksIGYpXG5cbiAgKCoqIFplcm8uICopXG4gIGxldCB6ZXJvID0gbWFrZSAoZnVuIF8gLT4gSy56ZXJvKVxuXG4gICgqKiBPbmUuICopXG4gIGxldCBvbmUgPSBtYWtlIChmdW4gbiAtPiBpZiBuID0gMCB0aGVuIEsub25lIGVsc2UgSy56ZXJvKVxuXG4gIGxldCB2YXIgPSBtYWtlIChmdW4gbiAtPiBpZiBuID0gMSB0aGVuIEsub25lIGVsc2UgSy56ZXJvKVxuXG4gICgqKiBBZGRpdGlvbi4gKilcbiAgbGV0IGFkZCBhIGIgPSBtYWtlIChmdW4gbiAtPiBLLmFkZCAoZ2V0IGEgbikgKGdldCBiIG4pKVxuXG4gICgqKiBTdWJ0cmFjdGlvbi4gKilcbiAgbGV0IHN1YiBhIGIgPSBtYWtlIChmdW4gbiAtPiBLLmFkZCAoZ2V0IGEgbikgKEsubXVsIChLLm5lZyBLLm9uZSkgKGdldCBiIG4pKSlcblxuICAoKiogTXVsdGlwbGljYXRpb24uICopXG4gIGxldCBtdWwgYSBiID1cbiAgICBsZXQgZiBuID1cbiAgICAgIGxldCBhbnMgPSByZWYgSy56ZXJvIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbiBkb1xuICAgICAgICBhbnMgOj0gSy5hZGQgIWFucyAoSy5tdWwgKGdldCBhIGkpIChnZXQgYiAobi1pKSkpXG4gICAgICBkb25lO1xuICAgICAgIWFuc1xuICAgIGluXG4gICAgbWFrZSBmXG5cbiAgKCoqIEludGVnZXIgZXhwb25lbnRpYWwuICopXG4gIGxldCByZWMgZXhwbiBhIG4gPVxuICAgIGFzc2VydCAobiA+PSAwKTtcbiAgICBpZiBuID0gMCB0aGVuIG9uZVxuICAgIGVsc2UgaWYgbiA9IDEgdGhlbiBhIGVsc2VcbiAgICAgIG11bCBhIChleHBuIGEgKG4tMSkpXG5cbiAgKCoqIEhhZGFtYXJkIHByb2R1Y3QuICopXG4gIGxldCBoYWRhbWFyZCBhIGIgPSBtYWtlIChmdW4gbiAtPiBLLm11bCAoZ2V0IGEgbikgKGdldCBiIG4pKVxuXG4gICgqKiBNdWx0aXBsaWNhdGlvbiBieSBhIGNvbnN0YW50LiAqKVxuICBsZXQgY211bCBhIGIgPSBtYWtlIChmdW4gbiAtPiBLLm11bCBhIChnZXQgYiBuKSlcblxuICAoKiogTmVnYXRpb24uICopXG4gIGxldCBuZWcgYSA9IG1ha2UgKGZ1biBuIC0+IEsubmVnIChnZXQgYSBuKSlcblxuICBsZXQgc3RhciBhID1cbiAgICAoKiBUT0RPICopXG4gICAgYXNzZXJ0IChLLmVxIChnZXQgYSAwKSBLLnplcm8pO1xuICAgICgqIGFkZCB0aGUgZXhwb25lbnRzIGZyb20gMCB0byBuICopXG4gICAgbGV0IHJlYyBhdXggbiA9XG4gICAgICBpZiBuID0gMCB0aGVuIGV4cG4gYSAwXG4gICAgICBlbHNlIGFkZCAoZXhwbiBhIG4pIChhdXggKG4tMSkpXG4gICAgaW5cbiAgICBtYWtlIChmdW4gbiAtPiBnZXQgKGF1eCBuKSBuKVxuXG4gICgqKiBJbnZlcnNlLiAqKVxuICBsZXQgaW52IGEgPSBzdGFyIChzdWIgb25lIGEpXG5cbiAgbW9kdWxlIFBvbHlub21pYWwgPSBSaW5nLlBvbHlub21pYWwoSylcblxuICAoKiogQ2Fub25pY2FsIGluamVjdGlvbiBvZiBwb2x5bm9taWFscy4gKilcbiAgbGV0IHBvbHlub21pYWwgKHAgOiBQb2x5bm9taWFsLnQpID1cbiAgICBtYWtlIChmdW4gbiAtPiBQb2x5bm9taWFsLmNvZWZmIHAgbilcblxuICBtb2R1bGUgUmF0aW9uYWxGcmFjdGlvbnMgPSBGaWVsZC5SYXRpb25hbEZyYWN0aW9ucyhLKVxuXG4gICgqKiBDYW5vbmljYWwgaW5qZWN0aW9uIG9mIHJhdGlvbmFsIGZyYWN0aW9ucy4gKilcbiAgbGV0IHJhdGlvbmFsIChyIDogUmF0aW9uYWxGcmFjdGlvbnMudCkgPVxuICAgIGxldCBwLCBxID0gciBpblxuICAgIGxldCBwID0gcG9seW5vbWlhbCBwIGluXG4gICAgbGV0IHEgPSBwb2x5bm9taWFsIHEgaW5cbiAgICBtdWwgcCAoaW52IHEpXG5lbmRcblxuKCoqIFRoZSBmaWVsZCBvZiBzZXJpZXMuICopXG5tb2R1bGUgRmllbGQgKEsgOiBGaWVsZC5UKSA6IFJpbmcuVCA9IE1ha2UoSylcbiIsIigqKiBIaWdoZXItZGltZW5zaW9uYWwgcHJlY2F0ZWdvcmllcy4gKilcblxuKCoqIEZyZWUgcHJlY2F0ZWdvcmllcy4gKilcbm1vZHVsZSBNYWtlIChYIDogQWxwaGFiZXQuVCkgPSBzdHJ1Y3RcbiAgKCoqIEEgY2VsbC4gKilcbiAgKCogTm90ZTogd2Ugc3VwcG9zZSB0aGF0IGdlbmVyYXRvcnMgYXJlIHdoaXNrZXJlZCAoYnkgaWRlbnRpdGllcyBpZiBuZWNlc3NhcnkpXG4gIGFsbCB0aGUgd2F5IGRvd24uICopXG4gIHR5cGUgY2VsbCA9XG4gICAgfCBDIG9mIHdoaXNrZXIgKiBjZWxsICgqKiBhIGNvbXBvc2l0ZSAqKVxuICAgIHwgSSBvZiBjZWxsICgqKiBhbiBpZGVudGl0eSAqKVxuXG4gICgqKiBBIHdoaXNrZXJlZCBnZW5lcmF0b3IuICopXG4gIGFuZCB3aGlza2VyID1cbiAgICB8IEcgb2YgWC50ICgqKiBhIGdlbmVyYXRvciAqKVxuICAgIHwgVyBvZiBjZWxsICogd2hpc2tlciAqIGNlbGwgKCoqIGEgd2hpc2tlciBjb250ZXh0ICopXG5cbiAgdHlwZSB0ID0gY2VsbFxuXG4gICgqKiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBjZWxsLiAqKVxuICBsZXQgdG9fc3RyaW5nIGMgPVxuICAgIGxldCByZWMgbGlzdCA9IGZ1bmN0aW9uXG4gICAgICB8IEMgKHcsYykgLT4gdzo6KGxpc3QgYylcbiAgICAgIHwgSSBfIC0+IFtdXG4gICAgaW5cbiAgICBsZXQgcmVjIGNlbGwgPSBmdW5jdGlvblxuICAgICAgfCBDIF8gYXMgYyAtPiBcIltcIiBeIFN0cmluZy5jb25jYXQgXCJ8XCIgKExpc3QubWFwIHdoaXNrZXIgKGxpc3QgYykpIF4gXCJdXCJcbiAgICAgIHwgSSBjIC0+IFwiW1wiIF4gY2VsbCBjIF4gXCJdXCJcbiAgICBhbmQgd2hpc2tlciA9IGZ1bmN0aW9uXG4gICAgICB8IEcgZyAtPiBYLnRvX3N0cmluZyBnXG4gICAgICB8IFcgKGMxLHcsYzIpIC0+IGNlbGwgYzEgXiB3aGlza2VyIHcgXiBjZWxsIGMyXG4gICAgaW5cbiAgICBjZWxsIGNcblxuICAoKiogRGltZW5zaW9uIG9mIGEgY2VsbC4gKilcbiAgbGV0IGRpbSBjID1cbiAgICBsZXQgcmVjIGNlbGwgPSBmdW5jdGlvblxuICAgICAgfCBDICh3LF8pIC0+IHdoaXNrZXIgd1xuICAgICAgfCBJIGMgLT4gY2VsbCBjICsgMVxuICAgIGFuZCB3aGlza2VyID0gZnVuY3Rpb25cbiAgICAgIHwgRyBnIC0+IDBcbiAgICAgIHwgVyAoXyx3LF8pIC0+IHdoaXNrZXIgdyArIDFcbiAgICBpblxuICAgIGNlbGwgY1xuXG4gICgqKiBDb21wb3NpdGlvbiBvZiB0d28gY2VsbHMgb24gdGhlIGJvdW5kYXJ5IG9mIG1heGltYWwgZGltZW5zaW9uLiAqKVxuICBsZXQgcmVjIGNvbXBvc2UgYyBkID1cbiAgICBpZiBkaW0gYyA9IGRpbSBkIHRoZW5cbiAgICAgIGxldCByZWMgYXV4ID0gZnVuY3Rpb25cbiAgICAgICAgfCBDICh3LGMpIC0+IEMgKHcsIGF1eCBjKVxuICAgICAgICB8IEkgXyAtPiBkXG4gICAgICBpblxuICAgICAgYXV4IGNcbiAgICBlbHNlIGlmIGRpbSBjID4gZGltIGQgdGhlblxuICAgICAgbGV0IHJlYyBhdXggPSBmdW5jdGlvblxuICAgICAgICB8IEMgKHcsYykgLT5cbiAgICAgICAgICAgbGV0IHcgPVxuICAgICAgICAgICAgIG1hdGNoIHcgd2l0aFxuICAgICAgICAgICAgIHwgVyAoYzEsdyxjMikgLT4gVyAoYzEsdyxjb21wb3NlIGMyIGQpXG4gICAgICAgICAgICAgfCBHIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIGxldCBjID0gYXV4IGMgaW5cbiAgICAgICAgICAgQyAodyxjKVxuICAgICAgICB8IEkgYyAtPiBJIChjb21wb3NlIGMgZClcbiAgICAgIGluXG4gICAgICBhdXggY1xuICAgIGVsc2VcbiAgICAgICgqXG4gICAgICBsZXQgcmVjIGF1eCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgQyAodyxkKSAtPlxuICAgICAgICAgICBsZXQgdyA9XG4gICAgICAgICAgICAgbWF0Y2ggdyB3aXRoXG4gICAgICAgICAgICAgfCBXIChkMSx3LGQyKSAtPiBXXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIGxldCBkID0gYXV4IGQgaW5cbiAgICAgICAgICAgQyAodyxkKVxuICAgICAgICB8IEkgZCAtPiBJIChjb21wb3NlIGMgZClcbiAgICAgIGluXG4gICAgICBhdXggZFxuICAgICAgICopXG4gICAgICBmYWlsd2l0aCBcIlRPRE9cIlxuXG4gICgqKiBQcmVzZW50YXRpb24gb2YgYSBwcmVjYXRlZ29yeTogYSBcInByZS1wb2x5Z3JhcGhcIi4gKilcbiAgbW9kdWxlIFByZXMgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgRSA9IE1hcC5NYWtlKFgpXG5cbiAgICAoKiBCeSBjb252ZW50aW9uLCBhIHplcm8gY2VsbCBoYXMgKHBoeXNpY2FsbHkpIGl0c2VsZiBhcyBzb3VyY2UgYW5kIHRhcmdldC4gKilcbiAgICB0eXBlIHQgPSAoY2VsbCAqIGNlbGwpIEUudFxuXG4gICAgKCoqIEVtcHR5IHNpZ25hdHVyZS4gKilcbiAgICBsZXQgZW1wdHkgPSBFLmVtcHR5XG5cbiAgICAoKiogRG9lcyBhIGdlbmVyYXRvciBiZWxvbmcgdGhlIHNpZ25hdHVyZT8gKilcbiAgICBsZXQgbWVtIHMgZyA9XG4gICAgICBFLm1lbSBnIHNcblxuICAgIGxldCBib3VuZGFyeSBzIGcgPVxuICAgICAgbGV0IHgseSA9IEUuZmluZCBnIHMgaW5cbiAgICAgIGFzc2VydCAoeCAhPSBnICYmIHkgIT0gZyk7XG4gICAgICB4LHlcblxuICAgICgqKiBTb3VyY2Ugb2YgYSBnZW5lcmF0b3IuICopXG4gICAgbGV0IHNvdXJjZSBzIGcgPVxuICAgICAgZnN0IChib3VuZGFyeSBzIGcpXG5cbiAgICAoKiogVGFyZ2V0IG9mIGEgZ2VuZXJhdG9yLiAqKVxuICAgIGxldCB0YXJnZXQgcyBnID1cbiAgICAgIHNuZCAoYm91bmRhcnkgcyBnKVxuXG4gICAgKCoqIE9wZXJhdGlvbnMgb24gY2VsbHMgaW4gYSBwcmVzZW50YXRpb24uICopXG4gICAgbW9kdWxlIENlbGwgPSBzdHJ1Y3RcbiAgICAgICgqKiBFbnN1cmUgdGhhdCBhIGNlbGwgdXNlcyBvbmx5IGdlbmVyYXRvcnMgZGVmaW5lZCBpbiB0aGUgc2lnbmF0dXJlLiAqKVxuICAgICAgbGV0IG1lbSBzIGMgPVxuICAgICAgICBsZXQgcmVjIGNlbGwgPSBmdW5jdGlvblxuICAgICAgICAgIHwgQyAodyxjKSAtPiB3aGlza2VyIHcgJiYgY2VsbCBjXG4gICAgICAgICAgfCBJIGMgLT4gY2VsbCBjXG4gICAgICAgIGFuZCB3aGlza2VyID0gZnVuY3Rpb25cbiAgICAgICAgICB8IFcgKGMxLHcsYzIpIC0+IGNlbGwgYzEgJiYgd2hpc2tlciB3ICYmIGNlbGwgYzJcbiAgICAgICAgICB8IEcgZyAtPiBtZW0gcyBnXG4gICAgICAgIGluXG4gICAgICAgIGNlbGwgY1xuXG4gICAgICAoKiogRGltZW5zaW9uIG9mIGEgY2VsbC4gKilcbiAgICAgIGxldCBkaW0gcyBjID0gZGltIGNcblxuICAgICAgKCogbGV0IHNvdXJjZSBzIGMgPSAqKVxuICAgICAgICAoKiBsZXQgcmVjIGNlbGwgPSBmdW5jdGlvbiAqKVxuICAgICAgICAgICgqIHwgQyAodyxjKSAtPiB3aGlza2VyIHcgKilcbiAgICAgICAgICAoKiB8IEkgYyAtPiBjICopXG4gICAgICAgICgqIGFuZCB3aGlza2VyID0gZnVuY3Rpb24gKilcbiAgICAgICAgICAoKiB8IFcgKGMxLHcsYzIpIC0+ICopXG4gICAgICAgICAgICAgKCogY2VsbCAgKilcbiAgICAgICAgICAoKiB8IEcgZyAtPiAqKVxuICAgICAgICAoKiBpbiAqKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuIiwiKCoqIE1vbm9pZHMuICopXG5cbigqKiBBIG1vbm9pZC4gKilcbm1vZHVsZSB0eXBlIFQgPSBzaWdcbiAgdHlwZSB0XG5cbiAgKCoqIEVxdWFsaXR5LiAqKVxuICB2YWwgZXEgOiB0IC0+IHQgLT4gYm9vbFxuXG4gICgqKiBNdWx0aXBsaWNhdGlvbi4gKilcbiAgdmFsIG11bCA6IHQgLT4gdCAtPiB0XG5cbiAgKCoqIFVuaXQuICopXG4gIHZhbCBvbmUgOiB0XG5cbiAgKCoqIFN0cmluZyByZXByZXNlbnRhdGlvbi4gKilcbiAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG5cbiAgKCoqIENvbXBhcmlzb24uICopXG4gIHZhbCBjb21wYXJlIDogdCAtPiB0IC0+IGludFxuZW5kXG5cbigqKiBBIGNvbW11dGF0aXZlIG1vbm9pZC4gKilcbm1vZHVsZSB0eXBlIEFiZWxpYW4gPSBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIGVxIDogdCAtPiB0IC0+IGJvb2xcblxuICAoKiogQWRkaXRpb24uICopXG4gIHZhbCBhZGQgOiB0IC0+IHQgLT4gdFxuXG4gICgqKiBaZXJvLiAqKVxuICB2YWwgemVybyA6IHRcblxuICAoKiogU3RyaW5nIHJlcHJlc2VudGF0aW9uLiAqKVxuICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbmVuZFxuXG4oKiogVGhlIGZyZWUgbW9ub2lkIG9uIGEgc2V0LiAqKVxubW9kdWxlIEZyZWUgKFggOiBBbHBoYWJldC5UKSA9IHN0cnVjdFxuICB0eXBlIHQgPSBYLnQgYXJyYXlcblxuICB0eXBlIHdvcmQgPSB0XG5cbiAgbGV0IG11bCAodTp0KSAodjp0KSA6IHQgPSBBcnJheS5hcHBlbmQgdSB2XG5cbiAgbGV0IG9uZSA6IHQgPSBbfHxdXG5cbiAgbGV0IGluaiBhIDogdCA9IFt8YXxdXG5cbiAgbGV0IGxlbmd0aCAodTp0KSA9IEFycmF5Lmxlbmd0aCB1XG5cbiAgbGV0IHN1YiAodTp0KSBvIGwgOiB0ID0gQXJyYXkuc3ViIHUgbyBsXG5cbiAgbGV0IGVxIHUgdiA9XG4gICAgbGV0IHVsID0gbGVuZ3RoIHUgaW5cbiAgICBsZXQgdmwgPSBsZW5ndGggdiBpblxuICAgIGlmIHVsIDw+IHZsIHRoZW4gZmFsc2UgZWxzZVxuICAgICAgdHJ5XG4gICAgICAgIGZvciBpID0gMCB0byB1bCAtIDEgZG9cbiAgICAgICAgICBpZiBub3QgKFguZXEgdS4oaSkgdi4oaSkpIHRoZW4gcmFpc2UgRXhpdFxuICAgICAgICBkb25lO1xuICAgICAgICB0cnVlXG4gICAgICB3aXRoXG4gICAgICB8IEV4aXQgLT4gZmFsc2VcblxuICBsZXQgY29tcGFyZSB1IHYgPVxuICAgIGxldCB1bCA9IGxlbmd0aCB1IGluXG4gICAgbGV0IHZsID0gbGVuZ3RoIHYgaW5cbiAgICBsZXQgYW5zID0gcmVmIDAgaW5cbiAgICB0cnlcbiAgICAgIGZvciBpID0gMCB0byBtaW4gdWwgdmwgLSAxIGRvXG4gICAgICAgIGxldCBjID0gWC5jb21wYXJlIHUuKGkpIHYuKGkpIGluXG4gICAgICAgIGlmIGMgPD4gMCB0aGVuIChhbnMgOj0gYzsgcmFpc2UgRXhpdClcbiAgICAgIGRvbmU7XG4gICAgICB1bCAtIHZsXG4gICAgd2l0aFxuICAgIHwgRXhpdCAtPiAhYW5zXG5cbiAgKCoqIFBhcnRpYWwgZXF1YWxpdHkgKGVxdWFsaXR5IG9uIHN1YndvcmRzKS4gKilcbiAgbGV0IHBlcSAodTp0KSB1b2ZmICh2OnQpIHZvZmYgbGVuID1cbiAgICB0cnlcbiAgICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIGlmIG5vdCAoWC5lcSB1Lih1b2ZmICsgaSkgdi4odm9mZiArIGkpKSB0aGVuIHJhaXNlIEV4aXRcbiAgICAgIGRvbmU7XG4gICAgICB0cnVlXG4gICAgd2l0aFxuICAgIHwgRXhpdCAtPiBmYWxzZVxuXG4gIGxldCB0b19zdHJpbmcgKHU6dCkgPVxuICAgIGlmIGVxIG9uZSB1IHRoZW4gXCLOtVwiIGVsc2VcbiAgICBsZXQgdSA9IEFycmF5LnRvX2xpc3QgdSBpblxuICAgIGxldCB1ID0gTGlzdC5tYXAgWC50b19zdHJpbmcgdSBpblxuICAgIFN0cmluZy5jb25jYXQgXCJcIiB1XG5cbiAgbGV0IGluY2x1ZGVkIHUgdiA9XG4gICAgbGV0IHVsID0gbGVuZ3RoIHUgaW5cbiAgICBsZXQgdmwgPSBsZW5ndGggdiBpblxuICAgIHRyeVxuICAgICAgZm9yIGkgPSAwIHRvIHZsIC0gdWwgZG9cbiAgICAgICAgaWYgcGVxIHUgMCB2IGkgdWwgdGhlbiByYWlzZSBFeGl0XG4gICAgICBkb25lO1xuICAgIGZhbHNlXG4gICAgd2l0aFxuICAgIHwgRXhpdCAtPiB0cnVlXG5cbiAgKCoqIFRoZSBsZWZ0bW9zdCB1bmlmaWVyIHdoZXJlIFt1XSBpcyBvbiB0aGUgbGVmdCBhbmQgW3ZdIG9uIHRoZSByaWdodCAqKVxuICBsZXQgdW5pZmllciA/KGk9MCkgdSB2ID1cbiAgICBsZXQgdWwgPSBsZW5ndGggdSBpblxuICAgIGxldCB2bCA9IGxlbmd0aCB2IGluXG4gICAgbGV0IGFucyA9IHJlZiBOb25lIGluXG4gICAgdHJ5XG4gICAgICBmb3IgaSA9IGkgdG8gdWwgLSAxIGRvXG4gICAgICAgIGlmIHBlcSB1IGkgdiAwIChtaW4gKHVsLWkpIHZsKSB0aGVuXG4gICAgICAgICAgKFxuICAgICAgICAgICAgYW5zIDo9IFNvbWUgaTtcbiAgICAgICAgICAgIHJhaXNlIEV4aXRcbiAgICAgICAgICApXG4gICAgICBkb25lO1xuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgd2l0aFxuICAgIHwgRXhpdCAtPiAobWF0Y2ggIWFucyB3aXRoIFNvbWUgYW5zIC0+IGFucyB8IE5vbmUgLT4gYXNzZXJ0IGZhbHNlKVxuXG4gICgqKiBBbGwgdW5pZmllcnMgd2l0aCBmaXJzdCBvbiB0aGUgbGVmdC4gKilcbiAgbGV0IG9yZGVyZWRfdW5pZmllcnMgdSB2ID1cbiAgICBsZXQgYW5zID0gcmVmIFtdIGluXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIHRyeVxuICAgICAgd2hpbGUgdHJ1ZSBkb1xuICAgICAgICBsZXQgaiA9IHVuaWZpZXIgfmk6IWkgdSB2IGluXG4gICAgICAgIGFucyA6PSBqIDo6ICFhbnM7XG4gICAgICAgIGkgOj0gaisxXG4gICAgICBkb25lO1xuICAgICAgYXNzZXJ0IGZhbHNlXG4gICAgd2l0aFxuICAgIHwgTm90X2ZvdW5kIC0+ICFhbnNcblxuICBsZXQgb3JkZXJlZF91bmlmaWVyc19iaWNvbnRleHQgdSB2ID1cbiAgICBsZXQgbHUgPSBsZW5ndGggdSBpblxuICAgIGxldCBsdiA9IGxlbmd0aCB2IGluXG4gICAgbGV0IGwgPSBvcmRlcmVkX3VuaWZpZXJzIHUgdiBpblxuICAgIExpc3QubWFwIChmdW4gaSAtPlxuICAgICAgaWYgaSArIGx2IDw9IGx1IHRoZW5cbiAgICAgICAgKG9uZSwgb25lKSxcbiAgICAgICAgKHN1YiB1IDAgaSwgc3ViIHUgKGkgKyBsdikgKGx1IC0gKGkgKyBsdikpKVxuICAgICAgZWxzZVxuICAgICAgICAob25lLCBzdWIgdiAobHUgLSBpKSAobHYgLSAobHUgLSBpKSkpLFxuICAgICAgICAoc3ViIHUgMCBpLCBvbmUpXG4gICAgKSBsXG5cbiAgKCoqIEFsbCB1bmlmaWVycywgd2l0aCBjb250ZXh0cyBvbiB0aGUgbGVmdCBhbmQgb24gdGhlIHJpZ2h0LiAqKVxuICBsZXQgdW5pZmllcnNfYmljb250ZXh0IHUgdiA9XG4gICAgbGV0IGwgPSBvcmRlcmVkX3VuaWZpZXJzX2JpY29udGV4dCB1IHYgaW5cbiAgICBsZXQgbCcgPSBvcmRlcmVkX3VuaWZpZXJzX2JpY29udGV4dCB2IHUgaW5cbiAgICBsZXQgbCcgPSBMaXN0Lm1hcCAoZnVuIChjLGQpIC0+IGQsYykgbCcgaW5cbiAgICBsQGwnXG5cbiAgbW9kdWxlIE9yZGVyID0gc3RydWN0XG4gICAgbGV0IGxleGljb2dyYXBoaWMgbGVxIHUgdiA9XG4gICAgICBsZXQgdWwgPSBsZW5ndGggdSBpblxuICAgICAgbGV0IHZsID0gbGVuZ3RoIHYgaW5cbiAgICAgIGxldCBhbnMgPSByZWYgdHJ1ZSBpblxuICAgICAgdHJ5XG4gICAgICAgIGZvciBpID0gMCB0byBtaW4gdWwgdmwgLSAxIGRvXG4gICAgICAgICAgaWYgbGVxIHUuKGkpIHYuKGkpIHRoZW5cbiAgICAgICAgICAgIChpZiBub3QgKFguZXEgdS4oaSkgdi4oaSkpIHRoZW4gcmFpc2UgRXhpdClcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAoYW5zIDo9IGZhbHNlOyByYWlzZSBFeGl0KVxuICAgICAgICBkb25lO1xuICAgICAgICB1bCA8PSB2bFxuICAgICAgd2l0aFxuICAgICAgfCBFeGl0IC0+ICFhbnNcblxuICAgIGxldCBkZWdsZXggbGVxIHUgdiA9XG4gICAgICBsZXQgdWwgPSBsZW5ndGggdSBpblxuICAgICAgbGV0IHZsID0gbGVuZ3RoIHYgaW5cbiAgICAgIGlmIHVsIDwgdmwgdGhlbiB0cnVlXG4gICAgICBlbHNlIGlmIHVsID4gdmwgdGhlbiBmYWxzZVxuICAgICAgZWxzZSBsZXhpY29ncmFwaGljIGxlcSB1IHZcbiAgZW5kXG5cbiAgKCoqIEFuaWNrIGNoYWlucy4gKilcbiAgbW9kdWxlIEFuaWNrID0gc3RydWN0XG4gICAgKCoqIEFuIEFuaWNrIGNoYWluLiAqKVxuICAgIHR5cGUgdCA9IHdvcmQgbGlzdFxuXG4gICAgKCoqIFRoZSBlbXB0eSBjaGFpbi4gKilcbiAgICBsZXQgZW1wdHkgOiB0ID0gW11cblxuICAgICgqKiBUaGUgc2luZ2xldG9uIGNoYWluLiAqKVxuICAgIGxldCBzaW5nbGV0b24gYSA6IHQgPSBbaW5qIGFdXG5cbiAgICAoKiogU2luZ2xldG9uIGNoYWlucy4gKilcbiAgICBsZXQgc2luZ2xldG9ucyBsID0gTGlzdC5tYXAgc2luZ2xldG9uIGxcblxuICAgICgqKiBIZWFkIG9mIHRoZSBjaGFpbi4gKilcbiAgICBsZXQgaGQgKGw6dCkgOiB3b3JkID0gTGlzdC5oZCBsXG5cbiAgICAoKiogVGFpbCBvZiB0aGUgY2hhaW4uICopXG4gICAgbGV0IHRsIChsOnQpIDogdCA9IExpc3QudGwgbFxuXG4gICAgbGV0IHdlcSA9IGVxXG5cbiAgICBsZXQgZXEgYyBkID1cbiAgICAgIGxldCB3ZXEgPSBlcSBpblxuICAgICAgbGV0IHJlYyBhdXggYyBkID1cbiAgICAgICAgbWF0Y2ggKGMsZCkgd2l0aFxuICAgICAgICB8IHU6OmMsIHY6OmQgLT4gd2VxIHUgdiAmJiBhdXggYyBkXG4gICAgICAgIHwgW10sIFtdIC0+IHRydWVcbiAgICAgICAgfCBbXSwgXyAtPiBmYWxzZVxuICAgICAgICB8IF8sIFtdIC0+IGZhbHNlXG4gICAgICBpblxuICAgICAgYXV4IGMgZFxuXG4gICAgbGV0IGNvbXBhcmUgYyBkID1cbiAgICAgIGxldCB3YyA9IGNvbXBhcmUgaW5cbiAgICAgIGxldCByZWMgYXV4IGMgZCA9XG4gICAgICAgIG1hdGNoIChjLGQpIHdpdGhcbiAgICAgICAgfCB1OjpjLCB2OjpkIC0+XG4gICAgICAgICAgIGxldCBjbXAgPSB3YyB1IHYgaW5cbiAgICAgICAgICAgaWYgY21wID0gMCB0aGVuIGF1eCBjIGQgZWxzZSBjbXBcbiAgICAgICAgfCBbXSwgW10gLT4gMFxuICAgICAgICB8IFtdLCBfIC0+IC0xXG4gICAgICAgIHwgXywgW10gLT4gMVxuICAgICAgaW5cbiAgICAgIGF1eCBjIGRcblxuICAgICgqKiBDb21wdXRlIChuKzEpLWNoYWlucyBmcm9tIG4tY2hhaW5zLiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgdGhlIGxpc3Qgb2ZcbiAgICAgICAgbWluaW1hbCByZWR1Y2libGUgd29yZHMuICopXG4gICAgbGV0IGV4dGVuZCAobDp3b3JkIGxpc3QpIChjOnQpIDogdCBsaXN0ID1cbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCBbfHxdOjpfIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IHU6OmMgLT5cbiAgICAgICAgIGxldCB1bCA9IGxlbmd0aCB1IGluXG4gICAgICAgICBsZXQgYW5zID0gcmVmIFtdIGluXG4gICAgICAgICBsZXQgaXRlcl9jdHggZiBsID1cbiAgICAgICAgICAgbGV0IHJlYyBhdXggaCA9IGZ1bmN0aW9uXG4gICAgICAgICAgICAgfCB4Ojp0IC0+IGYgaCB4IHQ7IGF1eCAoeDo6aCkgdFxuICAgICAgICAgICAgIHwgW10gLT4gKClcbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgYXV4IFtdIGxcbiAgICAgICAgIGluXG4gICAgICAgICBpdGVyX2N0eCAoZnVuIGwxIHYgbDIgLT5cbiAgICAgICAgICAgbGV0IHZsID0gbGVuZ3RoIHYgaW5cbiAgICAgICAgICAgZm9yIGkgPSBtYXggKHVsLXZsKSAwIHRvIHVsIC0gMSBkb1xuICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgaWYgbm90IChwZXEgdSBpIHYgMCAodWwtaSkpIHRoZW4gcmFpc2UgRXhpdDtcbiAgICAgICAgICAgICAgIGxldCBpID0gdWwgLSBpIGluXG4gICAgICAgICAgICAgICBsZXQgdicgPSBzdWIgdiBpICh2bC1pKSBpblxuICAgICAgICAgICAgICAgKCogRW5zdXJlIHRoYXQgdGhlIHN1ZmZpeCBpcyBub3QgcmVkdWNpYmxlIGJ5IGFueSBvdGhlciBydWxlLiAqKVxuICAgICAgICAgICAgICAgbGV0IHcgPSBtdWwgdSB2JyBpblxuICAgICAgICAgICAgICAgbGV0IGYgdSA9IGlmIGluY2x1ZGVkIHUgdyB0aGVuIHJhaXNlIEV4aXQgaW5cbiAgICAgICAgICAgICAgIExpc3QuaXRlciBmIGwxO1xuICAgICAgICAgICAgICAgTGlzdC5pdGVyIGYgbDI7XG4gICAgICAgICAgICAgICAoKiAuLi5vciBieSB0aGUgcnVsZSBpdHNlbGYgKGV4Y2VwdGluZyBhdCBsYXN0IHBvc2l0aW9uKS4gKilcbiAgICAgICAgICAgICAgIGlmIGluY2x1ZGVkIHYgKHN1YiB3IDAgKGxlbmd0aCB3IC0gMSkpIHRoZW4gcmFpc2UgRXhpdDtcbiAgICAgICAgICAgICAgIGFucyA6PSAodic6OnU6OmMpIDo6ICFhbnNcbiAgICAgICAgICAgICB3aXRoXG4gICAgICAgICAgICAgfCBFeGl0IC0+ICgpXG4gICAgICAgICAgIGRvbmU7XG4gICAgICAgICApIGw7XG4gICAgICAgICAhYW5zXG5cbiAgICAoKiogQWRkIGFuIGVsZW1lbnQgdG8gYSBjaGFpbi4gKilcbiAgICBsZXQgZXh0ZW5kIGwgY2MgPSBMaXN0LmNvbmNhdCAoTGlzdC5tYXAgKGV4dGVuZCBsKSBjYylcblxuICAgICgqKiBDb25jYXRlbmF0aW9uIG9mIHRoZSBlbGVtZW50cyBvZiB0aGUgY2hhaW4uICopXG4gICAgbGV0IGV2YWwgKGw6dCkgPSBMaXN0LmZvbGRfbGVmdCBtdWwgb25lIChMaXN0LnJldiBsKVxuXG4gICAgKCoqIERpbWVuc2lvbiBvZiB0aGUgY2hhaW4uICopXG4gICAgbGV0IGxlbmd0aCAobDp0KSA9IExpc3QubGVuZ3RoIGxcbiAgICAgIFxuICAgICgqKiBTdHJpbmcgcmVwcmVzZW50YXRpb24uICopXG4gICAgbGV0IHRvX3N0cmluZyAoYzp0KSA9IFwiW1wiIF4gU3RyaW5nLmNvbmNhdCBcInxcIiAoTGlzdC5tYXAgdG9fc3RyaW5nIChMaXN0LnJldiBjKSkgXiBcIl1cIlxuICBlbmRcbmVuZFxubW9kdWxlIEZyZWVNb25vaWQgKFggOiBBbHBoYWJldC5UKSA6IFQgPSBGcmVlKFgpXG5cbigqKiBPcmllbnRlZCBwcmVzZW50YXRpb24gb2YgYSBtb25vaWQuICopXG5tb2R1bGUgUHJlcyAoWCA6IEFscGhhYmV0LlQpID0gc3RydWN0XG4gIG1vZHVsZSBXID0gRnJlZShYKVxuXG4gIHR5cGUgdCA9XG4gICAge1xuICAgICAgZ2VuZXJhdG9ycyA6IFgudCBsaXN0O1xuICAgICAgcnVsZXMgOiAoVy50ICogVy50KSBsaXN0O1xuICAgIH1cblxuICBsZXQgbWFrZSBnZW5lcmF0b3JzIHJ1bGVzID1cbiAgICB7IGdlbmVyYXRvcnM7IHJ1bGVzIH1cblxuICAoKiogT3JpZW50IHJ1bGVzIGFjY29yZGluZyB0byBhIHBhcnRpYWwgb3JkZXIuICopXG4gIGxldCBvcmllbnQgbGVxIHByZXMgPVxuICAgIGxldCBydWxlcyA9IExpc3QubWFwIChmdW4gKHUsdikgLT4gaWYgbGVxIHYgdSB0aGVuIHUsdiBlbHNlIHYsdSkgcHJlcy5ydWxlcyBpblxuICAgIHsgcHJlcyB3aXRoIHJ1bGVzIH1cblxuICAoKiogTm9ybWFsaXplIGEgd29yZC4gKilcbiAgbGV0IHJlYyBub3JtYWxpemUgcHJlcyB1ID1cbiAgICB0cnlcbiAgICAgIGxldCB2LHYnID0gTGlzdC5maW5kIChmdW4gKHYsXykgLT4gVy5pbmNsdWRlZCB2IHUpIHByZXMucnVsZXMgaW5cbiAgICAgIGxldCBpID0gVy51bmlmaWVyIHUgdiBpblxuICAgICAgbGV0IHYxID0gVy5zdWIgdSAwIGkgaW5cbiAgICAgIGxldCB2MiA9IFcuc3ViIHUgKGkgKyBXLmxlbmd0aCB2KSAoVy5sZW5ndGggdSAtIChpICsgVy5sZW5ndGggdikpIGluXG4gICAgICBub3JtYWxpemUgcHJlcyAoVy5tdWwgdjEgKFcubXVsIHYgdjIpKVxuICAgIHdpdGhcbiAgICB8IE5vdF9mb3VuZCAtPiB1XG5cbiAgbGV0IGFkZF9ydWxlIHByZXMgKHUsdikgPVxuICAgIHsgcHJlcyB3aXRoIHJ1bGVzID0gKHUsdik6OnByZXMucnVsZXMgfVxuXG4gICgqKiBSZWR1Y2UgYSBwcmVzZW50YXRpb24uICopXG4gIGxldCByZWR1Y2UgcHJlcyA9XG4gICAgbGV0IHJ1bGVzID0gTGlzdC5tYXAgKGZ1biAodSx2KSAtPiB1LCBub3JtYWxpemUgcHJlcyB2KSBwcmVzLnJ1bGVzIGluXG4gICAgbGV0IHJlYyBhdXggaCA9IGZ1bmN0aW9uXG4gICAgICB8ICh1LHYpOjp0IC0+XG4gICAgICAgICBsZXQgZiBsID0gTGlzdC5leGlzdHMgKGZ1biAodScsdicpIC0+IFcuaW5jbHVkZWQgdScgdSkgbCBpblxuICAgICAgICAgaWYgZiBoIHx8IGYgdCB0aGVuIGF1eCBoIHQgZWxzZSBhdXggKCh1LHYpOjpoKSB0XG4gICAgICB8IFtdIC0+IExpc3QucmV2IGhcbiAgICBpblxuICAgIGxldCBydWxlcyA9IGF1eCBbXSBydWxlcyBpblxuICAgIHsgcHJlcyB3aXRoIHJ1bGVzIH1cblxuICAoKiogS251dGgtQmVuZGl4IGNvbXBsZXRpb24gd3J0IGEgdG90YWwgb3JkZXIuICopXG4gIGxldCBjb21wbGV0ZSBsZXEgcHJlcyA9XG4gICAgbGV0IHByZXMgPSBvcmllbnQgbGVxIHByZXMgaW5cbiAgICBsZXQgcHJlcyA9IHJlZHVjZSBwcmVzIGluXG4gICAgbGV0IHRvZG8gPSBRdWV1ZS5jcmVhdGUgKCkgaW5cbiAgICBMaXN0Lml0ZXIgKGZ1biByIC0+IFF1ZXVlLmFkZCByIHRvZG8pIHByZXMucnVsZXM7XG4gICAgbGV0IHByZXMgPSByZWYgcHJlcyBpblxuICAgICgqIEFkZCBhIHJlbGF0aW9uICopXG4gICAgbGV0IHJlbCAodSx2KSA9XG4gICAgICAoKiBQcmludGYucHJpbnRmIFwicmVsOiAlc1xcbiUhXCIgKEEudG9fc3RyaW5nIHApOyAqKVxuICAgICAgbGV0IHUsdiA9IGlmIGxlcSB2IHUgdGhlbiB1LHYgZWxzZSB2LHUgaW5cbiAgICAgIHByZXMgOj0gYWRkX3J1bGUgIXByZXMgKHUsdik7XG4gICAgICBRdWV1ZS5wdXNoICh1LHYpIHRvZG9cbiAgICBpblxuICAgIHdoaWxlIG5vdCAoUXVldWUuaXNfZW1wdHkgdG9kbykgZG9cbiAgICAgIGxldCB1LHUnID0gUXVldWUucG9wIHRvZG8gaW5cbiAgICAgIExpc3QuaXRlciAoZnVuICh2LHYnKSAtPlxuICAgICAgICAgIExpc3QuaXRlciAoZnVuICgodTEsdTIpLCh2MSx2MikpIC0+XG4gICAgICAgICAgICAgIGxldCBzMSA9IFcubXVsIHUxIChXLm11bCB1JyB1MikgaW5cbiAgICAgICAgICAgICAgbGV0IHMyID0gVy5tdWwgdjEgKFcubXVsIHYnIHYyKSBpblxuICAgICAgICAgICAgICByZWwgKHMxLHMyKVxuICAgICAgICAgICAgKSAoVy51bmlmaWVyc19iaWNvbnRleHQgdSB2KVxuICAgICAgICApICFwcmVzLnJ1bGVzXG4gICAgZG9uZTtcbiAgICAhcHJlc1xuXG4gICgqKiBNYWtlIGEgbW9ub2lkIGZyb20gYSBjb252ZXJnZW50IHByZXNlbnRhdGlvbi4gKilcbiAgbW9kdWxlIE1ha2UgKFAgOiBzaWcgdmFsIHByZXNlbnRhdGlvbiA6IHQgZW5kKSA6IFQgPSBzdHJ1Y3RcbiAgICBsZXQgcCA9IFAucHJlc2VudGF0aW9uXG5cbiAgICBsZXQgbmYgPSBub3JtYWxpemUgcFxuXG4gICAgdHlwZSB0ID0gVy50XG5cbiAgICBsZXQgbXVsID0gVy5tdWxcblxuICAgIGxldCBvbmUgPSBXLm9uZVxuXG4gICAgbGV0IHRvX3N0cmluZyA9IFcudG9fc3RyaW5nXG5cbiAgICBsZXQgY29tcGFyZSB1IHYgPSBXLmNvbXBhcmUgKG5mIHUpIChuZiB2KVxuXG4gICAgbGV0IGVxIHUgdiA9IFcuZXEgKG5mIHUpIChuZiB2KVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgR2VuZXJhdGUgKFggOiBBbHBoYWJldC5UIHdpdGggdHlwZSB0ID0gaW50KSA9IHN0cnVjdFxuICBtb2R1bGUgUHJlcyA9IFByZXMoWClcblxuICBsZXQgaW50c2V0IG4gPVxuICAgIGxldCByZWMgYXV4IGsgPVxuICAgICAgaWYgayA+PSBuIHRoZW4gW10gZWxzZVxuICAgICAgICBrOjooYXV4IChrKzEpKVxuICAgIGluXG4gICAgYXV4IDBcbmVuZFxuXG4oKiogVW5kZXJseWluZyBhbHBoYWJldCBvZiBhIG1vbm9pZC4gKilcbm1vZHVsZSBBbHBoYWJldCAoTSA6IFQpIDogQWxwaGFiZXQuVCA9IHN0cnVjdFxuICBpbmNsdWRlIE1cbmVuZFxuIiwiKCoqIE1hdHJpY2VzLiAqKVxuXG4oKiogTWF0cmljZXMgb3ZlciBhIHJpbmcuICopXG5tb2R1bGUgTWFrZSAoUjpSaW5nLlQpID0gc3RydWN0XG4gICgqKiBBIG1hdHJpeC4gKilcbiAgdHlwZSB0ID0gUi50IGFycmF5IGFycmF5XG5cbiAgdHlwZSBtYXRyaXggPSB0XG5cbiAgKCoqIFplcm8gbWF0cml4LiAqKVxuICBsZXQgemVybyByIGMgOiB0ID0gQXJyYXkuaW5pdCByIChmdW4gXyAtPiBBcnJheS5tYWtlIGMgUi56ZXJvKVxuXG4gICgqKiBJbml0aWFsaXplIGEgbWF0cml4LiAqKVxuICBsZXQgaW5pdCByIGMgZiA6IHQgPVxuICAgIEFycmF5LmluaXQgciAoZnVuIGkgLT4gQXJyYXkuaW5pdCBjIChmdW4gaiAtPiBmIGkgaikpXG5cbiAgKCoqIE51bWJlciBvZiByb3dzLiAqKVxuICBsZXQgcm93cyAobSA6IHQpID0gQXJyYXkubGVuZ3RoIG1cblxuICAoKiogTnVtYmVyIG9mIGNvbHVtbnMuICopXG4gIGxldCBjb2xzIChtIDogdCkgPSBBcnJheS5sZW5ndGggbS4oMClcblxuICAoKiogQ29lZmZpY2llbnQuICopXG4gIGxldCBnZXQgKG06dCkgaSBqID0gbS4oaSkuKGopXG5cbiAgKCoqIFN0cmluZyByZXByZXNlbnRhdGlvbi4gKilcbiAgbGV0IHRvX3N0cmluZyBtID1cbiAgICBsZXQgYW5zID0gcmVmIFwiXCIgaW5cbiAgICBmb3IgaSA9IDAgdG8gcm93cyBtIC0gMSBkb1xuICAgICAgZm9yIGogPSAwIHRvIGNvbHMgbSAtIDEgZG9cbiAgICAgICAgaWYgaiA8PiAwIHRoZW4gYW5zIDo9ICFhbnMgXiBcIiBcIjtcbiAgICAgICAgYW5zIDo9ICFhbnMgXiBSLnRvX3N0cmluZyBtLihpKS4oailcbiAgICAgIGRvbmU7XG4gICAgICBhbnMgOj0gIWFucyBeIFwiXFxuXCJcbiAgICBkb25lO1xuICAgICFhbnNcblxuICAoKiogT3BlcmF0aW9ucyBvbiByb3dzLiAqKVxuICBtb2R1bGUgUm93ID0gc3RydWN0XG4gICAgKCoqIEEgYSByb3cgbnVsbD8gKilcbiAgICBsZXQgaXNfemVybyBtIGkgPVxuICAgICAgQXJyYXkuZm9yX2FsbCAoUi5lcSBSLnplcm8pIG0uKGkpXG5cbiAgICAoKiogUmVwbGFjZSBhIHJvdyBieSBhbm90aGVyIG9uZS4gKilcbiAgICBsZXQgcmVwbGFjZSBtIGkgbWkgOiB0ID1cbiAgICAgIEFycmF5LmluaXQgKHJvd3MgbSkgKGZ1biBrIC0+IGlmIGsgPSBpIHRoZW4gbWkgZWxzZSBtLihrKSlcblxuICAgICgqKiBFeGNoYW5nZSB0d28gcm93cy4gKilcbiAgICBsZXQgZXhjaGFuZ2UgbSBpIGogOiB0ID1cbiAgICAgIEFycmF5LmluaXQgKHJvd3MgbSkgKGZ1biBrIC0+IGlmIGsgPSBpIHRoZW4gbS4oaikgZWxzZSBpZiBrID0gaiB0aGVuIG0uKGkpIGVsc2UgbS4oaykpXG5cbiAgICAoKiogTXVsdGlwbHkgYSByb3cgYnkgYSBjb2VmZmljZW50LiAqKVxuICAgIGxldCBtdWx0IG0gcSBpID1cbiAgICAgIGFzc2VydCAobm90IChSLmVxIFIuemVybyBxKSk7XG4gICAgICBsZXQgbWkgPSBBcnJheS5pbml0IChjb2xzIG0pIChmdW4gayAtPiBSLm11bCBxIG0uKGkpLihrKSkgaW5cbiAgICAgIHJlcGxhY2UgbSBpIG1pXG5cbiAgICAoKiogQWRkIHRvIGEgcm93IFtxXSB0aW1lcyBhbm90aGVyIHJvdy4gKilcbiAgICBsZXQgbWFkZCBtIGkgcSBqID1cbiAgICAgIGFzc2VydCAoaSA8PiBqKTtcbiAgICAgIGxldCBtaSA9IEFycmF5LmluaXQgKGNvbHMgbSkgKGZ1biBrIC0+IFIuYWRkIG0uKGkpLihrKSAoUi5tdWwgcSBtLihqKS4oaykpKSBpblxuICAgICAgcmVwbGFjZSBtIGkgbWlcbiAgZW5kXG5cbiAgKCoqIFB1dCBhIG1hdHJpeCBpbiByb3cgZWNoZWxvbiBmb3JtLiAqKVxuICBsZXQgcm93X2VjaGVsb24gbSA9XG4gICAgbGV0IG0gPSByZWYgbSBpblxuICAgIGxldCBpcCA9IHJlZiAwIGluXG4gICAgbGV0IGNvbHMgPSBpZiByb3dzICFtID0gMCB0aGVuIDAgZWxzZSBjb2xzICFtIGluXG4gICAgdHJ5XG4gICAgICBmb3IgaiA9IDAgdG8gY29scyAtIDEgZG9cbiAgICAgICAgaWYgIWlwID49IHJvd3MgIW0gdGhlbiByYWlzZSBFeGl0O1xuICAgICAgICBpZiBSLmVxIFIuemVybyAhbS4oIWlwKS4oaikgdGhlblxuICAgICAgICAgIChcbiAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICBmb3IgaSA9ICFpcCArIDEgdG8gcm93cyAhbSAtIDEgZG9cbiAgICAgICAgICAgICAgICBpZiBub3QgKFIuZXEgUi56ZXJvICFtLihpKS4oaikpIHRoZW4gKG0gOj0gUm93LmV4Y2hhbmdlICFtICFpcCBpOyByYWlzZSBFeGl0KVxuICAgICAgICAgICAgICBkb25lXG4gICAgICAgICAgICB3aXRoXG4gICAgICAgICAgICB8IEV4aXQgLT4gKClcbiAgICAgICAgICApO1xuICAgICAgICBsZXQgYSA9ICFtLighaXApLihqKSBpblxuICAgICAgICBpZiBub3QgKFIuZXEgUi56ZXJvIGEpIHRoZW5cbiAgICAgICAgICAoXG4gICAgICAgICAgICBmb3IgaSA9ICFpcCArIDEgdG8gcm93cyAhbSAtIDEgZG9cbiAgICAgICAgICAgICAgbGV0IGIgPSAhbS4oaSkuKGopIGluXG4gICAgICAgICAgICAgIGlmIG5vdCAoUi5lcSBSLnplcm8gYikgdGhlblxuICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgIG0gOj0gUm93Lm11bHQgIW0gKFIubmVnIGEpIGk7XG4gICAgICAgICAgICAgICAgICBtIDo9IFJvdy5tYWRkICFtIGkgYiAhaXBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICBkb25lO1xuICAgICAgICAgICAgaW5jciBpcFxuICAgICAgICAgIClcbiAgICAgIGRvbmU7XG4gICAgICAhbVxuICAgIHdpdGhcbiAgICB8IEV4aXQgLT4gIW1cblxuICAoKiogRGltZW5zaW9uIG9mIHRoZSBpbWFnZS4gKilcbiAgbGV0IHJhbmsgbSA9XG4gICAgbGV0IG0gPSByb3dfZWNoZWxvbiBtIGluXG4gICAgbGV0IG4gPSByZWYgMCBpblxuICAgIHRyeVxuICAgICAgKCpcbiAgICAgIGlmIHJvd3MgbSA9IDAgdGhlbiByYWlzZSBFeGl0OyAoKiBBdm9pZCBhIHByb2JsZW0gd2l0aCB1bmRlZmluZWQgY29scyBiZWxvdy4gKilcbiAgICAgIGZvciBpID0gMCB0byBtaW4gKHJvd3MgbSkgKGNvbHMgbSkgLSAxIGRvXG4gICAgICAgIGlmIFIuZXEgUi56ZXJvIG0uKGkpLihpKSB0aGVuIHJhaXNlIEV4aXQgZWxzZSBpbmNyIG5cbiAgICAgIGRvbmU7XG4gICAgICAqKVxuICAgICAgZm9yIGkgPSAwIHRvIHJvd3MgbSAtIDEgZG9cbiAgICAgICAgaWYgUm93LmlzX3plcm8gbSBpIHRoZW4gcmFpc2UgRXhpdDtcbiAgICAgICAgaW5jciBuXG4gICAgICBkb25lO1xuICAgICAgIW5cbiAgICB3aXRoXG4gICAgfCBFeGl0IC0+ICFuXG5cbiAgKCoqIERpbWVuc2lvbiBvZiB0aGUga2VybmVsLiAqKVxuICBsZXQgbnVsbGl0eSBtID1cbiAgICByb3dzIG0gLSByYW5rIG1cblxuICAoKiogTWF0cmljZXMgd2l0aCBsYWJlbGVkIGJhc2lzIGVsZW1lbnRzLiAqKVxuICBtb2R1bGUgTGFiZWxlZCAoWDpBbHBoYWJldC5UKSA9IHN0cnVjdFxuICAgIG1vZHVsZSBMID0gc3RydWN0XG4gICAgICBpbmNsdWRlIE1hcC5NYWtlKFgpXG5cbiAgICAgIGxldCBmaW5kIDogWC50IC0+ICdhIHQgLT4gJ2EgPSBmaW5kXG5cbiAgICAgIGxldCBpdGVyIDogKFgudCAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXQgPSBpdGVyXG5cbiAgICAgIGxldCBvZl9hcnJheSAoYTpYLnQgYXJyYXkpID1cbiAgICAgICAgbGV0IGFucyA9IHJlZiBlbXB0eSBpblxuICAgICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgICAgYW5zIDo9IGFkZCBhLihpKSBpICFhbnNcbiAgICAgICAgZG9uZTtcbiAgICAgICAgIWFuc1xuICAgIGVuZFxuXG4gICAgdHlwZSBtYXAgPSBpbnQgTC50XG5cbiAgICAoKiogQSBtYXRyaXggd2l0aCBsYWJlbGVkIGJhc2lzIGVsZW1lbnRzLiAqKVxuICAgIHR5cGUgdCA9IG1hcCAqIG1hcCAqIG1hdHJpeFxuXG4gICAgKCoqIFVuZGVybHlpbmcgKG5vbi1sYWJlbGVkKSBtYXRyaXguICopXG4gICAgbGV0IG1hdHJpeCAoKF8sXyxtKTp0KSA9IG1cblxuICAgIGxldCB6ZXJvIHJvd3MgY29scyA6IHQgPVxuICAgICAgbGV0IG0gPSB6ZXJvIChBcnJheS5sZW5ndGggcm93cykgKEFycmF5Lmxlbmd0aCBjb2xzKSBpblxuICAgICAgTC5vZl9hcnJheSByb3dzLCBMLm9mX2FycmF5IGNvbHMsIG1cblxuICAgICgqKiBTZXQgY29lZmZpY2llbnQuICopXG4gICAgbGV0IHNldCAoKHIsYyxtKTp0KSBpIGogeCA9XG4gICAgICBsZXQgaSA9IEwuZmluZCBpIHIgaW5cbiAgICAgIGxldCBqID0gTC5maW5kIGogYyBpblxuICAgICAgbS4oaSkuKGopIDwtIHhcblxuICAgICgqKiBDb2VmZmljaWVudC4gKilcbiAgICBsZXQgZ2V0ICgocixjLG0pOnQpIGkgaiA9XG4gICAgICBsZXQgaSA9IEwuZmluZCBpIHIgaW5cbiAgICAgIGxldCBqID0gTC5maW5kIGogYyBpblxuICAgICAgbS4oaSkuKGopXG5cbiAgICAoKiogUmFuay4gKilcbiAgICBsZXQgcmFuayAoKHIsYyxtKTp0KSA9IHJhbmsgbVxuXG4gICAgbGV0IG51bGxpdHkgKChyLGMsbSk6dCkgPSBudWxsaXR5IG1cblxuICAgICgqKiBJdGVyYXRlIG92ZXIgc291cmNlIGJhc2lzLiAqKVxuICAgIGxldCBpdGVyX3NyYyBmICgocixjLG0pOnQpID1cbiAgICAgIEwuaXRlciAoZnVuIHggXyAtPiBmIHgpIHJcblxuICAgICgqKiBJdGVyYXRlIG92ZXIgdGFyZ2V0IGJhc2lzLiAqKVxuICAgIGxldCBpdGVyX3RndCBmICgocixjLG0pOnQpID1cbiAgICAgIEwuaXRlciAoZnVuIHggXyAtPiBmIHgpIGNcblxuICAgICgqKiBJdGVyYXRlIG92ZXIgc291cmNlIGFuZCB0YXJnZXQgYmFzaXMuICopXG4gICAgbGV0IGl0ZXIgZiAobTp0KSA9XG4gICAgICBpdGVyX3NyYyAoZnVuIHggLT4gaXRlcl90Z3QgKGZ1biB5IC0+IGYgeCB5KSBtKSBtXG4gIGVuZFxuZW5kXG5cbigqKiBGdW5jdG9ycyBiZXR3ZWVuIGRpZmZlcmVudCByaW5ncy4gKilcbm1vZHVsZSBGdW5jdG9yIChSOlJpbmcuVCkgKFInOlJpbmcuVCkgPSBzdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNYWtlKFIpXG4gIG1vZHVsZSBNJyA9IE1ha2UoUicpXG5cbiAgbGV0IG1hcCBmIChtOk0udCkgOiBNJy50ID1cbiAgICBsZXQgciA9IE0ucm93cyBtIGluXG4gICAgbGV0IGMgPSBpZiByID0gMCB0aGVuIDAgZWxzZSBNLmNvbHMgbSBpblxuICAgIE0nLmluaXQgciBjIChmdW4gaSBqIC0+IGYgKE0uZ2V0IG0gaSBqKSlcblxuICBtb2R1bGUgTGFiZWxlZCAoWDpBbHBoYWJldC5UKSAoWCc6QWxwaGFiZXQuVCkgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgTCA9IE0uTGFiZWxlZChYKVxuICAgIG1vZHVsZSBMJyA9IE0nLkxhYmVsZWQoWCcpXG5cbiAgICBsZXQgbWFwIHMgdCBmIChtOkwudCkgOiBMJy50ID1cbiAgICAgIGxldCByLGMsbSA9IG0gaW5cbiAgICAgIGxldCBsbWFwIChmOlgudC0+WCcudCkgKGw6TC5tYXApIDogTCcubWFwID0gTC5MLmZvbGQgKGZ1biB4IGkgbCcgLT4gTCcuTC5hZGQgKGYgeCkgaSBsJykgbCBMJy5MLmVtcHR5IGluXG4gICAgICBsZXQgciA9IGxtYXAgcyByIGluXG4gICAgICBsZXQgYyA9IGxtYXAgdCBjIGluXG4gICAgICBsZXQgbSA9IG1hcCBmIG0gaW5cbiAgICAgIHIsYyxtXG4gIGVuZFxuZW5kXG4iLCIoKiogTW9kdWxlcy4gKilcblxuKCoqIEEgbGVmdCBtb2R1bGUuICopXG5tb2R1bGUgdHlwZSBMZWZ0ID0gc2lnXG4gICgqKiBBbiBlbGVtZW50IG9mIHRoZSBtb2R1bGUuICopXG4gIHR5cGUgdFxuXG4gICgqKiBBbiBlbGVtZW50IG9mIHRoZSByaW5nLiAqKVxuICB0eXBlIHJcblxuICBtb2R1bGUgUmluZyA6IHNpZ1xuICAgIGluY2x1ZGUgUmluZy5UIHdpdGggdHlwZSB0IDo9IHJcbiAgZW5kXG5cbiAgaW5jbHVkZSBHcm91cC5BYmVsaWFuIHdpdGggdHlwZSB0IDo9IHRcblxuICAoKiogTGVmdCBhY3Rpb24gb2YgdGhlIHJpbmcuICopXG4gIHZhbCBjbXVsIDogciAtPiB0IC0+IHRcbmVuZFxuXG4oKiogQSByaWdodCBtb2R1bGUuICopXG5tb2R1bGUgdHlwZSBSaWdodCA9IHNpZ1xuICBpbmNsdWRlIExlZnRcblxuICAoKiogUmlnaHQgYWN0aW9uIG9mIHRoZSByaW5nLiAqKVxuICB2YWwgY211bCA6IHQgLT4gciAtPiB0XG5lbmRcblxuKCpcbigqKiBBIGJpbW9kdWxlLiAqKVxubW9kdWxlIHR5cGUgQmkgPSBzaWdcbiAgaW5jbHVkZSBMZWZ0XG4gIGluY2x1ZGUgUmlnaHRcbmVuZFxuKilcblxuKCoqIEJ5IGRlZmF1bHQsIGJ5IGEgbW9kdWxlLCB3ZSBtZWFuIGEgbGVmdCBtb2R1bGUuICopXG5tb2R1bGUgdHlwZSBUID0gTGVmdFxuXG4oKiogRnJlZSBsZWZ0IG1vZHVsZS4gKilcbm1vZHVsZSBGcmVlTGVmdCAoUiA6IFJpbmcuVCkgKFggOiBBbHBoYWJldC5UKSA9IHN0cnVjdFxuICBtb2R1bGUgUmluZyA9IFJcblxuICBtb2R1bGUgRSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgTWFwLk1ha2UoWClcblxuICAgIGxldCBhZGQgeCBhIHAgPVxuICAgICAgaWYgUi5lcSBSLnplcm8gYSB0aGVuXG4gICAgICAgIHJlbW92ZSB4IHBcbiAgICAgIGVsc2VcbiAgICAgICAgYWRkIHggYSBwXG4gIGVuZFxuXG4gICgqKiBBbiBlbGVtZW50IG9mIHRoZSByaW5nLiAqKVxuICB0eXBlIHIgPSBSLnRcblxuICAoKiogQW4gZWxlbWVudCBvZiB0aGUgbW9kdWxlLiAqKVxuICB0eXBlIHQgPSByIEUudFxuICAoKiB0eXBlIGVsZW1lbnQgPSB0ICopXG5cbiAgbGV0IHplcm8gOiB0ID0gRS5lbXB0eVxuXG4gIGxldCBjaW5qIChhOlIudCkgKHg6WC50KSA6IHQgPSBFLmFkZCB4IGEgemVyb1xuXG4gIGxldCBpbmogeCA9IGNpbmogUi5vbmUgeFxuXG4gICgqKiBDb2VmZmljaWVudCBvZiBhbiBlbGVtZW50LiAqKVxuICBsZXQgY29lZmYgKHA6dCkgKHg6WC50KSA9XG4gICAgdHJ5XG4gICAgICBFLmZpbmQgeCBwXG4gICAgd2l0aFxuICAgIHwgTm90X2ZvdW5kIC0+IFIuemVyb1xuXG4gIGxldCBpbmNsdWRlZCB4IHkgPVxuICAgIEUuZm9yX2FsbCAoZnVuIHUgYSAtPiBjb2VmZiB5IHUgPSBhKSAoeDp0KVxuXG4gIGxldCBlcSB4IHkgPVxuICAgIGluY2x1ZGVkIHggeSAmJiBpbmNsdWRlZCB5IHhcblxuICBsZXQgYWRkX21vbm9taWFsIChwOnQpIChhOnIpICh4OlgudCkgOiB0ID1cbiAgICBsZXQgYSA9IFIuYWRkIGEgKGNvZWZmIHAgeCkgaW5cbiAgICBFLmFkZCB4IGEgcFxuXG4gIGxldCBhZGQgKHA6dCkgKHE6dCkgOiB0ID1cbiAgICBFLmZvbGQgKGZ1biB4IGEgcCAtPiBhZGRfbW9ub21pYWwgcCBhIHgpIHEgcFxuXG4gIGxldCBjbXVsIGEgKHg6dCkgOiB0ID1cbiAgICBFLm1hcCAoUi5tdWwgYSkgeFxuXG4gIGxldCBuZWcgKHg6dCkgPVxuICAgIGNtdWwgKFIubmVnIFIub25lKSB4XG5cbiAgbGV0IHN1YiB4IHkgPVxuICAgIGFkZCB4IChuZWcgeSlcblxuICBsZXQgdG9fc3RyaW5nICh4OnQpID1cbiAgICBpZiBlcSB6ZXJvIHggdGhlbiBcIjBcIiBlbHNlXG4gICAgbGV0IGFucyA9IHJlZiBcIlwiIGluXG4gICAgRS5pdGVyIChmdW4gdSBhIC0+XG4gICAgICBpZiAhYW5zIDw+IFwiXCIgdGhlbiBhbnMgOj0gIWFucyBeIFwiK1wiO1xuICAgICAgbGV0IGEgPVxuICAgICAgICBpZiBSLmVxIGEgUi5vbmUgdGhlbiBcIlwiIGVsc2VcbiAgICAgICAgICBcIihcIiBeIFIudG9fc3RyaW5nIGEgXiBcIilcIiBeIFwiKlwiXG4gICAgICBpblxuICAgICAgYW5zIDo9ICFhbnMgXiBhIF4gWC50b19zdHJpbmcgdVxuICAgICkgeDtcbiAgICAhYW5zXG5cbiAgKCoqIE1hcCBhIGxpbmVhciBmdW5jdGlvbi4gKilcbiAgbGV0IG1hcCBmIChwOnQpID1cbiAgICBFLmZvbGQgKGZ1biAoeDpYLnQpIGEgcSAtPiBhZGQgcSAoY211bCBhIChmIHgpKSkgcCB6ZXJvXG5cbiAgbGV0IGl0ZXIgZiBwID1cbiAgICBFLml0ZXIgKGZ1biAoeDpYLnQpIChhOlIudCkgLT4gZiBhIHgpIHBcblxuICAoKiogTW9ycGhpc21zIGJldHdlZW4gZnJlZSBtb2R1bGVzLiAqKVxuICBtb2R1bGUgTWFwID0gc3RydWN0XG4gICAgbW9kdWxlIEUgPSBNYXAuTWFrZShYKVxuXG4gICAgdHlwZSBtYXAgPSB0IEUudFxuXG4gICAgbGV0IHNldCAoZjptYXApICh4OlgudCkgKHA6dCkgOiBtYXAgPVxuICAgICAgRS5hZGQgeCBwIGZcblxuICAgIGxldCBhcHAgKGY6bWFwKSAoeDpYLnQpID1cbiAgICAgIHRyeVxuICAgICAgICBFLmZpbmQgeCBmXG4gICAgICB3aXRoXG4gICAgICB8IE5vdF9mb3VuZCAtPiB6ZXJvXG5cbiAgICBsZXQgYmluZCBmIChwOnQpID1cbiAgICAgIEUuZm9sZCAoZnVuICh4OlgudCkgYSBxIC0+IGFkZCBxIChjbXVsIGEgKGFwcCBmIHgpKSkgcCB6ZXJvXG5cbiAgICBsZXQgemVybyA6IG1hcCA9IEUuZW1wdHlcblxuICAgIGxldCB0b19zdHJpbmcgKGY6bWFwKSA9XG4gICAgICBFLmZvbGQgKGZ1biAoeDpYLnQpIChwOnQpIHMgLT4gcyBeIChYLnRvX3N0cmluZyB4KSBeIFwiIC0+IFwiIF4gKHRvX3N0cmluZyBwKSBeIFwiXFxuXCIpIGYgXCJcIlxuXG4gICAgdHlwZSB0ID0gbWFwXG4gIGVuZFxuXG4gICgqKiBBIHByZXNlbnRhdGlvbiBvZiBhIGZyZWUgbW9kdWxlIChhIGJhc2lzKS4gKilcbiAgbW9kdWxlIFByZXMgPSBzdHJ1Y3RcbiAgICAoKiogQSBwcmVzZW50YXRpb24uICopXG4gICAgdHlwZSBwcmVzID0gWC50IGFycmF5XG5cbiAgICB0eXBlIHQgPSBwcmVzXG5cbiAgICAoKiogQ3JlYXRlIGEgcHJlc2VudGF0aW9uLiAqKVxuICAgIGxldCBtYWtlIGdlbiA9IChnZW4gOiB0KVxuXG4gICAgKCoqIERpbWVuc2lvbiBvZiBhIHByZXNlbnRhdGlvbi4gKilcbiAgICBsZXQgZGltIChwcmVzIDogdCkgPSBBcnJheS5sZW5ndGggcHJlc1xuXG4gICAgbGV0IHByZXNlbnRhdGlvbl90b19zdHJpbmcgcHJlcyA9XG4gICAgICBsZXQgYW5zID0gcmVmIFwiXCIgaW5cbiAgICAgIEFycmF5Lml0ZXIgKGZ1biB4IC0+XG4gICAgICAgIGFucyA6PSAhYW5zIF4gKGlmICFhbnMgPSBcIlwiIHRoZW4gXCJcIiBlbHNlIFwiIFwiKSBeIFgudG9fc3RyaW5nIHhcbiAgICAgICkgcHJlcztcbiAgICAgICFhbnNcblxuICAgICgqKiBMaW5lYXIgbWFwcyBiZXR3ZWVuIHByZXNlbnRhdGlvbnMuICopXG4gICAgbW9kdWxlIE1hcCA9IHN0cnVjdFxuICAgICAgbW9kdWxlIE0gPSBNYXRyaXguTWFrZShSKVxuICAgICAgbW9kdWxlIEwgPSBNLkxhYmVsZWQoWClcblxuICAgICAgKCoqIEEgbGluZWFyIG1hcCAoZW5jb2RlZCBhcyBhIG1hdHJpeCkuICopXG4gICAgICB0eXBlIG1hcCA9IEwudFxuICAgICAgdHlwZSB0ID0gbWFwXG5cbiAgICAgICgqKiBBcHBseSBhIG1vcnBoaXNtIHRvIGFuIGVsZW1lbnQuICopXG4gICAgICBsZXQgYXBwIChmOnQpIHAgPVxuICAgICAgICBtYXAgKGZ1biB4IC0+XG4gICAgICAgICAgbGV0IGFucyA9IHJlZiB6ZXJvIGluXG4gICAgICAgICAgTC5pdGVyX3RndCAoZnVuIHkgLT5cbiAgICAgICAgICAgIGFucyA6PSBhZGQgIWFucyAoY2luaiAoTC5nZXQgZiB4IHkpIHkpXG4gICAgICAgICAgKSBmO1xuICAgICAgICAgICFhbnNcbiAgICAgICAgKSBwXG4gICAgICAgIFxuICAgICAgKCoqIFRoZSB6ZXJvIG1vcnBoaXNtLiAqKVxuICAgICAgbGV0IHplcm8gc3JjIHRndCA6IHQgPSBMLnplcm8gc3JjIHRndFxuXG4gICAgICAoKiogQ3JlYXRlIGZyb20gYSBtYXAgd2l0aCBnaXZlbiBzb3VyY2UgYW5kIHRhcmdldC4gKilcbiAgICAgIGxldCBvZl9tYXAgZiBzcmMgdGd0ID1cbiAgICAgICAgbGV0IGFucyA9IHplcm8gc3JjIHRndCBpblxuICAgICAgICBBcnJheS5pdGVyIChmdW4geCAtPlxuICAgICAgICAgIGxldCBwID0gTWFwLmFwcCBmIHggaW5cbiAgICAgICAgICBpdGVyIChmdW4gYSB5IC0+IEwuc2V0IGFucyB4IHkgKFIuYWRkIChMLmdldCBhbnMgeCB5KSBhKSkgcFxuICAgICAgICApIHNyYztcbiAgICAgICAgYW5zXG5cbiAgICAgICgqKiBDb252ZXJ0IHRvIGEgbWFwLiAqKVxuICAgICAgbGV0IHRvX21hcCAoZjp0KSA9XG4gICAgICAgIGxldCBhbnMgPSByZWYgTWFwLnplcm8gaW5cbiAgICAgICAgTC5pdGVyIChmdW4geCB5IC0+XG4gICAgICAgICAgYW5zIDo9IE1hcC5zZXQgIWFucyB4IChhZGQgKE1hcC5hcHAgIWFucyB4KSAoY2luaiAoTC5nZXQgZiB4IHkpIHkpKVxuICAgICAgICApIGY7XG4gICAgICAgICFhbnNcblxuICAgICAgKCoqIFJhbmsgb2YgYSBtYXAuICopXG4gICAgICBsZXQgcmFuayA6IHQgLT4gaW50ID0gTC5yYW5rXG5cbiAgICAgICgqKiBOdWxsaXR5IG9mIGEgbWFwLiAqKVxuICAgICAgbGV0IG51bGxpdHkgOiB0IC0+IGludCA9IEwubnVsbGl0eVxuXG4gICAgICAoKiBUT0RPOiBpbXByb3ZlIHRoaXMgKilcbiAgICAgIGxldCB0b19zdHJpbmcgZiA9XG4gICAgICAgIE1hcC50b19zdHJpbmcgKHRvX21hcCBmKVxuICAgIGVuZFxuXG4gICAgKCoqIEl0ZXJhdGUgYSBmdW5jdGlvbiBvbiB0aGUgZ2VuZXJhdG9ycyBvZiBhIG1vZHVsZS4gKilcbiAgICBsZXQgaXRlciBmIChwcmVzOnQpID0gQXJyYXkuaXRlciBmIHByZXNcblxuICAgICgqKiBDaGFpbiBjb21wbGV4ZXMgYmV0d2VlbiBmcmVlIG1vZHVsZXMuICopXG4gICAgbW9kdWxlIENvbXBsZXggPSBzdHJ1Y3RcbiAgICAgICgqKiBBIGNoYWluIGNvbXBsZXguICopXG4gICAgICB0eXBlIHQgPVxuICAgICAgICB7XG4gICAgICAgICAgbW9kdWxlcyA6IHByZXMgYXJyYXk7XG4gICAgICAgICAgZCA6IE1hcC50IGFycmF5XG4gICAgICAgIH1cblxuICAgICAgbGV0IG1vZHVsZXMgYyA9IGMubW9kdWxlc1xuXG4gICAgICBsZXQgbWFwcyBjID0gYy5kXG5cbiAgICAgICgqKiBMZW5ndGggb2YgYSBjaGFpbiBjb21wbGV4LiAqKVxuICAgICAgbGV0IGxlbmd0aCBjID0gQXJyYXkubGVuZ3RoIGMuZFxuXG4gICAgICAoKiogQ3JlYXRlIGEgY2hhaW4gY29tcGxleC4gKilcbiAgICAgIGxldCBtYWtlIG1vZHVsZXMgZCA9XG4gICAgICAgIGFzc2VydCAoQXJyYXkubGVuZ3RoIG1vZHVsZXMgPSBBcnJheS5sZW5ndGggZCArIDEpO1xuICAgICAgICB7IG1vZHVsZXM7IGQgfVxuXG4gICAgICAoKiogRW5zdXJlIHRoYXQgYSBjaGFpbiBjb21wbGV4IHNhdHNpZmllcyBkXjI9MC4gKilcbiAgICAgIGxldCB2YWxpZCBjID1cbiAgICAgICAgdHJ5XG4gICAgICAgICAgZm9yIGkgPSAxIHRvIGxlbmd0aCBjIC0gMSBkb1xuICAgICAgICAgICAgaXRlciAoZnVuIHggLT5cbiAgICAgICAgICAgICAgbGV0IHkgPSBNYXAuYXBwIGMuZC4oaS0xKSAoTWFwLmFwcCBjLmQuKGkpIChpbmogeCkpIGluXG4gICAgICAgICAgICAgIGlmIG5vdCAoZXEgemVybyB5KSB0aGVuXG4gICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgUHJpbnRmLnByaW50ZiBcImludmFsaWQ6ICVkXFxuJSFcIiBpO1xuICAgICAgICAgICAgICAgICAgUHJpbnRmLnByaW50ZiBcImQoJXMpID0gJXNcXG4lIVwiIChYLnRvX3N0cmluZyB4KSAodG9fc3RyaW5nIChNYXAuYXBwIGMuZC4oaSkgKGluaiB4KSkpO1xuICAgICAgICAgICAgICAgICAgUHJpbnRmLnByaW50ZiBcImReMiglcykgPSAlc1xcbiUhXCIgKFgudG9fc3RyaW5nIHgpICh0b19zdHJpbmcgKE1hcC5hcHAgYy5kLihpLTEpIChNYXAuYXBwIGMuZC4oaSkgKGluaiB4KSkpKTtcbiAgICAgICAgICAgICAgICAgIHJhaXNlIEV4aXRcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIGMubW9kdWxlcy4oaSsxKVxuICAgICAgICAgIGRvbmU7XG4gICAgICAgICAgdHJ1ZVxuICAgICAgICB3aXRoXG4gICAgICAgIHwgRXhpdCAtPiBmYWxzZVxuXG4gICAgICAoKiogU3RyaW5nIHJlcHJlc2VudGF0aW9uLiAqKVxuICAgICAgbGV0IHRvX3N0cmluZyBjID1cbiAgICAgICAgbGV0IGFucyA9IHJlZiBcIlwiIGluXG4gICAgICAgICgqIGFucyA6PSAhYW5zIF4gXCJDXCIgXiBzdHJpbmdfb2ZfaW50IChsZW5ndGggYykgXiBcIjogXCIgXiBwcmVzZW50YXRpb25fdG9fc3RyaW5nIGMubW9kdWxlcy4obGVuZ3RoIGMpIF4gXCJcXG5cXG5cIjsgKilcbiAgICAgICAgZm9yIGkgPSBsZW5ndGggYyAtIDEgZG93bnRvIDAgZG9cbiAgICAgICAgICBhbnMgOj0gIWFucyBeIFwiZFwiIF4gc3RyaW5nX29mX2ludCBpIF4gXCI6XFxuXCIgXiBNYXAudG9fc3RyaW5nIGMuZC4oaSkgXiBcIlxcblwiO1xuICAgICAgICAgICgqIGFucyA6PSAhYW5zIF4gXCJDXCIgXiBzdHJpbmdfb2ZfaW50IGkgXiBcIjogXCIgXiBwcmVzZW50YXRpb25fdG9fc3RyaW5nIGMubW9kdWxlcy4oaSkgXiBcIlxcblxcblwiICopXG4gICAgICAgIGRvbmU7XG4gICAgICAgICFhbnNcblxuICAgICAgKCoqIENvbXB1dGUgYmV0dGkgbnVtYmVycyBmb3IgdGhlIGNvbXBsZXguICopXG4gICAgICBsZXQgYmV0dGkgYyA9XG4gICAgICAgIEFycmF5LmluaXQgKGxlbmd0aCBjKSAoZnVuIGkgLT5cbiAgICAgICAgICBsZXQga2VyID0gaWYgaSA9IDAgdGhlbiBkaW0gYy5tb2R1bGVzLigwKSBlbHNlIE1hcC5udWxsaXR5IGMuZC4oaS0xKSBpblxuICAgICAgICAgIGxldCBpbSA9IE1hcC5yYW5rIGMuZC4oaSkgaW5cbiAgICAgICAgICBrZXIgLSBpbVxuICAgICAgICApXG4gICAgZW5kXG5cbiAgICAoKiogU3RyaW5nIHJlcHJlc2VudGF0aW9uLiAqKVxuICAgIGxldCB0b19zdHJpbmcgPSBwcmVzZW50YXRpb25fdG9fc3RyaW5nXG4gIGVuZFxuZW5kXG5tb2R1bGUgRnJlZUxlZnRNb2R1bGUgKFIgOiBSaW5nLlQpIChYIDogQWxwaGFiZXQuVCkgPSAoRnJlZUxlZnQoUikoWCkgOiBMZWZ0KVxubW9kdWxlIEZyZWUgKFIgOiBSaW5nLlQpIChYIDogQWxwaGFiZXQuVCkgPSBGcmVlTGVmdChSKShYKVxuXG5tb2R1bGUgRnJlZVJpZ2h0IChSIDogUmluZy5UKSAoWCA6IEFscGhhYmV0LlQpID0gc3RydWN0XG4gIGluY2x1ZGUgRnJlZUxlZnQoUmluZy5PcChSKSkoWClcblxuICBsZXQgY2luaiB4IGEgPSBjaW5qIGEgeFxuICAgIFxuICBsZXQgY211bCB4IGEgPSBjbXVsIGEgeFxuXG4gIGxldCB0b19zdHJpbmcgKHg6dCkgPVxuICAgIGxldCBhbnMgPSByZWYgXCJcIiBpblxuICAgIEUuaXRlciAoZnVuIHUgYSAtPlxuICAgICAgaWYgbm90IChSLmVxIGEgUi56ZXJvKSB0aGVuXG4gICAgICAgIChcbiAgICAgICAgICBpZiAhYW5zIDw+IFwiXCIgdGhlbiBhbnMgOj0gIWFucyBeIFwiK1wiO1xuICAgICAgICAgIGxldCBhID1cbiAgICAgICAgICAgIGlmIFIuZXEgYSBSLm9uZSB0aGVuIFwiXCIgZWxzZVxuICAgICAgICAgICAgICBcIipcIiBeIFwiKFwiIF4gUi50b19zdHJpbmcgYSBeIFwiKVwiXG4gICAgICAgICAgaW5cbiAgICAgICAgICBhbnMgOj0gIWFucyBeIFgudG9fc3RyaW5nIHUgXiBhXG4gICAgICAgIClcbiAgICApIHg7XG4gICAgIWFuc1xuZW5kXG5tb2R1bGUgRnJlZVJpZ2h0TW9kdWxlIChSIDogUmluZy5UKSAoWCA6IEFscGhhYmV0LlQpID0gKEZyZWVSaWdodChSKShYKSA6IFJpZ2h0KVxuIiwiKCoqIEdsb2J1bGFyIHNldHMuICopXG5cbigqKiBBIGdsb2J1bGFyIHNldC4gKilcbm1vZHVsZSB0eXBlIFQgPSBzaWdcbiAgKCoqIEEgY2VsbC4gKilcbiAgdHlwZSB0XG5cbiAgKCoqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGNlbGwuICopXG4gIHZhbCB0b19zdHJpbmcgOiB0IC0+IHN0cmluZ1xuXG4gICgqKiBEaW1lbnNpb24uICopXG4gIHZhbCBkaW0gOiB0IC0+IGludFxuXG4gICgqKiBTb3VyY2UuICopXG4gIHZhbCBzcmMgOiB0IC0+IHRcblxuICAoKiogVGFyZ2V0LiAqKVxuICB2YWwgdGd0IDogdCAtPiB0XG5lbmRcblxuKCoqIFRoZSB0ZXJtaW5hbCBnbG9idWxhciBzZXQuICopXG5tb2R1bGUgVGVybWluYWwgOiAgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgdG9fc3RyaW5nID0gc3RyaW5nX29mX2ludFxuXG4gIGxldCBkaW0gbiA9IG5cblxuICBsZXQgc3JjIG4gPVxuICAgIGFzc2VydCAobiA+IDApO1xuICAgIG4gLSAxXG5cbiAgbGV0IHRndCBuID1cbiAgICBhc3NlcnQgKG4gPiAwKTtcbiAgICBuIC0gMVxuZW5kXG5cbigqKiBQcmVzZW50ZWQgZ2xvYnVsYXIgc2V0LiAqKVxubW9kdWxlIFByZXMgKFggOiBBbHBoYWJldC5UKSA9IHN0cnVjdFxuICAoKiBDZWxscyBjb2RlZCBhcyBlbGVtZW50LCAoc291cmNlLHRhcmdldCksIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBiZWluZyB0aGVcbiAgICAgZWxlbWVudCBmb3IgMC1jZWxscyAqKVxuICBtb2R1bGUgQ2VsbCA9IEFscGhhYmV0LlByb2QzKEFscGhhYmV0LkludCkoWCkoWClcbiAgbW9kdWxlIEUgPSBBbHBoYWJldC5NYXAoWCkoQ2VsbClcblxuICAoKiogQSBnbG9idWxhciBzZXQuICopXG4gIHR5cGUgdCA9IEUudFxuXG4gICgqKiBUaGUgZW1wdHkgZ2xvYnVsYXIgc2V0LiAqKVxuICBsZXQgZW1wdHkgOiB0ID0gRS5lbXB0eVxuXG4gIGxldCBtZW0gKHM6dCkgKGc6WC50KSA9IEUubWVtIHMgZ1xuXG4gICgqKiBEaW1lbnNpb24gb2YgYSBnZW5lcmF0b3IuICopXG4gIGxldCBkaW0gKHM6dCkgKGc6WC50KSA9XG4gICAgbGV0IG4sXyxfID0gRS5hcHAgcyBnIGluXG4gICAgblxuXG4gICgqKiBTb3VyY2Ugb2YgYSBjZWxsLiAqKVxuICBsZXQgc3JjIChzOnQpIChnOlgudCkgPVxuICAgIGFzc2VydCAoZGltIHMgZyA+IDApO1xuICAgIGxldCBuLHNyYyxfID0gRS5hcHAgcyBnIGluXG4gICAgYXNzZXJ0IChuID4gMCk7XG4gICAgc3JjXG5cbiAgKCoqIFRhcmdldCBvZiBhIGNlbGwuICopXG4gIGxldCB0Z3QgKHM6dCkgKGc6WC50KSA9XG4gICAgbGV0IG4sXyx0Z3QgPSBFLmFwcCBzIGcgaW5cbiAgICBhc3NlcnQgKG4gPiAwKTtcbiAgICB0Z3RcblxuICAoKiogQWRkIGEgMC1jZWxsLiAqKVxuICBsZXQgYWRkMCAoczp0KSAoZzpYLnQpIDogdCA9XG4gICAgRS5hZGQgcyBnICgwLGcsZylcblxuICAoKiogQWRkIGFuIG4tY2VsbC4gKilcbiAgbGV0IGFkZCBzIChnOlgudCkgc3JjIHRndCA6IHQgPVxuICAgIGFzc2VydCAobWVtIHMgc3JjKTtcbiAgICBhc3NlcnQgKG1lbSBzIHRndCk7XG4gICAgbGV0IG4gPSBkaW0gcyBzcmMgKyAxIGluXG4gICAgYXNzZXJ0IChkaW0gcyB0Z3QgKyAxID0gbik7XG4gICAgRS5hZGQgcyBnIChuLHNyYyx0Z3QpXG5cbiAgbW9kdWxlIE1ha2UgKFAgOiBzaWcgdmFsIHByZXNlbnRhdGlvbiA6IHQgZW5kKSA6IFQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBYLnRcblxuICAgIGxldCB0b19zdHJpbmcgPSBYLnRvX3N0cmluZ1xuXG4gICAgbGV0IGRpbSA9IGRpbSBQLnByZXNlbnRhdGlvblxuXG4gICAgbGV0IHNyYyA9IHNyYyBQLnByZXNlbnRhdGlvblxuXG4gICAgbGV0IHRndCA9IHRndCBQLnByZXNlbnRhdGlvblxuICBlbmRcbmVuZFxuXG4oKiogQSBnbG9idWxhciB0aGVvcnksIHRoZSB0eXBpY2FsIGV4YW1wbGUgYmVpbmcgd2VhayBvbWVnYS1jYXRlZ29yaWVzLiAqKVxubW9kdWxlIFRoZW9yeSA9IHN0cnVjdFxuICBtb2R1bGUgVmFyID0gc3RydWN0XG4gICAgdHlwZSB0ID0gaW50XG5cbiAgICBsZXQgZnJlc2ggPVxuICAgICAgbGV0IG4gPSByZWYgKC0xKSBpblxuICAgICAgZnVuICgpIC0+XG4gICAgICBpbmNyIG47ICghbiA6IHQpXG5cbiAgICBsZXQgdG9fc3RyaW5nICh4OnQpID1cbiAgICAgIFwieFwiIF4gc3RyaW5nX29mX2ludCB4XG4gIGVuZFxuXG4gIG1vZHVsZSBDb25zID0gc3RydWN0XG4gICAgdHlwZSB0ID0gaW50XG4gICAgICAgICAgIFxuICAgIGxldCBmcmVzaCA9XG4gICAgICBsZXQgbiA9IHJlZiAoLTEpIGluXG4gICAgICBmdW4gKCkgLT5cbiAgICAgIGluY3IgbjsgKCFuIDogdClcblxuICAgIGxldCB0b19zdHJpbmcgKHg6dCkgPVxuICAgICAgXCJmXCIgXiBzdHJpbmdfb2ZfaW50IHhcbiAgZW5kXG5cbiAgdHlwZSB0ZXJtID1cbiAgICB8IFZhciBvZiBWYXIudFxuICAgIHwgQ29ucyBvZiBDb25zLnQgKiBjb250ZXh0XG4gICgqKiBBIGNvbnRleHQgY29udGFpbnMgdGVybXMgd2l0aCB0aGVpciBzb3VyY2UgYW5kIHRhcmdldC4gKilcbiAgYW5kIGNvbnRleHQgPSAodGVybSAqICh0ZXJtICogdGVybSkpIGxpc3RcbmVuZFxuIiwiKCoqIENhdGVnb3JpZXMuICopXG5cbigqKiBBIGNhdGVnb3J5LiAqKVxubW9kdWxlIHR5cGUgVCA9IHNpZ1xuICBpbmNsdWRlIEdyYXBoLlRcblxuICAoKiogQ29tcG9zaXRpb24gb2YgbW9ycGhpc21zLiAqKVxuICB2YWwgY29tcCA6IEUudCAtPiBFLnQgLT4gRS50XG5cbiAgKCoqIElkZW50aXR5IG1vcnBoaXNtLiAqKVxuICB2YWwgaWQgOiBWLnQgLT4gRS50XG5lbmRcblxuKCoqIEZyZWUgY2F0ZWdvcnkgb24gYSBncmFwaC4gKilcbm1vZHVsZSBGcmVlIChHIDogR3JhcGguVCkgPSBzdHJ1Y3RcbiAgbW9kdWxlIFYgPSBHLlZcbiAgbW9kdWxlIE0gPSBNb25vaWQuRnJlZShHLkUpXG4gIG1vZHVsZSBFID0gc3RydWN0XG4gICAgaW5jbHVkZSBBbHBoYWJldC5Qcm9kMyhWKShNKShWKVxuICAgIGxldCB0b19zdHJpbmcgKHgsZix5KSA9XG4gICAgICBpZiBNLmVxIE0ub25lIGYgdGhlbiBcImlkXCJeVi50b19zdHJpbmcgeCBlbHNlIE0udG9fc3RyaW5nIGZcbiAgZW5kXG4gIGxldCBzcmMgKCh4LGYseSk6RS50KSA9IHhcbiAgbGV0IHRndCAoKHgsZix5KTpFLnQpID0geVxuICBsZXQgaWQgKHg6Vi50KSA6IEUudCA9ICh4LE0ub25lLHgpXG4gIGxldCBjb21wICgoeCxmLHkpOkUudCkgKCh5JyxnLHopOkUudCkgOiBFLnQgPVxuICAgIGFzc2VydCAoVi5lcSB5IHknKTtcbiAgICB4LE0ubXVsIGYgZyx6XG4gIGxldCBpbmogZiA6IEUudCA9IChHLnNyYyBmLE0uaW5qIGYsRy50Z3QgZilcbmVuZFxubW9kdWxlIEZyZWVDYXRlZ29yeSAoRyA6IEdyYXBoLlQpIDogVCA9IEZyZWUoRylcblxuKCoqIFByZXNlbnRhdGlvbiBvZiBhIGNhdGVnb3J5LiAqKVxubW9kdWxlIFByZXMgKFYgOiBBbHBoYWJldC5UKSAoRSA6IEFscGhhYmV0LlQpID0gc3RydWN0XG4gIG1vZHVsZSBHUCA9IEdyYXBoLlByZXMoVikoRSlcbiAgbW9kdWxlIEZyZWUgPSBGcmVlKEdQLkdyYXBoKVxuXG4gICgqKiBBIHByZXNlbnRhdGlvbi4gKilcbiAgdHlwZSB0ID1cbiAgICB7XG4gICAgICBncmFwaCA6IEdQLnQ7XG4gICAgICByZWxhdGlvbnMgOiAoRnJlZS5FLnQgKiBGcmVlLkUudCkgbGlzdDtcbiAgICB9XG5cbiAgKCoqIEVtcHR5IHByZXNlbnRhdGlvbi4gKilcbiAgbGV0IGVtcHR5ID0geyBncmFwaCA9IEdQLmVtcHR5OyByZWxhdGlvbnMgPSBbXSB9XG5cbiAgbGV0IGFkZF9vYmplY3QgcCB4ID1cbiAgICB7IHAgd2l0aCBncmFwaCA9IEdQLmFkZF92ZXJ0ZXggcC5ncmFwaCB4IH1cblxuICBsZXQgYWRkX21vcnBoaXNtIHAgZiB4IHkgPVxuICAgIGFzc2VydCAoR1AuaGFzX3ZlcnRleCBwLmdyYXBoIHgpO1xuICAgIGFzc2VydCAoR1AuaGFzX3ZlcnRleCBwLmdyYXBoIHkpO1xuICAgIHsgcCB3aXRoIGdyYXBoID0gR1AuYWRkX2VkZ2UgcC5ncmFwaCBmICh4LHkpIH1cblxuICAoKiogTW9ycGhpc20gY29ycmVzcG9uZGluZyB0byBhIGdlbmVyYXRvci4gKilcbiAgbGV0IG1vcnBoaXNtIHAgZiA6IEZyZWUuRS50ID1cbiAgICBGcmVlLmluaiAoR1AuZWRnZSBwLmdyYXBoIGYpXG5cbiAgbGV0IGFkZF9yZWxhdGlvbiBwIGYgZyA9XG4gICAgeyBwIHdpdGggcmVsYXRpb25zID0gKGYsZyk6OnAucmVsYXRpb25zIH1cblxuICBsZXQgdG9fc3RyaW5nIHAgPVxuICAgIGxldCBncmFwaCA9IEdQLnRvX3N0cmluZyBwLmdyYXBoIGluXG4gICAgbGV0IHJlbGF0aW9ucyA9IHAucmVsYXRpb25zIGluXG4gICAgbGV0IHJlbGF0aW9ucyA9IExpc3QubWFwIChmdW4gKGYsZykgLT4gRnJlZS5FLnRvX3N0cmluZyBmIF4gXCI9XCIgXiBGcmVlLkUudG9fc3RyaW5nIGcpIHJlbGF0aW9ucyBpblxuICAgIGxldCByZWxhdGlvbnMgPSBTdHJpbmcuY29uY2F0IFwiICwgXCIgcmVsYXRpb25zIGluXG4gICAgZ3JhcGggXiBcIlxcblwiIF4gcmVsYXRpb25zXG5lbmRcblxuKCoqIENhdGVnb3J5IG9mIGEgbW9ub2lkLiAqKVxubW9kdWxlIE1vbm9pZCAoTSA6IE1vbm9pZC5UKSA6IFQgPSBzdHJ1Y3RcbiAgbW9kdWxlIFYgPSBBbHBoYWJldC5Vbml0XG4gIG1vZHVsZSBFID0gTVxuICBsZXQgc3JjIF8gPSAoKVxuICBsZXQgdGd0IF8gPSAoKVxuICBsZXQgY29tcCA9IE0ubXVsXG4gIGxldCBpZCAoKSA9IE0ub25lXG5lbmRcblxuKCoqIFVuZGVybHlpbmcgZ3JhcGggb2YgYSBjYXRlZ29yeS4gKilcbm1vZHVsZSBHcmFwaCAoQyA6IFQpIDogR3JhcGguVCA9IHN0cnVjdFxuICBpbmNsdWRlIENcbmVuZFxuIiwiKCoqIEF1dG9tYXRhLiAqKVxuXG4oKiogUmVndWxhciBleHByZXNzaW9ucy4gKilcbm1vZHVsZSBSZWdleHAgKFggOiBBbHBoYWJldC5UKSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgTGV0dGVyIG9mIFgudFxuICAgIHwgVW5pb24gb2YgdCAqIHRcbiAgICB8IEVtcHR5XG4gICAgfCBDb25jYXQgb2YgdCAqIHQgKCoqIGNvbmNhdGVuYXRpb24gKilcbiAgICB8IFNpbmdsICgqKiBlbXB0eSB3b3JkIHNpbmdsZXRvbiAqKVxuICAgIHwgU3RhciBvZiB0XG5cbiAgbGV0IGxldHRlciBhID0gTGV0dGVyIGFcbiAgbGV0IHVuaW9uIHIgcyA9IFVuaW9uIChyLHMpXG4gIGxldCBlbXB0eSA9IEVtcHR5XG4gIGxldCBjb25jYXQgciBzID0gQ29uY2F0IChyLHMpXG4gIGxldCBzdGFyIHIgPSBTdGFyIHJcblxuICBsZXQgcmVjIHVuaW9ucyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBFbXB0eVxuICAgIHwgW3JdIC0+IHJcbiAgICB8IHI6OmwgLT4gdW5pb24gciAodW5pb25zIGwpXG5cbigqXG4gIGxldCByZWMgdG9fc3RyaW5nID0gZnVuY3Rpb25cbiAgICB8IExldHRlciBhIC0+IFgudG9fc3RyaW5nIGFcbiAgICB8IFVuaW9uIChyLHMpIC0+IFwiKFwiIF4gdG9fc3RyaW5nIHIgXiBcIikgKyAoXCIgXiB0b19zdHJpbmcgcyBeIFwiKVwiXG4gICAgfCBFbXB0eSAtPiBcIjBcIlxuICAgIHwgQ29uY2F0IChyLHMpIC0+IFwiKFwiIF4gdG9fc3RyaW5nIHIgXiBcIikoXCIgXiB0b19zdHJpbmcgcyBeIFwiKVwiXG4gICAgfCBTaW5nbCAtPiBcIjFcIlxuICAgIHwgU3RhciByIC0+IFwiKFwiIF4gdG9fc3RyaW5nIHIgXiBcIikqXCJcbiopXG4gICAgICAgICAgICAgICAgICAgIFxuICBsZXQgdG9fc3RyaW5nIHIgPVxuICAgICgqIGxldmVsOiAwOisgLyAxOnggLyAyOiogKilcbiAgICBsZXQgcmVjIGF1eCBsIHIgPVxuICAgICAgbGV0IHBhIGwnIHMgPSBpZiBsJyA8IGwgdGhlbiBcIihcIiBeIHMgXiBcIilcIiBlbHNlIHMgaW5cbiAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgfCBMZXR0ZXIgYSAtPiBYLnRvX3N0cmluZyBhXG4gICAgICB8IFVuaW9uIChyLHMpIC0+IHBhIDAgKGF1eCAwIHIgXiBcIitcIiBeIGF1eCAwIHMpXG4gICAgICB8IEVtcHR5IC0+IFwiMFwiXG4gICAgICB8IENvbmNhdCAocixzKSAtPiBwYSAxIChhdXggMSByIF4gXCIuXCIgXiBhdXggMSBzKVxuICAgICAgfCBTaW5nbCAtPiBcIjFcIlxuICAgICAgfCBTdGFyIHIgLT4gYXV4IDIgciBeIFwiKlwiXG4gICAgaW5cbiAgICBhdXggKC0xKSByICAgICAgXG5cbiAgbGV0IHJlYyBzaW1wbCA9IGZ1bmN0aW9uXG4gICAgfCBVbmlvbiAoRW1wdHksIHIpIC0+IHNpbXBsIHJcbiAgICB8IFVuaW9uIChyLCBFbXB0eSkgLT4gc2ltcGwgclxuICAgIHwgVW5pb24gKHIsIHMpIC0+IFVuaW9uIChzaW1wbCByLCBzaW1wbCBzKVxuICAgIHwgQ29uY2F0IChFbXB0eSwgcikgLT4gRW1wdHlcbiAgICB8IENvbmNhdCAociwgRW1wdHkpIC0+IEVtcHR5XG4gICAgfCBDb25jYXQgKFNpbmdsLCByKSAtPiBzaW1wbCByXG4gICAgfCBDb25jYXQgKHIsIFNpbmdsKSAtPiBzaW1wbCByXG4gICAgfCBDb25jYXQgKHIsIHMpIC0+IENvbmNhdCAoc2ltcGwgciwgc2ltcGwgcylcbiAgICB8IFN0YXIgRW1wdHkgLT4gRW1wdHlcbiAgICB8IFN0YXIgciAtPiBTdGFyIChzaW1wbCByKVxuICAgIHwgTGV0dGVyIF8gfCBFbXB0eSB8IFNpbmdsIGFzIHIgLT4gclxuXG4gIGxldCBzaW1wbCByID1cbiAgICBsZXQgcmVjIGZpeCBmIHggPVxuICAgICAgbGV0IHkgPSBmIHggaW5cbiAgICAgIGlmIHkgPSB4IHRoZW4geFxuICAgICAgZWxzZSBmaXggZiB5XG4gICAgaW5cbiAgICBmaXggc2ltcGwgclxuXG4gIG1vZHVsZSBTZXJpZXMgPSBTZXJpZXMuTWFrZShGaWVsZC5JbnQpXG5cbiAgKCoqIEdlbmVyYXRpbmcgc2VyaWVzIG9mIGEgcmVndWxhciBleHByZXNzaW9uLiBUaGlzIGV4cHJlc3Npb24gaXMgYXNzdW1lZCB0b1xuICBiZSB1bmFtYmlndW91cy4gKilcbiAgbGV0IHJlYyBzZXJpZXMgPSBmdW5jdGlvblxuICAgIHwgTGV0dGVyIGEgLT4gU2VyaWVzLnZhclxuICAgIHwgVW5pb24gKGEsIGIpIC0+IFNlcmllcy5hZGQgKHNlcmllcyBhKSAoc2VyaWVzIGIpXG4gICAgfCBFbXB0eSAtPiBTZXJpZXMuemVyb1xuICAgIHwgQ29uY2F0IChhLCBiKSAtPiBTZXJpZXMubXVsIChzZXJpZXMgYSkgKHNlcmllcyBiKVxuICAgIHwgU2luZ2wgLT4gU2VyaWVzLm9uZVxuICAgIHwgU3RhciBhIC0+IFNlcmllcy5zdGFyIChzZXJpZXMgYSlcbmVuZFxuXG5tb2R1bGUgU3RhdGUgPSBBbHBoYWJldC5JbnRcblxubW9kdWxlIE1ha2UgKFggOiBBbHBoYWJldC5UKSA9IHN0cnVjdFxuICBtb2R1bGUgU3RhdGVzID0gQWxwaGFiZXQuUG93KFN0YXRlKVxuICBtb2R1bGUgVCA9IEFscGhhYmV0Lk1hcChBbHBoYWJldC5Qcm9kKFN0YXRlKShYKSkoU3RhdGVzKVxuICBtb2R1bGUgUmVnZXhwID0gUmVnZXhwKFgpXG5cbiAgdHlwZSB0ID1cbiAgICB7XG4gICAgICBzdGF0ZXMgOiBpbnQ7XG4gICAgICBpbml0aWFsIDogU3RhdGUudDtcbiAgICAgIHRlcm1pbmFsIDogU3RhdGVzLnQ7XG4gICAgICB0cmFuc2l0aW9ucyA6IFQudDtcbiAgICB9XG5cbiAgbGV0IHN0YXRlcyBhdXQgPSBhdXQuc3RhdGVzXG5cbiAgbGV0IHRyYW5zIGF1dCBhIHggPVxuICAgIHRyeVxuICAgICAgVC5hcHAgYXV0LnRyYW5zaXRpb25zIChhLHgpXG4gICAgd2l0aFxuICAgIHwgTm90X2ZvdW5kIC0+IFN0YXRlcy5lbXB0eVxuXG4gIGxldCBhZGRfdHJhbnNpdGlvbiBhdXQgYSB4IChiIDogU3RhdGUudCkgPVxuICAgIGxldCBiYiA9IHRyYW5zIGF1dCBhIHggaW5cbiAgICBsZXQgYmIgPSBTdGF0ZXMuYWRkIGJiIGIgaW5cbiAgICBsZXQgdHJhbnNpdGlvbnMgPSBULmFkZCBhdXQudHJhbnNpdGlvbnMgKGEseCkgYmIgaW5cbiAgICB7IGF1dCB3aXRoIHRyYW5zaXRpb25zIH1cblxuICBsZXQgY3JlYXRlIHN0YXRlcyBpbml0aWFsIHRlcm1pbmFsIHRyYW5zaXRpb25zID1cbiAgICBsZXQgdGVybWluYWwgPSBTdGF0ZXMub2ZfbGlzdCB0ZXJtaW5hbCBpblxuICAgIGxldCBhbnMgPSB7IHN0YXRlczsgaW5pdGlhbDsgdGVybWluYWw7IHRyYW5zaXRpb25zID0gVC5lbXB0eSB9IGluXG4gICAgTGlzdC5mb2xkX2xlZnQgKGZ1biBhbnMgKGEseCxiKSAtPiBhZGRfdHJhbnNpdGlvbiBhbnMgYSB4IGIpIGFucyB0cmFuc2l0aW9uc1xuXG4gIGxldCBrbGVlbmUgYXV0ID1cbiAgICBsZXQgbiA9IHN0YXRlcyBhdXQgaW5cbiAgICBsZXQgaW5pdCBmID0gQXJyYXkuaW5pdCBuIChmdW4gaSAtPiBBcnJheS5pbml0IG4gKGZ1biBqIC0+IGYgaSBqKSkgaW5cbiAgICBsZXQgcnIgPVxuICAgICAgaW5pdFxuICAgICAgICAoZnVuIGkgaiAtPlxuICAgICAgICAgIGxldCByID0gcmVmIFJlZ2V4cC5lbXB0eSBpblxuICAgICAgICAgIFQuaXRlciAoZnVuIChpJyxhKSBqaiAtPlxuICAgICAgICAgICAgICBpZiBTdGF0ZS5lcSBpIGknICYmIFN0YXRlcy5tZW0gamogaiB0aGVuIHIgOj0gUmVnZXhwLnVuaW9uICFyIChSZWdleHAubGV0dGVyIGEpXG4gICAgICAgICAgICApIGF1dC50cmFuc2l0aW9ucztcbiAgICAgICAgICBpZiBpID0gaiB0aGVuIHIgOj0gUmVnZXhwLnVuaW9uIFJlZ2V4cC5lbXB0eSAhcjtcbiAgICAgICAgICAhclxuICAgICAgICApXG4gICAgaW5cbiAgICBsZXQgcnIgPSByZWYgcnIgaW5cbiAgICBmb3IgayA9IDAgdG8gbiAtIDEgZG9cbiAgICAgIGxldCBzcyA9XG4gICAgICAgIGxldCByciA9ICFyciBpblxuICAgICAgICBpbml0XG4gICAgICAgICAgKGZ1biBpIGogLT5cbiAgICAgICAgICAgIFJlZ2V4cC51bmlvblxuICAgICAgICAgICAgICByci4oaSkuKGopXG4gICAgICAgICAgICAgIChSZWdleHAuY29uY2F0IHJyLihpKS4oaykgKFJlZ2V4cC5jb25jYXQgKFJlZ2V4cC5zdGFyIHJyLihrKS4oaykpIHJyLihrKS4oaikpKVxuICAgICAgICAgIClcbiAgICAgIGluXG4gICAgICByciA6PSBzc1xuICAgIGRvbmU7XG4gICAgbGV0IHJyID0gIXJyIGluXG4gICAgbGV0IHIgPSByZWYgUmVnZXhwLmVtcHR5IGluXG4gICAgbGV0IGkgPSBhdXQuaW5pdGlhbCBpblxuICAgIFN0YXRlcy5pdGVyIChmdW4gaiAtPiByIDo9IFJlZ2V4cC51bmlvbiAhciByci4oaSkuKGopKSBhdXQudGVybWluYWw7XG4gICAgIXJcbmVuZFxuIiwiKCoqIEFsZ2VicmFzLiAqKVxuXG4oKiogQW4gYWxnZWJyYS4gKilcbm1vZHVsZSB0eXBlIFQgPSBzaWdcbiAgKCoqIEFuIGVsZW1lbnQgb2YgdGhlIGFsZ2VicmEuICopXG4gIHR5cGUgdFxuXG4gICgqKiBBbiBlbGVtZW50IG9mIHRoZSByaW5nLiAqKVxuICB0eXBlIHJcblxuICBpbmNsdWRlIFJpbmcuVCB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgbW9kdWxlIEZpZWxkIDogc2lnXG4gICAgaW5jbHVkZSBGaWVsZC5UIHdpdGggdHlwZSB0IDo9IHJcbiAgZW5kXG5cbiAgdmFsIGNtdWwgOiByIC0+IHQgLT4gdFxuZW5kXG5cbigqKiBGcmVlIGFsZ2VicmEgb2YgYSBtb25vaWQgb3ZlciBhIHJpbmcuICopXG5tb2R1bGUgRnJlZSAoSyA6IEZpZWxkLlQpIChNIDogTW9ub2lkLlQpID0gc3RydWN0XG4gIGluY2x1ZGUgTW9kdWxlLkZyZWVMZWZ0KEspKE0pXG5cbiAgbW9kdWxlIEZpZWxkID0gS1xuXG4gIGxldCBvbmUgPSBpbmogTS5vbmVcblxuICBsZXQgbXVsX21vbm9taWFsIHAgdiA9XG4gICAgbWFwIChmdW4gdSAtPiBpbmogKE0ubXVsIHUgdikpIHBcblxuICBsZXQgbXVsIHAgcSA9XG4gICAgbWFwIChmdW4gdiAtPiBtdWxfbW9ub21pYWwgcCB2KSBxXG5cbiAgbGV0IGxlYWRpbmcgbGVxIChwOnQpIDogSy50ICogTS50ID1cbiAgICBsZXQgYSA9IHJlZiBLLnplcm8gaW5cbiAgICBsZXQgdSA9IHJlZiBNLm9uZSBpblxuICAgIGl0ZXIgKGZ1biBiIHYgLT4gaWYgbGVxICF1IHYgdGhlbiAoYSA6PSBiOyB1IDo9IHYpKSBwO1xuICAgICFhLCAhdVxuZW5kXG5tb2R1bGUgRnJlZUFsZ2VicmEgKEsgOiBGaWVsZC5UKSAoTSA6IE1vbm9pZC5UKSA9IChGcmVlKEspKE0pIDogVClcblxuKCoqIFByZXNlbnRhdGlvbiBvZiBhbiBhbGdlYnJhLiAqKVxubW9kdWxlIFByZXMgKEsgOiBGaWVsZC5UKSAoWCA6IEFscGhhYmV0LlQpID0gc3RydWN0XG4gIG1vZHVsZSBNID0gTW9ub2lkLkZyZWUoWClcbiAgbW9kdWxlIEEgPSBGcmVlKEspKE0pXG5cbiAgdHlwZSB0ID1cbiAgICB7XG4gICAgICBsZXEgOiBNLnQgLT4gTS50IC0+IGJvb2w7XG4gICAgICBnZW5lcmF0b3JzIDogWC50IGxpc3Q7XG4gICAgICBydWxlcyA6IChNLnQgKiBBLnQpIGxpc3Q7XG4gICAgfVxuXG4gIGxldCBmcmVlIGxlcSBnZW5lcmF0b3JzID1cbiAgICBsZXQgcnVsZXMgPSBbXSBpblxuICAgIHsgbGVxOyBnZW5lcmF0b3JzOyBydWxlcyB9XG5cbiAgKCoqIE9yaWVudCBhIHBvbHlub21pYWwgYXMgYSBydWxlLiAqKVxuICBsZXQgb3JpZW50IHByZXMgcCA9XG4gICAgbGV0IGEsdSA9IEEubGVhZGluZyBwcmVzLmxlcSBwIGluXG4gICAgbGV0IHAgPSBBLmNtdWwgKEsuaW52IGEpIHAgaW5cbiAgICBsZXQgcCA9IEEuc3ViIChBLmluaiB1KSBwIGluXG4gICAgdSxwXG5cbiAgKCoqIEFkZCBhIHJ1bGUgdG8gYSBwcmVzZW50YXRpb24uICopXG4gIGxldCBhZGRfcnVsZSBwcmVzIHIgPVxuICAgIGxldCBydWxlcyA9IHIgOjogcHJlcy5ydWxlcyBpblxuICAgIHsgcHJlcyB3aXRoIHJ1bGVzIH1cblxuICAoKiogQWRkIGEgcmVsYXRpb24gdG8gYSBwcmVzZW50YXRpb24uICopXG4gIGxldCBhZGRfcmVsYXRpb24gcHJlcyBwID1cbiAgICBhZGRfcnVsZSBwcmVzIChvcmllbnQgcHJlcyBwKVxuXG4gICgqKiBDcmVhdGUgYSBwcmVzZW50YXRpb24gZnJvbSBhbiBhbHBoYWJldCBhbmQgYSBsaXN0IG9mIG1vbm9taWFscy4gKilcbiAgbGV0IG1ha2UgbGVxIGdlbmVyYXRvcnMgcHAgOiB0ID1cbiAgICBMaXN0LmZvbGRfbGVmdCBhZGRfcmVsYXRpb24gKGZyZWUgbGVxIGdlbmVyYXRvcnMpIHBwXG5cbiAgKCoqIE1pbmltYWwgcmVkdWNpYmxlIHdvcmRzLiAqKVxuICBsZXQgaGVhZHMgcHJlcyA9XG4gICAgTGlzdC5tYXAgKGZ1biAodSxwKSAtPiB1KSBwcmVzLnJ1bGVzXG5cbiAgbGV0IHRvX3N0cmluZyBwcmVzID1cbiAgICBcIjwgXCJcbiAgICBeIFN0cmluZy5jb25jYXQgXCIgXCIgKExpc3QubWFwIFgudG9fc3RyaW5nIHByZXMuZ2VuZXJhdG9ycykgXiBcIiB8IFwiXG4gICAgXiBTdHJpbmcuY29uY2F0IFwiICwgXCIgKExpc3QubWFwIChmdW4gKHUscCkgLT4gTS50b19zdHJpbmcgdSBeIFwiIC0+IFwiIF4gQS50b19zdHJpbmcgcCkgcHJlcy5ydWxlcylcbiAgICBeIFwiID5cIlxuXG4gICgqKiBOb3JtYWxpemUgd29yZHMuICopXG4gIGxldCBub3JtYWxpemUgcHJlcyBwID1cbiAgICBsZXQgcCA9IHJlZiBwIGluXG4gICAgbGV0IGxvb3AgPSByZWYgdHJ1ZSBpbiBcbiAgICB3aGlsZSAhbG9vcCBkb1xuICAgICAgbG9vcCA6PSBmYWxzZTtcbiAgICAgIHAgOj0gQS5tYXAgKGZ1biB1IC0+XG4gICAgICAgIHRyeVxuICAgICAgICAgIGxldCB2LHYnID0gTGlzdC5maW5kIChmdW4gKHYsXykgLT4gTS5pbmNsdWRlZCB2IHUpIHByZXMucnVsZXMgaW5cbiAgICAgICAgICBsb29wIDo9IHRydWU7XG4gICAgICAgICAgbGV0IGkgPSBNLnVuaWZpZXIgdSB2IGluXG4gICAgICAgICAgbGV0IHYxID0gTS5zdWIgdSAwIGkgaW5cbiAgICAgICAgICBsZXQgdjIgPSBNLnN1YiB1IChpICsgTS5sZW5ndGggdikgKE0ubGVuZ3RoIHUgLSAoaSArIE0ubGVuZ3RoIHYpKSBpblxuICAgICAgICAgIGxldCB2MSA9IEEuaW5qIHYxIGluXG4gICAgICAgICAgbGV0IHYyID0gQS5pbmogdjIgaW5cbiAgICAgICAgICBBLm11bCB2MSAoQS5tdWwgdicgdjIpXG4gICAgICAgIHdpdGhcbiAgICAgICAgfCBOb3RfZm91bmQgLT4gQS5pbmogdVxuICAgICAgKSAhcFxuICAgIGRvbmU7XG4gICAgIXBcblxuICAoKiogQnVjaGJlcmdlcidzIGNvbXBsZXRpb24gYWxnb3JpdGhtLiAqKVxuICBsZXQgYnVjaGJlcmdlciBwcmVzID1cbiAgICAoKiBUT0RPOiBub3JtYWxpemUgdGhlIHByZXNlbnRhdGlvbiBmaXJzdCAqKVxuICAgIGxldCB0b2RvID0gUXVldWUuY3JlYXRlICgpIGluXG4gICAgTGlzdC5pdGVyIChmdW4gciAtPiBRdWV1ZS5hZGQgciB0b2RvKSBwcmVzLnJ1bGVzO1xuICAgIGxldCBwcmVzID0gcmVmIHByZXMgaW5cbiAgICAoKiBBZGQgYSByZWxhdGlvbiAqKVxuICAgIGxldCByZWwgcCA9XG4gICAgICAoKiBQcmludGYucHJpbnRmIFwicmVsOiAlc1xcbiUhXCIgKEEudG9fc3RyaW5nIHApOyAqKVxuICAgICAgaWYgbm90IChBLmVxIEEuemVybyBwKSB0aGVuXG4gICAgICAgIGxldCByID0gb3JpZW50ICFwcmVzIHAgaW5cbiAgICAgICAgcHJlcyA6PSBhZGRfcnVsZSAhcHJlcyByO1xuICAgICAgICBRdWV1ZS5wdXNoIHIgdG9kb1xuICAgIGluXG4gICAgd2hpbGUgbm90IChRdWV1ZS5pc19lbXB0eSB0b2RvKSBkb1xuICAgICAgbGV0IHUscCA9IFF1ZXVlLnBvcCB0b2RvIGluXG4gICAgICBMaXN0Lml0ZXIgKGZ1biAodixxKSAtPlxuICAgICAgICBMaXN0Lml0ZXIgKGZ1biAoKHUxLHUyKSwodjEsdjIpKSAtPlxuICAgICAgICAgICgqIFByaW50Zi5wcmludGYgXCJ1bmlmaWVyOiAlc3wlcy0+JXN8JXMgdnMgJXN8JXMtPiVzfCVzXFxuJSFcIiAqKVxuICAgICAgICAgICAgKCogKE0udG9fc3RyaW5nIHUxKSAoTS50b19zdHJpbmcgdSkgKEEudG9fc3RyaW5nIHApIChNLnRvX3N0cmluZyB1MikgKilcbiAgICAgICAgICAgICgqIChNLnRvX3N0cmluZyB2MSkgKE0udG9fc3RyaW5nIHYpIChBLnRvX3N0cmluZyBxKSAoTS50b19zdHJpbmcgdjIpOyAqKVxuICAgICAgICAgICgqIENvbXB1dGUgdGhlIFMtcG9seW5vbWlhbCAqKVxuICAgICAgICAgIGxldCB1MSA9IEEuaW5qIHUxIGluXG4gICAgICAgICAgbGV0IHUyID0gQS5pbmogdTIgaW5cbiAgICAgICAgICBsZXQgdjEgPSBBLmluaiB2MSBpblxuICAgICAgICAgIGxldCB2MiA9IEEuaW5qIHYyIGluXG4gICAgICAgICAgbGV0IHMxID0gQS5tdWwgdTEgKEEubXVsIHAgdTIpIGluXG4gICAgICAgICAgbGV0IHMyID0gQS5tdWwgdjEgKEEubXVsIHEgdjIpIGluXG4gICAgICAgICAgbGV0IHMgPSBBLnN1YiBzMSBzMiBpblxuICAgICAgICAgIGxldCBzID0gbm9ybWFsaXplICFwcmVzIHMgaW5cbiAgICAgICAgICByZWwgc1xuICAgICAgICApIChNLnVuaWZpZXJzX2JpY29udGV4dCB1IHYpXG4gICAgICApICFwcmVzLnJ1bGVzXG4gICAgZG9uZTtcbiAgICAhcHJlc1xuXG4gICgqKiBSZWR1Y2UgYSBwcmVzZW50YXRpb24uICopXG4gIGxldCByZWR1Y2UgcHJlcyA9XG4gICAgbGV0IHJ1bGVzID0gcHJlcy5ydWxlcyBpblxuICAgIGxldCBydWxlcyA9IExpc3QubWFwIChmdW4gKHUscCkgLT4gdSwgbm9ybWFsaXplIHByZXMgcCkgcnVsZXMgaW5cbiAgICBsZXQgcmVjIGF1eCBhY2MgPSBmdW5jdGlvblxuICAgICAgfCAodSxwKTo6cnVsZXMgLT5cbiAgICAgICAgIGxldCBmIGwgPSBMaXN0LmV4aXN0cyAoZnVuICh2LHEpIC0+IE0uaW5jbHVkZWQgdiB1KSBsIGluXG4gICAgICAgICBpZiBmIGFjYyB8fCBmIHJ1bGVzIHRoZW4gYXV4IGFjYyBydWxlcyBlbHNlIGF1eCAoKHUscCk6OmFjYykgcnVsZXNcbiAgICAgIHwgW10gLT4gTGlzdC5yZXYgYWNjXG4gICAgaW5cbiAgICBsZXQgcnVsZXMgPSBhdXggW10gcnVsZXMgaW5cbiAgICB7IHByZXMgd2l0aCBydWxlcyB9XG5cbiAgKCoqIEFsZ2VicmEgZ2l2ZW4gYnkgYSBjb252ZXJnZW50IHByZXNlbnRhdGlvbi4gKilcbiAgbW9kdWxlIEFsZ2VicmEgKFAgOiBzaWcgdmFsIHByZXNlbnRhdGlvbiA6IHQgZW5kKSA6IFQgd2l0aCB0eXBlIHQgPSBBLnQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIEFcblxuICAgIGxldCBuZiA9IG5vcm1hbGl6ZSBQLnByZXNlbnRhdGlvblxuXG4gICAgKCogbGV0IGluaiBtID0gbmYgKGluaiBtKSAqKVxuXG4gICAgKCogbGV0IGNpbmogYyBtID0gbmYgKGNpbmogYyBtKSAqKVxuXG4gICAgbGV0IG11bCBwIHEgPSBuZiAobXVsIHAgcSlcbiAgZW5kXG5cbiAgKCoqIEF1Z21lbnRhdGlvbnMgZm9yIHByZXNlbnRlZCBhbGdlYnJhcy4gKilcbiAgbW9kdWxlIEF1Z21lbnRhdGlvbiA9IHN0cnVjdFxuICAgICgqKiBBbiBhdWdtZW50YXRpb24uICopXG4gICAgdHlwZSB0ID0gQS50IC0+IEsudFxuXG4gICAgKCoqIEludmFsaWQgYXVnbWVudGF0aW9uLiAqKVxuICAgIGV4Y2VwdGlvbiBJbnZhbGlkXG5cbiAgICAoKiogQ29uc3RydWN0IGFuIGF1Z21lbnRhdGlvbiBieSBkZWZpbmluZyBpdCBvbiBnZW5lcmF0b3JzLiAqKVxuICAgIGxldCBtYWtlIHByZXMgKGVwcyA6IE0udCAtPiBLLnQpIDogdCA9XG4gICAgICAoKiBUT0RPOiB1c2UgYSBnZW5lcmljIGZ1bmN0aW9uICopXG4gICAgICBsZXQgZXBzIHAgPVxuICAgICAgICBsZXQgYW5zID0gcmVmIEsuemVybyBpblxuICAgICAgICBBLml0ZXIgKGZ1biBhIHUgLT5cbiAgICAgICAgICBhbnMgOj0gSy5hZGQgIWFucyAoSy5tdWwgYSAoZXBzIHUpKVxuICAgICAgICApIHA7XG4gICAgICAgICFhbnNcbiAgICAgIGluXG4gICAgICAoKiBFbnN1cmUgdGhhdCBpdCBpcyB3ZWxsLWRlZmluZWQuICopXG4gICAgICBhc3NlcnQgKEsuZXEgSy5vbmUgKGVwcyAoQS5pbmogTS5vbmUpKSk7XG4gICAgICBMaXN0Lml0ZXIgKGZ1biAodSxwKSAtPlxuICAgICAgICBpZiBub3QgKEsuZXEgKGVwcyAoQS5pbmogdSkpIChlcHMgcCkpIHRoZW4gcmFpc2UgSW52YWxpZFxuICAgICAgKSBwcmVzLnJ1bGVzO1xuICAgICAgZXBzXG5cbiAgICAoKiogVHJhZGl0aW9uYWwgYXVnbWVudGF0aW9uIGZvciBncmFkZWQgYWxnZWJyYXMuICopXG4gICAgbGV0IGdyYWRlZCBwcmVzID1cbiAgICAgIG1ha2UgcHJlcyAoZnVuIHUgLT4gaWYgTS5lcSBNLm9uZSB1IHRoZW4gSy5vbmUgZWxzZSBLLnplcm8pXG5cbiAgICAoKiogVHJhZGl0aW9uYWwgYXVnbWVudGF0aW9uIGZvciBtb25vaWRzIC8gZ3JvdXBzLiAqKVxuICAgIGxldCBtb25vaWQgcHJlcyA9XG4gICAgICBtYWtlIHByZXMgKGZ1biB1IC0+IEsub25lKVxuICBlbmRcblxuICAoKiogQW5pY2sgcmVzb2x1dGlvbi4gKilcbiAgbW9kdWxlIEFuaWNrID0gc3RydWN0XG4gICAgdHlwZSBjaGFpbiA9IE0uQW5pY2sudFxuXG4gICAgbW9kdWxlIEFNb2QgPSBzdHJ1Y3RcbiAgICAgIG1vZHVsZSBNb2QgPSBNb2R1bGUuRnJlZVJpZ2h0KEEpKE0uQW5pY2spXG5cbiAgICAgIGluY2x1ZGUgKE1vZCA6IG1vZHVsZSB0eXBlIG9mIE1vZCB3aXRoIG1vZHVsZSBNYXAgOj0gTW9kLk1hcClcblxuICAgICAgKCoqIE5vcm1hbGl6ZSBhIHBvbHlub21pYWwuICopXG4gICAgICBsZXQgbm9ybWFsaXplIHByZXMgcCA9XG4gICAgICAgIGxldCBhbnMgPSByZWYgemVybyBpblxuICAgICAgICBpdGVyIChmdW4gdSBjIC0+XG4gICAgICAgICAgbGV0IHUgPSBub3JtYWxpemUgcHJlcyB1IGluXG4gICAgICAgICAgYW5zIDo9IGFkZCAhYW5zIChjaW5qIGMgdSlcbiAgICAgICAgKSBwO1xuICAgICAgICAhYW5zXG5cbiAgICAgIG1vZHVsZSBNYXAgPSBzdHJ1Y3RcbiAgICAgICAgaW5jbHVkZSBNb2QuTWFwXG5cbiAgICAgICAgKCogV2UgbmVlZCB0byByZW5vcm1hbGl6ZSB3aGVuIGFwcGx5aW5nIGEgZnVuY3Rpb24uICopXG4gICAgICAgIGxldCBiaW5kIHByZXMgZiBwID1cbiAgICAgICAgICAoKiBUT0RPOiBtb3JlIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbj8gKilcbiAgICAgICAgICBub3JtYWxpemUgcHJlcyAoYmluZCBmIHApXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICgqKiBVbmRlcmx5aW5nIFtLXS1tb2R1bGUgb2YgW0FNb2RdLiAqKVxuICAgIG1vZHVsZSBBS01vZCA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID0gQU1vZC50XG4gICAgICB0eXBlIHIgPSBLLnRcbiAgICAgIGxldCBjaW5qIGEgYyB1ID0gQU1vZC5jaW5qIGMgKEEuY2luaiBhIHUpXG4gICAgICAoKiBsZXQgaW5qIGMgdSA9IEFNb2QuY211bCBjIChBLmluaiB1KSAqKVxuICAgICAgbGV0IGNtdWwgYSBjdSA9IEFNb2QuY211bCBjdSAoQS5jbXVsIGEgQS5vbmUpXG4gICAgICBsZXQgaXRlciBmIChwOnQpID1cbiAgICAgICAgQU1vZC5pdGVyIChmdW4gdSBjIC0+IEEuaXRlciAoZnVuIGEgdSAtPiBmIGEgYyB1KSB1KSBwXG5cbiAgICAgICgqKiBNYXAgYSBbS10tbGluZWFyIGZ1bmN0aW9uLiAqKVxuICAgICAgbGV0IG1hcCBmIHAgPVxuICAgICAgICBsZXQgYW5zID0gcmVmIEFNb2QuemVybyBpblxuICAgICAgICBpdGVyIChmdW4gYSBjIHUgLT4gYW5zIDo9IEFNb2QuYWRkICFhbnMgKGNtdWwgYSAoZiBjIHUpKSkgcDtcbiAgICAgICAgIWFuc1xuICAgIGVuZFxuXG4gICAgKCoqIEFycmF5IG9mIEFuaWNrIGNoYWlucyB1cCB0byBkZWdyZWUgbi4gKilcbiAgICBsZXQgY2hhaW5zIHByZXMgbiA9XG4gICAgICBsZXQgY2MgPSBBcnJheS5tYWtlIChuKzEpIFtNLkFuaWNrLmVtcHR5XSBpblxuICAgICAgaWYgbiA+PSAxIHRoZW4gY2MuKDEpIDwtIE0uQW5pY2suc2luZ2xldG9ucyBwcmVzLmdlbmVyYXRvcnM7XG4gICAgICBsZXQgbGVmdCA9IExpc3QubWFwIGZzdCBwcmVzLnJ1bGVzIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbiAtIDEgZG9cbiAgICAgICAgY2MuKGkrMSkgPC0gTS5Bbmljay5leHRlbmQgbGVmdCBjYy4oaSlcbiAgICAgIGRvbmU7XG4gICAgICBjY1xuXG4gICAgKCoqIENvbXB1dGUgdGhlIEFuaWNrIHJlc29sdXRpb24uICopXG4gICAgbGV0IHJlc29sdXRpb24gP2F1Z21lbnRhdGlvbiBwcmVzIG4gPVxuICAgICAgbGV0IGRlYnVnID0gZmFsc2UgaW5cbiAgICAgICgqIFRPRE86IGNoZWNrIHRoYXQgdGhlIFJTIGlzIGNvbnZlcmdlbnQgYW5kIHJlZHVjZWQgKilcbiAgICAgIGxldCBhdWdtZW50YXRpb24gPSBtYXRjaCBhdWdtZW50YXRpb24gd2l0aCBTb21lIGF1Z21lbnRhdGlvbiAtPiBhdWdtZW50YXRpb24gfCBOb25lIC0+IEF1Z21lbnRhdGlvbi5ncmFkZWQgcHJlcyBpblxuICAgICAgaWYgZGVidWcgdGhlbiBQcmludGYucHJpbnRmIFwiUmVzb2x2aW5nLi4uXFxuJSFcIjtcbiAgICAgICgqIFRoZSBBbmljayBjaGFpbnMuICopXG4gICAgICBsZXQgY2MgPSBjaGFpbnMgcHJlcyBuIGluXG4gICAgICAoKiBUaGUgZGlmZmVyZW50aWFsLiAqKVxuICAgICAgbGV0IGVwcyA9IGF1Z21lbnRhdGlvbiBpblxuICAgICAgbGV0IGV0YSBhID0gQS5jaW5qIGEgTS5vbmUgaW5cbiAgICAgIGxldCBkID0gQXJyYXkuaW5pdCBuIChmdW4gXyAtPiBBTW9kLk1hcC56ZXJvKSBpblxuICAgICAgTGlzdC5pdGVyIChmdW4geCAtPlxuICAgICAgICBkLigwKSA8LSBBTW9kLk1hcC5zZXQgZC4oMClcbiAgICAgICAgICAoTS5Bbmljay5zaW5nbGV0b24geClcbiAgICAgICAgICAoQU1vZC5jaW5qXG4gICAgICAgICAgICAgKE0uQW5pY2suZW1wdHkpXG4gICAgICAgICAgICAgKGxldCB4ID0gQS5pbmogKE0uaW5qIHgpIGluXG4gICAgICAgICAgICAgIEEuc3ViIHggKGV0YSAoZXBzIHgpKSlcbiAgICAgICAgICApO1xuICAgICAgICBpZiBkZWJ1ZyB0aGVuIFByaW50Zi5wcmludGYgXCJkMCglcykgPSAlc1xcbiUhXCJcbiAgICAgICAgICAoWC50b19zdHJpbmcgeCkgKEFNb2QudG9fc3RyaW5nIChBTW9kLk1hcC5hcHAgZC4oMCkgKE0uQW5pY2suc2luZ2xldG9uIHgpKSlcbiAgICAgICkgcHJlcy5nZW5lcmF0b3JzO1xuICAgICAgKCogVGhlIGNvbnRyYWN0aW5nIGhvbW90b3B5LiAqKVxuICAgICAgbGV0IHJlYyBjaCBuIHAgPVxuICAgICAgICBpZiBkZWJ1ZyB0aGVuIFByaW50Zi5wcmludGYgXCJpJWQoJXMpID0gP1xcbiUhXCIgbiAoQU1vZC50b19zdHJpbmcgcCk7XG4gICAgICAgIEFNb2QuaXRlciAoZnVuIHUgYyAtPiBhc3NlcnQgKE0uQW5pY2subGVuZ3RoIGMgPSBuKSkgcDtcbiAgICAgICAgYXNzZXJ0IChuID0gMCB8fCBBTW9kLmVxIEFNb2QuemVybyAoQU1vZC5NYXAuYmluZCBwcmVzIGQuKG4tMSkgcCkpO1xuICAgICAgICBpZiBBTW9kLmVxIEFNb2QuemVybyBwIHRoZW4gQU1vZC56ZXJvXG4gICAgICAgIGVsc2UgaWYgbiA9IDAgdGhlblxuICAgICAgICAgICgqIENvbnRyYWN0LiAqKVxuICAgICAgICAgIGxldCBhbnMgPSByZWYgQU1vZC56ZXJvIGluXG4gICAgICAgICAgQUtNb2QuaXRlciAoZnVuIGEgYyB1IC0+XG4gICAgICAgICAgICBpZiBNLmxlbmd0aCB1ID0gMCB0aGVuXG4gICAgICAgICAgICAgICgqIGFzc2VydCAoTS5sZW5ndGggdSA+IDApICopXG4gICAgICAgICAgICAgICgqIFRPRE86IHRoaXMgaXMgbWVzc3kgYnV0IHNob3VsZCB3b3JrIChpbnN0ZWFkIEFuaWNrIGRlZmluZXMgdGhlIGltYWdlIG9mIHUtMSkgKilcbiAgICAgICAgICAgICAgKClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgZm9yIGkgPSAwIHRvIE0ubGVuZ3RoIHUgLSAxIGRvXG4gICAgICAgICAgICAgICAgbGV0IHYgPSBNLnN1YiB1IDAgaSBpblxuICAgICAgICAgICAgICAgIGxldCBjID0gTS5Bbmljay5zaW5nbGV0b24gdS4oaSkgaW5cbiAgICAgICAgICAgICAgICBsZXQgdSA9IE0uc3ViIHUgKGkrMSkgKE0ubGVuZ3RoIHUgLSAoaSsxKSkgaW5cbiAgICAgICAgICAgICAgICBsZXQgYSA9IEsubXVsIGEgKGVwcyAoQS5pbmogdikpIGluXG4gICAgICAgICAgICAgICAgYW5zIDo9IEFNb2QuYWRkICFhbnMgKEFLTW9kLmNpbmogYSBjIHUpXG4gICAgICAgICAgICAgIGRvbmVcbiAgICAgICAgICApIHA7XG4gICAgICAgICAgIWFuc1xuICAgICAgICBlbHNlXG4gICAgICAgICAgKCogQ29tcHV0ZSBsZWFkaW5nIG1vbm9taWFsLiAqKVxuICAgICAgICAgIGxldCBhID0gcmVmIEsuemVybyBpblxuICAgICAgICAgIGxldCBjID0gcmVmIE0uQW5pY2suZW1wdHkgaW5cbiAgICAgICAgICBsZXQgdSA9IHJlZiBNLm9uZSBpblxuICAgICAgICAgIGxldCBjdSA9IHJlZiBNLm9uZSBpblxuICAgICAgICAgICgqIFRPRE86IHJlbW92ZSB0aGlzIHdoZW4gdGhlIGFsZ29yaXRobSBpcyB3b3JraW5nICopXG4gICAgICAgICAgaWYgbm90IChBTW9kLmVxIEFNb2QuemVybyAoQU1vZC5NYXAuYmluZCBwcmVzIGQuKG4tMSkgcCkpIHRoZW5cbiAgICAgICAgICAgICgqIFdlIGFyZSBvbmx5IGRlZmluZWQgb24gdGhlIGtlcm5lbC4gKilcbiAgICAgICAgICAgIGZhaWx3aXRoIChBTW9kLnRvX3N0cmluZyBwIF4gXCIgbm90IGluIHRoZSBrZXJuZWwuXFxuJSFcIik7XG4gICAgICAgICAgQUtNb2QuaXRlciAoZnVuIGEnIGMnIHUnIC0+XG4gICAgICAgICAgICBsZXQgY3UnID0gTS5tdWwgKE0uQW5pY2suZXZhbCBjJykgdScgaW5cbiAgICAgICAgICAgIGlmIHByZXMubGVxICFjdSBjdScgdGhlblxuICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgYXNzZXJ0IChub3QgKEsuZXEgYScgSy56ZXJvKSk7XG4gICAgICAgICAgICAgICAgYSA6PSBhJztcbiAgICAgICAgICAgICAgICBjIDo9IGMnO1xuICAgICAgICAgICAgICAgIHUgOj0gdSc7XG4gICAgICAgICAgICAgICAgY3UgOj0gY3UnXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICApIHA7XG4gICAgICAgICAgbGV0IGEgPSAhYSBpblxuICAgICAgICAgIGxldCBjID0gIWMgaW5cbiAgICAgICAgICBsZXQgdSA9ICF1IGluXG4gICAgICAgICAgKCogRmluZCB3aGVyZSBjbiB1IGlzIGxlZnRtb3N0IHJlZHVjaWJsZS4gKilcbiAgICAgICAgICBsZXQgY24gPSBNLkFuaWNrLmhkIGMgaW5cbiAgICAgICAgICBsZXQgY25sID0gTS5sZW5ndGggY24gaW5cbiAgICAgICAgICBsZXQgY251ID0gTS5tdWwgY24gdSBpblxuICAgICAgICAgIGxldCBjbnVsID0gTS5sZW5ndGggY251IGluXG4gICAgICAgICAgbGV0IGkgPVxuICAgICAgICAgICAgbGV0IGFucyA9IHJlZiAoLTEpIGluXG4gICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICAgZm9yIGkgPSAwIHRvIGNudWwgLSAxIGRvXG4gICAgICAgICAgICAgICAgTGlzdC5pdGVyIChmdW4gKHYsXykgLT5cbiAgICAgICAgICAgICAgICAgIGxldCB2bCA9IE0ubGVuZ3RoIHYgaW5cbiAgICAgICAgICAgICAgICAgIGlmIGkgKyB2bCA8PSBjbnVsICYmIE0ucGVxIGNudSBpIHYgMCB2bCB0aGVuXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICBhbnMgOj0gaSArIHZsIC0gY25sO1xuICAgICAgICAgICAgICAgICAgICAgIHJhaXNlIEV4aXRcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkgcHJlcy5ydWxlc1xuICAgICAgICAgICAgICBkb25lO1xuICAgICAgICAgICAgICBQcmludGYucHJpbnRmIFwiZmFpbGVkIChub24tcmVkdWNpYmxlKTogJXNcXG4lIVwiIChBTW9kLnRvX3N0cmluZyBwKTtcbiAgICAgICAgICAgICAgbGV0IGxlYWRpbmcgPSBBS01vZC5jaW5qIGEgYyB1IGluXG4gICAgICAgICAgICAgIFByaW50Zi5wcmludGYgXCJsZWFkaW5nOiAlc1xcbiUhXCIgKEFNb2QudG9fc3RyaW5nIGxlYWRpbmcpO1xuICAgICAgICAgICAgICBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgIHwgRXhpdCAtPiAhYW5zXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgdScgPSBNLnN1YiB1IDAgaSBpblxuICAgICAgICAgIGxldCB1JycgPSBNLnN1YiB1IGkgKE0ubGVuZ3RoIHUgLSBpKSBpblxuICAgICAgICAgIGxldCBjJyA9IHUnIDo6IGMgaW5cbiAgICAgICAgICBsZXQgYW5zID0gQUtNb2QuY2luaiBhIGMnIHUnJyBpblxuICAgICAgICAgIGxldCBhbnMgPSBBTW9kLm5vcm1hbGl6ZSBwcmVzIGFucyBpblxuICAgICAgICAgICgqIENvbXB1dGUgdGhlIHJlbWFpbmRlci4gKilcbiAgICAgICAgICBsZXQgYW5zJyA9IEFNb2QuTWFwLmJpbmQgcHJlcyBkLihuKSBhbnMgaW5cbiAgICAgICAgICBsZXQgcCcgPSBBTW9kLnN1YiBwIGFucycgaW5cbiAgICAgICAgICBsZXQgcCcgPSBBTW9kLm5vcm1hbGl6ZSBwcmVzIHAnIGluXG4gICAgICAgICAgbGV0IGFucycgPSBjaCBuIHAnIGluXG4gICAgICAgICAgbGV0IGFucyA9IEFNb2Qubm9ybWFsaXplIHByZXMgKEFNb2QuYWRkIGFucyBhbnMnKSBpblxuICAgICAgICAgIGlmIGRlYnVnIHRoZW4gUHJpbnRmLnByaW50ZiBcImklZCglcykgPSAlc1xcbiUhXCIgbiAoQU1vZC50b19zdHJpbmcgcCkgKEFNb2QudG9fc3RyaW5nIGFucyk7XG4gICAgICAgICAgYW5zXG4gICAgICBpblxuICAgICAgKCogRmlsbCBpbiBoaWdoZXIgZGlmZmVyZW50aWFscy4gKilcbiAgICAgIGZvciBpID0gMSB0byBuIC0gMSBkb1xuICAgICAgICBMaXN0Lml0ZXIgKGZ1biBjIC0+XG4gICAgICAgICAgaWYgZGVidWcgdGhlbiBQcmludGYucHJpbnRmIFwiXFxuZGlmZiVkKCVzKSA9ID9cXG4lIVwiIGkgKE0uQW5pY2sudG9fc3RyaW5nIGMpO1xuICAgICAgICAgIGxldCB1ID0gTS5Bbmljay5oZCBjIGluXG4gICAgICAgICAgbGV0IGMnID0gTS5Bbmljay50bCBjIGluXG4gICAgICAgICAgbGV0IHAgPSBBTW9kLmNtdWwgKEFNb2QuaW5qIGMnKSAoQS5pbmogdSkgaW5cbiAgICAgICAgICAoKiBQcmludGYucHJpbnRmIFwicDogJXNcXG4lIVwiIChBTW9kLnRvX3N0cmluZyBwKTsgKilcbiAgICAgICAgICBsZXQgcCcgPSBBTW9kLk1hcC5iaW5kIHByZXMgZC4oaS0xKSBwIGluXG4gICAgICAgICAgKCogUHJpbnRmLnByaW50ZiBcInAnOiAlc1xcbiUhXCIgKEFNb2QudG9fc3RyaW5nIHAnKTsgKilcbiAgICAgICAgICBsZXQgcCcgPSBjaCAoaS0xKSBwJyBpblxuICAgICAgICAgIGxldCBwID0gQU1vZC5zdWIgcCBwJyBpblxuICAgICAgICAgIGxldCBwID0gQU1vZC5ub3JtYWxpemUgcHJlcyBwIGluXG4gICAgICAgICAgaWYgZGVidWcgdGhlbiBQcmludGYucHJpbnRmIFwiZCVkKCVzKSA9ICVzXFxuXCIgaSAoTS5Bbmljay50b19zdHJpbmcgYykgKEFNb2QudG9fc3RyaW5nIHApO1xuICAgICAgICAgIGQuKGkpIDwtIEFNb2QuTWFwLnNldCBkLihpKSBjIHBcbiAgICAgICAgKSBjYy4oaSsxKVxuICAgICAgZG9uZTtcbiAgICAgIGxldCBjYyA9IEFycmF5Lm1hcCAoZnVuIGwgLT4gQU1vZC5QcmVzLm1ha2UgKEFycmF5Lm9mX2xpc3QgbCkpIGNjIGluXG4gICAgICBsZXQgZCA9IEFycmF5Lm1hcGkgKGZ1biBpIGQgLT4gQU1vZC5QcmVzLk1hcC5vZl9tYXAgZCBjYy4oaSsxKSBjYy4oaSkpIGQgaW5cbiAgICAgIEFNb2QuUHJlcy5Db21wbGV4Lm1ha2UgY2MgZFxuXG4gICAgbW9kdWxlIEtNb2QgPSBNb2R1bGUuRnJlZShLKShNLkFuaWNrKVxuICAgIG1vZHVsZSBNRiA9IE1hdHJpeC5GdW5jdG9yKEEpKEspXG4gICAgbW9kdWxlIE1GTCA9IE1GLkxhYmVsZWQoTS5BbmljaykoTS5BbmljaylcblxuICAgICgqKiBUb3IgY29tcGxleCwgd2hvc2UgaG9tb2xvZ3kgaXMgdGhlIG9uZSBvZiB0aGUgYWxnZWJyYSAoaW4gcmlnaHQgQS1tb2R1bGVzKS4gKilcbiAgICBsZXQgY29tcGxleCA/YXVnbWVudGF0aW9uIHByZXMgbiA9XG4gICAgICBsZXQgYXVnbWVudGF0aW9uID0gbWF0Y2ggYXVnbWVudGF0aW9uIHdpdGggU29tZSBhdWdtZW50YXRpb24gLT4gYXVnbWVudGF0aW9uIHwgTm9uZSAtPiBBdWdtZW50YXRpb24uZ3JhZGVkIHByZXMgaW5cbiAgICAgIGxldCByID0gcmVzb2x1dGlvbiB+YXVnbWVudGF0aW9uIHByZXMgbiBpblxuICAgICAgbGV0IGNjID0gQU1vZC5QcmVzLkNvbXBsZXgubW9kdWxlcyByIGluXG4gICAgICBsZXQgZCA9IEFNb2QuUHJlcy5Db21wbGV4Lm1hcHMgciBpblxuICAgICAgKCogVGVuc29yIG1vcnBoaXNtcyBieSB0aGUgYWxnZWJyYS4gKilcbiAgICAgIGxldCBkID1cbiAgICAgICAgbGV0IGlkIHggPSB4IGluXG4gICAgICAgIEFycmF5Lm1hcCAoZnVuIGQgLT5cbiAgICAgICAgICBNRkwubWFwIGlkIGlkIChmdW4gcCAtPlxuICAgICAgICAgICAgKCogbGV0IHggPSByZWYgSy56ZXJvIGluICopXG4gICAgICAgICAgICAoKiBsZXQgcCA9IG5vcm1hbGl6ZSBwcmVzIHAgaW4gKilcbiAgICAgICAgICAgICgqIEEuaXRlciAoZnVuIHkgdSAtPiB4IDo9IEsuYWRkICF4IHkpIHA7ICopXG4gICAgICAgICAgICAoKiAheCAqKVxuICAgICAgICAgICAgbGV0IHAgPSBub3JtYWxpemUgcHJlcyBwIGluXG4gICAgICAgICAgICBhdWdtZW50YXRpb24gcFxuICAgICAgICAgICkgZFxuICAgICAgICApIGRcbiAgICAgIGluXG4gICAgICBLTW9kLlByZXMuQ29tcGxleC5tYWtlIGNjIGRcblxuICAgIGxldCBiZXR0aSA/YXVnbWVudGF0aW9uIHByZXMgbiA9XG4gICAgICBsZXQgYyA9IGNvbXBsZXggP2F1Z21lbnRhdGlvbiBwcmVzIChuKzEpIGluXG4gICAgICBLTW9kLlByZXMuQ29tcGxleC5iZXR0aSBjXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBHZW5lcmF0ZSAoSyA6IEZpZWxkLlQpIChYIDogQWxwaGFiZXQuVCB3aXRoIHR5cGUgdCA9IGludCkgPSBzdHJ1Y3RcbiAgbW9kdWxlIFByZXMgPSBQcmVzKEspKFgpXG4gIG9wZW4gUHJlc1xuICBtb2R1bGUgTSA9IFByZXMuTVxuICBtb2R1bGUgQSA9IFByZXMuQVxuXG4gIGxldCBpbnRzZXQgbiA9XG4gICAgbGV0IHJlYyBhdXggayA9XG4gICAgICBpZiBrID49IG4gdGhlbiBbXSBlbHNlXG4gICAgICAgIGs6OihhdXggKGsrMSkpXG4gICAgaW5cbiAgICBhdXggMFxuXG4gIGxldCBicmFpZCBsZXEgbiA9XG4gICAgbGV0IGdlbmVyYXRvcnMgPSBpbnRzZXQgbiBpblxuICAgIGxldCByZWxhdGlvbnMgPSByZWYgW10gaW5cbiAgICBmb3IgaSA9IDAgdG8gbiAtIDIgZG9cbiAgICAgcmVsYXRpb25zIDo9IChBLnN1YiAoQS5pbmogW3xpO2krMTtpfF0pIChBLmluaiBbfGkrMTtpO2krMXxdKSkgOjogIXJlbGF0aW9uc1xuICAgIGRvbmU7XG4gICAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgICBmb3IgaiA9IGkgKyAyIHRvIG4gLSAxIGRvXG4gICAgICAgIHJlbGF0aW9ucyA6PSAoQS5zdWIgKEEuaW5qIFt8aTtqfF0pIChBLmluaiBbfGo7aXxdKSkgOjogIXJlbGF0aW9uc1xuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgbGV0IHJlbGF0aW9ucyA9IExpc3QucmV2ICFyZWxhdGlvbnMgaW5cbiAgICBtYWtlIGxlcSBnZW5lcmF0b3JzIHJlbGF0aW9uc1xuXG4gICgqKiBUaGUgc3ltbWV0cmljIGFsZ2VicmEuICopXG4gIGxldCBzeW1tZXRyaWMgbGVxIG4gPVxuICAgIGxldCBnZW5lcmF0b3JzID0gaW50c2V0IG4gaW5cbiAgICBsZXQgcmVsYXRpb25zID0gcmVmIFtdIGluXG4gICAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgICBmb3IgaiA9IGkgKyAxIHRvIG4gLSAxIGRvXG4gICAgICAgIHJlbGF0aW9ucyA6PSAoQS5zdWIgKEEuaW5qIFt8aTtqfF0pIChBLmluaiBbfGo7aXxdKSkgOjogIXJlbGF0aW9uc1xuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgbGV0IHJlbGF0aW9ucyA9IExpc3QucmV2ICFyZWxhdGlvbnMgaW5cbiAgICBtYWtlIGxlcSBnZW5lcmF0b3JzIHJlbGF0aW9uc1xuXG4gIGxldCBleHRlcmlvciBsZXEgbiA9XG4gICAgbGV0IGdlbmVyYXRvcnMgPSBpbnRzZXQgbiBpblxuICAgIGxldCByZWxhdGlvbnMgPSByZWYgW10gaW5cbiAgICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICAgIGZvciBqID0gaSArIDEgdG8gbiAtIDEgZG9cbiAgICAgICAgcmVsYXRpb25zIDo9IChBLnN1YiAoQS5pbmogW3xpO2p8XSkgKEEuY2luaiAoSy5uZWcgSy5vbmUpIFt8ajtpfF0pKSA6OiAhcmVsYXRpb25zXG4gICAgICBkb25lXG4gICAgZG9uZTtcbiAgICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICAgIHJlbGF0aW9ucyA6PSAoQS5pbmogW3xpO2l8XSkgOjogIXJlbGF0aW9uc1xuICAgIGRvbmU7XG4gICAgbGV0IHJlbGF0aW9ucyA9IExpc3QucmV2ICFyZWxhdGlvbnMgaW5cbiAgICBtYWtlIGxlcSBnZW5lcmF0b3JzIHJlbGF0aW9uc1xuZW5kXG4iLG51bGwsbnVsbCwiKCoqIFBvbHlub21pYWwgZXhwcmVzc2lvbnMuICopXG50eXBlIHQgPVxuICB8IE11bCBvZiB0ICogdFxuICB8IE9uZVxuICB8IFplcm9cbiAgfCBHZW4gb2YgY2hhclxuICB8IEFkZCBvZiB0ICogdFxuICB8IFN1YiBvZiB0ICogdFxuICB8IE5lZyBvZiB0XG5cbmxldCB0b19zdHJpbmcgcCA9XG4gIGxldCByZWMgYXV4ID0gZnVuY3Rpb25cbiAgICB8IE11bCAocCxxKSAtPiBhdXggcCBeIFwiKlwiIF4gYXV4IHFcbiAgICB8IE9uZSAtPiBcIjFcIlxuICAgIHwgWmVybyAtPiBcIjBcIlxuICAgIHwgR2VuIGMgLT4gU3RyaW5nLm1ha2UgMSBjXG4gICAgfCBBZGQgKHAscSkgLT4gYXV4IHAgXiBcIitcIiBeIGF1eCBxXG4gICAgfCBTdWIgKHAscSkgLT4gYXV4IHAgXiBcIi1cIiBeIGF1eCBxXG4gICAgfCBOZWcgcCAtPiBcIi1cIiBeIGF1eCBwXG4gIGluXG4gIGF1eCBwXG5cblxuIiwidHlwZSB0b2tlbiA9XG4gIHwgSU5UIG9mIChpbnQpXG4gIHwgQUREXG4gIHwgU1VCXG4gIHwgTVVMXG4gIHwgUE9XXG4gIHwgTFBBUlxuICB8IFJQQVJcbiAgfCBDSEFSIG9mIChjaGFyKVxuICB8IEVPRlxuXG5vcGVuIFBhcnNpbmc7O1xubGV0IF8gPSBwYXJzZV9lcnJvcjs7XG4jIDIgXCJ0b29scy9iZXJnbWFuL3BhcnNlci5tbHlcIlxub3BlbiBQb2xcblxubGV0IHJlYyBtdWxzID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBPbmVcbiAgfCBbeF0gLT4geFxuICB8IHg6OmwgLT4gTXVsICh4LCBtdWxzIGwpXG5cbmxldCByZWMgcG93IHAgPSBmdW5jdGlvblxuICB8IDAgLT4gT25lXG4gIHwgMSAtPiBwXG4gIHwgbiAtPiBNdWwgKHAsIHBvdyBwIChuLTEpKVxuIyAyNyBcInRvb2xzL2JlcmdtYW4vcGFyc2VyLm1sXCJcbmxldCB5eXRyYW5zbF9jb25zdCA9IFt8XG4gIDI1OCAoKiBBREQgKik7XG4gIDI1OSAoKiBTVUIgKik7XG4gIDI2MCAoKiBNVUwgKik7XG4gIDI2MSAoKiBQT1cgKik7XG4gIDI2MiAoKiBMUEFSICopO1xuICAyNjMgKCogUlBBUiAqKTtcbiAgICAwICgqIEVPRiAqKTtcbiAgICAwfF1cblxubGV0IHl5dHJhbnNsX2Jsb2NrID0gW3xcbiAgMjU3ICgqIElOVCAqKTtcbiAgMjY0ICgqIENIQVIgKik7XG4gICAgMHxdXG5cbmxldCB5eWxocyA9IFwiXFwyNTVcXDI1NVxcXG5cXDAwMVxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcXG5cXDAwMlxcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwMFxcMDAwXCJcblxubGV0IHl5bGVuID0gXCJcXDAwMlxcMDAwXFxcblxcMDAyXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDFcXDAwMFxcMDAxXFwwMDBcXDAwMlxcMDAwXFxcblxcMDAzXFwwMDBcXDAwMlxcMDAwXFwwMDFcXDAwMFxcMDAyXFwwMDBcIlxuXG5sZXQgeXlkZWZyZWQgPSBcIlxcMDAwXFwwMDBcXFxuXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwN1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTJcXDAwMFxcMDAwXFwwMDBcXFxuXFwwMDZcXDAwMFxcMDA4XFwwMDBcXDAwMFxcMDAwXFwwMTBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuXFwwMDFcXDAwMFxcMDA5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXCJcblxubGV0IHl5ZGdvdG8gPSBcIlxcMDAyXFwwMDBcXFxuXFwwMDdcXDAwMFxcMDA4XFwwMDBcXDAwOVxcMDAwXCJcblxubGV0IHl5c2luZGV4ID0gXCJcXDI1NVxcMjU1XFxcblxcMDAzXFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAzXFwyNTVcXDAwM1xcMjU1XFwyNTNcXDI1NFxcMDAwXFwwMDBcXDAxOVxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMjVcXDI1NVxcMDAwXFwwMDBcXDAwM1xcMjU1XFwwMDNcXDI1NVxcMDAzXFwyNTVcXDAwN1xcMjU1XFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTRcXDI1NFxcMjU0XFwyNTRcXDAwOVxcMjU1XFwwMDBcXDAwMFwiXG5cbmxldCB5eXJpbmRleCA9IFwiXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDEwXFwwMDBcXDAxM1xcMDAwXFwwMDdcXDAwMFxcMDAwXFwwMDBcIlxuXG5sZXQgeXlnaW5kZXggPSBcIlxcMDAwXFwwMDBcXFxuXFwwMDBcXDAwMFxcMDExXFwwMDBcXDAwNlxcMDAwXCJcblxubGV0IHl5dGFibGVzaXplID0gMjgwXG5sZXQgeXl0YWJsZSA9IFwiXFwwMDFcXDAwMFxcXG5cXDAxMVxcMDAwXFwwMTVcXDAwMFxcMDE2XFwwMDBcXDAwM1xcMDAwXFwwMDZcXDAwMFxcMDA0XFwwMDBcXDAwM1xcMDAwXFwwMjJcXDAwMFxcXG5cXDAwNVxcMDAwXFwwMDJcXDAwMFxcMDA2XFwwMDBcXDAxMlxcMDAwXFwwMDRcXDAwMFxcMDE2XFwwMDBcXDAxMFxcMDAwXFwwMTFcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcXG5cXDAyMFxcMDAwXFwwMjFcXDAwMFxcMDEzXFwwMDBcXDAxNFxcMDAwXFwwMTVcXDAwMFxcMDE2XFwwMDBcXDAwMFxcMDAwXFwwMThcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDExXFwwMDBcXDAxMVxcMDAwXFwwMTFcXDAwMFxcMDExXFwwMDBcXDAwMFxcMDAwXFwwMTFcXDAwMFxcXG5cXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAzXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG5cXDAwMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNFxcMDAwXFwwMTNcXDAwMFxcMDE0XFwwMDBcXDAxNVxcMDAwXFwwMTZcXDAwMFwiXG5cbmxldCB5eWNoZWNrID0gXCJcXDAwMVxcMDAwXFxcblxcMDAwXFwwMDBcXDAwNFxcMDAxXFwwMDVcXDAwMVxcMDAxXFwwMDFcXDAwOFxcMDAxXFwwMDNcXDAwMVxcMDAwXFwwMDBcXDAwMVxcMDAxXFxcblxcMDA2XFwwMDFcXDAwMFxcMDAwXFwwMDhcXDAwMVxcMDA2XFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMVxcMDA0XFwwMDBcXDAwNVxcMDAwXFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAxM1xcMDAwXFxcblxcMDE0XFwwMDBcXDAxNVxcMDAwXFwwMDJcXDAwMVxcMDAzXFwwMDFcXDAwNFxcMDAxXFwwMDVcXDAwMVxcMjU1XFwyNTVcXDAwN1xcMDAxXFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDJcXDAwMVxcMDAzXFwwMDFcXDAwNFxcMDAxXFwwMDVcXDAwMVxcMjU1XFwyNTVcXDAwN1xcMDAxXFxcblxcMDAyXFwwMDFcXDAwM1xcMDAxXFwwMDRcXDAwMVxcMDAyXFwwMDFcXDAwM1xcMDAxXFwwMDdcXDAwMVxcMDAyXFwwMDFcXDAwM1xcMDAxXFxcblxcMDA3XFwwMDFcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA3XFwwMDFcXDAwMlxcMDAxXFwwMDNcXDAwMVxcMDA0XFwwMDFcXDAwNVxcMDAxXCJcblxubGV0IHl5bmFtZXNfY29uc3QgPSBcIlxcXG4gIEFERFxcMDAwXFxcbiAgU1VCXFwwMDBcXFxuICBNVUxcXDAwMFxcXG4gIFBPV1xcMDAwXFxcbiAgTFBBUlxcMDAwXFxcbiAgUlBBUlxcMDAwXFxcbiAgRU9GXFwwMDBcXFxuICBcIlxuXG5sZXQgeXluYW1lc19ibG9jayA9IFwiXFxcbiAgSU5UXFwwMDBcXFxuICBDSEFSXFwwMDBcXFxuICBcIlxuXG5sZXQgeXlhY3QgPSBbfFxuICAoZnVuIF8gLT4gZmFpbHdpdGggXCJwYXJzZXJcIilcbjsgKGZ1biBfX2NhbWxfcGFyc2VyX2VudiAtPlxuICAgIGxldCBfMSA9IChQYXJzaW5nLnBlZWtfdmFsIF9fY2FtbF9wYXJzZXJfZW52IDEgOiAnZXhwcikgaW5cbiAgICBPYmoucmVwcihcbiMgMzEgXCJ0b29scy9iZXJnbWFuL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICggXzEgKVxuIyAxNjkgXCJ0b29scy9iZXJnbWFuL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICA6IFBvbC50KSlcbjsgKGZ1biBfX2NhbWxfcGFyc2VyX2VudiAtPlxuICAgIGxldCBfMSA9IChQYXJzaW5nLnBlZWtfdmFsIF9fY2FtbF9wYXJzZXJfZW52IDIgOiAnZXhwcikgaW5cbiAgICBsZXQgXzMgPSAoUGFyc2luZy5wZWVrX3ZhbCBfX2NhbWxfcGFyc2VyX2VudiAwIDogJ2V4cHIpIGluXG4gICAgT2JqLnJlcHIoXG4jIDM0IFwidG9vbHMvYmVyZ21hbi9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICggQWRkIChfMSwgXzMpIClcbiMgMTc3IFwidG9vbHMvYmVyZ21hbi9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgOiAnZXhwcikpXG47IChmdW4gX19jYW1sX3BhcnNlcl9lbnYgLT5cbiAgICBsZXQgXzEgPSAoUGFyc2luZy5wZWVrX3ZhbCBfX2NhbWxfcGFyc2VyX2VudiAyIDogJ2V4cHIpIGluXG4gICAgbGV0IF8zID0gKFBhcnNpbmcucGVla192YWwgX19jYW1sX3BhcnNlcl9lbnYgMCA6ICdleHByKSBpblxuICAgIE9iai5yZXByKFxuIyAzNSBcInRvb2xzL2JlcmdtYW4vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAoIE11bCAoXzEsIF8zKSApXG4jIDE4NSBcInRvb2xzL2JlcmdtYW4vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgIDogJ2V4cHIpKVxuOyAoZnVuIF9fY2FtbF9wYXJzZXJfZW52IC0+XG4gICAgbGV0IF8xID0gKFBhcnNpbmcucGVla192YWwgX19jYW1sX3BhcnNlcl9lbnYgMiA6ICdleHByKSBpblxuICAgIGxldCBfMyA9IChQYXJzaW5nLnBlZWtfdmFsIF9fY2FtbF9wYXJzZXJfZW52IDAgOiAnZXhwcikgaW5cbiAgICBPYmoucmVwcihcbiMgMzYgXCJ0b29scy9iZXJnbWFuL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgKCBTdWIgKF8xLCBfMykgKVxuIyAxOTMgXCJ0b29scy9iZXJnbWFuL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICA6ICdleHByKSlcbjsgKGZ1biBfX2NhbWxfcGFyc2VyX2VudiAtPlxuICAgIGxldCBfMSA9IChQYXJzaW5nLnBlZWtfdmFsIF9fY2FtbF9wYXJzZXJfZW52IDIgOiAnZXhwcikgaW5cbiAgICBsZXQgXzMgPSAoUGFyc2luZy5wZWVrX3ZhbCBfX2NhbWxfcGFyc2VyX2VudiAwIDogaW50KSBpblxuICAgIE9iai5yZXByKFxuIyAzNyBcInRvb2xzL2JlcmdtYW4vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICggcG93IF8xIF8zIClcbiMgMjAxIFwidG9vbHMvYmVyZ21hbi9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgOiAnZXhwcikpXG47IChmdW4gX19jYW1sX3BhcnNlcl9lbnYgLT5cbiAgICBsZXQgXzEgPSAoUGFyc2luZy5wZWVrX3ZhbCBfX2NhbWxfcGFyc2VyX2VudiAwIDogJ2NoYXJzKSBpblxuICAgIE9iai5yZXByKFxuIyAzOCBcInRvb2xzL2JlcmdtYW4vcGFyc2VyLm1seVwiXG4gICAgICAgICAgKCBtdWxzIF8xIClcbiMgMjA4IFwidG9vbHMvYmVyZ21hbi9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgOiAnZXhwcikpXG47IChmdW4gX19jYW1sX3BhcnNlcl9lbnYgLT5cbiAgICBsZXQgXzEgPSAoUGFyc2luZy5wZWVrX3ZhbCBfX2NhbWxfcGFyc2VyX2VudiAwIDogaW50KSBpblxuICAgIE9iai5yZXByKFxuIyAzOSBcInRvb2xzL2JlcmdtYW4vcGFyc2VyLm1seVwiXG4gICAgICAgICggaWYgXzEgPSAwIHRoZW4gWmVybyBlbHNlIGlmIF8xID0gMSB0aGVuIE9uZSBlbHNlIGZhaWx3aXRoIFwidW5leHBlY3RlZCBudW1iZXJcIiApXG4jIDIxNSBcInRvb2xzL2JlcmdtYW4vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgIDogJ2V4cHIpKVxuOyAoZnVuIF9fY2FtbF9wYXJzZXJfZW52IC0+XG4gICAgbGV0IF8yID0gKFBhcnNpbmcucGVla192YWwgX19jYW1sX3BhcnNlcl9lbnYgMCA6ICdleHByKSBpblxuICAgIE9iai5yZXByKFxuIyA0MCBcInRvb2xzL2JlcmdtYW4vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICggTmVnIF8yIClcbiMgMjIyIFwidG9vbHMvYmVyZ21hbi9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgOiAnZXhwcikpXG47IChmdW4gX19jYW1sX3BhcnNlcl9lbnYgLT5cbiAgICBsZXQgXzIgPSAoUGFyc2luZy5wZWVrX3ZhbCBfX2NhbWxfcGFyc2VyX2VudiAxIDogJ2V4cHIpIGluXG4gICAgT2JqLnJlcHIoXG4jIDQxIFwidG9vbHMvYmVyZ21hbi9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAoIF8yIClcbiMgMjI5IFwidG9vbHMvYmVyZ21hbi9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgOiAnZXhwcikpXG47IChmdW4gX19jYW1sX3BhcnNlcl9lbnYgLT5cbiAgICBsZXQgXzEgPSAoUGFyc2luZy5wZWVrX3ZhbCBfX2NhbWxfcGFyc2VyX2VudiAxIDogY2hhcikgaW5cbiAgICBsZXQgXzIgPSAoUGFyc2luZy5wZWVrX3ZhbCBfX2NhbWxfcGFyc2VyX2VudiAwIDogJ2NoYXJzKSBpblxuICAgIE9iai5yZXByKFxuIyA0NSBcInRvb2xzL2JlcmdtYW4vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAoIChHZW4gXzEpOjpfMiApXG4jIDIzNyBcInRvb2xzL2JlcmdtYW4vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgIDogJ2NoYXJzKSlcbjsgKGZ1biBfX2NhbWxfcGFyc2VyX2VudiAtPlxuICAgIGxldCBfMSA9IChQYXJzaW5nLnBlZWtfdmFsIF9fY2FtbF9wYXJzZXJfZW52IDAgOiBjaGFyKSBpblxuICAgIE9iai5yZXByKFxuIyA0NiBcInRvb2xzL2JlcmdtYW4vcGFyc2VyLm1seVwiXG4gICAgICAgICAoIFtHZW4gXzFdIClcbiMgMjQ0IFwidG9vbHMvYmVyZ21hbi9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgOiAnY2hhcnMpKVxuKCogRW50cnkgbWFpbiAqKVxuOyAoZnVuIF9fY2FtbF9wYXJzZXJfZW52IC0+IHJhaXNlIChQYXJzaW5nLllZZXhpdCAoUGFyc2luZy5wZWVrX3ZhbCBfX2NhbWxfcGFyc2VyX2VudiAwKSkpXG58XVxubGV0IHl5dGFibGVzID1cbiAgeyBQYXJzaW5nLmFjdGlvbnM9eXlhY3Q7XG4gICAgUGFyc2luZy50cmFuc2xfY29uc3Q9eXl0cmFuc2xfY29uc3Q7XG4gICAgUGFyc2luZy50cmFuc2xfYmxvY2s9eXl0cmFuc2xfYmxvY2s7XG4gICAgUGFyc2luZy5saHM9eXlsaHM7XG4gICAgUGFyc2luZy5sZW49eXlsZW47XG4gICAgUGFyc2luZy5kZWZyZWQ9eXlkZWZyZWQ7XG4gICAgUGFyc2luZy5kZ290bz15eWRnb3RvO1xuICAgIFBhcnNpbmcuc2luZGV4PXl5c2luZGV4O1xuICAgIFBhcnNpbmcucmluZGV4PXl5cmluZGV4O1xuICAgIFBhcnNpbmcuZ2luZGV4PXl5Z2luZGV4O1xuICAgIFBhcnNpbmcudGFibGVzaXplPXl5dGFibGVzaXplO1xuICAgIFBhcnNpbmcudGFibGU9eXl0YWJsZTtcbiAgICBQYXJzaW5nLmNoZWNrPXl5Y2hlY2s7XG4gICAgUGFyc2luZy5lcnJvcl9mdW5jdGlvbj1wYXJzZV9lcnJvcjtcbiAgICBQYXJzaW5nLm5hbWVzX2NvbnN0PXl5bmFtZXNfY29uc3Q7XG4gICAgUGFyc2luZy5uYW1lc19ibG9jaz15eW5hbWVzX2Jsb2NrIH1cbmxldCBtYWluIChsZXhmdW4gOiBMZXhpbmcubGV4YnVmIC0+IHRva2VuKSAobGV4YnVmIDogTGV4aW5nLmxleGJ1ZikgPVxuICAgKFBhcnNpbmcueXlwYXJzZSB5eXRhYmxlcyAxIGxleGZ1biBsZXhidWYgOiBQb2wudClcbiIsIiV7XG5vcGVuIFBvbFxuXG5sZXQgcmVjIG11bHMgPSBmdW5jdGlvblxuICB8IFtdIC0+IE9uZVxuICB8IFt4XSAtPiB4XG4gIHwgeDo6bCAtPiBNdWwgKHgsIG11bHMgbClcblxubGV0IHJlYyBwb3cgcCA9IGZ1bmN0aW9uXG4gIHwgMCAtPiBPbmVcbiAgfCAxIC0+IHBcbiAgfCBuIC0+IE11bCAocCwgcG93IHAgKG4tMSkpXG4lfVxuXG4ldG9rZW4gPGludD4gSU5UXG4ldG9rZW4gQUREIFNVQiBNVUwgUE9XXG4ldG9rZW4gTFBBUiBSUEFSXG4ldG9rZW4gPGNoYXI+IENIQVJcbiV0b2tlbiBFT0ZcblxuJWxlZnQgQUREIFNVQlxuJWxlZnQgTVVMXG4lbm9uYXNzb2MgUE9XXG4lbm9uYXNzb2MgVU1JTlVTXG5cbiVzdGFydCBtYWluXG4ldHlwZSA8UG9sLnQ+IG1haW5cbiUlXG5cbm1haW46XG4gIHwgZXhwciBFT0YgeyAkMSB9XG5cbmV4cHI6XG4gIHwgZXhwciBBREQgZXhwciB7IEFkZCAoJDEsICQzKSB9XG4gIHwgZXhwciBNVUwgZXhwciB7IE11bCAoJDEsICQzKSB9XG4gIHwgZXhwciBTVUIgZXhwciB7IFN1YiAoJDEsICQzKSB9XG4gIHwgZXhwciBQT1cgSU5UIHsgcG93ICQxICQzIH1cbiAgfCBjaGFycyB7IG11bHMgJDEgfVxuICB8IElOVCB7IGlmICQxID0gMCB0aGVuIFplcm8gZWxzZSBpZiAkMSA9IDEgdGhlbiBPbmUgZWxzZSBmYWlsd2l0aCBcInVuZXhwZWN0ZWQgbnVtYmVyXCIgfVxuICB8IFNVQiBleHByICVwcmVjIFVNSU5VUyB7IE5lZyAkMiB9XG4gIHwgTFBBUiBleHByIFJQQVIgeyAkMiB9XG47XG5cbmNoYXJzOlxuICB8IENIQVIgY2hhcnMgeyAoR2VuICQxKTo6JDIgfVxuICB8IENIQVIgeyBbR2VuICQxXSB9XG47XG4iLCIjIDEgXCJ0b29scy9iZXJnbWFuL2xleGVyLm1sbFwiXG4gXG5vcGVuIFBhcnNlclxuXG4jIDYgXCJ0b29scy9iZXJnbWFuL2xleGVyLm1sXCJcbmxldCBfX29jYW1sX2xleF90YWJsZXMgPSB7XG4gIExleGluZy5sZXhfYmFzZSA9XG4gICBcIlxcMDAwXFwwMDBcXDI0NlxcMjU1XFwwMDFcXDAwMFxcMjQ4XFwyNTVcXDA3NVxcMDAwXFwyNTBcXDI1NVxcMjUxXFwyNTVcXDI1MlxcMjU1XFxcbiAgICBcXDI1M1xcMjU1XFwyNTRcXDI1NVxcMjU1XFwyNTVcIjtcbiAgTGV4aW5nLmxleF9iYWNrdHJrID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwOFxcMDAwXFwyNTVcXDI1NVxcMDA2XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVwiO1xuICBMZXhpbmcubGV4X2RlZmF1bHQgPVxuICAgXCJcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXCI7XG4gIExleGluZy5sZXhfdHJhbnMgPVxuICAgXCJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA2XFwwMDBcXDAwNVxcMDAwXFwwMDhcXDAwMFxcMDEwXFwwMDBcXDAwMFxcMDAwXFwwMDlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA3XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcIjtcbiAgTGV4aW5nLmxleF9jaGVjayA9XG4gICBcIlxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMDAyXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAwXFwwMDBcXDAwMlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVwiO1xuICBMZXhpbmcubGV4X2Jhc2VfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2JhY2t0cmtfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2RlZmF1bHRfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X3RyYW5zX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9jaGVja19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfY29kZSA9XG4gICBcIlwiO1xufVxuXG5sZXQgcmVjIHRva2VuIGxleGJ1ZiA9XG4gICBfX29jYW1sX2xleF90b2tlbl9yZWMgbGV4YnVmIDBcbmFuZCBfX29jYW1sX2xleF90b2tlbl9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlID1cbiAgbWF0Y2ggTGV4aW5nLmVuZ2luZSBfX29jYW1sX2xleF90YWJsZXMgX19vY2FtbF9sZXhfc3RhdGUgbGV4YnVmIHdpdGhcbiAgICAgIHwgMCAtPlxuIyA4IFwidG9vbHMvYmVyZ21hbi9sZXhlci5tbGxcIlxuICAgICAgICAoIEFERCApXG4jIDEyNCBcInRvb2xzL2JlcmdtYW4vbGV4ZXIubWxcIlxuXG4gIHwgMSAtPlxuIyA5IFwidG9vbHMvYmVyZ21hbi9sZXhlci5tbGxcIlxuICAgICAgICAoIFNVQiApXG4jIDEyOSBcInRvb2xzL2JlcmdtYW4vbGV4ZXIubWxcIlxuXG4gIHwgMiAtPlxuIyAxMCBcInRvb2xzL2JlcmdtYW4vbGV4ZXIubWxsXCJcbiAgICAgICAgKCBNVUwgKVxuIyAxMzQgXCJ0b29scy9iZXJnbWFuL2xleGVyLm1sXCJcblxuICB8IDMgLT5cbiMgMTEgXCJ0b29scy9iZXJnbWFuL2xleGVyLm1sbFwiXG4gICAgICAgICggUE9XIClcbiMgMTM5IFwidG9vbHMvYmVyZ21hbi9sZXhlci5tbFwiXG5cbiAgfCA0IC0+XG4jIDEyIFwidG9vbHMvYmVyZ21hbi9sZXhlci5tbGxcIlxuICAgICAgICAoIExQQVIgKVxuIyAxNDQgXCJ0b29scy9iZXJnbWFuL2xleGVyLm1sXCJcblxuICB8IDUgLT5cbiMgMTMgXCJ0b29scy9iZXJnbWFuL2xleGVyLm1sbFwiXG4gICAgICAgICggUlBBUiApXG4jIDE0OSBcInRvb2xzL2JlcmdtYW4vbGV4ZXIubWxcIlxuXG4gIHwgNiAtPlxubGV0XG4jIDE0IFwidG9vbHMvYmVyZ21hbi9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgIG5cbiMgMTU1IFwidG9vbHMvYmVyZ21hbi9sZXhlci5tbFwiXG49IExleGluZy5zdWJfbGV4ZW1lIGxleGJ1ZiBsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wb3MgbGV4YnVmLkxleGluZy5sZXhfY3Vycl9wb3MgaW5cbiMgMTQgXCJ0b29scy9iZXJnbWFuL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgICAgKCBJTlQgKGludF9vZl9zdHJpbmcgbikgKVxuIyAxNTkgXCJ0b29scy9iZXJnbWFuL2xleGVyLm1sXCJcblxuICB8IDcgLT5cbmxldFxuIyAxNSBcInRvb2xzL2JlcmdtYW4vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICBjXG4jIDE2NSBcInRvb2xzL2JlcmdtYW4vbGV4ZXIubWxcIlxuPSBMZXhpbmcuc3ViX2xleGVtZV9jaGFyIGxleGJ1ZiBsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wb3MgaW5cbiMgMTUgXCJ0b29scy9iZXJnbWFuL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBDSEFSIGMgKVxuIyAxNjkgXCJ0b29scy9iZXJnbWFuL2xleGVyLm1sXCJcblxuICB8IDggLT5cbiMgMTYgXCJ0b29scy9iZXJnbWFuL2xleGVyLm1sbFwiXG4gICAgICAgICAgICggdG9rZW4gbGV4YnVmIClcbiMgMTc0IFwidG9vbHMvYmVyZ21hbi9sZXhlci5tbFwiXG5cbiAgfCA5IC0+XG4jIDE3IFwidG9vbHMvYmVyZ21hbi9sZXhlci5tbGxcIlxuICAgICAgICAoIEVPRiApXG4jIDE3OSBcInRvb2xzL2JlcmdtYW4vbGV4ZXIubWxcIlxuXG4gIHwgX19vY2FtbF9sZXhfc3RhdGUgLT4gbGV4YnVmLkxleGluZy5yZWZpbGxfYnVmZiBsZXhidWY7XG4gICAgICBfX29jYW1sX2xleF90b2tlbl9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlXG5cbjs7XG5cbiIsIntcbm9wZW4gUGFyc2VyXG59XG5cbmxldCBzcGFjZSA9ICcgJyB8ICdcXHQnIHwgJ1xccidcblxucnVsZSB0b2tlbiA9IHBhcnNlXG4gIHwgXCIrXCIgeyBBREQgfVxuICB8IFwiLVwiIHsgU1VCIH1cbiAgfCBcIipcIiB7IE1VTCB9XG4gIHwgXCJeXCIgeyBQT1cgfVxuICB8IFwiKFwiIHsgTFBBUiB9XG4gIHwgXCIpXCIgeyBSUEFSIH1cbiAgfCAoWycwJy0nOSddKyBhcyBuKSB7IElOVCAoaW50X29mX3N0cmluZyBuKSB9XG4gIHwgKFsnYSctJ3onJ0EnLSdaJ10gYXMgYykgeyBDSEFSIGMgfVxuICB8IHNwYWNlKyB7IHRva2VuIGxleGJ1ZiB9XG4gIHwgZW9mIHsgRU9GIH1cbiIsIm9wZW4gSnNfb2Zfb2NhbWxcbm9wZW4gQWxnXG5cbm1vZHVsZSBIdG1sID0gRG9tX2h0bWxcblxubGV0IGRvYyA9IEh0bWwuZG9jdW1lbnRcbmxldCBidXR0b24gdHh0IGFjdGlvbiA9XG4gIGxldCBidXR0b25fdHlwZSA9IEpzLnN0cmluZyBcImJ1dHRvblwiIGluXG4gIGxldCBiID0gSHRtbC5jcmVhdGVJbnB1dCB+X3R5cGU6YnV0dG9uX3R5cGUgZG9jIGluXG4gIGIjIy52YWx1ZSA6PSBKcy5zdHJpbmcgdHh0O1xuICBiIyMub25jbGljayA6PSBEb21faHRtbC5oYW5kbGVyIChmdW4gXyAtPiBhY3Rpb24gKCk7IEpzLl90cnVlKTtcbiAgYlxuXG5sZXQgZGVidWcgcyA9XG4gIEZpcmVidWcuY29uc29sZSMjZGVidWcgKEpzLnN0cmluZyBzKVxuXG5sZXQganNnZXQgeCA9IEpzLk9wdC5nZXQgeCAoZnVuICgpIC0+IGFzc2VydCBmYWxzZSlcblxuZXhjZXB0aW9uIFBhcnNpbmdcbiAgXG5sZXQgcGFyc2VfcG9sIHMgPVxuICBQYXJzZXIubWFpbiBMZXhlci50b2tlbiAoTGV4aW5nLmZyb21fc3RyaW5nIHMpXG5cbiAgKCpcbiAgbGV0IGxleGVyID0gR2VubGV4Lm1ha2VfbGV4ZXIgW1wiK1wiO1wiLVwiO1wiKlwiO1wiXlwiO1wiKFwiO1wiKVwiXSBpblxuICBsZXQgcmVjIG11bHRzID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGBPbmVcbiAgICB8IFt4XSAtPiB4XG4gICAgfCB4OjpsIC0+IGBNdWwgKHgsIG11bHRzIGwpXG4gIGluXG4gIGZ1biBzIC0+XG4gICAgbGV0IGludCBuID1cbiAgICAgIGlmIG4gPSAwIHRoZW4gYFplcm9cbiAgICAgIGVsc2UgaWYgbiA9IDEgdGhlbiBgT25lXG4gICAgICBlbHNlIGlmIG4gPSAtMSB0aGVuIGBOZWcgYE9uZVxuICAgICAgZWxzZSByYWlzZSBQYXJzaW5nXG4gICAgaW5cbiAgICBsZXQgcmVjIGFkZCA9IHBhcnNlclxuICAgICAgfCBbPCBwID0gbXVsIDsgcSA9IGFkZHMgPl0gLT4gcSBwXG4gICAgYW5kIGFkZHMgPSBwYXJzZXJcbiAgICAgICAgfCBbPCAnR2VubGV4Lkt3ZCBcIitcIjsgcSA9IG11bDsgciA9IGFkZHMgPl0gLT4gZnVuIHAgLT4gciAoYEFkZCAocCxxKSlcbiAgICAgICAgfCBbPCAnR2VubGV4Lkt3ZCBcIi1cIjsgcSA9IG11bDsgciA9IGFkZHMgPl0gLT4gZnVuIHAgLT4gciAoYFN1YiAocCxxKSlcbiAgICAgICAgfCBbPCAnR2VubGV4LkludCBuIDsgciA9IGFkZHMgPl0gLT4gZnVuIHAgLT5cbiAgICAgICAgICBpZiBuID49IDAgdGhlbiByYWlzZSBQYXJzaW5nXG4gICAgICAgICAgZWxzZSByIChgU3ViIChwLGludCAoLW4pKSlcbiAgICAgICAgfCBbPCA+XSAtPiBmdW4gcCAtPiBwXG4gICAgYW5kIG11bCA9IHBhcnNlclxuICAgICAgICB8IFs8IHAgPSBleHAgOyBxID0gbXVscyA+XSAtPiBxIHBcbiAgICAgICAgfCBbPCBwID0gZXhwID5dIC0+IHBcbiAgICBhbmQgbXVscyA9IHBhcnNlclxuICAgICAgICB8IFs8ICdHZW5sZXguS3dkIFwiKlwiOyBxID0gZXhwOyByID0gbXVscyA+XSAtPiBmdW4gcCAtPiByIChgTXVsIChwLHEpKVxuICAgICAgICB8IFs8ID5dIC0+IGZ1biBwIC0+IHBcbiAgICBhbmQgZXhwID0gcGFyc2VyXG4gICAgICAgIHwgWzwgcCA9IGF0b207IHEgPSBleHBzID5dIC0+IHEgcFxuICAgIGFuZCBleHBzID0gcGFyc2VyXG4gICAgICAgIHwgWzwgJ0dlbmxleC5Ld2QgXCJeXCIgOyAnR2VubGV4LkludCBuID5dIC0+XG4gICAgICAgICAgIGZ1biBwIC0+XG4gICAgICAgICAgICAgbGV0IHJlYyBhdXggPSBmdW5jdGlvblxuICAgICAgICAgICAgICAgfCAwIC0+IGBPbmVcbiAgICAgICAgICAgICAgIHwgMSAtPiBwXG4gICAgICAgICAgICAgICB8IG4gLT4gYE11bCAocCwgYXV4IChuLTEpKVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgYXV4IG5cbiAgICAgICAgfCBbPCA+XSAtPiBmdW4gcCAtPiBwXG4gICAgYW5kIGF0b20gPSBwYXJzZXJcbiAgICAgICAgfCBbPCAnR2VubGV4LkNoYXIgYyA+XSAtPlxuICAgICAgICAgICBgR2VuIGNcbiAgICAgICAgfCBbPCAnR2VubGV4LklkZW50IHMgPl0gLT5cbiAgICAgICAgICAgbGV0IGFucyA9IHJlZiBbXSBpblxuICAgICAgICAgICBmb3IgaSA9IFN0cmluZy5sZW5ndGggcyAtIDEgZG93bnRvIDAgZG9cbiAgICAgICAgICAgICBhbnMgOj0gKGBHZW4gcy5baV0pIDo6ICFhbnNcbiAgICAgICAgICAgZG9uZTtcbiAgICAgICAgICAgbXVsdHMgIWFuc1xuICAgICAgICB8IFs8ICdHZW5sZXguSW50IG4gPl0gLT4gaW50IG5cbiAgICAgICAgfCBbPCAnR2VubGV4Lkt3ZCBcIi1cIjsgcCA9IGF0b20gPl0gLT4gYE5lZyBwXG4gICAgICAgIHwgWzwgJ0dlbmxleC5Ld2QgXCIoXCI7IHAgPSBhZGQ7ICdHZW5sZXguS3dkIFwiKVwiID5dIC0+IHBcbiAgICBpblxuICAgIGFkZCAobGV4ZXIgKFN0cmVhbS5vZl9zdHJpbmcgcykpXG4gICAqKVxuXG5sZXQgY2hhcl9vZl9zdHJpbmcgcyA9XG4gIGFzc2VydCAoU3RyaW5nLmxlbmd0aCBzID0gMSk7XG4gIHMuWzBdXG5cbm1vZHVsZSBNID0gc3RydWN0XG4gIGluY2x1ZGUgTW9ub2lkLkZyZWUoQWxwaGFiZXQuQ2hhcilcblxuICBsZXQgcyBzIDogdCA9XG4gICAgQXJyYXkuaW5pdCAoU3RyaW5nLmxlbmd0aCBzKSAoZnVuIGkgLT4gcy5baV0pXG5lbmRcbm1vZHVsZSBLID0gRmllbGQuSW50XG5tb2R1bGUgUCA9IEFsZ2VicmEuUHJlcyhLKShBbHBoYWJldC5DaGFyKVxubW9kdWxlIEEgPSBQLkFcblxubGV0IGV2YWxfcG9sIHAgPVxuICBsZXQgcmVjIGF1eCA9IGZ1bmN0aW9uXG4gICAgfCBQb2wuTXVsIChwLHEpIC0+IEEubXVsIChhdXggcCkgKGF1eCBxKVxuICAgIHwgT25lIC0+IEEub25lXG4gICAgfCBaZXJvIC0+IEEuemVyb1xuICAgIHwgR2VuIGMgLT4gQS5pbmogKE0uaW5qIGMpXG4gICAgfCBBZGQgKHAscSkgLT4gQS5hZGQgKGF1eCBwKSAoYXV4IHEpXG4gICAgfCBTdWIgKHAscSkgLT4gQS5zdWIgKGF1eCBwKSAoYXV4IHEpXG4gICAgfCBOZWcgcCAtPiBBLm5lZyAoYXV4IHApXG4gIGluXG4gIGF1eCBwXG5cbigqKiBSZXBsYWNlIFtjXSBieSBbdF0gaW4gW3NdLiAqKVxubGV0IHJlYyByZXBsYWNlIGMgdCBzID1cbiAgdHJ5XG4gICAgbGV0IG4gPSBTdHJpbmcuaW5kZXggcyBjIGluXG4gICAgcmVwbGFjZSBjIHQgKFN0cmluZy5zdWIgcyAwIG4gXiB0IF4gU3RyaW5nLnN1YiBzIChuKzEpIChTdHJpbmcubGVuZ3RoIHMtKG4rMSkpKVxuICB3aXRoXG4gIHwgTm90X2ZvdW5kIC0+IHNcblxubGV0IHJ1biBfID1cbiAgbGV0IHZhcnMgPSBqc2dldCAoSHRtbC5Db2VyY2VUby50ZXh0YXJlYSAoanNnZXQgKGRvYyMjZ2V0RWxlbWVudEJ5SWQoSnMuc3RyaW5nIFwidmFyc1wiKSkpKSBpblxuICBsZXQgcmVsYXRpb25zID0ganNnZXQgKEh0bWwuQ29lcmNlVG8udGV4dGFyZWEgKGpzZ2V0IChkb2MjI2dldEVsZW1lbnRCeUlkKEpzLnN0cmluZyBcInJlbGF0aW9uc1wiKSkpKSBpblxuICBsZXQgb3JkZXIgPSBqc2dldCAoSHRtbC5Db2VyY2VUby5zZWxlY3QgKGpzZ2V0IChkb2MjI2dldEVsZW1lbnRCeUlkKEpzLnN0cmluZyBcIm9yZGVyXCIpKSkpIGluXG4gIGxldCBnZW5lcmF0ZSA9IGpzZ2V0IChIdG1sLkNvZXJjZVRvLnNlbGVjdCAoanNnZXQgKGRvYyMjZ2V0RWxlbWVudEJ5SWQoSnMuc3RyaW5nIFwiZ2VuZXJhdGVcIikpKSkgaW5cbiAgbGV0IGdlbmVyYXRlbiA9IGpzZ2V0IChIdG1sLkNvZXJjZVRvLmlucHV0IChqc2dldCAoZG9jIyNnZXRFbGVtZW50QnlJZChKcy5zdHJpbmcgXCJnZW5lcmF0ZW5cIikpKSkgaW5cbiAgbGV0IGF1Z21lbnRhdGlvbiA9IGpzZ2V0IChIdG1sLkNvZXJjZVRvLnNlbGVjdCAoanNnZXQgKGRvYyMjZ2V0RWxlbWVudEJ5SWQoSnMuc3RyaW5nIFwiYXVnbWVudGF0aW9uXCIpKSkpIGluXG4gIGxldCBtYXhkZWcgPSBqc2dldCAoSHRtbC5Db2VyY2VUby5pbnB1dCAoanNnZXQgKGRvYyMjZ2V0RWxlbWVudEJ5SWQoSnMuc3RyaW5nIFwibWF4ZGVnXCIpKSkpIGluXG4gIGxldCBncm9ibmVyID0ganNnZXQgKGRvYyMjZ2V0RWxlbWVudEJ5SWQoSnMuc3RyaW5nIFwiZ3JvYm5lclwiKSkgaW5cbiAgbGV0IGNoYWlucyA9IGpzZ2V0IChkb2MjI2dldEVsZW1lbnRCeUlkKEpzLnN0cmluZyBcImNoYWluc1wiKSkgaW5cbiAgbGV0IHJlc29sdXRpb24gPSBqc2dldCAoZG9jIyNnZXRFbGVtZW50QnlJZChKcy5zdHJpbmcgXCJyZXNvbHV0aW9uXCIpKSBpblxuICBsZXQgYmV0dGkgPSBqc2dldCAoZG9jIyNnZXRFbGVtZW50QnlJZChKcy5zdHJpbmcgXCJiZXR0aVwiKSkgaW5cbiAgbGV0IGdvID0ganNnZXQgKGRvYyMjZ2V0RWxlbWVudEJ5SWQoSnMuc3RyaW5nIFwiZ29cIikpIGluXG4gIGxldCBzdGF0dXMgPSBqc2dldCAoZG9jIyNnZXRFbGVtZW50QnlJZChKcy5zdHJpbmcgXCJzdGF0dXNcIikpIGluXG4gIGxldCBzdGF0dXMgcyA9IHN0YXR1cyMjLmlubmVySFRNTCA6PSBKcy5zdHJpbmcgcyBpblxuICBsZXQgZXJyb3IgcyA9IHN0YXR1cyAoXCI8ZW0gc3R5bGU9XFxcImNvbG9yOnJlZFxcXCI+XCIgXiBzIF4gXCI8L2VtPlwiKSBpblxuICBcbiAgZ28jIy5vbmNsaWNrIDo9IEh0bWwuaGFuZGxlciAoZnVuIF8gLT5cbiAgICB0cnlcbiAgICAgIGxldCB2YXJzID0gSnMudG9fc3RyaW5nIHZhcnMjIy52YWx1ZSBpblxuICAgICAgbGV0IHJlbGF0aW9ucyA9IEpzLnRvX3N0cmluZyByZWxhdGlvbnMjIy52YWx1ZSBpblxuXG4gICAgICBncm9ibmVyIyMuaW5uZXJIVE1MIDo9IEpzLnN0cmluZyBcIlwiO1xuICAgICAgY2hhaW5zIyMuaW5uZXJIVE1MIDo9IEpzLnN0cmluZyBcIlwiO1xuICAgICAgcmVzb2x1dGlvbiMjLmlubmVySFRNTCA6PSBKcy5zdHJpbmcgXCJcIjtcbiAgICAgIGJldHRpIyMuaW5uZXJIVE1MIDo9IEpzLnN0cmluZyBcIlwiO1xuXG4gICAgICBzdGF0dXMgXCJQYXJzaW5nIHZhcmlhYmxlcy4uLlwiO1xuICAgICAgbGV0IHZhcnMgPSBTdHJpbmcuc3BsaXRfb25fY2hhciAnLCcgdmFycyBpblxuICAgICAgbGV0IHZhcnMgPSBMaXN0Lm1hcCBTdHJpbmcudHJpbSB2YXJzIGluXG4gICAgICBsZXQgdmFycyA9IExpc3QubWFwIGNoYXJfb2Zfc3RyaW5nIHZhcnMgaW5cblxuICAgICAgc3RhdHVzIFwiUGFyc2luZyByZWxhdGlvbnMuLi5cIjtcbiAgICAgIGxldCByZWxhdGlvbnMgPSBTdHJpbmcuc3BsaXRfb25fY2hhciAnLCcgcmVsYXRpb25zIGluXG4gICAgICBsZXQgcmVsYXRpb25zID0gTGlzdC5tYXAgU3RyaW5nLnRyaW0gcmVsYXRpb25zIGluXG4gICAgICBsZXQgcmVsYXRpb25zID1cbiAgICAgICAgdHJ5XG4gICAgICAgICAgTGlzdC5tYXAgcGFyc2VfcG9sIHJlbGF0aW9uc1xuICAgICAgICB3aXRoXG4gICAgICAgIHwgZSAtPiBlcnJvciAoXCJQYXJzaW5nIGVycm9yOiBcIiBeIFByaW50ZXhjLnRvX3N0cmluZyBlKTsgcmFpc2UgRXhpdFxuICAgICAgaW5cbiAgICAgIGdyb2JuZXIjIy5pbm5lckhUTUwgOj0gSnMuc3RyaW5nIChcIlJlbGF0aW9uczogXCIgXiBTdHJpbmcuY29uY2F0IFwiICwgXCIgKExpc3QubWFwIFBvbC50b19zdHJpbmcgcmVsYXRpb25zKSk7XG4gICAgICBsZXQgcmVsYXRpb25zID0gTGlzdC5tYXAgZXZhbF9wb2wgcmVsYXRpb25zIGluXG4gICAgICBsZXQgb3JkZXIgPVxuICAgICAgICBtYXRjaCBKcy50b19zdHJpbmcgb3JkZXIjIy52YWx1ZSB3aXRoXG4gICAgICAgIHwgXCJkZWdsZXhcIiAtPiBNLk9yZGVyLmRlZ2xleCBBbHBoYWJldC5DaGFyLmxlcVxuICAgICAgICB8IFwicmV2ZGVnbGV4XCIgLT4gTS5PcmRlci5kZWdsZXggQWxwaGFiZXQuQ2hhci5nZXFcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgaW5cbiAgICAgIGxldCBwcmVzID0gUC5tYWtlIG9yZGVyIHZhcnMgcmVsYXRpb25zIGluXG4gICAgICBsZXQgYXVnbWVudGF0aW9uID1cbiAgICAgICAgdHJ5XG4gICAgICAgICAgbWF0Y2ggSnMudG9fc3RyaW5nIGF1Z21lbnRhdGlvbiMjLnZhbHVlIHdpdGhcbiAgICAgICAgICB8IFwiYWxnZWJyYVwiIC0+IFAuQXVnbWVudGF0aW9uLmdyYWRlZCBwcmVzXG4gICAgICAgICAgfCBcIm1vbm9pZFwiIC0+IFAuQXVnbWVudGF0aW9uLm1vbm9pZCBwcmVzXG4gICAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICB3aXRoXG4gICAgICAgIHwgUC5BdWdtZW50YXRpb24uSW52YWxpZCAtPlxuICAgICAgICAgICBlcnJvciBcIkludmFsaWQgYXVnbWVudGF0aW9uIVwiO1xuICAgICAgICAgIHJhaXNlIEV4aXRcbiAgICAgIGluXG5cbiAgICAgIHN0YXR1cyBcIkNvbXB1dGluZyBHcsO2Ym5lciBiYXNpcy4uLlwiO1xuICAgICAgbGV0IHByZXMgPSBQLnJlZHVjZSAoUC5idWNoYmVyZ2VyIHByZXMpIGluXG4gICAgICBncm9ibmVyIyMuaW5uZXJIVE1MIDo9IEpzLnN0cmluZyAoUC50b19zdHJpbmcgcHJlcyk7XG4gICAgICBcbiAgICAgIHN0YXR1cyBcIkNvbXB1dGluZyBBbmljayBjaGFpbnMuLi5cIjtcbiAgICAgIGxldCBoZWFkcyA9IFAuaGVhZHMgcHJlcyBpblxuICAgICAgbGV0IGNjID0gTS5Bbmljay5zaW5nbGV0b25zIHZhcnMgaW5cbiAgICAgIGxldCBjYyA9IHJlZiBjYyBpblxuICAgICAgbGV0IHMgPSByZWYgXCJcIiBpblxuICAgICAgZm9yIGkgPSAwIHRvIDYgZG9cbiAgICAgICAgcyA6PSAhcyBeIHN0cmluZ19vZl9pbnQgaSBeIFwiIGNoYWluczogXCIgXiBTdHJpbmcuY29uY2F0IFwiIFwiIChMaXN0Lm1hcCBNLkFuaWNrLnRvX3N0cmluZyAhY2MpIF4gXCI8YnIvPlwiO1xuICAgICAgICBjaGFpbnMjIy5pbm5lckhUTUwgOj0gSnMuc3RyaW5nICFzO1xuICAgICAgICBjYyA6PSBNLkFuaWNrLmV4dGVuZCBoZWFkcyAhY2NcbiAgICAgIGRvbmU7XG5cbiAgICAgIHN0YXR1cyBcIkNvbXB1dGluZyByZXNvbHV0aW9uLi4uXCI7XG4gICAgICBsZXQgbWF4ZGVnID0gaW50X29mX3N0cmluZyAoSnMudG9fc3RyaW5nIG1heGRlZyMjLnZhbHVlKSBpblxuICAgICAgbGV0IGQgPSBQLkFuaWNrLnJlc29sdXRpb24gfmF1Z21lbnRhdGlvbiBwcmVzIChtYXhkZWcrMSkgaW5cbiAgICAgIHJlc29sdXRpb24jIy5pbm5lckhUTUwgOj0gSnMuc3RyaW5nIChyZXBsYWNlICdcXG4nIFwiPGJyLz5cIiAoUC5Bbmljay5BTW9kLlByZXMuQ29tcGxleC50b19zdHJpbmcgZCkpO1xuXG4gICAgICBzdGF0dXMgXCJDb21wdXRpbmcgQmV0dGkgbnVtYmVycy4uLlwiO1xuICAgICAgbGV0IHMgPSByZWYgXCJcIiBpblxuICAgICAgbGV0IGggPSBQLkFuaWNrLmJldHRpIH5hdWdtZW50YXRpb24gcHJlcyBtYXhkZWcgaW5cbiAgICAgIEFycmF5Lml0ZXJpIChmdW4gaSBuIC0+IHMgOj0gIXMgXiBcIkhcIiBeIHN0cmluZ19vZl9pbnQgaSBeIFwiID0gXCIgXiBzdHJpbmdfb2ZfaW50IG4gXiBcIjxici8+XCIpIGg7XG4gICAgICBiZXR0aSMjLmlubmVySFRNTCA6PSBKcy5zdHJpbmcgIXM7XG5cbiAgICAgIHN0YXR1cyBcIkRvbmUuXCI7XG4gICAgICBKcy5fdHJ1ZVxuICAgIHdpdGhcbiAgICB8IEV4aXQgLT5cbiAgICAgICBKcy5fZmFsc2VcbiAgICB8IEZhaWx1cmUgcyAtPlxuICAgICAgIGVycm9yIChcIkVycm9yOiBcIiBeIHMpO1xuICAgICAgSnMuX2ZhbHNlXG4gICAgfCBOb3RfZm91bmQgLT5cbiAgICAgICBlcnJvciBcIk5vdF9mb3VuZC4uLlwiO1xuICAgICAgSnMuX2ZhbHNlXG4gICk7XG5cbiAgbGV0IGdlbmVyYXRlX2hhbmRsZXIgXyA9XG4gICAgbGV0IGxpc3RfaW5pdCBuIGYgPVxuICAgICAgbGV0IHJlYyBhdXggayA9IGlmIGsgPj0gbiB0aGVuIFtdIGVsc2UgKGYgayk6OihhdXggKGsrMSkpIGluXG4gICAgICBhdXggMFxuICAgIGluXG4gICAgbGV0IHNldCB2IHIgPVxuICAgICAgdmFycyMjLnZhbHVlIDo9IEpzLnN0cmluZyB2O1xuICAgICAgcmVsYXRpb25zIyMudmFsdWUgOj0gSnMuc3RyaW5nIHJcbiAgICBpblxuICAgIGxldCBnZW4gbiA9IFN0cmluZy5tYWtlIDEgKGNoYXJfb2ZfaW50IChuICsgaW50X29mX2NoYXIgJ2EnKSkgaW5cbiAgICAoKiBsZXQgZ2VuJyBuID0gU3RyaW5nLm1ha2UgMSAoY2hhcl9vZl9pbnQgKG4gKyBpbnRfb2ZfY2hhciAnQScpKSBpbiAqKVxuICAgIGxldCBzeW0gbiA9XG4gICAgICBsZXQgdiA9IFN0cmluZy5jb25jYXQgXCIsXCIgKGxpc3RfaW5pdCBuIGdlbikgaW5cbiAgICAgIGxldCByZWwgPSByZWYgW10gaW5cbiAgICAgIGZvciBpID0gMCB0byBuLTEgZG9cbiAgICAgICAgZm9yIGogPSBpKzEgdG8gbi0xIGRvXG4gICAgICAgICAgcmVsIDo9IChnZW4gaV5nZW4gal5cIi1cIl5nZW4gal5nZW4gaSkgOjogIXJlbFxuICAgICAgICBkb25lXG4gICAgICBkb25lO1xuICAgICAgbGV0IHJlbCA9IFN0cmluZy5jb25jYXQgXCIsXCIgKExpc3QucmV2ICFyZWwpIGluXG4gICAgICBzZXQgdiByZWxcbiAgICBpblxuICAgIGxldCBleHQgbiA9XG4gICAgICBsZXQgdiA9IFN0cmluZy5jb25jYXQgXCIsXCIgKGxpc3RfaW5pdCBuIGdlbikgaW5cbiAgICAgIGxldCByZWwgPSByZWYgW10gaW5cbiAgICAgIGZvciBpID0gMCB0byBuLTEgZG9cbiAgICAgICAgcmVsIDo9IChnZW4gaV5nZW4gaSkgOjogIXJlbDtcbiAgICAgICAgZm9yIGogPSAoaSsxKSB0byBuLTEgZG9cbiAgICAgICAgICByZWwgOj0gKGdlbiBpXmdlbiBqXlwiK1wiXmdlbiBqXmdlbiBpKSA6OiAhcmVsXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmU7XG4gICAgICBsZXQgcmVsID0gU3RyaW5nLmNvbmNhdCBcIixcIiAoTGlzdC5yZXYgIXJlbCkgaW5cbiAgICAgIHNldCB2IHJlbFxuICAgIGluXG4gICAgbGV0IHN5bWcgbiA9XG4gICAgICBsZXQgdiA9IFN0cmluZy5jb25jYXQgXCIsXCIgKGxpc3RfaW5pdCBuIGdlbikgaW5cbiAgICAgIGxldCByZWwgPSByZWYgW10gaW5cbiAgICAgIGZvciBpID0gMCB0byBuLTIgZG9cbiAgICAgICAgcmVsIDo9IChnZW4gaV5nZW4gaV5cIi0xXCIpIDo6ICFyZWw7XG4gICAgICAgIHJlbCA6PSAoZ2VuIGleZ2VuIChpKzEpXmdlbiBpXlwiLVwiXmdlbiAoaSsxKV5nZW4gaV5nZW4gKGkrMSkpIDo6ICFyZWxcbiAgICAgIGRvbmU7XG4gICAgICBmb3IgaSA9IDAgdG8gbi0xIGRvXG4gICAgICAgIGZvciBqID0gaSsyIHRvIG4tMSBkb1xuICAgICAgICAgIHJlbCA6PSAoZ2VuIGleZ2VuIGpeXCItXCJeZ2VuIGpeZ2VuIGkpIDo6ICFyZWxcbiAgICAgICAgZG9uZVxuICAgICAgZG9uZTtcbiAgICAgIGxldCByZWwgPSBTdHJpbmcuY29uY2F0IFwiLFwiIChMaXN0LnJldiAhcmVsKSBpblxuICAgICAgc2V0IHYgcmVsXG4gICAgaW5cbiAgICBsZXQgc2tseWFuaW4gbiA9XG4gICAgICBsZXQgdiA9IFN0cmluZy5jb25jYXQgXCIsXCIgKGxpc3RfaW5pdCBuIGdlbikgaW5cbiAgICAgIGxldCByZWwgPSByZWYgXCJcIiBpblxuICAgICAgZm9yIGkgPSAwIHRvIG4tMSBkb1xuICAgICAgICByZWwgOj0gIXJlbCBeIChpZiAhcmVsID0gXCJcIiB0aGVuIFwiXCIgZWxzZSBcIitcIikgXiBnZW4gaSBeIFwiXlwiIF4gc3RyaW5nX29mX2ludCBuXG4gICAgICBkb25lO1xuICAgICAgcmVsIDo9ICFyZWwgXiBcIitcIjtcbiAgICAgIGZvciBpID0gMCB0byBuLTEgZG9cbiAgICAgICAgcmVsIDo9ICFyZWwgXiBnZW4gaVxuICAgICAgZG9uZTtcbiAgICAgIHNldCB2ICFyZWxcbiAgICBpblxuICAgIGxldCBwb3cgbiA9XG4gICAgICBsZXQgdiA9IFwieCx5XCIgaW5cbiAgICAgIGxldCByZWwgPSByZWYgW10gaW5cbiAgICAgIGZvciBpID0gMCB0byBuLTEgZG9cbiAgICAgICAgbGV0IHMgPSByZWYgXCJ4XCIgaW5cbiAgICAgICAgZm9yIF8gPSAwIHRvIGktMSBkb1xuICAgICAgICAgIHMgOj0gIXMgXiBcInlcIlxuICAgICAgICBkb25lO1xuICAgICAgICBzIDo9ICFzIF4gXCJ4XCI7XG4gICAgICAgIHJlbCA6PSAhcyA6OiAhcmVsXG4gICAgICBkb25lO1xuICAgICAgbGV0IHJlbCA9IFN0cmluZy5jb25jYXQgXCIsXCIgKExpc3QucmV2ICFyZWwpIGluXG4gICAgICBzZXQgdiByZWxcbiAgICBpblxuICAgIGxldCBwbGFjdGljIG4gPVxuICAgICAgbGV0IHYgPSBsaXN0X2luaXQgbiBnZW4gaW5cbiAgICAgIGxldCB2ID0gU3RyaW5nLmNvbmNhdCBcIixcIiB2IGluXG4gICAgICBsZXQgcmVsID0gcmVmIFtdIGluXG4gICAgICBmb3IgeCA9IDAgdG8gbi0xIGRvXG4gICAgICAgIGZvciB5ID0geCsxIHRvIG4tMSBkb1xuICAgICAgICAgIGZvciB6ID0geSB0byBuLTEgZG9cbiAgICAgICAgICAgIGxldCB4ID0gZ2VuIHggaW5cbiAgICAgICAgICAgIGxldCB5ID0gZ2VuIHkgaW5cbiAgICAgICAgICAgIGxldCB6ID0gZ2VuIHogaW5cbiAgICAgICAgICAgIHJlbCA6PSAoeV56XnheXCItXCJeeV54XnopIDo6ICFyZWxcbiAgICAgICAgICBkb25lXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmU7XG4gICAgICBmb3IgeCA9IDAgdG8gbi0xIGRvXG4gICAgICAgIGZvciB5ID0geCB0byBuLTEgZG9cbiAgICAgICAgICBmb3IgeiA9IHkrMSB0byBuLTEgZG9cbiAgICAgICAgICAgIGxldCB4ID0gZ2VuIHggaW5cbiAgICAgICAgICAgIGxldCB5ID0gZ2VuIHkgaW5cbiAgICAgICAgICAgIGxldCB6ID0gZ2VuIHogaW5cbiAgICAgICAgICAgIHJlbCA6PSAoeF56XnleXCItXCJeel54XnkpIDo6ICFyZWxcbiAgICAgICAgICBkb25lXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmU7XG4gICAgICBsZXQgcmVsID0gU3RyaW5nLmNvbmNhdCBcIixcIiAoTGlzdC5yZXYgIXJlbCkgaW5cbiAgICAgIHNldCB2IHJlbFxuICAgIGluXG4gICAgbGV0IG4gPSBpbnRfb2Zfc3RyaW5nIChKcy50b19zdHJpbmcgZ2VuZXJhdGVuIyMudmFsdWUpIGluXG4gICAgKFxuICAgICAgbWF0Y2ggSnMudG9fc3RyaW5nIGdlbmVyYXRlIyMudmFsdWUgd2l0aFxuICAgICAgfCBcInN5bVwiIC0+IHN5bSBuXG4gICAgICB8IFwiZXh0XCIgLT4gZXh0IG5cbiAgICAgIHwgXCJzeW1nXCIgLT4gc3ltZyBuXG4gICAgICB8IFwic2tseWFuaW5cIiAtPiBza2x5YW5pbiBuXG4gICAgICB8IFwicG93XCIgLT4gcG93IG5cbiAgICAgIHwgXCJwbGFjdGljXCIgLT4gcGxhY3RpYyBuXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgKTtcbiAgICBKcy5fdHJ1ZVxuICBpblxuXG4gIGdlbmVyYXRlIyMub25pbnB1dCA6PSBIdG1sLmhhbmRsZXIgZ2VuZXJhdGVfaGFuZGxlcjtcbiAgZ2VuZXJhdGVuIyMub25jaGFuZ2UgOj0gSHRtbC5oYW5kbGVyIGdlbmVyYXRlX2hhbmRsZXI7XG4gIEpzLl90cnVlXG5cbmxldCAoKSA9XG4gIEh0bWwud2luZG93IyMub25sb2FkIDo9IEh0bWwuaGFuZGxlciBydW5cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogRW5zdXJlIHRoYXQgW2F0X2V4aXRdIGZ1bmN0aW9ucyBhcmUgY2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgcHJvZ3JhbSAqKVxuXG5sZXQgXyA9IGRvX2F0X2V4aXQoKVxuIl19