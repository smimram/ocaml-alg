//# 1 ".kb.eobjs/jsoo/kb.bc.runtime.js"
// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=unknown, use-js-string=true, version=5.4.0+git-c1a8c4a
//# 3 ".kb.eobjs/jsoo/kb.bc.runtime.js"

//# 7 ".kb.eobjs/jsoo/kb.bc.runtime.js"
(function
  (Object){
   typeof globalThis !== "object"
   &&
    (this
      ? get()
      : (Object.defineProperty
         (Object.prototype, "_T_", {configurable: true, get: get}),
        _T_));
   function get(){
    var global = this || self;
    global.globalThis = global;
    delete Object.prototype._T_;
   }
  }
  (Object));
(function(globalThis){
   "use strict";
   function caml_int64_is_zero(x){return + x.isZero();}
   function caml_str_repeat(n, s){
    if(n == 0) return "";
    if(s.repeat) return s.repeat(n);
    var r = "", l = 0;
    for(;;){
     if(n & 1) r += s;
     n >>= 1;
     if(n == 0) return r;
     s += s;
     l++;
     if(l == 9) s.slice(0, 1);
    }
   }
   var caml_int64_offset = Math.pow(2, - 24);
   function caml_raise_constant(tag){throw tag;}
   var caml_global_data = [0];
   function caml_raise_zero_divide(){
    caml_raise_constant(caml_global_data.Division_by_zero);
   }
   function MlInt64(lo, mi, hi){
    this.lo = lo & 0xffffff;
    this.mi = mi & 0xffffff;
    this.hi = hi & 0xffff;
   }
   MlInt64.prototype.caml_custom = "_j";
   MlInt64.prototype.copy =
    function(){return new MlInt64(this.lo, this.mi, this.hi);};
   MlInt64.prototype.ucompare =
    function(x){
     if(this.hi > x.hi) return 1;
     if(this.hi < x.hi) return - 1;
     if(this.mi > x.mi) return 1;
     if(this.mi < x.mi) return - 1;
     if(this.lo > x.lo) return 1;
     if(this.lo < x.lo) return - 1;
     return 0;
    };
   MlInt64.prototype.compare =
    function(x){
     var hi = this.hi << 16, xhi = x.hi << 16;
     if(hi > xhi) return 1;
     if(hi < xhi) return - 1;
     if(this.mi > x.mi) return 1;
     if(this.mi < x.mi) return - 1;
     if(this.lo > x.lo) return 1;
     if(this.lo < x.lo) return - 1;
     return 0;
    };
   MlInt64.prototype.neg =
    function(){
     var
      lo = - this.lo,
      mi = - this.mi + (lo >> 24),
      hi = - this.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.add =
    function(x){
     var
      lo = this.lo + x.lo,
      mi = this.mi + x.mi + (lo >> 24),
      hi = this.hi + x.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.sub =
    function(x){
     var
      lo = this.lo - x.lo,
      mi = this.mi - x.mi + (lo >> 24),
      hi = this.hi - x.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.mul =
    function(x){
     var
      lo = this.lo * x.lo,
      mi = (lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
      hi =
        (mi * caml_int64_offset | 0) + this.hi * x.lo + this.mi * x.mi
        + this.lo * x.hi;
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.isZero =
    function(){return (this.lo | this.mi | this.hi) == 0;};
   MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0;};
   MlInt64.prototype.and =
    function(x){
     return new MlInt64(this.lo & x.lo, this.mi & x.mi, this.hi & x.hi);
    };
   MlInt64.prototype.or =
    function(x){
     return new MlInt64(this.lo | x.lo, this.mi | x.mi, this.hi | x.hi);
    };
   MlInt64.prototype.xor =
    function(x){
     return new MlInt64(this.lo ^ x.lo, this.mi ^ x.mi, this.hi ^ x.hi);
    };
   MlInt64.prototype.shift_left =
    function(s){
     s = s & 63;
     if(s == 0) return this;
     if(s < 24)
      return new
              MlInt64
              (this.lo << s,
               this.mi << s | this.lo >> 24 - s,
               this.hi << s | this.mi >> 24 - s);
     if(s < 48)
      return new
              MlInt64
              (0, this.lo << s - 24, this.mi << s - 24 | this.lo >> 48 - s);
     return new MlInt64(0, 0, this.lo << s - 48);
    };
   MlInt64.prototype.shift_right_unsigned =
    function(s){
     s = s & 63;
     if(s == 0) return this;
     if(s < 24)
      return new
              MlInt64
              (this.lo >> s | this.mi << 24 - s,
               this.mi >> s | this.hi << 24 - s,
               this.hi >> s);
     if(s < 48)
      return new
              MlInt64
              (this.mi >> s - 24 | this.hi << 48 - s, this.hi >> s - 24, 0);
     return new MlInt64(this.hi >> s - 48, 0, 0);
    };
   MlInt64.prototype.shift_right =
    function(s){
     s = s & 63;
     if(s == 0) return this;
     var h = this.hi << 16 >> 16;
     if(s < 24)
      return new
              MlInt64
              (this.lo >> s | this.mi << 24 - s,
               this.mi >> s | h << 24 - s,
               this.hi << 16 >> s >>> 16);
     var sign = this.hi << 16 >> 31;
     if(s < 48)
      return new
              MlInt64
              (this.mi >> s - 24 | this.hi << 48 - s,
               this.hi << 16 >> s - 24 >> 16,
               sign & 0xffff);
     return new MlInt64(this.hi << 16 >> s - 32, sign, sign);
    };
   MlInt64.prototype.lsl1 =
    function(){
     this.hi = this.hi << 1 | this.mi >> 23;
     this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
     this.lo = this.lo << 1 & 0xffffff;
    };
   MlInt64.prototype.lsr1 =
    function(){
     this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
     this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
     this.hi = this.hi >>> 1;
    };
   MlInt64.prototype.udivmod =
    function(x){
     var
      offset = 0,
      modulus = this.copy(),
      divisor = x.copy(),
      quotient = new MlInt64(0, 0, 0);
     while(modulus.ucompare(divisor) > 0){offset++; divisor.lsl1();}
     while(offset >= 0){
      offset--;
      quotient.lsl1();
      if(modulus.ucompare(divisor) >= 0){
       quotient.lo++;
       modulus = modulus.sub(divisor);
      }
      divisor.lsr1();
     }
     return {quotient: quotient, modulus: modulus};
    };
   MlInt64.prototype.div =
    function(y){
     var x = this;
     if(y.isZero()) caml_raise_zero_divide();
     var sign = x.hi ^ y.hi;
     if(x.hi & 0x8000) x = x.neg();
     if(y.hi & 0x8000) y = y.neg();
     var q = x.udivmod(y).quotient;
     if(sign & 0x8000) q = q.neg();
     return q;
    };
   MlInt64.prototype.mod =
    function(y){
     var x = this;
     if(y.isZero()) caml_raise_zero_divide();
     var sign = x.hi;
     if(x.hi & 0x8000) x = x.neg();
     if(y.hi & 0x8000) y = y.neg();
     var r = x.udivmod(y).modulus;
     if(sign & 0x8000) r = r.neg();
     return r;
    };
   MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24;};
   MlInt64.prototype.toFloat =
    function(){
     return (this.hi << 16) * Math.pow(2, 32) + this.mi * Math.pow(2, 24)
            + this.lo;
    };
   MlInt64.prototype.toArray =
    function(){
     return [this.hi >> 8,
             this.hi & 0xff,
             this.mi >> 16,
             this.mi >> 8 & 0xff,
             this.mi & 0xff,
             this.lo >> 16,
             this.lo >> 8 & 0xff,
             this.lo & 0xff];
    };
   MlInt64.prototype.lo32 =
    function(){return this.lo | (this.mi & 0xff) << 24;};
   MlInt64.prototype.hi32 =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16;};
   function caml_int64_of_int32(x){
    return new MlInt64(x & 0xffffff, x >> 24 & 0xffffff, x >> 31 & 0xffff);
   }
   function caml_int64_to_int32(x){return x.toInt();}
   function caml_int64_is_negative(x){return + x.isNeg();}
   function caml_int64_neg(x){return x.neg();}
   function caml_jsbytes_of_string(x){return x;}
   function jsoo_sys_getenv(n){
    var process = globalThis.process;
    if(process && process.env && process.env[n] != undefined)
     return process.env[n];
    if(globalThis.jsoo_static_env && globalThis.jsoo_static_env[n])
     return globalThis.jsoo_static_env[n];
   }
   var caml_record_backtrace_flag = 0;
   (function(){
      var r = jsoo_sys_getenv("OCAMLRUNPARAM");
      if(r !== undefined){
       var l = r.split(",");
       for(var i = 0; i < l.length; i++)
        if(l[i] == "b"){
         caml_record_backtrace_flag = 1;
         break;
        }
        else if(l[i].startsWith("b="))
         caml_record_backtrace_flag = + l[i].slice(2);
        else
         continue;
      }
     }
     ());
   function caml_exn_with_js_backtrace(exn, force){
    if(! exn.js_error || force || exn[0] == 248)
     exn.js_error = new globalThis.Error("Js exception containing backtrace");
    return exn;
   }
   function caml_maybe_attach_backtrace(exn, force){
    return caml_record_backtrace_flag
            ? caml_exn_with_js_backtrace(exn, force)
            : exn;
   }
   function caml_raise_with_arg(tag, arg){
    throw caml_maybe_attach_backtrace([0, tag, arg]);
   }
   function caml_string_of_jsbytes(x){return x;}
   function caml_raise_with_string(tag, msg){
    caml_raise_with_arg(tag, caml_string_of_jsbytes(msg));
   }
   function caml_invalid_argument(msg){
    caml_raise_with_string(caml_global_data.Invalid_argument, msg);
   }
   function caml_parse_format(fmt){
    fmt = caml_jsbytes_of_string(fmt);
    var len = fmt.length;
    if(len > 31) caml_invalid_argument("format_int: format too long");
    var
     f =
       {justify: "+",
        signstyle: "-",
        filler: " ",
        alternate: false,
        base: 0,
        signedconv: false,
        width: 0,
        uppercase: false,
        sign: 1,
        prec: - 1,
        conv: "f"};
    for(var i = 0; i < len; i++){
     var c = fmt.charAt(i);
     switch(c){
       case "-":
        f.justify = "-"; break;
       case "+":
       case " ":
        f.signstyle = c; break;
       case "0":
        f.filler = "0"; break;
       case "#":
        f.alternate = true; break;
       case "1":
       case "2":
       case "3":
       case "4":
       case "5":
       case "6":
       case "7":
       case "8":
       case "9":
        f.width = 0;
        while(c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9){f.width = f.width * 10 + c; i++;}
        i--;
        break;
       case ".":
        f.prec = 0;
        i++;
        while(c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9){f.prec = f.prec * 10 + c; i++;}
        i--;
       case "d":
       case "i":
        f.signedconv = true;
       case "u":
        f.base = 10; break;
       case "x":
        f.base = 16; break;
       case "X":
        f.base = 16; f.uppercase = true; break;
       case "o":
        f.base = 8; break;
       case "e":
       case "f":
       case "g":
        f.signedconv = true; f.conv = c; break;
       case "E":
       case "F":
       case "G":
        f.signedconv = true;
        f.uppercase = true;
        f.conv = c.toLowerCase();
        break;
     }
    }
    return f;
   }
   function caml_finish_formatting(f, rawbuffer){
    if(f.uppercase) rawbuffer = rawbuffer.toUpperCase();
    var len = rawbuffer.length;
    if(f.signedconv && (f.sign < 0 || f.signstyle != "-")) len++;
    if(f.alternate){if(f.base == 8) len += 1; if(f.base == 16) len += 2;}
    var buffer = "";
    if(f.justify == "+" && f.filler == " ")
     for(var i = len; i < f.width; i++) buffer += " ";
    if(f.signedconv)
     if(f.sign < 0)
      buffer += "-";
     else if(f.signstyle != "-") buffer += f.signstyle;
    if(f.alternate && f.base == 8) buffer += "0";
    if(f.alternate && f.base == 16) buffer += f.uppercase ? "0X" : "0x";
    if(f.justify == "+" && f.filler == "0")
     for(var i = len; i < f.width; i++) buffer += "0";
    buffer += rawbuffer;
    if(f.justify == "-") for(var i = len; i < f.width; i++) buffer += " ";
    return caml_string_of_jsbytes(buffer);
   }
   function caml_int64_format(fmt, x){
    var f = caml_parse_format(fmt);
    if(f.signedconv && caml_int64_is_negative(x)){f.sign = - 1; x = caml_int64_neg(x);}
    var
     buffer = "",
     wbase = caml_int64_of_int32(f.base),
     cvtbl = "0123456789abcdef";
    do{
     var p = x.udivmod(wbase);
     x = p.quotient;
     buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer;
    }
    while
     (! caml_int64_is_zero(x));
    if(f.prec >= 0){
     f.filler = " ";
     var n = f.prec - buffer.length;
     if(n > 0) buffer = caml_str_repeat(n, "0") + buffer;
    }
    return caml_finish_formatting(f, buffer);
   }
   function caml_expm1_float(x){return Math.expm1(x);}
   function caml_ml_condition_broadcast(t){return 0;}
   function jsoo_is_ascii(s){
    if(s.length < 24){
     for(var i = 0; i < s.length; i++) if(s.charCodeAt(i) > 127) return false;
     return true;
    }
    else
     return ! /[^\x00-\x7f]/.test(s);
   }
   function caml_utf16_of_utf8(s){
    for(var b = "", t = "", c, c1, c2, v, i = 0, l = s.length; i < l; i++){
     c1 = s.charCodeAt(i);
     if(c1 < 0x80){
      for(var j = i + 1; j < l && (c1 = s.charCodeAt(j)) < 0x80; j++) ;
      if(j - i > 512){
       t.substr(0, 1);
       b += t;
       t = "";
       b += s.slice(i, j);
      }
      else
       t += s.slice(i, j);
      if(j == l) break;
      i = j;
     }
     v = 1;
     if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128){
      c = c2 + (c1 << 6);
      if(c1 < 0xe0){
       v = c - 0x3080;
       if(v < 0x80) v = 1;
      }
      else{
       v = 2;
       if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128){
        c = c2 + (c << 6);
        if(c1 < 0xf0){
         v = c - 0xe2080;
         if(v < 0x800 || v >= 0xd7ff && v < 0xe000) v = 2;
        }
        else{
         v = 3;
         if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128 && c1 < 0xf5){
          v = c2 - 0x3c82080 + (c << 6);
          if(v < 0x10000 || v > 0x10ffff) v = 3;
         }
        }
       }
      }
     }
     if(v < 4){
      i -= v;
      t += "\ufffd";
     }
     else if(v > 0xffff)
      t += String.fromCharCode(0xd7c0 + (v >> 10), 0xdc00 + (v & 0x3FF));
     else
      t += String.fromCharCode(v);
     if(t.length > 1024){t.substr(0, 1); b += t; t = "";}
    }
    return b + t;
   }
   function caml_jsstring_of_string(s){
    if(jsoo_is_ascii(s)) return s;
    return caml_utf16_of_utf8(s);
   }
   function fs_node_supported(){
    return typeof globalThis.process !== "undefined"
           && typeof globalThis.process.versions !== "undefined"
           && typeof globalThis.process.versions.node !== "undefined";
   }
   function make_path_is_absolute(){
    function posix(path){
     if(path.charAt(0) === "/") return ["", path.substring(1)];
     return;
    }
    function win32(path){
     var
      splitDeviceRe =
        /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/,
      result = splitDeviceRe.exec(path),
      device = result[1] || "",
      isUnc = Boolean(device && device.charAt(1) !== ":");
     if(Boolean(result[2] || isUnc)){
      var root = result[1] || "", sep = result[2] || "";
      return [root, path.substring(root.length + sep.length)];
     }
     return;
    }
    return fs_node_supported() && globalThis.process
            && globalThis.process.platform
            ? globalThis.process.platform === "win32" ? win32 : posix
            : posix;
   }
   var path_is_absolute = make_path_is_absolute();
   function caml_trailing_slash(name){
    return name.slice(- 1) !== "/" ? name + "/" : name;
   }
   if(fs_node_supported() && globalThis.process && globalThis.process.cwd)
    var caml_current_dir = globalThis.process.cwd().replace(/\\/g, "/");
   else
    var caml_current_dir = "/static";
   caml_current_dir = caml_trailing_slash(caml_current_dir);
   function caml_make_path(name){
    name = caml_jsstring_of_string(name);
    if(! path_is_absolute(name)) name = caml_current_dir + name;
    var
     comp0 = path_is_absolute(name),
     comp = comp0[1].split("/"),
     ncomp = [];
    for(var i = 0; i < comp.length; i++)
     switch(comp[i]){
       case "..":
        if(ncomp.length > 1) ncomp.pop(); break;
       case ".": break;
       case "": break;
       default: ncomp.push(comp[i]); break;
     }
    ncomp.unshift(comp0[0]);
    ncomp.orig = name;
    return ncomp;
   }
   function caml_utf8_of_utf16(s){
    for(var b = "", t = b, c, d, i = 0, l = s.length; i < l; i++){
     c = s.charCodeAt(i);
     if(c < 0x80){
      for(var j = i + 1; j < l && (c = s.charCodeAt(j)) < 0x80; j++) ;
      if(j - i > 512){
       t.substr(0, 1);
       b += t;
       t = "";
       b += s.slice(i, j);
      }
      else
       t += s.slice(i, j);
      if(j == l) break;
      i = j;
     }
     if(c < 0x800){
      t += String.fromCharCode(0xc0 | c >> 6);
      t += String.fromCharCode(0x80 | c & 0x3f);
     }
     else if(c < 0xd800 || c >= 0xdfff)
      t +=
       String.fromCharCode
        (0xe0 | c >> 12, 0x80 | c >> 6 & 0x3f, 0x80 | c & 0x3f);
     else if
      (c >= 0xdbff || i + 1 == l || (d = s.charCodeAt(i + 1)) < 0xdc00
       || d > 0xdfff)
      t += "\xef\xbf\xbd";
     else{
      i++;
      c = (c << 10) + d - 0x35fdc00;
      t +=
       String.fromCharCode
        (0xf0 | c >> 18,
         0x80 | c >> 12 & 0x3f,
         0x80 | c >> 6 & 0x3f,
         0x80 | c & 0x3f);
     }
     if(t.length > 1024){t.substr(0, 1); b += t; t = "";}
    }
    return b + t;
   }
   function caml_string_of_jsstring(s){
    return jsoo_is_ascii(s)
            ? caml_string_of_jsbytes(s)
            : caml_string_of_jsbytes(caml_utf8_of_utf16(s));
   }
   var
    unix_error =
      ["E2BIG",
       "EACCES",
       "EAGAIN",
       "EBADF",
       "EBUSY",
       "ECHILD",
       "EDEADLK",
       "EDOM",
       "EEXIST",
       "EFAULT",
       "EFBIG",
       "EINTR",
       "EINVAL",
       "EIO",
       "EISDIR",
       "EMFILE",
       "EMLINK",
       "ENAMETOOLONG",
       "ENFILE",
       "ENODEV",
       "ENOENT",
       "ENOEXEC",
       "ENOLCK",
       "ENOMEM",
       "ENOSPC",
       "ENOSYS",
       "ENOTDIR",
       "ENOTEMPTY",
       "ENOTTY",
       "ENXIO",
       "EPERM",
       "EPIPE",
       "ERANGE",
       "EROFS",
       "ESPIPE",
       "ESRCH",
       "EXDEV",
       "EWOULDBLOCK",
       "EINPROGRESS",
       "EALREADY",
       "ENOTSOCK",
       "EDESTADDRREQ",
       "EMSGSIZE",
       "EPROTOTYPE",
       "ENOPROTOOPT",
       "EPROTONOSUPPORT",
       "ESOCKTNOSUPPORT",
       "EOPNOTSUPP",
       "EPFNOSUPPORT",
       "EAFNOSUPPORT",
       "EADDRINUSE",
       "EADDRNOTAVAIL",
       "ENETDOWN",
       "ENETUNREACH",
       "ENETRESET",
       "ECONNABORTED",
       "ECONNRESET",
       "ENOBUFS",
       "EISCONN",
       "ENOTCONN",
       "ESHUTDOWN",
       "ETOOMANYREFS",
       "ETIMEDOUT",
       "ECONNREFUSED",
       "EHOSTDOWN",
       "EHOSTUNREACH",
       "ELOOP",
       "EOVERFLOW"];
   function make_unix_err_args(code, syscall, path, errno){
    var variant = unix_error.indexOf(code);
    if(variant < 0){if(errno == null) errno = - 9999; variant = [0, errno];}
    var
     args =
       [variant,
        caml_string_of_jsstring(syscall || ""),
        caml_string_of_jsstring(path || "")];
    return args;
   }
   var caml_named_values = {};
   function caml_named_value(nm){return caml_named_values[nm];}
   function caml_raise_with_args(tag, args){
    throw caml_maybe_attach_backtrace([0, tag].concat(args));
   }
   function caml_subarray_to_jsbytes(a, i, len){
    var f = String.fromCharCode;
    if(i == 0 && len <= 4096 && len == a.length) return f.apply(null, a);
    var s = "";
    for(; 0 < len; i += 1024, len -= 1024)
     s += f.apply(null, a.slice(i, i + Math.min(len, 1024)));
    return s;
   }
   function caml_convert_string_to_bytes(s){
    if(s.t == 2)
     s.c += caml_str_repeat(s.l - s.c.length, "\0");
    else
     s.c = caml_subarray_to_jsbytes(s.c, 0, s.c.length);
    s.t = 0;
   }
   function MlBytes(tag, contents, length){
    this.t = tag;
    this.c = contents;
    this.l = length;
   }
   MlBytes.prototype.toString =
    function(){
     switch(this.t){
       case 9:
        return this.c;
       default: caml_convert_string_to_bytes(this);
       case 0:
        if(jsoo_is_ascii(this.c)){this.t = 9; return this.c;} this.t = 8;
       case 8:
        return this.c;
     }
    };
   MlBytes.prototype.toUtf16 =
    function(){
     var r = this.toString();
     if(this.t == 9) return r;
     return caml_utf16_of_utf8(r);
    };
   MlBytes.prototype.slice =
    function(){
     var content = this.t == 4 ? this.c.slice() : this.c;
     return new MlBytes(this.t, content, this.l);
    };
   function caml_is_ml_bytes(s){return s instanceof MlBytes;}
   function caml_is_ml_string(s){
    return typeof s === "string" && ! /[^\x00-\xff]/.test(s);
   }
   function caml_bytes_of_array(a){
    if(! (a instanceof Uint8Array)) a = new Uint8Array(a);
    return new MlBytes(4, a, a.length);
   }
   function caml_bytes_of_jsbytes(s){return new MlBytes(0, s, s.length);}
   function caml_bytes_of_string(s){
    return caml_bytes_of_jsbytes(caml_jsbytes_of_string(s));
   }
   function caml_raise_sys_error(msg){
    caml_raise_with_string(caml_global_data.Sys_error, msg);
   }
   function caml_raise_no_such_file(name){
    caml_raise_sys_error(name + ": No such file or directory");
   }
   function caml_convert_bytes_to_array(s){
    var a = new Uint8Array(s.l), b = s.c, l = b.length, i = 0;
    for(; i < l; i++) a[i] = b.charCodeAt(i);
    for(l = s.l; i < l; i++) a[i] = 0;
    s.c = a;
    s.t = 4;
    return a;
   }
   function caml_uint8_array_of_bytes(s){
    if(s.t != 4) caml_convert_bytes_to_array(s);
    return s.c;
   }
   function caml_create_bytes(len){
    if(len < 0) caml_invalid_argument("Bytes.create");
    return new MlBytes(len ? 2 : 9, "", len);
   }
   function caml_ml_bytes_length(s){return s.l;}
   function caml_blit_bytes(s1, i1, s2, i2, len){
    if(len == 0) return 0;
    if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length)){
     s2.c =
      s1.t == 4
       ? caml_subarray_to_jsbytes(s1.c, i1, len)
       : i1 == 0 && s1.c.length == len ? s1.c : s1.c.substr(i1, len);
     s2.t = s2.c.length == s2.l ? 0 : 2;
    }
    else if(s2.t == 2 && i2 == s2.c.length){
     s2.c +=
      s1.t == 4
       ? caml_subarray_to_jsbytes(s1.c, i1, len)
       : i1 == 0 && s1.c.length == len ? s1.c : s1.c.substr(i1, len);
     s2.t = s2.c.length == s2.l ? 0 : 2;
    }
    else{
     if(s2.t != 4) caml_convert_bytes_to_array(s2);
     var c1 = s1.c, c2 = s2.c;
     if(s1.t == 4)
      if(i2 <= i1)
       for(var i = 0; i < len; i++) c2[i2 + i] = c1[i1 + i];
      else
       for(var i = len - 1; i >= 0; i--) c2[i2 + i] = c1[i1 + i];
     else{
      var l = Math.min(len, c1.length - i1);
      for(var i = 0; i < l; i++) c2[i2 + i] = c1.charCodeAt(i1 + i);
      for(; i < len; i++) c2[i2 + i] = 0;
     }
    }
    return 0;
   }
   function MlFile(){}
   function MlFakeFile(content){this.data = content;}
   MlFakeFile.prototype = new MlFile();
   MlFakeFile.prototype.constructor = MlFakeFile;
   MlFakeFile.prototype.truncate =
    function(len){
     var old = this.data;
     this.data = caml_create_bytes(len | 0);
     caml_blit_bytes(old, 0, this.data, 0, len);
    };
   MlFakeFile.prototype.length =
    function(){return caml_ml_bytes_length(this.data);};
   MlFakeFile.prototype.write =
    function(offset, buf, pos, len){
     var clen = this.length();
     if(offset + len >= clen){
      var new_str = caml_create_bytes(offset + len), old_data = this.data;
      this.data = new_str;
      caml_blit_bytes(old_data, 0, this.data, 0, clen);
     }
     caml_blit_bytes(caml_bytes_of_array(buf), pos, this.data, offset, len);
     return 0;
    };
   MlFakeFile.prototype.read =
    function(offset, buf, pos, len){
     var clen = this.length();
     if(offset + len >= clen) len = clen - offset;
     if(len){
      var data = caml_create_bytes(len | 0);
      caml_blit_bytes(this.data, offset, data, 0, len);
      buf.set(caml_uint8_array_of_bytes(data), pos);
     }
     return len;
    };
   function MlFakeFd(name, file, flags){
    this.file = file;
    this.name = name;
    this.flags = flags;
   }
   MlFakeFd.prototype.err_closed =
    function(){
     caml_raise_sys_error(this.name + ": file descriptor already closed");
    };
   MlFakeFd.prototype.length =
    function(){if(this.file) return this.file.length(); this.err_closed();};
   MlFakeFd.prototype.write =
    function(offset, buf, pos, len){
     if(this.file) return this.file.write(offset, buf, pos, len);
     this.err_closed();
    };
   MlFakeFd.prototype.read =
    function(offset, buf, pos, len){
     if(this.file) return this.file.read(offset, buf, pos, len);
     this.err_closed();
    };
   MlFakeFd.prototype.close = function(){this.file = undefined;};
   function MlFakeDevice(root, f){
    this.content = {};
    this.root = root;
    this.lookupFun = f;
   }
   MlFakeDevice.prototype.nm = function(name){return this.root + name;};
   MlFakeDevice.prototype.create_dir_if_needed =
    function(name){
     var comp = name.split("/"), res = "";
     for(var i = 0; i < comp.length - 1; i++){
      res += comp[i] + "/";
      if(this.content[res]) continue;
      this.content[res] = Symbol("directory");
     }
    };
   MlFakeDevice.prototype.slash =
    function(name){return /\/$/.test(name) ? name : name + "/";};
   MlFakeDevice.prototype.lookup =
    function(name){
     if(! this.content[name] && this.lookupFun){
      var
       res =
         this.lookupFun
          (caml_string_of_jsbytes(this.root), caml_string_of_jsbytes(name));
      if(res !== 0){
       this.create_dir_if_needed(name);
       this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]));
      }
     }
    };
   MlFakeDevice.prototype.exists =
    function(name){
     if(name == "") return 1;
     var name_slash = this.slash(name);
     if(this.content[name_slash]) return 1;
     this.lookup(name);
     return this.content[name] ? 1 : 0;
    };
   MlFakeDevice.prototype.isFile =
    function(name){return this.exists(name) && ! this.is_dir(name) ? 1 : 0;};
   MlFakeDevice.prototype.mkdir =
    function(name, mode, raise_unix){
     var unix_error = raise_unix && caml_named_value("Unix.Unix_error");
     if(this.exists(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("EEXIST", "mkdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": File exists");
     var parent = /^(.*)\/[^/]+/.exec(name);
     parent = parent && parent[1] || "";
     if(! this.exists(parent))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOENT", "mkdir", this.nm(parent)));
      else
       caml_raise_sys_error(parent + ": No such file or directory");
     if(! this.is_dir(parent))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOTDIR", "mkdir", this.nm(parent)));
      else
       caml_raise_sys_error(parent + ": Not a directory");
     this.create_dir_if_needed(this.slash(name));
    };
   MlFakeDevice.prototype.rmdir =
    function(name, raise_unix){
     var
      unix_error = raise_unix && caml_named_value("Unix.Unix_error"),
      name_slash = name == "" ? "" : this.slash(name),
      r = new RegExp("^" + name_slash + "([^/]+)");
     if(! this.exists(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOENT", "rmdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": No such file or directory");
     if(! this.is_dir(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOTDIR", "rmdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": Not a directory");
     for(var n in this.content)
      if(n.match(r))
       if(unix_error)
        caml_raise_with_args
         (unix_error, make_unix_err_args("ENOTEMPTY", "rmdir", this.nm(name)));
       else
        caml_raise_sys_error(this.nm(name) + ": Directory not empty");
     delete this.content[name_slash];
    };
   MlFakeDevice.prototype.readdir =
    function(name){
     var name_slash = name == "" ? "" : this.slash(name);
     if(! this.exists(name))
      caml_raise_sys_error(name + ": No such file or directory");
     if(! this.is_dir(name)) caml_raise_sys_error(name + ": Not a directory");
     var r = new RegExp("^" + name_slash + "([^/]+)"), seen = {}, a = [];
     for(var n in this.content){
      var m = n.match(r);
      if(m && ! seen[m[1]]){seen[m[1]] = true; a.push(m[1]);}
     }
     return a;
    };
   MlFakeDevice.prototype.opendir =
    function(name, raise_unix){
     var
      unix_error = raise_unix && caml_named_value("Unix.Unix_error"),
      a = this.readdir(name),
      c = false,
      i = 0;
     return {readSync:
             function(){
              if(c)
               if(unix_error)
                caml_raise_with_args
                 (unix_error,
                  make_unix_err_args("EBADF", "closedir", this.nm(name)));
               else
                caml_raise_sys_error(name + ": closedir failed");
              if(i == a.length) return null;
              var entry = a[i];
              i++;
              return {name: entry};
             },
             closeSync:
             function(){
              if(c)
               if(unix_error)
                caml_raise_with_args
                 (unix_error,
                  make_unix_err_args("EBADF", "closedir", this.nm(name)));
               else
                caml_raise_sys_error(name + ": closedir failed");
              c = true;
              a = [];
             }};
    };
   MlFakeDevice.prototype.is_dir =
    function(name){
     if(name == "") return true;
     var name_slash = this.slash(name);
     return this.content[name_slash] ? 1 : 0;
    };
   MlFakeDevice.prototype.unlink =
    function(name){
     var ok = this.content[name] ? true : false;
     delete this.content[name];
     return ok;
    };
   MlFakeDevice.prototype.open =
    function(name, f){
     var file;
     if(f.rdonly && f.wronly)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_rdonly and Open_wronly are not compatible");
     if(f.text && f.binary)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_text and Open_binary are not compatible");
     this.lookup(name);
     if(this.content[name]){
      if(this.is_dir(name))
       caml_raise_sys_error(this.nm(name) + " : is a directory");
      if(f.create && f.excl)
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      file = this.content[name];
      if(f.truncate) file.truncate();
     }
     else if(f.create){
      this.create_dir_if_needed(name);
      this.content[name] = new MlFakeFile(caml_create_bytes(0));
      file = this.content[name];
     }
     else
      caml_raise_no_such_file(this.nm(name));
     return new MlFakeFd(this.nm(name), file, f);
    };
   MlFakeDevice.prototype.open =
    function(name, f){
     var file;
     if(f.rdonly && f.wronly)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_rdonly and Open_wronly are not compatible");
     if(f.text && f.binary)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_text and Open_binary are not compatible");
     this.lookup(name);
     if(this.content[name]){
      if(this.is_dir(name))
       caml_raise_sys_error(this.nm(name) + " : is a directory");
      if(f.create && f.excl)
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      file = this.content[name];
      if(f.truncate) file.truncate();
     }
     else if(f.create){
      this.create_dir_if_needed(name);
      this.content[name] = new MlFakeFile(caml_create_bytes(0));
      file = this.content[name];
     }
     else
      caml_raise_no_such_file(this.nm(name));
     return new MlFakeFd(this.nm(name), file, f);
    };
   MlFakeDevice.prototype.register =
    function(name, content){
     var file;
     if(this.content[name])
      caml_raise_sys_error(this.nm(name) + " : file already exists");
     if(caml_is_ml_bytes(content)) file = new MlFakeFile(content);
     if(caml_is_ml_string(content))
      file = new MlFakeFile(caml_bytes_of_string(content));
     else if(content instanceof Array)
      file = new MlFakeFile(caml_bytes_of_array(content));
     else if(typeof content === "string")
      file = new MlFakeFile(caml_bytes_of_jsbytes(content));
     else if(content.toString){
      var
       bytes =
         caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
      file = new MlFakeFile(bytes);
     }
     if(file){
      this.create_dir_if_needed(name);
      this.content[name] = file;
     }
     else
      caml_raise_sys_error
       (this.nm(name) + " : registering file with invalid content type");
    };
   MlFakeDevice.prototype.constructor = MlFakeDevice;
   function caml_ml_string_length(s){return s.length;}
   function caml_string_unsafe_get(s, i){return s.charCodeAt(i);}
   function caml_uint8_array_of_string(s){
    var l = caml_ml_string_length(s), a = new Array(l), i = 0;
    for(; i < l; i++) a[i] = caml_string_unsafe_get(s, i);
    return a;
   }
   function caml_bytes_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_bytes_unsafe_set(s, i, c){
    c &= 0xff;
    if(s.t != 4){
     if(i == s.c.length){
      s.c += String.fromCharCode(c);
      if(i + 1 == s.l) s.t = 0;
      return 0;
     }
     caml_convert_bytes_to_array(s);
    }
    s.c[i] = c;
    return 0;
   }
   function caml_bytes_set(s, i, c){
    if(i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_set(s, i, c);
   }
   function MlNodeFd(fd, flags){
    this.fs = require("fs");
    this.fd = fd;
    this.flags = flags;
   }
   MlNodeFd.prototype = new MlFile();
   MlNodeFd.prototype.constructor = MlNodeFd;
   MlNodeFd.prototype.truncate =
    function(len){
     try{this.fs.ftruncateSync(this.fd, len | 0);}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.length =
    function(){
     try{return this.fs.fstatSync(this.fd).size;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.write =
    function(offset, buf, buf_offset, len){
     try{
      if(this.flags.isCharacterDevice)
       this.fs.writeSync(this.fd, buf, buf_offset, len);
      else
       this.fs.writeSync(this.fd, buf, buf_offset, len, offset);
     }
     catch(err){caml_raise_sys_error(err.toString());}
     return 0;
    };
   MlNodeFd.prototype.read =
    function(offset, a, buf_offset, len){
     try{
      if(this.flags.isCharacterDevice)
       var read = this.fs.readSync(this.fd, a, buf_offset, len);
      else
       var read = this.fs.readSync(this.fd, a, buf_offset, len, offset);
      return read;
     }
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.close =
    function(){
     try{this.fs.closeSync(this.fd); return 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   function MlNodeDevice(root){this.fs = require("fs"); this.root = root;}
   MlNodeDevice.prototype.nm = function(name){return this.root + name;};
   MlNodeDevice.prototype.exists =
    function(name){
     try{return this.fs.existsSync(this.nm(name)) ? 1 : 0;}
     catch(err){return 0;}
    };
   MlNodeDevice.prototype.isFile =
    function(name){
     try{return this.fs.statSync(this.nm(name)).isFile() ? 1 : 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeDevice.prototype.mkdir =
    function(name, mode, raise_unix){
     try{this.fs.mkdirSync(this.nm(name), {mode: mode}); return 0;}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.rmdir =
    function(name, raise_unix){
     try{this.fs.rmdirSync(this.nm(name)); return 0;}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.readdir =
    function(name, raise_unix){
     try{return this.fs.readdirSync(this.nm(name));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.is_dir =
    function(name){
     try{return this.fs.statSync(this.nm(name)).isDirectory() ? 1 : 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeDevice.prototype.unlink =
    function(name, raise_unix){
     try{
      var b = this.fs.existsSync(this.nm(name)) ? 1 : 0;
      this.fs.unlinkSync(this.nm(name));
      return b;
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.open =
    function(name, f, raise_unix){
     var consts = require("constants"), res = 0;
     for(var key in f)
      switch(key){
        case "rdonly":
         res |= consts.O_RDONLY; break;
        case "wronly":
         res |= consts.O_WRONLY; break;
        case "append":
         res |= consts.O_WRONLY | consts.O_APPEND; break;
        case "create":
         res |= consts.O_CREAT; break;
        case "truncate":
         res |= consts.O_TRUNC; break;
        case "excl":
         res |= consts.O_EXCL; break;
        case "binary":
         res |= consts.O_BINARY; break;
        case "text":
         res |= consts.O_TEXT; break;
        case "nonblock":
         res |= consts.O_NONBLOCK; break;
      }
     try{
      var
       fd = this.fs.openSync(this.nm(name), res),
       isCharacterDevice =
         this.fs.lstatSync(this.nm(name)).isCharacterDevice();
      f.isCharacterDevice = isCharacterDevice;
      return new MlNodeFd(fd, f);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.rename =
    function(o, n, raise_unix){
     try{this.fs.renameSync(this.nm(o), this.nm(n));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.stat =
    function(name, raise_unix){
     try{
      var js_stats = this.fs.statSync(this.nm(name));
      return this.stats_from_js(js_stats);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.lstat =
    function(name, raise_unix){
     try{
      var js_stats = this.fs.lstatSync(this.nm(name));
      return this.stats_from_js(js_stats);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.symlink =
    function(to_dir, target, path, raise_unix){
     try{
      this.fs.symlinkSync
       (this.nm(target), this.nm(path), to_dir ? "dir" : "file");
      return 0;
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.readlink =
    function(name, raise_unix){
     try{
      var link = this.fs.readlinkSync(this.nm(name), "utf8");
      return caml_string_of_jsstring(link);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.opendir =
    function(name, raise_unix){
     try{return this.fs.opendirSync(this.nm(name));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.raise_nodejs_error =
    function(err, raise_unix){
     var unix_error = caml_named_value("Unix.Unix_error");
     if(raise_unix && unix_error){
      var
       args = make_unix_err_args(err.code, err.syscall, err.path, err.errno);
      caml_raise_with_args(unix_error, args);
     }
     else
      caml_raise_sys_error(err.toString());
    };
   MlNodeDevice.prototype.stats_from_js =
    function(js_stats){
     var file_kind;
     if(js_stats.isFile())
      file_kind = 0;
     else if(js_stats.isDirectory())
      file_kind = 1;
     else if(js_stats.isCharacterDevice())
      file_kind = 2;
     else if(js_stats.isBlockDevice())
      file_kind = 3;
     else if(js_stats.isSymbolicLink())
      file_kind = 4;
     else if(js_stats.isFIFO())
      file_kind = 5;
     else if(js_stats.isSocket()) file_kind = 6;
     return [0,
             js_stats.dev,
             js_stats.ino,
             file_kind,
             js_stats.mode,
             js_stats.nlink,
             js_stats.uid,
             js_stats.gid,
             js_stats.rdev,
             js_stats.size,
             js_stats.atimeMs,
             js_stats.mtimeMs,
             js_stats.ctimeMs];
    };
   MlNodeDevice.prototype.constructor = MlNodeDevice;
   function caml_get_root(path){
    var x = path_is_absolute(path);
    if(! x) return;
    return x[0] + "/";
   }
   function caml_failwith(msg){
    if(! caml_global_data.Failure)
     caml_global_data.Failure = [248, caml_string_of_jsbytes("Failure"), - 3];
    caml_raise_with_string(caml_global_data.Failure, msg);
   }
   var
    caml_root =
      caml_get_root(caml_current_dir)
      || caml_failwith("unable to compute caml_root"),
    jsoo_mount_point = [];
   if(fs_node_supported())
    jsoo_mount_point.push
     ({path: caml_root, device: new MlNodeDevice(caml_root)});
   else
    jsoo_mount_point.push
     ({path: caml_root, device: new MlFakeDevice(caml_root)});
   jsoo_mount_point.push
    ({path: "/static/", device: new MlFakeDevice("/static/")});
   function resolve_fs_device(name){
    var
     path = caml_make_path(name),
     name = path.join("/"),
     name_slash = caml_trailing_slash(name),
     res;
    for(var i = 0; i < jsoo_mount_point.length; i++){
     var m = jsoo_mount_point[i];
     if
      (name_slash.search(m.path) == 0
       && (! res || res.path.length < m.path.length))
      res =
       {path: m.path,
        device: m.device,
        rest: name.substring(m.path.length, name.length)};
    }
    if(! res && fs_node_supported()){
     var root = caml_get_root(name);
     if(root && root.match(/^[a-zA-Z]:\/$/)){
      var m = {path: root, device: new MlNodeDevice(root)};
      jsoo_mount_point.push(m);
      res =
       {path: m.path,
        device: m.device,
        rest: name.substring(m.path.length, name.length)};
     }
    }
    if(res) return res;
    caml_raise_sys_error("no device found for " + name_slash);
   }
   function caml_sys_is_directory(name){
    var root = resolve_fs_device(name), a = root.device.is_dir(root.rest);
    return a ? 1 : 0;
   }
   function caml_raise_not_found(){
    caml_raise_constant(caml_global_data.Not_found);
   }
   function caml_sys_getenv(name){
    var r = jsoo_sys_getenv(caml_jsstring_of_string(name));
    if(r === undefined) caml_raise_not_found();
    return caml_string_of_jsstring(r);
   }
   function shift_right_nat(nat1, ofs1, len1, nat2, ofs2, nbits){
    if(nbits == 0){nat2.data[ofs2] = 0; return 0;}
    var wrap = 0;
    for(var i = len1 - 1; i >= 0; i--){
     var a = nat1.data[ofs1 + i] >>> 0;
     nat1.data[ofs1 + i] = a >>> nbits | wrap;
     wrap = a << 32 - nbits;
    }
    nat2.data[ofs2] = wrap;
    return 0;
   }
   var caml_gr_state;
   function caml_gr_state_get(){
    if(caml_gr_state) return caml_gr_state;
    throw caml_maybe_attach_backtrace
           ([0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]);
   }
   function caml_gr_point_color(x, y){
    var
     s = caml_gr_state_get(),
     im = s.context.getImageData(x, s.height - y, 1, 1),
     d = im.data;
    return (d[0] << 16) + (d[1] << 8) + d[2];
   }
   function caml_runtime_events_user_resolve(){return 0;}
   var MlObjectTable;
   if(typeof globalThis.Map === "undefined")
    MlObjectTable =
     function(){
       function NaiveLookup(objs){this.objs = objs;}
       NaiveLookup.prototype.get =
        function(v){
         for(var i = 0; i < this.objs.length; i++)
          if(this.objs[i] === v) return i;
        };
       NaiveLookup.prototype.set = function(){};
       return function(){
        this.objs = [];
        this.lookup = new NaiveLookup(this.objs);};
      }
      ();
   else
    MlObjectTable =
     function(){this.objs = []; this.lookup = new globalThis.Map();};
   MlObjectTable.prototype.store =
    function(v){this.lookup.set(v, this.objs.length); this.objs.push(v);};
   MlObjectTable.prototype.recall =
    function(v){
     var i = this.lookup.get(v);
     return i === undefined ? undefined : this.objs.length - i;
    };
   function caml_sys_rename(o, n){
    var o_root = resolve_fs_device(o), n_root = resolve_fs_device(n);
    if(o_root.device != n_root.device)
     caml_failwith("caml_sys_rename: cannot move file between two filesystem");
    if(! o_root.device.rename)
     caml_failwith("caml_sys_rename: no implemented");
    o_root.device.rename(o_root.rest, n_root.rest);
   }
   function caml_log10_float(x){return Math.log10(x);}
   var caml_runtime_warnings = 0;
   function caml_ml_enable_runtime_warnings(bool){caml_runtime_warnings = bool; return 0;
   }
   function caml_classify_float(x){
    if(isFinite(x)){
     if(Math.abs(x) >= 2.2250738585072014e-308) return 0;
     if(x != 0) return 1;
     return 2;
    }
    return isNaN(x) ? 4 : 3;
   }
   var caml_ml_channels = new Array();
   function caml_refill(chan){
    if(chan.refill != null){
     var str = chan.refill(), str_a = caml_uint8_array_of_string(str);
     if(str_a.length == 0)
      chan.refill = null;
     else{
      if(chan.buffer.length < chan.buffer_max + str_a.length){
       var b = new Uint8Array(chan.buffer_max + str_a.length);
       b.set(chan.buffer);
       chan.buffer = b;
      }
      chan.buffer.set(str_a, chan.buffer_max);
      chan.offset += str_a.length;
      chan.buffer_max += str_a.length;
     }
    }
    else{
     var
      nread =
        chan.file.read
         (chan.offset,
          chan.buffer,
          chan.buffer_max,
          chan.buffer.length - chan.buffer_max);
     chan.offset += nread;
     chan.buffer_max += nread;
    }
   }
   function caml_array_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_ml_input_scan_line(chanid){
    var chan = caml_ml_channels[chanid], p = chan.buffer_curr;
    do
     if(p >= chan.buffer_max){
      if(chan.buffer_curr > 0){
       chan.buffer.set(chan.buffer.subarray(chan.buffer_curr), 0);
       p -= chan.buffer_curr;
       chan.buffer_max -= chan.buffer_curr;
       chan.buffer_curr = 0;
      }
      if(chan.buffer_max >= chan.buffer.length) return - chan.buffer_max | 0;
      var prev_max = chan.buffer_max;
      caml_refill(chan);
      if(prev_max == chan.buffer_max) return - chan.buffer_max | 0;
     }
    while
     (chan.buffer[p++] != 10);
    return p - chan.buffer_curr | 0;
   }
   function caml_gc_minor(unit){
    if(typeof globalThis.gc == "function") globalThis.gc(true);
    return 0;
   }
   function caml_ml_condition_new(unit){return {condition: 1};}
   function caml_int64_of_bytes(a){
    return new
            MlInt64
            (a[7] << 0 | a[6] << 8 | a[5] << 16,
             a[4] << 0 | a[3] << 8 | a[2] << 16,
             a[1] << 0 | a[0] << 8);
   }
   function caml_ba_uint8_get64(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 7 >= ba.data.length) caml_array_bound_error();
    var
     b1 = ba.get(ofs + 0),
     b2 = ba.get(ofs + 1),
     b3 = ba.get(ofs + 2),
     b4 = ba.get(ofs + 3),
     b5 = ba.get(ofs + 4),
     b6 = ba.get(ofs + 5),
     b7 = ba.get(ofs + 6),
     b8 = ba.get(ofs + 7);
    return caml_int64_of_bytes([b8, b7, b6, b5, b4, b3, b2, b1]);
   }
   function caml_int64_to_bytes(x){return x.toArray();}
   function caml_int64_marshal(writer, v, sizes){
    var b = caml_int64_to_bytes(v);
    for(var i = 0; i < 8; i++) writer.write(8, b[i]);
    sizes[0] = 8;
    sizes[1] = 8;
   }
   function caml_ba_num_dims(ba){return ba.dims.length;}
   function caml_wrap_exception(e){
    {
     if(e instanceof Array) return e;
     var exn;
     if
      (globalThis.RangeError && e instanceof globalThis.RangeError
       && e.message
       && e.message.match(/maximum call stack/i))
      exn = caml_global_data.Stack_overflow;
     else if
      (globalThis.InternalError && e instanceof globalThis.InternalError
       && e.message
       && e.message.match(/too much recursion/i))
      exn = caml_global_data.Stack_overflow;
     else if(e instanceof globalThis.Error && caml_named_value("jsError"))
      exn = [0, caml_named_value("jsError"), e];
     else
      exn = [0, caml_global_data.Failure, caml_string_of_jsstring(String(e))];
     if(e instanceof globalThis.Error) exn.js_error = e;
     return exn;
    }
   }
   function caml_create_file(name, content){
    var root = resolve_fs_device(name);
    if(! root.device.register) caml_failwith("cannot register file");
    root.device.register(root.rest, content);
    return 0;
   }
   function jsoo_create_file(name, content){
    var
     name = caml_string_of_jsbytes(name),
     content = caml_string_of_jsbytes(content);
    return caml_create_file(name, content);
   }
   function caml_fs_init(){
    var tmp = globalThis.caml_fs_tmp;
    if(tmp)
     for(var i = 0; i < tmp.length; i++)
      jsoo_create_file(tmp[i].name, tmp[i].content);
    globalThis.jsoo_create_file = jsoo_create_file;
    globalThis.caml_fs_tmp = [];
    return 0;
   }
   function caml_get_continuation_callstack(){return [0];}
   var caml_parser_trace = 0;
   function caml_set_parser_trace(bool){
    var oldflag = caml_parser_trace;
    caml_parser_trace = bool;
    return oldflag;
   }
   function caml_list_of_js_array(a){
    var l = 0;
    for(var i = a.length - 1; i >= 0; i--){var e = a[i]; l = [0, e, l];}
    return l;
   }
   function caml_mul(a, b){return Math.imul(a, b);}
   function caml_hash_mix_int(h, d){
    d = caml_mul(d, 0xcc9e2d51 | 0);
    d = d << 15 | d >>> 32 - 15;
    d = caml_mul(d, 0x1b873593);
    h ^= d;
    h = h << 13 | h >>> 32 - 13;
    return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0;
   }
   function num_digits_nat(nat, ofs, len){
    for(var i = len - 1; i >= 0; i--) if(nat.data[ofs + i] != 0) return i + 1;
    return 1;
   }
   function caml_hash_nat(x){
    var len = num_digits_nat(x, 0, x.data.length), h = 0;
    for(var i = 0; i < len; i++) h = caml_hash_mix_int(h, x.data[i]);
    return h;
   }
   function caml_call_gen(f, args){
    var
     n = f.l >= 0 ? f.l : f.l = f.length,
     argsLen = args.length,
     d = n - argsLen;
    if(d == 0)
     return f.apply(null, args);
    else if(d < 0){
     var g = f.apply(null, args.slice(0, n));
     if(typeof g !== "function") return g;
     return caml_call_gen(g, args.slice(n));
    }
    else{
     switch(d){
       case 1:
        {
         var
          g =
            function(x){
             var nargs = new Array(argsLen + 1);
             for(var i = 0; i < argsLen; i++) nargs[i] = args[i];
             nargs[argsLen] = x;
             return f.apply(null, nargs);
            };
         break;
        }
       case 2:
        {
         var
          g =
            function(x, y){
             var nargs = new Array(argsLen + 2);
             for(var i = 0; i < argsLen; i++) nargs[i] = args[i];
             nargs[argsLen] = x;
             nargs[argsLen + 1] = y;
             return f.apply(null, nargs);
            };
         break;
        }
       default:
        var
         g =
           function(){
            var
             extra_args = arguments.length == 0 ? 1 : arguments.length,
             nargs = new Array(args.length + extra_args);
            for(var i = 0; i < args.length; i++) nargs[i] = args[i];
            for(var i = 0; i < arguments.length; i++)
             nargs[args.length + i] = arguments[i];
            return caml_call_gen(f, nargs);
           };
     }
     g.l = d;
     return g;
    }
   }
   var caml_callback = caml_call_gen;
   function caml_js_wrap_callback_arguments(f){
    return function(){
     var len = arguments.length, args = new Array(len);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, [args]);};
   }
   function caml_sys_chdir(dir){
    var root = resolve_fs_device(dir);
    if(root.device.exists(root.rest)){
     if(root.rest)
      caml_current_dir = caml_trailing_slash(root.path + root.rest);
     else
      caml_current_dir = root.path;
     return 0;
    }
    else
     caml_raise_no_such_file(caml_jsbytes_of_string(dir));
   }
   function caml_obj_update_tag(b, o, n){
    if(b[0] == o){b[0] = n; return 1;}
    return 0;
   }
   function caml_lazy_update_to_forcing(o){
    return o instanceof Array && o[0] == o[0] >>> 0
            && caml_obj_update_tag(o, 246, 244)
            ? 0
            : 1;
   }
   function caml_gc_counters(){return [254, 0, 0, 0];}
   function caml_gr_synchronize(){
    caml_failwith("caml_gr_synchronize not Implemented");
   }
   function caml_unix_closedir(dir_handle){
    try{dir_handle.pointer.closeSync();}
    catch(e){
     var unix_error = caml_named_value("Unix.Unix_error");
     caml_raise_with_args
      (unix_error, make_unix_err_args("EBADF", "closedir", dir_handle.path));
    }
   }
   function caml_unix_opendir(path){
    var root = resolve_fs_device(path);
    if(! root.device.opendir)
     caml_failwith("caml_unix_opendir: not implemented");
    var dir_handle = root.device.opendir(root.rest, true);
    return {pointer: dir_handle, path: path};
   }
   function caml_unix_rewinddir(dir_handle){
    caml_unix_closedir(dir_handle);
    var new_dir_handle = caml_unix_opendir(dir_handle.path);
    dir_handle.pointer = new_dir_handle.pointer;
    return 0;
   }
   function caml_raise_end_of_file(){
    caml_raise_constant(caml_global_data.End_of_file);
   }
   function caml_unix_readdir(dir_handle){
    var entry;
    try{entry = dir_handle.pointer.readSync();}
    catch(e){
     var unix_error = caml_named_value("Unix.Unix_error");
     caml_raise_with_args
      (unix_error, make_unix_err_args("EBADF", "readdir", dir_handle.path));
    }
    if(entry === null)
     caml_raise_end_of_file();
    else
     return caml_string_of_jsstring(entry.name);
   }
   function caml_unix_findfirst(path){
    var path_js = caml_jsstring_of_string(path);
    path_js = path_js.replace(/(^|[\\\/])\*\.\*$/, "");
    path = caml_string_of_jsstring(path_js);
    var
     dir_handle = caml_unix_opendir(path),
     first_entry = caml_unix_readdir(dir_handle);
    return [0, first_entry, dir_handle];
   }
   function caml_is_continuation_tag(t){return t == 245 ? 1 : 0;}
   var log2_ok = Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
   function jsoo_floor_log2(x){
    if(log2_ok) return Math.floor(Math.log2(x));
    var i = 0;
    if(x == 0) return - Infinity;
    if(x >= 1) while(x >= 2){x /= 2; i++;} else while(x < 1){x *= 2; i--;}
    return i;
   }
   function caml_int32_bits_of_float(x){
    var float32a = new Float32Array(1);
    float32a[0] = x;
    var int32a = new Int32Array(float32a.buffer);
    return int32a[0] | 0;
   }
   function caml_int64_create_lo_mi_hi(lo, mi, hi){return new MlInt64(lo, mi, hi);
   }
   function caml_int64_bits_of_float(x){
    if(! isFinite(x)){
     if(isNaN(x)) return caml_int64_create_lo_mi_hi(1, 0, 0x7ff0);
     return x > 0
             ? caml_int64_create_lo_mi_hi(0, 0, 0x7ff0)
             : caml_int64_create_lo_mi_hi(0, 0, 0xfff0);
    }
    var sign = x == 0 && 1 / x == - Infinity ? 0x8000 : x >= 0 ? 0 : 0x8000;
    if(sign) x = - x;
    var exp = jsoo_floor_log2(x) + 1023;
    if(exp <= 0){
     exp = 0;
     x /= Math.pow(2, - 1026);
    }
    else{
     x /= Math.pow(2, exp - 1027);
     if(x < 16){x *= 2; exp -= 1;}
     if(exp == 0) x /= 2;
    }
    var k = Math.pow(2, 24), r3 = x | 0;
    x = (x - r3) * k;
    var r2 = x | 0;
    x = (x - r2) * k;
    var r1 = x | 0;
    r3 = r3 & 0xf | sign | exp << 4;
    return caml_int64_create_lo_mi_hi(r1, r2, r3);
   }
   function caml_ba_serialize(writer, ba, sz){
    writer.write(32, ba.dims.length);
    writer.write(32, ba.kind | ba.layout << 8);
    if(ba.caml_custom == "_bigarr02")
     for(var i = 0; i < ba.dims.length; i++)
      if(ba.dims[i] < 0xffff)
       writer.write(16, ba.dims[i]);
      else{
       writer.write(16, 0xffff);
       writer.write(32, 0);
       writer.write(32, ba.dims[i]);
      }
    else
     for(var i = 0; i < ba.dims.length; i++) writer.write(32, ba.dims[i]);
    switch(ba.kind){
      case 2:
      case 3:
      case 12:
       for(var i = 0; i < ba.data.length; i++) writer.write(8, ba.data[i]);
       break;
      case 4:
      case 5:
       for(var i = 0; i < ba.data.length; i++) writer.write(16, ba.data[i]);
       break;
      case 6:
       for(var i = 0; i < ba.data.length; i++) writer.write(32, ba.data[i]);
       break;
      case 8:
      case 9:
       writer.write(8, 0);
       for(var i = 0; i < ba.data.length; i++) writer.write(32, ba.data[i]);
       break;
      case 7:
       for(var i = 0; i < ba.data.length / 2; i++){
        var b = caml_int64_to_bytes(ba.get(i));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
      case 1:
       for(var i = 0; i < ba.data.length; i++){
        var b = caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
      case 0:
       for(var i = 0; i < ba.data.length; i++){
        var b = caml_int32_bits_of_float(ba.get(i));
        writer.write(32, b);
       }
       break;
      case 10:
       for(var i = 0; i < ba.data.length / 2; i++){
        var j = ba.get(i);
        writer.write(32, caml_int32_bits_of_float(j[1]));
        writer.write(32, caml_int32_bits_of_float(j[2]));
       }
       break;
      case 11:
       for(var i = 0; i < ba.data.length / 2; i++){
        var
         complex = ba.get(i),
         b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
        var b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
    }
    sz[0] = (4 + ba.dims.length) * 4;
    sz[1] = (4 + ba.dims.length) * 8;
   }
   function caml_ba_get_size_per_element(kind){
    switch(kind){case 7:case 10:case 11: return 2;default: return 1;
    }
   }
   function caml_ba_create_buffer(kind, size){
    var view;
    switch(kind){
      case 0:
       view = Float32Array; break;
      case 1:
       view = Float64Array; break;
      case 2:
       view = Int8Array; break;
      case 3:
       view = Uint8Array; break;
      case 4:
       view = Int16Array; break;
      case 5:
       view = Uint16Array; break;
      case 6:
       view = Int32Array; break;
      case 7:
       view = Int32Array; break;
      case 8:
       view = Int32Array; break;
      case 9:
       view = Int32Array; break;
      case 10:
       view = Float32Array; break;
      case 11:
       view = Float64Array; break;
      case 12:
       view = Uint8Array; break;
    }
    if(! view) caml_invalid_argument("Bigarray.create: unsupported kind");
    var data = new view(size * caml_ba_get_size_per_element(kind));
    return data;
   }
   function caml_int32_float_of_bits(x){
    var int32a = new Int32Array(1);
    int32a[0] = x;
    var float32a = new Float32Array(int32a.buffer);
    return float32a[0];
   }
   function caml_int64_float_of_bits(x){
    var lo = x.lo, mi = x.mi, hi = x.hi, exp = (hi & 0x7fff) >> 4;
    if(exp == 2047)
     return (lo | mi | hi & 0xf) == 0
             ? hi & 0x8000 ? - Infinity : Infinity
             : NaN;
    var k = Math.pow(2, - 24), res = (lo * k + mi) * k + (hi & 0xf);
    if(exp > 0){
     res += 16;
     res *= Math.pow(2, exp - 1027);
    }
    else
     res *= Math.pow(2, - 1026);
    if(hi & 0x8000) res = - res;
    return res;
   }
   function caml_ba_get_size(dims){
    var n_dims = dims.length, size = 1;
    for(var i = 0; i < n_dims; i++){
     if(dims[i] < 0)
      caml_invalid_argument("Bigarray.create: negative dimension");
     size = size * dims[i];
    }
    return size;
   }
   function caml_int64_create_lo_hi(lo, hi){
    return new
            MlInt64
            (lo & 0xffffff,
             lo >>> 24 & 0xff | (hi & 0xffff) << 8,
             hi >>> 16 & 0xffff);
   }
   function caml_int64_hi32(v){return v.hi32();}
   function caml_int64_lo32(v){return v.lo32();}
   var caml_ba_custom_name = "_bigarr02";
   function Ml_Bigarray(kind, layout, dims, buffer){
    this.kind = kind;
    this.layout = layout;
    this.dims = dims;
    this.data = buffer;
   }
   Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
   Ml_Bigarray.prototype.offset =
    function(arg){
     var ofs = 0;
     if(typeof arg === "number") arg = [arg];
     if(! (arg instanceof Array))
      caml_invalid_argument("bigarray.js: invalid offset");
     if(this.dims.length != arg.length)
      caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
     if(this.layout == 0)
      for(var i = 0; i < this.dims.length; i++){
       if(arg[i] < 0 || arg[i] >= this.dims[i]) caml_array_bound_error();
       ofs = ofs * this.dims[i] + arg[i];
      }
     else
      for(var i = this.dims.length - 1; i >= 0; i--){
       if(arg[i] < 1 || arg[i] > this.dims[i]) caml_array_bound_error();
       ofs = ofs * this.dims[i] + (arg[i] - 1);
      }
     return ofs;
    };
   Ml_Bigarray.prototype.get =
    function(ofs){
     switch(this.kind){
       case 7:
        var l = this.data[ofs * 2 + 0], h = this.data[ofs * 2 + 1];
        return caml_int64_create_lo_hi(l, h);
       case 10:
       case 11:
        var r = this.data[ofs * 2 + 0], i = this.data[ofs * 2 + 1];
        return [254, r, i];
       default: return this.data[ofs];
     }
    };
   Ml_Bigarray.prototype.set =
    function(ofs, v){
     switch(this.kind){
       case 7:
        this.data[ofs * 2 + 0] = caml_int64_lo32(v);
        this.data[ofs * 2 + 1] = caml_int64_hi32(v);
        break;
       case 10:
       case 11:
        this.data[ofs * 2 + 0] = v[1]; this.data[ofs * 2 + 1] = v[2]; break;
       default: this.data[ofs] = v; break;
     }
     return 0;
    };
   Ml_Bigarray.prototype.fill =
    function(v){
     switch(this.kind){
       case 7:
        var a = caml_int64_lo32(v), b = caml_int64_hi32(v);
        if(a == b)
         this.data.fill(a);
        else
         for(var i = 0; i < this.data.length; i++)
          this.data[i] = i % 2 == 0 ? a : b;
        break;
       case 10:
       case 11:
        var im = v[1], re = v[2];
        if(im == re)
         this.data.fill(im);
        else
         for(var i = 0; i < this.data.length; i++)
          this.data[i] = i % 2 == 0 ? im : re;
        break;
       default: this.data.fill(v); break;
     }
    };
   Ml_Bigarray.prototype.compare =
    function(b, total){
     if(this.layout != b.layout || this.kind != b.kind){
      var k1 = this.kind | this.layout << 8, k2 = b.kind | b.layout << 8;
      return k2 - k1;
     }
     if(this.dims.length != b.dims.length)
      return b.dims.length - this.dims.length;
     for(var i = 0; i < this.dims.length; i++)
      if(this.dims[i] != b.dims[i]) return this.dims[i] < b.dims[i] ? - 1 : 1;
     switch(this.kind){
       case 0:
       case 1:
       case 10:
       case 11:
        var x, y;
        for(var i = 0; i < this.data.length; i++){
         x = this.data[i];
         y = b.data[i];
         if(x < y) return - 1;
         if(x > y) return 1;
         if(x != y){
          if(! total) return NaN;
          if(x == x) return 1;
          if(y == y) return - 1;
         }
        }
        break;
       case 7:
        for(var i = 0; i < this.data.length; i += 2){
         if(this.data[i + 1] < b.data[i + 1]) return - 1;
         if(this.data[i + 1] > b.data[i + 1]) return 1;
         if(this.data[i] >>> 0 < b.data[i] >>> 0) return - 1;
         if(this.data[i] >>> 0 > b.data[i] >>> 0) return 1;
        }
        break;
       case 2:
       case 3:
       case 4:
       case 5:
       case 6:
       case 8:
       case 9:
       case 12:
        for(var i = 0; i < this.data.length; i++){
         if(this.data[i] < b.data[i]) return - 1;
         if(this.data[i] > b.data[i]) return 1;
        }
        break;
     }
     return 0;
    };
   function Ml_Bigarray_c_1_1(kind, layout, dims, buffer){
    this.kind = kind;
    this.layout = layout;
    this.dims = dims;
    this.data = buffer;
   }
   Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
   Ml_Bigarray_c_1_1.prototype.offset =
    function(arg){
     if(typeof arg !== "number")
      if(arg instanceof Array && arg.length == 1)
       arg = arg[0];
      else
       caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
     if(arg < 0 || arg >= this.dims[0]) caml_array_bound_error();
     return arg;
    };
   Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs];};
   Ml_Bigarray_c_1_1.prototype.set =
    function(ofs, v){this.data[ofs] = v; return 0;};
   Ml_Bigarray_c_1_1.prototype.fill =
    function(v){this.data.fill(v); return 0;};
   function caml_ba_create_unsafe(kind, layout, dims, data){
    var size_per_element = caml_ba_get_size_per_element(kind);
    if(caml_ba_get_size(dims) * size_per_element != data.length)
     caml_invalid_argument("length doesn't match dims");
    if(layout == 0 && dims.length == 1 && size_per_element == 1)
     return new Ml_Bigarray_c_1_1(kind, layout, dims, data);
    return new Ml_Bigarray(kind, layout, dims, data);
   }
   function caml_ba_deserialize(reader, sz, name){
    var num_dims = reader.read32s();
    if(num_dims < 0 || num_dims > 16)
     caml_failwith("input_value: wrong number of bigarray dimensions");
    var
     tag = reader.read32s(),
     kind = tag & 0xff,
     layout = tag >> 8 & 1,
     dims = [];
    if(name == "_bigarr02")
     for(var i = 0; i < num_dims; i++){
      var size_dim = reader.read16u();
      if(size_dim == 0xffff){
       var size_dim_hi = reader.read32u(), size_dim_lo = reader.read32u();
       if(size_dim_hi != 0)
        caml_failwith("input_value: bigarray dimension overflow in 32bit");
       size_dim = size_dim_lo;
      }
      dims.push(size_dim);
     }
    else
     for(var i = 0; i < num_dims; i++) dims.push(reader.read32u());
    var
     size = caml_ba_get_size(dims),
     data = caml_ba_create_buffer(kind, size),
     ba = caml_ba_create_unsafe(kind, layout, dims, data);
    switch(kind){
      case 2:
       for(var i = 0; i < size; i++) data[i] = reader.read8s(); break;
      case 3:
      case 12:
       for(var i = 0; i < size; i++) data[i] = reader.read8u(); break;
      case 4:
       for(var i = 0; i < size; i++) data[i] = reader.read16s(); break;
      case 5:
       for(var i = 0; i < size; i++) data[i] = reader.read16u(); break;
      case 6:
       for(var i = 0; i < size; i++) data[i] = reader.read32s(); break;
      case 8:
      case 9:
       var sixty = reader.read8u();
       if(sixty)
        caml_failwith
         ("input_value: cannot read bigarray with 64-bit OCaml ints");
       for(var i = 0; i < size; i++) data[i] = reader.read32s();
       break;
      case 7:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var int64 = caml_int64_of_bytes(t);
        ba.set(i, int64);
       }
       break;
      case 1:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var f = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        ba.set(i, f);
       }
       break;
      case 0:
       for(var i = 0; i < size; i++){
        var f = caml_int32_float_of_bits(reader.read32s());
        ba.set(i, f);
       }
       break;
      case 10:
       for(var i = 0; i < size; i++){
        var
         re = caml_int32_float_of_bits(reader.read32s()),
         im = caml_int32_float_of_bits(reader.read32s());
        ba.set(i, [254, re, im]);
       }
       break;
      case 11:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var re = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var im = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        ba.set(i, [254, re, im]);
       }
       break;
    }
    sz[0] = (4 + num_dims) * 4;
    return caml_ba_create_unsafe(kind, layout, dims, data);
   }
   function caml_ba_compare(a, b, total){return a.compare(b, total);}
   function caml_hash_mix_int64(h, v){
    h = caml_hash_mix_int(h, caml_int64_lo32(v));
    h = caml_hash_mix_int(h, caml_int64_hi32(v));
    return h;
   }
   function caml_hash_mix_float(h, v0){
    return caml_hash_mix_int64(h, caml_int64_bits_of_float(v0));
   }
   function caml_ba_hash(ba){
    var num_elts = caml_ba_get_size(ba.dims), h = 0;
    switch(ba.kind){
      case 2:
      case 3:
      case 12:
       if(num_elts > 256) num_elts = 256;
       var w = 0, i = 0;
       for(i = 0; i + 4 <= ba.data.length; i += 4){
        w =
         ba.data[i + 0] | ba.data[i + 1] << 8 | ba.data[i + 2] << 16
         | ba.data[i + 3] << 24;
        h = caml_hash_mix_int(h, w);
       }
       w = 0;
       switch(num_elts & 3){
         case 3:
          w = ba.data[i + 2] << 16;
         case 2:
          w |= ba.data[i + 1] << 8;
         case 1:
          w |= ba.data[i + 0]; h = caml_hash_mix_int(h, w);
       }
       break;
      case 4:
      case 5:
       if(num_elts > 128) num_elts = 128;
       var w = 0, i = 0;
       for(i = 0; i + 2 <= ba.data.length; i += 2){
        w = ba.data[i + 0] | ba.data[i + 1] << 16;
        h = caml_hash_mix_int(h, w);
       }
       if((num_elts & 1) != 0) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 6:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 8:
      case 9:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 7:
       if(num_elts > 32) num_elts = 32;
       num_elts *= 2;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 10:
       num_elts *= 2;
      case 0:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float(h, ba.data[i]);
       break;
      case 11:
       num_elts *= 2;
      case 1:
       if(num_elts > 32) num_elts = 32;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float(h, ba.data[i]);
       break;
    }
    return h;
   }
   function caml_int32_unmarshal(reader, size){size[0] = 4; return reader.read32s();
   }
   function caml_nativeint_unmarshal(reader, size){
    switch(reader.read8u()){
      case 1:
       size[0] = 4; return reader.read32s();
      case 2:
       caml_failwith("input_value: native integer value too large");
      default: caml_failwith("input_value: ill-formed native integer");
    }
   }
   function caml_int64_unmarshal(reader, size){
    var t = new Array(8);
    for(var j = 0; j < 8; j++) t[j] = reader.read8u();
    size[0] = 8;
    return caml_int64_of_bytes(t);
   }
   function caml_int64_compare(x, y, total){return x.compare(y);}
   function caml_int64_hash(v){return v.lo32() ^ v.hi32();}
   var
    caml_custom_ops =
      {"_j":
       {deserialize: caml_int64_unmarshal,
        serialize: caml_int64_marshal,
        fixed_length: 8,
        compare: caml_int64_compare,
        hash: caml_int64_hash},
       "_i": {deserialize: caml_int32_unmarshal, fixed_length: 4},
       "_n": {deserialize: caml_nativeint_unmarshal, fixed_length: 4},
       "_bigarray":
       {deserialize:
        function(reader, sz){
         return caml_ba_deserialize(reader, sz, "_bigarray");
        },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader, sz){
         return caml_ba_deserialize(reader, sz, "_bigarr02");
        },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash}};
   function caml_compare_val_get_custom(a){
    return caml_custom_ops[a.caml_custom]
           && caml_custom_ops[a.caml_custom].compare;
   }
   function caml_compare_val_number_custom(num, custom, swap, total){
    var comp = caml_compare_val_get_custom(custom);
    if(comp){
     var x = swap > 0 ? comp(custom, num, total) : comp(num, custom, total);
     if(total && x != x) return swap;
     if(+ x != + x) return + x;
     if((x | 0) != 0) return x | 0;
    }
    return swap;
   }
   function caml_compare_val_tag(a){
    if(typeof a === "number")
     return 1000;
    else if(caml_is_ml_bytes(a))
     return 252;
    else if(caml_is_ml_string(a))
     return 1252;
    else if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255){var tag = a[0] | 0; return tag == 254 ? 0 : tag;}
    else if(a instanceof String)
     return 12520;
    else if(typeof a == "string")
     return 12520;
    else if(a instanceof Number)
     return 1000;
    else if(a && a.caml_custom)
     return 1255;
    else if(a && a.compare)
     return 1256;
    else if(typeof a == "function")
     return 1247;
    else if(typeof a == "symbol") return 1251;
    return 1001;
   }
   function caml_int_compare(a, b){
    if(a < b) return - 1;
    if(a == b) return 0;
    return 1;
   }
   function caml_string_compare(s1, s2){
    return s1 < s2 ? - 1 : s1 > s2 ? 1 : 0;
   }
   function caml_bytes_compare(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c < s2.c ? - 1 : s1.c > s2.c ? 1 : 0;
   }
   function caml_compare_val(a, b, total){
    var stack = [];
    for(;;){
     if(! (total && a === b)){
      var tag_a = caml_compare_val_tag(a);
      if(tag_a == 250){a = a[1]; continue;}
      var tag_b = caml_compare_val_tag(b);
      if(tag_b == 250){b = b[1]; continue;}
      if(tag_a !== tag_b){
       if(tag_a == 1000){
        if(tag_b == 1255)
         return caml_compare_val_number_custom(a, b, - 1, total);
        return - 1;
       }
       if(tag_b == 1000){
        if(tag_a == 1255)
         return caml_compare_val_number_custom(b, a, 1, total);
        return 1;
       }
       return tag_a < tag_b ? - 1 : 1;
      }
      switch(tag_a){
        case 247:
         caml_invalid_argument("compare: functional value"); break;
        case 248:
         var x = caml_int_compare(a[2], b[2]); if(x != 0) return x | 0; break;
        case 249:
         caml_invalid_argument("compare: functional value"); break;
        case 250:
         caml_invalid_argument("equal: got Forward_tag, should not happen");
         break;
        case 251:
         caml_invalid_argument("equal: abstract value"); break;
        case 252:
         if(a !== b){
          var x = caml_bytes_compare(a, b);
          if(x != 0) return x | 0;
         }
         break;
        case 253:
         caml_invalid_argument("equal: got Double_tag, should not happen");
         break;
        case 254:
         caml_invalid_argument
          ("equal: got Double_array_tag, should not happen");
         break;
        case 255:
         caml_invalid_argument("equal: got Custom_tag, should not happen");
         break;
        case 1247:
         caml_invalid_argument("compare: functional value"); break;
        case 1255:
         var comp = caml_compare_val_get_custom(a);
         if(comp != caml_compare_val_get_custom(b))
          return a.caml_custom < b.caml_custom ? - 1 : 1;
         if(! comp) caml_invalid_argument("compare: abstract value");
         var x = comp(a, b, total);
         if(x != x) return total ? - 1 : x;
         if(x !== (x | 0)) return - 1;
         if(x != 0) return x | 0;
         break;
        case 1256:
         var x = a.compare(b, total);
         if(x != x) return total ? - 1 : x;
         if(x !== (x | 0)) return - 1;
         if(x != 0) return x | 0;
         break;
        case 1000:
         a = + a;
         b = + b;
         if(a < b) return - 1;
         if(a > b) return 1;
         if(a != b){
          if(! total) return NaN;
          if(a == a) return 1;
          if(b == b) return - 1;
         }
         break;
        case 1001:
         if(a < b) return - 1;
         if(a > b) return 1;
         if(a != b){
          if(! total) return NaN;
          if(a == a) return 1;
          if(b == b) return - 1;
         }
         break;
        case 1251:
         if(a !== b){if(! total) return NaN; return 1;} break;
        case 1252:
         var a = caml_jsbytes_of_string(a), b = caml_jsbytes_of_string(b);
         if(a !== b){if(a < b) return - 1; if(a > b) return 1;}
         break;
        case 12520:
         var a = a.toString(), b = b.toString();
         if(a !== b){if(a < b) return - 1; if(a > b) return 1;}
         break;
        case 246:
        case 254:
        default:
         if(caml_is_continuation_tag(tag_a)){
          caml_invalid_argument("compare: continuation value");
          break;
         }
         if(a.length != b.length) return a.length < b.length ? - 1 : 1;
         if(a.length > 1) stack.push(a, b, 1);
         break;
      }
     }
     if(stack.length == 0) return 0;
     var i = stack.pop();
     b = stack.pop();
     a = stack.pop();
     if(i + 1 < a.length) stack.push(a, b, i + 1);
     a = a[i];
     b = b[i];
    }
   }
   function caml_greaterthan(x, y){
    return + (caml_compare_val(x, y, false) > 0);
   }
   function div_helper(a, b, c){
    var
     x = a * 65536 + (b >>> 16),
     y = Math.floor(x / c) * 65536,
     z = x % c * 65536,
     w = z + (b & 0x0000FFFF);
    return [y + Math.floor(w / c), w % c];
   }
   function div_digit_nat(natq, ofsq, natr, ofsr, nat1, ofs1, len, nat2, ofs2){
    var rem = nat1.data[ofs1 + len - 1] >>> 0;
    for(var i = len - 2; i >= 0; i--){
     var
      x = div_helper(rem, nat1.data[ofs1 + i] >>> 0, nat2.data[ofs2] >>> 0);
     natq.data[ofsq + i] = x[0];
     rem = x[1];
    }
    natr.data[ofsr] = rem;
    return 0;
   }
   function num_leading_zero_bits_in_digit(nat, ofs){
    var a = nat.data[ofs], b = 0;
    if(a & 0xFFFF0000){b += 16; a >>>= 16;}
    if(a & 0xFF00){b += 8; a >>>= 8;}
    if(a & 0xF0){b += 4; a >>>= 4;}
    if(a & 12){b += 2; a >>>= 2;}
    if(a & 2){b += 1; a >>>= 1;}
    if(a & 1) b += 1;
    return 32 - b;
   }
   function shift_left_nat(nat1, ofs1, len1, nat2, ofs2, nbits){
    if(nbits == 0){nat2.data[ofs2] = 0; return 0;}
    var wrap = 0;
    for(var i = 0; i < len1; i++){
     var a = nat1.data[ofs1 + i] >>> 0;
     nat1.data[ofs1 + i] = a << nbits | wrap;
     wrap = a >>> 32 - nbits;
    }
    nat2.data[ofs2] = wrap;
    return 0;
   }
   function MlNat(x){
    this.data = new Int32Array(x);
    this.length = this.data.length + 2;
   }
   MlNat.prototype.caml_custom = "_nat";
   function create_nat(size){
    var arr = new MlNat(size);
    for(var i = 0; i < size; i++) arr.data[i] = - 1;
    return arr;
   }
   function set_to_zero_nat(nat, ofs, len){
    for(var i = 0; i < len; i++) nat.data[ofs + i] = 0;
    return 0;
   }
   function incr_nat(nat, ofs, len, carry_in){
    var carry = carry_in;
    for(var i = 0; i < len; i++){
     var x = (nat.data[ofs + i] >>> 0) + carry;
     nat.data[ofs + i] = x | 0;
     if(x == x >>> 0){carry = 0; break;} else carry = 1;
    }
    return carry;
   }
   function add_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in){
    var carry = carry_in;
    for(var i = 0; i < len2; i++){
     var
      x = (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
     nat1.data[ofs1 + i] = x;
     if(x == x >>> 0) carry = 0; else carry = 1;
    }
    return incr_nat(nat1, ofs1 + len2, len1 - len2, carry);
   }
   function nat_of_array(l){return new MlNat(l);}
   function mult_digit_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3){
    var carry = 0, a = nat3.data[ofs3] >>> 0;
    for(var i = 0; i < len2; i++){
     var
      x1 =
        (nat1.data[ofs1 + i] >>> 0)
        + (nat2.data[ofs2 + i] >>> 0) * (a & 0x0000FFFF)
        + carry,
      x2 = (nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
     carry = Math.floor(x2 / 65536);
     var x3 = x1 + x2 % 65536 * 65536;
     nat1.data[ofs1 + i] = x3;
     carry += Math.floor(x3 / 4294967296);
    }
    return len2 < len1 && carry
            ? add_nat
              (nat1, ofs1 + len2, len1 - len2, nat_of_array([carry]), 0, 1, 0)
            : carry;
   }
   function decr_nat(nat, ofs, len, carry_in){
    var borrow = carry_in == 1 ? 0 : 1;
    for(var i = 0; i < len; i++){
     var x = (nat.data[ofs + i] >>> 0) - borrow;
     nat.data[ofs + i] = x;
     if(x >= 0){borrow = 0; break;} else borrow = 1;
    }
    return borrow == 1 ? 0 : 1;
   }
   function sub_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in){
    var borrow = carry_in == 1 ? 0 : 1;
    for(var i = 0; i < len2; i++){
     var
      x = (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
     nat1.data[ofs1 + i] = x;
     if(x >= 0) borrow = 0; else borrow = 1;
    }
    return decr_nat(nat1, ofs1 + len2, len1 - len2, borrow == 1 ? 0 : 1);
   }
   function compare_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    var
     a = num_digits_nat(nat1, ofs1, len1),
     b = num_digits_nat(nat2, ofs2, len2);
    if(a > b) return 1;
    if(a < b) return - 1;
    for(var i = len1 - 1; i >= 0; i--){
     if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0) return 1;
     if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0) return - 1;
    }
    return 0;
   }
   function div_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    if(len2 == 1){
     div_digit_nat(nat1, ofs1 + 1, nat1, ofs1, nat1, ofs1, len1, nat2, ofs2);
     return 0;
    }
    var s = num_leading_zero_bits_in_digit(nat2, ofs2 + len2 - 1);
    shift_left_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s);
    shift_left_nat(nat1, ofs1, len1, nat_of_array([0]), 0, s);
    var d = (nat2.data[ofs2 + len2 - 1] >>> 0) + 1, a = create_nat(len2 + 1);
    for(var i = len1 - 1; i >= len2; i--){
     var
      quo =
        d == 4294967296
         ? nat1.data[ofs1 + i] >>> 0
         : div_helper
            (nat1.data[ofs1 + i] >>> 0, nat1.data[ofs1 + i - 1] >>> 0, d)
           [0];
     set_to_zero_nat(a, 0, len2 + 1);
     mult_digit_nat(a, 0, len2 + 1, nat2, ofs2, len2, nat_of_array([quo]), 0);
     sub_nat(nat1, ofs1 + i - len2, len2 + 1, a, 0, len2 + 1, 1);
     while
     (nat1.data[ofs1 + i] != 0
      || compare_nat(nat1, ofs1 + i - len2, len2, nat2, ofs2, len2) >= 0){
      quo = quo + 1;
      sub_nat(nat1, ofs1 + i - len2, len2 + 1, nat2, ofs2, len2, 1);
     }
     nat1.data[ofs1 + i] = quo;
    }
    shift_right_nat(nat1, ofs1, len2, nat_of_array([0]), 0, s);
    shift_right_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s);
    return 0;
   }
   function caml_ba_blit(src, dst){
    if(dst.dims.length != src.dims.length)
     caml_invalid_argument("Bigarray.blit: dimension mismatch");
    for(var i = 0; i < dst.dims.length; i++)
     if(dst.dims[i] != src.dims[i])
      caml_invalid_argument("Bigarray.blit: dimension mismatch");
    dst.data.set(src.data);
    return 0;
   }
   function is_digit_int(nat, ofs){if(nat.data[ofs] >= 0) return 1; return 0;}
   function caml_int64_div(x, y){return x.div(y);}
   function caml_js_html_entities(s){
    var entity = /^&#?[0-9a-zA-Z]+;$/;
    if(s.match(entity)){
     var str, temp = document.createElement("p");
     temp.innerHTML = s;
     str = temp.textContent || temp.innerText;
     temp = null;
     return str;
    }
    else
     caml_failwith("Invalid entity " + s);
   }
   function caml_string_unsafe_set(s, i, c){
    caml_failwith("caml_string_unsafe_set");
   }
   function caml_int64_of_float(x){
    if(x < 0) x = Math.ceil(x);
    return new
            MlInt64
            (x & 0xffffff,
             Math.floor(x * caml_int64_offset) & 0xffffff,
             Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff);
   }
   function caml_ml_channel_size_64(chanid){
    var chan = caml_ml_channels[chanid];
    return caml_int64_of_float(chan.file.length());
   }
   function caml_ba_set_2(ba, i0, i1, v){
    ba.set(ba.offset([i0, i1]), v);
    return 0;
   }
   var
    caml_argv =
      function(){
        var process = globalThis.process, main = "a.out", args = [];
        if(process && process.argv && process.argv.length > 1){
         var argv = process.argv;
         main = argv[1];
         args = argv.slice(2);
        }
        var p = caml_string_of_jsstring(main), args2 = [0, p];
        for(var i = 0; i < args.length; i++)
         args2.push(caml_string_of_jsstring(args[i]));
        return args2;
       }
       (),
    caml_executable_name = caml_argv[1];
   function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s));}
   function serialize_nat(writer, nat, sz){
    var len = nat.data.length;
    writer.write(32, len);
    for(var i = 0; i < len; i++) writer.write(32, nat.data[i]);
    sz[0] = len * 4;
    sz[1] = len * 8;
   }
   function caml_memprof_set(_control){return 0;}
   function caml_sys_exit(code){
    if(globalThis.quit) globalThis.quit(code);
    if(globalThis.process && globalThis.process.exit)
     globalThis.process.exit(code);
    caml_invalid_argument("Function 'exit' not implemented");
   }
   function caml_channel_descriptor(chanid){
    var chan = caml_ml_channels[chanid];
    return chan.fd;
   }
   function caml_js_from_array(a){return a.slice(1);}
   function caml_ba_reshape(ba, vind){
    vind = caml_js_from_array(vind);
    var new_dim = [], num_dims = vind.length;
    if(num_dims < 0 || num_dims > 16)
     caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
    var num_elts = 1;
    for(var i = 0; i < num_dims; i++){
     new_dim[i] = vind[i];
     if(new_dim[i] < 0)
      caml_invalid_argument("Bigarray.reshape: negative dimension");
     num_elts = num_elts * new_dim[i];
    }
    var size = caml_ba_get_size(ba.dims);
    if(num_elts != size)
     caml_invalid_argument("Bigarray.reshape: size mismatch");
    return caml_ba_create_unsafe(ba.kind, ba.layout, new_dim, ba.data);
   }
   var caml_oo_last_id = 0;
   function caml_set_oo_id(b){b[2] = caml_oo_last_id++; return b;}
   function caml_gr_fill_rect(x, y, w, h){
    var s = caml_gr_state_get();
    s.context.fillRect(x, s.height - y, w, - h);
    return 0;
   }
   function caml_bigstring_blit_string_to_ba(str1, pos1, ba2, pos2, len){
    if(12 != ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs2 = ba2.offset(pos2);
    if(pos1 + len > caml_ml_string_length(str1)) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = caml_uint8_array_of_string(str1).slice(pos1, pos1 + len);
    ba2.data.set(slice, ofs2);
    return 0;
   }
   function caml_gr_set_window_title(name){
    var s = caml_gr_state_get();
    s.title = name;
    var jsname = caml_jsstring_of_string(name);
    if(s.set_title) s.set_title(jsname);
    return 0;
   }
   function caml_get_global_data(){return caml_global_data;}
   function caml_int64_shift_right_unsigned(x, s){return x.shift_right_unsigned(s);
   }
   function caml_ba_uint8_get16(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 1 >= ba.data.length) caml_array_bound_error();
    var b1 = ba.get(ofs), b2 = ba.get(ofs + 1);
    return b1 | b2 << 8;
   }
   function caml_compare(a, b){return caml_compare_val(a, b, true);}
   var
    caml_MD5Transform =
      function(){
        function add(x, y){return x + y | 0;}
        function xx(q, a, b, x, s, t){
         a = add(add(a, q), add(x, t));
         return add(a << s | a >>> 32 - s, b);
        }
        function ff(a, b, c, d, x, s, t){
         return xx(b & c | ~ b & d, a, b, x, s, t);
        }
        function gg(a, b, c, d, x, s, t){
         return xx(b & d | c & ~ d, a, b, x, s, t);
        }
        function hh(a, b, c, d, x, s, t){return xx(b ^ c ^ d, a, b, x, s, t);}
        function ii(a, b, c, d, x, s, t){
         return xx(c ^ (b | ~ d), a, b, x, s, t);
        }
        return function(w, buffer){
         var a = w[0], b = w[1], c = w[2], d = w[3];
         a = ff(a, b, c, d, buffer[0], 7, 0xD76AA478);
         d = ff(d, a, b, c, buffer[1], 12, 0xE8C7B756);
         c = ff(c, d, a, b, buffer[2], 17, 0x242070DB);
         b = ff(b, c, d, a, buffer[3], 22, 0xC1BDCEEE);
         a = ff(a, b, c, d, buffer[4], 7, 0xF57C0FAF);
         d = ff(d, a, b, c, buffer[5], 12, 0x4787C62A);
         c = ff(c, d, a, b, buffer[6], 17, 0xA8304613);
         b = ff(b, c, d, a, buffer[7], 22, 0xFD469501);
         a = ff(a, b, c, d, buffer[8], 7, 0x698098D8);
         d = ff(d, a, b, c, buffer[9], 12, 0x8B44F7AF);
         c = ff(c, d, a, b, buffer[10], 17, 0xFFFF5BB1);
         b = ff(b, c, d, a, buffer[11], 22, 0x895CD7BE);
         a = ff(a, b, c, d, buffer[12], 7, 0x6B901122);
         d = ff(d, a, b, c, buffer[13], 12, 0xFD987193);
         c = ff(c, d, a, b, buffer[14], 17, 0xA679438E);
         b = ff(b, c, d, a, buffer[15], 22, 0x49B40821);
         a = gg(a, b, c, d, buffer[1], 5, 0xF61E2562);
         d = gg(d, a, b, c, buffer[6], 9, 0xC040B340);
         c = gg(c, d, a, b, buffer[11], 14, 0x265E5A51);
         b = gg(b, c, d, a, buffer[0], 20, 0xE9B6C7AA);
         a = gg(a, b, c, d, buffer[5], 5, 0xD62F105D);
         d = gg(d, a, b, c, buffer[10], 9, 0x02441453);
         c = gg(c, d, a, b, buffer[15], 14, 0xD8A1E681);
         b = gg(b, c, d, a, buffer[4], 20, 0xE7D3FBC8);
         a = gg(a, b, c, d, buffer[9], 5, 0x21E1CDE6);
         d = gg(d, a, b, c, buffer[14], 9, 0xC33707D6);
         c = gg(c, d, a, b, buffer[3], 14, 0xF4D50D87);
         b = gg(b, c, d, a, buffer[8], 20, 0x455A14ED);
         a = gg(a, b, c, d, buffer[13], 5, 0xA9E3E905);
         d = gg(d, a, b, c, buffer[2], 9, 0xFCEFA3F8);
         c = gg(c, d, a, b, buffer[7], 14, 0x676F02D9);
         b = gg(b, c, d, a, buffer[12], 20, 0x8D2A4C8A);
         a = hh(a, b, c, d, buffer[5], 4, 0xFFFA3942);
         d = hh(d, a, b, c, buffer[8], 11, 0x8771F681);
         c = hh(c, d, a, b, buffer[11], 16, 0x6D9D6122);
         b = hh(b, c, d, a, buffer[14], 23, 0xFDE5380C);
         a = hh(a, b, c, d, buffer[1], 4, 0xA4BEEA44);
         d = hh(d, a, b, c, buffer[4], 11, 0x4BDECFA9);
         c = hh(c, d, a, b, buffer[7], 16, 0xF6BB4B60);
         b = hh(b, c, d, a, buffer[10], 23, 0xBEBFBC70);
         a = hh(a, b, c, d, buffer[13], 4, 0x289B7EC6);
         d = hh(d, a, b, c, buffer[0], 11, 0xEAA127FA);
         c = hh(c, d, a, b, buffer[3], 16, 0xD4EF3085);
         b = hh(b, c, d, a, buffer[6], 23, 0x04881D05);
         a = hh(a, b, c, d, buffer[9], 4, 0xD9D4D039);
         d = hh(d, a, b, c, buffer[12], 11, 0xE6DB99E5);
         c = hh(c, d, a, b, buffer[15], 16, 0x1FA27CF8);
         b = hh(b, c, d, a, buffer[2], 23, 0xC4AC5665);
         a = ii(a, b, c, d, buffer[0], 6, 0xF4292244);
         d = ii(d, a, b, c, buffer[7], 10, 0x432AFF97);
         c = ii(c, d, a, b, buffer[14], 15, 0xAB9423A7);
         b = ii(b, c, d, a, buffer[5], 21, 0xFC93A039);
         a = ii(a, b, c, d, buffer[12], 6, 0x655B59C3);
         d = ii(d, a, b, c, buffer[3], 10, 0x8F0CCC92);
         c = ii(c, d, a, b, buffer[10], 15, 0xFFEFF47D);
         b = ii(b, c, d, a, buffer[1], 21, 0x85845DD1);
         a = ii(a, b, c, d, buffer[8], 6, 0x6FA87E4F);
         d = ii(d, a, b, c, buffer[15], 10, 0xFE2CE6E0);
         c = ii(c, d, a, b, buffer[6], 15, 0xA3014314);
         b = ii(b, c, d, a, buffer[13], 21, 0x4E0811A1);
         a = ii(a, b, c, d, buffer[4], 6, 0xF7537E82);
         d = ii(d, a, b, c, buffer[11], 10, 0xBD3AF235);
         c = ii(c, d, a, b, buffer[2], 15, 0x2AD7D2BB);
         b = ii(b, c, d, a, buffer[9], 21, 0xEB86D391);
         w[0] = add(a, w[0]);
         w[1] = add(b, w[1]);
         w[2] = add(c, w[2]);
         w[3] = add(d, w[3]);};
       }
       ();
   function caml_MD5Update(ctx, input, input_len){
    var in_buf = ctx.len & 0x3f, input_pos = 0;
    ctx.len += input_len;
    if(in_buf){
     var missing = 64 - in_buf;
     if(input_len < missing){
      ctx.b8.set(input.subarray(0, input_len), in_buf);
      return;
     }
     ctx.b8.set(input.subarray(0, missing), in_buf);
     caml_MD5Transform(ctx.w, ctx.b32);
     input_len -= missing;
     input_pos += missing;
    }
    while(input_len >= 64){
     ctx.b8.set(input.subarray(input_pos, input_pos + 64), 0);
     caml_MD5Transform(ctx.w, ctx.b32);
     input_len -= 64;
     input_pos += 64;
    }
    if(input_len)
     ctx.b8.set(input.subarray(input_pos, input_pos + input_len), 0);
   }
   function caml_runtime_events_read_poll(cursor, callbacks, num){return 0;}
   function caml_fresh_oo_id(){return caml_oo_last_id++;}
   function caml_int64_to_float(x){return x.toFloat();}
   function caml_ba_get_1(ba, i0){return ba.get(ba.offset(i0));}
   function caml_bigstring_memcmp(s1, pos1, s2, pos2, len){
    for(var i = 0; i < len; i++){
     var a = caml_ba_get_1(s1, pos1 + i), b = caml_ba_get_1(s2, pos2 + i);
     if(a < b) return - 1;
     if(a > b) return 1;
    }
    return 0;
   }
   function caml_new_string(s){return caml_string_of_jsbytes(s);}
   function caml_erf_float(x){
    var
     a1 = 0.254829592,
     a2 = - 0.284496736,
     a3 = 1.421413741,
     a4 = - 1.453152027,
     a5 = 1.061405429,
     p = 0.3275911,
     sign = 1;
    if(x < 0) sign = - 1;
    x = Math.abs(x);
    var
     t = 1.0 / (1.0 + p * x),
     y =
       1.0
       -
        ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t
        * Math.exp(- (x * x));
    return sign * y;
   }
   function caml_ba_uint8_get32(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 3 >= ba.data.length) caml_array_bound_error();
    var
     b1 = ba.get(ofs + 0),
     b2 = ba.get(ofs + 1),
     b3 = ba.get(ofs + 2),
     b4 = ba.get(ofs + 3);
    return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24;
   }
   function caml_raw_backtrace_length(){return 0;}
   function caml_str_initialize(unit){return 0;}
   function caml_obj_block(tag, size){
    var o = new Array(size + 1);
    o[0] = tag;
    for(var i = 1; i <= size; i++) o[i] = 0;
    return o;
   }
   function caml_gr_clear_graph(){
    var s = caml_gr_state_get();
    s.canvas.width = s.width;
    s.canvas.height = s.height;
    return 0;
   }
   function bigstring_to_array_buffer(bs){return bs.data.buffer;}
   function caml_sys_const_naked_pointers_checked(_unit){return 0;}
   function lxor_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] ^= nat2.data[ofs2]; return 0;
   }
   function caml_obj_add_offset(v, offset){
    caml_failwith("Obj.add_offset is not supported");
   }
   function caml_final_release(){return 0;}
   var caml_marshal_header_size = 20;
   function caml_js_to_array(a){
    var len = a.length, b = new Array(len + 1);
    b[0] = 0;
    for(var i = 0; i < len; i++) b[i + 1] = a[i];
    return b;
   }
   function caml_sys_is_regular_file(name){
    var root = resolve_fs_device(name);
    return root.device.isFile(root.rest);
   }
   function caml_gr_plot(x, y){
    var
     s = caml_gr_state_get(),
     im = s.context.createImageData(1, 1),
     d = im.data,
     color = s.color;
    d[0] = color >> 16 & 0xff;
    d[1] = color >> 8 & 0xff, d[2] = color >> 0 & 0xff;
    d[3] = 0xFF;
    s.x = x;
    s.y = y;
    s.context.putImageData(im, x, s.height - y);
    return 0;
   }
   function caml_bytes_set64(s, i, i64){
    if(i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = caml_int64_to_bytes(i64);
    for(var j = 0; j < 8; j++) caml_bytes_unsafe_set(s, i + 7 - j, a[j]);
    return 0;
   }
   function caml_string_set16(s, i, i16){caml_failwith("caml_string_set16");}
   function caml_int64_bswap(x){
    var y = caml_int64_to_bytes(x);
    return caml_int64_of_bytes
            ([y[7], y[6], y[5], y[4], y[3], y[2], y[1], y[0]]);
   }
   function caml_gc_major(unit){
    if(typeof globalThis.gc == "function") globalThis.gc();
    return 0;
   }
   function caml_lex_array(s){
    s = caml_jsbytes_of_string(s);
    var l = s.length / 2, a = new Array(l);
    for(var i = 0; i < l; i++)
     a[i] = (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8) << 16 >> 16;
    return a;
   }
   function caml_lex_engine(tbl, start_state, lexbuf){
    var
     lex_buffer = 2,
     lex_buffer_len = 3,
     lex_start_pos = 5,
     lex_curr_pos = 6,
     lex_last_pos = 7,
     lex_last_action = 8,
     lex_eof_reached = 9,
     lex_base = 1,
     lex_backtrk = 2,
     lex_default = 3,
     lex_trans = 4,
     lex_check = 5;
    if(! tbl.lex_default){
     tbl.lex_base = caml_lex_array(tbl[lex_base]);
     tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
     tbl.lex_check = caml_lex_array(tbl[lex_check]);
     tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
     tbl.lex_default = caml_lex_array(tbl[lex_default]);
    }
    var
     c,
     state = start_state,
     buffer = caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
    if(state >= 0){
     lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
     lexbuf[lex_last_action] = - 1;
    }
    else
     state = - state - 1;
    for(;;){
     var base = tbl.lex_base[state];
     if(base < 0) return - base - 1;
     var backtrk = tbl.lex_backtrk[state];
     if(backtrk >= 0){
      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
      lexbuf[lex_last_action] = backtrk;
     }
     if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
      if(lexbuf[lex_eof_reached] == 0) return - state - 1; else c = 256;
     else{c = buffer[lexbuf[lex_curr_pos]]; lexbuf[lex_curr_pos]++;}
     if(tbl.lex_check[base + c] == state)
      state = tbl.lex_trans[base + c];
     else
      state = tbl.lex_default[state];
     if(state < 0){
      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
      if(lexbuf[lex_last_action] == - 1)
       caml_failwith("lexing: empty token");
      else
       return lexbuf[lex_last_action];
     }
     else if(c == 256) lexbuf[lex_eof_reached] = 0;
    }
   }
   function caml_sys_file_exists(name){
    var root = resolve_fs_device(name);
    return root.device.exists(root.rest);
   }
   function caml_convert_raw_backtrace_slot(){
    caml_failwith("caml_convert_raw_backtrace_slot");
   }
   function caml_array_sub(a, i, len){
    var a2 = new Array(len + 1);
    a2[0] = 0;
    for(var i2 = 1, i1 = i + 1; i2 <= len; i2++, i1++) a2[i2] = a[i1];
    return a2;
   }
   function caml_bytes_equal(s1, s2){
    if(s1 === s2) return 1;
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c == s2.c ? 1 : 0;
   }
   function caml_gr_size_x(){var s = caml_gr_state_get(); return s.width;}
   function caml_ml_debug_info_status(){return 0;}
   function caml_atomic_fetch_add(ref, i){
    var old = ref[1];
    ref[1] += i;
    return old;
   }
   var
    os_type =
      globalThis.process && globalThis.process.platform
       && globalThis.process.platform == "win32"
       ? "Cygwin"
       : "Unix";
   function caml_sys_const_ostype_cygwin(){return os_type == "Cygwin" ? 1 : 0;
   }
   function caml_cosh_float(x){return Math.cosh(x);}
   function MlMutex(){this.locked = false;}
   function caml_ml_mutex_new(unit){return new MlMutex();}
   var caml_ephe_key_offset = 3;
   function caml_ephe_check_key(x, i){
    var weak = x[caml_ephe_key_offset + i];
    if(globalThis.WeakRef && weak instanceof globalThis.WeakRef)
     weak = weak.deref();
    return weak === undefined ? 0 : 1;
   }
   function caml_hash_mix_final(h){
    h ^= h >>> 16;
    h = caml_mul(h, 0x85ebca6b | 0);
    h ^= h >>> 13;
    h = caml_mul(h, 0xc2b2ae35 | 0);
    h ^= h >>> 16;
    return h;
   }
   function caml_gr_text_size(txt){
    var
     s = caml_gr_state_get(),
     w = s.context.measureText(caml_jsstring_of_string(txt)).width;
    return [0, w, s.text_size];
   }
   function caml_lex_run_mem(s, i, mem, curr_pos){
    for(;;){
     var dst = s.charCodeAt(i);
     i++;
     if(dst == 0xff) return;
     var src = s.charCodeAt(i);
     i++;
     if(src == 0xff)
      mem[dst + 1] = curr_pos;
     else
      mem[dst + 1] = mem[src + 1];
    }
   }
   function caml_lex_run_tag(s, i, mem){
    for(;;){
     var dst = s.charCodeAt(i);
     i++;
     if(dst == 0xff) return;
     var src = s.charCodeAt(i);
     i++;
     if(src == 0xff) mem[dst + 1] = - 1; else mem[dst + 1] = mem[src + 1];
    }
   }
   function caml_new_lex_engine(tbl, start_state, lexbuf){
    var
     lex_buffer = 2,
     lex_buffer_len = 3,
     lex_start_pos = 5,
     lex_curr_pos = 6,
     lex_last_pos = 7,
     lex_last_action = 8,
     lex_eof_reached = 9,
     lex_mem = 10,
     lex_base = 1,
     lex_backtrk = 2,
     lex_default = 3,
     lex_trans = 4,
     lex_check = 5,
     lex_base_code = 6,
     lex_backtrk_code = 7,
     lex_default_code = 8,
     lex_trans_code = 9,
     lex_check_code = 10,
     lex_code = 11;
    if(! tbl.lex_default){
     tbl.lex_base = caml_lex_array(tbl[lex_base]);
     tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
     tbl.lex_check = caml_lex_array(tbl[lex_check]);
     tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
     tbl.lex_default = caml_lex_array(tbl[lex_default]);
    }
    if(! tbl.lex_default_code){
     tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
     tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
     tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
     tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
     tbl.lex_default_code = caml_lex_array(tbl[lex_default_code]);
    }
    if(tbl.lex_code == null)
     tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
    var
     c,
     state = start_state,
     buffer = caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
    if(state >= 0){
     lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
     lexbuf[lex_last_action] = - 1;
    }
    else
     state = - state - 1;
    for(;;){
     var base = tbl.lex_base[state];
     if(base < 0){
      var pc_off = tbl.lex_base_code[state];
      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
      return - base - 1;
     }
     var backtrk = tbl.lex_backtrk[state];
     if(backtrk >= 0){
      var pc_off = tbl.lex_backtrk_code[state];
      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
      lexbuf[lex_last_action] = backtrk;
     }
     if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
      if(lexbuf[lex_eof_reached] == 0) return - state - 1; else c = 256;
     else{c = buffer[lexbuf[lex_curr_pos]]; lexbuf[lex_curr_pos]++;}
     var pstate = state;
     if(tbl.lex_check[base + c] == state)
      state = tbl.lex_trans[base + c];
     else
      state = tbl.lex_default[state];
     if(state < 0){
      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
      if(lexbuf[lex_last_action] == - 1)
       caml_failwith("lexing: empty token");
      else
       return lexbuf[lex_last_action];
     }
     else{
      var base_code = tbl.lex_base_code[pstate], pc_off;
      if(tbl.lex_check_code[base_code + c] == pstate)
       pc_off = tbl.lex_trans_code[base_code + c];
      else
       pc_off = tbl.lex_default_code[pstate];
      if(pc_off > 0)
       caml_lex_run_mem
        (tbl.lex_code, pc_off, lexbuf[lex_mem], lexbuf[lex_curr_pos]);
      if(c == 256) lexbuf[lex_eof_reached] = 0;
     }
    }
   }
   function caml_ba_uint8_set64(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 7 >= ba.data.length) caml_array_bound_error();
    var v = caml_int64_to_bytes(v);
    for(var i = 0; i < 8; i++) ba.set(ofs + i, v[7 - i]);
    return 0;
   }
   function caml_sys_executable_name(a){return caml_executable_name;}
   function caml_lessequal(x, y){
    return + (caml_compare_val(x, y, false) <= 0);
   }
   function caml_acosh_float(x){return Math.acosh(x);}
   function caml_MD5Init(){
    var
     buffer = new ArrayBuffer(64),
     b32 = new Uint32Array(buffer),
     b8 = new Uint8Array(buffer);
    return {len: 0,
            w:
            new Uint32Array([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476]),
            b32: b32,
            b8: b8};
   }
   function caml_ml_flush(chanid){
    var chan = caml_ml_channels[chanid];
    if(! chan.opened) caml_raise_sys_error("Cannot flush a closed channel");
    if(! chan.buffer || chan.buffer_curr == 0) return 0;
    if(chan.output)
     chan.output(caml_subarray_to_jsbytes(chan.buffer, 0, chan.buffer_curr));
    else
     chan.file.write(chan.offset, chan.buffer, 0, chan.buffer_curr);
    chan.offset += chan.buffer_curr;
    chan.buffer_curr = 0;
    return 0;
   }
   function caml_seek_out(chanid, pos){
    caml_ml_flush(chanid);
    var chan = caml_ml_channels[chanid];
    chan.offset = pos;
    return 0;
   }
   function caml_ml_seek_out_64(chanid, pos){
    var pos = caml_int64_to_float(pos);
    return caml_seek_out(chanid, pos);
   }
   function compare_nat_real(nat1, nat2){
    return compare_nat(nat1, 0, nat1.data.length, nat2, 0, nat2.data.length);
   }
   function caml_gc_set(_control){return 0;}
   function caml_js_get(o, f){return o[f];}
   function caml_unix_isatty(fileDescriptor){
    if(fs_node_supported()){
     var tty = require("tty");
     return tty.isatty(fileDescriptor) ? 1 : 0;
    }
    else
     return 0;
   }
   function caml_ml_set_buffered(chanid, v){
    caml_ml_channels[chanid].buffered = v;
    if(! v) caml_ml_flush(chanid);
    return 0;
   }
   function caml_gc_compaction(){return 0;}
   function caml_ephe_get_key(x, i){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.get_key");
    var weak = x[caml_ephe_key_offset + i];
    if(globalThis.WeakRef && weak instanceof globalThis.WeakRef)
     weak = weak.deref();
    return weak === undefined ? 0 : [0, weak];
   }
   function caml_unix_localtime(t){
    var
     d = new Date(t * 1000),
     d_num = d.getTime(),
     januaryfirst = new Date(d.getFullYear(), 0, 1).getTime(),
     doy = Math.floor((d_num - januaryfirst) / 86400000),
     jan = new Date(d.getFullYear(), 0, 1),
     jul = new Date(d.getFullYear(), 6, 1),
     stdTimezoneOffset =
       Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    return [0,
            d.getSeconds(),
            d.getMinutes(),
            d.getHours(),
            d.getDate(),
            d.getMonth(),
            d.getFullYear() - 1900,
            d.getDay(),
            doy,
            d.getTimezoneOffset() < stdTimezoneOffset | 0];
   }
   function caml_unix_mktime(tm){
    var
     d = new Date(tm[6] + 1900, tm[5], tm[4], tm[3], tm[2], tm[1]).getTime(),
     t = Math.floor(d / 1000),
     tm2 = caml_unix_localtime(t);
    return [0, t, tm2];
   }
   function caml_bigstring_blit_bytes_to_ba(str1, pos1, ba2, pos2, len){
    if(12 != ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs2 = ba2.offset(pos2);
    if(pos1 + len > caml_ml_bytes_length(str1)) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = caml_uint8_array_of_bytes(str1).slice(pos1, pos1 + len);
    ba2.data.set(slice, ofs2);
    return 0;
   }
   var caml_sys_fds = new Array(3);
   function caml_sys_close(fd){
    var file = caml_sys_fds[fd];
    if(file) file.close();
    delete caml_sys_fds[fd];
    return 0;
   }
   function caml_ml_close_channel(chanid){
    var chan = caml_ml_channels[chanid];
    chan.opened = false;
    caml_sys_close(chan.fd);
    return 0;
   }
   function caml_atomic_exchange(ref, v){
    var r = ref[1];
    ref[1] = v;
    return r;
   }
   function caml_sys_isatty(_chan){return 0;}
   function is_digit_zero(nat, ofs){
    if(nat.data[ofs] == 0) return 1;
    return 0;
   }
   function caml_unix_lstat(name){
    var root = resolve_fs_device(name);
    if(! root.device.lstat) caml_failwith("caml_unix_lstat: not implemented");
    return root.device.lstat(root.rest, true);
   }
   function caml_unix_lstat_64(name){
    var r = caml_unix_lstat(name);
    r[9] = caml_int64_of_int32(r[9]);
   }
   function caml_js_set(o, f, v){o[f] = v; return 0;}
   function caml_array_get(array, index){
    if(index < 0 || index >= array.length - 1) caml_array_bound_error();
    return array[index + 1];
   }
   function caml_continuation_use_noexc(cont){
    var stack = cont[1];
    cont[1] = 0;
    return stack;
   }
   function caml_unix_rmdir(name){
    var root = resolve_fs_device(name);
    if(! root.device.rmdir) caml_failwith("caml_unix_rmdir: not implemented");
    return root.device.rmdir(root.rest, true);
   }
   function caml_log2_float(x){return Math.log2(x);}
   function caml_gc_huge_fallback_count(unit){return 0;}
   function caml_runtime_events_resume(){return 0;}
   function caml_spacetime_only_works_for_native_code(){
    caml_failwith("Spacetime profiling only works for native code");
   }
   function caml_int64_sub(x, y){return x.sub(y);}
   function caml_seek_in(chanid, pos){
    var chan = caml_ml_channels[chanid];
    if(chan.refill != null) caml_raise_sys_error("Illegal seek");
    if
     (pos >= chan.offset - chan.buffer_max && pos <= chan.offset
      && chan.file.flags.binary)
     chan.buffer_curr = chan.buffer_max - (chan.offset - pos);
    else{chan.offset = pos; chan.buffer_curr = 0; chan.buffer_max = 0;}
    return 0;
   }
   function caml_ml_seek_in_64(chanid, pos){
    var pos = caml_int64_to_float(pos);
    return caml_seek_in(chanid, pos);
   }
   var caml_domain_id = 0;
   function caml_ml_mutex_unlock(t){t.locked = false; return 0;}
   var caml_domain_latest_idx = 1;
   function caml_domain_spawn(f, mutex){
    var id = caml_domain_latest_idx++, old = caml_domain_id;
    caml_domain_id = id;
    caml_callback(f, [0]);
    caml_domain_id = old;
    caml_ml_mutex_unlock(mutex);
    return id;
   }
   function caml_unix_mkdir(name, perm){
    var root = resolve_fs_device(name);
    if(! root.device.mkdir) caml_failwith("caml_unix_mkdir: not implemented");
    return root.device.mkdir(root.rest, perm, true);
   }
   function caml_int64_shift_left(x, s){return x.shift_left(s);}
   function caml_notequal(x, y){
    return + (caml_compare_val(x, y, false) != 0);
   }
   function caml_sys_const_int_size(){return 32;}
   function caml_js_wrap_callback(f){
    return function(){
     var len = arguments.length;
     if(len > 0){
      var args = new Array(len);
      for(var i = 0; i < len; i++) args[i] = arguments[i];
     }
     else
      args = [undefined];
     var res = caml_callback(f, args);
     return res instanceof Function ? caml_js_wrap_callback(res) : res;};
   }
   function caml_js_wrap_meth_callback(f){
    return function(){
     var len = arguments.length, args = new Array(len + 1);
     args[0] = this;
     for(var i = 0; i < len; i++) args[i + 1] = arguments[i];
     var res = caml_callback(f, args);
     return res instanceof Function ? caml_js_wrap_callback(res) : res;};
   }
   function caml_is_js(){return 1;}
   function caml_lazy_update_to_forward(o){
    caml_obj_update_tag(o, 244, 250);
    return 0;
   }
   function caml_ba_dim(ba, i){
    if(i < 0 || i >= ba.dims.length) caml_invalid_argument("Bigarray.dim");
    return ba.dims[i];
   }
   function caml_ba_dim_1(ba){return caml_ba_dim(ba, 0);}
   function caml_js_meth_call(o, f, args){
    return o[caml_jsstring_of_string(f)].apply(o, caml_js_from_array(args));
   }
   var caml_ephe_data_offset = 2;
   function caml_weak_create(n){
    if(n < 0) caml_invalid_argument("Weak.create");
    var x = [251, "caml_ephe_list_head"];
    x.length = caml_ephe_key_offset + n;
    return x;
   }
   function caml_ephe_create(n){var x = caml_weak_create(n); return x;}
   function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s);}
   function caml_trampoline(res){
    var c = 1;
    while(res && res.joo_tramp){
     res = res.joo_tramp.apply(null, res.joo_args);
     c++;
    }
    return res;
   }
   function caml_maybe_print_stats(unit){return 0;}
   function caml_bytes_unsafe_get(s, i){
    switch(s.t & 6){
      default: if(i >= s.c.length) return 0;
      case 0:
       return s.c.charCodeAt(i);
      case 4:
       return s.c[i];
    }
   }
   function caml_bytes_get64(s, i){
    if(i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = new Array(8);
    for(var j = 0; j < 8; j++) a[7 - j] = caml_bytes_unsafe_get(s, i + j);
    return caml_int64_of_bytes(a);
   }
   var caml_custom_event_index = 0;
   function caml_runtime_events_user_register
   (event_name, event_tag, event_type){
    caml_custom_event_index += 1;
    return [0, caml_custom_event_index, event_name, event_type, event_tag];
   }
   function caml_unix_has_symlink(unit){return fs_node_supported() ? 1 : 0;}
   function caml_ephe_set_key(x, i, v){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.set");
    if(v instanceof Object && globalThis.WeakRef){
     if(x[1].register) x[1].register(v, undefined, v);
     x[caml_ephe_key_offset + i] = new globalThis.WeakRef(v);
    }
    else
     x[caml_ephe_key_offset + i] = v;
    return 0;
   }
   function caml_ephe_unset_key(x, i){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.set");
    if
     (globalThis.WeakRef
      && x[caml_ephe_key_offset + i] instanceof globalThis.WeakRef
      && x[1].unregister){
     var old = x[caml_ephe_key_offset + i].deref();
     if(old !== undefined){
      var count = 0;
      for(var j = caml_ephe_key_offset; j < x.length; j++){
       var key = x[j];
       if(key instanceof globalThis.WeakRef){
        key = key.deref();
        if(key === old) count++;
       }
      }
      if(count == 1) x[1].unregister(old);
     }
    }
    x[caml_ephe_key_offset + i] = undefined;
    return 0;
   }
   function caml_weak_set(x, i, v){
    if(v == 0) caml_ephe_unset_key(x, i); else caml_ephe_set_key(x, i, v[1]);
    return 0;
   }
   function caml_sys_remove(name){
    var root = resolve_fs_device(name), ok = root.device.unlink(root.rest);
    if(ok == 0) caml_raise_no_such_file(caml_jsbytes_of_string(name));
    return 0;
   }
   function caml_string_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_string_get32(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 3) caml_string_bound_error();
    var
     b1 = caml_string_unsafe_get(s, i),
     b2 = caml_string_unsafe_get(s, i + 1),
     b3 = caml_string_unsafe_get(s, i + 2),
     b4 = caml_string_unsafe_get(s, i + 3);
    return b4 << 24 | b3 << 16 | b2 << 8 | b1;
   }
   function caml_bytes_get(s, i){
    if(i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_get(s, i);
   }
   function caml_hypot_float(x, y){return Math.hypot(x, y);}
   function caml_js_call(f, o, args){
    return f.apply(o, caml_js_from_array(args));
   }
   function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0;}
   function caml_unix_inet_addr_of_string(){return 0;}
   function caml_hash_mix_bytes_arr(h, s){
    var len = s.length, i, w;
    for(i = 0; i + 4 <= len; i += 4){
     w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
     h = caml_hash_mix_int(h, w);
    }
    w = 0;
    switch(len & 3){
      case 3:
       w = s[i + 2] << 16;
      case 2:
       w |= s[i + 1] << 8;
      case 1:
       w |= s[i]; h = caml_hash_mix_int(h, w);
    }
    h ^= len;
    return h;
   }
   function caml_hash_mix_jsbytes(h, s){
    var len = s.length, i, w;
    for(i = 0; i + 4 <= len; i += 4){
     w =
      s.charCodeAt(i) | s.charCodeAt(i + 1) << 8 | s.charCodeAt(i + 2) << 16
      | s.charCodeAt(i + 3) << 24;
     h = caml_hash_mix_int(h, w);
    }
    w = 0;
    switch(len & 3){
      case 3:
       w = s.charCodeAt(i + 2) << 16;
      case 2:
       w |= s.charCodeAt(i + 1) << 8;
      case 1:
       w |= s.charCodeAt(i); h = caml_hash_mix_int(h, w);
    }
    h ^= len;
    return h;
   }
   function caml_ml_bytes_content(s){
    switch(s.t & 6){
      default: caml_convert_string_to_bytes(s);
      case 0:
       return s.c;
      case 4:
       return s.c;
    }
   }
   function caml_hash_mix_bytes(h, v){
    var content = caml_ml_bytes_content(v);
    return typeof content === "string"
            ? caml_hash_mix_jsbytes(h, content)
            : caml_hash_mix_bytes_arr(h, content);
   }
   function caml_bytes_lessthan(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c < s2.c ? 1 : 0;
   }
   function caml_erfc_float(x){return 1 - caml_erf_float(x);}
   function caml_gr_fill_poly(ar){
    var s = caml_gr_state_get();
    s.context.beginPath();
    s.context.moveTo(ar[1][1], s.height - ar[1][2]);
    for(var i = 2; i < ar.length; i++)
     s.context.lineTo(ar[i][1], s.height - ar[i][2]);
    s.context.lineTo(ar[1][1], s.height - ar[1][2]);
    s.context.fill();
    return 0;
   }
   function caml_gc_quick_stat(){
    return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
   }
   function caml_ml_input_char(chanid){
    var chan = caml_ml_channels[chanid];
    if(chan.buffer_curr >= chan.buffer_max){
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
     caml_refill(chan);
    }
    if(chan.buffer_curr >= chan.buffer_max) caml_raise_end_of_file();
    var res = chan.buffer[chan.buffer_curr];
    chan.buffer_curr++;
    return res;
   }
   function caml_ml_input_int(chanid){
    var chan = caml_ml_channels[chanid], res = 0;
    for(var i = 0; i < 4; i++)
     res = (res << 8) + caml_ml_input_char(chanid) | 0;
    return res | 0;
   }
   function caml_gr_display_mode(){
    caml_failwith("caml_gr_display_mode not Implemented");
   }
   function caml_obj_reachable_words(o){return 0;}
   function nth_digit_nat(nat, ofs){return nat.data[ofs];}
   function caml_array_blit(a1, i1, a2, i2, len){
    if(i2 <= i1)
     for(var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];
    else
     for(var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];
    return 0;
   }
   function caml_float_of_string(s){
    var res;
    s = caml_jsbytes_of_string(s);
    res = + s;
    if(s.length > 0 && res === res) return res;
    s = s.replace(/_/g, "");
    res = + s;
    if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s)) return res;
    var m = /^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)(p([+-]?[0-9]+))?/i.exec(s);
    if(m){
     var
      m3 = m[3].replace(/0+$/, ""),
      mantissa = parseInt(m[1] + m[2] + m3, 16),
      exponent = (m[5] | 0) - 4 * m3.length;
     res = mantissa * Math.pow(2, exponent);
     return res;
    }
    if(/^\+?inf(inity)?$/i.test(s)) return Infinity;
    if(/^-inf(inity)?$/i.test(s)) return - Infinity;
    caml_failwith("float_of_string");
   }
   function caml_sys_getcwd(){
    return caml_string_of_jsbytes(caml_current_dir);
   }
   function caml_int64_add(x, y){return x.add(y);}
   function caml_int64_mul(x, y){return x.mul(y);}
   function caml_int64_ult(x, y){return x.ucompare(y) < 0;}
   function caml_parse_sign_and_base(s){
    var i = 0, len = caml_ml_string_length(s), base = 10, sign = 1;
    if(len > 0)
     switch(caml_string_unsafe_get(s, i)){
       case 45:
        i++; sign = - 1; break;
       case 43:
        i++; sign = 1; break;
     }
    if(i + 1 < len && caml_string_unsafe_get(s, i) == 48)
     switch(caml_string_unsafe_get(s, i + 1)){
       case 120:
       case 88:
        base = 16; i += 2; break;
       case 111:
       case 79:
        base = 8; i += 2; break;
       case 98:
       case 66:
        base = 2; i += 2; break;
       case 117:
       case 85:
        i += 2; break;
     }
    return [i, sign, base];
   }
   function caml_parse_digit(c){
    if(c >= 48 && c <= 57) return c - 48;
    if(c >= 65 && c <= 90) return c - 55;
    if(c >= 97 && c <= 122) return c - 87;
    return - 1;
   }
   function caml_int64_of_string(s){
    var
     r = caml_parse_sign_and_base(s),
     i = r[0],
     sign = r[1],
     base = r[2],
     base64 = caml_int64_of_int32(base),
     threshold =
       new MlInt64(0xffffff, 0xfffffff, 0xffff).udivmod(base64).quotient,
     c = caml_string_unsafe_get(s, i),
     d = caml_parse_digit(c);
    if(d < 0 || d >= base) caml_failwith("int_of_string");
    var res = caml_int64_of_int32(d);
    for(;;){
     i++;
     c = caml_string_unsafe_get(s, i);
     if(c == 95) continue;
     d = caml_parse_digit(c);
     if(d < 0 || d >= base) break;
     if(caml_int64_ult(threshold, res)) caml_failwith("int_of_string");
     d = caml_int64_of_int32(d);
     res = caml_int64_add(caml_int64_mul(base64, res), d);
     if(caml_int64_ult(res, d)) caml_failwith("int_of_string");
    }
    if(i != caml_ml_string_length(s)) caml_failwith("int_of_string");
    if(base == 10 && caml_int64_ult(new MlInt64(0, 0, 0x8000), res))
     caml_failwith("int_of_string");
    if(sign < 0) res = caml_int64_neg(res);
    return res;
   }
   function caml_ba_set_1(ba, i0, v){ba.set(ba.offset(i0), v); return 0;}
   function caml_int64_xor(x, y){return x.xor(y);}
   function caml_int64_or(x, y){return x.or(y);}
   function caml_lxm_next(v){
    function shift_l(x, k){return caml_int64_shift_left(x, k);}
    function shift_r(x, k){return caml_int64_shift_right_unsigned(x, k);}
    function or(a, b){return caml_int64_or(a, b);}
    function xor(a, b){return caml_int64_xor(a, b);}
    function add(a, b){return caml_int64_add(a, b);}
    function mul(a, b){return caml_int64_mul(a, b);}
    function rotl(x, k){return or(shift_l(x, k), shift_r(x, 64 - k));}
    function get(a, i){return caml_ba_get_1(a, i);}
    function set(a, i, x){return caml_ba_set_1(a, i, x);}
    var
     M = caml_int64_of_string(caml_new_string("0xd1342543de82ef95")),
     daba = caml_int64_of_string(caml_new_string("0xdaba0b6eb09322e3")),
     z,
     q0,
     q1,
     st = v,
     a = get(st, 0),
     s = get(st, 1),
     x0 = get(st, 2),
     x1 = get(st, 3);
    z = add(s, x0);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = xor(z, shift_r(z, 32));
    set(st, 1, add(mul(s, M), a));
    var q0 = x0, q1 = x1;
    q1 = xor(q1, q0);
    q0 = rotl(q0, 24);
    q0 = xor(xor(q0, q1), shift_l(q1, 16));
    q1 = rotl(q1, 37);
    set(st, 2, q0);
    set(st, 3, q1);
    return z;
   }
   function caml_sys_const_big_endian(){return 0;}
   function caml_list_to_js_array(l){
    var a = [];
    for(; l !== 0; l = l[2]) a.push(l[1]);
    return a;
   }
   var
    caml_output_val =
      function(){
        function Writer(){this.chunk = [];}
        Writer.prototype =
         {chunk_idx: 20,
          block_len: 0,
          obj_counter: 0,
          size_32: 0,
          size_64: 0,
          write:
          function(size, value){
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[this.chunk_idx++] = value >> i & 0xFF;
          },
          write_at:
          function(pos, size, value){
           var pos = pos;
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[pos++] = value >> i & 0xFF;
          },
          write_code:
          function(size, code, value){
           this.chunk[this.chunk_idx++] = code;
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[this.chunk_idx++] = value >> i & 0xFF;
          },
          write_shared:
          function(offset){
           if(offset < 1 << 8)
            this.write_code(8, 0x04, offset);
           else if(offset < 1 << 16)
            this.write_code(16, 0x05, offset);
           else
            this.write_code(32, 0x06, offset);
          },
          pos: function(){return this.chunk_idx;},
          finalize:
          function(){
           this.block_len = this.chunk_idx - 20;
           this.chunk_idx = 0;
           this.write(32, 0x8495A6BE);
           this.write(32, this.block_len);
           this.write(32, this.obj_counter);
           this.write(32, this.size_32);
           this.write(32, this.size_64);
           return this.chunk;
          }};
        return function(v, flags){
         flags = caml_list_to_js_array(flags);
         var
          no_sharing = flags.indexOf(0) !== - 1,
          closures = flags.indexOf(1) !== - 1;
         if(closures)
          console.warn
           ("in caml_output_val: flag Marshal.Closures is not supported.");
         var
          writer = new Writer(),
          stack = [],
          intern_obj_table = no_sharing ? null : new MlObjectTable();
         function memo(v){
          if(no_sharing) return false;
          var existing_offset = intern_obj_table.recall(v);
          if(existing_offset){
           writer.write_shared(existing_offset);
           return true;
          }
          else{intern_obj_table.store(v); return false;}
         }
         function extern_rec(v){
          if(v.caml_custom){
           if(memo(v)) return;
           var
            name = v.caml_custom,
            ops = caml_custom_ops[name],
            sz_32_64 = [0, 0];
           if(! ops.serialize)
            caml_invalid_argument("output_value: abstract value (Custom)");
           if(ops.fixed_length == undefined){
            writer.write(8, 0x18);
            for(var i = 0; i < name.length; i++)
             writer.write(8, name.charCodeAt(i));
            writer.write(8, 0);
            var header_pos = writer.pos();
            for(var i = 0; i < 12; i++) writer.write(8, 0);
            ops.serialize(writer, v, sz_32_64);
            writer.write_at(header_pos, 32, sz_32_64[0]);
            writer.write_at(header_pos + 4, 32, 0);
            writer.write_at(header_pos + 8, 32, sz_32_64[1]);
           }
           else{
            writer.write(8, 0x19);
            for(var i = 0; i < name.length; i++)
             writer.write(8, name.charCodeAt(i));
            writer.write(8, 0);
            var old_pos = writer.pos();
            ops.serialize(writer, v, sz_32_64);
            if(ops.fixed_length != writer.pos() - old_pos)
             caml_failwith
              ("output_value: incorrect fixed sizes specified by " + name);
           }
           writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
           writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3);
          }
          else if(v instanceof Array && v[0] === (v[0] | 0)){
           if(v[0] == 251)
            caml_failwith("output_value: abstract value (Abstract)");
           if(caml_is_continuation_tag(v[0]))
            caml_invalid_argument("output_value: continuation value");
           if(v.length > 1 && memo(v)) return;
           if(v[0] < 16 && v.length - 1 < 8)
            writer.write(8, 0x80 + v[0] + (v.length - 1 << 4));
           else
            writer.write_code(32, 0x08, v.length - 1 << 10 | v[0]);
           writer.size_32 += v.length;
           writer.size_64 += v.length;
           if(v.length > 1) stack.push(v, 1);
          }
          else if(caml_is_ml_bytes(v)){
           if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
            caml_failwith
             ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
           if(memo(v)) return;
           var len = caml_ml_bytes_length(v);
           if(len < 0x20)
            writer.write(8, 0x20 + len);
           else if(len < 0x100)
            writer.write_code(8, 0x09, len);
           else
            writer.write_code(32, 0x0A, len);
           for(var i = 0; i < len; i++)
            writer.write(8, caml_bytes_unsafe_get(v, i));
           writer.size_32 += 1 + ((len + 4) / 4 | 0);
           writer.size_64 += 1 + ((len + 8) / 8 | 0);
          }
          else if(caml_is_ml_string(v)){
           if(memo(v)) return;
           var len = caml_ml_string_length(v);
           if(len < 0x20)
            writer.write(8, 0x20 + len);
           else if(len < 0x100)
            writer.write_code(8, 0x09, len);
           else
            writer.write_code(32, 0x0A, len);
           for(var i = 0; i < len; i++)
            writer.write(8, caml_string_unsafe_get(v, i));
           writer.size_32 += 1 + ((len + 4) / 4 | 0);
           writer.size_64 += 1 + ((len + 8) / 8 | 0);
          }
          else if(v != (v | 0)){
           var type_of_v = typeof v;
           caml_failwith("output_value: abstract value (" + type_of_v + ")");
          }
          else if(v >= 0 && v < 0x40)
           writer.write(8, 0X40 + v);
          else if(v >= - (1 << 7) && v < 1 << 7)
           writer.write_code(8, 0x00, v);
          else if(v >= - (1 << 15) && v < 1 << 15)
           writer.write_code(16, 0x01, v);
          else
           writer.write_code(32, 0x02, v);
         }
         extern_rec(v);
         while(stack.length > 0){
          var i = stack.pop(), v = stack.pop();
          if(i + 1 < v.length) stack.push(v, i + 1);
          extern_rec(v[i]);
         }
         if(intern_obj_table)
          writer.obj_counter = intern_obj_table.objs.length;
         writer.finalize();
         return writer.chunk;};
       }
       ();
   function caml_string_of_array(a){
    return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a, 0, a.length));
   }
   function caml_output_value_to_string(v, flags){
    return caml_string_of_array(caml_output_val(v, flags));
   }
   function caml_raise_not_a_dir(name){
    caml_raise_sys_error(name + ": Not a directory");
   }
   function caml_sys_system_command(cmd){
    var cmd = caml_jsstring_of_string(cmd);
    if(typeof require != "undefined"){
     var child_process = require("child_process");
     if(child_process && child_process.execSync)
      try{child_process.execSync(cmd, {stdio: "inherit"}); return 0;}
      catch(e){return 1;}
    }
    else
     return 127;
   }
   function caml_js_error_of_exception(exn){
    if(exn.js_error) return exn.js_error;
    return null;
   }
   function caml_unix_getuid(unit){
    if(globalThis.process && globalThis.process.getuid)
     return globalThis.process.getuid();
    caml_raise_not_found();
   }
   function deserialize_nat(reader, sz){
    var len = reader.read32s(), nat = new MlNat(len);
    for(var i = 0; i < len; i++) nat.data[i] = reader.read32s();
    sz[0] = len * 4;
    return nat;
   }
   function initialize_nat(){
    caml_custom_ops["_nat"] =
     {deserialize: deserialize_nat,
      serialize: serialize_nat,
      hash: caml_hash_nat};
   }
   function caml_bytes_of_utf16_jsstring(s){
    var tag = 9;
    if(! jsoo_is_ascii(s)) tag = 8, s = caml_utf8_of_utf16(s);
    return new MlBytes(tag, s, s.length);
   }
   function caml_gr_open_subwindow(a, b, c, d){
    caml_failwith("caml_gr_open_subwindow not Implemented");
   }
   function UInt8ArrayReader(s, i){this.s = s; this.i = i;}
   UInt8ArrayReader.prototype =
    {read8u: function(){return this.s[this.i++];},
     read8s: function(){return this.s[this.i++] << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s[i] << 8 | s[i + 1];
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s[i] << 24 >> 16 | s[i + 1];
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (s[i] << 24 | s[i + 1] << 16 | s[i + 2] << 8 | s[i + 3]) >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return s[i] << 24 | s[i + 1] << 16 | s[i + 2] << 8 | s[i + 3];
     },
     readstr:
     function(len){
      var i = this.i;
      this.i = i + len;
      return caml_string_of_array(this.s.subarray(i, i + len));
     },
     readuint8array:
     function(len){
      var i = this.i;
      this.i = i + len;
      return this.s.subarray(i, i + len);
     }};
   function caml_marshal_data_size(s, ofs){
    var r = new UInt8ArrayReader(caml_uint8_array_of_bytes(s), ofs);
    function readvlq(overflow){
     var c = r.read8u(), n = c & 0x7F;
     while((c & 0x80) != 0){
      c = r.read8u();
      var n7 = n << 7;
      if(n != n7 >> 7) overflow[0] = true;
      n = n7 | c & 0x7F;
     }
     return n;
    }
    switch(r.read32u()){
      case 0x8495A6BE:
       var header_len = 20, data_len = r.read32u(); break;
      case 0x8495A6BD:
       var
        header_len = r.read8u() & 0x3F,
        overflow = [false],
        data_len = readvlq(overflow);
       if(overflow[0])
        caml_failwith
         ("Marshal.data_size: object too large to be read back on this platform");
       break;
      case 0x8495A6BF:
      default: caml_failwith("Marshal.data_size: bad object"); break;
    }
    return header_len - caml_marshal_header_size + data_len;
   }
   function MlStringReader(s, i){
    this.s = caml_jsbytes_of_string(s);
    this.i = i;
   }
   MlStringReader.prototype =
    {read8u: function(){return this.s.charCodeAt(this.i++);},
     read8s: function(){return this.s.charCodeAt(this.i++) << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1);
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1);
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (s.charCodeAt(i) << 24 | s.charCodeAt(i + 1) << 16
             | s.charCodeAt(i + 2) << 8
             | s.charCodeAt(i + 3))
             >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return s.charCodeAt(i) << 24 | s.charCodeAt(i + 1) << 16
             | s.charCodeAt(i + 2) << 8
             | s.charCodeAt(i + 3);
     },
     readstr:
     function(len){
      var i = this.i;
      this.i = i + len;
      return caml_string_of_jsbytes(this.s.substring(i, i + len));
     },
     readuint8array:
     function(len){
      var b = new Uint8Array(len), s = this.s, i = this.i;
      for(var j = 0; j < len; j++) b[j] = s.charCodeAt(i + j);
      this.i = i + len;
      return b;
     }};
   var
    zstd_decompress =
      function(){
        "use strict";
        var
         ab = ArrayBuffer,
         u8 = Uint8Array,
         u16 = Uint16Array,
         i16 = Int16Array,
         u32 = Uint32Array,
         i32 = Int32Array;
        function slc(v, s, e){
         if(u8.prototype.slice) return u8.prototype.slice.call(v, s, e);
         if(s == null || s < 0) s = 0;
         if(e == null || e > v.length) e = v.length;
         var n = new u8(e - s);
         n.set(v.subarray(s, e));
         return n;
        }
        function fill(v, n, s, e){
         if(u8.prototype.fill) return u8.prototype.fill.call(v, n, s, e);
         if(s == null || s < 0) s = 0;
         if(e == null || e > v.length) e = v.length;
         for(; s < e; ++s) v[s] = n;
         return v;
        }
        function cpw(v, t, s, e){
         if(u8.prototype.copyWithin)
          return u8.prototype.copyWithin.call(v, t, s, e);
         if(s == null || s < 0) s = 0;
         if(e == null || e > v.length) e = v.length;
         while(s < e) v[t++] = v[s++];
        }
        var
         ec =
           ["invalid zstd data",
            "window size too large (>2046MB)",
            "invalid block type",
            "FSE accuracy too high",
            "match distance too far back",
            "unexpected EOF"];
        function err(ind, msg, nt){
         var e = new Error(msg || ec[ind]);
         e.code = ind;
         if(! nt) throw e;
         return e;
        }
        function rb(d, b, n){
         var i = 0, o = 0;
         for(; i < n; ++i) o |= d[b++] << (i << 3);
         return o;
        }
        function b4(d, b){
         return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
        }
        function rzfh(dat, w){
         var n3 = dat[0] | dat[1] << 8 | dat[2] << 16;
         if(n3 == 0x2FB528 && dat[3] == 253){
          var
           flg = dat[4],
           ss = flg >> 5 & 1,
           cc = flg >> 2 & 1,
           df = flg & 3,
           fcf = flg >> 6;
          if(flg & 8) err(0);
          var bt = 6 - ss, db = df == 3 ? 4 : df, di = rb(dat, bt, db);
          bt += db;
          var
           fsb = fcf ? 1 << fcf : ss,
           fss = rb(dat, bt, fsb) + (fcf == 1 && 256),
           ws = fss;
          if(! ss){
           var wb = 1 << 10 + (dat[5] >> 3);
           ws = wb + (wb >> 3) * (dat[5] & 7);
          }
          if(ws > 2145386496) err(1);
          var buf = new u8((w == 1 ? fss || ws : w ? 0 : ws) + 12);
          buf[0] = 1, buf[4] = 4, buf[8] = 8;
          return {b: bt + fsb,
                  y: 0,
                  l: 0,
                  d: di,
                  w: w && w != 1 ? w : buf.subarray(12),
                  e: ws,
                  o: new i32(buf.buffer, 0, 3),
                  u: fss,
                  c: cc,
                  m: Math.min(131072, ws)};
         }
         else if((n3 >> 4 | dat[3] << 20) == 0x184D2A5) return b4(dat, 4) + 8;
         err(0);
        }
        function msb(val){
         var bits = 0;
         for(; 1 << bits <= val; ++bits) ;
         return bits - 1;
        }
        function rfse(dat, bt, mal){
         var tpos = (bt << 3) + 4, al = (dat[bt] & 15) + 5;
         if(al > mal) err(3);
         var
          sz = 1 << al,
          probs = sz,
          sym = - 1,
          re = - 1,
          i = - 1,
          ht = sz,
          buf = new ab(512 + (sz << 2)),
          freq = new i16(buf, 0, 256),
          dstate = new u16(buf, 0, 256),
          nstate = new u16(buf, 512, sz),
          bb1 = 512 + (sz << 1),
          syms = new u8(buf, bb1, sz),
          nbits = new u8(buf, bb1 + sz);
         while(sym < 255 && probs > 0){
          var
           bits = msb(probs + 1),
           cbt = tpos >> 3,
           msk = (1 << bits + 1) - 1,
           val =
             (dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16) >> (tpos & 7)
             & msk,
           msk1fb = (1 << bits) - 1,
           msv = msk - probs - 1,
           sval = val & msk1fb;
          if(sval < msv)
           tpos += bits, val = sval;
          else{tpos += bits + 1; if(val > msk1fb) val -= msv;}
          freq[++sym] = --val;
          if(val == - 1){probs += val; syms[--ht] = sym;} else probs -= val;
          if(! val)
           do{
            var rbt = tpos >> 3;
            re = (dat[rbt] | dat[rbt + 1] << 8) >> (tpos & 7) & 3;
            tpos += 2;
            sym += re;
           }
           while
            (re == 3);
         }
         if(sym > 255 || probs) err(0);
         var sympos = 0, sstep = (sz >> 1) + (sz >> 3) + 3, smask = sz - 1;
         for(var s = 0; s <= sym; ++s){
          var sf = freq[s];
          if(sf < 1){dstate[s] = - sf; continue;}
          for(i = 0; i < sf; ++i){
           syms[sympos] = s;
           do sympos = sympos + sstep & smask;while(sympos >= ht);
          }
         }
         if(sympos) err(0);
         for(i = 0; i < sz; ++i){
          var ns = dstate[syms[i]]++, nb = nbits[i] = al - msb(ns);
          nstate[i] = (ns << nb) - sz;
         }
         return [tpos + 7 >> 3, {b: al, s: syms, n: nbits, t: nstate}];
        }
        function rhu(dat, bt){
         var
          i = 0,
          wc = - 1,
          buf = new u8(292),
          hb = dat[bt],
          hw = buf.subarray(0, 256),
          rc = buf.subarray(256, 268),
          ri = new u16(buf.buffer, 268);
         if(hb < 128){
          var _a = rfse(dat, bt + 1, 6), ebt = _a[0], fdt = _a[1];
          bt += hb;
          var epos = ebt << 3, lb = dat[bt];
          if(! lb) err(0);
          var
           st1 = 0,
           st2 = 0,
           btr1 = fdt.b,
           btr2 = btr1,
           fpos = (++bt << 3) - 8 + msb(lb);
          for(;;){
           fpos -= btr1;
           if(fpos < epos) break;
           var cbt = fpos >> 3;
           st1 +=
            (dat[cbt] | dat[cbt + 1] << 8) >> (fpos & 7) & (1 << btr1) - 1;
           hw[++wc] = fdt.s[st1];
           fpos -= btr2;
           if(fpos < epos) break;
           cbt = fpos >> 3;
           st2 +=
            (dat[cbt] | dat[cbt + 1] << 8) >> (fpos & 7) & (1 << btr2) - 1;
           hw[++wc] = fdt.s[st2];
           btr1 = fdt.n[st1];
           st1 = fdt.t[st1];
           btr2 = fdt.n[st2];
           st2 = fdt.t[st2];
          }
          if(++wc > 255) err(0);
         }
         else{
          wc = hb - 127;
          for(; i < wc; i += 2){
           var byte = dat[++bt];
           hw[i] = byte >> 4;
           hw[i + 1] = byte & 15;
          }
          ++bt;
         }
         var wes = 0;
         for(i = 0; i < wc; ++i){
          var wt = hw[i];
          if(wt > 11) err(0);
          wes += wt && 1 << wt - 1;
         }
         var mb = msb(wes) + 1, ts = 1 << mb, rem = ts - wes;
         if(rem & rem - 1) err(0);
         hw[wc++] = msb(rem) + 1;
         for(i = 0; i < wc; ++i){
          var wt = hw[i];
          ++rc[hw[i] = wt && mb + 1 - wt];
         }
         var
          hbuf = new u8(ts << 1),
          syms = hbuf.subarray(0, ts),
          nb = hbuf.subarray(ts);
         ri[mb] = 0;
         for(i = mb; i > 0; --i){
          var pv = ri[i];
          fill(nb, i, pv, ri[i - 1] = pv + rc[i] * (1 << mb - i));
         }
         if(ri[0] != ts) err(0);
         for(i = 0; i < wc; ++i){
          var bits = hw[i];
          if(bits){
           var code = ri[bits];
           fill(syms, i, code, ri[bits] = code + (1 << mb - bits));
          }
         }
         return [bt, {n: nb, b: mb, s: syms}];
        }
        var
         dllt =
           rfse
             (new
               u8
               ([81,
                 16,
                 99,
                 140,
                 49,
                 198,
                 24,
                 99,
                 12,
                 33,
                 196,
                 24,
                 99,
                 102,
                 102,
                 134,
                 70,
                 146,
                 4]),
              0,
              6)
            [1],
         dmlt =
           rfse
             (new
               u8
               ([33,
                 20,
                 196,
                 24,
                 99,
                 140,
                 33,
                 132,
                 16,
                 66,
                 8,
                 33,
                 132,
                 16,
                 66,
                 8,
                 33,
                 68,
                 68,
                 68,
                 68,
                 68,
                 68,
                 68,
                 68,
                 36,
                 9]),
              0,
              6)
            [1],
         doct =
           rfse
             (new u8([32, 132, 16, 66, 102, 70, 68, 68, 68, 68, 36, 73, 2]),
              0,
              5)
            [1];
        function b2bl(b, s){
         var len = b.length, bl = new i32(len);
         for(var i = 0; i < len; ++i){bl[i] = s; s += 1 << b[i];}
         return bl;
        }
        var
         llb =
           new
            u8
            (new
              i32
              ([0,
                0,
                0,
                0,
                16843009,
                50528770,
                134678020,
                202050057,
                269422093]).buffer,
             0,
             36),
         llbl = b2bl(llb, 0),
         mlb =
           new
            u8
            (new
              i32
              ([0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                16843009,
                50528770,
                117769220,
                185207048,
                252579084,
                16]).buffer,
             0,
             53),
         mlbl = b2bl(mlb, 3);
        function dhu(dat, out, hu){
         var
          len = dat.length,
          ss = out.length,
          lb = dat[len - 1],
          msk = (1 << hu.b) - 1,
          eb = - hu.b;
         if(! lb) err(0);
         var
          st = 0,
          btr = hu.b,
          pos = (len << 3) - 8 + msb(lb) - btr,
          i = - 1;
         for(; pos > eb && i < ss;){
          var
           cbt = pos >> 3,
           val =
             (dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16) >> (pos & 7);
          st = (st << btr | val) & msk;
          out[++i] = hu.s[st];
          pos -= btr = hu.n[st];
         }
         if(pos != eb || i + 1 != ss) err(0);
        }
        function dhu4(dat, out, hu){
         var
          bt = 6,
          ss = out.length,
          sz1 = ss + 3 >> 2,
          sz2 = sz1 << 1,
          sz3 = sz1 + sz2;
         dhu
          (dat.subarray(bt, bt += dat[0] | dat[1] << 8),
           out.subarray(0, sz1),
           hu);
         dhu
          (dat.subarray(bt, bt += dat[2] | dat[3] << 8),
           out.subarray(sz1, sz2),
           hu);
         dhu
          (dat.subarray(bt, bt += dat[4] | dat[5] << 8),
           out.subarray(sz2, sz3),
           hu);
         dhu(dat.subarray(bt), out.subarray(sz3), hu);
        }
        function rzb(dat, st, out){
         var _a, bt = st.b, b0 = dat[bt], btype = b0 >> 1 & 3;
         st.l = b0 & 1;
         var
          sz = b0 >> 3 | dat[bt + 1] << 5 | dat[bt + 2] << 13,
          ebt = (bt += 3) + sz;
         if(btype == 1){
          if(bt >= dat.length) return;
          st.b = bt + 1;
          if(out){fill(out, dat[bt], st.y, st.y += sz); return out;}
          return fill(new u8(sz), dat[bt]);
         }
         if(ebt > dat.length) return;
         if(btype == 0){
          st.b = ebt;
          if(out){
           out.set(dat.subarray(bt, ebt), st.y);
           st.y += sz;
           return out;
          }
          return slc(dat, bt, ebt);
         }
         if(btype == 2){
          var
           b3 = dat[bt],
           lbt = b3 & 3,
           sf = b3 >> 2 & 3,
           lss = b3 >> 4,
           lcs = 0,
           s4 = 0;
          if(lbt < 2)
           if(sf & 1)
            lss |= dat[++bt] << 4 | (sf & 2 && dat[++bt] << 12);
           else
            lss = b3 >> 3;
          else{
           s4 = sf;
           if(sf < 2)
            lss |= (dat[++bt] & 63) << 4, lcs = dat[bt] >> 6 | dat[++bt] << 2;
           else if(sf == 2)
            lss |= dat[++bt] << 4 | (dat[++bt] & 3) << 12,
            lcs = dat[bt] >> 2 | dat[++bt] << 6;
           else
            lss |= dat[++bt] << 4 | (dat[++bt] & 63) << 12,
            lcs = dat[bt] >> 6 | dat[++bt] << 2 | dat[++bt] << 10;
          }
          ++bt;
          var
           buf = out ? out.subarray(st.y, st.y + st.m) : new u8(st.m),
           spl = buf.length - lss;
          if(lbt == 0)
           buf.set(dat.subarray(bt, bt += lss), spl);
          else if(lbt == 1)
           fill(buf, dat[bt++], spl);
          else{
           var hu = st.h;
           if(lbt == 2){
            var hud = rhu(dat, bt);
            lcs += bt - (bt = hud[0]);
            st.h = hu = hud[1];
           }
           else if(! hu) err(0);
           (s4 ? dhu4 : dhu)
            (dat.subarray(bt, bt += lcs), buf.subarray(spl), hu);
          }
          var ns = dat[bt++];
          if(ns){
           if(ns == 255)
            ns = (dat[bt++] | dat[bt++] << 8) + 0x7F00;
           else if(ns > 127) ns = ns - 128 << 8 | dat[bt++];
           var scm = dat[bt++];
           if(scm & 3) err(0);
           var dts = [dmlt, doct, dllt];
           for(var i = 2; i > - 1; --i){
            var md = scm >> (i << 1) + 2 & 3;
            if(md == 1){
             var rbuf = new u8([0, 0, dat[bt++]]);
             dts[i] =
              {s: rbuf.subarray(2, 3),
               n: rbuf.subarray(0, 1),
               t: new u16(rbuf.buffer, 0, 1),
               b: 0};
            }
            else if(md == 2)
             _a = rfse(dat, bt, 9 - (i & 1)), bt = _a[0], dts[i] = _a[1];
            else if(md == 3){if(! st.t) err(0); dts[i] = st.t[i];}
           }
           var
            _b = st.t = dts,
            mlt = _b[0],
            oct = _b[1],
            llt = _b[2],
            lb = dat[ebt - 1];
           if(! lb) err(0);
           var
            spos = (ebt << 3) - 8 + msb(lb) - llt.b,
            cbt = spos >> 3,
            oubt = 0,
            lst =
              (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << llt.b) - 1;
           cbt = (spos -= oct.b) >> 3;
           var
            ost =
              (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << oct.b) - 1;
           cbt = (spos -= mlt.b) >> 3;
           var
            mst =
              (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << mlt.b) - 1;
           for(++ns; --ns;){
            var
             llc = llt.s[lst],
             lbtr = llt.n[lst],
             mlc = mlt.s[mst],
             mbtr = mlt.n[mst],
             ofc = oct.s[ost],
             obtr = oct.n[ost];
            cbt = (spos -= ofc) >> 3;
            var
             ofp = 1 << ofc,
             off =
               ofp
               +
                ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16
                | dat[cbt + 3] << 24)
                >>> (spos & 7)
                & ofp - 1);
            cbt = (spos -= mlb[mlc]) >> 3;
            var
             ml =
               mlbl[mlc]
               +
                ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16)
                >> (spos & 7)
                & (1 << mlb[mlc]) - 1);
            cbt = (spos -= llb[llc]) >> 3;
            var
             ll =
               llbl[llc]
               +
                ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16)
                >> (spos & 7)
                & (1 << llb[llc]) - 1);
            cbt = (spos -= lbtr) >> 3;
            lst =
             llt.t[lst]
             +
              ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << lbtr) - 1);
            cbt = (spos -= mbtr) >> 3;
            mst =
             mlt.t[mst]
             +
              ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << mbtr) - 1);
            cbt = (spos -= obtr) >> 3;
            ost =
             oct.t[ost]
             +
              ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << obtr) - 1);
            if(off > 3){
             st.o[2] = st.o[1];
             st.o[1] = st.o[0];
             st.o[0] = off -= 3;
            }
            else{
             var idx = off - (ll != 0);
             if(idx){
              off = idx == 3 ? st.o[0] - 1 : st.o[idx];
              if(idx > 1) st.o[2] = st.o[1];
              st.o[1] = st.o[0];
              st.o[0] = off;
             }
             else
              off = st.o[0];
            }
            for(var i = 0; i < ll; ++i) buf[oubt + i] = buf[spl + i];
            oubt += ll, spl += ll;
            var stin = oubt - off;
            if(stin < 0){
             var len = - stin, bs = st.e + stin;
             if(len > ml) len = ml;
             for(var i = 0; i < len; ++i) buf[oubt + i] = st.w[bs + i];
             oubt += len, ml -= len, stin = 0;
            }
            for(var i = 0; i < ml; ++i) buf[oubt + i] = buf[stin + i];
            oubt += ml;
           }
           if(oubt != spl)
            while(spl < buf.length) buf[oubt++] = buf[spl++];
           else
            oubt = buf.length;
           if(out) st.y += oubt; else buf = slc(buf, 0, oubt);
          }
          else if(out){
           st.y += lss;
           if(spl) for(var i = 0; i < lss; ++i) buf[i] = buf[spl + i];
          }
          else if(spl) buf = slc(buf, spl);
          st.b = ebt;
          return buf;
         }
         err(2);
        }
        function cct(bufs, ol){
         if(bufs.length == 1) return bufs[0];
         var buf = new u8(ol);
         for(var i = 0, b = 0; i < bufs.length; ++i){
          var chk = bufs[i];
          buf.set(chk, b);
          b += chk.length;
         }
         return buf;
        }
        return function(dat, buf){
         var bt = 0, bufs = [], nb = + ! buf, ol = 0;
         for(; dat.length;){
          var st = rzfh(dat, nb || buf);
          if(typeof st == "object"){
           if(nb){
            buf = null;
            if(st.w.length == st.u){bufs.push(buf = st.w); ol += st.u;}
           }
           else{bufs.push(buf); st.e = 0;}
           for(; ! st.l;){
            var blk = rzb(dat, st, buf);
            if(! blk) err(5);
            if(buf)
             st.e = st.y;
            else{
             bufs.push(blk);
             ol += blk.length;
             cpw(st.w, 0, blk.length);
             st.w.set(blk, st.w.length - blk.length);
            }
           }
           bt = st.b + st.c * 4;
          }
          else
           bt = st;
          dat = dat.subarray(bt);
         }
         return cct(bufs, ol);};
       }
       ();
   function caml_float_of_bytes(a){
    return caml_int64_float_of_bits(caml_int64_of_bytes(a));
   }
   function caml_input_value_from_reader(reader, ofs){
    function readvlq(overflow){
     var c = reader.read8u(), n = c & 0x7F;
     while((c & 0x80) != 0){
      c = reader.read8u();
      var n7 = n << 7;
      if(n != n7 >> 7) overflow[0] = true;
      n = n7 | c & 0x7F;
     }
     return n;
    }
    var magic = reader.read32u();
    switch(magic){
      case 0x8495A6BE:
       var
        header_len = 20,
        compressed = 0,
        data_len = reader.read32u(),
        uncompressed_data_len = data_len,
        num_objects = reader.read32u(),
        _size_32 = reader.read32u(),
        _size_64 = reader.read32u();
       break;
      case 0x8495A6BD:
       var
        header_len = reader.read8u() & 0x3F,
        compressed = 1,
        overflow = [false],
        data_len = readvlq(overflow),
        uncompressed_data_len = readvlq(overflow),
        num_objects = readvlq(overflow),
        _size_32 = readvlq(overflow),
        _size_64 = readvlq(overflow);
       if(overflow[0])
        caml_failwith
         ("caml_input_value_from_reader: object too large to be read back on this platform");
       break;
      case 0x8495A6BF:
       caml_failwith
        ("caml_input_value_from_reader: object too large to be read back on a 32-bit platform");
       break;
      default:
       caml_failwith("caml_input_value_from_reader: bad object"); break;
    }
    var
     stack = [],
     intern_obj_table = num_objects > 0 ? [] : null,
     obj_counter = 0;
    function intern_rec(reader){
     var code = reader.read8u();
     if(code >= 0x40)
      if(code >= 0x80){
       var tag = code & 0xF, size = code >> 4 & 0x7, v = [tag];
       if(size == 0) return v;
       if(intern_obj_table) intern_obj_table[obj_counter++] = v;
       stack.push(v, size);
       return v;
      }
      else
       return code & 0x3F;
     else if(code >= 0x20){
      var len = code & 0x1F, v = reader.readstr(len);
      if(intern_obj_table) intern_obj_table[obj_counter++] = v;
      return v;
     }
     else
      switch(code){
        case 0x00:
         return reader.read8s();
        case 0x01:
         return reader.read16s();
        case 0x02:
         return reader.read32s();
        case 0x03:
         caml_failwith("input_value: integer too large"); break;
        case 0x04:
         var offset = reader.read8u();
         if(compressed == 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x05:
         var offset = reader.read16u();
         if(compressed == 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x06:
         var offset = reader.read32u();
         if(compressed == 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x08:
         var
          header = reader.read32u(),
          tag = header & 0xFF,
          size = header >> 10,
          v = [tag];
         if(size == 0) return v;
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         stack.push(v, size);
         return v;
        case 0x13:
         caml_failwith("input_value: data block too large"); break;
        case 0x09:
         var len = reader.read8u(), v = reader.readstr(len);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0A:
         var len = reader.read32u(), v = reader.readstr(len);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0C:
         var t = new Array(8);
         for(var i = 0; i < 8; i++) t[7 - i] = reader.read8u();
         var v = caml_float_of_bytes(t);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0B:
         var t = new Array(8);
         for(var i = 0; i < 8; i++) t[i] = reader.read8u();
         var v = caml_float_of_bytes(t);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0E:
         var len = reader.read8u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[7 - j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x0D:
         var len = reader.read8u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x07:
         var len = reader.read32u(), v = new Array(len + 1);
         v[0] = 254;
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         var t = new Array(8);
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[7 - j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x0F:
         var len = reader.read32u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x10:
        case 0x11:
         caml_failwith("input_value: code pointer"); break;
        case 0x12:
        case 0x18:
        case 0x19:
         var c, s = "";
         while((c = reader.read8u()) != 0) s += String.fromCharCode(c);
         var ops = caml_custom_ops[s], expected_size;
         if(! ops)
          caml_failwith("input_value: unknown custom block identifier");
         switch(code){
           case 0x12: break;
           case 0x19:
            if(! ops.fixed_length)
             caml_failwith("input_value: expected a fixed-size custom block");
            expected_size = ops.fixed_length;
            break;
           case 0x18:
            expected_size = reader.read32u();
            reader.read32s();
            reader.read32s();
            break;
         }
         var
          old_pos = reader.i,
          size = [0],
          v = ops.deserialize(reader, size);
         if(expected_size != undefined)
          if(expected_size != size[0])
           caml_failwith
            ("input_value: incorrect length of serialized custom block");
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        default: caml_failwith("input_value: ill-formed message");
      }
    }
    if(compressed)
     var
      data = reader.readuint8array(data_len),
      res = new Uint8Array(uncompressed_data_len),
      res = zstd_decompress(data, res),
      reader = new UInt8ArrayReader(res, 0);
    var res = intern_rec(reader);
    while(stack.length > 0){
     var size = stack.pop(), v = stack.pop(), d = v.length;
     if(d < size) stack.push(v, size);
     v[d] = intern_rec(reader);
    }
    if(typeof ofs != "number") ofs[0] = reader.i;
    return res;
   }
   function caml_string_of_bytes(s){
    s.t & 6 && caml_convert_string_to_bytes(s);
    return caml_string_of_jsbytes(s.c);
   }
   function caml_input_value_from_bytes(s, ofs){
    var
     reader =
       new
        MlStringReader
        (caml_string_of_bytes(s), typeof ofs == "number" ? ofs : ofs[0]);
    return caml_input_value_from_reader(reader, ofs);
   }
   function caml_input_value(chanid){
    var
     chan = caml_ml_channels[chanid],
     header = new Uint8Array(caml_marshal_header_size);
    function block(buffer, offset, n){
     var r = 0;
     while(r < n){
      if(chan.buffer_curr >= chan.buffer_max){
       chan.buffer_curr = 0;
       chan.buffer_max = 0;
       caml_refill(chan);
      }
      if(chan.buffer_curr >= chan.buffer_max) break;
      buffer[offset + r] = chan.buffer[chan.buffer_curr];
      chan.buffer_curr++;
      r++;
     }
     return r;
    }
    var r = block(header, 0, caml_marshal_header_size);
    if(r == 0)
     caml_raise_end_of_file();
    else if(r < caml_marshal_header_size)
     caml_failwith("input_value: truncated object");
    var
     len = caml_marshal_data_size(caml_bytes_of_array(header), 0),
     buf = new Uint8Array(len + caml_marshal_header_size);
    buf.set(header, 0);
    var r = block(buf, caml_marshal_header_size, len);
    if(r < len)
     caml_failwith("input_value: truncated object " + r + "  " + len);
    var
     offset = [0],
     res = caml_input_value_from_bytes(caml_bytes_of_array(buf), offset);
    chan.offset = chan.offset + offset[0];
    return res;
   }
   function caml_input_value_to_outside_heap(c){return caml_input_value(c);}
   function caml_atomic_cas(ref, o, n){
    if(ref[1] === o){ref[1] = n; return 1;}
    return 0;
   }
   function caml_copysign_float(x, y){
    if(y == 0) y = 1 / y;
    x = Math.abs(x);
    return y < 0 ? - x : x;
   }
   function caml_gr_set_text_size(size){
    var s = caml_gr_state_get();
    s.text_size = size;
    s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
    return 0;
   }
   function caml_atomic_load(ref){return ref[1];}
   function caml_MD5Final(ctx){
    var in_buf = ctx.len & 0x3f;
    ctx.b8[in_buf] = 0x80;
    in_buf++;
    if(in_buf > 56){
     for(var j = in_buf; j < 64; j++) ctx.b8[j] = 0;
     caml_MD5Transform(ctx.w, ctx.b32);
     for(var j = 0; j < 56; j++) ctx.b8[j] = 0;
    }
    else
     for(var j = in_buf; j < 56; j++) ctx.b8[j] = 0;
    ctx.b32[14] = ctx.len << 3;
    ctx.b32[15] = ctx.len >> 29 & 0x1FFFFFFF;
    caml_MD5Transform(ctx.w, ctx.b32);
    var t = new Uint8Array(16);
    for(var i = 0; i < 4; i++)
     for(var j = 0; j < 4; j++) t[i * 4 + j] = ctx.w[i] >> 8 * j & 0xFF;
    return t;
   }
   function caml_md5_bytes(s, ofs, len){
    var ctx = caml_MD5Init(), a = caml_uint8_array_of_bytes(s);
    caml_MD5Update(ctx, a.subarray(ofs, ofs + len), len);
    return caml_string_of_array(caml_MD5Final(ctx));
   }
   function caml_ba_set_generic(ba, i, v){
    ba.set(ba.offset(caml_js_from_array(i)), v);
    return 0;
   }
   function caml_ml_condition_wait(t, mutext){return 0;}
   function caml_string_lessequal(s1, s2){return s1 <= s2 ? 1 : 0;}
   function caml_string_greaterequal(s1, s2){return caml_string_lessequal(s2, s1);
   }
   function caml_nextafter_float(x, y){
    if(isNaN(x) || isNaN(y)) return NaN;
    if(x == y) return y;
    if(x == 0) return y < 0 ? - Math.pow(2, - 1074) : Math.pow(2, - 1074);
    var bits = caml_int64_bits_of_float(x), one = caml_int64_of_int32(1);
    if(x < y == x > 0)
     bits = caml_int64_add(bits, one);
    else
     bits = caml_int64_sub(bits, one);
    return caml_int64_float_of_bits(bits);
   }
   function caml_gr_size_y(){var s = caml_gr_state_get(); return s.height;}
   function caml_pos_in(chanid){
    var chan = caml_ml_channels[chanid];
    return chan.offset - (chan.buffer_max - chan.buffer_curr) | 0;
   }
   function caml_ml_pos_in(chanid){return caml_pos_in(chanid);}
   function caml_int64_and(x, y){return x.and(y);}
   function caml_sys_const_word_size(){return 32;}
   function caml_runtime_events_pause(){return 0;}
   function caml_unix_unlink(name){
    var root = resolve_fs_device(name);
    if(! root.device.unlink)
     caml_failwith("caml_unix_unlink: not implemented");
    return root.device.unlink(root.rest, true);
   }
   function caml_sys_open_for_node(fd, flags){
    if(flags.name)
     try{
      var fs = require("fs"), fd2 = fs.openSync(flags.name, "rs");
      return new MlNodeFd(fd2, flags);
     }
     catch(e){}
    return new MlNodeFd(fd, flags);
   }
   function MlFakeFd_out(fd, flags){
    MlFakeFile.call(this, caml_create_bytes(0));
    this.log = function(s){return 0;};
    if(fd == 1 && typeof console.log == "function")
     this.log = console.log;
    else if(fd == 2 && typeof console.error == "function")
     this.log = console.error;
    else if(typeof console.log == "function") this.log = console.log;
    this.flags = flags;
   }
   MlFakeFd_out.prototype.length = function(){return 0;};
   MlFakeFd_out.prototype.write =
    function(offset, buf, pos, len){
     if(this.log){
      if
       (len > 0 && pos >= 0 && pos + len <= buf.length
        && buf[pos + len - 1] == 10)
       len--;
      var src = caml_create_bytes(len);
      caml_blit_bytes(caml_bytes_of_array(buf), pos, src, 0, len);
      this.log(src.toUtf16());
      return 0;
     }
     caml_raise_sys_error(this.fd + ": file descriptor already closed");
    };
   MlFakeFd_out.prototype.read =
    function(offset, buf, pos, len){
     caml_raise_sys_error(this.fd + ": file descriptor is write only");
    };
   MlFakeFd_out.prototype.close = function(){this.log = undefined;};
   function caml_sys_open_internal(file, idx){
    if(idx == undefined) idx = caml_sys_fds.length;
    caml_sys_fds[idx] = file;
    return idx | 0;
   }
   function caml_sys_open(name, flags, _perms){
    var f = {};
    while(flags){
     switch(flags[1]){
       case 0:
        f.rdonly = 1; break;
       case 1:
        f.wronly = 1; break;
       case 2:
        f.append = 1; break;
       case 3:
        f.create = 1; break;
       case 4:
        f.truncate = 1; break;
       case 5:
        f.excl = 1; break;
       case 6:
        f.binary = 1; break;
       case 7:
        f.text = 1; break;
       case 8:
        f.nonblock = 1; break;
     }
     flags = flags[2];
    }
    if(f.rdonly && f.wronly)
     caml_raise_sys_error
      (caml_jsbytes_of_string(name)
       + " : flags Open_rdonly and Open_wronly are not compatible");
    if(f.text && f.binary)
     caml_raise_sys_error
      (caml_jsbytes_of_string(name)
       + " : flags Open_text and Open_binary are not compatible");
    var root = resolve_fs_device(name), file = root.device.open(root.rest, f);
    return caml_sys_open_internal(file, undefined);
   }
   (function(){
      function file(fd, flags){
       return fs_node_supported()
               ? caml_sys_open_for_node(fd, flags)
               : new MlFakeFd_out(fd, flags);
      }
      caml_sys_open_internal
       (file(0, {rdonly: 1, altname: "/dev/stdin", isCharacterDevice: true}),
        0);
      caml_sys_open_internal
       (file(1, {buffered: 2, wronly: 1, isCharacterDevice: true}), 1);
      caml_sys_open_internal
       (file(2, {buffered: 2, wronly: 1, isCharacterDevice: true}), 2);
     }
     ());
   function caml_string_get(s, i){
    if(i >>> 0 >= caml_ml_string_length(s)) caml_string_bound_error();
    return caml_string_unsafe_get(s, i);
   }
   var
    re_match =
      function(){
        var
         re_word_letters =
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
         opcodes =
           {CHAR: 0,
            CHARNORM: 1,
            STRING: 2,
            STRINGNORM: 3,
            CHARCLASS: 4,
            BOL: 5,
            EOL: 6,
            WORDBOUNDARY: 7,
            BEGGROUP: 8,
            ENDGROUP: 9,
            REFGROUP: 10,
            ACCEPT: 11,
            SIMPLEOPT: 12,
            SIMPLESTAR: 13,
            SIMPLEPLUS: 14,
            GOTO: 15,
            PUSHBACK: 16,
            SETMARK: 17,
            CHECKPROGRESS: 18};
        function is_word_letter(c){
         return re_word_letters[c >> 3] >> (c & 7) & 1;
        }
        function in_bitset(s, i){
         return caml_string_get(s, i >> 3) >> (i & 7) & 1;
        }
        function re_match_impl(re, s, pos, partial){
         var
          prog = caml_js_from_array(re[1]),
          cpool = caml_js_from_array(re[2]),
          normtable = caml_jsbytes_of_string(re[3]),
          numgroups = re[4] | 0,
          numregisters = re[5] | 0,
          startchars = re[6] | 0,
          s = caml_uint8_array_of_string(s),
          pc = 0,
          quit = false,
          stack = [],
          groups = new Array(numgroups),
          re_register = new Array(numregisters);
         for(var i = 0; i < groups.length; i++)
          groups[i] = {start: - 1, end: - 1};
         groups[0].start = pos;
         function backtrack(){
          while(stack.length){
           var item = stack.pop();
           if(item.undo)
            item.undo.obj[item.undo.prop] = item.undo.value;
           else if(item.pos){pc = item.pos.pc; pos = item.pos.txt; return;}
          }
          quit = true;
         }
         function push(item){stack.push(item);}
         function accept(){
          groups[0].end = pos;
          var result = new Array(1 + groups.length * 2);
          result[0] = 0;
          for(var i = 0; i < groups.length; i++){
           var g = groups[i];
           if(g.start < 0 || g.end < 0) g.start = g.end = - 1;
           result[2 * i + 1] = g.start;
           result[2 * i + 1 + 1] = g.end;
          }
          return result;
         }
         function prefix_match(){
          if(partial) return accept(); else backtrack();
         }
         while(! quit){
          var
           op = prog[pc] & 0xff,
           sarg = prog[pc] >> 8,
           uarg = sarg & 0xff,
           c = s[pos],
           group;
          pc++;
          switch(op){
            case opcodes.CHAR:
             if(pos === s.length){prefix_match(); break;}
             if(c === uarg) pos++; else backtrack();
             break;
            case opcodes.CHARNORM:
             if(pos === s.length){prefix_match(); break;}
             if(normtable.charCodeAt(c) === uarg) pos++; else backtrack();
             break;
            case opcodes.STRING:
             for
             (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0;
              i < arg.length;
              i++){
              if(pos === s.length){prefix_match(); break;}
              if(c === arg.charCodeAt(i))
               c = s[++pos];
              else{backtrack(); break;}
             }
             break;
            case opcodes.STRINGNORM:
             for
             (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0;
              i < arg.length;
              i++){
              if(pos === s.length){prefix_match(); break;}
              if(normtable.charCodeAt(c) === arg.charCodeAt(i))
               c = s[++pos];
              else{backtrack(); break;}
             }
             break;
            case opcodes.CHARCLASS:
             if(pos === s.length){prefix_match(); break;}
             if(in_bitset(cpool[uarg], c)) pos++; else backtrack();
             break;
            case opcodes.BOL:
             if(pos > 0 && s[pos - 1] != 10) backtrack(); break;
            case opcodes.EOL:
             if(pos < s.length && s[pos] != 10) backtrack(); break;
            case opcodes.WORDBOUNDARY:
             if(pos == 0){
              if(pos === s.length){prefix_match(); break;}
              if(is_word_letter(s[0])) break;
              backtrack();
             }
             else if(pos === s.length){
              if(is_word_letter(s[pos - 1])) break;
              backtrack();
             }
             else{
              if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos])) break;
              backtrack();
             }
             break;
            case opcodes.BEGGROUP:
             group = groups[uarg];
             push({undo: {obj: group, prop: "start", value: group.start}});
             group.start = pos;
             break;
            case opcodes.ENDGROUP:
             group = groups[uarg];
             push({undo: {obj: group, prop: "end", value: group.end}});
             group.end = pos;
             break;
            case opcodes.REFGROUP:
             group = groups[uarg];
             if(group.start < 0 || group.end < 0){backtrack(); break;}
             for(var i = group.start; i < group.end; i++){
              if(pos === s.length){prefix_match(); break;}
              if(s[i] != s[pos]){backtrack(); break;}
              pos++;
             }
             break;
            case opcodes.SIMPLEOPT:
             if(in_bitset(cpool[uarg], c)) pos++; break;
            case opcodes.SIMPLESTAR:
             while(in_bitset(cpool[uarg], c)) c = s[++pos]; break;
            case opcodes.SIMPLEPLUS:
             if(pos === s.length){prefix_match(); break;}
             if(in_bitset(cpool[uarg], c))
              do c = s[++pos];while(in_bitset(cpool[uarg], c));
             else
              backtrack();
             break;
            case opcodes.ACCEPT: return accept();
            case opcodes.GOTO:
             pc = pc + sarg; break;
            case opcodes.PUSHBACK:
             push({pos: {pc: pc + sarg, txt: pos}}); break;
            case opcodes.SETMARK:
             push
              ({undo: {obj: re_register, prop: uarg, value: re_register[uarg]}});
             re_register[uarg] = pos;
             break;
            case opcodes.CHECKPROGRESS:
             if(re_register[uarg] === pos) backtrack(); break;
            default: throw new Error("Invalid bytecode");
          }
         }
         return 0;
        }
        return re_match_impl;
       }
       ();
   function re_search_backward(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.search_backward");
    while(pos >= 0){
     var res = re_match(re, s, pos, 0);
     if(res) return res;
     pos--;
    }
    return [0];
   }
   function caml_js_from_string(s){return caml_jsstring_of_string(s);}
   function caml_ba_sub(ba, ofs, len){
    var changed_dim, mul = 1;
    if(ba.layout == 0){
     for(var i = 1; i < ba.dims.length; i++) mul = mul * ba.dims[i];
     changed_dim = 0;
    }
    else{
     for(var i = 0; i < ba.dims.length - 1; i++) mul = mul * ba.dims[i];
     changed_dim = ba.dims.length - 1;
     ofs = ofs - 1;
    }
    if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
     caml_invalid_argument("Bigarray.sub: bad sub-array");
    var new_dims = [];
    for(var i = 0; i < ba.dims.length; i++) new_dims[i] = ba.dims[i];
    new_dims[changed_dim] = len;
    mul *= caml_ba_get_size_per_element(ba.kind);
    var new_data = ba.data.subarray(ofs * mul, (ofs + len) * mul);
    return caml_ba_create_unsafe(ba.kind, ba.layout, new_dims, new_data);
   }
   function caml_gc_full_major(unit){
    if(typeof globalThis.gc == "function") globalThis.gc();
    return 0;
   }
   function caml_ml_mutex_try_lock(t){
    if(! t.locked){t.locked = true; return 1;}
    return 0;
   }
   function caml_bytes_set32(s, i, i32){
    if(i >>> 0 >= s.l - 3) caml_bytes_bound_error();
    var
     b4 = 0xFF & i32 >> 24,
     b3 = 0xFF & i32 >> 16,
     b2 = 0xFF & i32 >> 8,
     b1 = 0xFF & i32;
    caml_bytes_unsafe_set(s, i + 0, b1);
    caml_bytes_unsafe_set(s, i + 1, b2);
    caml_bytes_unsafe_set(s, i + 2, b3);
    caml_bytes_unsafe_set(s, i + 3, b4);
    return 0;
   }
   function caml_gr_sigio_signal(){return 0;}
   function caml_ba_uint8_set32(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 3 >= ba.data.length) caml_array_bound_error();
    ba.set(ofs + 0, v & 0xff);
    ba.set(ofs + 1, v >>> 8 & 0xff);
    ba.set(ofs + 2, v >>> 16 & 0xff);
    ba.set(ofs + 3, v >>> 24 & 0xff);
    return 0;
   }
   function caml_sys_const_ostype_unix(){return os_type == "Unix" ? 1 : 0;}
   function caml_unix_gmtime(t){
    var
     d = new Date(t * 1000),
     d_num = d.getTime(),
     januaryfirst = new Date(Date.UTC(d.getUTCFullYear(), 0, 1)).getTime(),
     doy = Math.floor((d_num - januaryfirst) / 86400000);
    return [0,
            d.getUTCSeconds(),
            d.getUTCMinutes(),
            d.getUTCHours(),
            d.getUTCDate(),
            d.getUTCMonth(),
            d.getUTCFullYear() - 1900,
            d.getUTCDay(),
            doy,
            false | 0];
   }
   function caml_signbit_float(x){if(x == 0) x = 1 / x; return x < 0 ? 1 : 0;}
   function caml_gr_current_x(){var s = caml_gr_state_get(); return s.x;}
   function caml_gr_set_line_width(w){
    var s = caml_gr_state_get();
    s.line_width = w;
    s.context.lineWidth = w;
    return 0;
   }
   function caml_gr_set_font(f){
    var s = caml_gr_state_get();
    s.font = f;
    s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
    return 0;
   }
   function caml_gr_set_color(color){
    var s = caml_gr_state_get();
    function convert(number){
     var str = "" + number.toString(16);
     while(str.length < 2) str = "0" + str;
     return str;
    }
    var r = color >> 16 & 0xff, g = color >> 8 & 0xff, b = color >> 0 & 0xff;
    s.color = color;
    var c_str = "#" + convert(r) + convert(g) + convert(b);
    s.context.fillStyle = c_str;
    s.context.strokeStyle = c_str;
    return 0;
   }
   function caml_gr_moveto(x, y){
    var s = caml_gr_state_get();
    s.x = x;
    s.y = y;
    return 0;
   }
   function caml_gr_resize_window(w, h){
    var s = caml_gr_state_get();
    s.width = w;
    s.height = h;
    s.canvas.width = w;
    s.canvas.height = h;
    return 0;
   }
   function caml_gr_state_init(){
    caml_gr_moveto(caml_gr_state.x, caml_gr_state.y);
    caml_gr_resize_window(caml_gr_state.width, caml_gr_state.height);
    caml_gr_set_line_width(caml_gr_state.line_width);
    caml_gr_set_text_size(caml_gr_state.text_size);
    caml_gr_set_font(caml_gr_state.font);
    caml_gr_set_color(caml_gr_state.color);
    caml_gr_set_window_title(caml_gr_state.title);
    caml_gr_state.context.textBaseline = "bottom";
   }
   function caml_ba_kind_of_typed_array(ta){
    var kind;
    if(ta instanceof Float32Array)
     kind = 0;
    else if(ta instanceof Float64Array)
     kind = 1;
    else if(ta instanceof Int8Array)
     kind = 2;
    else if(ta instanceof Uint8Array)
     kind = 3;
    else if(ta instanceof Uint8ClampedArray)
     kind = 3;
    else if(ta instanceof Int16Array)
     kind = 4;
    else if(ta instanceof Uint16Array)
     kind = 5;
    else if(ta instanceof Int32Array)
     kind = 6;
    else if(ta instanceof Uint32Array)
     kind = 6;
    else
     caml_invalid_argument("caml_ba_kind_of_typed_array: unsupported kind");
    return kind;
   }
   function caml_ba_from_typed_array(ta){
    var
     kind = caml_ba_kind_of_typed_array(ta),
     ta =
       ta instanceof Uint32Array
        ? new Int32Array(ta.buffer, ta.byteOffset, ta.length)
        : ta;
    return caml_ba_create_unsafe(kind, 0, [ta.length], ta);
   }
   function caml_ml_seek_out(chanid, pos){return caml_seek_out(chanid, pos);}
   function caml_js_typeof(o){return typeof o;}
   function caml_hash_mix_string(h, v){
    return caml_hash_mix_jsbytes(h, caml_jsbytes_of_string(v));
   }
   function caml_string_hash(h, v){
    var h = caml_hash_mix_string(h, v), h = caml_hash_mix_final(h);
    return h & 0x3FFFFFFF;
   }
   function caml_restore_raw_backtrace(exn, bt){return 0;}
   function caml_gr_lineto(x, y){
    var s = caml_gr_state_get();
    s.context.beginPath();
    s.context.moveTo(s.x, s.height - s.y);
    s.context.lineTo(x, s.height - y);
    s.context.stroke();
    s.x = x;
    s.y = y;
    return 0;
   }
   function caml_js_function_arity(f){return f.l >= 0 ? f.l : f.l = f.length;}
   function caml_js_wrap_meth_callback_unsafe(f){
    return function(){
     var len = caml_js_function_arity(f) - 1, args = new Array(len + 1);
     args[0] = this;
     for(var i = 0; i < len; i++) args[i + 1] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_ba_dim_3(ba){return caml_ba_dim(ba, 2);}
   function caml_is_special_exception(exn){
    switch(exn[2]){case - 8:case - 11:case - 12: return 1;default: return 0;
    }
   }
   function caml_format_exception(exn){
    var r = "";
    if(exn[0] == 0){
     r += exn[1][1];
     if
      (exn.length == 3 && exn[2][0] == 0 && caml_is_special_exception(exn[1]))
      var bucket = exn[2], start = 1;
     else
      var start = 2, bucket = exn;
     r += "(";
     for(var i = start; i < bucket.length; i++){
      if(i > start) r += ", ";
      var v = bucket[i];
      if(typeof v == "number")
       r += v.toString();
      else if(v instanceof MlBytes)
       r += '"' + v.toString() + '"';
      else if(typeof v == "string")
       r += '"' + v.toString() + '"';
      else
       r += "_";
     }
     r += ")";
    }
    else if(exn[0] == 248) r += exn[1];
    return r;
   }
   function caml_fatal_uncaught_exception(err){
    if(err instanceof Array && (err[0] == 0 || err[0] == 248)){
     var handler = caml_named_value("Printexc.handle_uncaught_exception");
     if(handler)
      caml_callback(handler, [err, false]);
     else{
      var
       msg = caml_format_exception(err),
       at_exit = caml_named_value("Pervasives.do_at_exit");
      if(at_exit) caml_callback(at_exit, [0]);
      console.error("Fatal error: exception " + msg + "\n");
      if(err.js_error) throw err.js_error;
     }
    }
    else
     throw err;
   }
   function caml_ephe_check_data(x){
    return x[caml_ephe_data_offset] === undefined ? 0 : 1;
   }
   function caml_bytes_get16(s, i){
    if(i >>> 0 >= s.l - 1) caml_bytes_bound_error();
    var
     b1 = caml_bytes_unsafe_get(s, i),
     b2 = caml_bytes_unsafe_get(s, i + 1);
    return b2 << 8 | b1;
   }
   function caml_obj_make_forward(b, v){b[0] = 250; b[1] = v; return 0;}
   function caml_js_from_bool(x){return ! ! x;}
   function caml_ml_set_channel_name(chanid, name){
    var chan = caml_ml_channels[chanid];
    chan.name = name;
    return 0;
   }
   function caml_exp2_float(x){return Math.pow(2, x);}
   function caml_gr_close_graph(){
    var s = caml_gr_state_get();
    s.canvas.width = 0;
    s.canvas.height = 0;
    return 0;
   }
   function caml_ml_domain_cpu_relax(unit){return 0;}
   function caml_create_string(len){caml_invalid_argument("String.create");}
   function caml_ml_input_block(chanid, ba, i, l){
    var
     chan = caml_ml_channels[chanid],
     n = l,
     avail = chan.buffer_max - chan.buffer_curr;
    if(l <= avail){
     ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + l), i);
     chan.buffer_curr += l;
    }
    else if(avail > 0){
     ba.set
      (chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + avail), i);
     chan.buffer_curr += avail;
     n = avail;
    }
    else{
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
     caml_refill(chan);
     var avail = chan.buffer_max - chan.buffer_curr;
     if(n > avail) n = avail;
     ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + n), i);
     chan.buffer_curr += n;
    }
    return n | 0;
   }
   function caml_md5_chan(chanid, toread){
    var ctx = caml_MD5Init(), buffer = new Uint8Array(4096);
    if(toread < 0)
     while(true){
      var read = caml_ml_input_block(chanid, buffer, 0, buffer.length);
      if(read == 0) break;
      caml_MD5Update(ctx, buffer.subarray(0, read), read);
     }
    else
     while(toread > 0){
      var
       read =
         caml_ml_input_block
          (chanid, buffer, 0, toread > buffer.length ? buffer.length : toread);
      if(read == 0) caml_raise_end_of_file();
      caml_MD5Update(ctx, buffer.subarray(0, read), read);
      toread -= read;
     }
    return caml_string_of_array(caml_MD5Final(ctx));
   }
   function caml_atanh_float(x){return Math.atanh(x);}
   function caml_ml_condition_signal(t){return 0;}
   function caml_unix_findnext(dir_handle){return caml_unix_readdir(dir_handle);
   }
   function caml_ml_output_bytes(chanid, buffer, offset, len){
    var chan = caml_ml_channels[chanid];
    if(! chan.opened)
     caml_raise_sys_error("Cannot output to a closed channel");
    var buffer = caml_uint8_array_of_bytes(buffer);
    buffer = buffer.subarray(offset, offset + len);
    if(chan.buffer_curr + buffer.length > chan.buffer.length){
     var b = new Uint8Array(chan.buffer_curr + buffer.length);
     b.set(chan.buffer);
     chan.buffer = b;
    }
    switch(chan.buffered){
      case 0:
       chan.buffer.set(buffer, chan.buffer_curr);
       chan.buffer_curr += buffer.length;
       caml_ml_flush(chanid);
       break;
      case 1:
       chan.buffer.set(buffer, chan.buffer_curr);
       chan.buffer_curr += buffer.length;
       if(chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);
       break;
      case 2:
       var id = buffer.lastIndexOf(10);
       if(id < 0){
        chan.buffer.set(buffer, chan.buffer_curr);
        chan.buffer_curr += buffer.length;
        if(chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);
       }
       else{
        chan.buffer.set(buffer.subarray(0, id + 1), chan.buffer_curr);
        chan.buffer_curr += id + 1;
        caml_ml_flush(chanid);
        chan.buffer.set(buffer.subarray(id + 1), chan.buffer_curr);
        chan.buffer_curr += buffer.length - id - 1;
       }
       break;
    }
    return 0;
   }
   function caml_ml_output(chanid, buffer, offset, len){
    return caml_ml_output_bytes
            (chanid, caml_bytes_of_string(buffer), offset, len);
   }
   function caml_ml_domain_id(unit){return caml_domain_id;}
   function caml_ephe_get_data(x){
    return x[caml_ephe_data_offset] === undefined
            ? 0
            : [0, x[caml_ephe_data_offset]];
   }
   function caml_xmlhttprequest_create(unit){
    if(typeof globalThis.XMLHttpRequest !== "undefined")
     try{return new globalThis.XMLHttpRequest;}catch(e){}
    if(typeof globalThis.activeXObject !== "undefined"){
     try{return new globalThis.activeXObject("Msxml2.XMLHTTP");}catch(e){}
     try{return new globalThis.activeXObject("Msxml3.XMLHTTP");}catch(e){}
     try{return new globalThis.activeXObject("Microsoft.XMLHTTP");}catch(e){}
    }
    caml_failwith("Cannot create a XMLHttpRequest");
   }
   function caml_trampoline_return(f, args){return {joo_tramp: f, joo_args: args};
   }
   function caml_ml_is_buffered(chanid){
    return caml_ml_channels[chanid].buffered ? 1 : 0;
   }
   function caml_array_append(a1, a2){
    var l1 = a1.length, l2 = a2.length, l = l1 + l2 - 1, a = new Array(l);
    a[0] = 0;
    var i = 1, j = 1;
    for(; i < l1; i++) a[i] = a1[i];
    for(; i < l; i++, j++) a[i] = a2[j];
    return a;
   }
   function caml_unix_gettimeofday(){return new Date().getTime() / 1000;}
   function caml_unix_time(){return Math.floor(caml_unix_gettimeofday());}
   function caml_ml_set_channel_refill(chanid, f){
    caml_ml_channels[chanid].refill = f;
    return 0;
   }
   function caml_runtime_events_create_cursor(target){return {};}
   function caml_fill_bytes(s, i, l, c){
    if(l > 0)
     if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
      if(c == 0){
       s.c = "";
       s.t = 2;
      }
      else{
       s.c = caml_str_repeat(l, String.fromCharCode(c));
       s.t = l == s.l ? 0 : 2;
      }
     else{
      if(s.t != 4) caml_convert_bytes_to_array(s);
      for(l += i; i < l; i++) s.c[i] = c;
     }
    return 0;
   }
   function caml_js_expr(s){
    console.error("caml_js_expr: fallback to runtime evaluation\n");
    return eval(caml_jsstring_of_string(s));
   }
   function caml_ml_runtime_warnings_enabled(_unit){return caml_runtime_warnings;
   }
   function caml_output_value_to_bytes(v, flags){
    return caml_bytes_of_array(caml_output_val(v, flags));
   }
   function caml_eventlog_resume(unit){return 0;}
   function caml_md5_string(s, ofs, len){
    return caml_md5_bytes(caml_bytes_of_string(s), ofs, len);
   }
   function caml_array_of_string(x){return caml_uint8_array_of_string(x);}
   function caml_string_equal(s1, s2){if(s1 === s2) return 1; return 0;}
   function caml_jsoo_flags_use_js_string(unit){return 1;}
   function caml_output_value_to_buffer(s, ofs, len, v, flags){
    var t = caml_output_val(v, flags);
    if(t.length > len) caml_failwith("Marshal.to_buffer: buffer overflow");
    caml_blit_bytes(t, 0, s, ofs, t.length);
    return 0;
   }
   function re_replacement_text(repl, groups, orig){
    var
     repl = caml_jsbytes_of_string(repl),
     len = repl.length,
     orig = caml_jsbytes_of_string(orig),
     res = "",
     n = 0,
     cur,
     start,
     end,
     c;
    while(n < len){
     cur = repl.charAt(n++);
     if(cur != "\\")
      res += cur;
     else{
      if(n == len) caml_failwith("Str.replace: illegal backslash sequence");
      cur = repl.charAt(n++);
      switch(cur){
        case "\\":
         res += cur; break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
         c = + cur;
         if(c * 2 >= groups.length - 1)
          caml_failwith("Str.replace: reference to unmatched group");
         start = caml_array_get(groups, c * 2);
         end = caml_array_get(groups, c * 2 + 1);
         if(start == - 1)
          caml_failwith("Str.replace: reference to unmatched group");
         res += orig.slice(start, end);
         break;
        default: res += "\\" + cur;
      }
     }
    }
    return caml_string_of_jsbytes(res);
   }
   function caml_pure_js_expr(s){
    console.error("caml_pure_js_expr: fallback to runtime evaluation\n");
    return eval(caml_jsstring_of_string(s));
   }
   function caml_blit_string(a, b, c, d, e){
    caml_blit_bytes(caml_bytes_of_string(a), b, c, d, e);
    return 0;
   }
   function blit_nat(nat1, ofs1, nat2, ofs2, len){
    for(var i = 0; i < len; i++) nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
    return 0;
   }
   function caml_bigstring_blit_ba_to_bytes(ba1, pos1, bytes2, pos2, len){
    if(12 != ba1.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs1 = ba1.offset(pos1);
    if(ofs1 + len > ba1.data.length) caml_array_bound_error();
    if(pos2 + len > caml_ml_bytes_length(bytes2)) caml_array_bound_error();
    var slice = ba1.data.slice(ofs1, ofs1 + len);
    caml_blit_bytes(caml_bytes_of_array(slice), 0, bytes2, pos2, len);
    return 0;
   }
   function caml_unix_stat(name){
    var root = resolve_fs_device(name);
    if(! root.device.stat) caml_failwith("caml_unix_stat: not implemented");
    return root.device.stat(root.rest, true);
   }
   function caml_register_named_value(nm, v){
    caml_named_values[caml_jsbytes_of_string(nm)] = v;
    return 0;
   }
   function jsoo_create_file_extern(name, content){
    if(globalThis.jsoo_create_file)
     globalThis.jsoo_create_file(name, content);
    else{
     if(! globalThis.caml_fs_tmp) globalThis.caml_fs_tmp = [];
     globalThis.caml_fs_tmp.push({name: name, content: content});
    }
    return 0;
   }
   function caml_unix_stat_64(name){
    var r = caml_unix_stat(name);
    r[9] = caml_int64_of_int32(r[9]);
   }
   function caml_to_js_string(s){return caml_jsstring_of_string(s);}
   function caml_ml_mutex_lock(t){
    if(t.locked)
     caml_failwith("Mutex.lock: mutex already locked. Cannot wait.");
    else
     t.locked = true;
    return 0;
   }
   function re_search_forward(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.search_forward");
    while(pos <= caml_ml_string_length(s)){
     var res = re_match(re, s, pos, 0);
     if(res) return res;
     pos++;
    }
    return [0];
   }
   function caml_make_vect(len, init){
    if(len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 0;
    for(var i = 1; i < len; i++) b[i] = init;
    return b;
   }
   function caml_ml_seek_in(chanid, pos){return caml_seek_in(chanid, pos);}
   function caml_sys_read_directory(name){
    var
     root = resolve_fs_device(name),
     a = root.device.readdir(root.rest),
     l = new Array(a.length + 1);
    l[0] = 0;
    for(var i = 0; i < a.length; i++) l[i + 1] = caml_string_of_jsbytes(a[i]);
    return l;
   }
   function caml_ml_output_char(chanid, c){
    var s = caml_string_of_jsbytes(String.fromCharCode(c));
    caml_ml_output(chanid, s, 0, 1);
    return 0;
   }
   function caml_sys_const_ostype_win32(){return os_type == "Win32" ? 1 : 0;}
   function caml_obj_is_block(x){return + (x instanceof Array);}
   function caml_obj_set_raw_field(o, i, v){return o[i + 1] = v;}
   function caml_js_var(x){
    var x = caml_jsstring_of_string(x);
    if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
     console.error
      ('caml_js_var: "' + x
       + '" is not a valid JavaScript variable. continuing ..');
    return eval(x);
   }
   function caml_trunc_float(x){return Math.trunc(x);}
   function caml_ephe_unset_data(x){
    if(globalThis.FinalizationRegistry && globalThis.WeakRef)
     if(x[1] instanceof globalThis.FinalizationRegistry)
      for(var j = caml_ephe_key_offset; j < x.length; j++){
       var key = x[j];
       if(key instanceof globalThis.WeakRef){
        key = key.deref();
        if(key) x[1].unregister(key);
       }
      }
    x[caml_ephe_data_offset] = undefined;
    return 0;
   }
   function caml_ephe_set_data(x, data){
    if(globalThis.FinalizationRegistry && globalThis.WeakRef)
     if(! (x[1] instanceof globalThis.FinalizationRegistry)){
      x[1] =
       new
        globalThis.FinalizationRegistry
        (function(){caml_ephe_unset_data(x);});
      for(var j = caml_ephe_key_offset; j < x.length; j++){
       var key = x[j];
       if(key instanceof globalThis.WeakRef){
        key = key.deref();
        if(key) x[1].register(key, undefined, key);
       }
      }
     }
    x[caml_ephe_data_offset] = data;
    return 0;
   }
   function caml_ephe_blit_data(src, dst){
    var n = src[caml_ephe_data_offset];
    if(n === undefined)
     caml_ephe_unset_data(dst);
    else
     caml_ephe_set_data(dst, n);
    return 0;
   }
   function caml_is_printable(c){return + (c > 31 && c < 127);}
   function caml_bytes_lessequal(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c <= s2.c ? 1 : 0;
   }
   function caml_array_of_bytes(x){return caml_uint8_array_of_bytes(x);}
   function caml_equal(x, y){return + (caml_compare_val(x, y, false) == 0);}
   function re_partial_match(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.partial_match");
    var res = re_match(re, s, pos, 1);
    return res ? res : [0];
   }
   function caml_sys_random_seed(){
    if(globalThis.crypto)
     if(globalThis.crypto.getRandomValues){
      var a = globalThis.crypto.getRandomValues(new Int32Array(4));
      return [0, a[0], a[1], a[2], a[3]];
     }
     else if(globalThis.crypto.randomBytes){
      var a = new Int32Array(globalThis.crypto.randomBytes(16).buffer);
      return [0, a[0], a[1], a[2], a[3]];
     }
    var now = new Date().getTime(), x = now ^ 0xffffffff * Math.random();
    return [0, x];
   }
   var all_finalizers = new globalThis.Set();
   function caml_final_register_called_without_value(cb, a){
    if(globalThis.FinalizationRegistry && a instanceof Object){
     var
      x =
        new
         globalThis.FinalizationRegistry
         (function(x){all_finalizers.delete(x); cb(0); return;});
     x.register(a, x);
     all_finalizers.add(x);
    }
    return 0;
   }
   function caml_ba_get_2(ba, i0, i1){return ba.get(ba.offset([i0, i1]));}
   function caml_ba_uint8_set16(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 1 >= ba.data.length) caml_array_bound_error();
    ba.set(ofs + 0, v & 0xff);
    ba.set(ofs + 1, v >>> 8 & 0xff);
    return 0;
   }
   function caml_lazy_reset_to_lazy(o){
    caml_obj_update_tag(o, 244, 246);
    return 0;
   }
   function caml_js_delete(o, f){delete o[f]; return 0;}
   function caml_int_of_string(s){
    var
     r = caml_parse_sign_and_base(s),
     i = r[0],
     sign = r[1],
     base = r[2],
     len = caml_ml_string_length(s),
     threshold = - 1 >>> 0,
     c = i < len ? caml_string_unsafe_get(s, i) : 0,
     d = caml_parse_digit(c);
    if(d < 0 || d >= base) caml_failwith("int_of_string");
    var res = d;
    for(i++; i < len; i++){
     c = caml_string_unsafe_get(s, i);
     if(c == 95) continue;
     d = caml_parse_digit(c);
     if(d < 0 || d >= base) break;
     res = base * res + d;
     if(res > threshold) caml_failwith("int_of_string");
    }
    if(i != len) caml_failwith("int_of_string");
    res = sign * res;
    if(base == 10 && (res | 0) != res) caml_failwith("int_of_string");
    return res | 0;
   }
   function caml_list_mount_point(){
    var prev = 0;
    for(var i = 0; i < jsoo_mount_point.length; i++){
     var old = prev;
     prev = [0, caml_string_of_jsbytes(jsoo_mount_point[i].path), old];
    }
    return prev;
   }
   var
    caml_marshal_constants =
      {PREFIX_SMALL_BLOCK: 0x80,
       PREFIX_SMALL_INT: 0x40,
       PREFIX_SMALL_STRING: 0x20,
       CODE_INT8: 0x00,
       CODE_INT16: 0x01,
       CODE_INT32: 0x02,
       CODE_INT64: 0x03,
       CODE_SHARED8: 0x04,
       CODE_SHARED16: 0x05,
       CODE_SHARED32: 0x06,
       CODE_BLOCK32: 0x08,
       CODE_BLOCK64: 0x13,
       CODE_STRING8: 0x09,
       CODE_STRING32: 0x0A,
       CODE_DOUBLE_BIG: 0x0B,
       CODE_DOUBLE_LITTLE: 0x0C,
       CODE_DOUBLE_ARRAY8_BIG: 0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE: 0x0E,
       CODE_DOUBLE_ARRAY32_BIG: 0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE: 0x07,
       CODE_CODEPOINTER: 0x10,
       CODE_INFIXPOINTER: 0x11,
       CODE_CUSTOM: 0x12,
       CODE_CUSTOM_LEN: 0x18,
       CODE_CUSTOM_FIXED: 0x19};
   function caml_obj_raw_field(o, i){return o[i + 1];}
   function caml_js_equals(x, y){return + (x == y);}
   function caml_obj_compare_and_swap(x, i, old, n){
    if(x[i + 1] == old){x[i + 1] = n; return 1;}
    return 0;
   }
   function bigstring_to_typed_array(bs){return bs.data;}
   function caml_gr_arc_aux(ctx, cx, cy, ry, rx, a1, a2){
    while(a1 > a2) a2 += 360;
    a1 /= 180;
    a2 /= 180;
    var
     rot = 0,
     xPos,
     yPos,
     xPos_prev,
     yPos_prev,
     space = 2,
     num = (a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
     delta = (a2 - a1) * Math.PI / num,
     i = a1 * Math.PI;
    for(var j = 0; j <= num; j++){
     xPos =
      cx - rx * Math.sin(i) * Math.sin(rot * Math.PI)
      + ry * Math.cos(i) * Math.cos(rot * Math.PI);
     xPos = xPos.toFixed(2);
     yPos =
      cy + ry * Math.cos(i) * Math.sin(rot * Math.PI)
      + rx * Math.sin(i) * Math.cos(rot * Math.PI);
     yPos = yPos.toFixed(2);
     if(j == 0)
      ctx.moveTo(xPos, yPos);
     else if(xPos_prev != xPos || yPos_prev != yPos) ctx.lineTo(xPos, yPos);
     xPos_prev = xPos;
     yPos_prev = yPos;
     i -= delta;
    }
    return 0;
   }
   function caml_gr_fill_arc(x, y, rx, ry, a1, a2){
    var s = caml_gr_state_get();
    s.context.beginPath();
    caml_gr_arc_aux(s.context, x, s.height - y, rx, ry, a1, a2);
    s.context.fill();
    return 0;
   }
   function caml_ba_slice(ba, vind){
    vind = caml_js_from_array(vind);
    var num_inds = vind.length, index = [], sub_dims = [], ofs;
    if(num_inds > ba.dims.length)
     caml_invalid_argument("Bigarray.slice: too many indices");
    if(ba.layout == 0){
     for(var i = 0; i < num_inds; i++) index[i] = vind[i];
     for(; i < ba.dims.length; i++) index[i] = 0;
     sub_dims = ba.dims.slice(num_inds);
    }
    else{
     for(var i = 0; i < num_inds; i++)
      index[ba.dims.length - num_inds + i] = vind[i];
     for(var i = 0; i < ba.dims.length - num_inds; i++) index[i] = 1;
     sub_dims = ba.dims.slice(0, ba.dims.length - num_inds);
    }
    ofs = ba.offset(index);
    var
     size = caml_ba_get_size(sub_dims),
     size_per_element = caml_ba_get_size_per_element(ba.kind),
     new_data =
       ba.data.subarray
        (ofs * size_per_element, (ofs + size) * size_per_element);
    return caml_ba_create_unsafe(ba.kind, ba.layout, sub_dims, new_data);
   }
   function caml_js_wrap_callback_unsafe(f){
    return function(){
     var len = caml_js_function_arity(f), args = new Array(len);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_ba_kind(ba){return ba.kind;}
   function caml_alloc_dummy_infix(){
    return function f(x){return caml_call_gen(f.fun, [x]);};
   }
   function caml_js_fun_call(f, a){
    switch(a.length){
      case 1:
       return f();
      case 2:
       return f(a[1]);
      case 3:
       return f(a[1], a[2]);
      case 4:
       return f(a[1], a[2], a[3]);
      case 5:
       return f(a[1], a[2], a[3], a[4]);
      case 6:
       return f(a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return f(a[1], a[2], a[3], a[4], a[5], a[6]);
      case 8:
       return f(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    }
    return f.apply(null, caml_js_from_array(a));
   }
   function caml_gc_major_slice(work){return 0;}
   function caml_js_pure_expr(f){return caml_callback(f, [0]);}
   function compare_digits_nat(nat1, ofs1, nat2, ofs2){
    if(nat1.data[ofs1] > nat2.data[ofs2]) return 1;
    if(nat1.data[ofs1] < nat2.data[ofs2]) return - 1;
    return 0;
   }
   function caml_ml_input(chanid, b, i, l){
    var ba = caml_uint8_array_of_bytes(b);
    return caml_ml_input_block(chanid, ba, i, l);
   }
   function caml_gr_wait_event(_evl){
    caml_failwith
     ("caml_gr_wait_event not Implemented: use Graphics_js instead");
   }
   function caml_gr_sigio_handler(){return 0;}
   function caml_hash_mix_bigstring(h, bs){
    return caml_hash_mix_bytes_arr(h, bs.data);
   }
   function caml_record_backtrace(b){
    caml_record_backtrace_flag = b;
    return 0;
   }
   function caml_unix_cleanup(){}
   function caml_sys_get_config(){
    return [0, caml_string_of_jsbytes(os_type), 32, 0];
   }
   function caml_sys_const_backend_type(){
    return [0, caml_string_of_jsbytes("js_of_ocaml")];
   }
   function caml_obj_is_shared(x){return 1;}
   function caml_ml_out_channels_list(){
    var l = 0;
    for(var c = 0; c < caml_ml_channels.length; c++)
     if
      (caml_ml_channels[c] && caml_ml_channels[c].opened
       && caml_ml_channels[c].out)
      l = [0, caml_ml_channels[c].fd, l];
    return l;
   }
   function caml_asinh_float(x){return Math.asinh(x);}
   function caml_pos_out(chanid){
    var chan = caml_ml_channels[chanid];
    return chan.offset + chan.buffer_curr;
   }
   function bigstring_of_array_buffer(ab){
    var ta = new Uint8Array(ab);
    return caml_ba_create_unsafe(12, 0, [ta.length], ta);
   }
   function caml_mod(x, y){if(y == 0) caml_raise_zero_divide(); return x % y;}
   function caml_ba_init(){return 0;}
   function caml_unix_filedescr_of_fd(x){return x;}
   function re_string_match(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.string_match");
    var res = re_match(re, s, pos, 0);
    return res ? res : [0];
   }
   function BigStringReader(bs, i){this.s = bs; this.i = i;}
   BigStringReader.prototype =
    {read8u: function(){return caml_ba_get_1(this.s, this.i++);},
     read8s: function(){return caml_ba_get_1(this.s, this.i++) << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return caml_ba_get_1(s, i) << 8 | caml_ba_get_1(s, i + 1);
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return caml_ba_get_1(s, i) << 24 >> 16 | caml_ba_get_1(s, i + 1);
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (caml_ba_get_1(s, i) << 24 | caml_ba_get_1(s, i + 1) << 16
             | caml_ba_get_1(s, i + 2) << 8
             | caml_ba_get_1(s, i + 3))
             >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return caml_ba_get_1(s, i) << 24 | caml_ba_get_1(s, i + 1) << 16
             | caml_ba_get_1(s, i + 2) << 8
             | caml_ba_get_1(s, i + 3);
     },
     readstr:
     function(len){
      var i = this.i, arr = new Array(len);
      for(var j = 0; j < len; j++) arr[j] = caml_ba_get_1(this.s, i + j);
      this.i = i + len;
      return caml_string_of_array(arr);
     },
     readuint8array:
     function(len){
      var i = this.i, offset = this.offset(i);
      this.i = i + len;
      return this.s.data.subarray(offset, offset + len);
     }};
   function caml_gr_dump_image(im){
    var data = [0];
    for(var i = 0; i < im.height; i++){
     data[i + 1] = [0];
     for(var j = 0; j < im.width; j++){
      var
       o = i * (im.width * 4) + j * 4,
       r = im.data[o + 0],
       g = im.data[o + 1],
       b = im.data[o + 2];
      data[i + 1][j + 1] = (r << 16) + (g << 8) + b;
     }
    }
    return data;
   }
   function caml_ba_get_generic(ba, i){
    var ofs = ba.offset(caml_js_from_array(i));
    return ba.get(ofs);
   }
   function caml_unix_startup(){}
   function caml_get_exception_backtrace(){return 0;}
   function caml_format_float(fmt, x){
    function toFixed(x, dp){
     if(Math.abs(x) < 1.0)
      return x.toFixed(dp);
     else{
      var e = parseInt(x.toString().split("+")[1]);
      if(e > 20){
       e -= 20;
       x /= Math.pow(10, e);
       x += new Array(e + 1).join("0");
       if(dp > 0) x = x + "." + new Array(dp + 1).join("0");
       return x;
      }
      else
       return x.toFixed(dp);
     }
    }
    var s, f = caml_parse_format(fmt), prec = f.prec < 0 ? 6 : f.prec;
    if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1; x = - x;}
    if(isNaN(x)){
     s = "nan";
     f.filler = " ";
    }
    else if(! isFinite(x)){
     s = "inf";
     f.filler = " ";
    }
    else
     switch(f.conv){
       case "e":
        var s = x.toExponential(prec), i = s.length;
        if(s.charAt(i - 3) == "e")
         s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
        break;
       case "f":
        s = toFixed(x, prec); break;
       case "g":
        prec = prec ? prec : 1;
        s = x.toExponential(prec - 1);
        var j = s.indexOf("e"), exp = + s.slice(j + 1);
        if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec){
         var i = j - 1;
         while(s.charAt(i) == "0") i--;
         if(s.charAt(i) == ".") i--;
         s = s.slice(0, i + 1) + s.slice(j);
         i = s.length;
         if(s.charAt(i - 3) == "e")
          s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
         break;
        }
        else{
         var p = prec;
         if(exp < 0){
          p -= exp + 1;
          s = x.toFixed(p);
         }
         else
          while(s = x.toFixed(p), s.length > prec + 1) p--;
         if(p){
          var i = s.length - 1;
          while(s.charAt(i) == "0") i--;
          if(s.charAt(i) == ".") i--;
          s = s.slice(0, i + 1);
         }
        }
        break;
     }
    return caml_finish_formatting(f, s);
   }
   function caml_mount_autoload(name, f){
    var
     path = caml_make_path(name),
     name = caml_trailing_slash(path.join("/"));
    jsoo_mount_point.push({path: name, device: new MlFakeDevice(name, f)});
    return 0;
   }
   function caml_string_lessthan(s1, s2){return s1 < s2 ? 1 : 0;}
   function caml_string_greaterthan(s1, s2){return caml_string_lessthan(s2, s1);
   }
   function caml_div(x, y){
    if(y == 0) caml_raise_zero_divide();
    return x / y | 0;
   }
   function caml_obj_dup(x){
    var l = x.length, a = new Array(l);
    for(var i = 0; i < l; i++) a[i] = x[i];
    return a;
   }
   function caml_ephe_get_data_copy(x){
    return x[caml_ephe_data_offset] === undefined
            ? 0
            : [0, caml_obj_dup(x[caml_ephe_data_offset])];
   }
   function caml_memprof_start(rate, stack_size, tracker){return 0;}
   function caml_sys_get_argv(a){return [0, caml_argv[1], caml_argv];}
   function caml_ml_domain_set_name(_name){return 0;}
   function caml_js_to_bool(x){return + x;}
   function caml_gr_create_image(x, y){
    var s = caml_gr_state_get();
    return s.context.createImageData(x, y);
   }
   function caml_ephe_get_key_copy(x, i){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.get_copy");
    var y = caml_ephe_get_key(x, i);
    if(y === 0) return y;
    var z = y[1];
    if(z instanceof Array) return [0, caml_obj_dup(z)];
    return y;
   }
   function caml_lessthan(x, y){return + (caml_compare_val(x, y, false) < 0);}
   function caml_raw_backtrace_next_slot(){return 0;}
   function caml_build_symbols(toc){
    var symb;
    while(toc)
     if(caml_jsstring_of_string(toc[1][1]) == "SYJS"){symb = toc[1][2]; break;}
     else
      toc = toc[2];
    var r = {};
    if(symb)
     for(var i = 1; i < symb.length; i++)
      r[caml_jsstring_of_string(symb[i][1])] = symb[i][2];
    return r;
   }
   function caml_register_global(n, v, name_opt){
    if(name_opt){
     var name = name_opt;
     if(globalThis.toplevelReloc)
      n = caml_callback(globalThis.toplevelReloc, [name]);
     else if(caml_global_data.toc){
      if(! caml_global_data.symbols)
       caml_global_data.symbols = caml_build_symbols(caml_global_data.toc);
      var nid = caml_global_data.symbols[name];
      if(nid >= 0)
       n = nid;
      else
       caml_failwith("caml_register_global: cannot locate " + name);
     }
    }
    caml_global_data[n + 1] = v;
    if(name_opt) caml_global_data[name_opt] = v;
   }
   function mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3, len3){
    var carry = 0;
    for(var i = 0; i < len3; i++)
     carry +=
      mult_digit_nat
       (nat1, ofs1 + i, len1 - i, nat2, ofs2, len2, nat3, ofs3 + i);
    return carry;
   }
   function square_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    var carry = 0;
    carry += add_nat(nat1, ofs1, len1, nat1, ofs1, len1, 0);
    carry += mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat2, ofs2, len2);
    return carry;
   }
   function caml_js_from_float(x){return x;}
   function caml_floatarray_create(len){
    if(len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 254;
    for(var i = 1; i < len; i++) b[i] = 0;
    return b;
   }
   function caml_gc_stat(){
    return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
   }
   function caml_get_major_credit(n){return 0;}
   function caml_sys_modify_argv(arg){caml_argv = arg; return 0;}
   var caml_method_cache = [];
   function caml_get_public_method(obj, tag, cacheid){
    var meths = obj[1], ofs = caml_method_cache[cacheid];
    if(ofs === undefined)
     for(var i = caml_method_cache.length; i < cacheid; i++)
      caml_method_cache[i] = 0;
    else if(meths[ofs] === tag) return meths[ofs - 1];
    var li = 3, hi = meths[1] * 2 + 1, mi;
    while(li < hi){
     mi = li + hi >> 1 | 1;
     if(tag < meths[mi + 1]) hi = mi - 2; else li = mi;
    }
    caml_method_cache[cacheid] = li + 1;
    return tag == meths[li + 1] ? meths[li] : 0;
   }
   function caml_js_get_console(){
    var
     c = console,
     m =
       ["log",
        "debug",
        "info",
        "warn",
        "error",
        "assert",
        "dir",
        "dirxml",
        "trace",
        "group",
        "groupCollapsed",
        "groupEnd",
        "time",
        "timeEnd"];
    function f(){}
    for(var i = 0; i < m.length; i++) if(! c[m[i]]) c[m[i]] = f;
    return c;
   }
   function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name);}
   function caml_ml_open_descriptor_in(fd){
    var file = caml_sys_fds[fd];
    if(file.flags.wronly) caml_raise_sys_error("fd " + fd + " is writeonly");
    var
     refill = null,
     channel =
       {file: file,
        offset: file.flags.append ? file.length() : 0,
        fd: fd,
        opened: true,
        out: false,
        buffer_curr: 0,
        buffer_max: 0,
        buffer: new Uint8Array(65536),
        refill: refill};
    caml_ml_channels[channel.fd] = channel;
    return channel.fd;
   }
   function bigstring_of_typed_array(ba){
    var
     ta =
       new
        Uint8Array
        (ba.buffer, ba.byteOffset, ba.length * ba.BYTES_PER_ELEMENT);
    return caml_ba_create_unsafe(12, 0, [ta.length], ta);
   }
   function caml_round_float(x){
    if(x >= 0){
     var y = Math.floor(x);
     return x - y >= 0.5 ? y + 1 : y;
    }
    else{var y = Math.ceil(x); return y - x >= 0.5 ? y - 1 : y;}
   }
   function caml_ojs_new_arr(c, a){
    switch(a.length){
      case 0:
       return new c;
      case 1:
       return new c(a[0]);
      case 2:
       return new c(a[0], a[1]);
      case 3:
       return new c(a[0], a[1], a[2]);
      case 4:
       return new c(a[0], a[1], a[2], a[3]);
      case 5:
       return new c(a[0], a[1], a[2], a[3], a[4]);
      case 6:
       return new c(a[0], a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return new c(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);
    }
    function F(){return c.apply(this, a);}
    F.prototype = c.prototype;
    return new F;
   }
   function complement_nat(nat, ofs, len){
    for(var i = 0; i < len; i++)
     nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0);
   }
   var caml_domain_dls = [0];
   function caml_domain_dls_set(a){caml_domain_dls = a;}
   function caml_obj_tag(x){
    if(x instanceof Array && x[0] == x[0] >>> 0)
     return x[0];
    else if(caml_is_ml_bytes(x))
     return 252;
    else if(caml_is_ml_string(x))
     return 252;
    else if(x instanceof Function || typeof x == "function")
     return 247;
    else if(x && x.caml_custom) return 255; else return 1000;
   }
   function caml_lazy_read_result(o){
    return caml_obj_tag(o) == 250 ? o[1] : o;
   }
   var caml_js_regexps = {amp: /&/g, lt: /</g, quot: /\"/g, all: /[&<\"]/};
   function caml_js_html_escape(s){
    if(! caml_js_regexps.all.test(s)) return s;
    return s.replace(caml_js_regexps.amp, "&amp;").replace
             (caml_js_regexps.lt, "&lt;").replace
            (caml_js_regexps.quot, "&quot;");
   }
   function caml_ba_dim_2(ba){return caml_ba_dim(ba, 1);}
   function caml_js_wrap_meth_callback_arguments(f){
    return function(){
     var len = arguments.length, args = new Array(len);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, [this, args]);};
   }
   function caml_sinh_float(x){return Math.sinh(x);}
   function caml_ldexp_float(x, exp){
    exp |= 0;
    if(exp > 1023){
     exp -= 1023;
     x *= Math.pow(2, 1023);
     if(exp > 1023){exp -= 1023; x *= Math.pow(2, 1023);}
    }
    if(exp < - 1023){exp += 1023; x *= Math.pow(2, - 1023);}
    x *= Math.pow(2, exp);
    return x;
   }
   function caml_gr_state_set(ctx){
    caml_gr_state = ctx;
    caml_gr_state_init();
    return 0;
   }
   function caml_js_wrap_callback_strict(arity, f){
    return function(){
     var
      n = arguments.length,
      args = new Array(arity),
      len = Math.min(arguments.length, arity);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_gc_minor_words(unit){return 0;}
   function caml_get_current_callstack(){return [0];}
   function land_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] &= nat2.data[ofs2]; return 0;
   }
   function caml_int64_mod(x, y){return x.mod(y);}
   function caml_obj_set_tag(x, tag){x[0] = tag; return 0;}
   function caml_int32_bswap(x){
    return (x & 0x000000FF) << 24 | (x & 0x0000FF00) << 8
           | (x & 0x00FF0000) >>> 8
           | (x & 0xFF000000) >>> 24;
   }
   function caml_ba_set_3(ba, i0, i1, i2, v){
    ba.set(ba.offset([i0, i1, i2]), v);
    return 0;
   }
   function caml_js_instanceof(o, c){return o instanceof c ? 1 : 0;}
   function caml_get_major_bucket(n){return 0;}
   function nth_digit_nat_native(nat, ofs){return nat.data[ofs];}
   function set_digit_nat_native(nat, ofs, digit){nat.data[ofs] = digit; return 0;
   }
   function caml_string_set64(s, i, i64){caml_failwith("caml_string_set64");}
   function caml_gr_state_create(canvas, w, h){
    var context = canvas.getContext("2d");
    return {context: context,
            canvas: canvas,
            x: 0,
            y: 0,
            width: w,
            height: h,
            line_width: 1,
            font: caml_string_of_jsbytes("fixed"),
            text_size: 26,
            color: 0x000000,
            title: caml_string_of_jsbytes("")};
   }
   function caml_gr_draw_arc(x, y, rx, ry, a1, a2){
    var s = caml_gr_state_get();
    s.context.beginPath();
    caml_gr_arc_aux(s.context, x, s.height - y, rx, ry, a1, a2);
    s.context.stroke();
    return 0;
   }
   function caml_ba_map_file(vfd, kind, layout, shared, dims, pos){caml_failwith("caml_ba_map_file not implemented");
   }
   function caml_ba_map_file_bytecode(argv, argn){
    return caml_ba_map_file
            (argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);
   }
   function caml_ba_create_from(data1, data2, jstyp, kind, layout, dims){
    if(data2 || caml_ba_get_size_per_element(kind) == 2)
     caml_invalid_argument
      ("caml_ba_create_from: use return caml_ba_create_unsafe");
    return caml_ba_create_unsafe(kind, layout, dims, data1);
   }
   function caml_tanh_float(x){return Math.tanh(x);}
   function caml_runtime_events_start(){return 0;}
   function caml_gr_draw_str(str){
    var s = caml_gr_state_get(), m = s.context.measureText(str), dx = m.width;
    s.context.fillText(str, s.x, s.height - s.y);
    s.x += dx | 0;
    return 0;
   }
   function caml_gr_draw_string(str){
    caml_gr_draw_str(caml_jsstring_of_string(str));
    return 0;
   }
   function caml_gr_draw_char(c){
    caml_gr_draw_str(String.fromCharCode(c));
    return 0;
   }
   function caml_unmount(name){
    var
     path = caml_make_path(name),
     name = caml_trailing_slash(path.join("/")),
     idx = - 1;
    for(var i = 0; i < jsoo_mount_point.length; i++)
     if(jsoo_mount_point[i].path == name) idx = i;
    if(idx > - 1) jsoo_mount_point.splice(idx, 1);
    return 0;
   }
   function caml_bigstring_blit_ba_to_ba(ba1, pos1, ba2, pos2, len){
    if(12 != ba1.kind)
     caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
    if(12 != ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs1 = ba1.offset(pos1), ofs2 = ba2.offset(pos2);
    if(ofs1 + len > ba1.data.length) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = ba1.data.subarray(ofs1, ofs1 + len);
    ba2.data.set(slice, pos2);
    return 0;
   }
   function caml_input_value_from_string(s, ofs){
    var reader = new MlStringReader(s, typeof ofs == "number" ? ofs : ofs[0]);
    return caml_input_value_from_reader(reader, ofs);
   }
   function caml_ml_pos_in_64(chanid){
    return caml_int64_of_float(caml_pos_in(chanid));
   }
   function caml_gr_draw_image(im, x, y){
    var s = caml_gr_state_get();
    if(! im.image){
     var canvas = document.createElement("canvas");
     canvas.width = s.width;
     canvas.height = s.height;
     canvas.getContext("2d").putImageData(im, 0, 0);
     var image = new globalThis.Image();
     image.onload =
      function(){
       s.context.drawImage(image, x, s.height - im.height - y);
       im.image = image;
      };
     image.src = canvas.toDataURL("image/png");
    }
    else
     s.context.drawImage(im.image, x, s.height - im.height - y);
    return 0;
   }
   function caml_register_channel_for_spacetime(_channel){return 0;}
   function caml_string_set(s, i, c){caml_failwith("caml_string_set");}
   function caml_sys_rmdir(name){
    var root = resolve_fs_device(name);
    root.device.rmdir(root.rest);
    return 0;
   }
   function caml_unix_symlink(to_dir, src, dst){
    var src_root = resolve_fs_device(src), dst_root = resolve_fs_device(dst);
    if(src_root.device != dst_root.device)
     caml_failwith
      ("caml_unix_symlink: cannot symlink between two filesystems");
    if(! src_root.device.symlink)
     caml_failwith("caml_unix_symlink: not implemented");
    return src_root.device.symlink(to_dir, src_root.rest, dst_root.rest, true);
   }
   function caml_ml_pos_out(chanid){return caml_pos_out(chanid);}
   function caml_spacetime_enabled(_unit){return 0;}
   function caml_bytes_notequal(s1, s2){return 1 - caml_bytes_equal(s1, s2);}
   function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("");}
   function caml_js_object(a){
    var o = {};
    for(var i = 1; i < a.length; i++){
     var p = a[i];
     o[caml_jsstring_of_string(p[1])] = p[2];
    }
    return o;
   }
   function caml_ba_create(kind, layout, dims_ml){
    var
     dims = caml_js_from_array(dims_ml),
     data = caml_ba_create_buffer(kind, caml_ba_get_size(dims));
    return caml_ba_create_unsafe(kind, layout, dims, data);
   }
   function caml_gr_remember_mode(){
    caml_failwith("caml_gr_remember_mode not Implemented");
   }
   function caml_fma_float(x, y, z){
    var
     SPLIT = Math.pow(2, 27) + 1,
     MIN_VALUE = Math.pow(2, - 1022),
     EPSILON = Math.pow(2, - 52),
     C = 416,
     A = Math.pow(2, + C),
     B = Math.pow(2, - C);
    function multiply(a, b){
     var
      at = SPLIT * a,
      ahi = at - (at - a),
      alo = a - ahi,
      bt = SPLIT * b,
      bhi = bt - (bt - b),
      blo = b - bhi,
      p = a * b,
      e = ahi * bhi - p + ahi * blo + alo * bhi + alo * blo;
     return {p: p, e: e};
    }
    function add(a, b){
     var s = a + b, v = s - a, e = a - (s - v) + (b - v);
     return {s: s, e: e};
    }
    function adjust(x, y){
     return x !== 0 && y !== 0 && SPLIT * x - (SPLIT * x - x) === x
             ? x * (1 + (x < 0 ? - 1 : + 1) * (y < 0 ? - 1 : + 1) * EPSILON)
             : x;
    }
    if
     (x === 0 || x !== x || x === + (1 / 0) || x === - (1 / 0) || y === 0
      || y !== y
      || y === + (1 / 0)
      || y === - (1 / 0))
     return x * y + z;
    if(z === 0) return x * y;
    if(z !== z || z === + (1 / 0) || z === - (1 / 0)) return z;
    var scale = 1;
    while(Math.abs(x) > A){scale *= A; x *= B;}
    while(Math.abs(y) > A){scale *= A; y *= B;}
    if(scale === 1 / 0) return x * y * scale;
    while(Math.abs(x) < B){scale *= B; x *= A;}
    while(Math.abs(y) < B){scale *= B; y *= A;}
    if(scale === 0) return z;
    var xs = x, ys = y, zs = z / scale;
    if(Math.abs(zs) > Math.abs(xs * ys) * 4 / EPSILON) return z;
    if(Math.abs(zs) < Math.abs(xs * ys) * EPSILON / 4 * EPSILON / 4)
     zs = (z < 0 ? - 1 : + 1) * MIN_VALUE;
    var
     xy = multiply(xs, ys),
     s = add(xy.p, zs),
     u = add(xy.e, s.e),
     i = add(s.s, u.s),
     f = i.s + adjust(i.e, u.e);
    if(f === 0) return f;
    var fs = f * scale;
    if(Math.abs(fs) > MIN_VALUE) return fs;
    return fs + adjust(f - fs / scale, i.e) * scale;
   }
   function caml_recommended_domain_count(unit){return 1;}
   function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8;}
   function caml_ml_set_binary_mode(chanid, mode){
    var chan = caml_ml_channels[chanid];
    chan.file.flags.text = ! mode;
    chan.file.flags.binary = mode;
    return 0;
   }
   function caml_final_register(){return 0;}
   function caml_gr_draw_rect(x, y, w, h){
    var s = caml_gr_state_get();
    s.context.strokeRect(x, s.height - y, w, - h);
    return 0;
   }
   function caml_string_get16(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 1) caml_string_bound_error();
    var
     b1 = caml_string_unsafe_get(s, i),
     b2 = caml_string_unsafe_get(s, i + 1);
    return b2 << 8 | b1;
   }
   function caml_output_value(chanid, v, flags){
    var s = caml_output_value_to_string(v, flags);
    caml_ml_output(chanid, s, 0, caml_ml_string_length(s));
    return 0;
   }
   function caml_ba_get_3(ba, i0, i1, i2){
    return ba.get(ba.offset([i0, i1, i2]));
   }
   function caml_ephe_blit_key(a1, i1, a2, i2, len){
    caml_array_blit
     (a1,
      caml_ephe_key_offset + i1 - 1,
      a2,
      caml_ephe_key_offset + i2 - 1,
      len);
    return 0;
   }
   var caml_initial_time = new Date().getTime() * 0.001;
   function caml_sys_time(){
    var now = new Date().getTime();
    return now * 0.001 - caml_initial_time;
   }
   function caml_sys_time_include_children(b){return caml_sys_time();}
   function caml_check_bound(array, index){
    if(index >>> 0 >= array.length - 1) caml_array_bound_error();
    return array;
   }
   function caml_unix_getpwuid(unit){caml_raise_not_found();}
   function caml_hash(count, limit, seed, obj){
    var queue, rd, wr, sz, num, h, v, i, len;
    sz = limit;
    if(sz < 0 || sz > 256) sz = 256;
    num = count;
    h = seed;
    queue = [obj];
    rd = 0;
    wr = 1;
    while(rd < wr && num > 0){
     v = queue[rd++];
     if(v && v.caml_custom){
      if
       (caml_custom_ops[v.caml_custom] && caml_custom_ops[v.caml_custom].hash){
       var hh = caml_custom_ops[v.caml_custom].hash(v);
       h = caml_hash_mix_int(h, hh);
       num--;
      }
     }
     else if(v instanceof Array && v[0] === (v[0] | 0))
      switch(v[0]){
        case 248:
         h = caml_hash_mix_int(h, v[2]); num--; break;
        case 250:
         queue[--rd] = v[1]; break;
        default:
         if(caml_is_continuation_tag(v[0])) break;
         var tag = v.length - 1 << 10 | v[0];
         h = caml_hash_mix_int(h, tag);
         for(i = 1, len = v.length; i < len; i++){if(wr >= sz) break; queue[wr++] = v[i];
         }
         break;
      }
     else if(caml_is_ml_bytes(v)){
      h = caml_hash_mix_bytes(h, v);
      num--;
     }
     else if(caml_is_ml_string(v)){
      h = caml_hash_mix_string(h, v);
      num--;
     }
     else if(typeof v === "string"){
      h = caml_hash_mix_jsbytes(h, v);
      num--;
     }
     else if(v === (v | 0)){
      h = caml_hash_mix_int(h, v + v + 1);
      num--;
     }
     else if(typeof v === "number"){h = caml_hash_mix_float(h, v); num--;}
    }
    h = caml_hash_mix_final(h);
    return h & 0x3FFFFFFF;
   }
   function caml_ba_to_typed_array(ba){return ba.data;}
   function caml_domain_dls_get(unit){return caml_domain_dls;}
   function caml_bytes_get32(s, i){
    if(i >>> 0 >= s.l - 3) caml_bytes_bound_error();
    var
     b1 = caml_bytes_unsafe_get(s, i),
     b2 = caml_bytes_unsafe_get(s, i + 1),
     b3 = caml_bytes_unsafe_get(s, i + 2),
     b4 = caml_bytes_unsafe_get(s, i + 3);
    return b4 << 24 | b3 << 16 | b2 << 8 | b1;
   }
   function caml_frexp_float(x){
    if(x == 0 || ! isFinite(x)) return [0, x, 0];
    var neg = x < 0;
    if(neg) x = - x;
    var exp = Math.max(- 1023, jsoo_floor_log2(x) + 1);
    x *= Math.pow(2, - exp);
    while(x < 0.5){x *= 2; exp--;}
    while(x >= 1){x *= 0.5; exp++;}
    if(neg) x = - x;
    return [0, x, exp];
   }
   function caml_string_get64(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 7) caml_string_bound_error();
    var a = new Array(8);
    for(var j = 0; j < 8; j++) a[7 - j] = caml_string_unsafe_get(s, i + j);
    return caml_int64_of_bytes(a);
   }
   function caml_js_error_option_of_exception(exn){
    if(exn.js_error) return [0, exn.js_error];
    return 0;
   }
   function caml_ml_pos_out_64(chanid){
    return caml_int64_of_float(caml_pos_out(chanid));
   }
   function caml_unix_findclose(dir_handle){return caml_unix_closedir(dir_handle);
   }
   function caml_gr_close_subwindow(a){
    caml_failwith("caml_gr_close_subwindow not Implemented");
   }
   function caml_floatarray_blit(a1, i1, a2, i2, len){
    if(i2 <= i1)
     for(var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];
    else
     for(var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];
    return 0;
   }
   function caml_get_minor_free(unit){return 0;}
   function caml_set_static_env(k, v){
    if(! globalThis.jsoo_static_env) globalThis.jsoo_static_env = {};
    globalThis.jsoo_static_env[k] = v;
    return 0;
   }
   function caml_ba_change_layout(ba, layout){
    if(ba.layout == layout) return ba;
    var new_dims = [];
    for(var i = 0; i < ba.dims.length; i++)
     new_dims[i] = ba.dims[ba.dims.length - i - 1];
    return caml_ba_create_unsafe(ba.kind, layout, new_dims, ba.data);
   }
   function caml_js_new(c, a){
    switch(a.length){
      case 1:
       return new c;
      case 2:
       return new c(a[1]);
      case 3:
       return new c(a[1], a[2]);
      case 4:
       return new c(a[1], a[2], a[3]);
      case 5:
       return new c(a[1], a[2], a[3], a[4]);
      case 6:
       return new c(a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return new c(a[1], a[2], a[3], a[4], a[5], a[6]);
      case 8:
       return new c(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    }
    function F(){return c.apply(this, caml_js_from_array(a));}
    F.prototype = c.prototype;
    return new F;
   }
   function caml_gr_current_y(){var s = caml_gr_state_get(); return s.y;}
   function caml_format_int(fmt, i){
    if(caml_jsbytes_of_string(fmt) == "%d")
     return caml_string_of_jsbytes("" + i);
    var f = caml_parse_format(fmt);
    if(i < 0) if(f.signedconv){f.sign = - 1; i = - i;} else i >>>= 0;
    var s = i.toString(f.base);
    if(f.prec >= 0){
     f.filler = " ";
     var n = f.prec - s.length;
     if(n > 0) s = caml_str_repeat(n, "0") + s;
    }
    return caml_finish_formatting(f, s);
   }
   function jsoo_effect_not_supported(){
    caml_failwith("Effect handlers are not supported");
   }
   var caml_ml_domain_unique_token_ = [0];
   function caml_ml_domain_unique_token(unit){return caml_ml_domain_unique_token_;
   }
   function caml_continuation_use_and_update_handler_noexc
   (cont, hval, hexn, heff){
    var stack = caml_continuation_use_noexc(cont);
    stack[3] = [0, hval, hexn, heff];
    return stack;
   }
   function caml_obj_truncate(x, s){
    if(s <= 0 || s + 1 > x.length) caml_invalid_argument("Obj.truncate");
    if(x.length != s + 1) x.length = s + 1;
    return 0;
   }
   function caml_js_to_string(s){return caml_string_of_jsstring(s);}
   function is_digit_odd(nat, ofs){if(nat.data[ofs] & 1) return 1; return 0;}
   function caml_runtime_variant(_unit){return caml_string_of_jsbytes("");}
   function caml_ml_open_descriptor_out(fd){
    var file = caml_sys_fds[fd];
    if(file.flags.rdonly) caml_raise_sys_error("fd " + fd + " is readonly");
    var
     buffered = file.flags.buffered !== undefined ? file.flags.buffered : 1,
     channel =
       {file: file,
        offset: file.flags.append ? file.length() : 0,
        fd: fd,
        opened: true,
        out: true,
        buffer_curr: 0,
        buffer: new Uint8Array(65536),
        buffered: buffered};
    caml_ml_channels[channel.fd] = channel;
    return channel.fd;
   }
   function caml_array_concat(l){
    var a = [0];
    while(l !== 0){
     var b = l[1];
     for(var i = 1; i < b.length; i++) a.push(b[i]);
     l = l[2];
    }
    return a;
   }
   function caml_gr_open_graph(info){
    var info = caml_jsstring_of_string(info);
    function get(name){
     var res = info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
     if(res) return res[2];
    }
    var specs = [];
    if(! (info == "")) specs.push(info);
    var target = get("target");
    if(! target) target = "";
    var status = get("status");
    if(! status) specs.push("status=1");
    var w = get("width");
    w = w ? parseInt(w) : 200;
    specs.push("width=" + w);
    var h = get("height");
    h = h ? parseInt(h) : 200;
    specs.push("height=" + h);
    var win = globalThis.open("about:blank", target, specs.join(","));
    if(! win) caml_failwith("Graphics.open_graph: cannot open the window");
    var doc = win.document, canvas = doc.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    var ctx = caml_gr_state_create(canvas, w, h);
    ctx.set_title = function(title){doc.title = title;};
    caml_gr_state_set(ctx);
    var body = doc.body;
    body.style.margin = "0px";
    body.appendChild(canvas);
    return 0;
   }
   function caml_make_float_vect(len){
    if(len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 254;
    for(var i = 1; i < len; i++) b[i] = 0;
    return b;
   }
   function caml_cbrt_float(x){return Math.cbrt(x);}
   function caml_eventlog_pause(unit){return 0;}
   function caml_memprof_stop(unit){return 0;}
   function caml_greaterequal(x, y){
    return + (caml_compare_val(x, y, false) >= 0);
   }
   function caml_get_exception_raw_backtrace(){return [0];}
   function caml_log1p_float(x){return Math.log1p(x);}
   function caml_runtime_events_free_cursor(cursor){return 0;}
   function caml_lazy_make_forward(v){return [250, v];}
   function lor_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] |= nat2.data[ofs2]; return 0;
   }
   function caml_gr_blit_image(im, x, y){
    var
     s = caml_gr_state_get(),
     im2 =
       s.context.getImageData
        (x, s.height - im.height - y, im.width, im.height);
    for(var i = 0; i < im2.data.length; i += 4){
     im.data[i] = im2.data[i];
     im.data[i + 1] = im2.data[i + 1];
     im.data[i + 2] = im2.data[i + 2];
     im.data[i + 3] = im2.data[i + 3];
    }
    return 0;
   }
   function caml_gr_window_id(a){
    caml_failwith("caml_gr_window_id not Implemented");
   }
   function caml_js_on_ie(){
    var ua = globalThis.navigator ? globalThis.navigator.userAgent : "";
    return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0;
   }
   function caml_int64_shift_right(x, s){return x.shift_right(s);}
   function caml_ba_layout(ba){return ba.layout;}
   function caml_convert_raw_backtrace(){return [0];}
   function caml_array_set(array, index, newval){
    if(index < 0 || index >= array.length - 1) caml_array_bound_error();
    array[index + 1] = newval;
    return 0;
   }
   function caml_alloc_stack(hv, hx, hf){return 0;}
   function caml_bytes_greaterequal(s1, s2){return caml_bytes_lessequal(s2, s1);
   }
   function set_digit_nat(nat, ofs, digit){nat.data[ofs] = digit; return 0;}
   function caml_bytes_set16(s, i, i16){
    if(i >>> 0 >= s.l - 1) caml_bytes_bound_error();
    var b2 = 0xFF & i16 >> 8, b1 = 0xFF & i16;
    caml_bytes_unsafe_set(s, i + 0, b1);
    caml_bytes_unsafe_set(s, i + 1, b2);
    return 0;
   }
   function caml_gr_doc_of_state(state){
    if(state.canvas.ownerDocument) return state.canvas.ownerDocument;
   }
   function caml_ml_output_int(chanid, i){
    var
     arr = [i >> 24 & 0xFF, i >> 16 & 0xFF, i >> 8 & 0xFF, i & 0xFF],
     s = caml_string_of_array(arr);
    caml_ml_output(chanid, s, 0, 4);
    return 0;
   }
   function caml_obj_with_tag(tag, x){
    var l = x.length, a = new Array(l);
    a[0] = tag;
    for(var i = 1; i < l; i++) a[i] = x[i];
    return a;
   }
   function caml_ml_channel_size(chanid){
    var chan = caml_ml_channels[chanid];
    return chan.file.length();
   }
   function caml_raw_backtrace_slot(){
    caml_invalid_argument
     ("Printexc.get_raw_backtrace_slot: index out of bounds");
   }
   function caml_hexstring_of_float(x, prec, style){
    if(! isFinite(x)){
     if(isNaN(x)) return caml_string_of_jsstring("nan");
     return caml_string_of_jsstring(x > 0 ? "infinity" : "-infinity");
    }
    var sign = x == 0 && 1 / x == - Infinity ? 1 : x >= 0 ? 0 : 1;
    if(sign) x = - x;
    var exp = 0;
    if(x == 0)
     ;
    else if(x < 1)
     while(x < 1 && exp > - 1022){x *= 2; exp--;}
    else
     while(x >= 2){x /= 2; exp++;}
    var exp_sign = exp < 0 ? "" : "+", sign_str = "";
    if(sign)
     sign_str = "-";
    else
     switch(style){
       case 43:
        sign_str = "+"; break;
       case 32:
        sign_str = " "; break;
       default: break;
     }
    if(prec >= 0 && prec < 13){
     var cst = Math.pow(2, prec * 4);
     x = Math.round(x * cst) / cst;
    }
    var x_str = x.toString(16);
    if(prec >= 0){
     var idx = x_str.indexOf(".");
     if(idx < 0)
      x_str += "." + caml_str_repeat(prec, "0");
     else{
      var size = idx + 1 + prec;
      if(x_str.length < size)
       x_str += caml_str_repeat(size - x_str.length, "0");
      else
       x_str = x_str.substr(0, size);
     }
    }
    return caml_string_of_jsstring
            (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10));
   }
   function caml_runtime_events_user_write(event, event_content){return 0;}
   function caml_js_wrap_meth_callback_strict(arity, f){
    return function(){
     var args = new Array(arity + 1), len = Math.min(arguments.length, arity);
     args[0] = this;
     for(var i = 0; i < len; i++) args[i + 1] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_unix_readlink(name){
    var root = resolve_fs_device(name);
    if(! root.device.readlink)
     caml_failwith("caml_unix_readlink: not implemented");
    return root.device.readlink(root.rest, true);
   }
   function caml_backtrace_status(_unit){
    return caml_record_backtrace_flag ? 1 : 0;
   }
   function caml_install_signal_handler(){return 0;}
   function caml_sys_argv(a){return caml_argv;}
   function caml_ba_fill(ba, v){ba.fill(v); return 0;}
   function caml_modf_float(x){
    if(isFinite(x)){
     var neg = 1 / x < 0;
     x = Math.abs(x);
     var i = Math.floor(x), f = x - i;
     if(neg){i = - i; f = - f;}
     return [0, f, i];
    }
    if(isNaN(x)) return [0, NaN, NaN];
    return [0, 1 / x, x];
   }
   function caml_gc_get(){return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];}
   function caml_float_compare(x, y){
    if(x === y) return 0;
    if(x < y) return - 1;
    if(x > y) return 1;
    if(x === x) return 1;
    if(y === y) return - 1;
    return 0;
   }
   function caml_string_set32(s, i, i32){caml_failwith("caml_string_set32");}
   function caml_parse_engine(tables, env, cmd, arg){
    var
     ERRCODE = 256,
     loop = 6,
     testshift = 7,
     shift = 8,
     shift_recover = 9,
     reduce = 10,
     READ_TOKEN = 0,
     RAISE_PARSE_ERROR = 1,
     GROW_STACKS_1 = 2,
     GROW_STACKS_2 = 3,
     COMPUTE_SEMANTIC_ACTION = 4,
     CALL_ERROR_FUNCTION = 5,
     env_s_stack = 1,
     env_v_stack = 2,
     env_symb_start_stack = 3,
     env_symb_end_stack = 4,
     env_stacksize = 5,
     env_stackbase = 6,
     env_curr_char = 7,
     env_lval = 8,
     env_symb_start = 9,
     env_symb_end = 10,
     env_asp = 11,
     env_rule_len = 12,
     env_rule_number = 13,
     env_sp = 14,
     env_state = 15,
     env_errflag = 16,
     tbl_transl_const = 2,
     tbl_transl_block = 3,
     tbl_lhs = 4,
     tbl_len = 5,
     tbl_defred = 6,
     tbl_dgoto = 7,
     tbl_sindex = 8,
     tbl_rindex = 9,
     tbl_gindex = 10,
     tbl_tablesize = 11,
     tbl_table = 12,
     tbl_check = 13,
     tbl_names_const = 15,
     tbl_names_block = 16;
    function log(x){
     var s = caml_string_of_jsbytes(x + "\n");
     caml_ml_output(2, s, 0, caml_ml_string_length(s));
    }
    function token_name(names, number){
     var str = caml_jsstring_of_string(names);
     if(str[0] == "\x00") return "<unknown token>";
     return str.split("\x00")[number];
    }
    function print_token(state, tok){
     var token, kind;
     if(tok instanceof Array){
      token = token_name(tables[tbl_names_block], tok[0]);
      if(typeof tok[1] == "number")
       kind = "" + tok[1];
      else if(typeof tok[1] == "string")
       kind = tok[1];
      else if(tok[1] instanceof MlBytes)
       kind = caml_jsbytes_of_string(tok[1]);
      else
       kind = "_";
      log("State " + state + ": read token " + token + "(" + kind + ")");
     }
     else{
      token = token_name(tables[tbl_names_const], tok);
      log("State " + state + ": read token " + token);
     }
    }
    if(! tables.dgoto){
     tables.defred = caml_lex_array(tables[tbl_defred]);
     tables.sindex = caml_lex_array(tables[tbl_sindex]);
     tables.check = caml_lex_array(tables[tbl_check]);
     tables.rindex = caml_lex_array(tables[tbl_rindex]);
     tables.table = caml_lex_array(tables[tbl_table]);
     tables.len = caml_lex_array(tables[tbl_len]);
     tables.lhs = caml_lex_array(tables[tbl_lhs]);
     tables.gindex = caml_lex_array(tables[tbl_gindex]);
     tables.dgoto = caml_lex_array(tables[tbl_dgoto]);
    }
    var
     res = 0,
     n,
     n1,
     n2,
     state1,
     sp = env[env_sp],
     state = env[env_state],
     errflag = env[env_errflag];
    exit:
    for(;;)
     next:
     switch(cmd){
       case 0:
        state = 0; errflag = 0;
       case 6:
        n = tables.defred[state];
        if(n != 0){cmd = reduce; break;}
        if(env[env_curr_char] >= 0){cmd = testshift; break;}
        res = READ_TOKEN;
        break exit;
       case 1:
        if(arg instanceof Array){
         env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
         env[env_lval] = arg[1];
        }
        else{
         env[env_curr_char] = tables[tbl_transl_const][arg + 1];
         env[env_lval] = 0;
        }
        if(caml_parser_trace) print_token(state, arg);
       case 7:
        n1 = tables.sindex[state];
        n2 = n1 + env[env_curr_char];
        if
         (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] == env[env_curr_char]){cmd = shift; break;}
        n1 = tables.rindex[state];
        n2 = n1 + env[env_curr_char];
        if
         (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] == env[env_curr_char]){
         n = tables.table[n2];
         cmd = reduce;
         break;
        }
        if(errflag <= 0){res = CALL_ERROR_FUNCTION; break exit;}
       case 5:
        if(errflag < 3){
         errflag = 3;
         for(;;){
          state1 = env[env_s_stack][sp + 1];
          n1 = tables.sindex[state1];
          n2 = n1 + ERRCODE;
          if
           (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
            && tables.check[n2] == ERRCODE){
           if(caml_parser_trace) log("Recovering in state " + state1);
           cmd = shift_recover;
           break next;
          }
          else{
           if(caml_parser_trace) log("Discarding state " + state1);
           if(sp <= env[env_stackbase]){
            if(caml_parser_trace) log("No more states to discard");
            return RAISE_PARSE_ERROR;
           }
           sp--;
          }
         }
        }
        else{
         if(env[env_curr_char] == 0) return RAISE_PARSE_ERROR;
         if(caml_parser_trace) log("Discarding last token read");
         env[env_curr_char] = - 1;
         cmd = loop;
         break;
        }
       case 8:
        env[env_curr_char] = - 1; if(errflag > 0) errflag--;
       case 9:
        if(caml_parser_trace)
         log("State " + state + ": shift to state " + tables.table[n2]);
        state = tables.table[n2];
        sp++;
        if(sp >= env[env_stacksize]){res = GROW_STACKS_1; break exit;}
       case 2:
        env[env_s_stack][sp + 1] = state;
        env[env_v_stack][sp + 1] = env[env_lval];
        env[env_symb_start_stack][sp + 1] = env[env_symb_start];
        env[env_symb_end_stack][sp + 1] = env[env_symb_end];
        cmd = loop;
        break;
       case 10:
        if(caml_parser_trace) log("State " + state + ": reduce by rule " + n);
        var m = tables.len[n];
        env[env_asp] = sp;
        env[env_rule_number] = n;
        env[env_rule_len] = m;
        sp = sp - m + 1;
        m = tables.lhs[n];
        state1 = env[env_s_stack][sp];
        n1 = tables.gindex[m];
        n2 = n1 + state1;
        if
         (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] == state1)
         state = tables.table[n2];
        else
         state = tables.dgoto[m];
        if(sp >= env[env_stacksize]){res = GROW_STACKS_2; break exit;}
       case 3:
        res = COMPUTE_SEMANTIC_ACTION; break exit;
       case 4:
        env[env_s_stack][sp + 1] = state;
        env[env_v_stack][sp + 1] = arg;
        var asp = env[env_asp];
        env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
        if(sp > asp)
         env[env_symb_start_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
        cmd = loop;
        break;
       default: return RAISE_PARSE_ERROR;
     }
    env[env_sp] = sp;
    env[env_state] = state;
    env[env_errflag] = errflag;
    return res;
   }
   function caml_jsoo_flags_effects(unit){return 0;}
   function caml_update_dummy(x, y){
    if(y.fun){x.fun = y.fun; return 0;}
    if(typeof y === "function"){x.fun = y; return 0;}
    var i = y.length;
    while(i--) x[i] = y[i];
    return 0;
   }
   function caml_array_fill(array, ofs, len, v){
    for(var i = 0; i < len; i++) array[ofs + i + 1] = v;
    return 0;
   }
   function caml_sys_mkdir(name, perm){
    var root = resolve_fs_device(name);
    root.device.mkdir(root.rest, perm);
    return 0;
   }
   function caml_string_notequal(s1, s2){
    return 1 - caml_string_equal(s1, s2);
   }
   function caml_bytes_greaterthan(s1, s2){return caml_bytes_lessthan(s2, s1);
   }
   function caml_gr_make_image(arr){
    var
     s = caml_gr_state_get(),
     h = arr.length - 1,
     w = arr[1].length - 1,
     im = s.context.createImageData(w, h);
    for(var i = 0; i < h; i++)
     for(var j = 0; j < w; j++){
      var c = arr[i + 1][j + 1], o = i * (w * 4) + j * 4;
      if(c == - 1){
       im.data[o + 0] = 0;
       im.data[o + 1] = 0;
       im.data[o + 2] = 0;
       im.data[o + 3] = 0;
      }
      else{
       im.data[o + 0] = c >> 16 & 0xff;
       im.data[o + 1] = c >> 8 & 0xff;
       im.data[o + 2] = c >> 0 & 0Xff;
       im.data[o + 3] = 0xff;
      }
     }
    return im;
   }
   function caml_ml_set_channel_output(chanid, f){
    var chan = caml_ml_channels[chanid];
    chan.output = function(s){f(s);};
    return 0;
   }
   function caml_read_file_content(name){
    var
     name = typeof name == "string" ? caml_string_of_jsbytes(name) : name,
     root = resolve_fs_device(name);
    if(root.device.exists(root.rest)){
     var
      file = root.device.open(root.rest, {rdonly: 1}),
      len = file.length(),
      buf = new Uint8Array(len);
     file.read(0, buf, 0, len);
     return caml_string_of_array(buf);
    }
    caml_raise_no_such_file(caml_jsbytes_of_string(name));
   }
   function caml_js_to_float(x){return x;}
   function caml_setup_uncaught_exception_handler(){
    var process = globalThis.process;
    if(process && process.on)
     process.on
      ("uncaughtException",
       function(err, origin){
        caml_fatal_uncaught_exception(err);
        process.exit(2);
       });
    else if(globalThis.addEventListener)
     globalThis.addEventListener
      ("error",
       function(event){
        if(event.error) caml_fatal_uncaught_exception(event.error);
       });
   }
   caml_setup_uncaught_exception_handler();
   globalThis.jsoo_runtime =
    {caml_runtime_events_read_poll: caml_runtime_events_read_poll,
     caml_runtime_events_free_cursor: caml_runtime_events_free_cursor,
     caml_runtime_events_create_cursor: caml_runtime_events_create_cursor,
     caml_runtime_events_resume: caml_runtime_events_resume,
     caml_runtime_events_pause: caml_runtime_events_pause,
     caml_runtime_events_start: caml_runtime_events_start,
     caml_runtime_events_user_resolve: caml_runtime_events_user_resolve,
     caml_runtime_events_user_write: caml_runtime_events_user_write,
     caml_runtime_events_user_register: caml_runtime_events_user_register,
     caml_custom_event_index: caml_custom_event_index,
     zstd_decompress: zstd_decompress,
     jsoo_effect_not_supported: jsoo_effect_not_supported,
     caml_ml_condition_signal: caml_ml_condition_signal,
     caml_ml_condition_broadcast: caml_ml_condition_broadcast,
     caml_ml_condition_wait: caml_ml_condition_wait,
     caml_ml_condition_new: caml_ml_condition_new,
     caml_get_continuation_callstack: caml_get_continuation_callstack,
     caml_continuation_use_and_update_handler_noexc:
     caml_continuation_use_and_update_handler_noexc,
     caml_continuation_use_noexc: caml_continuation_use_noexc,
     caml_alloc_stack: caml_alloc_stack,
     caml_ml_mutex_unlock: caml_ml_mutex_unlock,
     caml_ml_mutex_try_lock: caml_ml_mutex_try_lock,
     caml_ml_mutex_lock: caml_ml_mutex_lock,
     caml_ml_mutex_new: caml_ml_mutex_new,
     MlMutex: MlMutex,
     caml_lxm_next: caml_lxm_next,
     caml_ml_domain_cpu_relax: caml_ml_domain_cpu_relax,
     caml_ml_domain_id: caml_ml_domain_id,
     caml_domain_spawn: caml_domain_spawn,
     caml_domain_id: caml_domain_id,
     caml_recommended_domain_count: caml_recommended_domain_count,
     caml_ml_domain_set_name: caml_ml_domain_set_name,
     caml_ml_domain_unique_token: caml_ml_domain_unique_token,
     caml_atomic_exchange: caml_atomic_exchange,
     caml_atomic_fetch_add: caml_atomic_fetch_add,
     caml_atomic_cas: caml_atomic_cas,
     caml_atomic_load: caml_atomic_load,
     caml_domain_dls_get: caml_domain_dls_get,
     caml_domain_dls_set: caml_domain_dls_set,
     caml_domain_dls: caml_domain_dls,
     caml_ephe_check_data: caml_ephe_check_data,
     caml_ephe_unset_data: caml_ephe_unset_data,
     caml_ephe_set_data: caml_ephe_set_data,
     caml_ephe_get_data_copy: caml_ephe_get_data_copy,
     caml_ephe_get_data: caml_ephe_get_data,
     caml_ephe_blit_data: caml_ephe_blit_data,
     caml_ephe_blit_key: caml_ephe_blit_key,
     caml_ephe_check_key: caml_ephe_check_key,
     caml_ephe_get_key_copy: caml_ephe_get_key_copy,
     caml_ephe_get_key: caml_ephe_get_key,
     caml_weak_set: caml_weak_set,
     caml_weak_create: caml_weak_create,
     caml_ephe_create: caml_ephe_create,
     caml_ephe_unset_key: caml_ephe_unset_key,
     caml_ephe_set_key: caml_ephe_set_key,
     caml_ephe_data_offset: caml_ephe_data_offset,
     caml_ephe_key_offset: caml_ephe_key_offset,
     caml_unix_inet_addr_of_string: caml_unix_inet_addr_of_string,
     caml_unix_findclose: caml_unix_findclose,
     caml_unix_findnext: caml_unix_findnext,
     caml_unix_findfirst: caml_unix_findfirst,
     caml_unix_rewinddir: caml_unix_rewinddir,
     caml_unix_closedir: caml_unix_closedir,
     caml_unix_readdir: caml_unix_readdir,
     caml_unix_opendir: caml_unix_opendir,
     caml_unix_has_symlink: caml_unix_has_symlink,
     caml_unix_getpwuid: caml_unix_getpwuid,
     caml_unix_getuid: caml_unix_getuid,
     caml_unix_unlink: caml_unix_unlink,
     caml_unix_readlink: caml_unix_readlink,
     caml_unix_symlink: caml_unix_symlink,
     caml_unix_rmdir: caml_unix_rmdir,
     caml_unix_mkdir: caml_unix_mkdir,
     caml_unix_lstat_64: caml_unix_lstat_64,
     caml_unix_lstat: caml_unix_lstat,
     caml_unix_stat_64: caml_unix_stat_64,
     caml_unix_stat: caml_unix_stat,
     make_unix_err_args: make_unix_err_args,
     caml_unix_isatty: caml_unix_isatty,
     caml_unix_filedescr_of_fd: caml_unix_filedescr_of_fd,
     caml_unix_cleanup: caml_unix_cleanup,
     caml_unix_startup: caml_unix_startup,
     caml_unix_mktime: caml_unix_mktime,
     caml_unix_localtime: caml_unix_localtime,
     caml_unix_gmtime: caml_unix_gmtime,
     caml_unix_time: caml_unix_time,
     caml_unix_gettimeofday: caml_unix_gettimeofday,
     caml_str_initialize: caml_str_initialize,
     re_replacement_text: re_replacement_text,
     re_partial_match: re_partial_match,
     re_string_match: re_string_match,
     re_search_backward: re_search_backward,
     re_search_forward: re_search_forward,
     re_match: re_match,
     caml_sys_is_regular_file: caml_sys_is_regular_file,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime: caml_register_channel_for_spacetime,
     caml_sys_const_naked_pointers_checked:
     caml_sys_const_naked_pointers_checked,
     caml_spacetime_enabled: caml_spacetime_enabled,
     caml_ml_runtime_warnings_enabled: caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings: caml_ml_enable_runtime_warnings,
     caml_runtime_warnings: caml_runtime_warnings,
     caml_install_signal_handler: caml_install_signal_handler,
     caml_runtime_parameters: caml_runtime_parameters,
     caml_runtime_variant: caml_runtime_variant,
     caml_sys_isatty: caml_sys_isatty,
     caml_sys_get_config: caml_sys_get_config,
     os_type: os_type,
     caml_sys_const_backend_type: caml_sys_const_backend_type,
     caml_sys_const_ostype_cygwin: caml_sys_const_ostype_cygwin,
     caml_sys_const_ostype_win32: caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix: caml_sys_const_ostype_unix,
     caml_sys_const_max_wosize: caml_sys_const_max_wosize,
     caml_sys_const_int_size: caml_sys_const_int_size,
     caml_sys_const_word_size: caml_sys_const_word_size,
     caml_sys_const_big_endian: caml_sys_const_big_endian,
     caml_sys_random_seed: caml_sys_random_seed,
     caml_sys_time_include_children: caml_sys_time_include_children,
     caml_sys_time: caml_sys_time,
     caml_sys_system_command: caml_sys_system_command,
     caml_sys_executable_name: caml_sys_executable_name,
     caml_sys_modify_argv: caml_sys_modify_argv,
     caml_sys_argv: caml_sys_argv,
     caml_sys_get_argv: caml_sys_get_argv,
     caml_executable_name: caml_executable_name,
     caml_argv: caml_argv,
     caml_sys_unsafe_getenv: caml_sys_unsafe_getenv,
     caml_sys_getenv: caml_sys_getenv,
     jsoo_sys_getenv: jsoo_sys_getenv,
     caml_set_static_env: caml_set_static_env,
     caml_fatal_uncaught_exception: caml_fatal_uncaught_exception,
     caml_format_exception: caml_format_exception,
     caml_is_special_exception: caml_is_special_exception,
     caml_sys_exit: caml_sys_exit,
     caml_raise_sys_error: caml_raise_sys_error,
     caml_maybe_print_stats: caml_maybe_print_stats,
     caml_is_printable: caml_is_printable,
     caml_get_global_data: caml_get_global_data,
     caml_register_global: caml_register_global,
     caml_build_symbols: caml_build_symbols,
     caml_global_data: caml_global_data,
     caml_named_value: caml_named_value,
     caml_register_named_value: caml_register_named_value,
     caml_named_values: caml_named_values,
     caml_call_gen: caml_call_gen,
     caml_set_parser_trace: caml_set_parser_trace,
     caml_parse_engine: caml_parse_engine,
     caml_parser_trace: caml_parser_trace,
     caml_is_continuation_tag: caml_is_continuation_tag,
     caml_lazy_read_result: caml_lazy_read_result,
     caml_lazy_reset_to_lazy: caml_lazy_reset_to_lazy,
     caml_lazy_update_to_forward: caml_lazy_update_to_forward,
     caml_lazy_update_to_forcing: caml_lazy_update_to_forcing,
     caml_obj_update_tag: caml_obj_update_tag,
     caml_obj_add_offset: caml_obj_add_offset,
     caml_obj_reachable_words: caml_obj_reachable_words,
     caml_obj_set_raw_field: caml_obj_set_raw_field,
     caml_obj_raw_field: caml_obj_raw_field,
     caml_fresh_oo_id: caml_fresh_oo_id,
     caml_set_oo_id: caml_set_oo_id,
     caml_oo_last_id: caml_oo_last_id,
     caml_get_public_method: caml_get_public_method,
     caml_lazy_make_forward: caml_lazy_make_forward,
     caml_obj_is_shared: caml_obj_is_shared,
     caml_obj_compare_and_swap: caml_obj_compare_and_swap,
     caml_obj_make_forward: caml_obj_make_forward,
     caml_obj_truncate: caml_obj_truncate,
     caml_obj_dup: caml_obj_dup,
     caml_obj_with_tag: caml_obj_with_tag,
     caml_obj_block: caml_obj_block,
     caml_obj_set_tag: caml_obj_set_tag,
     caml_obj_tag: caml_obj_tag,
     caml_obj_is_block: caml_obj_is_block,
     caml_alloc_dummy_infix: caml_alloc_dummy_infix,
     caml_update_dummy: caml_update_dummy,
     deserialize_nat: deserialize_nat,
     serialize_nat: serialize_nat,
     lxor_digit_nat: lxor_digit_nat,
     lor_digit_nat: lor_digit_nat,
     land_digit_nat: land_digit_nat,
     compare_nat_real: compare_nat_real,
     compare_nat: compare_nat,
     compare_digits_nat: compare_digits_nat,
     shift_right_nat: shift_right_nat,
     div_nat: div_nat,
     div_digit_nat: div_digit_nat,
     div_helper: div_helper,
     shift_left_nat: shift_left_nat,
     square_nat: square_nat,
     mult_nat: mult_nat,
     mult_digit_nat: mult_digit_nat,
     sub_nat: sub_nat,
     decr_nat: decr_nat,
     complement_nat: complement_nat,
     add_nat: add_nat,
     incr_nat: incr_nat,
     is_digit_odd: is_digit_odd,
     is_digit_zero: is_digit_zero,
     is_digit_int: is_digit_int,
     num_leading_zero_bits_in_digit: num_leading_zero_bits_in_digit,
     num_digits_nat: num_digits_nat,
     nth_digit_nat_native: nth_digit_nat_native,
     set_digit_nat_native: set_digit_nat_native,
     nth_digit_nat: nth_digit_nat,
     set_digit_nat: set_digit_nat,
     blit_nat: blit_nat,
     set_to_zero_nat: set_to_zero_nat,
     create_nat: create_nat,
     nat_of_array: nat_of_array,
     caml_hash_nat: caml_hash_nat,
     MlNat: MlNat,
     initialize_nat: initialize_nat,
     caml_array_of_bytes: caml_array_of_bytes,
     caml_array_of_string: caml_array_of_string,
     caml_js_to_string: caml_js_to_string,
     caml_to_js_string: caml_to_js_string,
     caml_js_from_string: caml_js_from_string,
     caml_new_string: caml_new_string,
     caml_js_to_byte_string: caml_js_to_byte_string,
     caml_is_ml_string: caml_is_ml_string,
     caml_ml_bytes_content: caml_ml_bytes_content,
     caml_is_ml_bytes: caml_is_ml_bytes,
     caml_bytes_of_jsbytes: caml_bytes_of_jsbytes,
     caml_string_of_jsstring: caml_string_of_jsstring,
     caml_jsstring_of_string: caml_jsstring_of_string,
     caml_jsbytes_of_string: caml_jsbytes_of_string,
     caml_string_of_jsbytes: caml_string_of_jsbytes,
     caml_bytes_of_string: caml_bytes_of_string,
     caml_string_of_bytes: caml_string_of_bytes,
     caml_string_lessthan: caml_string_lessthan,
     caml_string_lessequal: caml_string_lessequal,
     caml_string_equal: caml_string_equal,
     caml_string_compare: caml_string_compare,
     caml_ml_string_length: caml_ml_string_length,
     caml_string_unsafe_set: caml_string_unsafe_set,
     caml_string_unsafe_get: caml_string_unsafe_get,
     caml_ml_bytes_length: caml_ml_bytes_length,
     caml_blit_string: caml_blit_string,
     caml_blit_bytes: caml_blit_bytes,
     caml_fill_bytes: caml_fill_bytes,
     caml_bytes_greaterthan: caml_bytes_greaterthan,
     caml_string_greaterthan: caml_string_greaterthan,
     caml_bytes_greaterequal: caml_bytes_greaterequal,
     caml_string_greaterequal: caml_string_greaterequal,
     caml_bytes_lessthan: caml_bytes_lessthan,
     caml_bytes_lessequal: caml_bytes_lessequal,
     caml_bytes_notequal: caml_bytes_notequal,
     caml_string_notequal: caml_string_notequal,
     caml_bytes_equal: caml_bytes_equal,
     caml_bytes_compare: caml_bytes_compare,
     caml_bytes_of_array: caml_bytes_of_array,
     caml_string_of_array: caml_string_of_array,
     caml_create_bytes: caml_create_bytes,
     caml_create_string: caml_create_string,
     caml_uint8_array_of_string: caml_uint8_array_of_string,
     caml_uint8_array_of_bytes: caml_uint8_array_of_bytes,
     caml_convert_bytes_to_array: caml_convert_bytes_to_array,
     caml_convert_string_to_bytes: caml_convert_string_to_bytes,
     MlBytes: MlBytes,
     caml_bytes_of_utf16_jsstring: caml_bytes_of_utf16_jsstring,
     caml_bytes_set: caml_bytes_set,
     caml_string_set64: caml_string_set64,
     caml_bytes_set64: caml_bytes_set64,
     caml_string_set32: caml_string_set32,
     caml_bytes_set32: caml_bytes_set32,
     caml_string_set16: caml_string_set16,
     caml_bytes_set16: caml_bytes_set16,
     caml_string_set: caml_string_set,
     caml_bytes_get: caml_bytes_get,
     caml_bytes_get64: caml_bytes_get64,
     caml_string_get64: caml_string_get64,
     caml_bytes_get32: caml_bytes_get32,
     caml_string_get32: caml_string_get32,
     caml_bytes_get16: caml_bytes_get16,
     caml_string_get16: caml_string_get16,
     caml_string_get: caml_string_get,
     caml_bytes_bound_error: caml_bytes_bound_error,
     caml_string_bound_error: caml_string_bound_error,
     caml_bytes_unsafe_set: caml_bytes_unsafe_set,
     caml_bytes_unsafe_get: caml_bytes_unsafe_get,
     jsoo_is_ascii: jsoo_is_ascii,
     caml_utf16_of_utf8: caml_utf16_of_utf8,
     caml_utf8_of_utf16: caml_utf8_of_utf16,
     caml_subarray_to_jsbytes: caml_subarray_to_jsbytes,
     caml_str_repeat: caml_str_repeat,
     caml_md5_bytes: caml_md5_bytes,
     caml_MD5Final: caml_MD5Final,
     caml_MD5Update: caml_MD5Update,
     caml_MD5Init: caml_MD5Init,
     caml_MD5Transform: caml_MD5Transform,
     caml_md5_string: caml_md5_string,
     caml_md5_chan: caml_md5_chan,
     caml_output_value_to_buffer: caml_output_value_to_buffer,
     caml_output_value_to_bytes: caml_output_value_to_bytes,
     caml_output_value_to_string: caml_output_value_to_string,
     caml_output_val: caml_output_val,
     MlObjectTable: MlObjectTable,
     caml_marshal_data_size: caml_marshal_data_size,
     caml_marshal_header_size: caml_marshal_header_size,
     caml_input_value_from_reader: caml_input_value_from_reader,
     caml_custom_ops: caml_custom_ops,
     caml_nativeint_unmarshal: caml_nativeint_unmarshal,
     caml_int32_unmarshal: caml_int32_unmarshal,
     caml_int64_marshal: caml_int64_marshal,
     caml_int64_unmarshal: caml_int64_unmarshal,
     caml_input_value_from_bytes: caml_input_value_from_bytes,
     caml_input_value_from_string: caml_input_value_from_string,
     caml_float_of_bytes: caml_float_of_bytes,
     BigStringReader: BigStringReader,
     MlStringReader: MlStringReader,
     UInt8ArrayReader: UInt8ArrayReader,
     caml_marshal_constants: caml_marshal_constants,
     caml_new_lex_engine: caml_new_lex_engine,
     caml_lex_engine: caml_lex_engine,
     caml_lex_array: caml_lex_array,
     caml_js_error_of_exception: caml_js_error_of_exception,
     caml_xmlhttprequest_create: caml_xmlhttprequest_create,
     caml_js_get_console: caml_js_get_console,
     caml_js_html_entities: caml_js_html_entities,
     caml_js_html_escape: caml_js_html_escape,
     caml_js_on_ie: caml_js_on_ie,
     caml_js_object: caml_js_object,
     caml_pure_js_expr: caml_pure_js_expr,
     caml_js_expr: caml_js_expr,
     caml_js_eval_string: caml_js_eval_string,
     caml_js_equals: caml_js_equals,
     caml_js_function_arity: caml_js_function_arity,
     caml_js_wrap_meth_callback_unsafe: caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict: caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:
     caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback: caml_js_wrap_meth_callback,
     caml_js_wrap_callback_unsafe: caml_js_wrap_callback_unsafe,
     caml_js_wrap_callback_strict: caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments: caml_js_wrap_callback_arguments,
     caml_js_wrap_callback: caml_js_wrap_callback,
     caml_ojs_new_arr: caml_ojs_new_arr,
     caml_js_new: caml_js_new,
     caml_js_meth_call: caml_js_meth_call,
     caml_js_fun_call: caml_js_fun_call,
     caml_js_call: caml_js_call,
     caml_js_var: caml_js_var,
     caml_list_to_js_array: caml_list_to_js_array,
     caml_list_of_js_array: caml_list_of_js_array,
     caml_js_to_array: caml_js_to_array,
     caml_js_from_array: caml_js_from_array,
     caml_js_to_float: caml_js_to_float,
     caml_js_from_float: caml_js_from_float,
     caml_js_to_bool: caml_js_to_bool,
     caml_js_from_bool: caml_js_from_bool,
     caml_js_error_option_of_exception: caml_js_error_option_of_exception,
     caml_exn_with_js_backtrace: caml_exn_with_js_backtrace,
     caml_maybe_attach_backtrace: caml_maybe_attach_backtrace,
     caml_wrap_exception: caml_wrap_exception,
     caml_jsoo_flags_effects: caml_jsoo_flags_effects,
     caml_jsoo_flags_use_js_string: caml_jsoo_flags_use_js_string,
     caml_is_js: caml_is_js,
     caml_callback: caml_callback,
     caml_trampoline_return: caml_trampoline_return,
     caml_trampoline: caml_trampoline,
     caml_js_typeof: caml_js_typeof,
     caml_js_instanceof: caml_js_instanceof,
     caml_js_delete: caml_js_delete,
     caml_js_get: caml_js_get,
     caml_js_set: caml_js_set,
     caml_js_pure_expr: caml_js_pure_expr,
     caml_ml_set_buffered: caml_ml_set_buffered,
     caml_ml_is_buffered: caml_ml_is_buffered,
     caml_ml_output_int: caml_ml_output_int,
     caml_ml_pos_out_64: caml_ml_pos_out_64,
     caml_ml_pos_out: caml_ml_pos_out,
     caml_pos_out: caml_pos_out,
     caml_ml_seek_out_64: caml_ml_seek_out_64,
     caml_ml_seek_out: caml_ml_seek_out,
     caml_seek_out: caml_seek_out,
     caml_output_value: caml_output_value,
     caml_ml_output_char: caml_ml_output_char,
     caml_ml_output: caml_ml_output,
     caml_ml_output_bytes: caml_ml_output_bytes,
     caml_ml_flush: caml_ml_flush,
     caml_ml_input_scan_line: caml_ml_input_scan_line,
     caml_ml_pos_in_64: caml_ml_pos_in_64,
     caml_ml_pos_in: caml_ml_pos_in,
     caml_pos_in: caml_pos_in,
     caml_ml_seek_in_64: caml_ml_seek_in_64,
     caml_ml_seek_in: caml_ml_seek_in,
     caml_seek_in: caml_seek_in,
     caml_ml_input_int: caml_ml_input_int,
     caml_ml_input_char: caml_ml_input_char,
     caml_input_value_to_outside_heap: caml_input_value_to_outside_heap,
     caml_input_value: caml_input_value,
     caml_ml_input_block: caml_ml_input_block,
     caml_ml_input: caml_ml_input,
     caml_refill: caml_refill,
     caml_ml_set_channel_refill: caml_ml_set_channel_refill,
     caml_ml_set_channel_output: caml_ml_set_channel_output,
     caml_ml_channel_size_64: caml_ml_channel_size_64,
     caml_ml_channel_size: caml_ml_channel_size,
     caml_ml_close_channel: caml_ml_close_channel,
     caml_ml_set_binary_mode: caml_ml_set_binary_mode,
     caml_channel_descriptor: caml_channel_descriptor,
     caml_ml_open_descriptor_in: caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out: caml_ml_open_descriptor_out,
     caml_ml_out_channels_list: caml_ml_out_channels_list,
     caml_ml_channels: caml_ml_channels,
     caml_ml_set_channel_name: caml_ml_set_channel_name,
     caml_sys_open: caml_sys_open,
     caml_sys_close: caml_sys_close,
     caml_sys_fds: caml_sys_fds,
     caml_int64_bswap: caml_int64_bswap,
     caml_int32_bswap: caml_int32_bswap,
     caml_bswap16: caml_bswap16,
     caml_mod: caml_mod,
     caml_div: caml_div,
     caml_mul: caml_mul,
     caml_int_of_string: caml_int_of_string,
     caml_parse_digit: caml_parse_digit,
     caml_parse_sign_and_base: caml_parse_sign_and_base,
     caml_format_int: caml_format_int,
     caml_int64_hash: caml_int64_hash,
     caml_int64_to_bytes: caml_int64_to_bytes,
     caml_int64_of_bytes: caml_int64_of_bytes,
     caml_int64_hi32: caml_int64_hi32,
     caml_int64_lo32: caml_int64_lo32,
     caml_int64_create_lo_hi: caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi: caml_int64_create_lo_mi_hi,
     caml_int64_of_string: caml_int64_of_string,
     caml_int64_format: caml_int64_format,
     caml_int64_of_float: caml_int64_of_float,
     caml_int64_to_float: caml_int64_to_float,
     caml_int64_to_int32: caml_int64_to_int32,
     caml_int64_of_int32: caml_int64_of_int32,
     caml_int64_mod: caml_int64_mod,
     caml_int64_div: caml_int64_div,
     caml_int64_shift_right: caml_int64_shift_right,
     caml_int64_shift_right_unsigned: caml_int64_shift_right_unsigned,
     caml_int64_shift_left: caml_int64_shift_left,
     caml_int64_xor: caml_int64_xor,
     caml_int64_or: caml_int64_or,
     caml_int64_and: caml_int64_and,
     caml_int64_is_negative: caml_int64_is_negative,
     caml_int64_is_zero: caml_int64_is_zero,
     caml_int64_mul: caml_int64_mul,
     caml_int64_sub: caml_int64_sub,
     caml_int64_add: caml_int64_add,
     caml_int64_neg: caml_int64_neg,
     caml_int64_compare: caml_int64_compare,
     caml_int64_ult: caml_int64_ult,
     MlInt64: MlInt64,
     caml_int64_offset: caml_int64_offset,
     caml_float_of_string: caml_float_of_string,
     caml_format_float: caml_format_float,
     caml_fma_float: caml_fma_float,
     caml_erfc_float: caml_erfc_float,
     caml_erf_float: caml_erf_float,
     caml_cbrt_float: caml_cbrt_float,
     caml_round_float: caml_round_float,
     caml_atanh_float: caml_atanh_float,
     caml_tanh_float: caml_tanh_float,
     caml_asinh_float: caml_asinh_float,
     caml_sinh_float: caml_sinh_float,
     caml_acosh_float: caml_acosh_float,
     caml_cosh_float: caml_cosh_float,
     caml_log10_float: caml_log10_float,
     caml_hypot_float: caml_hypot_float,
     caml_log2_float: caml_log2_float,
     caml_log1p_float: caml_log1p_float,
     caml_exp2_float: caml_exp2_float,
     caml_expm1_float: caml_expm1_float,
     caml_signbit_float: caml_signbit_float,
     caml_copysign_float: caml_copysign_float,
     caml_float_compare: caml_float_compare,
     caml_frexp_float: caml_frexp_float,
     caml_ldexp_float: caml_ldexp_float,
     caml_modf_float: caml_modf_float,
     caml_classify_float: caml_classify_float,
     caml_int32_float_of_bits: caml_int32_float_of_bits,
     caml_trunc_float: caml_trunc_float,
     caml_nextafter_float: caml_nextafter_float,
     caml_int64_float_of_bits: caml_int64_float_of_bits,
     caml_hexstring_of_float: caml_hexstring_of_float,
     caml_int32_bits_of_float: caml_int32_bits_of_float,
     caml_int64_bits_of_float: caml_int64_bits_of_float,
     jsoo_floor_log2: jsoo_floor_log2,
     caml_string_hash: caml_string_hash,
     caml_hash: caml_hash,
     caml_hash_mix_string: caml_hash_mix_string,
     caml_hash_mix_bytes: caml_hash_mix_bytes,
     caml_hash_mix_bytes_arr: caml_hash_mix_bytes_arr,
     caml_hash_mix_jsbytes: caml_hash_mix_jsbytes,
     caml_hash_mix_int64: caml_hash_mix_int64,
     caml_hash_mix_float: caml_hash_mix_float,
     caml_hash_mix_final: caml_hash_mix_final,
     caml_hash_mix_int: caml_hash_mix_int,
     caml_gr_close_subwindow: caml_gr_close_subwindow,
     caml_gr_open_subwindow: caml_gr_open_subwindow,
     caml_gr_window_id: caml_gr_window_id,
     caml_gr_display_mode: caml_gr_display_mode,
     caml_gr_remember_mode: caml_gr_remember_mode,
     caml_gr_synchronize: caml_gr_synchronize,
     caml_gr_wait_event: caml_gr_wait_event,
     caml_gr_sigio_signal: caml_gr_sigio_signal,
     caml_gr_sigio_handler: caml_gr_sigio_handler,
     caml_gr_blit_image: caml_gr_blit_image,
     caml_gr_create_image: caml_gr_create_image,
     caml_gr_draw_image: caml_gr_draw_image,
     caml_gr_dump_image: caml_gr_dump_image,
     caml_gr_make_image: caml_gr_make_image,
     caml_gr_text_size: caml_gr_text_size,
     caml_gr_set_text_size: caml_gr_set_text_size,
     caml_gr_set_font: caml_gr_set_font,
     caml_gr_draw_string: caml_gr_draw_string,
     caml_gr_draw_char: caml_gr_draw_char,
     caml_gr_draw_str: caml_gr_draw_str,
     caml_gr_fill_arc: caml_gr_fill_arc,
     caml_gr_fill_poly: caml_gr_fill_poly,
     caml_gr_fill_rect: caml_gr_fill_rect,
     caml_gr_set_line_width: caml_gr_set_line_width,
     caml_gr_draw_arc: caml_gr_draw_arc,
     caml_gr_arc_aux: caml_gr_arc_aux,
     caml_gr_draw_rect: caml_gr_draw_rect,
     caml_gr_lineto: caml_gr_lineto,
     caml_gr_current_y: caml_gr_current_y,
     caml_gr_current_x: caml_gr_current_x,
     caml_gr_moveto: caml_gr_moveto,
     caml_gr_point_color: caml_gr_point_color,
     caml_gr_plot: caml_gr_plot,
     caml_gr_set_color: caml_gr_set_color,
     caml_gr_size_y: caml_gr_size_y,
     caml_gr_size_x: caml_gr_size_x,
     caml_gr_clear_graph: caml_gr_clear_graph,
     caml_gr_resize_window: caml_gr_resize_window,
     caml_gr_set_window_title: caml_gr_set_window_title,
     caml_gr_close_graph: caml_gr_close_graph,
     caml_gr_doc_of_state: caml_gr_doc_of_state,
     caml_gr_state_create: caml_gr_state_create,
     caml_gr_state_init: caml_gr_state_init,
     caml_gr_open_graph: caml_gr_open_graph,
     caml_gr_state_set: caml_gr_state_set,
     caml_gr_state_get: caml_gr_state_get,
     caml_gr_state: caml_gr_state,
     caml_get_major_credit: caml_get_major_credit,
     caml_get_major_bucket: caml_get_major_bucket,
     caml_get_minor_free: caml_get_minor_free,
     caml_gc_minor_words: caml_gc_minor_words,
     caml_gc_major_slice: caml_gc_major_slice,
     caml_gc_huge_fallback_count: caml_gc_huge_fallback_count,
     caml_eventlog_pause: caml_eventlog_pause,
     caml_eventlog_resume: caml_eventlog_resume,
     caml_memprof_stop: caml_memprof_stop,
     caml_memprof_start: caml_memprof_start,
     caml_final_release: caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register: caml_final_register,
     caml_memprof_set: caml_memprof_set,
     caml_gc_get: caml_gc_get,
     caml_gc_set: caml_gc_set,
     caml_gc_stat: caml_gc_stat,
     caml_gc_quick_stat: caml_gc_quick_stat,
     caml_gc_counters: caml_gc_counters,
     caml_gc_compaction: caml_gc_compaction,
     caml_gc_full_major: caml_gc_full_major,
     caml_gc_major: caml_gc_major,
     caml_gc_minor: caml_gc_minor,
     caml_sys_open_for_node: caml_sys_open_for_node,
     MlNodeFd: MlNodeFd,
     MlNodeDevice: MlNodeDevice,
     fs_node_supported: fs_node_supported,
     MlFakeFd: MlFakeFd,
     MlFakeFd_out: MlFakeFd_out,
     MlFakeFile: MlFakeFile,
     MlFakeDevice: MlFakeDevice,
     caml_read_file_content: caml_read_file_content,
     jsoo_create_file: jsoo_create_file,
     caml_create_file: caml_create_file,
     caml_fs_init: caml_fs_init,
     jsoo_create_file_extern: jsoo_create_file_extern,
     caml_ba_map_file_bytecode: caml_ba_map_file_bytecode,
     caml_ba_map_file: caml_ba_map_file,
     caml_sys_rmdir: caml_sys_rmdir,
     caml_sys_mkdir: caml_sys_mkdir,
     caml_sys_rename: caml_sys_rename,
     caml_sys_is_directory: caml_sys_is_directory,
     caml_sys_remove: caml_sys_remove,
     caml_sys_read_directory: caml_sys_read_directory,
     caml_sys_file_exists: caml_sys_file_exists,
     caml_raise_not_a_dir: caml_raise_not_a_dir,
     caml_raise_no_such_file: caml_raise_no_such_file,
     caml_sys_chdir: caml_sys_chdir,
     caml_sys_getcwd: caml_sys_getcwd,
     caml_unmount: caml_unmount,
     caml_mount_autoload: caml_mount_autoload,
     resolve_fs_device: resolve_fs_device,
     caml_list_mount_point: caml_list_mount_point,
     jsoo_mount_point: jsoo_mount_point,
     caml_make_path: caml_make_path,
     path_is_absolute: path_is_absolute,
     MlFile: MlFile,
     caml_root: caml_root,
     caml_get_root: caml_get_root,
     caml_current_dir: caml_current_dir,
     caml_trailing_slash: caml_trailing_slash,
     caml_finish_formatting: caml_finish_formatting,
     caml_parse_format: caml_parse_format,
     caml_array_bound_error: caml_array_bound_error,
     caml_raise_not_found: caml_raise_not_found,
     caml_raise_zero_divide: caml_raise_zero_divide,
     caml_raise_end_of_file: caml_raise_end_of_file,
     caml_invalid_argument: caml_invalid_argument,
     caml_failwith: caml_failwith,
     caml_raise_with_string: caml_raise_with_string,
     caml_raise_with_args: caml_raise_with_args,
     caml_raise_with_arg: caml_raise_with_arg,
     caml_raise_constant: caml_raise_constant,
     caml_lessthan: caml_lessthan,
     caml_lessequal: caml_lessequal,
     caml_greaterthan: caml_greaterthan,
     caml_greaterequal: caml_greaterequal,
     caml_notequal: caml_notequal,
     caml_equal: caml_equal,
     caml_int_compare: caml_int_compare,
     caml_compare: caml_compare,
     caml_compare_val: caml_compare_val,
     caml_compare_val_number_custom: caml_compare_val_number_custom,
     caml_compare_val_get_custom: caml_compare_val_get_custom,
     caml_compare_val_tag: caml_compare_val_tag,
     caml_bigstring_blit_ba_to_bytes: caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_bytes_to_ba: caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_string_to_ba: caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba: caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp: caml_bigstring_memcmp,
     bigstring_of_typed_array: bigstring_of_typed_array,
     bigstring_of_array_buffer: bigstring_of_array_buffer,
     bigstring_to_typed_array: bigstring_to_typed_array,
     bigstring_to_array_buffer: bigstring_to_array_buffer,
     caml_hash_mix_bigstring: caml_hash_mix_bigstring,
     caml_ba_from_typed_array: caml_ba_from_typed_array,
     caml_ba_kind_of_typed_array: caml_ba_kind_of_typed_array,
     caml_ba_to_typed_array: caml_ba_to_typed_array,
     caml_ba_hash: caml_ba_hash,
     caml_ba_create_from: caml_ba_create_from,
     caml_ba_deserialize: caml_ba_deserialize,
     caml_ba_serialize: caml_ba_serialize,
     caml_ba_reshape: caml_ba_reshape,
     caml_ba_slice: caml_ba_slice,
     caml_ba_sub: caml_ba_sub,
     caml_ba_blit: caml_ba_blit,
     caml_ba_fill: caml_ba_fill,
     caml_ba_set_3: caml_ba_set_3,
     caml_ba_set_2: caml_ba_set_2,
     caml_ba_set_1: caml_ba_set_1,
     caml_ba_uint8_set64: caml_ba_uint8_set64,
     caml_ba_uint8_set32: caml_ba_uint8_set32,
     caml_ba_uint8_set16: caml_ba_uint8_set16,
     caml_ba_set_generic: caml_ba_set_generic,
     caml_ba_get_3: caml_ba_get_3,
     caml_ba_get_2: caml_ba_get_2,
     caml_ba_get_1: caml_ba_get_1,
     caml_ba_uint8_get64: caml_ba_uint8_get64,
     caml_ba_uint8_get32: caml_ba_uint8_get32,
     caml_ba_uint8_get16: caml_ba_uint8_get16,
     caml_ba_get_generic: caml_ba_get_generic,
     caml_ba_dim_3: caml_ba_dim_3,
     caml_ba_dim_2: caml_ba_dim_2,
     caml_ba_dim_1: caml_ba_dim_1,
     caml_ba_dim: caml_ba_dim,
     caml_ba_num_dims: caml_ba_num_dims,
     caml_ba_layout: caml_ba_layout,
     caml_ba_kind: caml_ba_kind,
     caml_ba_change_layout: caml_ba_change_layout,
     caml_ba_create: caml_ba_create,
     caml_ba_create_unsafe: caml_ba_create_unsafe,
     caml_ba_compare: caml_ba_compare,
     Ml_Bigarray_c_1_1: Ml_Bigarray_c_1_1,
     Ml_Bigarray: Ml_Bigarray,
     caml_ba_custom_name: caml_ba_custom_name,
     caml_ba_create_buffer: caml_ba_create_buffer,
     caml_ba_get_size_per_element: caml_ba_get_size_per_element,
     caml_ba_get_size: caml_ba_get_size,
     caml_ba_init: caml_ba_init,
     caml_convert_raw_backtrace_slot: caml_convert_raw_backtrace_slot,
     caml_get_current_callstack: caml_get_current_callstack,
     caml_restore_raw_backtrace: caml_restore_raw_backtrace,
     caml_raw_backtrace_slot: caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot: caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length: caml_raw_backtrace_length,
     caml_convert_raw_backtrace: caml_convert_raw_backtrace,
     caml_record_backtrace: caml_record_backtrace,
     caml_get_exception_raw_backtrace: caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace: caml_get_exception_backtrace,
     caml_backtrace_status: caml_backtrace_status,
     caml_ml_debug_info_status: caml_ml_debug_info_status,
     caml_record_backtrace_flag: caml_record_backtrace_flag,
     caml_floatarray_create: caml_floatarray_create,
     caml_make_float_vect: caml_make_float_vect,
     caml_make_vect: caml_make_vect,
     caml_check_bound: caml_check_bound,
     caml_array_fill: caml_array_fill,
     caml_array_get: caml_array_get,
     caml_array_set: caml_array_set,
     caml_floatarray_blit: caml_floatarray_blit,
     caml_array_blit: caml_array_blit,
     caml_array_concat: caml_array_concat,
     caml_array_append: caml_array_append,
     caml_array_sub: caml_array_sub};
   var
    cst_Assert_failure = "Assert_failure",
    cst_Division_by_zero = "Division_by_zero",
    cst_End_of_file = "End_of_file",
    cst_Failure = "Failure",
    cst_Invalid_argument = "Invalid_argument",
    cst_Match_failure = "Match_failure",
    cst_Not_found = "Not_found",
    cst_Out_of_memory = "Out_of_memory",
    cst_Stack_overflow = "Stack_overflow",
    cst_Sys_blocked_io = "Sys_blocked_io",
    cst_Sys_error = "Sys_error",
    cst_Undefined_recursive_module = "Undefined_recursive_module";
   caml_fs_init();
   caml_register_global(0, [248, cst_Out_of_memory, -1], cst_Out_of_memory);
   caml_register_global(1, [248, cst_Sys_error, -2], cst_Sys_error);
   caml_register_global(2, [248, cst_Failure, -3], cst_Failure);
   caml_register_global
    (3, [248, cst_Invalid_argument, -4], cst_Invalid_argument);
   caml_register_global(4, [248, cst_End_of_file, -5], cst_End_of_file);
   caml_register_global
    (5, [248, cst_Division_by_zero, -6], cst_Division_by_zero);
   caml_register_global(6, [248, cst_Not_found, -7], cst_Not_found);
   caml_register_global(7, [248, cst_Match_failure, -8], cst_Match_failure);
   caml_register_global(8, [248, cst_Stack_overflow, -9], cst_Stack_overflow);
   caml_register_global(9, [248, cst_Sys_blocked_io, -10], cst_Sys_blocked_io);
   caml_register_global
    (10, [248, cst_Assert_failure, -11], cst_Assert_failure);
   caml_register_global
    (11,
     [248, cst_Undefined_recursive_module, -12],
     cst_Undefined_recursive_module);
   return;
  }
  (globalThis));


(function(a){"use strict";var
b3="Dune__exe__Kb",aB=118,b2="Js_of_ocaml__EventSource",aA="Js_of_ocaml__File",az="Stdlib__Fun",b1="Stdlib__Seq",ay="Stdlib__Weak",b0="Js_of_ocaml__Url",ax="Alg__Module",bZ="Alg__Globular",aw=132,bY="Stdlib__BytesLabels",av="Stdlib__ArrayLabels",bX=115,au="Stdlib__Buffer",at="Js_of_ocaml__ResizeObserver",bW="Alg__Group",as="Stdlib__Out_channel",bU="Stdlib__Printf",bV=105,bR=102,bS="CamlinternalLazy",bT="Js_of_ocaml__Dom_svg",bQ="Stdlib__String",bP="Stdlib__Result",aq="Stdlib__Either",ar=129,ap="Alg__Alphabet",bO="Js_of_ocaml__Import",ao="Stdlib__Sys",bN="Stdlib__Random",bL=116,bM="Alg__Category",an="Alg__Automaton",bK=126,bI="Failure",bJ="Stdlib__Oo",am="Alg__Series",bH=121,bG="CamlinternalOO",bF="Stdlib__Array",al="Js_of_ocaml__Dom",bE=111,ak="Alg__Simplicial",ai="Alg",aj="Not_found",ah="Js_of_ocaml__PerformanceObserver",bD="Stdlib__Lazy",bB="Stdlib__Map",bC="Stdlib__Char",ag="Stdlib__Digest",af="Stdlib__Callback",bA="Stdlib__Ephemeron",ae="Js_of_ocaml__Form",ad="Alg__Hypergraph",bz="Stdlib__In_channel",ac=134,by="Stdlib",aa=131,ab="Stdlib__Printexc",bx=125,$="Js_of_ocaml__CSS",bw="Js_of_ocaml__Geolocation",Y="Js_of_ocaml__Typed_array",Z="Js_of_ocaml__Lib_version",_="Dune__exe__ParserRefs",bu="Stdlib__Bytes",bv=103,br="Stdlib__Unit",bs="Stdlib__Option",bt="Js_of_ocaml__IntersectionObserver",X="Out_of_memory",W="Js_of_ocaml__Intl",V="Js_of_ocaml__Sys_js",bn="Stdlib__Float",bo="Stdlib__Complex",bp="Stdlib__StdLabels",bq="Dune__exe__Parser",T="Stdlib__Semaphore",U="Stdlib__Filename",bm="Js_of_ocaml__WebGL",R="Stdlib__Marshal",S="Js_of_ocaml__MutationObserver",bl="Assert_failure",Q="Js_of_ocaml__Regexp",P="Stdlib__Set",O="Js_of_ocaml__Dom_events",N="Sys_blocked_io",bk="Js_of_ocaml__Worker",M=110,bh="Stdlib__MoreLabels",bi="Std_exit",bj=123,bg="Dune__exe",K="Stdlib__Queue",L="Alg__Utils",I="Stdlib__Parsing",J="Alg__Extlib",bf="Stdlib__Obj",H=112,be="Js_of_ocaml__Json",G="Js_of_ocaml",bc="Jsoo_runtime__",bd="CamlinternalMod",bb=133,F="Stdlib__Condition",ba="Js_of_ocaml__Js",E="Alg__Ring",a$="Dune__exe__Lexer",a9="Stdlib__Bigarray",a_=104,a8=128,a6="Invalid_argument",a7=122,a4=106,a5=113,C="Stdlib__Format",D="Match_failure",a2=119,a3="Stdlib__Scanf",a1="Js_of_ocaml__Dom_html",a0="Js_of_ocaml__",A="Jsoo_runtime",B="Alg__Algebra",aX="Stdlib__Bool",aY=101,aZ="Division_by_zero",y="Stdlib__Effect",z="Alg__Matrix",x="Alg__Graph",w="Js_of_ocaml__Firebug",aW="Stdlib__Domain",v="Alg__Precategory",u=120,aT="Stdlib__Mutex",aU=117,aV=130,t="Stdlib__Arg",aR=127,aS=107,aO="Stdlib__StringLabels",aP=114,aQ="CamlinternalFormatBasics",aN="Js_of_ocaml__XmlHttpRequest",r=135,s="Jsoo_runtime__Runtime_version",q="Alg__Field",aM="Stdlib__Uchar",p="Stdlib__List",o="Stdlib__Atomic",n=100,m="Stdlib__Int64",aK=109,aL=124,aJ="Sys_error",aH="Stdlib__Lexing",aI="CamlinternalFormat",k="Stdlib__Gc",l="Alg__Monoid",aG="Stdlib__Int",i="Stdlib__ListLabels",j="Stdlib__Hashtbl",aF="Js_of_ocaml__Jstable",h="Stdlib__Int32",aE="End_of_file",g="Alg__Term",f="Stdlib__Stack",aD="Stack_overflow",aC="Stdlib__Nativeint",d=108,e="Js_of_ocaml__WebSockets",c="Undefined_recursive_module",b4=a.jsoo_runtime,b=b4.caml_get_global_data();b.prim_count=845;var
b5=[2,B],b6=[2,an],b7=[2,x],b8=[0,0,[2,bZ],94,0,1],b9=[0,0,[2,ax],86,0,1],b_=[2,z],b$=[0,0,[2,ad],92,0,1],ca=[2,v],cb=[2,am],cc=[0,0,[2,b3],ac,0,1],cd=[2,bg],ce=[2,bq],cf=[0,0,[2,bT],bj,[0,0,[2,b2],aL,0,1],2],cg=[2,a1],ch=[0,0,[2,O],a7,0,1],ci=[0,0,[2,bw],bK,0,1],cj=[2,ae],ck=[0,0,[2,w],bx,0,1],cl=[0,0,[2,W],a8,0,1],cm=[2,bt],cn=[2,aF],co=[0,0,[2,be],u,0,1],cp=[2,S],cq=[2,at],cr=[2,bm],cs=[0,0,[2,b0],a5,0,1],ct=[2,s],cu=[2,aj],cv=[0,0,[2,bi],r,0,1],cw=[2,aD],cx=[2,bY],cy=[2,ag],cz=[2,y],cA=[2,U],cB=[2,bz],cC=[2,bJ],cD=[2,as],cE=[2,ab],cF=[2,a3],cG=[2,bp];b.toc=[0,[0,"SYMB",[0,136,[0,[0,[0,[0,[0,[0,[0,0,[2,ai],77,[0,0,b5,87,0,1],2],[2,ap],79,[0,[0,0,b6,96,0,1],[2,bM],95,0,2],3],[2,J],80,[0,[0,0,[2,q],82,[0,b8,b7,93,0,2],3],[2,bW],84,[0,[0,b$,b_,85,b9,2],[2,l],83,[0,0,ca,91,0,1],3],4],5],[2,E],81,[0,[0,[0,[0,0,cb,90,0,1],[2,ak],89,0,2],[2,g],88,[0,0,[2,L],78,0,1],3],[2,bl],0,[0,[0,0,[2,aI],48,0,1],[2,aQ],12,0,2],4],6],[2,bS],18,[0,[0,[0,[0,0,[2,bd],64,0,1],[2,bG],62,0,2],[2,aZ],1,[0,[0,[0,0,cd,aV,cc,2],[2,a$],bb,[0,0,ce,aw,0,1],3],[2,_],aa,[0,0,[2,aE],2,0,1],4],5],[2,bI],3,[0,[0,0,[2,a6],4,[0,0,[2,G],ar,0,1],2],[2,a0],n,[0,0,[2,$],bH,0,1],3],6],7],[2,al],bv,[0,[0,[0,[0,[0,[0,ch,cg,a4,cf,3],[2,aA],bV,[0,ck,cj,aS,ci,2],4],[2,bO],aY,[0,[0,0,cm,aR,cl,2],[2,ba],bR,[0,co,cn,a2,0,2],3],5],[2,Z],aP,[0,[0,[0,0,cp,aB,0,1],[2,ah],aU,0,2],[2,Q],H,[0,[0,0,cq,bL,0,1],[2,V],bX,0,2],3],6],[2,Y],a_,[0,[0,[0,[0,cs,cr,bE,0,2],[2,e],M,0,3],[2,bk],aK,[0,0,[2,aN],d,0,1],4],[2,A],99,[0,[0,0,[2,bc],97,[0,0,ct,98,0,1],2],[2,D],5,[0,[0,0,cu,6,0,1],[2,X],7,[0,0,cw,8,cv,2],3],4],5],7],[2,by],13,[0,[0,[0,[0,0,[2,t],50,0,1],[2,bF],32,[0,0,[2,av],68,0,1],2],[2,o],17,[0,0,[2,a9],55,0,1],3],[2,aX],23,[0,[0,[0,0,[2,au],43,0,1],[2,bu],28,[0,[0,0,cx,70,0,1],[2,af],61,0,2],3],[2,bC],24,[0,[0,0,[2,bo],67,0,1],[2,F],45,[0,[0,0,cy,54,0,1],[2,aW],47,[0,0,cz,76,0,1],2],3],4],5],8],9],[2,aq],14,[0,[0,[0,[0,[0,[0,0,[2,bA],65,[0,0,cA,66,0,1],2],[2,bn],33,[0,0,[2,C],59,0,1],3],[2,az],52,[0,0,[2,k],53,[0,0,[2,j],57,[0,0,cB,74,0,1],2],3],4],[2,aG],27,[0,0,[2,h],34,[0,0,[2,m],35,0,1],2],5],[2,bD],19,[0,[0,[0,0,[2,aH],37,0,1],[2,p],26,[0,[0,0,[2,i],69,0,1],[2,bB],40,0,2],3],[2,R],31,[0,[0,[0,0,[2,bh],72,0,1],[2,aT],44,0,2],[2,aC],36,0,3],4],6],[2,bf],16,[0,[0,[0,[0,[0,[0,0,cC,63,0,1],[2,bs],21,[0,0,cD,75,0,1],2],[2,I],38,[0,[0,0,cE,51,0,1],[2,bU],49,0,2],3],[2,K],42,[0,[0,0,[2,bN],56,0,1],[2,bP],22,[0,[0,0,cF,60,0,1],[2,T],46,0,2],3],4],[2,b1],20,[0,[0,0,[2,P],39,[0,0,[2,f],41,[0,0,cG,73,0,1],2],3],[2,bQ],29,[0,0,[2,aO],71,0,1],4],5],[2,ao],15,[0,[0,0,[2,aM],25,[0,0,[2,br],30,[0,0,[2,ay],58,0,1],2],3],[2,N],9,[0,0,[2,aJ],10,[0,0,[2,c],11,0,1],2],4],6],7],10]]],[0,[0,"SYJS",[0,[0,c,11],[0,aJ,10],[0,N,9],[0,ay,58],[0,br,30],[0,aM,25],[0,ao,15],[0,aO,71],[0,bQ,29],[0,bp,73],[0,f,41],[0,P,39],[0,b1,20],[0,T,46],[0,a3,60],[0,bP,22],[0,bN,56],[0,K,42],[0,bU,49],[0,ab,51],[0,I,38],[0,as,75],[0,bs,21],[0,bJ,63],[0,bf,16],[0,aC,36],[0,aT,44],[0,bh,72],[0,R,31],[0,bB,40],[0,i,69],[0,p,26],[0,aH,37],[0,bD,19],[0,m,35],[0,h,34],[0,aG,27],[0,bz,74],[0,j,57],[0,k,53],[0,az,52],[0,C,59],[0,bn,33],[0,U,66],[0,bA,65],[0,aq,14],[0,y,76],[0,aW,47],[0,ag,54],[0,F,45],[0,bo,67],[0,bC,24],[0,af,61],[0,bY,70],[0,bu,28],[0,au,43],[0,aX,23],[0,a9,55],[0,o,17],[0,av,68],[0,bF,32],[0,t,50],[0,by,13],[0,bi,r],[0,aD,8],[0,X,7],[0,aj,6],[0,D,5],[0,s,98],[0,bc,97],[0,A,99],[0,aN,d],[0,bk,aK],[0,e,M],[0,bm,bE],[0,b0,a5],[0,Y,a_],[0,V,bX],[0,at,bL],[0,Q,H],[0,ah,aU],[0,S,aB],[0,Z,aP],[0,aF,a2],[0,be,u],[0,ba,bR],[0,W,a8],[0,bt,aR],[0,bO,aY],[0,bw,bK],[0,ae,aS],[0,w,bx],[0,aA,bV],[0,b2,aL],[0,bT,bj],[0,a1,a4],[0,O,a7],[0,al,bv],[0,$,bH],[0,a0,n],[0,G,ar],[0,a6,4],[0,bI,3],[0,aE,2],[0,_,aa],[0,bq,aw],[0,a$,bb],[0,b3,ac],[0,bg,aV],[0,aZ,1],[0,bG,62],[0,bd,64],[0,bS,18],[0,aQ,12],[0,aI,48],[0,bl,0],[0,L,78],[0,g,88],[0,ak,89],[0,am,90],[0,E,81],[0,v,91],[0,l,83],[0,ax,86],[0,z,85],[0,ad,92],[0,bW,84],[0,x,93],[0,bZ,94],[0,q,82],[0,J,80],[0,bM,95],[0,an,96],[0,ap,79],[0,B,87],[0,ai,77]]],[0,[0,"CRCS",0],[0,[0,"PRIM","%caml_format_int_special\0%direct_int_div\0%direct_int_mod\0%direct_int_mul\0%identity\0%int_add\0%int_and\0%int_asr\0%int_div\0%int_lsl\0%int_lsr\0%int_mod\0%int_mul\0%int_neg\0%int_or\0%int_sub\0%int_xor\0BigStringReader\0MlBytes\0MlFakeDevice\0MlFakeFd\0MlFakeFd_out\0MlFakeFile\0MlFile\0MlInt64\0MlMutex\0MlNat\0MlNodeDevice\0MlNodeFd\0MlObjectTable\0MlStringReader\0Ml_Bigarray\0Ml_Bigarray_c_1_1\0UInt8ArrayReader\0add_nat\0bigstring_of_array_buffer\0bigstring_of_typed_array\0bigstring_to_array_buffer\0bigstring_to_typed_array\0blit_nat\0caml_MD5Final\0caml_MD5Init\0caml_MD5Transform\0caml_MD5Update\0caml_abs_float\0caml_acos_float\0caml_acosh_float\0caml_add_float\0caml_alloc_dummy\0caml_alloc_dummy_float\0caml_alloc_dummy_infix\0caml_alloc_stack\0caml_argv\0caml_array_append\0caml_array_blit\0caml_array_bound_error\0caml_array_concat\0caml_array_fill\0caml_array_get\0caml_array_get_addr\0caml_array_get_float\0caml_array_of_bytes\0caml_array_of_string\0caml_array_set\0caml_array_set_addr\0caml_array_set_float\0caml_array_sub\0caml_array_unsafe_get\0caml_array_unsafe_get_float\0caml_array_unsafe_set\0caml_array_unsafe_set_float\0caml_asin_float\0caml_asinh_float\0caml_atan2_float\0caml_atan_float\0caml_atanh_float\0caml_atomic_cas\0caml_atomic_exchange\0caml_atomic_fetch_add\0caml_atomic_load\0caml_ba_blit\0caml_ba_change_layout\0caml_ba_compare\0caml_ba_create\0caml_ba_create_buffer\0caml_ba_create_from\0caml_ba_create_unsafe\0caml_ba_custom_name\0caml_ba_deserialize\0caml_ba_dim\0caml_ba_dim_1\0caml_ba_dim_2\0caml_ba_dim_3\0caml_ba_fill\0caml_ba_from_typed_array\0caml_ba_get_1\0caml_ba_get_2\0caml_ba_get_3\0caml_ba_get_generic\0caml_ba_get_size\0caml_ba_get_size_per_element\0caml_ba_hash\0caml_ba_init\0caml_ba_kind\0caml_ba_kind_of_typed_array\0caml_ba_layout\0caml_ba_map_file\0caml_ba_map_file_bytecode\0caml_ba_num_dims\0caml_ba_reshape\0caml_ba_serialize\0caml_ba_set_1\0caml_ba_set_2\0caml_ba_set_3\0caml_ba_set_generic\0caml_ba_slice\0caml_ba_sub\0caml_ba_to_typed_array\0caml_ba_uint8_get16\0caml_ba_uint8_get32\0caml_ba_uint8_get64\0caml_ba_uint8_set16\0caml_ba_uint8_set32\0caml_ba_uint8_set64\0caml_backtrace_status\0caml_bigstring_blit_ba_to_ba\0caml_bigstring_blit_ba_to_bytes\0caml_bigstring_blit_bytes_to_ba\0caml_bigstring_blit_string_to_ba\0caml_bigstring_memcmp\0caml_blit_bytes\0caml_blit_string\0caml_bswap16\0caml_build_symbols\0caml_bytes_bound_error\0caml_bytes_compare\0caml_bytes_equal\0caml_bytes_get\0caml_bytes_get16\0caml_bytes_get32\0caml_bytes_get64\0caml_bytes_greaterequal\0caml_bytes_greaterthan\0caml_bytes_lessequal\0caml_bytes_lessthan\0caml_bytes_notequal\0caml_bytes_of_array\0caml_bytes_of_jsbytes\0caml_bytes_of_string\0caml_bytes_of_utf16_jsstring\0caml_bytes_set\0caml_bytes_set16\0caml_bytes_set32\0caml_bytes_set64\0caml_bytes_unsafe_get\0caml_bytes_unsafe_set\0caml_call_gen\0caml_callback\0caml_cbrt_float\0caml_ceil_float\0caml_channel_descriptor\0caml_check_bound\0caml_classify_float\0caml_compare\0caml_compare_val\0caml_compare_val_get_custom\0caml_compare_val_number_custom\0caml_compare_val_tag\0caml_continuation_use_and_update_handler_noexc\0caml_continuation_use_noexc\0caml_convert_bytes_to_array\0caml_convert_raw_backtrace\0caml_convert_raw_backtrace_slot\0caml_convert_string_to_bytes\0caml_copysign_float\0caml_cos_float\0caml_cosh_float\0caml_create_bytes\0caml_create_file\0caml_create_string\0caml_current_dir\0caml_custom_event_index\0caml_custom_ops\0caml_div\0caml_div_float\0caml_domain_dls\0caml_domain_dls_get\0caml_domain_dls_set\0caml_domain_id\0caml_domain_spawn\0caml_ensure_stack_capacity\0caml_ephe_blit_data\0caml_ephe_blit_key\0caml_ephe_check_data\0caml_ephe_check_key\0caml_ephe_create\0caml_ephe_data_offset\0caml_ephe_get_data\0caml_ephe_get_data_copy\0caml_ephe_get_key\0caml_ephe_get_key_copy\0caml_ephe_key_offset\0caml_ephe_set_data\0caml_ephe_set_key\0caml_ephe_unset_data\0caml_ephe_unset_key\0caml_eq_float\0caml_equal\0caml_erf_float\0caml_erfc_float\0caml_eventlog_pause\0caml_eventlog_resume\0caml_executable_name\0caml_exn_with_js_backtrace\0caml_exp2_float\0caml_exp_float\0caml_expm1_float\0caml_failwith\0caml_fatal_uncaught_exception\0caml_fill_bytes\0caml_fill_string\0caml_final_register\0caml_final_register_called_without_value\0caml_final_release\0caml_finish_formatting\0caml_float_compare\0caml_float_of_bytes\0caml_float_of_int\0caml_float_of_string\0caml_floatarray_blit\0caml_floatarray_create\0caml_floatarray_get\0caml_floatarray_set\0caml_floatarray_unsafe_get\0caml_floatarray_unsafe_set\0caml_floor_float\0caml_fma_float\0caml_fmod_float\0caml_format_exception\0caml_format_float\0caml_format_int\0caml_fresh_oo_id\0caml_frexp_float\0caml_fs_init\0caml_gc_compaction\0caml_gc_counters\0caml_gc_full_major\0caml_gc_get\0caml_gc_huge_fallback_count\0caml_gc_major\0caml_gc_major_slice\0caml_gc_minor\0caml_gc_minor_words\0caml_gc_quick_stat\0caml_gc_set\0caml_gc_stat\0caml_ge_float\0caml_get_continuation_callstack\0caml_get_current_callstack\0caml_get_exception_backtrace\0caml_get_exception_raw_backtrace\0caml_get_global_data\0caml_get_major_bucket\0caml_get_major_credit\0caml_get_minor_free\0caml_get_public_method\0caml_get_root\0caml_global_data\0caml_gr_arc_aux\0caml_gr_blit_image\0caml_gr_clear_graph\0caml_gr_close_graph\0caml_gr_close_subwindow\0caml_gr_create_image\0caml_gr_current_x\0caml_gr_current_y\0caml_gr_display_mode\0caml_gr_doc_of_state\0caml_gr_draw_arc\0caml_gr_draw_char\0caml_gr_draw_image\0caml_gr_draw_rect\0caml_gr_draw_str\0caml_gr_draw_string\0caml_gr_dump_image\0caml_gr_fill_arc\0caml_gr_fill_poly\0caml_gr_fill_rect\0caml_gr_lineto\0caml_gr_make_image\0caml_gr_moveto\0caml_gr_open_graph\0caml_gr_open_subwindow\0caml_gr_plot\0caml_gr_point_color\0caml_gr_remember_mode\0caml_gr_resize_window\0caml_gr_set_color\0caml_gr_set_font\0caml_gr_set_line_width\0caml_gr_set_text_size\0caml_gr_set_window_title\0caml_gr_sigio_handler\0caml_gr_sigio_signal\0caml_gr_size_x\0caml_gr_size_y\0caml_gr_state\0caml_gr_state_create\0caml_gr_state_get\0caml_gr_state_init\0caml_gr_state_set\0caml_gr_synchronize\0caml_gr_text_size\0caml_gr_wait_event\0caml_gr_window_id\0caml_greaterequal\0caml_greaterthan\0caml_gt_float\0caml_hash\0caml_hash_mix_bigstring\0caml_hash_mix_bytes\0caml_hash_mix_bytes_arr\0caml_hash_mix_final\0caml_hash_mix_float\0caml_hash_mix_int\0caml_hash_mix_int64\0caml_hash_mix_jsbytes\0caml_hash_mix_string\0caml_hash_nat\0caml_hexstring_of_float\0caml_hypot_float\0caml_input_value\0caml_input_value_from_bytes\0caml_input_value_from_reader\0caml_input_value_from_string\0caml_input_value_to_outside_heap\0caml_install_signal_handler\0caml_int32_add\0caml_int32_and\0caml_int32_bits_of_float\0caml_int32_bswap\0caml_int32_compare\0caml_int32_div\0caml_int32_float_of_bits\0caml_int32_format\0caml_int32_mod\0caml_int32_mul\0caml_int32_neg\0caml_int32_of_float\0caml_int32_of_int\0caml_int32_of_string\0caml_int32_or\0caml_int32_shift_left\0caml_int32_shift_right\0caml_int32_shift_right_unsigned\0caml_int32_sub\0caml_int32_to_float\0caml_int32_to_int\0caml_int32_unmarshal\0caml_int32_xor\0caml_int64_add\0caml_int64_and\0caml_int64_bits_of_float\0caml_int64_bswap\0caml_int64_compare\0caml_int64_create_lo_hi\0caml_int64_create_lo_mi_hi\0caml_int64_div\0caml_int64_float_of_bits\0caml_int64_format\0caml_int64_hash\0caml_int64_hi32\0caml_int64_is_negative\0caml_int64_is_zero\0caml_int64_lo32\0caml_int64_marshal\0caml_int64_mod\0caml_int64_mul\0caml_int64_neg\0caml_int64_of_bytes\0caml_int64_of_float\0caml_int64_of_int\0caml_int64_of_int32\0caml_int64_of_nativeint\0caml_int64_of_string\0caml_int64_offset\0caml_int64_or\0caml_int64_shift_left\0caml_int64_shift_right\0caml_int64_shift_right_unsigned\0caml_int64_sub\0caml_int64_to_bytes\0caml_int64_to_float\0caml_int64_to_int\0caml_int64_to_int32\0caml_int64_to_nativeint\0caml_int64_ult\0caml_int64_unmarshal\0caml_int64_xor\0caml_int_compare\0caml_int_of_float\0caml_int_of_string\0caml_invalid_argument\0caml_is_continuation_tag\0caml_is_js\0caml_is_ml_bytes\0caml_is_ml_string\0caml_is_printable\0caml_is_special_exception\0caml_js_call\0caml_js_delete\0caml_js_equals\0caml_js_error_of_exception\0caml_js_error_option_of_exception\0caml_js_eval_string\0caml_js_expr\0caml_js_from_array\0caml_js_from_bool\0caml_js_from_float\0caml_js_from_string\0caml_js_fun_call\0caml_js_function_arity\0caml_js_get\0caml_js_get_console\0caml_js_html_entities\0caml_js_html_escape\0caml_js_instanceof\0caml_js_meth_call\0caml_js_new\0caml_js_object\0caml_js_on_ie\0caml_js_pure_expr\0caml_js_set\0caml_js_to_array\0caml_js_to_bool\0caml_js_to_byte_string\0caml_js_to_float\0caml_js_to_string\0caml_js_typeof\0caml_js_var\0caml_js_wrap_callback\0caml_js_wrap_callback_arguments\0caml_js_wrap_callback_strict\0caml_js_wrap_callback_unsafe\0caml_js_wrap_meth_callback\0caml_js_wrap_meth_callback_arguments\0caml_js_wrap_meth_callback_strict\0caml_js_wrap_meth_callback_unsafe\0caml_jsbytes_of_string\0caml_jsoo_flags_effects\0caml_jsoo_flags_use_js_string\0caml_jsstring_of_string\0caml_lazy_make_forward\0caml_lazy_read_result\0caml_lazy_reset_to_lazy\0caml_lazy_update_to_forcing\0caml_lazy_update_to_forward\0caml_ldexp_float\0caml_le_float\0caml_lessequal\0caml_lessthan\0caml_lex_array\0caml_lex_engine\0caml_list_mount_point\0caml_list_of_js_array\0caml_list_to_js_array\0caml_log10_float\0caml_log1p_float\0caml_log2_float\0caml_log_float\0caml_lt_float\0caml_lxm_next\0caml_make_array\0caml_make_float_vect\0caml_make_path\0caml_make_vect\0caml_marshal_constants\0caml_marshal_data_size\0caml_marshal_header_size\0caml_maybe_attach_backtrace\0caml_maybe_print_stats\0caml_md5_bytes\0caml_md5_chan\0caml_md5_string\0caml_memprof_set\0caml_memprof_start\0caml_memprof_stop\0caml_ml_bytes_content\0caml_ml_bytes_length\0caml_ml_channel_size\0caml_ml_channel_size_64\0caml_ml_channels\0caml_ml_close_channel\0caml_ml_condition_broadcast\0caml_ml_condition_new\0caml_ml_condition_signal\0caml_ml_condition_wait\0caml_ml_debug_info_status\0caml_ml_domain_cpu_relax\0caml_ml_domain_id\0caml_ml_domain_set_name\0caml_ml_domain_unique_token\0caml_ml_enable_runtime_warnings\0caml_ml_flush\0caml_ml_input\0caml_ml_input_block\0caml_ml_input_char\0caml_ml_input_int\0caml_ml_input_scan_line\0caml_ml_is_buffered\0caml_ml_mutex_lock\0caml_ml_mutex_new\0caml_ml_mutex_try_lock\0caml_ml_mutex_unlock\0caml_ml_open_descriptor_in\0caml_ml_open_descriptor_out\0caml_ml_out_channels_list\0caml_ml_output\0caml_ml_output_bytes\0caml_ml_output_char\0caml_ml_output_int\0caml_ml_pos_in\0caml_ml_pos_in_64\0caml_ml_pos_out\0caml_ml_pos_out_64\0caml_ml_runtime_warnings_enabled\0caml_ml_seek_in\0caml_ml_seek_in_64\0caml_ml_seek_out\0caml_ml_seek_out_64\0caml_ml_set_binary_mode\0caml_ml_set_buffered\0caml_ml_set_channel_name\0caml_ml_set_channel_output\0caml_ml_set_channel_refill\0caml_ml_string_length\0caml_mod\0caml_modf_float\0caml_mount_autoload\0caml_mul\0caml_mul_float\0caml_named_value\0caml_named_values\0caml_nativeint_add\0caml_nativeint_and\0caml_nativeint_bswap\0caml_nativeint_compare\0caml_nativeint_div\0caml_nativeint_format\0caml_nativeint_mod\0caml_nativeint_mul\0caml_nativeint_neg\0caml_nativeint_of_float\0caml_nativeint_of_int\0caml_nativeint_of_int32\0caml_nativeint_of_string\0caml_nativeint_or\0caml_nativeint_shift_left\0caml_nativeint_shift_right\0caml_nativeint_shift_right_unsigned\0caml_nativeint_sub\0caml_nativeint_to_float\0caml_nativeint_to_int\0caml_nativeint_to_int32\0caml_nativeint_unmarshal\0caml_nativeint_xor\0caml_neg_float\0caml_neq_float\0caml_new_lex_engine\0caml_new_string\0caml_nextafter_float\0caml_notequal\0caml_obj_add_offset\0caml_obj_block\0caml_obj_compare_and_swap\0caml_obj_dup\0caml_obj_is_block\0caml_obj_is_shared\0caml_obj_make_forward\0caml_obj_raw_field\0caml_obj_reachable_words\0caml_obj_set_raw_field\0caml_obj_set_tag\0caml_obj_tag\0caml_obj_truncate\0caml_obj_update_tag\0caml_obj_with_tag\0caml_ojs_new_arr\0caml_oo_last_id\0caml_output_val\0caml_output_value\0caml_output_value_to_buffer\0caml_output_value_to_bytes\0caml_output_value_to_string\0caml_parse_digit\0caml_parse_engine\0caml_parse_format\0caml_parse_sign_and_base\0caml_parser_trace\0caml_pos_in\0caml_pos_out\0caml_power_float\0caml_pure_js_expr\0caml_raise_constant\0caml_raise_end_of_file\0caml_raise_no_such_file\0caml_raise_not_a_dir\0caml_raise_not_found\0caml_raise_sys_error\0caml_raise_with_arg\0caml_raise_with_args\0caml_raise_with_string\0caml_raise_zero_divide\0caml_raw_backtrace_length\0caml_raw_backtrace_next_slot\0caml_raw_backtrace_slot\0caml_read_file_content\0caml_recommended_domain_count\0caml_record_backtrace\0caml_record_backtrace_flag\0caml_refill\0caml_register_channel_for_spacetime\0caml_register_global\0caml_register_named_value\0caml_restore_raw_backtrace\0caml_root\0caml_round_float\0caml_runtime_events_create_cursor\0caml_runtime_events_free_cursor\0caml_runtime_events_pause\0caml_runtime_events_read_poll\0caml_runtime_events_resume\0caml_runtime_events_start\0caml_runtime_events_user_register\0caml_runtime_events_user_resolve\0caml_runtime_events_user_write\0caml_runtime_parameters\0caml_runtime_variant\0caml_runtime_warnings\0caml_seek_in\0caml_seek_out\0caml_set_oo_id\0caml_set_parser_trace\0caml_set_static_env\0caml_signbit_float\0caml_sin_float\0caml_sinh_float\0caml_spacetime_enabled\0caml_spacetime_only_works_for_native_code\0caml_sqrt_float\0caml_str_initialize\0caml_str_repeat\0caml_string_bound_error\0caml_string_compare\0caml_string_equal\0caml_string_get\0caml_string_get16\0caml_string_get32\0caml_string_get64\0caml_string_greaterequal\0caml_string_greaterthan\0caml_string_hash\0caml_string_lessequal\0caml_string_lessthan\0caml_string_notequal\0caml_string_of_array\0caml_string_of_bytes\0caml_string_of_jsbytes\0caml_string_of_jsstring\0caml_string_set\0caml_string_set16\0caml_string_set32\0caml_string_set64\0caml_string_unsafe_get\0caml_string_unsafe_set\0caml_sub_float\0caml_subarray_to_jsbytes\0caml_sys_argv\0caml_sys_chdir\0caml_sys_close\0caml_sys_const_backend_type\0caml_sys_const_big_endian\0caml_sys_const_int_size\0caml_sys_const_max_wosize\0caml_sys_const_naked_pointers_checked\0caml_sys_const_ostype_cygwin\0caml_sys_const_ostype_unix\0caml_sys_const_ostype_win32\0caml_sys_const_word_size\0caml_sys_executable_name\0caml_sys_exit\0caml_sys_fds\0caml_sys_file_exists\0caml_sys_get_argv\0caml_sys_get_config\0caml_sys_getcwd\0caml_sys_getenv\0caml_sys_is_directory\0caml_sys_is_regular_file\0caml_sys_isatty\0caml_sys_mkdir\0caml_sys_modify_argv\0caml_sys_open\0caml_sys_open_for_node\0caml_sys_random_seed\0caml_sys_read_directory\0caml_sys_remove\0caml_sys_rename\0caml_sys_rmdir\0caml_sys_system_command\0caml_sys_time\0caml_sys_time_include_children\0caml_sys_unsafe_getenv\0caml_tan_float\0caml_tanh_float\0caml_to_js_string\0caml_trailing_slash\0caml_trampoline\0caml_trampoline_return\0caml_trunc_float\0caml_uint8_array_of_bytes\0caml_uint8_array_of_string\0caml_unix_cleanup\0caml_unix_closedir\0caml_unix_filedescr_of_fd\0caml_unix_findclose\0caml_unix_findfirst\0caml_unix_findnext\0caml_unix_getpwuid\0caml_unix_gettimeofday\0caml_unix_getuid\0caml_unix_gmtime\0caml_unix_has_symlink\0caml_unix_inet_addr_of_string\0caml_unix_isatty\0caml_unix_localtime\0caml_unix_lstat\0caml_unix_lstat_64\0caml_unix_mkdir\0caml_unix_mktime\0caml_unix_opendir\0caml_unix_readdir\0caml_unix_readlink\0caml_unix_rewinddir\0caml_unix_rmdir\0caml_unix_startup\0caml_unix_stat\0caml_unix_stat_64\0caml_unix_symlink\0caml_unix_time\0caml_unix_unlink\0caml_unmount\0caml_update_dummy\0caml_utf16_of_utf8\0caml_utf8_of_utf16\0caml_weak_blit\0caml_weak_check\0caml_weak_create\0caml_weak_get\0caml_weak_get_copy\0caml_weak_set\0caml_wrap_exception\0caml_xmlhttprequest_create\0compare_digits_nat\0compare_nat\0compare_nat_real\0complement_nat\0create_nat\0decr_nat\0deserialize_nat\0div_digit_nat\0div_helper\0div_nat\0fs_node_supported\0incr_nat\0initialize_nat\0is_digit_int\0is_digit_odd\0is_digit_zero\0jsoo_create_file\0jsoo_create_file_extern\0jsoo_effect_not_supported\0jsoo_floor_log2\0jsoo_is_ascii\0jsoo_mount_point\0jsoo_sys_getenv\0land_digit_nat\0lor_digit_nat\0lxor_digit_nat\0make_unix_err_args\0mult_digit_nat\0mult_nat\0nat_of_array\0nth_digit_nat\0nth_digit_nat_native\0num_digits_nat\0num_leading_zero_bits_in_digit\0os_type\0path_is_absolute\0re_match\0re_partial_match\0re_replacement_text\0re_search_backward\0re_search_forward\0re_string_match\0resolve_fs_device\0serialize_nat\0set_digit_nat\0set_digit_nat_native\0set_to_zero_nat\0shift_left_nat\0shift_right_nat\0square_nat\0sub_nat\0unix_closedir\0unix_getpwuid\0unix_gettimeofday\0unix_getuid\0unix_gmtime\0unix_has_symlink\0unix_inet_addr_of_string\0unix_isatty\0unix_localtime\0unix_lstat\0unix_lstat_64\0unix_mkdir\0unix_mktime\0unix_opendir\0unix_readdir\0unix_readlink\0unix_rewinddir\0unix_rmdir\0unix_stat\0unix_stat_64\0unix_symlink\0unix_time\0unix_unlink\0win_cleanup\0win_filedescr_of_channel\0win_findclose\0win_findfirst\0win_findnext\0win_handle_fd\0win_startup\0zstd_decompress\0"],0]]]];return}(globalThis));
//# 1 "../../.js/default/stdlib/stdlib.cma.js"
// Generated by js_of_ocaml
//# 3 "../../.js/default/stdlib/stdlib.cma.js"

//# 5 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function erase_rel(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, erase_rel(rest)];
      case 1:
       var rest$0 = param[1]; return [1, erase_rel(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, erase_rel(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, erase_rel(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, erase_rel(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, erase_rel(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, erase_rel(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, erase_rel(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1];
       return [8, ty, erase_rel(rest$7)];
      case 9:
       var rest$8 = param[3], ty1 = param[1];
       return [9, ty1, ty1, erase_rel(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, erase_rel(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, erase_rel(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, erase_rel(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, erase_rel(rest$12)];
      default: var rest$13 = param[1]; return [14, erase_rel(rest$13)];
    }
   }
   function concat_fmtty(fmtty1, fmtty2){
    if(typeof fmtty1 === "number") return fmtty2;
    switch(fmtty1[0]){
      case 0:
       var rest = fmtty1[1]; return [0, concat_fmtty(rest, fmtty2)];
      case 1:
       var rest$0 = fmtty1[1]; return [1, concat_fmtty(rest$0, fmtty2)];
      case 2:
       var rest$1 = fmtty1[1]; return [2, concat_fmtty(rest$1, fmtty2)];
      case 3:
       var rest$2 = fmtty1[1]; return [3, concat_fmtty(rest$2, fmtty2)];
      case 4:
       var rest$3 = fmtty1[1]; return [4, concat_fmtty(rest$3, fmtty2)];
      case 5:
       var rest$4 = fmtty1[1]; return [5, concat_fmtty(rest$4, fmtty2)];
      case 6:
       var rest$5 = fmtty1[1]; return [6, concat_fmtty(rest$5, fmtty2)];
      case 7:
       var rest$6 = fmtty1[1]; return [7, concat_fmtty(rest$6, fmtty2)];
      case 8:
       var rest$7 = fmtty1[2], ty = fmtty1[1];
       return [8, ty, concat_fmtty(rest$7, fmtty2)];
      case 9:
       var rest$8 = fmtty1[3], ty2 = fmtty1[2], ty1 = fmtty1[1];
       return [9, ty1, ty2, concat_fmtty(rest$8, fmtty2)];
      case 10:
       var rest$9 = fmtty1[1]; return [10, concat_fmtty(rest$9, fmtty2)];
      case 11:
       var rest$10 = fmtty1[1]; return [11, concat_fmtty(rest$10, fmtty2)];
      case 12:
       var rest$11 = fmtty1[1]; return [12, concat_fmtty(rest$11, fmtty2)];
      case 13:
       var rest$12 = fmtty1[1]; return [13, concat_fmtty(rest$12, fmtty2)];
      default:
       var rest$13 = fmtty1[1]; return [14, concat_fmtty(rest$13, fmtty2)];
    }
   }
   function concat_fmt(fmt1, fmt2){
    if(typeof fmt1 === "number") return fmt2;
    switch(fmt1[0]){
      case 0:
       var rest = fmt1[1]; return [0, concat_fmt(rest, fmt2)];
      case 1:
       var rest$0 = fmt1[1]; return [1, concat_fmt(rest$0, fmt2)];
      case 2:
       var rest$1 = fmt1[2], pad = fmt1[1];
       return [2, pad, concat_fmt(rest$1, fmt2)];
      case 3:
       var rest$2 = fmt1[2], pad$0 = fmt1[1];
       return [3, pad$0, concat_fmt(rest$2, fmt2)];
      case 4:
       var rest$3 = fmt1[4], prec = fmt1[3], pad$1 = fmt1[2], iconv = fmt1[1];
       return [4, iconv, pad$1, prec, concat_fmt(rest$3, fmt2)];
      case 5:
       var
        rest$4 = fmt1[4],
        prec$0 = fmt1[3],
        pad$2 = fmt1[2],
        iconv$0 = fmt1[1];
       return [5, iconv$0, pad$2, prec$0, concat_fmt(rest$4, fmt2)];
      case 6:
       var
        rest$5 = fmt1[4],
        prec$1 = fmt1[3],
        pad$3 = fmt1[2],
        iconv$1 = fmt1[1];
       return [6, iconv$1, pad$3, prec$1, concat_fmt(rest$5, fmt2)];
      case 7:
       var
        rest$6 = fmt1[4],
        prec$2 = fmt1[3],
        pad$4 = fmt1[2],
        iconv$2 = fmt1[1];
       return [7, iconv$2, pad$4, prec$2, concat_fmt(rest$6, fmt2)];
      case 8:
       var
        rest$7 = fmt1[4],
        prec$3 = fmt1[3],
        pad$5 = fmt1[2],
        fconv = fmt1[1];
       return [8, fconv, pad$5, prec$3, concat_fmt(rest$7, fmt2)];
      case 9:
       var rest$8 = fmt1[2], pad$6 = fmt1[1];
       return [9, pad$6, concat_fmt(rest$8, fmt2)];
      case 10:
       var rest$9 = fmt1[1]; return [10, concat_fmt(rest$9, fmt2)];
      case 11:
       var rest$10 = fmt1[2], str = fmt1[1];
       return [11, str, concat_fmt(rest$10, fmt2)];
      case 12:
       var rest$11 = fmt1[2], chr = fmt1[1];
       return [12, chr, concat_fmt(rest$11, fmt2)];
      case 13:
       var rest$12 = fmt1[3], fmtty = fmt1[2], pad$7 = fmt1[1];
       return [13, pad$7, fmtty, concat_fmt(rest$12, fmt2)];
      case 14:
       var rest$13 = fmt1[3], fmtty$0 = fmt1[2], pad$8 = fmt1[1];
       return [14, pad$8, fmtty$0, concat_fmt(rest$13, fmt2)];
      case 15:
       var rest$14 = fmt1[1]; return [15, concat_fmt(rest$14, fmt2)];
      case 16:
       var rest$15 = fmt1[1]; return [16, concat_fmt(rest$15, fmt2)];
      case 17:
       var rest$16 = fmt1[2], fmting_lit = fmt1[1];
       return [17, fmting_lit, concat_fmt(rest$16, fmt2)];
      case 18:
       var rest$17 = fmt1[2], fmting_gen = fmt1[1];
       return [18, fmting_gen, concat_fmt(rest$17, fmt2)];
      case 19:
       var rest$18 = fmt1[1]; return [19, concat_fmt(rest$18, fmt2)];
      case 20:
       var rest$19 = fmt1[3], char_set = fmt1[2], width_opt = fmt1[1];
       return [20, width_opt, char_set, concat_fmt(rest$19, fmt2)];
      case 21:
       var rest$20 = fmt1[2], counter = fmt1[1];
       return [21, counter, concat_fmt(rest$20, fmt2)];
      case 22:
       var rest$21 = fmt1[1]; return [22, concat_fmt(rest$21, fmt2)];
      case 23:
       var rest$22 = fmt1[2], ign = fmt1[1];
       return [23, ign, concat_fmt(rest$22, fmt2)];
      default:
       var rest$23 = fmt1[3], f = fmt1[2], arity = fmt1[1];
       return [24, arity, f, concat_fmt(rest$23, fmt2)];
    }
   }
   var CamlinternalFormatBasics = [0, concat_fmtty, erase_rel, concat_fmt];
   runtime.caml_register_global
    (0, CamlinternalFormatBasics, "CamlinternalFormatBasics");
   return;
  }
  (globalThis));

//# 180 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_false$0 = "false",
    cst_true$0 = "true",
    caml_atomic_cas = runtime.caml_atomic_cas,
    caml_atomic_load = runtime.caml_atomic_load,
    caml_blit_string = runtime.caml_blit_string,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_channel_size = runtime.caml_ml_channel_size,
    caml_ml_channel_size_64 = runtime.caml_ml_channel_size_64,
    caml_ml_close_channel = runtime.caml_ml_close_channel,
    caml_ml_flush = runtime.caml_ml_flush,
    caml_ml_input = runtime.caml_ml_input,
    caml_ml_input_char = runtime.caml_ml_input_char,
    caml_ml_open_descriptor_in = runtime.caml_ml_open_descriptor_in,
    caml_ml_open_descriptor_out = runtime.caml_ml_open_descriptor_out,
    caml_ml_output = runtime.caml_ml_output,
    caml_ml_output_bytes = runtime.caml_ml_output_bytes,
    caml_ml_output_char = runtime.caml_ml_output_char,
    caml_ml_set_binary_mode = runtime.caml_ml_set_binary_mode,
    caml_ml_set_channel_name = runtime.caml_ml_set_channel_name,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_sys_open = runtime.caml_sys_open,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = "%,",
    cst = ".",
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Invalid_argument = global_data.Invalid_argument,
    Failure = global_data.Failure,
    Match_failure = global_data.Match_failure,
    Assert_failure = global_data.Assert_failure,
    Not_found = global_data.Not_found,
    Out_of_memory = global_data.Out_of_memory,
    Stack_overflow = global_data.Stack_overflow,
    Sys_error = global_data.Sys_error,
    End_of_file = global_data.End_of_file,
    Division_by_zero = global_data.Division_by_zero,
    Sys_blocked_io = global_data.Sys_blocked_io,
    Undefined_recursive_module = global_data.Undefined_recursive_module,
    cst_really_input = "really_input",
    cst_input = "input",
    _l_ = [0, 0, [0, 6, 0]],
    _k_ = [0, 0, [0, 7, 0]],
    cst_output_substring = "output_substring",
    cst_output = "output",
    _j_ = [0, 1, [0, 3, [0, 4, [0, 6, 0]]]],
    _i_ = [0, 1, [0, 3, [0, 4, [0, 7, 0]]]],
    _g_ = [0, 1],
    _h_ = [0, 0],
    cst_bool_of_string = "bool_of_string",
    cst_true = cst_true$0,
    cst_false = cst_false$0,
    cst_char_of_int = "char_of_int",
    cst_Stdlib_Exit = "Stdlib.Exit",
    _a_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 32752),
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 65520),
    _c_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 32752),
    _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32751),
    _e_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 16),
    _f_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 15536);
   function failwith(s){
    throw caml_maybe_attach_backtrace([0, Failure, s], 1);
   }
   function invalid_arg(s){
    throw caml_maybe_attach_backtrace([0, Invalid_argument, s], 1);
   }
   var Exit = [248, cst_Stdlib_Exit, runtime.caml_fresh_oo_id(0)];
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return runtime.caml_greaterequal(x, y) ? x : y;}
   function abs(x){return 0 <= x ? x : - x | 0;}
   function lnot(x){return x ^ -1;}
   var
    infinity = caml_int64_float_of_bits(_a_),
    neg_infinity = caml_int64_float_of_bits(_b_),
    nan = caml_int64_float_of_bits(_c_),
    max_float = caml_int64_float_of_bits(_d_),
    min_float = caml_int64_float_of_bits(_e_),
    epsilon_float = caml_int64_float_of_bits(_f_),
    max_int = 2147483647,
    min_int = -2147483648;
   function symbol(s1, s2){
    var
     l1 = caml_ml_string_length(s1),
     l2 = caml_ml_string_length(s2),
     s = caml_create_bytes(l1 + l2 | 0);
    caml_blit_string(s1, 0, s, 0, l1);
    caml_blit_string(s2, 0, s, l1, l2);
    return caml_string_of_bytes(s);
   }
   function char_of_int(n){
    if(0 <= n && 255 >= n) return n;
    return invalid_arg(cst_char_of_int);
   }
   function string_of_bool(b){return b ? cst_true : cst_false;}
   function bool_of_string(param){
    return caml_string_notequal(param, cst_false$0)
            ? caml_string_notequal
               (param, cst_true$0)
              ? invalid_arg(cst_bool_of_string)
              : 1
            : 0;
   }
   function bool_of_string_opt(param){
    return caml_string_notequal(param, cst_false$0)
            ? caml_string_notequal(param, cst_true$0) ? 0 : _g_
            : _h_;
   }
   function string_of_int(n){return "" + n;}
   function int_of_string_opt(s){
    try{var _B_ = [0, caml_int_of_string(s)]; return _B_;}
    catch(_C_){
     var _A_ = caml_wrap_exception(_C_);
     if(_A_[1] === Failure) return 0;
     throw caml_maybe_attach_backtrace(_A_, 0);
    }
   }
   function valid_float_lexem(s){
    var l = caml_ml_string_length(s), i = 0;
    for(;;){
     if(l <= i) return symbol(s, cst);
     var match = runtime.caml_string_get(s, i), switch$0 = 0;
     if(48 <= match){
      if(58 > match) switch$0 = 1;
     }
     else if(45 === match) switch$0 = 1;
     if(! switch$0) return s;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function string_of_float(f){
    return valid_float_lexem(runtime.caml_format_float("%.12g", f));
   }
   function float_of_string_opt(s){
    try{var _y_ = [0, caml_float_of_string(s)]; return _y_;}
    catch(_z_){
     var _x_ = caml_wrap_exception(_z_);
     if(_x_[1] === Failure) return 0;
     throw caml_maybe_attach_backtrace(_x_, 0);
    }
   }
   function symbol$0(l1, l2){
    if(! l1) return l2;
    var tl = l1[2], hd = l1[1];
    return [0, hd, symbol$0(tl, l2)];
   }
   var
    stdin = caml_ml_open_descriptor_in(0),
    stdout = caml_ml_open_descriptor_out(1),
    stderr = caml_ml_open_descriptor_out(2);
   function open_out_gen(mode, perm, name){
    var c = caml_ml_open_descriptor_out(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c;
   }
   function open_out(name){return open_out_gen(_i_, 438, name);}
   function open_out_bin(name){return open_out_gen(_j_, 438, name);}
   function flush_all(param){
    var param$0 = runtime.caml_ml_out_channels_list(0);
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1];
     try{caml_ml_flush(a);}
     catch(_w_){
      var _v_ = caml_wrap_exception(_w_);
      if(_v_[1] !== Sys_error) throw caml_maybe_attach_backtrace(_v_, 0);
     }
     var param$0 = l;
    }
   }
   function output_bytes(oc, s){
    return caml_ml_output_bytes(oc, s, 0, caml_ml_bytes_length(s));
   }
   function output_string(oc, s){
    return caml_ml_output(oc, s, 0, caml_ml_string_length(s));
   }
   function output(oc, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_ml_output_bytes(oc, s, ofs, len);
    return invalid_arg(cst_output);
   }
   function output_substring(oc, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_string_length(s) - len | 0) >= ofs)
     return caml_ml_output(oc, s, ofs, len);
    return invalid_arg(cst_output_substring);
   }
   function output_value(chan, v){
    return runtime.caml_output_value(chan, v, 0);
   }
   function close_out(oc){
    caml_ml_flush(oc);
    return caml_ml_close_channel(oc);
   }
   function close_out_noerr(oc){
    try{caml_ml_flush(oc);}catch(_u_){}
    try{var _s_ = caml_ml_close_channel(oc); return _s_;}catch(_t_){return 0;}
   }
   function open_in_gen(mode, perm, name){
    var c = caml_ml_open_descriptor_in(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c;
   }
   function open_in(name){return open_in_gen(_k_, 0, name);}
   function open_in_bin(name){return open_in_gen(_l_, 0, name);}
   function input(ic, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_ml_input(ic, s, ofs, len);
    return invalid_arg(cst_input);
   }
   function unsafe_really_input(ic, s, ofs, len){
    var ofs$0 = ofs, len$0 = len;
    for(;;){
     if(0 >= len$0) return 0;
     var r = caml_ml_input(ic, s, ofs$0, len$0);
     if(0 === r) throw caml_maybe_attach_backtrace(End_of_file, 1);
     var
      len$1 = len$0 - r | 0,
      ofs$1 = ofs$0 + r | 0,
      ofs$0 = ofs$1,
      len$0 = len$1;
    }
   }
   function really_input(ic, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return unsafe_really_input(ic, s, ofs, len);
    return invalid_arg(cst_really_input);
   }
   function really_input_string(ic, len){
    var s = caml_create_bytes(len);
    really_input(ic, s, 0, len);
    return caml_string_of_bytes(s);
   }
   function input_line(chan){
    function build_result(buf, pos, param){
     var pos$0 = pos, param$0 = param;
     for(;;){
      if(! param$0) return buf;
      var tl = param$0[2], hd = param$0[1], len = caml_ml_bytes_length(hd);
      runtime.caml_blit_bytes(hd, 0, buf, pos$0 - len | 0, len);
      var pos$1 = pos$0 - len | 0, pos$0 = pos$1, param$0 = tl;
     }
    }
    var accu = 0, len = 0;
    for(;;){
     var n = runtime.caml_ml_input_scan_line(chan);
     if(0 === n){
      if(! accu) throw caml_maybe_attach_backtrace(End_of_file, 1);
      var _r_ = build_result(caml_create_bytes(len), len, accu);
     }
     else{
      if(0 >= n){
       var beg = caml_create_bytes(- n | 0);
       caml_ml_input(chan, beg, 0, - n | 0);
       var
        len$1 = len - n | 0,
        accu$0 = [0, beg, accu],
        accu = accu$0,
        len = len$1;
       continue;
      }
      var res = caml_create_bytes(n - 1 | 0);
      caml_ml_input(chan, res, 0, n - 1 | 0);
      caml_ml_input_char(chan);
      if(accu)
       var
        len$0 = (len + n | 0) - 1 | 0,
        _r_ = build_result(caml_create_bytes(len$0), len$0, [0, res, accu]);
      else
       var _r_ = res;
     }
     return caml_string_of_bytes(_r_);
    }
   }
   function close_in_noerr(ic){
    try{var _p_ = caml_ml_close_channel(ic); return _p_;}catch(_q_){return 0;}
   }
   function print_char(c){return caml_ml_output_char(stdout, c);}
   function print_string(s){return output_string(stdout, s);}
   function print_bytes(s){return output_bytes(stdout, s);}
   function print_int(i){return output_string(stdout, "" + i);}
   function print_float(f){return output_string(stdout, string_of_float(f));}
   function print_endline(s){
    output_string(stdout, s);
    caml_ml_output_char(stdout, 10);
    return caml_ml_flush(stdout);
   }
   function print_newline(param){
    caml_ml_output_char(stdout, 10);
    return caml_ml_flush(stdout);
   }
   function prerr_char(c){return caml_ml_output_char(stderr, c);}
   function prerr_string(s){return output_string(stderr, s);}
   function prerr_bytes(s){return output_bytes(stderr, s);}
   function prerr_int(i){return output_string(stderr, "" + i);}
   function prerr_float(f){return output_string(stderr, string_of_float(f));}
   function prerr_endline(s){
    output_string(stderr, s);
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr);
   }
   function prerr_newline(param){
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr);
   }
   function read_line(param){caml_ml_flush(stdout); return input_line(stdin);}
   function read_int(param){return caml_int_of_string(read_line(0));}
   function read_int_opt(param){return int_of_string_opt(read_line(0));}
   function read_float(param){return caml_float_of_string(read_line(0));}
   function read_float_opt(param){return float_of_string_opt(read_line(0));}
   function string_of_format(param){var str = param[2]; return str;}
   function symbol$1(param, _n_){
    var
     str2 = _n_[2],
     fmt2 = _n_[1],
     str1 = param[2],
     fmt1 = param[1],
     _o_ = symbol(str1, symbol(cst$0, str2));
    return [0, caml_call2(CamlinternalFormatBasics[3], fmt1, fmt2), _o_];
   }
   var exit_function = [0, flush_all];
   function at_exit(f){
    for(;;){
     var
      f_yet_to_run = [0, 1],
      old_exit = caml_atomic_load(exit_function),
      new_exit$0 =
        function(f_yet_to_run, old_exit){
         function new_exit(param){
          if(caml_atomic_cas(f_yet_to_run, 1, 0)) caml_call1(f, 0);
          return caml_call1(old_exit, 0);
         }
         return new_exit;
        },
      new_exit = new_exit$0(f_yet_to_run, old_exit),
      success = caml_atomic_cas(exit_function, old_exit, new_exit),
      _m_ = 1 - success;
     if(_m_) continue;
     return _m_;
    }
   }
   var do_domain_local_at_exit = [0, function(param){return 0;}];
   function do_at_exit(param){
    caml_call1(do_domain_local_at_exit[1], 0);
    return caml_call1(caml_atomic_load(exit_function), 0);
   }
   function exit(retcode){
    do_at_exit(0);
    return runtime.caml_sys_exit(retcode);
   }
   runtime.caml_register_named_value("Pervasives.do_at_exit", do_at_exit);
   var
    Stdlib =
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       symbol,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       symbol$0,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       caml_ml_flush,
       flush_all,
       caml_ml_output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       caml_ml_output_char,
       runtime.caml_ml_output_int,
       output_value,
       runtime.caml_ml_seek_out,
       runtime.caml_ml_pos_out,
       caml_ml_channel_size,
       close_out,
       close_out_noerr,
       caml_ml_set_binary_mode,
       open_in,
       open_in_bin,
       open_in_gen,
       caml_ml_input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       caml_ml_input_char,
       runtime.caml_ml_input_int,
       runtime.caml_input_value,
       runtime.caml_ml_seek_in,
       runtime.caml_ml_pos_in,
       caml_ml_channel_size,
       caml_ml_close_channel,
       close_in_noerr,
       caml_ml_set_binary_mode,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol$1,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit];
   runtime.caml_register_global(45, Stdlib, "Stdlib");
   return;
  }
  (globalThis));

//# 764 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    ocaml_version = "5.0.0",
    ocaml_release = [0, 5, 0, 0, 0],
    Stdlib = global_data.Stdlib,
    executable_name = runtime.caml_sys_executable_name(0),
    os_type = runtime.caml_sys_get_config(0)[1],
    backend_type = [0, "js_of_ocaml"],
    unix = runtime.caml_sys_const_ostype_unix(0),
    win32 = runtime.caml_sys_const_ostype_win32(0),
    cygwin = runtime.caml_sys_const_ostype_cygwin(0),
    max_array_length = runtime.caml_sys_const_max_wosize(0),
    max_floatarray_length = max_array_length / 2 | 0,
    max_string_length = (4 * max_array_length | 0) - 1 | 0,
    cst_Stdlib_Sys_Break = "Stdlib.Sys.Break",
    big_endian = 0,
    word_size = 32,
    int_size = 32;
   function getenv_opt(s){
    try{var _d_ = [0, runtime.caml_sys_getenv(s)]; return _d_;}
    catch(_e_){
     var _c_ = caml_wrap_exception(_e_);
     if(_c_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_c_, 0);
    }
   }
   var interactive = [0, 0];
   function set_signal(sig_num, sig_beh){return 0;}
   var
    Break = [248, cst_Stdlib_Sys_Break, runtime.caml_fresh_oo_id(0)],
    sigabrt = -1,
    sigalrm = -2,
    sigfpe = -3,
    sighup = -4,
    sigill = -5,
    sigint = -6,
    sigkill = -7,
    sigpipe = -8,
    sigquit = -9,
    sigsegv = -10,
    sigterm = -11,
    sigusr1 = -12,
    sigusr2 = -13,
    sigchld = -14,
    sigcont = -15,
    sigstop = -16,
    sigtstp = -17,
    sigttin = -18,
    sigttou = -19,
    sigvtalrm = -20,
    sigprof = -21,
    sigbus = -22,
    sigpoll = -23,
    sigsys = -24,
    sigtrap = -25,
    sigurg = -26,
    sigxcpu = -27,
    sigxfsz = -28;
   function catch_break(on){return on ? 0 : 0;}
   var development_version = 0;
   function Make(_b_, _a_){return [0, 1];}
   var
    Immediate64 = [0, Make],
    Stdlib_Sys =
      [0,
       executable_name,
       getenv_opt,
       interactive,
       os_type,
       backend_type,
       unix,
       win32,
       cygwin,
       word_size,
       int_size,
       big_endian,
       max_string_length,
       max_array_length,
       max_floatarray_length,
       set_signal,
       sigabrt,
       sigalrm,
       sigfpe,
       sighup,
       sigill,
       sigint,
       sigkill,
       sigpipe,
       sigquit,
       sigsegv,
       sigterm,
       sigusr1,
       sigusr2,
       sigchld,
       sigcont,
       sigstop,
       sigtstp,
       sigttin,
       sigttou,
       sigvtalrm,
       sigprof,
       sigbus,
       sigpoll,
       sigsys,
       sigtrap,
       sigurg,
       sigxcpu,
       sigxfsz,
       Break,
       catch_break,
       ocaml_version,
       development_version,
       ocaml_release,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled,
       Immediate64];
   runtime.caml_register_global(4, Stdlib_Sys, "Stdlib__Sys");
   return;
  }
  (globalThis));

//# 893 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Obj_extension_constructor$1 = "Obj.extension_constructor",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys,
    cst_Obj_Ephemeron_blit_key = "Obj.Ephemeron.blit_key",
    cst_Obj_Ephemeron_check_key = "Obj.Ephemeron.check_key",
    cst_Obj_Ephemeron_unset_key = "Obj.Ephemeron.unset_key",
    cst_Obj_Ephemeron_set_key = "Obj.Ephemeron.set_key",
    cst_Obj_Ephemeron_get_key_copy = "Obj.Ephemeron.get_key_copy",
    cst_Obj_Ephemeron_get_key = "Obj.Ephemeron.get_key",
    cst_Obj_Ephemeron_create = "Obj.Ephemeron.create",
    cst_Obj_extension_constructor$0 = cst_Obj_extension_constructor$1,
    cst_Obj_extension_constructor = cst_Obj_extension_constructor$1,
    _a_ = [0, "obj.ml", 97, 4];
   function is_block(a){return 1 - (typeof a === "number" ? 1 : 0);}
   var
    double_field = runtime.caml_array_get,
    set_double_field = runtime.caml_array_set,
    first_non_constant_constructor = 0,
    last_non_constant_constructor_ = 243,
    forcing_tag = 244,
    cont_tag = 245,
    lazy_tag = 246,
    closure_tag = 247,
    object_tag = 248,
    infix_tag = 249,
    forward_tag = 250,
    no_scan_tag = 251,
    abstract_tag = 251,
    string_tag = 252,
    double_tag = 253,
    double_array_tag = 254,
    custom_tag = 255,
    int_tag = 1000,
    out_of_heap_tag = 1001,
    unaligned_tag = 1002;
   function info(obj){
    if(caml_obj_tag(obj) !== 247)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var
     info = runtime.caml_obj_raw_field(obj, 1),
     arity = 64 === Stdlib_Sys[9] ? info >> 56 : info >> 24,
     start_env = info << 8 >>> 9 | 0;
    return [0, arity, start_env];
   }
   function of_val(x){
    var switch$0 = 0;
    if(is_block(x) && caml_obj_tag(x) !== 248 && 1 <= x.length - 1){var slot = x[1]; switch$0 = 1;}
    if(! switch$0) var slot = x;
    var switch$1 = 0;
    if(is_block(slot) && caml_obj_tag(slot) === 248){var name = slot[1]; switch$1 = 1;}
    if(! switch$1)
     var name = caml_call1(Stdlib[1], cst_Obj_extension_constructor$0);
    return caml_obj_tag(name) === 252
            ? slot
            : caml_call1(Stdlib[1], cst_Obj_extension_constructor);
   }
   function name(slot){return slot[1];}
   function id(slot){return slot[2];}
   var
    Extension_constructor = [0, of_val, name, id],
    max_ephe_length = Stdlib_Sys[13] - 2 | 0;
   function create(l){
    var _g_ = 0 <= l ? 1 : 0, _h_ = _g_ ? l <= max_ephe_length ? 1 : 0 : _g_;
    if(1 - _h_) caml_call1(Stdlib[1], cst_Obj_Ephemeron_create);
    return runtime.caml_ephe_create(l);
   }
   function length(x){return x.length - 1 - 2 | 0;}
   function raise_if_invalid_offset(e, o, msg){
    var
     _d_ = 0 <= o ? 1 : 0,
     _e_ = _d_ ? o < length(e) ? 1 : 0 : _d_,
     _f_ = 1 - _e_;
    return _f_ ? caml_call1(Stdlib[1], msg) : _f_;
   }
   function get_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key);
    return runtime.caml_ephe_get_key(e, o);
   }
   function get_key_copy(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key_copy);
    return runtime.caml_ephe_get_key_copy(e, o);
   }
   function set_key(e, o, x){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_set_key);
    return runtime.caml_ephe_set_key(e, o, x);
   }
   function unset_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_unset_key);
    return runtime.caml_ephe_unset_key(e, o);
   }
   function check_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_check_key);
    return runtime.caml_ephe_check_key(e, o);
   }
   function blit_key(e1, o1, e2, o2, l){
    if
     (0 <= l
      &&
       0 <= o1
       && (length(e1) - l | 0) >= o1 && 0 <= o2 && (length(e2) - l | 0) >= o2){
     var
      _b_ = 0 !== l ? 1 : 0,
      _c_ = _b_ ? runtime.caml_ephe_blit_key(e1, o1, e2, o2, l) : _b_;
     return _c_;
    }
    return caml_call1(Stdlib[1], cst_Obj_Ephemeron_blit_key);
   }
   var
    Stdlib_Obj =
      [0,
       is_block,
       double_field,
       set_double_field,
       first_non_constant_constructor,
       last_non_constant_constructor_,
       forcing_tag,
       cont_tag,
       lazy_tag,
       closure_tag,
       object_tag,
       infix_tag,
       forward_tag,
       no_scan_tag,
       abstract_tag,
       string_tag,
       double_tag,
       double_array_tag,
       custom_tag,
       int_tag,
       out_of_heap_tag,
       unaligned_tag,
       [0, info],
       Extension_constructor,
       [0,
        create,
        length,
        get_key,
        get_key_copy,
        set_key,
        unset_key,
        check_key,
        blit_key,
        runtime.caml_ephe_get_data,
        runtime.caml_ephe_get_data_copy,
        runtime.caml_ephe_set_data,
        runtime.caml_ephe_unset_data,
        runtime.caml_ephe_check_data,
        runtime.caml_ephe_blit_data,
        max_ephe_length]];
   runtime.caml_register_global(13, Stdlib_Obj, "Stdlib__Obj");
   return;
  }
  (globalThis));

//# 1063 "../../.js/default/stdlib/stdlib.cma.js"
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_atomic_exchange = runtime.caml_atomic_exchange,
    caml_atomic_fetch_add = runtime.caml_atomic_fetch_add;
   function set(r, x){caml_atomic_exchange(r, x); return 0;}
   function incr(r){caml_atomic_fetch_add(r, 1); return 0;}
   function decr(r){caml_atomic_fetch_add(r, -1); return 0;}
   var
    _a_ = caml_atomic_fetch_add,
    _b_ = runtime.caml_atomic_cas,
    _c_ = caml_atomic_exchange,
    _d_ = runtime.caml_atomic_load,
    Stdlib_Atomic =
      [0,
       function(_e_){return [0, _e_];},
       _d_,
       set,
       _c_,
       _b_,
       _a_,
       incr,
       decr];
   runtime.caml_register_global(0, Stdlib_Atomic, "Stdlib__Atomic");
   return;
  }
  (globalThis));

//# 1094 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_lazy_update_to_forward = runtime.caml_lazy_update_to_forward,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Undefined =
      [248, "CamlinternalLazy.Undefined", runtime.caml_fresh_oo_id(0)];
   function force_gen_lazy_block(only_val, blk){
    if(0 !== runtime.caml_lazy_update_to_forcing(blk))
     throw caml_maybe_attach_backtrace(Undefined, 1);
    if(only_val){
     var closure$0 = blk[1];
     blk[1] = 0;
     var result$0 = caml_call1(closure$0, 0);
     blk[1] = result$0;
     caml_lazy_update_to_forward(blk);
     return result$0;
    }
    var closure = blk[1];
    blk[1] = 0;
    try{
     var result = caml_call1(closure, 0);
     blk[1] = result;
     caml_lazy_update_to_forward(blk);
     return result;
    }
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     blk[1] = function(param){throw caml_maybe_attach_backtrace(e, 0);};
     runtime.caml_lazy_reset_to_lazy(blk);
     throw caml_maybe_attach_backtrace(e, 0);
    }
   }
   function force_lazy_block(blk){return force_gen_lazy_block(0, blk);}
   function force_gen(only_val, lzv){
    var t = runtime.caml_obj_tag(lzv);
    if(t === Stdlib_Obj[12]) return lzv[1];
    if(t === Stdlib_Obj[6]) throw caml_maybe_attach_backtrace(Undefined, 1);
    return t !== Stdlib_Obj[8] ? lzv : force_gen_lazy_block(only_val, lzv);
   }
   var CamlinternalLazy = [0, Undefined, force_lazy_block, force_gen];
   runtime.caml_register_global(2, CamlinternalLazy, "CamlinternalLazy");
   return;
  }
  (globalThis));

//# 1153 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Undefined = CamlinternalLazy[1];
   function force_val(l){return caml_call2(CamlinternalLazy[3], 1, l);}
   function from_fun(f){
    var x = runtime.caml_obj_block(Stdlib_Obj[8], 1);
    x[1] = f;
    return x;
   }
   function from_val(v){
    var t = caml_obj_tag(v);
    if
     (t !== Stdlib_Obj[12]
      && t !== Stdlib_Obj[8] && t !== Stdlib_Obj[6] && t !== Stdlib_Obj[16])
     return v;
    return runtime.caml_lazy_make_forward(v);
   }
   function is_val(l){
    var _i_ = Stdlib_Obj[8];
    return caml_obj_tag(l) !== _i_ ? 1 : 0;
   }
   function map(f, x){
    return [246,
            function(_f_){
             var _g_ = caml_obj_tag(x);
             if(250 === _g_)
              var _h_ = x[1];
             else{
              var switch$0 = 0;
              if(246 !== _g_ && 244 !== _g_){var _h_ = x; switch$0 = 1;}
              if(! switch$0) var _h_ = caml_call1(CamlinternalLazy[2], x);
             }
             return caml_call1(f, _h_);
            }];
   }
   function map_val(f, x){
    if(! is_val(x))
     return [246,
             function(_c_){
              var _d_ = caml_obj_tag(x);
              if(250 === _d_)
               var _e_ = x[1];
              else{
               var switch$0 = 0;
               if(246 !== _d_ && 244 !== _d_){var _e_ = x; switch$0 = 1;}
               if(! switch$0) var _e_ = caml_call1(CamlinternalLazy[2], x);
              }
              return caml_call1(f, _e_);
             }];
    var _a_ = caml_obj_tag(x);
    if(250 === _a_)
     var _b_ = x[1];
    else{
     var switch$0 = 0;
     if(246 !== _a_ && 244 !== _a_){var _b_ = x; switch$0 = 1;}
     if(! switch$0) var _b_ = caml_call1(CamlinternalLazy[2], x);
    }
    return from_val(caml_call1(f, _b_));
   }
   var
    Stdlib_Lazy =
      [0, Undefined, map, is_val, from_val, map_val, from_fun, force_val];
   runtime.caml_register_global(2, Stdlib_Lazy, "Stdlib__Lazy");
   return;
  }
  (globalThis));

//# 1238 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib = global_data.Stdlib,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    _a_ = [0, "seq.ml", 596, 4],
    cst_Seq_drop = "Seq.drop",
    cst_Seq_take = "Seq.take",
    cst_Seq_init = "Seq.init",
    cst_Stdlib_Seq_Forced_twice = "Stdlib.Seq.Forced_twice";
   function empty(param){return 0;}
   function return$0(x, param){return [0, x, empty];}
   function cons(x, next, param){return [0, x, next];}
   function append(seq1, seq2, param){
    var match = caml_call1(seq1, 0);
    if(! match) return caml_call1(seq2, 0);
    var next = match[2], x = match[1];
    return [0, x, function(_aM_){return append(next, seq2, _aM_);}];
   }
   function map(f, seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    function _aK_(_aL_){return map(f, next, _aL_);}
    return [0, caml_call1(f, x), _aK_];
   }
   function filter_map(f, seq, param){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(match$0){
      var y = match$0[1];
      return [0, y, function(_aJ_){return filter_map(f, next, _aJ_);}];
     }
     var seq$0 = next;
    }
   }
   function filter(f, seq, param){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     if(caml_call1(f, x))
      return [0, x, function(_aI_){return filter(f, next, _aI_);}];
     var seq$0 = next;
    }
   }
   function concat(seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1], _aG_ = 0;
    return append(x, function(_aH_){return concat(next, _aH_);}, _aG_);
   }
   function flat_map(f, seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1], _aD_ = 0;
    function _aE_(_aF_){return flat_map(f, next, _aF_);}
    return append(caml_call1(f, x), _aE_, _aD_);
   }
   function fold_left(f, acc, seq){
    var acc$0 = acc, seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return acc$0;
     var
      next = match[2],
      x = match[1],
      acc$1 = caml_call2(f, acc$0, x),
      acc$0 = acc$1,
      seq$0 = next;
    }
   }
   function iter(f, seq){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     caml_call1(f, x);
     var seq$0 = next;
    }
   }
   function unfold(f, u, param){
    var match = caml_call1(f, u);
    if(! match) return 0;
    var match$0 = match[1], u$0 = match$0[2], x = match$0[1];
    return [0, x, function(_aC_){return unfold(f, u$0, _aC_);}];
   }
   function is_empty(xs){return caml_call1(xs, 0) ? 0 : 1;}
   function uncons(xs){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    return [0, [0, x, xs$0]];
   }
   function length(xs$1){
    var accu = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return accu;
     var xs$0 = match[2], accu$0 = accu + 1 | 0, accu = accu$0, xs = xs$0;
    }
   }
   function iteri(f, xs$1){
    var i = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     caml_call2(f, i, x);
     var i$0 = i + 1 | 0, i = i$0, xs = xs$0;
    }
   }
   function fold_lefti(f, accu$1, xs$1){
    var accu = accu$1, i = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return accu;
     var
      xs$0 = match[2],
      x = match[1],
      accu$0 = caml_call3(f, accu, i, x),
      i$0 = i + 1 | 0,
      accu = accu$0,
      i = i$0,
      xs = xs$0;
    }
   }
   function for_all(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 1;
     var xs$1 = match[2], x = match[1], _aB_ = caml_call1(p, x);
     if(! _aB_) return _aB_;
     var xs$0 = xs$1;
    }
   }
   function exists(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], _aA_ = caml_call1(p, x);
     if(_aA_) return _aA_;
     var xs$0 = xs$1;
    }
   }
   function find(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1];
     if(caml_call1(p, x)) return [0, x];
     var xs$0 = xs$1;
    }
   }
   function find_map(f, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], result = caml_call1(f, x);
     if(result) return result;
     var xs$0 = xs$1;
    }
   }
   function iter2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 0;
     var ys$1 = match$0[2], y = match$0[1];
     caml_call2(f, x, y);
     var xs$0 = xs$1, ys$0 = ys$1;
    }
   }
   function fold_left2(f, accu, xs, ys){
    var accu$0 = accu, xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return accu$0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return accu$0;
     var
      ys$1 = match$0[2],
      y = match$0[1],
      accu$1 = caml_call3(f, accu$0, x, y),
      accu$0 = accu$1,
      xs$0 = xs$1,
      ys$0 = ys$1;
    }
   }
   function for_all2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 1;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 1;
     var ys$1 = match$0[2], y = match$0[1], _az_ = caml_call2(f, x, y);
     if(! _az_) return _az_;
     var xs$0 = xs$1, ys$0 = ys$1;
    }
   }
   function exists2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 0;
     var ys$1 = match$0[2], y = match$0[1], _ay_ = caml_call2(f, x, y);
     if(_ay_) return _ay_;
     var xs$0 = xs$1, ys$0 = ys$1;
    }
   }
   function equal(eq, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
     if(match){
      if(match$0){
       var
        ys$1 = match$0[2],
        y = match$0[1],
        xs$1 = match[2],
        x = match[1],
        _ax_ = caml_call2(eq, x, y);
       if(! _ax_) return _ax_;
       var xs$0 = xs$1, ys$0 = ys$1;
       continue;
      }
     }
     else if(! match$0) return 1;
     return 0;
    }
   }
   function compare(cmp, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
     if(! match) return match$0 ? -1 : 0;
     var xs$1 = match[2], x = match[1];
     if(! match$0) return 1;
     var ys$1 = match$0[2], y = match$0[1], c = caml_call2(cmp, x, y);
     if(0 !== c) return c;
     var xs$0 = xs$1, ys$0 = ys$1;
    }
   }
   function init_aux(f, i, j, param){
    if(i >= j) return 0;
    var _au_ = i + 1 | 0;
    function _av_(_aw_){return init_aux(f, _au_, j, _aw_);}
    return [0, caml_call1(f, i), _av_];
   }
   function init(n, f){
    if(0 > n) return caml_call1(Stdlib[1], cst_Seq_init);
    var _as_ = 0;
    return function(_at_){return init_aux(f, _as_, n, _at_);};
   }
   function repeat(x, param){
    return [0, x, function(_ar_){return repeat(x, _ar_);}];
   }
   function forever(f, param){
    function _ap_(_aq_){return forever(f, _aq_);}
    return [0, caml_call1(f, 0), _ap_];
   }
   function cycle_nonempty(xs, param){
    var _an_ = 0;
    return append(xs, function(_ao_){return cycle_nonempty(xs, _ao_);}, _an_);
   }
   function cycle(xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    function _ak_(_am_){return cycle_nonempty(xs, _am_);}
    return [0, x, function(_al_){return append(xs$0, _ak_, _al_);}];
   }
   function iterate1(f, x, param){
    var y = caml_call1(f, x);
    return [0, y, function(_aj_){return iterate1(f, y, _aj_);}];
   }
   function iterate(f, x){
    function _ag_(_ai_){return iterate1(f, x, _ai_);}
    return function(_ah_){return [0, x, _ag_];};
   }
   function mapi_aux(f, i, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], _ad_ = i + 1 | 0;
    function _ae_(_af_){return mapi_aux(f, _ad_, xs$0, _af_);}
    return [0, caml_call2(f, i, x), _ae_];
   }
   function mapi(f, xs){
    var _ab_ = 0;
    return function(_ac_){return mapi_aux(f, _ab_, xs, _ac_);};
   }
   function tail_scan(f, s, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], s$0 = caml_call2(f, s, x);
    return [0, s$0, function(_aa_){return tail_scan(f, s$0, xs$0, _aa_);}];
   }
   function scan(f, s, xs){
    function _Z_(_$_){return tail_scan(f, s, xs, _$_);}
    return function(___){return [0, s, _Z_];};
   }
   function take_aux(n, xs){
    return 0 === n
            ? empty
            : function
             (param){
              var match = caml_call1(xs, 0);
              if(! match) return 0;
              var xs$0 = match[2], x = match[1];
              return [0, x, take_aux(n - 1 | 0, xs$0)];
             };
   }
   function take(n, xs){
    if(n < 0) caml_call1(Stdlib[1], cst_Seq_take);
    return take_aux(n, xs);
   }
   function drop(n, xs){
    return 0 <= n
            ? 0
              === n
              ? xs
              : function
               (param){
                var n$0 = n, xs$0 = xs;
                for(;;){
                 var match = caml_call1(xs$0, 0);
                 if(! match) return 0;
                 var xs$1 = match[2], n$1 = n$0 - 1 | 0;
                 if(0 === n$1) return caml_call1(xs$1, 0);
                 var n$0 = n$1, xs$0 = xs$1;
                }
               }
            : caml_call1(Stdlib[1], cst_Seq_drop);
   }
   function take_while(p, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    return caml_call1(p, x)
            ? [0, x, function(_Y_){return take_while(p, xs$0, _Y_);}]
            : 0;
   }
   function drop_while(p, xs, param){
    var xs$0 = xs;
    for(;;){
     var node = caml_call1(xs$0, 0);
     if(! node) return 0;
     var xs$1 = node[2], x = node[1];
     if(! caml_call1(p, x)) return node;
     var xs$0 = xs$1;
    }
   }
   function group(eq, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], _P_ = caml_call1(eq, x);
    function _Q_(_X_){return drop_while(_P_, xs$0, _X_);}
    function _R_(_W_){return group(eq, _Q_, _W_);}
    var _S_ = caml_call1(eq, x);
    function _T_(_V_){return take_while(_S_, xs$0, _V_);}
    return [0, function(_U_){return [0, x, _T_];}, _R_];
   }
   var
    Forced_twice =
      [248, cst_Stdlib_Seq_Forced_twice, runtime.caml_fresh_oo_id(0)],
    to_lazy = Stdlib_Lazy[6];
   function failure(param){
    throw caml_maybe_attach_backtrace(Forced_twice, 1);
   }
   function memoize(xs){
    function s$0(param){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     return [0, x, memoize(xs$0)];
    }
    var s = caml_call1(to_lazy, s$0);
    return function(_O_){
     var _N_ = runtime.caml_obj_tag(s);
     if(250 === _N_) return s[1];
     if(246 !== _N_ && 244 !== _N_) return s;
     return caml_call1(CamlinternalLazy[2], s);};
   }
   function once(xs){
    function f(param){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     return [0, x, once(xs$0)];
    }
    var action = caml_call1(Stdlib_Atomic[1], f);
    return function(param){
     var f = caml_call2(Stdlib_Atomic[4], action, failure);
     return caml_call1(f, 0);};
   }
   function zip(xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if(! match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    return [0, [0, x, y], function(_M_){return zip(xs$0, ys$0, _M_);}];
   }
   function map2(f, xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if(! match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    function _K_(_L_){return map2(f, xs$0, ys$0, _L_);}
    return [0, caml_call2(f, x, y), _K_];
   }
   function interleave(xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return caml_call1(ys, 0);
    var xs$0 = match[2], x = match[1];
    return [0, x, function(_J_){return interleave(ys, xs$0, _J_);}];
   }
   function sorted_merge1(cmp, x, xs, y, ys){
    return 0 < caml_call2(cmp, x, y)
            ? [0,
              y,
              function(_H_){
               var match = caml_call1(ys, 0);
               if(! match) return [0, x, xs];
               var ys$0 = match[2], y = match[1];
               return sorted_merge1(cmp, x, xs, y, ys$0);
              }]
            : [0,
              x,
              function(_I_){
               var match = caml_call1(xs, 0);
               if(! match) return [0, y, ys];
               var xs$0 = match[2], x = match[1];
               return sorted_merge1(cmp, x, xs$0, y, ys);
              }];
   }
   function sorted_merge(cmp, xs, ys, param){
    var match = caml_call1(xs, 0), match$0 = caml_call1(ys, 0);
    if(match){
     if(match$0){
      var ys$0 = match$0[2], y = match$0[1], xs$0 = match[2], x = match[1];
      return sorted_merge1(cmp, x, xs$0, y, ys$0);
     }
     var c = match;
    }
    else{if(! match$0) return 0; var c = match$0;}
    return c;
   }
   function map_fst(xys, param){
    var match = caml_call1(xys, 0);
    if(! match) return 0;
    var xys$0 = match[2], x = match[1][1];
    return [0, x, function(_G_){return map_fst(xys$0, _G_);}];
   }
   function map_snd(xys, param){
    var match = caml_call1(xys, 0);
    if(! match) return 0;
    var xys$0 = match[2], y = match[1][2];
    return [0, y, function(_F_){return map_snd(xys$0, _F_);}];
   }
   function unzip(xys){
    function _C_(_E_){return map_snd(xys, _E_);}
    return [0, function(_D_){return map_fst(xys, _D_);}, _C_];
   }
   function filter_map_find_left_map(f, xs, param){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(0 === match$0[0]){
      var y = match$0[1];
      return [0,
              y,
              function(_B_){return filter_map_find_left_map(f, xs$1, _B_);}];
     }
     var xs$0 = xs$1;
    }
   }
   function filter_map_find_right_map(f, xs, param){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(0 === match$0[0]){var xs$0 = xs$1; continue;}
     var z = match$0[1];
     return [0,
             z,
             function(_A_){return filter_map_find_right_map(f, xs$1, _A_);}];
    }
   }
   function partition_map(f, xs){
    function _x_(_z_){return filter_map_find_right_map(f, xs, _z_);}
    return [0,
            function(_y_){return filter_map_find_left_map(f, xs, _y_);},
            _x_];
   }
   function partition(p, xs){
    function _t_(x){return 1 - caml_call1(p, x);}
    function _u_(_w_){return filter(_t_, xs, _w_);}
    return [0, function(_v_){return filter(p, xs, _v_);}, _u_];
   }
   function peel(xss){
    return unzip(function(_s_){return filter_map(uncons, xss, _s_);});
   }
   function transpose(xss, param){
    var match = peel(xss), tails = match[2], heads = match[1];
    if(! is_empty(heads))
     return [0, heads, function(_r_){return transpose(tails, _r_);}];
    if(is_empty(tails)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function _b_(remainders, xss, param){
    var match = caml_call1(xss, 0);
    if(! match) return transpose(remainders, 0);
    var xss$0 = match[2], xs = match[1], match$0 = caml_call1(xs, 0);
    if(match$0){
     var
      xs$0 = match$0[2],
      x = match$0[1],
      match$1 = peel(remainders),
      tails = match$1[2],
      heads = match$1[1],
      _l_ = function(_q_){return [0, xs$0, tails];},
      _m_ = function(_p_){return _b_(_l_, xss$0, _p_);};
     return [0, function(_o_){return [0, x, heads];}, _m_];
    }
    var
     match$2 = peel(remainders),
     tails$0 = match$2[2],
     heads$0 = match$2[1];
    return [0, heads$0, function(_n_){return _b_(tails$0, xss$0, _n_);}];
   }
   function map_product(f, xs, ys){
    function _f_(x){
     function _j_(y){return caml_call2(f, x, y);}
     return function(_k_){return map(_j_, ys, _k_);};
    }
    function xss(_i_){return map(_f_, xs, _i_);}
    function _e_(_h_){return _b_(empty, xss, _h_);}
    return function(_g_){return concat(_e_, _g_);};
   }
   function product(xs, ys){
    return map_product(function(x, y){return [0, x, y];}, xs, ys);
   }
   function of_dispenser(it){
    function c(param){
     var match = caml_call1(it, 0);
     if(! match) return 0;
     var x = match[1];
     return [0, x, c];
    }
    return c;
   }
   function to_dispenser(xs){
    var s = [0, xs];
    return function(param){
     var match = caml_call1(s[1], 0);
     if(! match) return 0;
     var xs = match[2], x = match[1];
     s[1] = xs;
     return [0, x];};
   }
   function ints(i, param){
    var _c_ = i + 1 | 0;
    return [0, i, function(_d_){return ints(_c_, _d_);}];
   }
   var
    Stdlib_Seq =
      [0,
       is_empty,
       uncons,
       length,
       iter,
       fold_left,
       iteri,
       fold_lefti,
       for_all,
       exists,
       find,
       find_map,
       iter2,
       fold_left2,
       for_all2,
       exists2,
       equal,
       compare,
       empty,
       return$0,
       cons,
       init,
       unfold,
       repeat,
       forever,
       cycle,
       iterate,
       map,
       mapi,
       filter,
       filter_map,
       scan,
       take,
       drop,
       take_while,
       drop_while,
       group,
       memoize,
       Forced_twice,
       once,
       transpose,
       append,
       concat,
       flat_map,
       flat_map,
       zip,
       map2,
       interleave,
       sorted_merge,
       product,
       map_product,
       unzip,
       unzip,
       partition_map,
       partition,
       of_dispenser,
       to_dispenser,
       ints];
   runtime.caml_register_global(10, Stdlib_Seq, "Stdlib__Seq");
   return;
  }
  (globalThis));

//# 2183 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_string_of_bytes = runtime.caml_string_of_bytes;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\\\\",
    cst$0 = "\\'",
    Stdlib = global_data.Stdlib,
    cst_b = "\\b",
    cst_t = "\\t",
    cst_n = "\\n",
    cst_r = "\\r",
    cst_Char_chr = "Char.chr";
   function chr(n){
    if(0 <= n && 255 >= n) return n;
    return caml_call1(Stdlib[1], cst_Char_chr);
   }
   function escaped(c){
    var switch$0 = 0;
    if(40 <= c){
     if(92 === c) return cst;
     if(127 > c) switch$0 = 1;
    }
    else if(32 <= c){
     if(39 <= c) return cst$0;
     switch$0 = 1;
    }
    else if(14 > c)
     switch(c){
       case 8:
        return cst_b;
       case 9:
        return cst_t;
       case 10:
        return cst_n;
       case 13:
        return cst_r;
     }
    if(switch$0){
     var s$0 = caml_create_bytes(1);
     caml_bytes_unsafe_set(s$0, 0, c);
     return caml_string_of_bytes(s$0);
    }
    var s = caml_create_bytes(4);
    caml_bytes_unsafe_set(s, 0, 92);
    caml_bytes_unsafe_set(s, 1, 48 + (c / 100 | 0) | 0);
    caml_bytes_unsafe_set(s, 2, 48 + ((c / 10 | 0) % 10 | 0) | 0);
    caml_bytes_unsafe_set(s, 3, 48 + (c % 10 | 0) | 0);
    return caml_string_of_bytes(s);
   }
   function lowercase_ascii(c){return 25 < c - 65 >>> 0 ? c : c + 32 | 0;}
   function uppercase_ascii(c){return 25 < c - 97 >>> 0 ? c : c - 32 | 0;}
   function compare(c1, c2){return c1 - c2 | 0;}
   function equal(c1, c2){return 0 === (c1 - c2 | 0) ? 1 : 0;}
   var
    Stdlib_Char =
      [0, chr, escaped, lowercase_ascii, uppercase_ascii, compare, equal];
   runtime.caml_register_global(8, Stdlib_Char, "Stdlib__Char");
   return;
  }
  (globalThis));

//# 2257 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_uchar_ml = "uchar.ml",
    caml_format_int = runtime.caml_format_int,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    err_no_pred = "U+0000 has no predecessor",
    err_no_succ = "U+10FFFF has no successor",
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    _d_ = [0, cst_uchar_ml, 88, 18],
    _c_ = [0, cst_uchar_ml, 91, 7],
    _b_ = [0, cst_uchar_ml, 80, 18],
    _a_ = [0, cst_uchar_ml, 85, 7],
    cst_is_not_a_latin1_character = " is not a latin1 character",
    cst_U = "U+",
    cst_is_not_an_Unicode_scalar_v = " is not an Unicode scalar value",
    min = 0,
    max = 1114111,
    lo_bound = 55295,
    hi_bound = 57344,
    bom = 65279,
    rep = 65533;
   function succ(u){
    return u === 55295
            ? hi_bound
            : u === 1114111 ? caml_call1(Stdlib[1], err_no_succ) : u + 1 | 0;
   }
   function pred(u){
    return u === 57344
            ? lo_bound
            : u === 0 ? caml_call1(Stdlib[1], err_no_pred) : u - 1 | 0;
   }
   function is_valid(i){
    var _o_ = 0 <= i ? 1 : 0, _p_ = _o_ ? i <= 55295 ? 1 : 0 : _o_;
    if(_p_)
     var _q_ = _p_;
    else
     var _r_ = 57344 <= i ? 1 : 0, _q_ = _r_ ? i <= 1114111 ? 1 : 0 : _r_;
    return _q_;
   }
   function of_int(i){
    if(is_valid(i)) return i;
    var
     _n_ =
       caml_call2
        (Stdlib[28], caml_format_int("%X", i), cst_is_not_an_Unicode_scalar_v);
    return caml_call1(Stdlib[1], _n_);
   }
   function is_char(u){return u < 256 ? 1 : 0;}
   function of_char(c){return c;}
   function to_char(u){
    if(255 >= u) return u;
    var
     _l_ =
       caml_call2
        (Stdlib[28],
         caml_format_int("%04X", u),
         cst_is_not_a_latin1_character),
     _m_ = caml_call2(Stdlib[28], cst_U, _l_);
    return caml_call1(Stdlib[1], _m_);
   }
   function unsafe_to_char(_k_){return _k_;}
   function equal(_j_, _i_){return _j_ === _i_ ? 1 : 0;}
   var compare = runtime.caml_int_compare;
   function hash(_h_){return _h_;}
   function utf_decode_is_valid(d){return 1 === (d >>> 27 | 0) ? 1 : 0;}
   function utf_decode_length(d){return (d >>> 24 | 0) & 7;}
   function utf_decode_uchar(d){return d & 16777215;}
   function utf_decode(n, u){return (8 | n) << 24 | u;}
   function utf_decode_invalid(n){return n << 24 | 65533;}
   function utf_8_byte_length(u){
    if(0 > u) throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(127 >= u) return 1;
    if(2047 >= u) return 2;
    if(65535 >= u) return 3;
    if(1114111 < u)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    return 4;
   }
   function utf_16_byte_length(u){
    if(0 > u) throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    if(65535 >= u) return 2;
    if(1114111 < u)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    return 4;
   }
   function _e_(_g_){return _g_;}
   var
    Stdlib_Uchar =
      [0,
       min,
       max,
       bom,
       rep,
       succ,
       pred,
       is_valid,
       of_int,
       function(_f_){return _f_;},
       _e_,
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal,
       compare,
       hash,
       utf_decode_is_valid,
       utf_decode_uchar,
       utf_decode_length,
       utf_decode,
       utf_decode_invalid,
       utf_8_byte_length,
       utf_16_byte_length];
   runtime.caml_register_global(13, Stdlib_Uchar, "Stdlib__Uchar");
   return;
  }
  (globalThis));

//# 2393 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_List_nth$1 = "List.nth",
    caml_compare = runtime.caml_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Sys = global_data.Stdlib__Sys,
    cst_List_map2 = "List.map2",
    cst_List_iter2 = "List.iter2",
    cst_List_fold_left2 = "List.fold_left2",
    cst_List_fold_right2 = "List.fold_right2",
    cst_List_for_all2 = "List.for_all2",
    cst_List_exists2 = "List.exists2",
    _b_ = [0, 0, 0],
    cst_List_combine = "List.combine",
    cst_List_rev_map2 = "List.rev_map2",
    cst_List_init = "List.init",
    cst_List_nth$0 = cst_List_nth$1,
    cst_nth = "nth",
    cst_List_nth = cst_List_nth$1,
    cst_tl = "tl",
    cst_hd = "hd";
   function length(l$0){
    var len = 0, param = l$0;
    for(;;){
     if(! param) return len;
     var l = param[2], len$0 = len + 1 | 0, len = len$0, param = l;
    }
   }
   function cons(a, l){return [0, a, l];}
   function hd(param){
    if(! param) return caml_call1(Stdlib[2], cst_hd);
    var a = param[1];
    return a;
   }
   function tl(param){
    if(! param) return caml_call1(Stdlib[2], cst_tl);
    var l = param[2];
    return l;
   }
   function nth(l, n){
    if(0 > n) return caml_call1(Stdlib[1], cst_List_nth);
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return caml_call1(Stdlib[2], cst_nth);
     var l$1 = l$0[2], a = l$0[1];
     if(0 === n$0) return a;
     var n$1 = n$0 - 1 | 0, l$0 = l$1, n$0 = n$1;
    }
   }
   function nth_opt(l, n){
    if(0 > n) return caml_call1(Stdlib[1], cst_List_nth$0);
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return 0;
     var l$1 = l$0[2], a = l$0[1];
     if(0 === n$0) return [0, a];
     var n$1 = n$0 - 1 | 0, l$0 = l$1, n$0 = n$1;
    }
   }
   var append = Stdlib[37];
   function rev_append(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0;
     var
      l1$1 = l1$0[2],
      a = l1$0[1],
      l2$1 = [0, a, l2$0],
      l1$0 = l1$1,
      l2$0 = l2$1;
    }
   }
   function rev(l){return rev_append(l, 0);}
   function init_aux(i, n, f){
    if(n <= i) return 0;
    var r = caml_call1(f, i);
    return [0, r, init_aux(i + 1 | 0, n, f)];
   }
   var rev_init_threshold = typeof Stdlib_Sys[5] === "number" ? 10000 : 50;
   function init(len, f){
    if(0 > len) return caml_call1(Stdlib[1], cst_List_init);
    if(rev_init_threshold >= len) return init_aux(0, len, f);
    var acc = 0, i = 0;
    for(;;){
     if(len <= i) return rev(acc);
     var
      i$0 = i + 1 | 0,
      acc$0 = [0, caml_call1(f, i), acc],
      acc = acc$0,
      i = i$0;
    }
   }
   function flatten(param){
    if(! param) return 0;
    var r = param[2], l = param[1], _J_ = flatten(r);
    return caml_call2(Stdlib[37], l, _J_);
   }
   function map(f, param){
    if(! param) return 0;
    var l = param[2], a = param[1], r = caml_call1(f, a);
    return [0, r, map(f, l)];
   }
   function _a_(i, f, param){
    if(! param) return 0;
    var l = param[2], a = param[1], r = caml_call2(f, i, a);
    return [0, r, _a_(i + 1 | 0, f, l)];
   }
   function mapi(f, l){return _a_(0, f, l);}
   function rev_map(f, l){
    var accu = 0, param = l;
    for(;;){
     if(! param) return accu;
     var
      l$0 = param[2],
      a = param[1],
      accu$0 = [0, caml_call1(f, a), accu],
      accu = accu$0,
      param = l$0;
    }
   }
   function iter(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1];
     caml_call1(f, a);
     var param$0 = l;
    }
   }
   function iteri(f, l$0){
    var i = 0, param = l$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], a = param[1];
     caml_call2(f, i, a);
     var i$0 = i + 1 | 0, i = i$0, param = l;
    }
   }
   function fold_left(f, accu, l){
    var accu$0 = accu, l$0 = l;
    for(;;){
     if(! l$0) return accu$0;
     var
      l$1 = l$0[2],
      a = l$0[1],
      accu$1 = caml_call2(f, accu$0, a),
      accu$0 = accu$1,
      l$0 = l$1;
    }
   }
   function fold_right(f, l, accu){
    if(! l) return accu;
    var l$0 = l[2], a = l[1];
    return caml_call2(f, a, fold_right(f, l$0, accu));
   }
   function map2(f, l1, l2){
    if(l1){
     if(l2){
      var
       l2$0 = l2[2],
       a2 = l2[1],
       l1$0 = l1[2],
       a1 = l1[1],
       r = caml_call2(f, a1, a2);
      return [0, r, map2(f, l1$0, l2$0)];
     }
    }
    else if(! l2) return 0;
    return caml_call1(Stdlib[1], cst_List_map2);
   }
   function rev_map2(f, l1, l2){
    var accu = 0, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        accu$0 = [0, caml_call2(f, a1, a2), accu],
        accu = accu$0,
        l1$0 = l1$1,
        l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return accu;
     return caml_call1(Stdlib[1], cst_List_rev_map2);
    }
   }
   function iter2(f, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var l2$1 = l2$0[2], a2 = l2$0[1], l1$1 = l1$0[2], a1 = l1$0[1];
       caml_call2(f, a1, a2);
       var l1$0 = l1$1, l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Stdlib[1], cst_List_iter2);
    }
   }
   function fold_left2(f, accu, l1, l2){
    var accu$0 = accu, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        accu$1 = caml_call3(f, accu$0, a1, a2),
        accu$0 = accu$1,
        l1$0 = l1$1,
        l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return accu$0;
     return caml_call1(Stdlib[1], cst_List_fold_left2);
    }
   }
   function fold_right2(f, l1, l2, accu){
    if(l1){
     if(l2){
      var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
      return caml_call3(f, a1, a2, fold_right2(f, l1$0, l2$0, accu));
     }
    }
    else if(! l2) return accu;
    return caml_call1(Stdlib[1], cst_List_fold_right2);
   }
   function for_all(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 1;
     var l = param$0[2], a = param$0[1], _I_ = caml_call1(p, a);
     if(! _I_) return _I_;
     var param$0 = l;
    }
   }
   function exists(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1], _H_ = caml_call1(p, a);
     if(_H_) return _H_;
     var param$0 = l;
    }
   }
   function for_all2(p, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _G_ = caml_call2(p, a1, a2);
       if(! _G_) return _G_;
       var l1$0 = l1$1, l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return caml_call1(Stdlib[1], cst_List_for_all2);
    }
   }
   function exists2(p, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _F_ = caml_call2(p, a1, a2);
       if(_F_) return _F_;
       var l1$0 = l1$1, l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Stdlib[1], cst_List_exists2);
    }
   }
   function mem(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var
      l = param$0[2],
      a = param$0[1],
      _E_ = 0 === caml_compare(a, x) ? 1 : 0;
     if(_E_) return _E_;
     var param$0 = l;
    }
   }
   function memq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1], _D_ = a === x ? 1 : 0;
     if(_D_) return _D_;
     var param$0 = l;
    }
   }
   function assoc(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(0 === caml_compare(a, x)) return b;
     var param$0 = l;
    }
   }
   function assoc_opt(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(0 === caml_compare(a, x)) return [0, b];
     var param$0 = l;
    }
   }
   function assq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(a === x) return b;
     var param$0 = l;
    }
   }
   function assq_opt(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(a === x) return [0, b];
     var param$0 = l;
    }
   }
   function mem_assoc(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var
      l = param$0[2],
      a = param$0[1][1],
      _C_ = 0 === caml_compare(a, x) ? 1 : 0;
     if(_C_) return _C_;
     var param$0 = l;
    }
   }
   function mem_assq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1][1], _B_ = a === x ? 1 : 0;
     if(_B_) return _B_;
     var param$0 = l;
    }
   }
   function remove_assoc(x, param){
    if(! param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return 0 === caml_compare(a, x) ? l : [0, pair, remove_assoc(x, l)];
   }
   function remove_assq(x, param){
    if(! param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return a === x ? l : [0, pair, remove_assq(x, l)];
   }
   function find(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], x = param$0[1];
     if(caml_call1(p, x)) return x;
     var param$0 = l;
    }
   }
   function find_opt(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1];
     if(caml_call1(p, x)) return [0, x];
     var param$0 = l;
    }
   }
   function find_map(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1], result = caml_call1(f, x);
     if(result) return result;
     var param$0 = l;
    }
   }
   function find_all(p){
    var accu = 0;
    return function(param$0){
     var accu$0 = accu, param = param$0;
     for(;;){
      if(! param) return rev(accu$0);
      var l = param[2], x = param[1];
      if(caml_call1(p, x)){
       var accu$1 = [0, x, accu$0], accu$0 = accu$1, param = l;
       continue;
      }
      var param = l;
     }};
   }
   function filteri(p, l){
    var i = 0, acc = 0, param = l;
    for(;;){
     if(! param) return rev(acc);
     var
      l$0 = param[2],
      x = param[1],
      acc$0 = caml_call2(p, i, x) ? [0, x, acc] : acc,
      i$0 = i + 1 | 0,
      i = i$0,
      acc = acc$0,
      param = l$0;
    }
   }
   function filter_map(f){
    var accu = 0;
    return function(param$0){
     var accu$0 = accu, param = param$0;
     for(;;){
      if(! param) return rev(accu$0);
      var l = param[2], x = param[1], match = caml_call1(f, x);
      if(match){
       var v = match[1], accu$1 = [0, v, accu$0], accu$0 = accu$1, param = l;
       continue;
      }
      var param = l;
     }};
   }
   function concat_map(f, l){
    var acc = 0, param = l;
    for(;;){
     if(! param) return rev(acc);
     var
      l$0 = param[2],
      x = param[1],
      xs = caml_call1(f, x),
      acc$0 = rev_append(xs, acc),
      acc = acc$0,
      param = l$0;
    }
   }
   function fold_left_map(f, accu, l){
    var accu$0 = accu, l_accu = 0, param = l;
    for(;;){
     if(! param) return [0, accu$0, rev(l_accu)];
     var
      l$0 = param[2],
      x = param[1],
      match = caml_call2(f, accu$0, x),
      x$0 = match[2],
      accu$1 = match[1],
      l_accu$0 = [0, x$0, l_accu],
      accu$0 = accu$1,
      l_accu = l_accu$0,
      param = l$0;
    }
   }
   function partition(p, l){
    var yes = 0, no = 0, param = l;
    for(;;){
     if(! param){var _A_ = rev(no); return [0, rev(yes), _A_];}
     var l$0 = param[2], x = param[1];
     if(caml_call1(p, x)){
      var yes$0 = [0, x, yes], yes = yes$0, param = l$0;
      continue;
     }
     var no$0 = [0, x, no], no = no$0, param = l$0;
    }
   }
   function partition_map(p, l){
    var left = 0, right = 0, param = l;
    for(;;){
     if(! param){var _z_ = rev(right); return [0, rev(left), _z_];}
     var l$0 = param[2], x = param[1], match = caml_call1(p, x);
     if(0 === match[0]){
      var v = match[1], left$0 = [0, v, left], left = left$0, param = l$0;
      continue;
     }
     var
      v$0 = match[1],
      right$0 = [0, v$0, right],
      right = right$0,
      param = l$0;
    }
   }
   function split(param){
    if(! param) return _b_;
    var
     l = param[2],
     match = param[1],
     y = match[2],
     x = match[1],
     match$0 = split(l),
     ry = match$0[2],
     rx = match$0[1];
    return [0, [0, x, rx], [0, y, ry]];
   }
   function combine(l1, l2){
    if(l1){
     if(l2){
      var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
      return [0, [0, a1, a2], combine(l1$0, l2$0)];
     }
    }
    else if(! l2) return 0;
    return caml_call1(Stdlib[1], cst_List_combine);
   }
   function merge(cmp, l1, l2){
    if(! l1) return l2;
    if(! l2) return l1;
    var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
    return 0 < caml_call2(cmp, h1, h2)
            ? [0, h2, merge(cmp, l1, t2)]
            : [0, h1, merge(cmp, t1, l2)];
   }
   function stable_sort(cmp, l){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x2, [0, x1, 0]]
            : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _y_ = l[2];
      if(_y_){
       var match$2 = _y_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _y_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x1$0, x3)
              ? 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]]
              : [0, x2$0, [0, x1$0, [0, x3, 0]]]
            : 0
              < caml_call2(cmp, x2$0, x3)
              ? 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]]
              : [0, x1$0, [0, x2$0, [0, x3, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h1, accu], l1 = t1, accu = accu$0;
         continue;
        }
        var accu$1 = [0, h2, accu], l2 = t2, accu = accu$1;
        continue;
       }
       var _x_ = rev_append(l1, accu);
      }
      else
       var _x_ = rev_append(l2, accu);
      return [0, _x_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x1, [0, x2, 0]]
            : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _w_ = l[2];
      if(_w_){
       var match$2 = _w_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _w_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x2$0, x3)
              ? [0, x1$0, [0, x2$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]]
            : 0
              < caml_call2(cmp, x1$0, x3)
              ? [0, x2$0, [0, x1$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h2, accu], l2 = t2, accu = accu$0;
         continue;
        }
        var accu$1 = [0, h1, accu], l1 = t1, accu = accu$1;
        continue;
       }
       var _v_ = rev_append(l1, accu);
      }
      else
       var _v_ = rev_append(l2, accu);
      return [0, _v_, tl$0];
     }
    }
    var len = length(l);
    return 2 <= len ? sort(len, l)[1] : l;
   }
   function sort_uniq(cmp, l){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 === c$0
            ? [0, x1, 0]
            : 0 <= c$0 ? [0, x2, [0, x1, 0]] : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _p_ = l[2];
      if(_p_){
       var match$2 = _p_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _p_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 === c$1)
         var
          c$2 = caml_call2(cmp, x2$0, x3),
          _q_ =
            0 === c$2
             ? [0, x2$0, 0]
             : 0 <= c$2 ? [0, x3, [0, x2$0, 0]] : [0, x2$0, [0, x3, 0]],
          s$0 = _q_;
        else if(0 <= c$1){
         var c$3 = caml_call2(cmp, x1$0, x3);
         if(0 === c$3)
          var _r_ = [0, x2$0, [0, x1$0, 0]];
         else if(0 <= c$3)
          var
           c$4 = caml_call2(cmp, x2$0, x3),
           _s_ =
             0 === c$4
              ? [0, x2$0, [0, x1$0, 0]]
              : 0
                <= c$4
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]],
           _r_ = _s_;
         else
          var _r_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
         var s$0 = _r_;
        }
        else{
         var c$5 = caml_call2(cmp, x2$0, x3);
         if(0 === c$5)
          var _t_ = [0, x1$0, [0, x2$0, 0]];
         else if(0 <= c$5)
          var
           c$6 = caml_call2(cmp, x1$0, x3),
           _u_ =
             0 === c$6
              ? [0, x1$0, [0, x2$0, 0]]
              : 0
                <= c$6
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]],
           _t_ = _u_;
         else
          var _t_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         var s$0 = _t_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 === c){
         var accu$0 = [0, h1, accu], l1 = t1, l2 = t2, accu = accu$0;
         continue;
        }
        if(0 < c){
         var accu$1 = [0, h1, accu], l1 = t1, accu = accu$1;
         continue;
        }
        var accu$2 = [0, h2, accu], l2 = t2, accu = accu$2;
        continue;
       }
       var _o_ = rev_append(l1, accu);
      }
      else
       var _o_ = rev_append(l2, accu);
      return [0, _o_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 === c$0
            ? [0, x1, 0]
            : 0 < c$0 ? [0, x1, [0, x2, 0]] : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _i_ = l[2];
      if(_i_){
       var match$2 = _i_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _i_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 === c$1)
         var
          c$2 = caml_call2(cmp, x2$0, x3),
          _j_ =
            0 === c$2
             ? [0, x2$0, 0]
             : 0 < c$2 ? [0, x2$0, [0, x3, 0]] : [0, x3, [0, x2$0, 0]],
          s$0 = _j_;
        else if(0 < c$1){
         var c$3 = caml_call2(cmp, x2$0, x3);
         if(0 === c$3)
          var _k_ = [0, x1$0, [0, x2$0, 0]];
         else if(0 < c$3)
          var _k_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         else
          var
           c$4 = caml_call2(cmp, x1$0, x3),
           _l_ =
             0 === c$4
              ? [0, x1$0, [0, x2$0, 0]]
              : 0
                < c$4
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]],
           _k_ = _l_;
         var s$0 = _k_;
        }
        else{
         var c$5 = caml_call2(cmp, x1$0, x3);
         if(0 === c$5)
          var _m_ = [0, x2$0, [0, x1$0, 0]];
         else if(0 < c$5)
          var _m_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
         else
          var
           c$6 = caml_call2(cmp, x2$0, x3),
           _n_ =
             0 === c$6
              ? [0, x2$0, [0, x1$0, 0]]
              : 0
                < c$6
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]],
           _m_ = _n_;
         var s$0 = _m_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 === c){
         var accu$0 = [0, h1, accu], l1 = t1, l2 = t2, accu = accu$0;
         continue;
        }
        if(0 <= c){
         var accu$1 = [0, h2, accu], l2 = t2, accu = accu$1;
         continue;
        }
        var accu$2 = [0, h1, accu], l1 = t1, accu = accu$2;
        continue;
       }
       var _h_ = rev_append(l1, accu);
      }
      else
       var _h_ = rev_append(l2, accu);
      return [0, _h_, tl$0];
     }
    }
    var len = length(l);
    return 2 <= len ? sort(len, l)[1] : l;
   }
   function compare_lengths(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0 ? -1 : 0;
     if(! l2$0) return 1;
     var l2$1 = l2$0[2], l1$1 = l1$0[2], l1$0 = l1$1, l2$0 = l2$1;
    }
   }
   function compare_length_with(l, n){
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return 0 === n$0 ? 0 : 0 < n$0 ? -1 : 1;
     var l$1 = l$0[2];
     if(0 >= n$0) return 1;
     var n$1 = n$0 - 1 | 0, l$0 = l$1, n$0 = n$1;
    }
   }
   function equal(eq, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _g_ = caml_call2(eq, a1, a2);
       if(! _g_) return _g_;
       var l1$0 = l1$1, l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return 0;
    }
   }
   function compare(cmp, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0 ? -1 : 0;
     var l1$1 = l1$0[2], a1 = l1$0[1];
     if(! l2$0) return 1;
     var l2$1 = l2$0[2], a2 = l2$0[1], c = caml_call2(cmp, a1, a2);
     if(0 !== c) return c;
     var l1$0 = l1$1, l2$0 = l2$1;
    }
   }
   function to_seq(l){
    function aux(l, param){
     if(! l) return 0;
     var tail = l[2], x = l[1];
     return [0, x, function(_f_){return aux(tail, _f_);}];
    }
    return function(_e_){return aux(l, _e_);};
   }
   function of_seq(seq){
    function direct(depth, seq){
     if(0 === depth){
      var _c_ = 0, _d_ = function(acc, x){return [0, x, acc];};
      return rev(caml_call3(Stdlib_Seq[5], _d_, _c_, seq));
     }
     var match = caml_call1(seq, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     return [0, x, direct(depth - 1 | 0, next)];
    }
    return direct(500, seq);
   }
   var
    Stdlib_List =
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal,
       compare,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       filter_map,
       concat_map,
       fold_left_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       stable_sort,
       stable_sort,
       stable_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq];
   runtime.caml_register_global(18, Stdlib_List, "Stdlib__List");
   return;
  }
  (globalThis));

//# 3492 "../../.js/default/stdlib/stdlib.cma.js"
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, zero = 0, one = 1, minus_one = -1;
   function abs(x){return 0 <= x ? x : - x | 0;}
   var max_int = 2147483647, min_int = -2147483648;
   function lognot(x){return x ^ -1;}
   function equal(_b_, _a_){return _b_ === _a_ ? 1 : 0;}
   var compare = runtime.caml_int_compare;
   function min(x, y){return x <= y ? x : y;}
   function max(x, y){return y <= x ? x : y;}
   function to_string(x){return "" + x;}
   var
    Stdlib_Int =
      [0,
       zero,
       one,
       minus_one,
       abs,
       max_int,
       min_int,
       lognot,
       equal,
       compare,
       min,
       max,
       to_string];
   runtime.caml_register_global(1, Stdlib_Int, "Stdlib__Int");
   return;
  }
  (globalThis));

//# 3525 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_bytes_ml = "bytes.ml",
    cst_index_out_of_bounds$3 = "index out of bounds",
    caml_blit_bytes = runtime.caml_blit_bytes,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_get16 = runtime.caml_bytes_get16,
    caml_bytes_get32 = runtime.caml_bytes_get32,
    caml_bytes_get64 = runtime.caml_bytes_get64,
    caml_bytes_of_string = runtime.caml_bytes_of_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_set16 = runtime.caml_bytes_set16,
    caml_bytes_set32 = runtime.caml_bytes_set32,
    caml_bytes_set64 = runtime.caml_bytes_set64,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fill_bytes = runtime.caml_fill_bytes,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Char = global_data.Stdlib__Char,
    cst_index_out_of_bounds$2 = cst_index_out_of_bounds$3,
    _f_ = [0, cst_bytes_ml, 820, 20],
    _e_ = [0, cst_bytes_ml, 831, 9],
    cst_index_out_of_bounds$1 = cst_index_out_of_bounds$3,
    cst_index_out_of_bounds$0 = cst_index_out_of_bounds$3,
    _d_ = [0, cst_bytes_ml, 766, 20],
    _c_ = [0, cst_bytes_ml, 777, 9],
    cst_index_out_of_bounds = cst_index_out_of_bounds$3,
    _b_ = [0, cst_bytes_ml, 654, 20],
    _a_ = [0, cst_bytes_ml, 679, 9],
    cst_Bytes_of_seq_cannot_grow_b = "Bytes.of_seq: cannot grow bytes",
    cst_String_rcontains_from_Byte =
      "String.rcontains_from / Bytes.rcontains_from",
    cst_String_contains_from_Bytes =
      "String.contains_from / Bytes.contains_from",
    cst_String_rindex_from_opt_Byt =
      "String.rindex_from_opt / Bytes.rindex_from_opt",
    cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from",
    cst_String_index_from_opt_Byte =
      "String.index_from_opt / Bytes.index_from_opt",
    cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from",
    cst_Bytes_concat = "Bytes.concat",
    cst_String_blit_Bytes_blit_str = "String.blit / Bytes.blit_string",
    cst_Bytes_blit = "Bytes.blit",
    cst_String_fill_Bytes_fill = "String.fill / Bytes.fill",
    cst_Bytes_extend = "Bytes.extend",
    cst_String_sub_Bytes_sub = "String.sub / Bytes.sub";
   function make(n, c){
    var s = caml_create_bytes(n);
    caml_fill_bytes(s, 0, n, c);
    return s;
   }
   function init(n, f){
    var s = caml_create_bytes(n), _aq_ = n - 1 | 0, _ap_ = 0;
    if(_aq_ >= 0){
     var i = _ap_;
     for(;;){
      caml_bytes_unsafe_set(s, i, caml_call1(f, i));
      var _ar_ = i + 1 | 0;
      if(_aq_ !== i){var i = _ar_; continue;}
      break;
     }
    }
    return s;
   }
   var empty = caml_create_bytes(0);
   function copy(s){
    var len = caml_ml_bytes_length(s), r = caml_create_bytes(len);
    caml_blit_bytes(s, 0, r, 0, len);
    return r;
   }
   function to_string(b){return caml_string_of_bytes(copy(b));}
   function of_string(s){return copy(caml_bytes_of_string(s));}
   function sub(s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs){
     var r = caml_create_bytes(len);
     caml_blit_bytes(s, ofs, r, 0, len);
     return r;
    }
    return caml_call1(Stdlib[1], cst_String_sub_Bytes_sub);
   }
   function sub_string(b, ofs, len){
    return caml_string_of_bytes(sub(b, ofs, len));
   }
   function symbol(a, b){
    var
     c = a + b | 0,
     _ao_ = b < 0 ? 1 : 0,
     match = c < 0 ? 1 : 0,
     switch$0 = 0;
    if(a < 0){
     if(_ao_ && ! match) switch$0 = 1;
    }
    else if(! _ao_ && match) switch$0 = 1;
    return switch$0 ? caml_call1(Stdlib[1], cst_Bytes_extend) : c;
   }
   function extend(s, left, right){
    var
     len = symbol(symbol(caml_ml_bytes_length(s), left), right),
     r = caml_create_bytes(len);
    if(0 <= left)
     var dstoff = left, srcoff = 0;
    else
     var dstoff = 0, srcoff = - left | 0;
    var
     cpylen =
       caml_call2
        (Stdlib_Int[10],
         caml_ml_bytes_length(s) - srcoff | 0,
         len - dstoff | 0);
    if(0 < cpylen) caml_blit_bytes(s, srcoff, r, dstoff, cpylen);
    return r;
   }
   function fill(s, ofs, len, c){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_fill_bytes(s, ofs, len, c);
    return caml_call1(Stdlib[1], cst_String_fill_Bytes_fill);
   }
   function blit(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (caml_ml_bytes_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2)
     return caml_blit_bytes(s1, ofs1, s2, ofs2, len);
    return caml_call1(Stdlib[1], cst_Bytes_blit);
   }
   function blit_string(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (runtime.caml_ml_string_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2)
     return runtime.caml_blit_string(s1, ofs1, s2, ofs2, len);
    return caml_call1(Stdlib[1], cst_String_blit_Bytes_blit_str);
   }
   function iter(f, a){
    var _am_ = caml_ml_bytes_length(a) - 1 | 0, _al_ = 0;
    if(_am_ >= 0){
     var i = _al_;
     for(;;){
      caml_call1(f, caml_bytes_unsafe_get(a, i));
      var _an_ = i + 1 | 0;
      if(_am_ !== i){var i = _an_; continue;}
      break;
     }
    }
    return 0;
   }
   function iteri(f, a){
    var _aj_ = caml_ml_bytes_length(a) - 1 | 0, _ai_ = 0;
    if(_aj_ >= 0){
     var i = _ai_;
     for(;;){
      caml_call2(f, i, caml_bytes_unsafe_get(a, i));
      var _ak_ = i + 1 | 0;
      if(_aj_ !== i){var i = _ak_; continue;}
      break;
     }
    }
    return 0;
   }
   function concat(sep, l){
    if(! l) return empty;
    var seplen = caml_ml_bytes_length(sep), acc = 0, param = l, pos$1 = 0;
    for(;;){
     if(param){
      var hd = param[1];
      if(param[2]){
       var
        tl = param[2],
        x = (caml_ml_bytes_length(hd) + seplen | 0) + acc | 0,
        acc$0 = acc <= x ? x : caml_call1(Stdlib[1], cst_Bytes_concat),
        acc = acc$0,
        param = tl;
       continue;
      }
      var _ah_ = caml_ml_bytes_length(hd) + acc | 0;
     }
     else
      var _ah_ = acc;
     var dst = caml_create_bytes(_ah_), pos = pos$1, param$0 = l;
     for(;;){
      if(! param$0) return dst;
      var hd$0 = param$0[1];
      if(param$0[2]){
       var tl$0 = param$0[2];
       caml_blit_bytes(hd$0, 0, dst, pos, caml_ml_bytes_length(hd$0));
       caml_blit_bytes
        (sep, 0, dst, pos + caml_ml_bytes_length(hd$0) | 0, seplen);
       var
        pos$0 = (pos + caml_ml_bytes_length(hd$0) | 0) + seplen | 0,
        pos = pos$0,
        param$0 = tl$0;
       continue;
      }
      caml_blit_bytes(hd$0, 0, dst, pos, caml_ml_bytes_length(hd$0));
      return dst;
     }
    }
   }
   function cat(s1, s2){
    var
     l1 = caml_ml_bytes_length(s1),
     l2 = caml_ml_bytes_length(s2),
     r = caml_create_bytes(l1 + l2 | 0);
    caml_blit_bytes(s1, 0, r, 0, l1);
    caml_blit_bytes(s2, 0, r, l1, l2);
    return r;
   }
   function is_space(param){
    var _ag_ = param - 9 | 0, switch$0 = 0;
    if(4 < _ag_ >>> 0){
     if(23 === _ag_) switch$0 = 1;
    }
    else if(2 !== _ag_) switch$0 = 1;
    return switch$0 ? 1 : 0;
   }
   function trim(s){
    var len = caml_ml_bytes_length(s), i = [0, 0];
    for(;;){
     if(i[1] < len && is_space(caml_bytes_unsafe_get(s, i[1]))){i[1]++; continue;}
     var j = [0, len - 1 | 0];
     for(;;){
      if(i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s, j[1]))){j[1] += -1; continue;}
      return i[1] <= j[1] ? sub(s, i[1], (j[1] - i[1] | 0) + 1 | 0) : empty;
     }
    }
   }
   function unsafe_escape(s){
    var n = [0, 0], _$_ = caml_ml_bytes_length(s) - 1 | 0, ___ = 0;
    if(_$_ >= 0){
     var i$0 = ___;
     for(;;){
      var match = caml_bytes_unsafe_get(s, i$0), switch$0 = 0;
      if(32 <= match){
       var _ad_ = match - 34 | 0, switch$1 = 0;
       if(58 < _ad_ >>> 0){
        if(93 > _ad_) switch$1 = 1;
       }
       else if(56 < _ad_ - 1 >>> 0) switch$0 = 1; else switch$1 = 1;
       if(switch$1){var _ae_ = 1; switch$0 = 2;}
      }
      else
       if(11 <= match){
        if(13 === match) switch$0 = 1;
       }
       else if(8 <= match) switch$0 = 1;
      switch(switch$0){
        case 0:
         var _ae_ = 4; break;
        case 1:
         var _ae_ = 2; break;
      }
      n[1] = n[1] + _ae_ | 0;
      var _af_ = i$0 + 1 | 0;
      if(_$_ !== i$0){var i$0 = _af_; continue;}
      break;
     }
    }
    if(n[1] === caml_ml_bytes_length(s)) return s;
    var s$0 = caml_create_bytes(n[1]);
    n[1] = 0;
    var _ab_ = caml_ml_bytes_length(s) - 1 | 0, _aa_ = 0;
    if(_ab_ >= 0){
     var i = _aa_;
     for(;;){
      var c = caml_bytes_unsafe_get(s, i), switch$2 = 0;
      if(35 <= c)
       if(92 === c)
        switch$2 = 2;
       else if(127 <= c) switch$2 = 1; else switch$2 = 3;
      else if(32 <= c)
       if(34 <= c) switch$2 = 2; else switch$2 = 3;
      else if(14 <= c)
       switch$2 = 1;
      else
       switch(c){
         case 8:
          caml_bytes_unsafe_set(s$0, n[1], 92);
          n[1]++;
          caml_bytes_unsafe_set(s$0, n[1], 98);
          break;
         case 9:
          caml_bytes_unsafe_set(s$0, n[1], 92);
          n[1]++;
          caml_bytes_unsafe_set(s$0, n[1], 116);
          break;
         case 10:
          caml_bytes_unsafe_set(s$0, n[1], 92);
          n[1]++;
          caml_bytes_unsafe_set(s$0, n[1], 110);
          break;
         case 13:
          caml_bytes_unsafe_set(s$0, n[1], 92);
          n[1]++;
          caml_bytes_unsafe_set(s$0, n[1], 114);
          break;
         default: switch$2 = 1;
       }
      switch(switch$2){
        case 1:
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], 48 + (c / 100 | 0) | 0);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], 48 + (c % 10 | 0) | 0);
         break;
        case 2:
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], c);
         break;
        case 3:
         caml_bytes_unsafe_set(s$0, n[1], c); break;
      }
      n[1]++;
      var _ac_ = i + 1 | 0;
      if(_ab_ !== i){var i = _ac_; continue;}
      break;
     }
    }
    return s$0;
   }
   function escaped(b){var b$0 = copy(b); return unsafe_escape(b$0);}
   function map(f, s){
    var l = caml_ml_bytes_length(s);
    if(0 === l) return s;
    var r = caml_create_bytes(l), _Y_ = l - 1 | 0, _X_ = 0;
    if(_Y_ >= 0){
     var i = _X_;
     for(;;){
      caml_bytes_unsafe_set(r, i, caml_call1(f, caml_bytes_unsafe_get(s, i)));
      var _Z_ = i + 1 | 0;
      if(_Y_ !== i){var i = _Z_; continue;}
      break;
     }
    }
    return r;
   }
   function mapi(f, s){
    var l = caml_ml_bytes_length(s);
    if(0 === l) return s;
    var r = caml_create_bytes(l), _V_ = l - 1 | 0, _U_ = 0;
    if(_V_ >= 0){
     var i = _U_;
     for(;;){
      caml_bytes_unsafe_set
       (r, i, caml_call2(f, i, caml_bytes_unsafe_get(s, i)));
      var _W_ = i + 1 | 0;
      if(_V_ !== i){var i = _W_; continue;}
      break;
     }
    }
    return r;
   }
   function fold_left(f, x, a){
    var r = [0, x], _S_ = caml_ml_bytes_length(a) - 1 | 0, _R_ = 0;
    if(_S_ >= 0){
     var i = _R_;
     for(;;){
      r[1] = caml_call2(f, r[1], caml_bytes_unsafe_get(a, i));
      var _T_ = i + 1 | 0;
      if(_S_ !== i){var i = _T_; continue;}
      break;
     }
    }
    return r[1];
   }
   function fold_right(f, a, x){
    var r = [0, x], _P_ = caml_ml_bytes_length(a) - 1 | 0;
    if(_P_ >= 0){
     var i = _P_;
     for(;;){
      r[1] = caml_call2(f, caml_bytes_unsafe_get(a, i), r[1]);
      var _Q_ = i - 1 | 0;
      if(0 !== i){var i = _Q_; continue;}
      break;
     }
    }
    return r[1];
   }
   function exists(p, s){
    var n = caml_ml_bytes_length(s), i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, caml_bytes_unsafe_get(s, i))) return 1;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function for_all(p, s){
    var n = caml_ml_bytes_length(s), i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, caml_bytes_unsafe_get(s, i))) return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function uppercase_ascii(s){return map(Stdlib_Char[4], s);}
   function lowercase_ascii(s){return map(Stdlib_Char[3], s);}
   function apply1(f, s){
    if(0 === caml_ml_bytes_length(s)) return s;
    var r = copy(s);
    caml_bytes_unsafe_set(r, 0, caml_call1(f, caml_bytes_unsafe_get(s, 0)));
    return r;
   }
   function capitalize_ascii(s){return apply1(Stdlib_Char[4], s);}
   function uncapitalize_ascii(s){return apply1(Stdlib_Char[3], s);}
   function starts_with(prefix, s){
    var
     len_s = caml_ml_bytes_length(s),
     len_pre = caml_ml_bytes_length(prefix),
     _O_ = len_pre <= len_s ? 1 : 0;
    if(! _O_) return _O_;
    var i = 0;
    for(;;){
     if(i === len_pre) return 1;
     if(caml_bytes_unsafe_get(s, i) !== caml_bytes_unsafe_get(prefix, i))
      return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function ends_with(suffix, s){
    var
     len_s = caml_ml_bytes_length(s),
     len_suf = caml_ml_bytes_length(suffix),
     diff = len_s - len_suf | 0,
     _N_ = 0 <= diff ? 1 : 0;
    if(! _N_) return _N_;
    var i = 0;
    for(;;){
     if(i === len_suf) return 1;
     if
      (caml_bytes_unsafe_get(s, diff + i | 0)
       !== caml_bytes_unsafe_get(suffix, i))
      return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function index_rec(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_bytes_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 + 1 | 0, i$0 = i$1;
    }
   }
   function index(s, c){return index_rec(s, caml_ml_bytes_length(s), 0, c);}
   function index_rec_opt(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) return 0;
     if(caml_bytes_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 + 1 | 0, i$0 = i$1;
    }
   }
   function index_opt(s, c){
    return index_rec_opt(s, caml_ml_bytes_length(s), 0, c);
   }
   function index_from(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i) return index_rec(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_Bytes_in);
   }
   function index_from_opt(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i) return index_rec_opt(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_opt_Byte);
   }
   function rindex_rec(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_bytes_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 - 1 | 0, i$0 = i$1;
    }
   }
   function rindex(s, c){
    return rindex_rec(s, caml_ml_bytes_length(s) - 1 | 0, c);
   }
   function rindex_from(s, i, c){
    if(-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_Bytes_r);
   }
   function rindex_rec_opt(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) return 0;
     if(caml_bytes_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 - 1 | 0, i$0 = i$1;
    }
   }
   function rindex_opt(s, c){
    return rindex_rec_opt(s, caml_ml_bytes_length(s) - 1 | 0, c);
   }
   function rindex_from_opt(s, i, c){
    if(-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec_opt(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_opt_Byt);
   }
   function contains_from(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i)
     try{index_rec(s, l, i, c); var _L_ = 1; return _L_;}
     catch(_M_){
      var _K_ = caml_wrap_exception(_M_);
      if(_K_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_K_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_contains_from_Bytes);
   }
   function contains(s, c){return contains_from(s, 0, c);}
   function rcontains_from(s, i, c){
    if(0 <= i && caml_ml_bytes_length(s) > i)
     try{rindex_rec(s, i, c); var _I_ = 1; return _I_;}
     catch(_J_){
      var _H_ = caml_wrap_exception(_J_);
      if(_H_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_H_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_rcontains_from_Byte);
   }
   var compare = runtime.caml_bytes_compare;
   function split_on_char(sep, s){
    var
     r = [0, 0],
     j = [0, caml_ml_bytes_length(s)],
     _D_ = caml_ml_bytes_length(s) - 1 | 0;
    if(_D_ >= 0){
     var i = _D_;
     for(;;){
      if(caml_bytes_unsafe_get(s, i) === sep){
       var _F_ = r[1];
       r[1] = [0, sub(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _F_];
       j[1] = i;
      }
      var _G_ = i - 1 | 0;
      if(0 !== i){var i = _G_; continue;}
      break;
     }
    }
    var _E_ = r[1];
    return [0, sub(s, 0, j[1]), _E_];
   }
   function to_seq(s){
    function aux(i, param){
     if(i === caml_ml_bytes_length(s)) return 0;
     var x = caml_bytes_get(s, i), _B_ = i + 1 | 0;
     return [0, x, function(_C_){return aux(_B_, _C_);}];
    }
    var _z_ = 0;
    return function(_A_){return aux(_z_, _A_);};
   }
   function to_seqi(s){
    function aux(i, param){
     if(i === caml_ml_bytes_length(s)) return 0;
     var x = caml_bytes_get(s, i), _x_ = i + 1 | 0;
     return [0, [0, i, x], function(_y_){return aux(_x_, _y_);}];
    }
    var _v_ = 0;
    return function(_w_){return aux(_v_, _w_);};
   }
   function of_seq(i){
    var n = [0, 0], buf = [0, make(256, 0)];
    function _u_(c){
     if(n[1] === caml_ml_bytes_length(buf[1])){
      var
       new_len =
         caml_call2
          (Stdlib_Int[10],
           2 * caml_ml_bytes_length(buf[1]) | 0,
           Stdlib_Sys[12]);
      if(caml_ml_bytes_length(buf[1]) === new_len)
       caml_call1(Stdlib[2], cst_Bytes_of_seq_cannot_grow_b);
      var new_buf = make(new_len, 0);
      blit(buf[1], 0, new_buf, 0, n[1]);
      buf[1] = new_buf;
     }
     caml_bytes_set(buf[1], n[1], c);
     n[1]++;
     return 0;
    }
    caml_call2(Stdlib_Seq[4], _u_, i);
    return sub(buf[1], 0, n[1]);
   }
   function unsafe_get_uint16_le(b, i){
    return Stdlib_Sys[11]
            ? caml_bswap16(caml_bytes_get16(b, i))
            : caml_bytes_get16(b, i);
   }
   function unsafe_get_uint16_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get16(b, i)
            : caml_bswap16(caml_bytes_get16(b, i));
   }
   function get_int8(b, i){
    var _s_ = Stdlib_Sys[10] - 8 | 0, _t_ = Stdlib_Sys[10] - 8 | 0;
    return caml_bytes_get(b, i) << _t_ >> _s_;
   }
   function get_uint16_le(b, i){
    return Stdlib_Sys[11]
            ? caml_bswap16(caml_bytes_get16(b, i))
            : caml_bytes_get16(b, i);
   }
   function get_uint16_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get16(b, i)
            : caml_bswap16(caml_bytes_get16(b, i));
   }
   function get_int16_ne(b, i){
    var _q_ = Stdlib_Sys[10] - 16 | 0, _r_ = Stdlib_Sys[10] - 16 | 0;
    return caml_bytes_get16(b, i) << _r_ >> _q_;
   }
   function get_int16_le(b, i){
    var _o_ = Stdlib_Sys[10] - 16 | 0, _p_ = Stdlib_Sys[10] - 16 | 0;
    return get_uint16_le(b, i) << _p_ >> _o_;
   }
   function get_int16_be(b, i){
    var _m_ = Stdlib_Sys[10] - 16 | 0, _n_ = Stdlib_Sys[10] - 16 | 0;
    return get_uint16_be(b, i) << _n_ >> _m_;
   }
   function get_int32_le(b, i){
    return Stdlib_Sys[11]
            ? caml_int32_bswap(caml_bytes_get32(b, i))
            : caml_bytes_get32(b, i);
   }
   function get_int32_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get32(b, i)
            : caml_int32_bswap(caml_bytes_get32(b, i));
   }
   function get_int64_le(b, i){
    return Stdlib_Sys[11]
            ? caml_int64_bswap(caml_bytes_get64(b, i))
            : caml_bytes_get64(b, i);
   }
   function get_int64_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get64(b, i)
            : caml_int64_bswap(caml_bytes_get64(b, i));
   }
   function unsafe_set_uint16_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, caml_bswap16(x))
            : caml_bytes_set16(b, i, x);
   }
   function unsafe_set_uint16_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, x)
            : caml_bytes_set16(b, i, caml_bswap16(x));
   }
   function set_int16_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, caml_bswap16(x))
            : caml_bytes_set16(b, i, x);
   }
   function set_int16_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, x)
            : caml_bytes_set16(b, i, caml_bswap16(x));
   }
   function set_int32_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set32(b, i, caml_int32_bswap(x))
            : caml_bytes_set32(b, i, x);
   }
   function set_int32_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set32(b, i, x)
            : caml_bytes_set32(b, i, caml_int32_bswap(x));
   }
   function set_int64_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set64(b, i, caml_int64_bswap(x))
            : caml_bytes_set64(b, i, x);
   }
   function set_int64_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set64(b, i, x)
            : caml_bytes_set64(b, i, caml_int64_bswap(x));
   }
   var
    set_uint8 = caml_bytes_set,
    set_uint16_ne = caml_bytes_set16,
    dec_invalid = Stdlib_Uchar[22];
   function dec_ret(n, u){
    var _l_ = caml_call1(Stdlib_Uchar[9], u);
    return caml_call2(Stdlib_Uchar[21], n, _l_);
   }
   function not_in_x80_to_xBF(b){return 2 !== (b >>> 6 | 0) ? 1 : 0;}
   function not_in_xA0_to_xBF(b){return 5 !== (b >>> 5 | 0) ? 1 : 0;}
   function not_in_x80_to_x9F(b){return 4 !== (b >>> 5 | 0) ? 1 : 0;}
   function not_in_x90_to_xBF(b){
    var _j_ = b < 144 ? 1 : 0, _k_ = _j_ || (191 < b ? 1 : 0);
    return _k_;
   }
   function not_in_x80_to_x8F(b){return 8 !== (b >>> 4 | 0) ? 1 : 0;}
   function utf_8_uchar_3(b0, b1, b2){
    return (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
   }
   function utf_8_uchar_4(b0, b1, b2, b3){
    return (b0 & 7) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
   }
   function get_utf_8_uchar(b, i){
    var b0 = caml_bytes_get(b, i), max = caml_ml_bytes_length(b) - 1 | 0;
    if(224 <= b0){
     var switch$0 = 0;
     if(237 <= b0){
      if(245 > b0)
       switch(b0 - 237 | 0){
         case 0:
          var i$0 = i + 1 | 0;
          if(max < i$0) return caml_call1(dec_invalid, 1);
          var b1 = caml_bytes_unsafe_get(b, i$0);
          if(not_in_x80_to_x9F(b1)) return caml_call1(dec_invalid, 1);
          var i$1 = i$0 + 1 | 0;
          if(max < i$1) return caml_call1(dec_invalid, 2);
          var b2 = caml_bytes_unsafe_get(b, i$1);
          return not_in_x80_to_xBF(b2)
                  ? caml_call1(dec_invalid, 2)
                  : dec_ret(3, utf_8_uchar_3(b0, b1, b2));
         case 3:
          var i$4 = i + 1 | 0;
          if(max < i$4) return caml_call1(dec_invalid, 1);
          var b1$1 = caml_bytes_unsafe_get(b, i$4);
          if(not_in_x90_to_xBF(b1$1)) return caml_call1(dec_invalid, 1);
          var i$5 = i$4 + 1 | 0;
          if(max < i$5) return caml_call1(dec_invalid, 2);
          var b2$1 = caml_bytes_unsafe_get(b, i$5);
          if(not_in_x80_to_xBF(b2$1)) return caml_call1(dec_invalid, 2);
          var i$6 = i$5 + 1 | 0;
          if(max < i$6) return caml_call1(dec_invalid, 3);
          var b3 = caml_bytes_unsafe_get(b, i$6);
          return not_in_x80_to_xBF(b3)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$1, b2$1, b3));
         case 7:
          var i$10 = i + 1 | 0;
          if(max < i$10) return caml_call1(dec_invalid, 1);
          var b1$3 = caml_bytes_unsafe_get(b, i$10);
          if(not_in_x80_to_x8F(b1$3)) return caml_call1(dec_invalid, 1);
          var i$11 = i$10 + 1 | 0;
          if(max < i$11) return caml_call1(dec_invalid, 2);
          var b2$3 = caml_bytes_unsafe_get(b, i$11);
          if(not_in_x80_to_xBF(b2$3)) return caml_call1(dec_invalid, 2);
          var i$12 = i$11 + 1 | 0;
          if(max < i$12) return caml_call1(dec_invalid, 3);
          var b3$1 = caml_bytes_unsafe_get(b, i$12);
          return not_in_x80_to_xBF(b3$1)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$3, b2$3, b3$1));
         case 1:
         case 2:
          switch$0 = 1; break;
         default:
          var i$7 = i + 1 | 0;
          if(max < i$7) return caml_call1(dec_invalid, 1);
          var b1$2 = caml_bytes_unsafe_get(b, i$7);
          if(not_in_x80_to_xBF(b1$2)) return caml_call1(dec_invalid, 1);
          var i$8 = i$7 + 1 | 0;
          if(max < i$8) return caml_call1(dec_invalid, 2);
          var b2$2 = caml_bytes_unsafe_get(b, i$8);
          if(not_in_x80_to_xBF(b2$2)) return caml_call1(dec_invalid, 2);
          var i$9 = i$8 + 1 | 0;
          if(max < i$9) return caml_call1(dec_invalid, 3);
          var b3$0 = caml_bytes_unsafe_get(b, i$9);
          return not_in_x80_to_xBF(b3$0)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$2, b2$2, b3$0));
       }
     }
     else{
      if(225 > b0){
       var i$13 = i + 1 | 0;
       if(max < i$13) return caml_call1(dec_invalid, 1);
       var b1$4 = caml_bytes_unsafe_get(b, i$13);
       if(not_in_xA0_to_xBF(b1$4)) return caml_call1(dec_invalid, 1);
       var i$14 = i$13 + 1 | 0;
       if(max < i$14) return caml_call1(dec_invalid, 2);
       var b2$4 = caml_bytes_unsafe_get(b, i$14);
       return not_in_x80_to_xBF(b2$4)
               ? caml_call1(dec_invalid, 2)
               : dec_ret(3, utf_8_uchar_3(b0, b1$4, b2$4));
      }
      switch$0 = 1;
     }
     if(switch$0){
      var i$2 = i + 1 | 0;
      if(max < i$2) return caml_call1(dec_invalid, 1);
      var b1$0 = caml_bytes_unsafe_get(b, i$2);
      if(not_in_x80_to_xBF(b1$0)) return caml_call1(dec_invalid, 1);
      var i$3 = i$2 + 1 | 0;
      if(max < i$3) return caml_call1(dec_invalid, 2);
      var b2$0 = caml_bytes_unsafe_get(b, i$3);
      return not_in_x80_to_xBF(b2$0)
              ? caml_call1(dec_invalid, 2)
              : dec_ret(3, utf_8_uchar_3(b0, b1$0, b2$0));
     }
    }
    else{
     if(128 > b0) return dec_ret(1, b0);
     if(194 <= b0){
      var i$15 = i + 1 | 0;
      if(max < i$15) return caml_call1(dec_invalid, 1);
      var b1$5 = caml_bytes_unsafe_get(b, i$15);
      return not_in_x80_to_xBF(b1$5)
              ? caml_call1(dec_invalid, 1)
              : dec_ret(2, (b0 & 31) << 6 | b1$5 & 63);
     }
    }
    return caml_call1(dec_invalid, 1);
   }
   function set_utf_8_uchar(b, i, u){
    function set(_i_, _h_, _g_){
     caml_bytes_unsafe_set(_i_, _h_, _g_);
     return 0;
    }
    var
     max = caml_ml_bytes_length(b) - 1 | 0,
     u$0 = caml_call1(Stdlib_Uchar[10], u);
    if(0 > u$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(127 >= u$0){caml_bytes_set(b, i, u$0); return 1;}
    if(2047 >= u$0){
     var last$1 = i + 1 | 0;
     return max < last$1
             ? 0
             : (caml_bytes_set
                (b, i, 192 | u$0 >>> 6 | 0),
               set(b, last$1, 128 | u$0 & 63),
               2);
    }
    if(65535 >= u$0){
     var last$0 = i + 2 | 0;
     return max < last$0
             ? 0
             : (caml_bytes_set
                (b, i, 224 | u$0 >>> 12 | 0),
               set(b, i + 1 | 0, 128 | (u$0 >>> 6 | 0) & 63),
               set(b, last$0, 128 | u$0 & 63),
               3);
    }
    if(1114111 < u$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var last = i + 3 | 0;
    return max < last
            ? 0
            : (caml_bytes_set
               (b, i, 240 | u$0 >>> 18 | 0),
              set(b, i + 1 | 0, 128 | (u$0 >>> 12 | 0) & 63),
              set(b, i + 2 | 0, 128 | (u$0 >>> 6 | 0) & 63),
              set(b, last, 128 | u$0 & 63),
              4);
   }
   function is_valid_utf_8(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     var match = caml_bytes_unsafe_get(b, i);
     if(224 <= match){
      var switch$0 = 0;
      if(237 <= match){
       if(245 > match)
        switch(match - 237 | 0){
          case 0:
           var last = i + 2 | 0;
           if
            (max >= last
             &&
              !
              not_in_x80_to_x9F(caml_bytes_unsafe_get(b, i + 1 | 0))
              && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last))){var i$0 = last + 1 | 0, i = i$0; continue;}
           return 0;
          case 3:
           var last$1 = i + 3 | 0;
           if
            (max >= last$1
             &&
              !
              not_in_x90_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$1))){var i$2 = last$1 + 1 | 0, i = i$2; continue;}
           return 0;
          case 7:
           var last$3 = i + 3 | 0;
           if
            (max >= last$3
             &&
              !
              not_in_x80_to_x8F(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$3))){var i$4 = last$3 + 1 | 0, i = i$4; continue;}
           return 0;
          case 1:
          case 2:
           switch$0 = 1; break;
          default:
           var last$2 = i + 3 | 0;
           if
            (max >= last$2
             &&
              !
              not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$2))){var i$3 = last$2 + 1 | 0, i = i$3; continue;}
           return 0;
        }
      }
      else{
       if(225 > match){
        var last$4 = i + 2 | 0;
        if
         (max >= last$4
          &&
           !
           not_in_xA0_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
           && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$4))){var i$5 = last$4 + 1 | 0, i = i$5; continue;}
        return 0;
       }
       switch$0 = 1;
      }
      if(switch$0){
       var last$0 = i + 2 | 0;
       if
        (max >= last$0
         &&
          !
          not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
          && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$0))){var i$1 = last$0 + 1 | 0, i = i$1; continue;}
       return 0;
      }
     }
     else{
      if(128 > match){var i$7 = i + 1 | 0, i = i$7; continue;}
      if(194 <= match){
       var last$5 = i + 1 | 0;
       if
        (max >= last$5
         && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$5))){var i$6 = last$5 + 1 | 0, i = i$6; continue;}
       return 0;
      }
     }
     return 0;
    }
   }
   function get_utf_16be_uchar(b, i){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     if(i === max) return caml_call1(dec_invalid, 1);
     var hi = unsafe_get_uint16_be(b, i);
     if(55296 <= hi && 57343 >= hi){
      if(56319 < hi) return caml_call1(dec_invalid, 2);
      var last = i + 3 | 0;
      if(max < last) return caml_call1(dec_invalid, (max - i | 0) + 1 | 0);
      var lo = unsafe_get_uint16_be(b, i + 2 | 0);
      if(56320 <= lo && 57343 >= lo){
       var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
       return dec_ret(4, u);
      }
      return caml_call1(dec_invalid, 2);
     }
     return dec_ret(2, hi);
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds);
   }
   function set_utf_16be_uchar(b, i, u){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     var u$0 = caml_call1(Stdlib_Uchar[10], u);
     if(0 > u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     if(65535 >= u$0){
      var last$0 = i + 1 | 0;
      return max < last$0 ? 0 : (unsafe_set_uint16_be(b, i, u$0), 2);
     }
     if(1114111 < u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     var last = i + 3 | 0;
     if(max < last) return 0;
     var
      u$1 = u$0 - 65536 | 0,
      hi = 55296 | u$1 >>> 10 | 0,
      lo = 56320 | u$1 & 1023;
     unsafe_set_uint16_be(b, i, hi);
     unsafe_set_uint16_be(b, i + 2 | 0, lo);
     return 4;
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$0);
   }
   function is_valid_utf_16be(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     if(i === max) return 0;
     var u = unsafe_get_uint16_be(b, i);
     if(55296 <= u && 57343 >= u){
      if(56319 < u) return 0;
      var last = i + 3 | 0;
      if(max < last) return 0;
      var u$0 = unsafe_get_uint16_be(b, i + 2 | 0);
      if(56320 <= u$0 && 57343 >= u$0){
       var i$1 = i + 4 | 0, i = i$1;
       continue;
      }
      return 0;
     }
     var i$0 = i + 2 | 0, i = i$0;
    }
   }
   function get_utf_16le_uchar(b, i){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     if(i === max) return caml_call1(dec_invalid, 1);
     var hi = unsafe_get_uint16_le(b, i);
     if(55296 <= hi && 57343 >= hi){
      if(56319 < hi) return caml_call1(dec_invalid, 2);
      var last = i + 3 | 0;
      if(max < last) return caml_call1(dec_invalid, (max - i | 0) + 1 | 0);
      var lo = unsafe_get_uint16_le(b, i + 2 | 0);
      if(56320 <= lo && 57343 >= lo){
       var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
       return dec_ret(4, u);
      }
      return caml_call1(dec_invalid, 2);
     }
     return dec_ret(2, hi);
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$1);
   }
   function set_utf_16le_uchar(b, i, u){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     var u$0 = caml_call1(Stdlib_Uchar[10], u);
     if(0 > u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     if(65535 >= u$0){
      var last$0 = i + 1 | 0;
      return max < last$0 ? 0 : (unsafe_set_uint16_le(b, i, u$0), 2);
     }
     if(1114111 < u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
     var last = i + 3 | 0;
     if(max < last) return 0;
     var
      u$1 = u$0 - 65536 | 0,
      hi = 55296 | u$1 >>> 10 | 0,
      lo = 56320 | u$1 & 1023;
     unsafe_set_uint16_le(b, i, hi);
     unsafe_set_uint16_le(b, i + 2 | 0, lo);
     return 4;
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$2);
   }
   function is_valid_utf_16le(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     if(i === max) return 0;
     var u = unsafe_get_uint16_le(b, i);
     if(55296 <= u && 57343 >= u){
      if(56319 < u) return 0;
      var last = i + 3 | 0;
      if(max < last) return 0;
      var u$0 = unsafe_get_uint16_le(b, i + 2 | 0);
      if(56320 <= u$0 && 57343 >= u$0){
       var i$1 = i + 4 | 0, i = i$1;
       continue;
      }
      return 0;
     }
     var i$0 = i + 2 | 0, i = i$0;
    }
   }
   var
    Stdlib_Bytes =
      [0,
       make,
       init,
       empty,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit_string,
       concat,
       cat,
       iter,
       iteri,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       compare,
       runtime.caml_bytes_equal,
       starts_with,
       ends_with,
       caml_string_of_bytes,
       caml_bytes_of_string,
       split_on_char,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       set_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       set_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       set_utf_16le_uchar,
       is_valid_utf_16le,
       caml_bytes_get,
       get_int8,
       caml_bytes_get16,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       caml_bytes_get32,
       get_int32_be,
       get_int32_le,
       caml_bytes_get64,
       get_int64_be,
       get_int64_le,
       set_uint8,
       caml_bytes_set,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       caml_bytes_set16,
       set_int16_be,
       set_int16_le,
       caml_bytes_set32,
       set_int32_be,
       set_int32_le,
       caml_bytes_set64,
       set_int64_be,
       set_int64_le,
       unsafe_escape];
   runtime.caml_register_global(30, Stdlib_Bytes, "Stdlib__Bytes");
   return;
  }
  (globalThis));

//# 4733 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "",
    caml_blit_string = runtime.caml_blit_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_hash = runtime.caml_string_hash,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    empty = cst$0,
    Stdlib = global_data.Stdlib,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    bts = Stdlib_Bytes[44],
    bos = Stdlib_Bytes[45],
    cst_String_rcontains_from_Byte =
      "String.rcontains_from / Bytes.rcontains_from",
    cst_String_contains_from_Bytes =
      "String.contains_from / Bytes.contains_from",
    cst_String_rindex_from_opt_Byt =
      "String.rindex_from_opt / Bytes.rindex_from_opt",
    cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from",
    cst_String_index_from_opt_Byte =
      "String.index_from_opt / Bytes.index_from_opt",
    cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from",
    cst_String_concat = "String.concat";
   function make(n, c){
    return caml_call1(bts, caml_call2(Stdlib_Bytes[1], n, c));
   }
   function init(n, f){
    return caml_call1(bts, caml_call2(Stdlib_Bytes[2], n, f));
   }
   var of_bytes = Stdlib_Bytes[6], to_bytes = Stdlib_Bytes[5];
   function sub(s, ofs, len){
    var _X_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call3(Stdlib_Bytes[7], _X_, ofs, len));
   }
   var blit = Stdlib_Bytes[12];
   function concat(sep, l){
    if(! l) return cst;
    var seplen = caml_ml_string_length(sep), acc = 0, param = l, pos$1 = 0;
    for(;;){
     if(param){
      var hd = param[1];
      if(param[2]){
       var
        tl = param[2],
        x = (caml_ml_string_length(hd) + seplen | 0) + acc | 0,
        acc$0 = acc <= x ? x : caml_call1(Stdlib[1], cst_String_concat),
        acc = acc$0,
        param = tl;
       continue;
      }
      var _W_ = caml_ml_string_length(hd) + acc | 0;
     }
     else
      var _W_ = acc;
     var dst = runtime.caml_create_bytes(_W_), pos = pos$1, param$0 = l;
     for(;;){
      if(param$0){
       var hd$0 = param$0[1];
       if(param$0[2]){
        var tl$0 = param$0[2];
        caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
        caml_blit_string
         (sep, 0, dst, pos + caml_ml_string_length(hd$0) | 0, seplen);
        var
         pos$0 = (pos + caml_ml_string_length(hd$0) | 0) + seplen | 0,
         pos = pos$0,
         param$0 = tl$0;
        continue;
       }
       caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
      }
      return caml_call1(bts, dst);
     }
    }
   }
   var cat = Stdlib[28];
   function iter(f, s){
    var _U_ = caml_ml_string_length(s) - 1 | 0, _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      caml_call1(f, caml_string_unsafe_get(s, i));
      var _V_ = i + 1 | 0;
      if(_U_ !== i){var i = _V_; continue;}
      break;
     }
    }
    return 0;
   }
   function iteri(f, s){
    var _R_ = caml_ml_string_length(s) - 1 | 0, _Q_ = 0;
    if(_R_ >= 0){
     var i = _Q_;
     for(;;){
      caml_call2(f, i, caml_string_unsafe_get(s, i));
      var _S_ = i + 1 | 0;
      if(_R_ !== i){var i = _S_; continue;}
      break;
     }
    }
    return 0;
   }
   function map(f, s){
    var _P_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call2(Stdlib_Bytes[17], f, _P_));
   }
   function mapi(f, s){
    var _O_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call2(Stdlib_Bytes[18], f, _O_));
   }
   function fold_right(f, x, a){
    var _N_ = caml_call1(bos, x);
    return caml_call3(Stdlib_Bytes[20], f, _N_, a);
   }
   function fold_left(f, a, x){
    var _M_ = caml_call1(bos, x);
    return caml_call3(Stdlib_Bytes[19], f, a, _M_);
   }
   function exists(f, s){
    var _L_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[22], f, _L_);
   }
   function for_all(f, s){
    var _K_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[21], f, _K_);
   }
   function is_space(param){
    var _J_ = param - 9 | 0, switch$0 = 0;
    if(4 < _J_ >>> 0){
     if(23 === _J_) switch$0 = 1;
    }
    else if(2 !== _J_) switch$0 = 1;
    return switch$0 ? 1 : 0;
   }
   function trim(s){
    if(caml_string_equal(s, cst$0)) return s;
    if
     (!
      is_space(caml_string_unsafe_get(s, 0))
      &&
       !
       is_space(caml_string_unsafe_get(s, caml_ml_string_length(s) - 1 | 0)))
     return s;
    var _I_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[23], _I_));
   }
   function escaped(s){
    var b = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[87], b));
   }
   function index_rec(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_string_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 + 1 | 0, i$0 = i$1;
    }
   }
   function index(s, c){return index_rec(s, caml_ml_string_length(s), 0, c);}
   function index_rec_opt(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) return 0;
     if(caml_string_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 + 1 | 0, i$0 = i$1;
    }
   }
   function index_opt(s, c){
    return index_rec_opt(s, caml_ml_string_length(s), 0, c);
   }
   function index_from(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i) return index_rec(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_Bytes_in);
   }
   function index_from_opt(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i) return index_rec_opt(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_opt_Byte);
   }
   function rindex_rec(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_string_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 - 1 | 0, i$0 = i$1;
    }
   }
   function rindex(s, c){
    return rindex_rec(s, caml_ml_string_length(s) - 1 | 0, c);
   }
   function rindex_from(s, i, c){
    if(-1 <= i && caml_ml_string_length(s) > i) return rindex_rec(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_Bytes_r);
   }
   function rindex_rec_opt(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) return 0;
     if(caml_string_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 - 1 | 0, i$0 = i$1;
    }
   }
   function rindex_opt(s, c){
    return rindex_rec_opt(s, caml_ml_string_length(s) - 1 | 0, c);
   }
   function rindex_from_opt(s, i, c){
    if(-1 <= i && caml_ml_string_length(s) > i)
     return rindex_rec_opt(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_opt_Byt);
   }
   function contains_from(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i)
     try{index_rec(s, l, i, c); var _G_ = 1; return _G_;}
     catch(_H_){
      var _F_ = caml_wrap_exception(_H_);
      if(_F_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_F_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_contains_from_Bytes);
   }
   function contains(s, c){return contains_from(s, 0, c);}
   function rcontains_from(s, i, c){
    if(0 <= i && caml_ml_string_length(s) > i)
     try{rindex_rec(s, i, c); var _D_ = 1; return _D_;}
     catch(_E_){
      var _C_ = caml_wrap_exception(_E_);
      if(_C_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_C_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_rcontains_from_Byte);
   }
   function uppercase_ascii(s){
    var _B_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[36], _B_));
   }
   function lowercase_ascii(s){
    var _A_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[37], _A_));
   }
   function capitalize_ascii(s){
    var _z_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[38], _z_));
   }
   function uncapitalize_ascii(s){
    var _y_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[39], _y_));
   }
   function starts_with(prefix, s){
    var
     len_s = caml_ml_string_length(s),
     len_pre = caml_ml_string_length(prefix),
     _x_ = len_pre <= len_s ? 1 : 0;
    if(! _x_) return _x_;
    var i = 0;
    for(;;){
     if(i === len_pre) return 1;
     if(caml_string_unsafe_get(s, i) !== caml_string_unsafe_get(prefix, i))
      return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function ends_with(suffix, s){
    var
     len_s = caml_ml_string_length(s),
     len_suf = caml_ml_string_length(suffix),
     diff = len_s - len_suf | 0,
     _w_ = 0 <= diff ? 1 : 0;
    if(! _w_) return _w_;
    var i = 0;
    for(;;){
     if(i === len_suf) return 1;
     if
      (caml_string_unsafe_get(s, diff + i | 0)
       !== caml_string_unsafe_get(suffix, i))
      return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function hash(x){return caml_string_hash(0, x);}
   function split_on_char(sep, s){
    var
     r = [0, 0],
     j = [0, caml_ml_string_length(s)],
     _s_ = caml_ml_string_length(s) - 1 | 0;
    if(_s_ >= 0){
     var i = _s_;
     for(;;){
      if(caml_string_unsafe_get(s, i) === sep){
       var _u_ = r[1];
       r[1] = [0, sub(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _u_];
       j[1] = i;
      }
      var _v_ = i - 1 | 0;
      if(0 !== i){var i = _v_; continue;}
      break;
     }
    }
    var _t_ = r[1];
    return [0, sub(s, 0, j[1]), _t_];
   }
   var compare = runtime.caml_string_compare;
   function to_seq(s){
    var _r_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[47], _r_);
   }
   function to_seqi(s){
    var _q_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[48], _q_);
   }
   function of_seq(g){
    return caml_call1(bts, caml_call1(Stdlib_Bytes[49], g));
   }
   function get_utf_8_uchar(s, i){
    var _p_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[50], _p_, i);
   }
   function is_valid_utf_8(s){
    var _o_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[52], _o_);
   }
   function get_utf_16be_uchar(s, i){
    var _n_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[53], _n_, i);
   }
   function is_valid_utf_16be(s){
    var _m_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[55], _m_);
   }
   function get_utf_16le_uchar(s, i){
    var _l_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[56], _l_, i);
   }
   function is_valid_utf_16le(s){
    var _k_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[58], _k_);
   }
   function get_int8(s, i){
    var _j_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[60], _j_, i);
   }
   function get_uint16_le(s, i){
    var _i_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[63], _i_, i);
   }
   function get_uint16_be(s, i){
    var _h_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[62], _h_, i);
   }
   function get_int16_ne(s, i){
    var _g_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[64], _g_, i);
   }
   function get_int16_le(s, i){
    var _f_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[66], _f_, i);
   }
   function get_int16_be(s, i){
    var _e_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[65], _e_, i);
   }
   function get_int32_le(s, i){
    var _d_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[69], _d_, i);
   }
   function get_int32_be(s, i){
    var _c_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[68], _c_, i);
   }
   function get_int64_le(s, i){
    var _b_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[72], _b_, i);
   }
   function get_int64_be(s, i){
    var _a_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[71], _a_, i);
   }
   var
    Stdlib_String =
      [0,
       make,
       init,
       empty,
       of_bytes,
       to_bytes,
       concat,
       cat,
       caml_string_equal,
       compare,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       is_valid_utf_16le,
       blit,
       runtime.caml_string_get,
       get_int8,
       runtime.caml_string_get16,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       runtime.caml_string_get32,
       hash,
       caml_string_hash,
       get_int32_be,
       get_int32_le,
       runtime.caml_string_get64,
       get_int64_be,
       get_int64_le];
   runtime.caml_register_global(12, Stdlib_String, "Stdlib__String");
   return;
  }
  (globalThis));

//# 5286 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_array_sub = runtime.caml_array_sub,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Floatarray = [0],
    _a_ = [0, "array.ml", 319, 4],
    cst_Array_combine = "Array.combine",
    cst_Array_exists2 = "Array.exists2",
    cst_Array_for_all2 = "Array.for_all2",
    cst_Array_map2_arrays_must_hav =
      "Array.map2: arrays must have the same length",
    cst_Array_iter2_arrays_must_ha =
      "Array.iter2: arrays must have the same length",
    cst_Array_blit = "Array.blit",
    cst_Array_fill = "Array.fill",
    cst_Array_sub = "Array.sub",
    cst_Array_init = "Array.init",
    cst_Stdlib_Array_Bottom = "Stdlib.Array.Bottom";
   function init(l, f){
    if(0 === l) return [0];
    if(0 > l) return caml_call1(Stdlib[1], cst_Array_init);
    var res = caml_make_vect(l, caml_call1(f, 0)), _as_ = l - 1 | 0, _ar_ = 1;
    if(_as_ >= 1){
     var i = _ar_;
     for(;;){
      res[1 + i] = caml_call1(f, i);
      var _at_ = i + 1 | 0;
      if(_as_ !== i){var i = _at_; continue;}
      break;
     }
    }
    return res;
   }
   function make_matrix(sx, sy, init){
    var res = caml_make_vect(sx, [0]), _ap_ = sx - 1 | 0, _ao_ = 0;
    if(_ap_ >= 0){
     var x = _ao_;
     for(;;){
      res[1 + x] = caml_make_vect(sy, init);
      var _aq_ = x + 1 | 0;
      if(_ap_ !== x){var x = _aq_; continue;}
      break;
     }
    }
    return res;
   }
   function copy(a){
    var l = a.length - 1;
    return 0 === l ? [0] : caml_array_sub(a, 0, l);
   }
   function append(a1, a2){
    var l1 = a1.length - 1;
    return 0 === l1
            ? copy(a2)
            : 0
              === a2.length - 1
              ? caml_array_sub(a1, 0, l1)
              : runtime.caml_array_append(a1, a2);
   }
   function sub(a, ofs, len){
    if(0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
     return caml_array_sub(a, ofs, len);
    return caml_call1(Stdlib[1], cst_Array_sub);
   }
   function fill(a, ofs, len, v){
    if(0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
     return runtime.caml_array_fill(a, ofs, len, v);
    return caml_call1(Stdlib[1], cst_Array_fill);
   }
   function blit(a1, ofs1, a2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (a1.length - 1 - len | 0) >= ofs1
        && 0 <= ofs2 && (a2.length - 1 - len | 0) >= ofs2)
     return runtime.caml_array_blit(a1, ofs1, a2, ofs2, len);
    return caml_call1(Stdlib[1], cst_Array_blit);
   }
   function iter(f, a){
    var _am_ = a.length - 1 - 1 | 0, _al_ = 0;
    if(_am_ >= 0){
     var i = _al_;
     for(;;){
      caml_call1(f, a[1 + i]);
      var _an_ = i + 1 | 0;
      if(_am_ !== i){var i = _an_; continue;}
      break;
     }
    }
    return 0;
   }
   function iter2(f, a, b){
    if(a.length - 1 !== b.length - 1)
     return caml_call1(Stdlib[1], cst_Array_iter2_arrays_must_ha);
    var _aj_ = a.length - 1 - 1 | 0, _ai_ = 0;
    if(_aj_ >= 0){
     var i = _ai_;
     for(;;){
      caml_call2(f, a[1 + i], b[1 + i]);
      var _ak_ = i + 1 | 0;
      if(_aj_ !== i){var i = _ak_; continue;}
      break;
     }
    }
    return 0;
   }
   function map(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var
     r = caml_make_vect(l, caml_call1(f, a[1])),
     _ag_ = l - 1 | 0,
     _af_ = 1;
    if(_ag_ >= 1){
     var i = _af_;
     for(;;){
      r[1 + i] = caml_call1(f, a[1 + i]);
      var _ah_ = i + 1 | 0;
      if(_ag_ !== i){var i = _ah_; continue;}
      break;
     }
    }
    return r;
   }
   function map2(f, a, b){
    var la = a.length - 1, lb = b.length - 1;
    if(la !== lb)
     return caml_call1(Stdlib[1], cst_Array_map2_arrays_must_hav);
    if(0 === la) return [0];
    var
     r = caml_make_vect(la, caml_call2(f, a[1], b[1])),
     _ad_ = la - 1 | 0,
     _ac_ = 1;
    if(_ad_ >= 1){
     var i = _ac_;
     for(;;){
      r[1 + i] = caml_call2(f, a[1 + i], b[1 + i]);
      var _ae_ = i + 1 | 0;
      if(_ad_ !== i){var i = _ae_; continue;}
      break;
     }
    }
    return r;
   }
   function iteri(f, a){
    var _aa_ = a.length - 1 - 1 | 0, _$_ = 0;
    if(_aa_ >= 0){
     var i = _$_;
     for(;;){
      caml_call2(f, i, a[1 + i]);
      var _ab_ = i + 1 | 0;
      if(_aa_ !== i){var i = _ab_; continue;}
      break;
     }
    }
    return 0;
   }
   function mapi(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var
     r = caml_make_vect(l, caml_call2(f, 0, a[1])),
     _Z_ = l - 1 | 0,
     _Y_ = 1;
    if(_Z_ >= 1){
     var i = _Y_;
     for(;;){
      r[1 + i] = caml_call2(f, i, a[1 + i]);
      var ___ = i + 1 | 0;
      if(_Z_ !== i){var i = ___; continue;}
      break;
     }
    }
    return r;
   }
   function to_list(a){
    var i$1 = a.length - 1 - 1 | 0, i = i$1, res = 0;
    for(;;){
     if(0 > i) return res;
     var res$0 = [0, a[1 + i], res], i$0 = i - 1 | 0, i = i$0, res = res$0;
    }
   }
   function list_length(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(! param$0) return accu$0;
     var
      t = param$0[2],
      accu$1 = accu$0 + 1 | 0,
      accu$0 = accu$1,
      param$0 = t;
    }
   }
   function of_list(l){
    if(! l) return [0];
    var
     tl = l[2],
     hd = l[1],
     a = caml_make_vect(list_length(0, l), hd),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = hd$0;
     var i$0 = i + 1 | 0, i = i$0, param = tl$0;
    }
   }
   function fold_left(f, x, a){
    var r = [0, x], _W_ = a.length - 1 - 1 | 0, _V_ = 0;
    if(_W_ >= 0){
     var i = _V_;
     for(;;){
      r[1] = caml_call2(f, r[1], a[1 + i]);
      var _X_ = i + 1 | 0;
      if(_W_ !== i){var i = _X_; continue;}
      break;
     }
    }
    return r[1];
   }
   function fold_left_map(f, acc, input_array){
    var len = input_array.length - 1;
    if(0 === len) return [0, acc, [0]];
    var
     match = caml_call2(f, acc, input_array[1]),
     elt = match[2],
     acc$0 = match[1],
     output_array = caml_make_vect(len, elt),
     acc$1 = [0, acc$0],
     _T_ = len - 1 | 0,
     _S_ = 1;
    if(_T_ >= 1){
     var i = _S_;
     for(;;){
      var
       match$0 = caml_call2(f, acc$1[1], input_array[1 + i]),
       elt$0 = match$0[2],
       acc$2 = match$0[1];
      acc$1[1] = acc$2;
      output_array[1 + i] = elt$0;
      var _U_ = i + 1 | 0;
      if(_T_ !== i){var i = _U_; continue;}
      break;
     }
    }
    return [0, acc$1[1], output_array];
   }
   function fold_right(f, a, x){
    var r = [0, x], _Q_ = a.length - 1 - 1 | 0;
    if(_Q_ >= 0){
     var i = _Q_;
     for(;;){
      r[1] = caml_call2(f, a[1 + i], r[1]);
      var _R_ = i - 1 | 0;
      if(0 !== i){var i = _R_; continue;}
      break;
     }
    }
    return r[1];
   }
   function exists(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, a[1 + i])) return 1;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function for_all(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, a[1 + i])) return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function for_all2(p, l1, l2){
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if(n1 !== n2) return caml_call1(Stdlib[1], cst_Array_for_all2);
    var i = 0;
    for(;;){
     if(i === n1) return 1;
     if(! caml_call2(p, l1[1 + i], l2[1 + i])) return 0;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function exists2(p, l1, l2){
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if(n1 !== n2) return caml_call1(Stdlib[1], cst_Array_exists2);
    var i = 0;
    for(;;){
     if(i === n1) return 0;
     if(caml_call2(p, l1[1 + i], l2[1 + i])) return 1;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function mem(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(0 === runtime.caml_compare(a[1 + i], x)) return 1;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function memq(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(x === a[1 + i]) return 1;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function find_opt(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var x = a[1 + i];
     if(caml_call1(p, x)) return [0, x];
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function find_map(f, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var r = caml_call1(f, a[1 + i]);
     if(r) return r;
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function split(x){
    if(runtime.caml_equal(x, [0])) return [0, [0], [0]];
    var
     match = x[1],
     b0 = match[2],
     a0 = match[1],
     n = x.length - 1,
     a = caml_make_vect(n, a0),
     b = caml_make_vect(n, b0),
     _O_ = n - 1 | 0,
     _N_ = 1;
    if(_O_ >= 1){
     var i = _N_;
     for(;;){
      var match$0 = x[1 + i], bi = match$0[2], ai = match$0[1];
      a[1 + i] = ai;
      b[1 + i] = bi;
      var _P_ = i + 1 | 0;
      if(_O_ !== i){var i = _P_; continue;}
      break;
     }
    }
    return [0, a, b];
   }
   function combine(a, b){
    var na = a.length - 1, nb = b.length - 1;
    if(na !== nb) caml_call1(Stdlib[1], cst_Array_combine);
    if(0 === na) return [0];
    var x = caml_make_vect(na, [0, a[1], b[1]]), _L_ = na - 1 | 0, _K_ = 1;
    if(_L_ >= 1){
     var i = _K_;
     for(;;){
      x[1 + i] = [0, a[1 + i], b[1 + i]];
      var _M_ = i + 1 | 0;
      if(_L_ !== i){var i = _M_; continue;}
      break;
     }
    }
    return x;
   }
   var Bottom = [248, cst_Stdlib_Array_Bottom, runtime.caml_fresh_oo_id(0)];
   function sort(cmp, a){
    function maxson(l, i){
     var i31 = ((i + i | 0) + i | 0) + 1 | 0, x = [0, i31];
     if((i31 + 2 | 0) < l){
      var _D_ = i31 + 1 | 0, _E_ = caml_check_bound(a, _D_)[1 + _D_];
      if(caml_call2(cmp, caml_check_bound(a, i31)[1 + i31], _E_) < 0)
       x[1] = i31 + 1 | 0;
      var
       _F_ = i31 + 2 | 0,
       _G_ = caml_check_bound(a, _F_)[1 + _F_],
       _H_ = x[1];
      if(caml_call2(cmp, caml_check_bound(a, _H_)[1 + _H_], _G_) < 0)
       x[1] = i31 + 2 | 0;
      return x[1];
     }
     if((i31 + 1 | 0) < l){
      var _I_ = i31 + 1 | 0, _J_ = caml_check_bound(a, _I_)[1 + _I_];
      if(0 > caml_call2(cmp, caml_check_bound(a, i31)[1 + i31], _J_))
       return i31 + 1 | 0;
     }
     if(i31 < l) return i31;
     throw caml_maybe_attach_backtrace([0, Bottom, i], 1);
    }
    var l = a.length - 1, _x_ = ((l + 1 | 0) / 3 | 0) - 1 | 0;
    if(_x_ >= 0){
     var i$6 = _x_;
     for(;;){
      var e$1 = caml_check_bound(a, i$6)[1 + i$6];
      try{
       var i = i$6;
       for(;;){
        var j = maxson(l, i);
        if(0 < caml_call2(cmp, caml_check_bound(a, j)[1 + j], e$1)){
         var _u_ = caml_check_bound(a, j)[1 + j];
         caml_check_bound(a, i)[1 + i] = _u_;
         var i = j;
         continue;
        }
        caml_check_bound(a, i)[1 + i] = e$1;
        break;
       }
      }
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(exn[1] !== Bottom) throw caml_maybe_attach_backtrace(exn, 0);
       var i$0 = exn[2];
       caml_check_bound(a, i$0)[1 + i$0] = e$1;
      }
      var _C_ = i$6 - 1 | 0;
      if(0 !== i$6){var i$6 = _C_; continue;}
      break;
     }
    }
    var _y_ = l - 1 | 0;
    if(_y_ >= 2){
     var i$4 = _y_;
     a:
     for(;;){
      var e$0 = caml_check_bound(a, i$4)[1 + i$4];
      a[1 + i$4] = caml_check_bound(a, 0)[1];
      var i$5 = 0;
      try{
       var i$1 = i$5;
       for(;;){
        var j$0 = maxson(i$4, i$1), _v_ = caml_check_bound(a, j$0)[1 + j$0];
        caml_check_bound(a, i$1)[1 + i$1] = _v_;
        var i$1 = j$0;
       }
      }
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(exn$0[1] !== Bottom) throw caml_maybe_attach_backtrace(exn$0, 0);
       var i$2 = exn$0[2], i$3 = i$2;
       for(;;){
        var father = (i$3 - 1 | 0) / 3 | 0;
        if(i$3 === father)
         throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
        if(0 <= caml_call2(cmp, caml_check_bound(a, father)[1 + father], e$0))
         caml_check_bound(a, i$3)[1 + i$3] = e$0;
        else{
         var _w_ = caml_check_bound(a, father)[1 + father];
         caml_check_bound(a, i$3)[1 + i$3] = _w_;
         if(0 < father){var i$3 = father; continue;}
         caml_check_bound(a, 0)[1] = e$0;
        }
        var _B_ = i$4 - 1 | 0;
        if(2 !== i$4){var i$4 = _B_; continue a;}
        break;
       }
      }
      break;
     }
    }
    var _z_ = 1 < l ? 1 : 0;
    if(_z_){
     var e = caml_check_bound(a, 1)[2];
     a[2] = caml_check_bound(a, 0)[1];
     a[1] = e;
     var _A_ = 0;
    }
    else
     var _A_ = _z_;
    return _A_;
   }
   function stable_sort(cmp, a){
    function merge(src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs){
     var
      src1r = src1ofs + src1len | 0,
      src2r = src2ofs + src2len | 0,
      s2$1 = caml_check_bound(src2, src2ofs)[1 + src2ofs],
      s1$1 = caml_check_bound(a, src1ofs)[1 + src1ofs],
      i1 = src1ofs,
      s1 = s1$1,
      i2 = src2ofs,
      s2 = s2$1,
      d = dstofs;
     for(;;){
      if(0 < caml_call2(cmp, s1, s2)){
       caml_check_bound(dst, d)[1 + d] = s2;
       var i2$0 = i2 + 1 | 0;
       if(i2$0 >= src2r) return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
       var
        d$0 = d + 1 | 0,
        s2$0 = caml_check_bound(src2, i2$0)[1 + i2$0],
        i2 = i2$0,
        s2 = s2$0,
        d = d$0;
       continue;
      }
      caml_check_bound(dst, d)[1 + d] = s1;
      var i1$0 = i1 + 1 | 0;
      if(i1$0 >= src1r) return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
      var
       d$1 = d + 1 | 0,
       s1$0 = caml_check_bound(a, i1$0)[1 + i1$0],
       i1 = i1$0,
       s1 = s1$0,
       d = d$1;
     }
    }
    function isortto(srcofs, dst, dstofs, len){
     var _m_ = len - 1 | 0, _l_ = 0;
     if(_m_ >= 0){
      var i = _l_;
      a:
      for(;;){
       var
        _n_ = srcofs + i | 0,
        e = caml_check_bound(a, _n_)[1 + _n_],
        j = [0, (dstofs + i | 0) - 1 | 0];
       for(;;){
        if(dstofs <= j[1]){
         var _o_ = j[1];
         if(0 < caml_call2(cmp, caml_check_bound(dst, _o_)[1 + _o_], e)){
          var
           _p_ = j[1],
           _q_ = caml_check_bound(dst, _p_)[1 + _p_],
           _r_ = j[1] + 1 | 0;
          caml_check_bound(dst, _r_)[1 + _r_] = _q_;
          j[1] += -1;
          continue;
         }
        }
        var _s_ = j[1] + 1 | 0;
        caml_check_bound(dst, _s_)[1 + _s_] = e;
        var _t_ = i + 1 | 0;
        if(_m_ !== i){var i = _t_; continue a;}
        break;
       }
       break;
      }
     }
     return 0;
    }
    function sortto(srcofs, dst, dstofs, len){
     if(len <= 5) return isortto(srcofs, dst, dstofs, len);
     var l1 = len / 2 | 0, l2 = len - l1 | 0;
     sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
     sortto(srcofs, a, srcofs + l2 | 0, l1);
     return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
    }
    var l = a.length - 1;
    if(l <= 5) return isortto(0, a, 0, l);
    var
     l1 = l / 2 | 0,
     l2 = l - l1 | 0,
     t = caml_make_vect(l2, caml_check_bound(a, 0)[1]);
    sortto(l1, t, 0, l2);
    sortto(0, a, l2, l1);
    return merge(l2, l1, t, 0, l2, a, 0);
   }
   function to_seq(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _j_ = i + 1 | 0;
     return [0, x, function(_k_){return aux(_j_, _k_);}];
    }
    var _h_ = 0;
    return function(_i_){return aux(_h_, _i_);};
   }
   function to_seqi(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _f_ = i + 1 | 0;
     return [0, [0, i, x], function(_g_){return aux(_f_, _g_);}];
    }
    var _d_ = 0;
    return function(_e_){return aux(_d_, _e_);};
   }
   function of_seq(i$2){
    var _b_ = 0;
    function _c_(acc, x){return [0, x, acc];}
    var l = caml_call3(Stdlib_Seq[5], _c_, _b_, i$2);
    if(! l) return [0];
    var
     tl = l[2],
     hd = l[1],
     len = list_length(0, l),
     a = caml_make_vect(len, hd),
     i$1 = len - 2 | 0,
     i = i$1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = hd$0;
     var i$0 = i - 1 | 0, i = i$0, param = tl$0;
    }
   }
   var
    Stdlib_Array =
      [0,
       init,
       make_matrix,
       append,
       runtime.caml_array_concat,
       sub,
       copy,
       fill,
       blit,
       to_list,
       of_list,
       iter,
       iteri,
       map,
       mapi,
       fold_left,
       fold_left_map,
       fold_right,
       iter2,
       map2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find_opt,
       find_map,
       split,
       combine,
       sort,
       stable_sort,
       stable_sort,
       to_seq,
       to_seqi,
       of_seq,
       Floatarray];
   runtime.caml_register_global(14, Stdlib_Array, "Stdlib__Array");
   return;
  }
  (globalThis));

//# 6723 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Assert_failure = global_data.Assert_failure,
    _b_ = [0, "int32.ml", 69, 6],
    zero = 0,
    one = 1,
    minus_one = -1;
   function succ(n){return n + 1 | 0;}
   function pred(n){return n - 1 | 0;}
   function abs(n){return caml_greaterequal(n, 0) ? n : - n | 0;}
   var min_int = -2147483648, max_int = 2147483647;
   function lognot(n){return n ^ -1;}
   var _a_ = Stdlib_Sys[9];
   if(32 === _a_)
    var
     max_int$0 = Stdlib[19],
     unsigned_to_int =
       function(n){
        if(0 >= caml_int_compare(0, n) && 0 >= caml_int_compare(n, max_int$0))
         return [0, n];
        return 0;
       };
   else{
    if(64 !== _a_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var unsigned_to_int = function(n){return [0, n & -1];};
   }
   function to_string(n){return runtime.caml_format_int("%d", n);}
   function of_string_opt(s){
    try{var _d_ = [0, runtime.caml_int_of_string(s)]; return _d_;}
    catch(_e_){
     var _c_ = caml_wrap_exception(_e_);
     if(_c_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_c_, 0);
    }
   }
   var compare = caml_int_compare;
   function equal(x, y){return 0 === caml_int_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    return caml_int_compare(n + 2147483648 | 0, m + 2147483648 | 0);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, 0))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return 0 <= unsigned_compare(r, d) ? q + 1 | 0 : q;
   }
   function unsigned_rem(n, d){
    return n - caml_mul(unsigned_div(n, d), d) | 0;
   }
   var
    Stdlib_Int32 =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max];
   runtime.caml_register_global(14, Stdlib_Int32, "Stdlib__Int32");
   return;
  }
  (globalThis));

//# 6815 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    zero = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    one = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    minus_one = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    min_int = runtime.caml_int64_create_lo_mi_hi(0, 0, 32768),
    max_int = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
    Stdlib = global_data.Stdlib,
    _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0);
   function succ(n){return runtime.caml_int64_add(n, _a_);}
   function pred(n){return caml_int64_sub(n, _b_);}
   function abs(n){
    return caml_greaterequal(n, _c_) ? n : runtime.caml_int64_neg(n);
   }
   function lognot(n){return runtime.caml_int64_xor(n, _d_);}
   var max_int$0 = runtime.caml_int64_of_int32(Stdlib[19]);
   function unsigned_to_int(n){
    if
     (0 >= caml_int64_compare(zero, n)
      && 0 >= caml_int64_compare(n, max_int$0))
     return [0, runtime.caml_int64_to_int32(n)];
    return 0;
   }
   function to_string(n){return runtime.caml_int64_format("%d", n);}
   function of_string_opt(s){
    try{var _f_ = [0, runtime.caml_int64_of_string(s)]; return _f_;}
    catch(_g_){
     var _e_ = caml_wrap_exception(_g_);
     if(_e_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_e_, 0);
    }
   }
   function compare(x, y){return caml_int64_compare(x, y);}
   function equal(x, y){return 0 === caml_int64_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    return caml_int64_compare
            (caml_int64_sub(n, min_int), caml_int64_sub(m, min_int));
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, zero))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var
     q =
       runtime.caml_int64_shift_left
        (runtime.caml_int64_div
          (runtime.caml_int64_shift_right_unsigned(n, 1), d),
         1),
     r = caml_int64_sub(n, caml_int64_mul(q, d));
    return 0 <= unsigned_compare(r, d) ? succ(q) : q;
   }
   function unsigned_rem(n, d){
    return caml_int64_sub(n, caml_int64_mul(unsigned_div(n, d), d));
   }
   var
    Stdlib_Int64 =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max];
   runtime.caml_register_global(11, Stdlib_Int64, "Stdlib__Int64");
   return;
  }
  (globalThis));

//# 6912 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    zero = 0,
    one = 1,
    minus_one = -1;
   function succ(n){return n + 1 | 0;}
   function pred(n){return n - 1 | 0;}
   function abs(n){return caml_greaterequal(n, 0) ? n : - n | 0;}
   var
    size = Stdlib_Sys[9],
    min_int = 1 << (size - 1 | 0),
    max_int = min_int - 1 | 0;
   function lognot(n){return n ^ -1;}
   var max_int$0 = Stdlib[19];
   function unsigned_to_int(n){
    if(0 >= caml_int_compare(0, n) && 0 >= caml_int_compare(n, max_int$0))
     return [0, n];
    return 0;
   }
   function to_string(n){return runtime.caml_format_int("%d", n);}
   function of_string_opt(s){
    try{var _b_ = [0, runtime.caml_int_of_string(s)]; return _b_;}
    catch(_c_){
     var _a_ = caml_wrap_exception(_c_);
     if(_a_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   var compare = caml_int_compare;
   function equal(x, y){return 0 === caml_int_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    return caml_int_compare(n - min_int | 0, m - min_int | 0);
   }
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(runtime.caml_lessthan(d, 0))
     return 0 <= unsigned_compare(n, d) ? one : zero;
    var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return 0 <= unsigned_compare(r, d) ? q + 1 | 0 : q;
   }
   function unsigned_rem(n, d){
    return n - caml_mul(unsigned_div(n, d), d) | 0;
   }
   var
    Stdlib_Nativeint =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       size,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max];
   runtime.caml_register_global(12, Stdlib_Nativeint, "Stdlib__Nativeint");
   return;
  }
  (globalThis));

//# 6997 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    caml_bytes_get = runtime.caml_bytes_get,
    caml_check_bound = runtime.caml_check_bound,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    dummy_pos = [0, cst, 0, 0, -1],
    zero_pos = [0, cst, 1, 0, 0],
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int = global_data.Stdlib__Int,
    cst_Lexing_lex_refill_cannot_g = "Lexing.lex_refill: cannot grow buffer";
   function engine(tbl, state, buf){
    var
     result = runtime.caml_lex_engine(tbl, state, buf),
     _F_ = 0 <= result ? 1 : 0,
     _G_ = _F_ ? buf[12] !== dummy_pos ? 1 : 0 : _F_;
    if(_G_){
     buf[11] = buf[12];
     var _H_ = buf[12];
     buf[12] = [0, _H_[1], _H_[2], _H_[3], buf[4] + buf[6] | 0];
    }
    return result;
   }
   function new_engine(tbl, state, buf){
    var
     result = runtime.caml_new_lex_engine(tbl, state, buf),
     _C_ = 0 <= result ? 1 : 0,
     _D_ = _C_ ? buf[12] !== dummy_pos ? 1 : 0 : _C_;
    if(_D_){
     buf[11] = buf[12];
     var _E_ = buf[12];
     buf[12] = [0, _E_[1], _E_[2], _E_[3], buf[4] + buf[6] | 0];
    }
    return result;
   }
   function from_function(opt, read_fun){
    if(opt)
     var sth = opt[1], with_positions = sth;
    else
     var with_positions = 1;
    var
     _o_ = with_positions ? zero_pos : dummy_pos,
     _p_ = with_positions ? zero_pos : dummy_pos,
     aux_buffer = caml_create_bytes(512),
     _q_ = [0],
     _r_ = 0,
     _s_ = 0,
     _t_ = 0,
     _u_ = 0,
     _v_ = 0,
     _w_ = 0,
     _x_ = 0,
     _y_ = caml_create_bytes(1024);
    return [0,
            function(lexbuf){
             var
              read =
                caml_call2
                 (read_fun, aux_buffer, caml_ml_bytes_length(aux_buffer)),
              n = 0 < read ? read : (lexbuf[9] = 1, 0);
             if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0)){
              if
               (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                <= caml_ml_bytes_length(lexbuf[2]))
               caml_call5
                (Stdlib_Bytes[11],
                 lexbuf[2],
                 lexbuf[5],
                 lexbuf[2],
                 0,
                 lexbuf[3] - lexbuf[5] | 0);
              else{
               var
                newlen =
                  caml_call2
                   (Stdlib_Int[10],
                    2 * caml_ml_bytes_length(lexbuf[2]) | 0,
                    Stdlib_Sys[12]);
               if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                caml_call1(Stdlib[2], cst_Lexing_lex_refill_cannot_g);
               var newbuf = caml_create_bytes(newlen);
               caml_call5
                (Stdlib_Bytes[11],
                 lexbuf[2],
                 lexbuf[5],
                 newbuf,
                 0,
                 lexbuf[3] - lexbuf[5] | 0);
               lexbuf[2] = newbuf;
              }
              var s = lexbuf[5];
              lexbuf[4] = lexbuf[4] + s | 0;
              lexbuf[6] = lexbuf[6] - s | 0;
              lexbuf[5] = 0;
              lexbuf[7] = lexbuf[7] - s | 0;
              lexbuf[3] = lexbuf[3] - s | 0;
              var t = lexbuf[10], _A_ = t.length - 1 - 1 | 0, _z_ = 0;
              if(_A_ >= 0){
               var i = _z_;
               for(;;){
                var v = caml_check_bound(t, i)[1 + i];
                if(0 <= v) caml_check_bound(t, i)[1 + i] = v - s | 0;
                var _B_ = i + 1 | 0;
                if(_A_ !== i){var i = _B_; continue;}
                break;
               }
              }
             }
             caml_call5
              (Stdlib_Bytes[11], aux_buffer, 0, lexbuf[2], lexbuf[3], n);
             lexbuf[3] = lexbuf[3] + n | 0;
             return 0;
            },
            _y_,
            _x_,
            _w_,
            _v_,
            _u_,
            _t_,
            _s_,
            _r_,
            _q_,
            _p_,
            _o_];
   }
   function from_channel(with_positions, ic){
    return from_function
            (with_positions,
             function(buf, n){return caml_call4(Stdlib[84], ic, buf, 0, n);});
   }
   function from_string(opt, s){
    if(opt)
     var sth = opt[1], with_positions = sth;
    else
     var with_positions = 1;
    var
     _d_ = with_positions ? zero_pos : dummy_pos,
     _e_ = with_positions ? zero_pos : dummy_pos,
     _f_ = [0],
     _g_ = 1,
     _h_ = 0,
     _i_ = 0,
     _j_ = 0,
     _k_ = 0,
     _l_ = 0,
     _m_ = runtime.caml_ml_string_length(s),
     _n_ = caml_call1(Stdlib_Bytes[5], s);
    return [0,
            function(lexbuf){lexbuf[9] = 1; return 0;},
            _n_,
            _m_,
            _l_,
            _k_,
            _j_,
            _i_,
            _h_,
            _g_,
            _f_,
            _e_,
            _d_];
   }
   function set_position(lexbuf, position){
    lexbuf[12] = [0, lexbuf[12][1], position[2], position[3], position[4]];
    lexbuf[4] = position[4];
    return 0;
   }
   function set_filename(lexbuf, fname){
    var _c_ = lexbuf[12];
    lexbuf[12] = [0, fname, _c_[2], _c_[3], _c_[4]];
    return 0;
   }
   function with_positions(lexbuf){return lexbuf[12] !== dummy_pos ? 1 : 0;}
   function lexeme(lexbuf){
    var len = lexbuf[6] - lexbuf[5] | 0;
    return caml_call3(Stdlib_Bytes[8], lexbuf[2], lexbuf[5], len);
   }
   function sub_lexeme(lexbuf, i1, i2){
    var len = i2 - i1 | 0;
    return caml_call3(Stdlib_Bytes[8], lexbuf[2], i1, len);
   }
   function sub_lexeme_opt(lexbuf, i1, i2){
    if(0 > i1) return 0;
    var len = i2 - i1 | 0;
    return [0, caml_call3(Stdlib_Bytes[8], lexbuf[2], i1, len)];
   }
   function sub_lexeme_char(lexbuf, i){return caml_bytes_get(lexbuf[2], i);}
   function sub_lexeme_char_opt(lexbuf, i){
    return 0 <= i ? [0, caml_bytes_get(lexbuf[2], i)] : 0;
   }
   function lexeme_char(lexbuf, i){
    return caml_bytes_get(lexbuf[2], lexbuf[5] + i | 0);
   }
   function lexeme_start(lexbuf){return lexbuf[11][4];}
   function lexeme_end(lexbuf){return lexbuf[12][4];}
   function lexeme_start_p(lexbuf){return lexbuf[11];}
   function lexeme_end_p(lexbuf){return lexbuf[12];}
   function new_line(lexbuf){
    var
     lcp = lexbuf[12],
     _a_ = lcp !== dummy_pos ? 1 : 0,
     _b_ =
       _a_
        ? (lexbuf[12] = [0, lcp[1], lcp[2] + 1 | 0, lcp[4], lcp[4]], 0)
        : _a_;
    return _b_;
   }
   function flush_input(lb){
    lb[6] = 0;
    lb[4] = 0;
    var lcp = lb[12];
    if(lcp !== dummy_pos)
     lb[12] = [0, lcp[1], zero_pos[2], zero_pos[3], zero_pos[4]];
    lb[3] = 0;
    return 0;
   }
   var
    Stdlib_Lexing =
      [0,
       dummy_pos,
       from_channel,
       from_string,
       from_function,
       set_position,
       set_filename,
       with_positions,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
   runtime.caml_register_global(7, Stdlib_Lexing, "Stdlib__Lexing");
   return;
  }
  (globalThis));

//# 7276 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Lexing = global_data.Stdlib__Lexing,
    YYexit = [248, "Stdlib.Parsing.YYexit", caml_fresh_oo_id(0)],
    Parse_error = [248, "Stdlib.Parsing.Parse_error", caml_fresh_oo_id(0)],
    env =
      [0,
       caml_make_vect(100, 0),
       caml_make_vect(100, 0),
       caml_make_vect(100, Stdlib_Lexing[1]),
       caml_make_vect(100, Stdlib_Lexing[1]),
       100,
       0,
       0,
       0,
       Stdlib_Lexing[1],
       Stdlib_Lexing[1],
       0,
       0,
       0,
       0,
       0,
       0],
    cst_syntax_error = "syntax error";
   function grow_stacks(param){
    var
     oldsize = env[5],
     newsize = oldsize * 2 | 0,
     new_s = caml_make_vect(newsize, 0),
     new_v = caml_make_vect(newsize, 0),
     new_start = caml_make_vect(newsize, Stdlib_Lexing[1]),
     new_end = caml_make_vect(newsize, Stdlib_Lexing[1]);
    caml_call5(Stdlib_Array[8], env[1], 0, new_s, 0, oldsize);
    env[1] = new_s;
    caml_call5(Stdlib_Array[8], env[2], 0, new_v, 0, oldsize);
    env[2] = new_v;
    caml_call5(Stdlib_Array[8], env[3], 0, new_start, 0, oldsize);
    env[3] = new_start;
    caml_call5(Stdlib_Array[8], env[4], 0, new_end, 0, oldsize);
    env[4] = new_end;
    env[5] = newsize;
    return 0;
   }
   function clear_parser(param){
    caml_call4(Stdlib_Array[7], env[2], 0, env[5], 0);
    env[8] = 0;
    return 0;
   }
   var current_lookahead_fun = [0, function(param){return 0;}];
   function yyparse(tables, start, lexer, lexbuf){
    var
     init_asp = env[11],
     init_sp = env[14],
     init_stackbase = env[6],
     init_state = env[15],
     init_curr_char = env[7],
     init_lval = env[8],
     init_errflag = env[16];
    env[6] = env[14] + 1 | 0;
    env[7] = start;
    env[10] = lexbuf[12];
    try{
     var cmd = 0, arg = 0;
     for(;;)
      switch(runtime.caml_parse_engine(tables, env, cmd, arg)){
        case 0:
         var arg$0 = caml_call1(lexer, lexbuf);
         env[9] = lexbuf[11];
         env[10] = lexbuf[12];
         var cmd = 1, arg = arg$0;
         continue;
        case 1:
         throw caml_maybe_attach_backtrace(Parse_error, 1);
        case 2:
         grow_stacks(0); var cmd = 2, arg = 0; continue;
        case 3:
         grow_stacks(0); var cmd = 3, arg = 0; continue;
        case 4:
         try{
          var
           _i_ = env[13],
           _j_ = caml_call1(caml_check_bound(tables[1], _i_)[1 + _i_], env),
           _k_ = 4,
           value = _j_,
           action = _k_;
         }
         catch(_m_){
          var _h_ = caml_wrap_exception(_m_);
          if(_h_ !== Parse_error) throw caml_maybe_attach_backtrace(_h_, 0);
          var value = 0, action = 5;
         }
         var cmd = action, arg = value;
         continue;
        default:
         caml_call1(tables[14], cst_syntax_error);
         var cmd = 5, arg = 0;
         continue;
      }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), curr_char = env[7];
     env[11] = init_asp;
     env[14] = init_sp;
     env[6] = init_stackbase;
     env[15] = init_state;
     env[7] = init_curr_char;
     env[8] = init_lval;
     env[16] = init_errflag;
     if(exn[1] === YYexit){var v = exn[2]; return v;}
     current_lookahead_fun[1] =
      function(tok){
       if(! caml_call1(Stdlib_Obj[1], tok))
        return caml_check_bound(tables[2], tok)[1 + tok] === curr_char ? 1 : 0;
       var _l_ = runtime.caml_obj_tag(tok);
       return caml_check_bound(tables[3], _l_)[1 + _l_] === curr_char ? 1 : 0;
      };
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function peek_val(env, n){
    var _g_ = env[11] - n | 0;
    return caml_check_bound(env[2], _g_)[1 + _g_];
   }
   function symbol_start_pos(param){
    var i$1 = env[12], i = i$1;
    for(;;){
     if(0 >= i){
      var _f_ = env[11];
      return caml_check_bound(env[4], _f_)[1 + _f_];
     }
     var
      _d_ = (env[11] - i | 0) + 1 | 0,
      st = caml_check_bound(env[3], _d_)[1 + _d_],
      _e_ = (env[11] - i | 0) + 1 | 0,
      en = caml_check_bound(env[4], _e_)[1 + _e_];
     if(runtime.caml_notequal(st, en)) return st;
     var i$0 = i - 1 | 0, i = i$0;
    }
   }
   function symbol_end_pos(param){
    var _c_ = env[11];
    return caml_check_bound(env[4], _c_)[1 + _c_];
   }
   function rhs_start_pos(n){
    var _b_ = env[11] - (env[12] - n | 0) | 0;
    return caml_check_bound(env[3], _b_)[1 + _b_];
   }
   function rhs_end_pos(n){
    var _a_ = env[11] - (env[12] - n | 0) | 0;
    return caml_check_bound(env[4], _a_)[1 + _a_];
   }
   function symbol_start(param){return symbol_start_pos(0)[4];}
   function symbol_end(param){return symbol_end_pos(0)[4];}
   function rhs_start(n){return rhs_start_pos(n)[4];}
   function rhs_end(n){return rhs_end_pos(n)[4];}
   function is_current_lookahead(tok){
    return caml_call1(current_lookahead_fun[1], tok);
   }
   function parse_error(param){return 0;}
   var
    Stdlib_Parsing =
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       runtime.caml_set_parser_trace,
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
   runtime.caml_register_global(7, Stdlib_Parsing, "Stdlib__Parsing");
   return;
  }
  (globalThis));

//# 8297 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Map_bal$3 = "Map.bal",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Seq = global_data.Stdlib__Seq,
    cst_Map_remove_min_elt = "Map.remove_min_elt",
    _a_ = [0, 0, 0, 0],
    _b_ = [0, "map.ml", 400, 10],
    _c_ = [0, 0, 0],
    cst_Map_bal = cst_Map_bal$3,
    cst_Map_bal$0 = cst_Map_bal$3,
    cst_Map_bal$1 = cst_Map_bal$3,
    cst_Map_bal$2 = cst_Map_bal$3,
    Stdlib_Map =
      [0,
       function(Ord){
        function height(param){
         if(! param) return 0;
         var h = param[5];
         return h;
        }
        function create(l, x, d, r){
         var
          hl = height(l),
          hr = height(r),
          _L_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
         return [0, l, x, d, r, _L_];
        }
        function singleton(x, d){return [0, 0, x, d, 0, 1];}
        function bal(l, x, d, r){
         if(l) var h = l[5], hl = h; else var hl = 0;
         if(r) var h$0 = r[5], hr = h$0; else var hr = 0;
         if((hr + 2 | 0) < hl){
          if(! l) return caml_call1(Stdlib[1], cst_Map_bal$0);
          var lr = l[4], ld = l[3], lv = l[2], ll = l[1], _G_ = height(lr);
          if(_G_ <= height(ll))
           return create(ll, lv, ld, create(lr, x, d, r));
          if(! lr) return caml_call1(Stdlib[1], cst_Map_bal);
          var
           lrr = lr[4],
           lrd = lr[3],
           lrv = lr[2],
           lrl = lr[1],
           _H_ = create(lrr, x, d, r);
          return create(create(ll, lv, ld, lrl), lrv, lrd, _H_);
         }
         if((hl + 2 | 0) >= hr){
          var _K_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
          return [0, l, x, d, r, _K_];
         }
         if(! r) return caml_call1(Stdlib[1], cst_Map_bal$2);
         var rr = r[4], rd = r[3], rv = r[2], rl = r[1], _I_ = height(rl);
         if(_I_ <= height(rr)) return create(create(l, x, d, rl), rv, rd, rr);
         if(! rl) return caml_call1(Stdlib[1], cst_Map_bal$1);
         var
          rlr = rl[4],
          rld = rl[3],
          rlv = rl[2],
          rll = rl[1],
          _J_ = create(rlr, rv, rd, rr);
         return create(create(l, x, d, rll), rlv, rld, _J_);
        }
        var empty = 0;
        function is_empty(param){return param ? 0 : 1;}
        function add(x, data, m){
         if(! m) return [0, 0, x, data, 0, 1];
         var
          h = m[5],
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return d === data ? m : [0, l, x, data, r, h];
         if(0 <= c){
          var rr = add(x, data, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = add(x, data, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function find(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return d;
          var r$0 = 0 <= c ? r : l, param$0 = r$0;
         }
        }
        function find_first(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(! caml_call1(f, v0$1)){var param$1 = r$0; continue;}
          var v0 = v0$1, d0 = d0$1, param = l$0;
          for(;;){
           if(! param) return [0, v0, d0];
           var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
           if(caml_call1(f, v0$0)){
            var v0 = v0$0, d0 = d0$0, param = l;
            continue;
           }
           var param = r;
          }
         }
        }
        function find_first_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(! caml_call1(f, v0$1)){var param$1 = r$0; continue;}
          var v0 = v0$1, d0 = d0$1, param = l$0;
          for(;;){
           if(! param) return [0, [0, v0, d0]];
           var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
           if(caml_call1(f, v0$0)){
            var v0 = v0$0, d0 = d0$0, param = l;
            continue;
           }
           var param = r;
          }
         }
        }
        function find_last(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(! caml_call1(f, v0$1)){var param$1 = l$0; continue;}
          var v0 = v0$1, d0 = d0$1, param = r$0;
          for(;;){
           if(! param) return [0, v0, d0];
           var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
           if(caml_call1(f, v0$0)){
            var v0 = v0$0, d0 = d0$0, param = r;
            continue;
           }
           var param = l;
          }
         }
        }
        function find_last_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(! caml_call1(f, v0$1)){var param$1 = l$0; continue;}
          var v0 = v0$1, d0 = d0$1, param = r$0;
          for(;;){
           if(! param) return [0, [0, v0, d0]];
           var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
           if(caml_call1(f, v0$0)){
            var v0 = v0$0, d0 = d0$0, param = r;
            continue;
           }
           var param = l;
          }
         }
        }
        function find_opt(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return [0, d];
          var r$0 = 0 <= c ? r : l, param$0 = r$0;
         }
        }
        function mem(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v),
           _F_ = 0 === c ? 1 : 0;
          if(_F_) return _F_;
          var r$0 = 0 <= c ? r : l, param$0 = r$0;
         }
        }
        function min_binding(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var l = param$0[1];
          if(l){var param$0 = l; continue;}
          var d = param$0[3], v = param$0[2];
          return [0, v, d];
         }
        }
        function min_binding_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var l = param$0[1];
          if(l){var param$0 = l; continue;}
          var d = param$0[3], v = param$0[2];
          return [0, [0, v, d]];
         }
        }
        function max_binding(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          if(param$0[4]){var r = param$0[4], param$0 = r; continue;}
          var d = param$0[3], v = param$0[2];
          return [0, v, d];
         }
        }
        function max_binding_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          if(param$0[4]){var r = param$0[4], param$0 = r; continue;}
          var d = param$0[3], v = param$0[2];
          return [0, [0, v, d]];
         }
        }
        function remove_min_binding(param){
         if(! param) return caml_call1(Stdlib[1], cst_Map_remove_min_elt);
         var l = param[1];
         if(l){
          var r = param[4], d = param[3], v = param[2];
          return bal(remove_min_binding(l), v, d, r);
         }
         var r$0 = param[4];
         return r$0;
        }
        function _d_(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var match = min_binding(t2), d = match[2], x = match[1];
         return bal(t1, x, d, remove_min_binding(t2));
        }
        function remove(x, m){
         if(! m) return 0;
         var
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return _d_(l, r);
         if(0 <= c){
          var rr = remove(x, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = remove(x, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function update(x, f, m){
         if(! m){
          var match$0 = caml_call1(f, 0);
          if(! match$0) return 0;
          var data$0 = match$0[1];
          return [0, 0, x, data$0, 0, 1];
         }
         var
          h = m[5],
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c){
          var match = caml_call1(f, [0, d]);
          if(! match) return _d_(l, r);
          var data = match[1];
          return d === data ? m : [0, l, x, data, r, h];
         }
         if(0 <= c){
          var rr = update(x, f, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = update(x, f, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function iter(f, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var r = param$0[4], d = param$0[3], v = param$0[2], l = param$0[1];
          iter(f, l);
          caml_call2(f, v, d);
          var param$0 = r;
         }
        }
        function map(f, param){
         if(! param) return 0;
         var
          h = param[5],
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = map(f, l),
          d$0 = caml_call1(f, d),
          r$0 = map(f, r);
         return [0, l$0, v, d$0, r$0, h];
        }
        function mapi(f, param){
         if(! param) return 0;
         var
          h = param[5],
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = mapi(f, l),
          d$0 = caml_call2(f, v, d),
          r$0 = mapi(f, r);
         return [0, l$0, v, d$0, r$0, h];
        }
        function fold(f, m, accu){
         var m$0 = m, accu$0 = accu;
         for(;;){
          if(! m$0) return accu$0;
          var
           r = m$0[4],
           d = m$0[3],
           v = m$0[2],
           l = m$0[1],
           accu$1 = caml_call3(f, v, d, fold(f, l, accu$0)),
           m$0 = r,
           accu$0 = accu$1;
         }
        }
        function for_all(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 1;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _C_ = caml_call2(p, v, d);
          if(_C_){
           var _D_ = for_all(p, l);
           if(_D_){var param$0 = r; continue;}
           var _E_ = _D_;
          }
          else
           var _E_ = _C_;
          return _E_;
         }
        }
        function exists(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _z_ = caml_call2(p, v, d);
          if(_z_)
           var _A_ = _z_;
          else{
           var _B_ = exists(p, l);
           if(! _B_){var param$0 = r; continue;}
           var _A_ = _B_;
          }
          return _A_;
         }
        }
        function add_min_binding(k, x, param){
         if(! param) return singleton(k, x);
         var r = param[4], d = param[3], v = param[2], l = param[1];
         return bal(add_min_binding(k, x, l), v, d, r);
        }
        function add_max_binding(k, x, param){
         if(! param) return singleton(k, x);
         var r = param[4], d = param[3], v = param[2], l = param[1];
         return bal(l, v, d, add_max_binding(k, x, r));
        }
        function join(l, v, d, r){
         if(! l) return add_min_binding(v, d, r);
         if(! r) return add_max_binding(v, d, l);
         var
          rh = r[5],
          rr = r[4],
          rd = r[3],
          rv = r[2],
          rl = r[1],
          lh = l[5],
          lr = l[4],
          ld = l[3],
          lv = l[2],
          ll = l[1];
         return (rh + 2 | 0) < lh
                 ? bal(ll, lv, ld, join(lr, v, d, r))
                 : (lh
                   + 2
                   | 0)
                   < rh
                   ? bal(join(l, v, d, rl), rv, rd, rr)
                   : create(l, v, d, r);
        }
        function concat(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var match = min_binding(t2), d = match[2], x = match[1];
         return join(t1, x, d, remove_min_binding(t2));
        }
        function concat_or_join(t1, v, d, t2){
         if(! d) return concat(t1, t2);
         var d$0 = d[1];
         return join(t1, v, d$0, t2);
        }
        function split(x, param){
         if(! param) return _a_;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return [0, l, [0, d], r];
         if(0 <= c){
          var
           match = split(x, r),
           rr = match[3],
           pres = match[2],
           lr = match[1];
          return [0, join(l, v, d, lr), pres, rr];
         }
         var
          match$0 = split(x, l),
          rl = match$0[3],
          pres$0 = match$0[2],
          ll = match$0[1];
         return [0, ll, pres$0, join(rl, v, d, r)];
        }
        function merge(f, s1, s2){
         if(s1){
          var h1 = s1[5], r1 = s1[4], d1 = s1[3], v1 = s1[2], l1 = s1[1];
          if(height(s2) <= h1){
           var
            match = split(v1, s2),
            r2 = match[3],
            d2 = match[2],
            l2 = match[1],
            _v_ = merge(f, r1, r2),
            _w_ = caml_call3(f, v1, [0, d1], d2);
           return concat_or_join(merge(f, l1, l2), v1, _w_, _v_);
          }
         }
         else if(! s2) return 0;
         if(! s2)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
         var
          r2$0 = s2[4],
          d2$0 = s2[3],
          v2 = s2[2],
          l2$0 = s2[1],
          match$0 = split(v2, s1),
          r1$0 = match$0[3],
          d1$0 = match$0[2],
          l1$0 = match$0[1],
          _x_ = merge(f, r1$0, r2$0),
          _y_ = caml_call3(f, v2, d1$0, [0, d2$0]);
         return concat_or_join(merge(f, l1$0, l2$0), v2, _y_, _x_);
        }
        function union(f, s1, s2){
         if(s1){
          if(s2){
           var
            h2 = s2[5],
            r2 = s2[4],
            d2 = s2[3],
            v2 = s2[2],
            l2 = s2[1],
            h1 = s1[5],
            r1 = s1[4],
            d1 = s1[3],
            v1 = s1[2],
            l1 = s1[1];
           if(h2 <= h1){
            var
             match = split(v1, s2),
             r2$0 = match[3],
             d2$0 = match[2],
             l2$0 = match[1],
             l = union(f, l1, l2$0),
             r = union(f, r1, r2$0);
            if(! d2$0) return join(l, v1, d1, r);
            var d2$1 = d2$0[1];
            return concat_or_join(l, v1, caml_call3(f, v1, d1, d2$1), r);
           }
           var
            match$0 = split(v2, s1),
            r1$0 = match$0[3],
            d1$0 = match$0[2],
            l1$0 = match$0[1],
            l$0 = union(f, l1$0, l2),
            r$0 = union(f, r1$0, r2);
           if(! d1$0) return join(l$0, v2, d2, r$0);
           var d1$1 = d1$0[1];
           return concat_or_join(l$0, v2, caml_call3(f, v2, d1$1, d2), r$0);
          }
          var s = s1;
         }
         else
          var s = s2;
         return s;
        }
        function filter(p, m){
         if(! m) return 0;
         var
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          l$0 = filter(p, l),
          pvd = caml_call2(p, v, d),
          r$0 = filter(p, r);
         if(! pvd) return concat(l$0, r$0);
         if(l === l$0 && r === r$0) return m;
         return join(l$0, v, d, r$0);
        }
        function filter_map(f, param){
         if(! param) return 0;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = filter_map(f, l),
          fvd = caml_call2(f, v, d),
          r$0 = filter_map(f, r);
         if(! fvd) return concat(l$0, r$0);
         var d$0 = fvd[1];
         return join(l$0, v, d$0, r$0);
        }
        function partition(p, param){
         if(! param) return _c_;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          match = partition(p, l),
          lf = match[2],
          lt = match[1],
          pvd = caml_call2(p, v, d),
          match$0 = partition(p, r),
          rf = match$0[2],
          rt = match$0[1];
         if(pvd){
          var _t_ = concat(lf, rf);
          return [0, join(lt, v, d, rt), _t_];
         }
         var _u_ = join(lf, v, d, rf);
         return [0, concat(lt, rt), _u_];
        }
        function cons_enum(m, e){
         var m$0 = m, e$0 = e;
         for(;;){
          if(! m$0) return e$0;
          var
           r = m$0[4],
           d = m$0[3],
           v = m$0[2],
           l = m$0[1],
           e$1 = [0, v, d, r, e$0],
           m$0 = l,
           e$0 = e$1;
         }
        }
        function compare(cmp, m1, m2){
         var
          e2$2 = cons_enum(m2, 0),
          e1$2 = cons_enum(m1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? -1 : 0;
          if(! e2) return 1;
          var
           e2$0 = e2[4],
           r2 = e2[3],
           d2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[4],
           r1 = e1[3],
           d1 = e1[2],
           v1 = e1[1],
           c = caml_call2(Ord[1], v1, v2);
          if(0 !== c) return c;
          var c$0 = caml_call2(cmp, d1, d2);
          if(0 !== c$0) return c$0;
          var
           e2$1 = cons_enum(r2, e2$0),
           e1$1 = cons_enum(r1, e1$0),
           e1 = e1$1,
           e2 = e2$1;
         }
        }
        function equal(cmp, m1, m2){
         var
          e2$2 = cons_enum(m2, 0),
          e1$2 = cons_enum(m1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? 0 : 1;
          if(! e2) return 0;
          var
           e2$0 = e2[4],
           r2 = e2[3],
           d2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[4],
           r1 = e1[3],
           d1 = e1[2],
           v1 = e1[1],
           _q_ = 0 === caml_call2(Ord[1], v1, v2) ? 1 : 0;
          if(_q_){
           var _r_ = caml_call2(cmp, d1, d2);
           if(_r_){
            var
             e2$1 = cons_enum(r2, e2$0),
             e1$1 = cons_enum(r1, e1$0),
             e1 = e1$1,
             e2 = e2$1;
            continue;
           }
           var _s_ = _r_;
          }
          else
           var _s_ = _q_;
          return _s_;
         }
        }
        function cardinal(param){
         if(! param) return 0;
         var r = param[4], l = param[1], _p_ = cardinal(r);
         return (cardinal(l) + 1 | 0) + _p_ | 0;
        }
        function bindings_aux(accu, param){
         var accu$0 = accu, param$0 = param;
         for(;;){
          if(! param$0) return accu$0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           accu$1 = [0, [0, v, d], bindings_aux(accu$0, r)],
           accu$0 = accu$1,
           param$0 = l;
         }
        }
        function bindings(s){return bindings_aux(0, s);}
        function add_seq(i, m){
         function _o_(m, param){
          var v = param[2], k = param[1];
          return add(k, v, m);
         }
         return caml_call3(Stdlib_Seq[5], _o_, m, i);
        }
        function of_seq(i){return add_seq(i, empty);}
        function seq_of_enum(c, param){
         if(! c) return 0;
         var
          rest = c[4],
          t = c[3],
          v = c[2],
          k = c[1],
          _m_ = cons_enum(t, rest);
         return [0, [0, k, v], function(_n_){return seq_of_enum(_m_, _n_);}];
        }
        function to_seq(m){
         var _k_ = cons_enum(m, 0);
         return function(_l_){return seq_of_enum(_k_, _l_);};
        }
        function snoc_enum(s, e){
         var s$0 = s, e$0 = e;
         for(;;){
          if(! s$0) return e$0;
          var
           r = s$0[4],
           d = s$0[3],
           v = s$0[2],
           l = s$0[1],
           e$1 = [0, v, d, l, e$0],
           s$0 = r,
           e$0 = e$1;
         }
        }
        function rev_seq_of_enum(c, param){
         if(! c) return 0;
         var
          rest = c[4],
          t = c[3],
          v = c[2],
          k = c[1],
          _i_ = snoc_enum(t, rest);
         return [0,
                 [0, k, v],
                 function(_j_){return rev_seq_of_enum(_i_, _j_);}];
        }
        function to_rev_seq(c){
         var _g_ = snoc_enum(c, 0);
         return function(_h_){return rev_seq_of_enum(_g_, _h_);};
        }
        function to_seq_from(low, m){
         var m$0 = m, c = 0;
         for(;;){
          if(m$0){
           var
            r = m$0[4],
            d = m$0[3],
            v = m$0[2],
            l = m$0[1],
            n = caml_call2(Ord[1], v, low);
           if(0 !== n){
            if(0 <= n){var c$0 = [0, v, d, r, c], m$0 = l, c = c$0; continue;}
            var m$0 = r;
            continue;
           }
           var _e_ = [0, v, d, r, c];
          }
          else
           var _e_ = c;
          return function(_f_){return seq_of_enum(_e_, _f_);};
         }
        }
        return [0,
                empty,
                is_empty,
                mem,
                add,
                update,
                singleton,
                remove,
                merge,
                union,
                compare,
                equal,
                iter,
                fold,
                for_all,
                exists,
                filter,
                filter_map,
                partition,
                cardinal,
                bindings,
                min_binding,
                min_binding_opt,
                max_binding,
                max_binding_opt,
                min_binding,
                min_binding_opt,
                split,
                find,
                find_opt,
                find_first,
                find_first_opt,
                find_last,
                find_last_opt,
                map,
                mapi,
                to_seq,
                to_rev_seq,
                to_seq_from,
                add_seq,
                of_seq];
       }];
   runtime.caml_register_global(11, Stdlib_Map, "Stdlib__Map");
   return;
  }
  (globalThis));

//# 9223 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Empty = [248, "Stdlib.Queue.Empty", runtime.caml_fresh_oo_id(0)];
   function create(param){return [0, 0, 0, 0];}
   function clear(q){q[1] = 0; q[2] = 0; q[3] = 0; return 0;}
   function add(x, q){
    var cell = [0, x, 0], match = q[3];
    return match
            ? (q[1] = q[1] + 1 | 0, match[2] = cell, q[3] = cell, 0)
            : (q[1] = 1, q[2] = cell, q[3] = cell, 0);
   }
   function peek(q){
    var match = q[2];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var content = match[1];
    return content;
   }
   function peek_opt(q){
    var match = q[2];
    if(! match) return 0;
    var content = match[1];
    return [0, content];
   }
   function take(q){
    var _g_ = q[2];
    if(! _g_) throw caml_maybe_attach_backtrace(Empty, 1);
    var content = _g_[1];
    if(_g_[2]){
     var next = _g_[2];
     q[1] = q[1] - 1 | 0;
     q[2] = next;
     return content;
    }
    clear(q);
    return content;
   }
   function take_opt(q){
    var _f_ = q[2];
    if(! _f_) return 0;
    var content = _f_[1];
    if(_f_[2]){
     var next = _f_[2];
     q[1] = q[1] - 1 | 0;
     q[2] = next;
     return [0, content];
    }
    clear(q);
    return [0, content];
   }
   function copy(q){
    var cell$0 = q[2], q_res = [0, q[1], 0, 0], prev = 0, cell = cell$0;
    for(;;){
     if(! cell){q_res[3] = prev; return q_res;}
     var content = cell[1], next = cell[2], prev$0 = [0, content, 0];
     if(prev) prev[2] = prev$0; else q_res[2] = prev$0;
     var prev = prev$0, cell = next;
    }
   }
   function is_empty(q){return 0 === q[1] ? 1 : 0;}
   function length(q){return q[1];}
   function iter(f, q){
    var cell$0 = q[2], cell = cell$0;
    for(;;){
     if(! cell) return 0;
     var content = cell[1], next = cell[2];
     caml_call1(f, content);
     var cell = next;
    }
   }
   function fold(f, accu$1, q){
    var cell$0 = q[2], accu = accu$1, cell = cell$0;
    for(;;){
     if(! cell) return accu;
     var
      content = cell[1],
      next = cell[2],
      accu$0 = caml_call2(f, accu, content),
      accu = accu$0,
      cell = next;
    }
   }
   function transfer(q1, q2){
    var _e_ = 0 < q1[1] ? 1 : 0;
    if(! _e_) return _e_;
    var match = q2[3];
    return match
            ? (q2
               [1]
              = q2[1] + q1[1] | 0,
              match[2] = q1[2],
              q2[3] = q1[3],
              clear(q1))
            : (q2[1] = q1[1], q2[2] = q1[2], q2[3] = q1[3], clear(q1));
   }
   function to_seq(q){
    function aux(c, param){
     if(! c) return 0;
     var x = c[1], next = c[2];
     return [0, x, function(_d_){return aux(next, _d_);}];
    }
    var _b_ = q[2];
    return function(_c_){return aux(_b_, _c_);};
   }
   function add_seq(q, i){
    function _a_(x){return add(x, q);}
    return caml_call2(Stdlib_Seq[4], _a_, i);
   }
   function of_seq(g){var q = create(0); add_seq(q, g); return q;}
   var
    Stdlib_Queue =
      [0,
       Empty,
       create,
       add,
       add,
       take,
       take_opt,
       take,
       peek,
       peek_opt,
       peek,
       clear,
       copy,
       is_empty,
       length,
       iter,
       fold,
       transfer,
       to_seq,
       add_seq,
       of_seq];
   runtime.caml_register_global(2, Stdlib_Queue, "Stdlib__Queue");
   return;
  }
  (globalThis));

//# 9378 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_blit_string = runtime.caml_blit_string,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_set16 = runtime.caml_bytes_set16,
    caml_bytes_set32 = runtime.caml_bytes_set32,
    caml_bytes_set64 = runtime.caml_bytes_set64,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Assert_failure = global_data.Assert_failure,
    cst_Buffer_truncate = "Buffer.truncate",
    _a_ = [0, "buffer.ml", 220, 9],
    cst_Buffer_add_channel = "Buffer.add_channel",
    cst_Buffer_add_substring_add_s = "Buffer.add_substring/add_subbytes",
    cst_Buffer_add_cannot_grow_buf = "Buffer.add: cannot grow buffer",
    cst_Buffer_nth = "Buffer.nth",
    cst_Buffer_blit = "Buffer.blit",
    cst_Buffer_sub = "Buffer.sub";
   function create(n){
    var
     n$0 = 1 <= n ? n : 1,
     n$1 = Stdlib_Sys[12] < n$0 ? Stdlib_Sys[12] : n$0,
     s = caml_create_bytes(n$1);
    return [0, [0, s, n$1], 0, s];
   }
   function contents(b){return caml_call3(Stdlib_Bytes[8], b[1][1], 0, b[2]);}
   function to_bytes(b){return caml_call3(Stdlib_Bytes[7], b[1][1], 0, b[2]);}
   function sub(b, ofs, len){
    if(0 <= ofs && 0 <= len && (b[2] - len | 0) >= ofs)
     return caml_call3(Stdlib_Bytes[8], b[1][1], ofs, len);
    return caml_call1(Stdlib[1], cst_Buffer_sub);
   }
   function blit(src, srcoff, dst, dstoff, len){
    if
     (0 <= len
      &&
       0 <= srcoff
       &&
        (src[2] - len | 0) >= srcoff
        && 0 <= dstoff && (caml_ml_bytes_length(dst) - len | 0) >= dstoff)
     return caml_call5(Stdlib_Bytes[11], src[1][1], srcoff, dst, dstoff, len);
    return caml_call1(Stdlib[1], cst_Buffer_blit);
   }
   function nth(b, ofs){
    var position = b[2], match = b[1], length = match[2], buffer = match[1];
    if(0 <= ofs && position > ofs && length >= position)
     return runtime.caml_bytes_unsafe_get(buffer, ofs);
    return caml_call1(Stdlib[1], cst_Buffer_nth);
   }
   function length(b){return b[2];}
   function clear(b){b[2] = 0; return 0;}
   function reset(b){
    b[2] = 0;
    var inner = [0, b[3], caml_ml_bytes_length(b[3])];
    b[1] = inner;
    return 0;
   }
   function resize(b, more){
    var old_pos = b[2], old_len = b[1][2], new_len = [0, old_len];
    for(;;){
     if(new_len[1] < (old_pos + more | 0)){
      new_len[1] = 2 * new_len[1] | 0;
      continue;
     }
     if(Stdlib_Sys[12] < new_len[1])
      if((old_pos + more | 0) <= Stdlib_Sys[12])
       new_len[1] = Stdlib_Sys[12];
      else
       caml_call1(Stdlib[2], cst_Buffer_add_cannot_grow_buf);
     var new_buffer = caml_create_bytes(new_len[1]);
     caml_call5(Stdlib_Bytes[11], b[1][1], 0, new_buffer, 0, b[2]);
     b[1] = [0, new_buffer, new_len[1]];
     return 0;
    }
   }
   function add_char(b, c){
    var pos = b[2], match = b[1], length = match[2], buffer = match[1];
    if(length <= pos){
     resize(b, 1);
     caml_bytes_set(b[1][1], b[2], c);
    }
    else
     caml_bytes_unsafe_set(buffer, pos, c);
    b[2] = pos + 1 | 0;
    return 0;
   }
   var uchar_utf_8_byte_length_max = 4, uchar_utf_16_byte_length_max = 4;
   function add_utf_8_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[1][2] <= pos) resize(b, uchar_utf_8_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[51], b[1][1], pos, u);
     if(0 === n){resize(b, uchar_utf_8_byte_length_max); continue;}
     b[2] = pos + n | 0;
     return 0;
    }
   }
   function add_utf_16be_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[1][2] <= pos) resize(b, uchar_utf_16_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[54], b[1][1], pos, u);
     if(0 === n){resize(b, uchar_utf_16_byte_length_max); continue;}
     b[2] = pos + n | 0;
     return 0;
    }
   }
   function add_utf_16le_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[1][2] <= pos) resize(b, uchar_utf_16_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[57], b[1][1], pos, u);
     if(0 === n){resize(b, uchar_utf_16_byte_length_max); continue;}
     b[2] = pos + n | 0;
     return 0;
    }
   }
   function add_substring(b, s, offset, len){
    var _r_ = offset < 0 ? 1 : 0;
    if(_r_)
     var _s_ = _r_;
    else
     var
      _t_ = len < 0 ? 1 : 0,
      _s_ = _t_ || ((caml_ml_string_length(s) - len | 0) < offset ? 1 : 0);
    if(_s_) caml_call1(Stdlib[1], cst_Buffer_add_substring_add_s);
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + len | 0;
    if(length < new_position){
     resize(b, len);
     caml_call5(Stdlib_Bytes[12], s, offset, b[1][1], b[2], len);
    }
    else
     caml_blit_string(s, offset, buffer, position, len);
    b[2] = new_position;
    return 0;
   }
   function add_subbytes(b, s, offset, len){
    return add_substring(b, caml_call1(Stdlib_Bytes[44], s), offset, len);
   }
   function add_string(b, s){
    var
     len = caml_ml_string_length(s),
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = b[2] + len | 0;
    if(length < new_position){
     resize(b, len);
     caml_call5(Stdlib_Bytes[12], s, 0, b[1][1], b[2], len);
    }
    else
     caml_blit_string(s, 0, buffer, position, len);
    b[2] = new_position;
    return 0;
   }
   function add_bytes(b, s){
    return add_string(b, caml_call1(Stdlib_Bytes[44], s));
   }
   function add_buffer(b, bs){return add_subbytes(b, bs[1][1], 0, bs[2]);}
   function add_channel(b, ic, to_read$1){
    var
     _p_ = to_read$1 < 0 ? 1 : 0,
     _q_ = _p_ || (Stdlib_Sys[12] < to_read$1 ? 1 : 0);
    if(_q_) caml_call1(Stdlib[1], cst_Buffer_add_channel);
    if(b[1][2] < (b[2] + to_read$1 | 0)) resize(b, to_read$1);
    var
     ofs$1 = b[2],
     buf = b[1][1],
     already_read = 0,
     ofs = ofs$1,
     to_read = to_read$1;
    for(;;){
     if(0 !== to_read){
      var r = caml_call4(Stdlib[84], ic, buf, ofs, to_read);
      if(0 !== r){
       var
        already_read$0 = already_read + r | 0,
        ofs$0 = ofs + r | 0,
        to_read$0 = to_read - r | 0,
        already_read = already_read$0,
        ofs = ofs$0,
        to_read = to_read$0;
       continue;
      }
     }
     b[2] = b[2] + already_read | 0;
     if(already_read < to_read$1)
      throw caml_maybe_attach_backtrace(Stdlib[12], 1);
     return 0;
    }
   }
   function output_buffer(oc, b){
    return caml_call4(Stdlib[68], oc, b[1][1], 0, b[2]);
   }
   function add_substitute(b, f, s){
    var lim$1 = caml_ml_string_length(s), previous = 32, i$4 = 0;
    for(;;){
     if(i$4 >= lim$1){
      var _o_ = 92 === previous ? 1 : 0;
      return _o_ ? add_char(b, previous) : _o_;
     }
     var previous$0 = caml_string_get(s, i$4);
     if(36 !== previous$0){
      if(92 === previous){
       add_char(b, 92);
       add_char(b, previous$0);
       var i$6 = i$4 + 1 | 0, previous = 32, i$4 = i$6;
       continue;
      }
      if(92 === previous$0){
       var i$7 = i$4 + 1 | 0, previous = previous$0, i$4 = i$7;
       continue;
      }
      add_char(b, previous$0);
      var i$8 = i$4 + 1 | 0, previous = previous$0, i$4 = i$8;
      continue;
     }
     if(92 === previous){
      add_char(b, previous$0);
      var i$5 = i$4 + 1 | 0, previous = 32, i$4 = i$5;
      continue;
     }
     var start$0 = i$4 + 1 | 0;
     if(lim$1 <= start$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var opening = caml_string_get(s, start$0), switch$0 = 0;
     if(40 !== opening && 123 !== opening){
      var
       start = start$0 + 1 | 0,
       lim$0 = caml_ml_string_length(s),
       i$2 = start;
      for(;;){
       if(lim$0 <= i$2)
        var stop$0 = lim$0;
       else{
        var match = caml_string_get(s, i$2), switch$1 = 0;
        if(91 <= match){
         if(97 <= match){
          if(123 > match) switch$1 = 1;
         }
         else if(95 === match) switch$1 = 1;
        }
        else
         if(58 <= match){
          if(65 <= match) switch$1 = 1;
         }
         else if(48 <= match) switch$1 = 1;
        if(switch$1){var i$3 = i$2 + 1 | 0, i$2 = i$3; continue;}
        var stop$0 = i$2;
       }
       var
        match$0 =
          [0,
           caml_call3(Stdlib_String[15], s, start$0, stop$0 - start$0 | 0),
           stop$0];
       switch$0 = 1;
       break;
      }
     }
     if(! switch$0){
      var new_start = start$0 + 1 | 0, k$2 = 0;
      if(40 === opening)
       var closing = 41;
      else{
       if(123 !== opening)
        throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
       var closing = 125;
      }
      var lim = caml_ml_string_length(s), k = k$2, stop = new_start;
      for(;;){
       if(lim <= stop) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
       if(caml_string_get(s, stop) === opening){
        var i = stop + 1 | 0, k$0 = k + 1 | 0, k = k$0, stop = i;
        continue;
       }
       if(caml_string_get(s, stop) !== closing){
        var i$1 = stop + 1 | 0, stop = i$1;
        continue;
       }
       if(0 !== k){
        var i$0 = stop + 1 | 0, k$1 = k - 1 | 0, k = k$1, stop = i$0;
        continue;
       }
       var
        match$0 =
          [0,
           caml_call3
            (Stdlib_String[15], s, new_start, (stop - start$0 | 0) - 1 | 0),
           stop + 1 | 0];
       break;
      }
     }
     var next_i = match$0[2], ident = match$0[1];
     add_string(b, caml_call1(f, ident));
     var previous = 32, i$4 = next_i;
    }
   }
   function truncate(b, len){
    if(0 <= len && b[2] >= len){b[2] = len; return 0;}
    return caml_call1(Stdlib[1], cst_Buffer_truncate);
   }
   function to_seq(b){
    function aux(i, param){
     if(b[2] <= i) return 0;
     var x = caml_bytes_get(b[1][1], i), _m_ = i + 1 | 0;
     return [0, x, function(_n_){return aux(_m_, _n_);}];
    }
    var _k_ = 0;
    return function(_l_){return aux(_k_, _l_);};
   }
   function to_seqi(b){
    function aux(i, param){
     if(b[2] <= i) return 0;
     var x = caml_bytes_get(b[1][1], i), _i_ = i + 1 | 0;
     return [0, [0, i, x], function(_j_){return aux(_i_, _j_);}];
    }
    var _g_ = 0;
    return function(_h_){return aux(_g_, _h_);};
   }
   function add_seq(b, seq){
    function _e_(_f_){return add_char(b, _f_);}
    return caml_call2(Stdlib_Seq[4], _e_, seq);
   }
   function of_seq(i){var b = create(32); add_seq(b, i); return b;}
   function add_int8(b, x){
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + 1 | 0;
    if(length < new_position){
     resize(b, 1);
     caml_bytes_set(b[1][1], b[2], x);
    }
    else
     caml_bytes_unsafe_set(buffer, position, x);
    b[2] = new_position;
    return 0;
   }
   function add_int16_ne(b, x){
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + 2 | 0;
    if(length < new_position){
     resize(b, 2);
     caml_bytes_set16(b[1][1], b[2], x);
    }
    else
     caml_bytes_set16(buffer, position, x);
    b[2] = new_position;
    return 0;
   }
   function add_int32_ne(b, x){
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + 4 | 0;
    if(length < new_position){
     resize(b, 4);
     caml_bytes_set32(b[1][1], b[2], x);
    }
    else
     caml_bytes_set32(buffer, position, x);
    b[2] = new_position;
    return 0;
   }
   function add_int64_ne(b, x){
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + 8 | 0;
    if(length < new_position){
     resize(b, 8);
     caml_bytes_set64(b[1][1], b[2], x);
    }
    else
     caml_bytes_set64(buffer, position, x);
    b[2] = new_position;
    return 0;
   }
   function add_int16_le(b, x){
    var _d_ = Stdlib_Sys[11] ? caml_bswap16(x) : x;
    return add_int16_ne(b, _d_);
   }
   function add_int16_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_bswap16(x);
    return add_int16_ne(b, x$0);
   }
   function add_int32_le(b, x){
    var _c_ = Stdlib_Sys[11] ? caml_int32_bswap(x) : x;
    return add_int32_ne(b, _c_);
   }
   function add_int32_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_int32_bswap(x);
    return add_int32_ne(b, x$0);
   }
   function add_int64_le(b, x){
    var _b_ = Stdlib_Sys[11] ? caml_int64_bswap(x) : x;
    return add_int64_ne(b, _b_);
   }
   function add_int64_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_int64_bswap(x);
    return add_int64_ne(b, x$0);
   }
   var
    Stdlib_Buffer =
      [0,
       create,
       contents,
       to_bytes,
       sub,
       blit,
       nth,
       length,
       clear,
       reset,
       output_buffer,
       truncate,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       to_seq,
       to_seqi,
       add_seq,
       of_seq,
       add_int8,
       add_int8,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int32_ne,
       add_int32_be,
       add_int32_le,
       add_int64_ne,
       add_int64_be,
       add_int64_le];
   runtime.caml_register_global(14, Stdlib_Buffer, "Stdlib__Buffer");
   return;
  }
  (globalThis));

//# 9887 "../../.js/default/stdlib/stdlib.cma.js"
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Stdlib_Mutex =
      [0,
       runtime.caml_ml_mutex_new,
       runtime.caml_ml_mutex_lock,
       runtime.caml_ml_mutex_try_lock,
       runtime.caml_ml_mutex_unlock];
   runtime.caml_register_global(0, Stdlib_Mutex, "Stdlib__Mutex");
   return;
  }
  (globalThis));

//# 9903 "../../.js/default/stdlib/stdlib.cma.js"
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Stdlib_Condition =
      [0,
       runtime.caml_ml_condition_new,
       runtime.caml_ml_condition_wait,
       runtime.caml_ml_condition_signal,
       runtime.caml_ml_condition_broadcast];
   runtime.caml_register_global(0, Stdlib_Condition, "Stdlib__Condition");
   return;
  }
  (globalThis));

//# 10010 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_domain_dls_set = runtime.caml_domain_dls_set,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_domain_id = runtime.caml_ml_domain_id,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Mutex = global_data.Stdlib__Mutex,
    Stdlib_Condition = global_data.Stdlib__Condition,
    Stdlib = global_data.Stdlib,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Array = global_data.Stdlib__Array,
    cst_internal_error_Am_I_alread = "internal error: Am I already finished?",
    cst_first_domain_already_spawn = "first domain already spawned";
   function cpu_relax(param){return runtime.caml_ml_domain_cpu_relax(0);}
   var unique_value = [0, 0];
   function create_dls(param){
    var st = caml_make_vect(8, unique_value);
    return caml_domain_dls_set(st);
   }
   create_dls(0);
   var
    key_counter = caml_call1(Stdlib_Atomic[1], 0),
    parent_keys = caml_call1(Stdlib_Atomic[1], 0);
   function new_key(split_from_parent, init_orphan){
    var
     idx = caml_call2(Stdlib_Atomic[6], key_counter, 1),
     k = [0, idx, init_orphan];
    if(split_from_parent){
     var split = split_from_parent[1], ki = [0, k, split];
     for(;;){
      var l = caml_call1(Stdlib_Atomic[2], parent_keys);
      if(1 - caml_call3(Stdlib_Atomic[5], parent_keys, l, [0, ki, l]))
       continue;
      break;
     }
    }
    return k;
   }
   function maybe_grow(idx){
    var st = runtime.caml_domain_dls_get(0), sz = st.length - 1;
    if(idx < sz) return st;
    var new_sz = sz;
    for(;;){
     if(idx < new_sz){
      var new_st = caml_make_vect(new_sz, unique_value);
      caml_call5(Stdlib_Array[8], st, 0, new_st, 0, sz);
      caml_domain_dls_set(new_st);
      return new_st;
     }
     var s = 2 * new_sz | 0, new_sz = s;
    }
   }
   function set(param, x){
    var idx = param[1], st = maybe_grow(idx);
    caml_check_bound(st, idx)[1 + idx] = x;
    return 0;
   }
   function get(param){
    var
     init = param[2],
     idx = param[1],
     st = maybe_grow(idx),
     v = caml_check_bound(st, idx)[1 + idx];
    if(v !== unique_value) return v;
    var v$0 = caml_call1(init, 0);
    caml_check_bound(st, idx)[1 + idx] = v$0;
    return v$0;
   }
   function get_id(param){var domain = param[1]; return domain;}
   function self(param){return caml_ml_domain_id(0);}
   function is_main_domain(param){return 0 === caml_ml_domain_id(0) ? 1 : 0;}
   var
    first_domain_spawned = caml_call1(Stdlib_Atomic[1], 0),
    first_spawn_function = [0, function(param){return 0;}];
   function before_first_spawn(f){
    if(caml_call1(Stdlib_Atomic[2], first_domain_spawned))
     throw caml_maybe_attach_backtrace
            ([0, Stdlib[6], cst_first_domain_already_spawn], 1);
    var old_f = first_spawn_function[1];
    function new_f(param){caml_call1(old_f, 0); return caml_call1(f, 0);}
    first_spawn_function[1] = new_f;
    return 0;
   }
   var at_exit_key = new_key(0, function(param, _e_){return 0;});
   function at_exit(f){
    var old_exit = get(at_exit_key);
    function new_exit(param){
     caml_call1(f, 0);
     return caml_call1(old_exit, 0);
    }
    return set(at_exit_key, new_exit);
   }
   function do_at_exit(param){
    var f = get(at_exit_key);
    return caml_call1(f, 0);
   }
   Stdlib[104][1] = do_at_exit;
   function spawn(f){
    if(1 - caml_call1(Stdlib_Atomic[2], first_domain_spawned)){
     caml_call2(Stdlib_Atomic[3], first_domain_spawned, 1);
     caml_call1(first_spawn_function[1], 0);
     first_spawn_function[1] = function(param){return 0;};
    }
    var _a_ = caml_call1(Stdlib_Atomic[2], parent_keys);
    function _b_(param){
     var split = param[2], k = param[1], idx = k[1];
     return [0, idx, caml_call1(split, get(k))];
    }
    var
     pk = caml_call2(Stdlib_List[19], _b_, _a_),
     term_mutex = caml_call1(Stdlib_Mutex[1], 0),
     term_condition = caml_call1(Stdlib_Condition[1], 0),
     term_state = [0, 0];
    function body(param){
     var switch$0 = 0;
     try{
      create_dls(0);
      var
       _c_ =
         function(param){
          var v = param[2], idx = param[1], st = maybe_grow(idx);
          caml_check_bound(st, idx)[1 + idx] = v;
          return 0;
         };
      caml_call2(Stdlib_List[17], _c_, pk);
      var res = caml_call1(f, 0);
     }
     catch(ex$0){
      var ex = caml_wrap_exception(ex$0), result = [1, ex];
      switch$0 = 1;
     }
     if(! switch$0) var result = [0, res];
     try{do_at_exit(0); var result$0 = result;}
     catch(ex){
      var
       ex$0 = caml_wrap_exception(ex),
       _d_ = 0 === result[0] ? [1, ex$0] : result,
       result$0 = _d_;
     }
     caml_call1(Stdlib_Mutex[2], term_mutex);
     return term_state[1]
             ? caml_call1(Stdlib[2], cst_internal_error_Am_I_alread)
             : (term_state
                [1]
               = [0, result$0],
               caml_call1(Stdlib_Condition[4], term_condition));
    }
    return [0,
            runtime.caml_domain_spawn(body, term_mutex),
            term_mutex,
            term_condition,
            term_state];
   }
   function join(param){
    var
     term_state = param[4],
     term_condition = param[3],
     term_mutex = param[2];
    caml_call1(Stdlib_Mutex[2], term_mutex);
    for(;;){
     var match = term_state[1];
     if(! match){
      caml_call2(Stdlib_Condition[2], term_condition, term_mutex);
      continue;
     }
     var res = match[1];
     caml_call1(Stdlib_Mutex[4], term_mutex);
     if(0 === res[0]){var x = res[1]; return x;}
     var ex = res[1];
     throw caml_maybe_attach_backtrace(ex, 1);
    }
   }
   var
    recommended_domain_count = runtime.caml_recommended_domain_count,
    Stdlib_Domain =
      [0,
       spawn,
       join,
       get_id,
       self,
       before_first_spawn,
       at_exit,
       cpu_relax,
       is_main_domain,
       recommended_domain_count,
       [0, new_key, get, set]];
   runtime.caml_register_global(8, Stdlib_Domain, "Stdlib__Domain");
   return;
  }
  (globalThis));

//# 10231 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$43 = "",
    cst_and = " and ",
    cst_Li$3 = "%Li",
    cst_i$3 = "%i",
    cst_li$3 = "%li",
    cst_ni$3 = "%ni",
    cst_u$0 = "%u",
    cst$42 = "' '",
    cst$41 = "'#'",
    cst$39 = "'*'",
    cst$40 = "'+'",
    cst$44 = ", ",
    cst_0$3 = "0",
    cst_at_character_number = ": at character number ",
    cst$38 = "@[",
    cst$37 = "@{",
    cst_bad_input_format_type_mism =
      "bad input: format type mismatch between ",
    cst_bad_input_format_type_mism$0 =
      "bad input: format type mismatch between %S and %S",
    cst_camlinternalFormat_ml = "camlinternalFormat.ml",
    cst_invalid_format = "invalid format ",
    cst_precision$3 = "precision",
    caml_blit_string = runtime.caml_blit_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_format_float = runtime.caml_format_float,
    caml_format_int = runtime.caml_format_int,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_notequal = runtime.caml_notequal,
    caml_string_get = runtime.caml_string_get,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$9 = "%{",
    cst$10 = "%}",
    cst$11 = "%(",
    cst$12 = "%)",
    cst$13 = "%?",
    cst$18 = cst$37,
    cst$19 = cst$38,
    cst$20 = cst$37,
    cst$21 = cst$38,
    cst$22 = cst$37,
    cst$23 = cst$38,
    cst$26 = cst$39,
    cst$24 = "'-'",
    cst$25 = cst$39,
    cst$27 = cst$40,
    cst$28 = cst$41,
    cst$29 = cst$42,
    cst$30 = cst$40,
    cst$31 = "'_'",
    sub_format = [0, 0, cst$43],
    formatting_lit = [0, "@;", 1, 0],
    cst$35 = cst$41,
    cst$32 = cst$40,
    cst$33 = cst$40,
    cst$34 = cst$42,
    cst$36 = cst$40,
    cst$17 = ".",
    cst$14 = "%!",
    cst$15 = cst$37,
    cst$16 = cst$38,
    cst$8 = "%%",
    cst$0 = "@]",
    cst$1 = "@}",
    cst$2 = "@?",
    cst$3 = "@\n",
    cst$4 = "@.",
    cst$5 = "@@",
    cst$6 = "@%",
    cst$7 = "@",
    cst = ".*",
    Assert_failure = global_data.Assert_failure,
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Int = global_data.Stdlib__Int,
    cst_c = "%c",
    cst_s = "%s",
    cst_i = cst_i$3,
    cst_li = cst_li$3,
    cst_ni = cst_ni$3,
    cst_Li = cst_Li$3,
    cst_f = "%f",
    cst_B = "%B",
    cst_a = "%a",
    cst_t = "%t",
    cst_r = "%r",
    cst_r$0 = "%_r",
    _b_ = [0, cst_camlinternalFormat_ml, 850, 23],
    _m_ = [0, cst_camlinternalFormat_ml, 814, 21],
    _e_ = [0, cst_camlinternalFormat_ml, 815, 21],
    _n_ = [0, cst_camlinternalFormat_ml, 818, 21],
    _f_ = [0, cst_camlinternalFormat_ml, 819, 21],
    _o_ = [0, cst_camlinternalFormat_ml, 822, 19],
    _g_ = [0, cst_camlinternalFormat_ml, 823, 19],
    _p_ = [0, cst_camlinternalFormat_ml, 826, 22],
    _h_ = [0, cst_camlinternalFormat_ml, 827, 22],
    _q_ = [0, cst_camlinternalFormat_ml, 831, 30],
    _i_ = [0, cst_camlinternalFormat_ml, 832, 30],
    _k_ = [0, cst_camlinternalFormat_ml, 836, 26],
    _c_ = [0, cst_camlinternalFormat_ml, 837, 26],
    _l_ = [0, cst_camlinternalFormat_ml, 846, 28],
    _d_ = [0, cst_camlinternalFormat_ml, 847, 28],
    _j_ = [0, cst_camlinternalFormat_ml, 851, 23],
    _s_ = [0, cst_camlinternalFormat_ml, 1558, 4],
    cst_Printf_bad_conversion = "Printf: bad conversion %[",
    _t_ = [0, cst_camlinternalFormat_ml, 1626, 39],
    _u_ = [0, cst_camlinternalFormat_ml, 1649, 31],
    _v_ = [0, cst_camlinternalFormat_ml, 1650, 31],
    cst_Printf_bad_conversion$0 = "Printf: bad conversion %_",
    _w_ = [0, cst_camlinternalFormat_ml, 1830, 8],
    ___ =
      [0,
       [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
       cst_bad_input_format_type_mism$0],
    _Z_ =
      [0,
       [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
       cst_bad_input_format_type_mism$0],
    _C_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, ", duplicate flag ", [1, 0]]]]]],
       "invalid format %S: at character number %d, duplicate flag %C"],
    cst_0 = cst_0$3,
    cst_padding = "padding",
    _D_ = [0, 1, 0],
    _E_ = [0, 0],
    cst_precision = cst_precision$3,
    _F_ = [1, 0],
    _G_ = [1, 1],
    cst_0$2 = "'0'",
    cst_0$0 = cst_0$3,
    _I_ = [1, 1],
    cst_0$1 = cst_0$3,
    cst_precision$0 = cst_precision$3,
    _H_ = [1, 1],
    cst_precision$1 = cst_precision$3,
    _M_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11,
            ", flag ",
            [1,
             [11,
              " is only allowed after the '",
              [12, 37, [11, "', before padding and precision", 0]]]]]]]]],
       "invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision"],
    _J_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11, ', invalid conversion "', [12, 37, [0, [12, 34, 0]]]]]]]],
       'invalid format %S: at character number %d, invalid conversion "%%%c"'],
    _K_ = [0, 0],
    cst_padding$0 = "`padding'",
    _L_ = [0, 0],
    cst_precision$2 = "`precision'",
    _N_ = [0, [12, 64, 0]],
    _O_ = [0, "@ ", 1, 0],
    _P_ = [0, "@,", 0, 0],
    _Q_ = [2, 60],
    _R_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ": '",
          [12,
           37,
           [11,
            "' alone is not accepted in character sets, use ",
            [12,
             37,
             [12,
              37,
              [11, " instead at position ", [4, 0, 0, 0, [12, 46, 0]]]]]]]]]],
       "invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d."],
    _S_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ": integer ",
          [4, 0, 0, 0, [11, " is greater than the limit ", [4, 0, 0, 0, 0]]]]]],
       "invalid format %S: integer %d is greater than the limit %d"],
    cst_digit = "digit",
    _T_ = [0, cst_camlinternalFormat_ml, 2837, 11],
    _U_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ': unclosed sub-format, expected "',
          [12, 37, [0, [11, '" at character number ', [4, 0, 0, 0, 0]]]]]]],
       'invalid format %S: unclosed sub-format, expected "%%%c" at character number %d'],
    cst_character = "character ')'",
    cst_character$0 = "character '}'",
    _V_ = [0, cst_camlinternalFormat_ml, 2899, 34],
    _W_ = [0, cst_camlinternalFormat_ml, 2935, 28],
    _X_ = [0, cst_camlinternalFormat_ml, 2957, 11],
    _Y_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11,
            cst$44,
            [2,
             0,
             [11,
              " is incompatible with '",
              [0, [11, "' in sub-format ", [3, 0, 0]]]]]]]]]],
       "invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S"],
    _B_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, cst$44, [2, 0, [11, " expected, read ", [1, 0]]]]]]]],
       "invalid format %S: at character number %d, %s expected, read %C"],
    _A_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, ", '", [0, [11, "' without ", [2, 0, 0]]]]]]]],
       "invalid format %S: at character number %d, '%c' without %s"],
    cst_non_zero_widths_are_unsupp =
      "non-zero widths are unsupported for %c conversions",
    cst_unexpected_end_of_format = "unexpected end of format",
    _z_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11, cst_at_character_number, [4, 0, 0, 0, [11, cst$44, [2, 0, 0]]]]]],
       "invalid format %S: at character number %d, %s"],
    _y_ =
      [0,
       [11, "invalid box description ", [3, 0, 0]],
       "invalid box description %S"],
    _x_ = [0, 0, 4],
    cst_nan = "nan",
    cst_neg_infinity = "neg_infinity",
    cst_infinity = "infinity",
    _r_ = [0, 103],
    cst_nd$0 = "%+nd",
    cst_nd$1 = "% nd",
    cst_ni$1 = "%+ni",
    cst_ni$2 = "% ni",
    cst_nx = "%nx",
    cst_nx$0 = "%#nx",
    cst_nX = "%nX",
    cst_nX$0 = "%#nX",
    cst_no = "%no",
    cst_no$0 = "%#no",
    cst_nd = "%nd",
    cst_ni$0 = cst_ni$3,
    cst_nu = "%nu",
    cst_ld$0 = "%+ld",
    cst_ld$1 = "% ld",
    cst_li$1 = "%+li",
    cst_li$2 = "% li",
    cst_lx = "%lx",
    cst_lx$0 = "%#lx",
    cst_lX = "%lX",
    cst_lX$0 = "%#lX",
    cst_lo = "%lo",
    cst_lo$0 = "%#lo",
    cst_ld = "%ld",
    cst_li$0 = cst_li$3,
    cst_lu = "%lu",
    cst_Ld$0 = "%+Ld",
    cst_Ld$1 = "% Ld",
    cst_Li$1 = "%+Li",
    cst_Li$2 = "% Li",
    cst_Lx = "%Lx",
    cst_Lx$0 = "%#Lx",
    cst_LX = "%LX",
    cst_LX$0 = "%#LX",
    cst_Lo = "%Lo",
    cst_Lo$0 = "%#Lo",
    cst_Ld = "%Ld",
    cst_Li$0 = cst_Li$3,
    cst_Lu = "%Lu",
    cst_d$0 = "%+d",
    cst_d$1 = "% d",
    cst_i$1 = "%+i",
    cst_i$2 = "% i",
    cst_x = "%x",
    cst_x$0 = "%#x",
    cst_X = "%X",
    cst_X$0 = "%#X",
    cst_o = "%o",
    cst_o$0 = "%#o",
    cst_d = "%d",
    cst_i$0 = cst_i$3,
    cst_u = cst_u$0,
    cst_0c = "0c",
    _a_ = [0, 0, 0],
    cst_CamlinternalFormat_Type_mi = "CamlinternalFormat.Type_mismatch";
   function create_char_set(param){return caml_call2(Stdlib_Bytes[1], 32, 0);}
   function add_in_char_set(char_set, c){
    var
     str_ind = c >>> 3 | 0,
     mask = 1 << (c & 7),
     _dU_ = runtime.caml_bytes_get(char_set, str_ind) | mask;
    return caml_bytes_set(char_set, str_ind, caml_call1(Stdlib[29], _dU_));
   }
   function freeze_char_set(char_set){
    return caml_call1(Stdlib_Bytes[6], char_set);
   }
   function rev_char_set(char_set){
    var char_set$0 = create_char_set(0), i = 0;
    for(;;){
     var _dS_ = caml_string_get(char_set, i) ^ 255;
     caml_bytes_set(char_set$0, i, caml_call1(Stdlib[29], _dS_));
     var _dT_ = i + 1 | 0;
     if(31 === i) return caml_call1(Stdlib_Bytes[44], char_set$0);
     var i = _dT_;
    }
   }
   function is_in_char_set(char_set, c){
    var str_ind = c >>> 3 | 0, mask = 1 << (c & 7);
    return 0 !== (caml_string_get(char_set, str_ind) & mask) ? 1 : 0;
   }
   function pad_of_pad_opt(pad_opt){
    if(! pad_opt) return 0;
    var width = pad_opt[1];
    return [0, 1, width];
   }
   function param_format_of_ignored_format(ign, fmt){
    if(typeof ign === "number")
     switch(ign){
       case 0:
        return [0, [0, fmt]];
       case 1:
        return [0, [1, fmt]];
       case 2:
        return [0, [19, fmt]];
       default: return [0, [22, fmt]];
     }
    switch(ign[0]){
      case 0:
       var pad_opt = ign[1]; return [0, [2, pad_of_pad_opt(pad_opt), fmt]];
      case 1:
       var pad_opt$0 = ign[1];
       return [0, [3, pad_of_pad_opt(pad_opt$0), fmt]];
      case 2:
       var pad_opt$1 = ign[2], iconv = ign[1];
       return [0, [4, iconv, pad_of_pad_opt(pad_opt$1), 0, fmt]];
      case 3:
       var pad_opt$2 = ign[2], iconv$0 = ign[1];
       return [0, [5, iconv$0, pad_of_pad_opt(pad_opt$2), 0, fmt]];
      case 4:
       var pad_opt$3 = ign[2], iconv$1 = ign[1];
       return [0, [6, iconv$1, pad_of_pad_opt(pad_opt$3), 0, fmt]];
      case 5:
       var pad_opt$4 = ign[2], iconv$2 = ign[1];
       return [0, [7, iconv$2, pad_of_pad_opt(pad_opt$4), 0, fmt]];
      case 6:
       var prec_opt = ign[2], pad_opt$5 = ign[1];
       if(prec_opt)
        var ndec = prec_opt[1], _dR_ = [0, ndec];
       else
        var _dR_ = 0;
       return [0, [8, _a_, pad_of_pad_opt(pad_opt$5), _dR_, fmt]];
      case 7:
       var pad_opt$6 = ign[1];
       return [0, [9, pad_of_pad_opt(pad_opt$6), fmt]];
      case 8:
       var fmtty = ign[2], pad_opt$7 = ign[1];
       return [0, [13, pad_opt$7, fmtty, fmt]];
      case 9:
       var fmtty$0 = ign[2], pad_opt$8 = ign[1];
       return [0, [14, pad_opt$8, fmtty$0, fmt]];
      case 10:
       var char_set = ign[2], width_opt = ign[1];
       return [0, [20, width_opt, char_set, fmt]];
      default: var counter = ign[1]; return [0, [21, counter, fmt]];
    }
   }
   function default_float_precision(fconv){return 5 === fconv[2] ? 12 : -6;}
   function buffer_create(init_size){
    return [0, 0, caml_create_bytes(init_size)];
   }
   function buffer_check_size(buf, overhead){
    var
     len = runtime.caml_ml_bytes_length(buf[2]),
     min_len = buf[1] + overhead | 0,
     _dP_ = len < min_len ? 1 : 0;
    if(_dP_){
     var
      new_len = caml_call2(Stdlib_Int[11], len * 2 | 0, min_len),
      new_str = caml_create_bytes(new_len);
     caml_call5(Stdlib_Bytes[11], buf[2], 0, new_str, 0, len);
     buf[2] = new_str;
     var _dQ_ = 0;
    }
    else
     var _dQ_ = _dP_;
    return _dQ_;
   }
   function buffer_add_char(buf, c){
    buffer_check_size(buf, 1);
    caml_bytes_set(buf[2], buf[1], c);
    buf[1] = buf[1] + 1 | 0;
    return 0;
   }
   function buffer_add_string(buf, s){
    var str_len = caml_ml_string_length(s);
    buffer_check_size(buf, str_len);
    caml_call5(Stdlib_String[48], s, 0, buf[2], buf[1], str_len);
    buf[1] = buf[1] + str_len | 0;
    return 0;
   }
   function buffer_contents(buf){
    return caml_call3(Stdlib_Bytes[8], buf[2], 0, buf[1]);
   }
   function char_of_iconv(iconv){
    switch(iconv){
      case 6:
      case 7:
       return 120;
      case 8:
      case 9:
       return 88;
      case 10:
      case 11:
       return 111;
      case 12:
      case 15:
       return 117;
      case 0:
      case 1:
      case 2:
      case 13:
       return 100;
      default: return 105;
    }
   }
   function char_of_fconv(opt, fconv){
    if(opt) var sth = opt[1], cF = sth; else var cF = 70;
    switch(fconv[2]){
      case 0:
       return 102;
      case 1:
       return 101;
      case 2:
       return 69;
      case 3:
       return 103;
      case 4:
       return 71;
      case 5:
       return cF;
      case 6:
       return 104;
      case 7:
       return 72;
      default: return 70;
    }
   }
   function bprint_padty(buf, padty){
    switch(padty){
      case 0:
       return buffer_add_char(buf, 45);
      case 1:
       return 0;
      default: return buffer_add_char(buf, 48);
    }
   }
   function bprint_ignored_flag(buf, ign_flag){
    return ign_flag ? buffer_add_char(buf, 95) : ign_flag;
   }
   function bprint_pad_opt(buf, pad_opt){
    if(! pad_opt) return 0;
    var width = pad_opt[1];
    return buffer_add_string(buf, caml_call1(Stdlib_Int[12], width));
   }
   function bprint_padding(buf, pad){
    if(typeof pad === "number") return 0;
    if(0 === pad[0]){
     var n = pad[2], padty = pad[1];
     bprint_padty(buf, padty);
     return buffer_add_string(buf, caml_call1(Stdlib_Int[12], n));
    }
    var padty$0 = pad[1];
    bprint_padty(buf, padty$0);
    return buffer_add_char(buf, 42);
   }
   function bprint_precision(buf, prec){
    if(typeof prec === "number")
     return prec ? buffer_add_string(buf, cst) : 0;
    var n = prec[1];
    buffer_add_char(buf, 46);
    return buffer_add_string(buf, caml_call1(Stdlib_Int[12], n));
   }
   function bprint_iconv_flag(buf, iconv){
    switch(iconv){
      case 1:
      case 4:
       return buffer_add_char(buf, 43);
      case 2:
      case 5:
       return buffer_add_char(buf, 32);
      case 7:
      case 9:
      case 11:
      case 13:
      case 14:
      case 15:
       return buffer_add_char(buf, 35);
      default: return 0;
    }
   }
   function bprint_altint_fmt(buf, ign_flag, iconv, pad, prec, c){
    buffer_add_char(buf, 37);
    bprint_ignored_flag(buf, ign_flag);
    bprint_iconv_flag(buf, iconv);
    bprint_padding(buf, pad);
    bprint_precision(buf, prec);
    buffer_add_char(buf, c);
    return buffer_add_char(buf, char_of_iconv(iconv));
   }
   function bprint_fconv_flag(buf, fconv){
    switch(fconv[1]){
      case 0: break;
      case 1:
       buffer_add_char(buf, 43); break;
      default: buffer_add_char(buf, 32);
    }
    return 8 <= fconv[2] ? buffer_add_char(buf, 35) : 0;
   }
   function string_of_formatting_lit(formatting_lit){
    if(typeof formatting_lit === "number")
     switch(formatting_lit){
       case 0:
        return cst$0;
       case 1:
        return cst$1;
       case 2:
        return cst$2;
       case 3:
        return cst$3;
       case 4:
        return cst$4;
       case 5:
        return cst$5;
       default: return cst$6;
     }
    switch(formatting_lit[0]){
      case 0:
       var str = formatting_lit[1]; return str;
      case 1:
       var str$0 = formatting_lit[1]; return str$0;
      default:
       var c = formatting_lit[1], _dO_ = caml_call2(Stdlib_String[1], 1, c);
       return caml_call2(Stdlib[28], cst$7, _dO_);
    }
   }
   function bprint_char_literal(buf, chr){
    return 37 === chr
            ? buffer_add_string(buf, cst$8)
            : buffer_add_char(buf, chr);
   }
   function bprint_string_literal(buf, str){
    var _dM_ = caml_ml_string_length(str) - 1 | 0, _dL_ = 0;
    if(_dM_ >= 0){
     var i = _dL_;
     for(;;){
      bprint_char_literal(buf, caml_string_get(str, i));
      var _dN_ = i + 1 | 0;
      if(_dM_ !== i){var i = _dN_; continue;}
      break;
     }
    }
    return 0;
   }
   function bprint_fmtty(buf, fmtty){
    var fmtty$0 = fmtty;
    for(;;){
     if(typeof fmtty$0 === "number") return 0;
     switch(fmtty$0[0]){
       case 0:
        var fmtty$1 = fmtty$0[1];
        buffer_add_string(buf, cst_c);
        var fmtty$0 = fmtty$1;
        continue;
       case 1:
        var fmtty$2 = fmtty$0[1];
        buffer_add_string(buf, cst_s);
        var fmtty$0 = fmtty$2;
        continue;
       case 2:
        var fmtty$3 = fmtty$0[1];
        buffer_add_string(buf, cst_i);
        var fmtty$0 = fmtty$3;
        continue;
       case 3:
        var fmtty$4 = fmtty$0[1];
        buffer_add_string(buf, cst_li);
        var fmtty$0 = fmtty$4;
        continue;
       case 4:
        var fmtty$5 = fmtty$0[1];
        buffer_add_string(buf, cst_ni);
        var fmtty$0 = fmtty$5;
        continue;
       case 5:
        var fmtty$6 = fmtty$0[1];
        buffer_add_string(buf, cst_Li);
        var fmtty$0 = fmtty$6;
        continue;
       case 6:
        var fmtty$7 = fmtty$0[1];
        buffer_add_string(buf, cst_f);
        var fmtty$0 = fmtty$7;
        continue;
       case 7:
        var fmtty$8 = fmtty$0[1];
        buffer_add_string(buf, cst_B);
        var fmtty$0 = fmtty$8;
        continue;
       case 8:
        var fmtty$9 = fmtty$0[2], sub_fmtty = fmtty$0[1];
        buffer_add_string(buf, cst$9);
        bprint_fmtty(buf, sub_fmtty);
        buffer_add_string(buf, cst$10);
        var fmtty$0 = fmtty$9;
        continue;
       case 9:
        var fmtty$10 = fmtty$0[3], sub_fmtty$0 = fmtty$0[1];
        buffer_add_string(buf, cst$11);
        bprint_fmtty(buf, sub_fmtty$0);
        buffer_add_string(buf, cst$12);
        var fmtty$0 = fmtty$10;
        continue;
       case 10:
        var fmtty$11 = fmtty$0[1];
        buffer_add_string(buf, cst_a);
        var fmtty$0 = fmtty$11;
        continue;
       case 11:
        var fmtty$12 = fmtty$0[1];
        buffer_add_string(buf, cst_t);
        var fmtty$0 = fmtty$12;
        continue;
       case 12:
        var fmtty$13 = fmtty$0[1];
        buffer_add_string(buf, cst$13);
        var fmtty$0 = fmtty$13;
        continue;
       case 13:
        var fmtty$14 = fmtty$0[1];
        buffer_add_string(buf, cst_r);
        var fmtty$0 = fmtty$14;
        continue;
       default:
        var fmtty$15 = fmtty$0[1];
        buffer_add_string(buf, cst_r$0);
        var fmtty$0 = fmtty$15;
        continue;
     }
    }
   }
   function int_of_custom_arity(param){
    if(! param) return 0;
    var x = param[1];
    return 1 + int_of_custom_arity(x) | 0;
   }
   function string_of_fmt(fmt){
    var buf = buffer_create(16);
    function fmtiter(fmt, ign_flag){
     var fmt$0 = fmt, ign_flag$0 = ign_flag;
     a:
     for(;;){
      if(typeof fmt$0 === "number") return 0;
      switch(fmt$0[0]){
        case 0:
         var rest = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 99);
         var fmt$0 = rest, ign_flag$0 = 0;
         continue;
        case 1:
         var rest$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 67);
         var fmt$0 = rest$0, ign_flag$0 = 0;
         continue;
        case 2:
         var rest$1 = fmt$0[2], pad = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad);
         buffer_add_char(buf, 115);
         var fmt$0 = rest$1, ign_flag$0 = 0;
         continue;
        case 3:
         var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad$0);
         buffer_add_char(buf, 83);
         var fmt$0 = rest$2, ign_flag$0 = 0;
         continue;
        case 4:
         var
          rest$3 = fmt$0[4],
          prec = fmt$0[3],
          pad$1 = fmt$0[2],
          iconv = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_iconv_flag(buf, iconv);
         bprint_padding(buf, pad$1);
         bprint_precision(buf, prec);
         buffer_add_char(buf, char_of_iconv(iconv));
         var fmt$0 = rest$3, ign_flag$0 = 0;
         continue;
        case 5:
         var
          rest$4 = fmt$0[4],
          prec$0 = fmt$0[3],
          pad$2 = fmt$0[2],
          iconv$0 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$0, pad$2, prec$0, 108);
         var fmt$0 = rest$4, ign_flag$0 = 0;
         continue;
        case 6:
         var
          rest$5 = fmt$0[4],
          prec$1 = fmt$0[3],
          pad$3 = fmt$0[2],
          iconv$1 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$1, pad$3, prec$1, 110);
         var fmt$0 = rest$5, ign_flag$0 = 0;
         continue;
        case 7:
         var
          rest$6 = fmt$0[4],
          prec$2 = fmt$0[3],
          pad$4 = fmt$0[2],
          iconv$2 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$2, pad$4, prec$2, 76);
         var fmt$0 = rest$6, ign_flag$0 = 0;
         continue;
        case 8:
         var
          rest$7 = fmt$0[4],
          prec$3 = fmt$0[3],
          pad$5 = fmt$0[2],
          fconv = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_fconv_flag(buf, fconv);
         bprint_padding(buf, pad$5);
         bprint_precision(buf, prec$3);
         buffer_add_char(buf, char_of_fconv(0, fconv));
         var fmt$0 = rest$7, ign_flag$0 = 0;
         continue;
        case 9:
         var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad$6);
         buffer_add_char(buf, 66);
         var fmt$0 = rest$8, ign_flag$0 = 0;
         continue;
        case 10:
         var rest$9 = fmt$0[1];
         buffer_add_string(buf, cst$14);
         var fmt$0 = rest$9;
         continue;
        case 11:
         var rest$10 = fmt$0[2], str = fmt$0[1];
         bprint_string_literal(buf, str);
         var fmt$0 = rest$10;
         continue;
        case 12:
         var rest$11 = fmt$0[2], chr = fmt$0[1];
         bprint_char_literal(buf, chr);
         var fmt$0 = rest$11;
         continue;
        case 13:
         var rest$12 = fmt$0[3], fmtty = fmt$0[2], pad_opt = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, pad_opt);
         buffer_add_char(buf, 123);
         bprint_fmtty(buf, fmtty);
         buffer_add_char(buf, 37);
         buffer_add_char(buf, 125);
         var fmt$0 = rest$12, ign_flag$0 = 0;
         continue;
        case 14:
         var rest$13 = fmt$0[3], fmtty$0 = fmt$0[2], pad_opt$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, pad_opt$0);
         buffer_add_char(buf, 40);
         bprint_fmtty(buf, fmtty$0);
         buffer_add_char(buf, 37);
         buffer_add_char(buf, 41);
         var fmt$0 = rest$13, ign_flag$0 = 0;
         continue;
        case 15:
         var rest$14 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 97);
         var fmt$0 = rest$14, ign_flag$0 = 0;
         continue;
        case 16:
         var rest$15 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 116);
         var fmt$0 = rest$15, ign_flag$0 = 0;
         continue;
        case 17:
         var rest$16 = fmt$0[2], fmting_lit = fmt$0[1];
         bprint_string_literal(buf, string_of_formatting_lit(fmting_lit));
         var fmt$0 = rest$16;
         continue;
        case 18:
         var rest$17 = fmt$0[2], fmting_gen = fmt$0[1];
         if(0 === fmting_gen[0]){
          var str$0 = fmting_gen[1][2];
          buffer_add_string(buf, cst$15);
          buffer_add_string(buf, str$0);
         }
         else{
          var str$1 = fmting_gen[1][2];
          buffer_add_string(buf, cst$16);
          buffer_add_string(buf, str$1);
         }
         var fmt$0 = rest$17;
         continue;
        case 19:
         var rest$18 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 114);
         var fmt$0 = rest$18, ign_flag$0 = 0;
         continue;
        case 20:
         var rest$19 = fmt$0[3], char_set = fmt$0[2], width_opt = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, width_opt);
         var
          print_char =
            function(buf, i){
             var c = caml_call1(Stdlib[29], i);
             return 37 === c
                     ? (buffer_add_char(buf, 37), buffer_add_char(buf, 37))
                     : 64
                       === c
                       ? (buffer_add_char(buf, 37), buffer_add_char(buf, 64))
                       : buffer_add_char(buf, c);
            };
         buffer_add_char(buf, 91);
         var
          set =
            is_in_char_set(char_set, 0)
             ? (buffer_add_char(buf, 94), rev_char_set(char_set))
             : char_set,
          is_alone$0 =
            function(set){
             function is_alone(c){
              var
               after = caml_call1(Stdlib_Char[1], c + 1 | 0),
               before = caml_call1(Stdlib_Char[1], c - 1 | 0),
               _dH_ = is_in_char_set(set, c);
              if(_dH_)
               var
                _dI_ = is_in_char_set(set, before),
                _dJ_ = _dI_ ? is_in_char_set(set, after) : _dI_,
                _dK_ = 1 - _dJ_;
              else
               var _dK_ = _dH_;
              return _dK_;
             }
             return is_alone;
            },
          is_alone = is_alone$0(set);
         if(is_alone(93)) buffer_add_char(buf, 93);
         var i = 1;
         b:
         for(;;){
          if(i < 256){
           if(! is_in_char_set(set, caml_call1(Stdlib[29], i))){var i$0 = i + 1 | 0, i = i$0; continue;}
           var switcher = caml_call1(Stdlib[29], i) - 45 | 0, switch$0 = 0;
           if(48 < switcher >>> 0)
            if(210 <= switcher) print_char(buf, 255); else switch$0 = 1;
           else{
            if(46 < switcher - 1 >>> 0){
             var i$2 = i + 1 | 0, i = i$2;
             continue;
            }
            switch$0 = 1;
           }
           if(switch$0){
            var i$1 = i + 1 | 0;
            if(! is_in_char_set(set, caml_call1(Stdlib[29], i$1))){
             print_char(buf, i$1 - 1 | 0);
             var i$6 = i$1 + 1 | 0, i = i$6;
             continue;
            }
            var
             switcher$0 = caml_call1(Stdlib[29], i$1) - 45 | 0,
             switch$1 = 0;
            if(48 < switcher$0 >>> 0){
             if(210 <= switcher$0){
              print_char(buf, 254);
              print_char(buf, 255);
              switch$1 = 1;
             }
            }
            else if
             (46 < switcher$0 - 1 >>> 0
              && ! is_in_char_set(set, caml_call1(Stdlib[29], i$1 + 1 | 0))){
             print_char(buf, i$1 - 1 | 0);
             var i$5 = i$1 + 1 | 0, i = i$5;
             continue;
            }
            if(! switch$1){
             if(! is_in_char_set(set, caml_call1(Stdlib[29], i$1 + 1 | 0))){
              print_char(buf, i$1 - 1 | 0);
              print_char(buf, i$1);
              var i$4 = i$1 + 2 | 0, i = i$4;
              continue;
             }
             var j = i$1 + 2 | 0, i$3 = i$1 - 1 | 0, j$0 = j;
             for(;;){
              if
               (256 !== j$0
                && is_in_char_set(set, caml_call1(Stdlib[29], j$0))){var j$1 = j$0 + 1 | 0, j$0 = j$1; continue;}
              print_char(buf, i$3);
              print_char(buf, 45);
              print_char(buf, j$0 - 1 | 0);
              if(j$0 < 256){var i$7 = j$0 + 1 | 0, i = i$7; continue b;}
              break;
             }
            }
           }
          }
          if(is_alone(45)) buffer_add_char(buf, 45);
          buffer_add_char(buf, 93);
          var fmt$0 = rest$19, ign_flag$0 = 0;
          continue a;
         }
        case 21:
         var rest$20 = fmt$0[2], counter = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         switch(counter){
           case 0:
            var _dD_ = 108; break;
           case 1:
            var _dD_ = 110; break;
           default: var _dD_ = 78;
         }
         buffer_add_char(buf, _dD_);
         var fmt$0 = rest$20, ign_flag$0 = 0;
         continue;
        case 22:
         var rest$21 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_string_literal(buf, cst_0c);
         var fmt$0 = rest$21, ign_flag$0 = 0;
         continue;
        case 23:
         var
          rest$22 = fmt$0[2],
          ign = fmt$0[1],
          fmt$1 = param_format_of_ignored_format(ign, rest$22)[1],
          fmt$0 = fmt$1,
          ign_flag$0 = 1;
         continue;
        default:
         var
          rest$23 = fmt$0[3],
          arity = fmt$0[1],
          _dF_ = int_of_custom_arity(arity),
          _dE_ = 1;
         if(_dF_ >= 1){
          var i$8 = _dE_;
          for(;;){
           buffer_add_char(buf, 37);
           bprint_ignored_flag(buf, ign_flag$0);
           buffer_add_char(buf, 63);
           var _dG_ = i$8 + 1 | 0;
           if(_dF_ !== i$8){var i$8 = _dG_; continue;}
           break;
          }
         }
         var fmt$0 = rest$23, ign_flag$0 = 0;
         continue;
      }
     }
    }
    fmtiter(fmt, 0);
    return buffer_contents(buf);
   }
   function symm(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, symm(rest)];
      case 1:
       var rest$0 = param[1]; return [1, symm(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, symm(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, symm(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, symm(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, symm(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, symm(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, symm(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1]; return [8, ty, symm(rest$7)];
      case 9:
       var rest$8 = param[3], ty2 = param[2], ty1 = param[1];
       return [9, ty2, ty1, symm(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, symm(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, symm(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, symm(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, symm(rest$12)];
      default: var rest$13 = param[1]; return [14, symm(rest$13)];
    }
   }
   function fmtty_rel_det(param){
    if(typeof param !== "number")
     switch(param[0]){
       case 0:
        var
         rest = param[1],
         match = fmtty_rel_det(rest),
         de = match[4],
         ed = match[3],
         af = match[2],
         fa = match[1],
         _di_ = function(param){af(0); return 0;};
        return [0, function(param){fa(0); return 0;}, _di_, ed, de];
       case 1:
        var
         rest$0 = param[1],
         match$0 = fmtty_rel_det(rest$0),
         de$0 = match$0[4],
         ed$0 = match$0[3],
         af$0 = match$0[2],
         fa$0 = match$0[1],
         _dj_ = function(param){af$0(0); return 0;};
        return [0, function(param){fa$0(0); return 0;}, _dj_, ed$0, de$0];
       case 2:
        var
         rest$1 = param[1],
         match$1 = fmtty_rel_det(rest$1),
         de$1 = match$1[4],
         ed$1 = match$1[3],
         af$1 = match$1[2],
         fa$1 = match$1[1],
         _dk_ = function(param){af$1(0); return 0;};
        return [0, function(param){fa$1(0); return 0;}, _dk_, ed$1, de$1];
       case 3:
        var
         rest$2 = param[1],
         match$2 = fmtty_rel_det(rest$2),
         de$2 = match$2[4],
         ed$2 = match$2[3],
         af$2 = match$2[2],
         fa$2 = match$2[1],
         _dl_ = function(param){af$2(0); return 0;};
        return [0, function(param){fa$2(0); return 0;}, _dl_, ed$2, de$2];
       case 4:
        var
         rest$3 = param[1],
         match$3 = fmtty_rel_det(rest$3),
         de$3 = match$3[4],
         ed$3 = match$3[3],
         af$3 = match$3[2],
         fa$3 = match$3[1],
         _dm_ = function(param){af$3(0); return 0;};
        return [0, function(param){fa$3(0); return 0;}, _dm_, ed$3, de$3];
       case 5:
        var
         rest$4 = param[1],
         match$4 = fmtty_rel_det(rest$4),
         de$4 = match$4[4],
         ed$4 = match$4[3],
         af$4 = match$4[2],
         fa$4 = match$4[1],
         _dn_ = function(param){af$4(0); return 0;};
        return [0, function(param){fa$4(0); return 0;}, _dn_, ed$4, de$4];
       case 6:
        var
         rest$5 = param[1],
         match$5 = fmtty_rel_det(rest$5),
         de$5 = match$5[4],
         ed$5 = match$5[3],
         af$5 = match$5[2],
         fa$5 = match$5[1],
         _do_ = function(param){af$5(0); return 0;};
        return [0, function(param){fa$5(0); return 0;}, _do_, ed$5, de$5];
       case 7:
        var
         rest$6 = param[1],
         match$6 = fmtty_rel_det(rest$6),
         de$6 = match$6[4],
         ed$6 = match$6[3],
         af$6 = match$6[2],
         fa$6 = match$6[1],
         _dp_ = function(param){af$6(0); return 0;};
        return [0, function(param){fa$6(0); return 0;}, _dp_, ed$6, de$6];
       case 8:
        var
         rest$7 = param[2],
         match$7 = fmtty_rel_det(rest$7),
         de$7 = match$7[4],
         ed$7 = match$7[3],
         af$7 = match$7[2],
         fa$7 = match$7[1],
         _dq_ = function(param){af$7(0); return 0;};
        return [0, function(param){fa$7(0); return 0;}, _dq_, ed$7, de$7];
       case 9:
        var
         rest$8 = param[3],
         ty2 = param[2],
         ty1 = param[1],
         match$8 = fmtty_rel_det(rest$8),
         de$8 = match$8[4],
         ed$8 = match$8[3],
         af$8 = match$8[2],
         fa$8 = match$8[1],
         ty = trans(symm(ty1), ty2),
         match$9 = fmtty_rel_det(ty),
         jd = match$9[4],
         dj = match$9[3],
         ga = match$9[2],
         ag = match$9[1],
         _dr_ = function(param){jd(0); de$8(0); return 0;},
         _ds_ = function(param){ed$8(0); dj(0); return 0;},
         _dt_ = function(param){ga(0); af$8(0); return 0;};
        return [0,
                function(param){fa$8(0); ag(0); return 0;},
                _dt_,
                _ds_,
                _dr_];
       case 10:
        var
         rest$9 = param[1],
         match$10 = fmtty_rel_det(rest$9),
         de$9 = match$10[4],
         ed$9 = match$10[3],
         af$9 = match$10[2],
         fa$9 = match$10[1],
         _du_ = function(param){af$9(0); return 0;};
        return [0, function(param){fa$9(0); return 0;}, _du_, ed$9, de$9];
       case 11:
        var
         rest$10 = param[1],
         match$11 = fmtty_rel_det(rest$10),
         de$10 = match$11[4],
         ed$10 = match$11[3],
         af$10 = match$11[2],
         fa$10 = match$11[1],
         _dv_ = function(param){af$10(0); return 0;};
        return [0, function(param){fa$10(0); return 0;}, _dv_, ed$10, de$10];
       case 12:
        var
         rest$11 = param[1],
         match$12 = fmtty_rel_det(rest$11),
         de$11 = match$12[4],
         ed$11 = match$12[3],
         af$11 = match$12[2],
         fa$11 = match$12[1],
         _dw_ = function(param){af$11(0); return 0;};
        return [0, function(param){fa$11(0); return 0;}, _dw_, ed$11, de$11];
       case 13:
        var
         rest$12 = param[1],
         match$13 = fmtty_rel_det(rest$12),
         de$12 = match$13[4],
         ed$12 = match$13[3],
         af$12 = match$13[2],
         fa$12 = match$13[1],
         _dx_ = function(param){de$12(0); return 0;},
         _dy_ = function(param){ed$12(0); return 0;},
         _dz_ = function(param){af$12(0); return 0;};
        return [0, function(param){fa$12(0); return 0;}, _dz_, _dy_, _dx_];
       default:
        var
         rest$13 = param[1],
         match$14 = fmtty_rel_det(rest$13),
         de$13 = match$14[4],
         ed$13 = match$14[3],
         af$13 = match$14[2],
         fa$13 = match$14[1],
         _dA_ = function(param){de$13(0); return 0;},
         _dB_ = function(param){ed$13(0); return 0;},
         _dC_ = function(param){af$13(0); return 0;};
        return [0, function(param){fa$13(0); return 0;}, _dC_, _dB_, _dA_];
     }
    function _df_(param){return 0;}
    function _dg_(param){return 0;}
    function _dh_(param){return 0;}
    return [0, function(param){return 0;}, _dh_, _dg_, _df_];
   }
   function trans(ty1, ty2){
    var switch$0 = 0;
    if(typeof ty1 === "number"){
     if(typeof ty2 === "number") return 0;
     switch(ty2[0]){
       case 10: break;
       case 11:
        switch$0 = 1; break;
       case 12:
        switch$0 = 2; break;
       case 13:
        switch$0 = 3; break;
       case 14:
        switch$0 = 4; break;
       case 8:
        switch$0 = 5; break;
       case 9:
        switch$0 = 6; break;
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     }
    }
    else
     switch(ty1[0]){
       case 0:
        var rest1 = ty1[1], switch$1 = 0;
        if(typeof ty2 === "number")
         switch$1 = 1;
        else
         switch(ty2[0]){
           case 0:
            var rest2 = ty2[1]; return [0, trans(rest1, rest2)];
           case 8:
            switch$0 = 5; break;
           case 9:
            switch$0 = 6; break;
           case 10: break;
           case 11:
            switch$0 = 1; break;
           case 12:
            switch$0 = 2; break;
           case 13:
            switch$0 = 3; break;
           case 14:
            switch$0 = 4; break;
           default: switch$1 = 1;
         }
        if(switch$1) switch$0 = 7;
        break;
       case 1:
        var rest1$0 = ty1[1], switch$2 = 0;
        if(typeof ty2 === "number")
         switch$2 = 1;
        else
         switch(ty2[0]){
           case 1:
            var rest2$0 = ty2[1]; return [1, trans(rest1$0, rest2$0)];
           case 8:
            switch$0 = 5; break;
           case 9:
            switch$0 = 6; break;
           case 10: break;
           case 11:
            switch$0 = 1; break;
           case 12:
            switch$0 = 2; break;
           case 13:
            switch$0 = 3; break;
           case 14:
            switch$0 = 4; break;
           default: switch$2 = 1;
         }
        if(switch$2) switch$0 = 7;
        break;
       case 2:
        var rest1$1 = ty1[1], switch$3 = 0;
        if(typeof ty2 === "number")
         switch$3 = 1;
        else
         switch(ty2[0]){
           case 2:
            var rest2$1 = ty2[1]; return [2, trans(rest1$1, rest2$1)];
           case 8:
            switch$0 = 5; break;
           case 9:
            switch$0 = 6; break;
           case 10: break;
           case 11:
            switch$0 = 1; break;
           case 12:
            switch$0 = 2; break;
           case 13:
            switch$0 = 3; break;
           case 14:
            switch$0 = 4; break;
           default: switch$3 = 1;
         }
        if(switch$3) switch$0 = 7;
        break;
       case 3:
        var rest1$2 = ty1[1], switch$4 = 0;
        if(typeof ty2 === "number")
         switch$4 = 1;
        else
         switch(ty2[0]){
           case 3:
            var rest2$2 = ty2[1]; return [3, trans(rest1$2, rest2$2)];
           case 8:
            switch$0 = 5; break;
           case 9:
            switch$0 = 6; break;
           case 10: break;
           case 11:
            switch$0 = 1; break;
           case 12:
            switch$0 = 2; break;
           case 13:
            switch$0 = 3; break;
           case 14:
            switch$0 = 4; break;
           default: switch$4 = 1;
         }
        if(switch$4) switch$0 = 7;
        break;
       case 4:
        var rest1$3 = ty1[1], switch$5 = 0;
        if(typeof ty2 === "number")
         switch$5 = 1;
        else
         switch(ty2[0]){
           case 4:
            var rest2$3 = ty2[1]; return [4, trans(rest1$3, rest2$3)];
           case 8:
            switch$0 = 5; break;
           case 9:
            switch$0 = 6; break;
           case 10: break;
           case 11:
            switch$0 = 1; break;
           case 12:
            switch$0 = 2; break;
           case 13:
            switch$0 = 3; break;
           case 14:
            switch$0 = 4; break;
           default: switch$5 = 1;
         }
        if(switch$5) switch$0 = 7;
        break;
       case 5:
        var rest1$4 = ty1[1], switch$6 = 0;
        if(typeof ty2 === "number")
         switch$6 = 1;
        else
         switch(ty2[0]){
           case 5:
            var rest2$4 = ty2[1]; return [5, trans(rest1$4, rest2$4)];
           case 8:
            switch$0 = 5; break;
           case 9:
            switch$0 = 6; break;
           case 10: break;
           case 11:
            switch$0 = 1; break;
           case 12:
            switch$0 = 2; break;
           case 13:
            switch$0 = 3; break;
           case 14:
            switch$0 = 4; break;
           default: switch$6 = 1;
         }
        if(switch$6) switch$0 = 7;
        break;
       case 6:
        var rest1$5 = ty1[1], switch$7 = 0;
        if(typeof ty2 === "number")
         switch$7 = 1;
        else
         switch(ty2[0]){
           case 6:
            var rest2$5 = ty2[1]; return [6, trans(rest1$5, rest2$5)];
           case 8:
            switch$0 = 5; break;
           case 9:
            switch$0 = 6; break;
           case 10: break;
           case 11:
            switch$0 = 1; break;
           case 12:
            switch$0 = 2; break;
           case 13:
            switch$0 = 3; break;
           case 14:
            switch$0 = 4; break;
           default: switch$7 = 1;
         }
        if(switch$7) switch$0 = 7;
        break;
       case 7:
        var rest1$6 = ty1[1], switch$8 = 0;
        if(typeof ty2 === "number")
         switch$8 = 1;
        else
         switch(ty2[0]){
           case 7:
            var rest2$6 = ty2[1]; return [7, trans(rest1$6, rest2$6)];
           case 8:
            switch$0 = 5; break;
           case 9:
            switch$0 = 6; break;
           case 10: break;
           case 11:
            switch$0 = 1; break;
           case 12:
            switch$0 = 2; break;
           case 13:
            switch$0 = 3; break;
           case 14:
            switch$0 = 4; break;
           default: switch$8 = 1;
         }
        if(switch$8) switch$0 = 7;
        break;
       case 8:
        var rest1$7 = ty1[2], ty1$0 = ty1[1], switch$9 = 0;
        if(typeof ty2 === "number")
         switch$9 = 1;
        else
         switch(ty2[0]){
           case 8:
            var
             rest2$7 = ty2[2],
             ty2$0 = ty2[1],
             _de_ = trans(rest1$7, rest2$7);
            return [8, trans(ty1$0, ty2$0), _de_];
           case 10: break;
           case 11:
            switch$0 = 1; break;
           case 12:
            switch$0 = 2; break;
           case 13:
            switch$0 = 3; break;
           case 14:
            switch$0 = 4; break;
           default: switch$9 = 1;
         }
        if(switch$9)
         throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
        break;
       case 9:
        var rest1$8 = ty1[3], ty12 = ty1[2], ty11 = ty1[1], switch$10 = 0;
        if(typeof ty2 === "number")
         switch$10 = 1;
        else
         switch(ty2[0]){
           case 8:
            switch$0 = 5; break;
           case 9:
            var
             rest2$8 = ty2[3],
             ty22 = ty2[2],
             ty21 = ty2[1],
             ty = trans(symm(ty12), ty21),
             match = fmtty_rel_det(ty),
             f4 = match[4],
             f2 = match[2];
            f2(0);
            f4(0);
            return [9, ty11, ty22, trans(rest1$8, rest2$8)];
           case 10: break;
           case 11:
            switch$0 = 1; break;
           case 12:
            switch$0 = 2; break;
           case 13:
            switch$0 = 3; break;
           case 14:
            switch$0 = 4; break;
           default: switch$10 = 1;
         }
        if(switch$10)
         throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
        break;
       case 10:
        var rest1$9 = ty1[1];
        if(typeof ty2 !== "number" && 10 === ty2[0]){
         var rest2$9 = ty2[1];
         return [10, trans(rest1$9, rest2$9)];
        }
        throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
       case 11:
        var rest1$10 = ty1[1], switch$11 = 0;
        if(typeof ty2 === "number")
         switch$11 = 1;
        else
         switch(ty2[0]){
           case 10: break;
           case 11:
            var rest2$10 = ty2[1]; return [11, trans(rest1$10, rest2$10)];
           default: switch$11 = 1;
         }
        if(switch$11)
         throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
        break;
       case 12:
        var rest1$11 = ty1[1], switch$12 = 0;
        if(typeof ty2 === "number")
         switch$12 = 1;
        else
         switch(ty2[0]){
           case 10: break;
           case 11:
            switch$0 = 1; break;
           case 12:
            var rest2$11 = ty2[1]; return [12, trans(rest1$11, rest2$11)];
           default: switch$12 = 1;
         }
        if(switch$12)
         throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
        break;
       case 13:
        var rest1$12 = ty1[1], switch$13 = 0;
        if(typeof ty2 === "number")
         switch$13 = 1;
        else
         switch(ty2[0]){
           case 10: break;
           case 11:
            switch$0 = 1; break;
           case 12:
            switch$0 = 2; break;
           case 13:
            var rest2$12 = ty2[1]; return [13, trans(rest1$12, rest2$12)];
           default: switch$13 = 1;
         }
        if(switch$13)
         throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
        break;
       default:
        var rest1$13 = ty1[1], switch$14 = 0;
        if(typeof ty2 === "number")
         switch$14 = 1;
        else
         switch(ty2[0]){
           case 10: break;
           case 11:
            switch$0 = 1; break;
           case 12:
            switch$0 = 2; break;
           case 13:
            switch$0 = 3; break;
           case 14:
            var rest2$13 = ty2[1]; return [14, trans(rest1$13, rest2$13)];
           default: switch$14 = 1;
         }
        if(switch$14)
         throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
     }
    switch(switch$0){
      case 0:
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      case 1:
       throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
      case 2:
       throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
      case 3:
       throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
      case 4:
       throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
      case 5:
       throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
      case 6:
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      default: throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
    }
   }
   function fmtty_of_padding_fmtty(pad, fmtty){
    return typeof pad === "number" ? fmtty : 0 === pad[0] ? fmtty : [2, fmtty];
   }
   function fmtty_of_custom(arity, fmtty){
    if(! arity) return fmtty;
    var arity$0 = arity[1];
    return [12, fmtty_of_custom(arity$0, fmtty)];
   }
   function fmtty_of_fmt(fmtty){
    var fmtty$0 = fmtty;
    for(;;){
     if(typeof fmtty$0 === "number") return 0;
     switch(fmtty$0[0]){
       case 0:
        var rest = fmtty$0[1]; return [0, fmtty_of_fmt(rest)];
       case 1:
        var rest$0 = fmtty$0[1]; return [0, fmtty_of_fmt(rest$0)];
       case 2:
        var rest$1 = fmtty$0[2], pad = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad, [1, fmtty_of_fmt(rest$1)]);
       case 3:
        var rest$2 = fmtty$0[2], pad$0 = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad$0, [1, fmtty_of_fmt(rest$2)]);
       case 4:
        var
         rest$3 = fmtty$0[4],
         prec = fmtty$0[3],
         pad$1 = fmtty$0[2],
         ty_rest = fmtty_of_fmt(rest$3),
         prec_ty = fmtty_of_precision_fmtty(prec, [2, ty_rest]);
        return fmtty_of_padding_fmtty(pad$1, prec_ty);
       case 5:
        var
         rest$4 = fmtty$0[4],
         prec$0 = fmtty$0[3],
         pad$2 = fmtty$0[2],
         ty_rest$0 = fmtty_of_fmt(rest$4),
         prec_ty$0 = fmtty_of_precision_fmtty(prec$0, [3, ty_rest$0]);
        return fmtty_of_padding_fmtty(pad$2, prec_ty$0);
       case 6:
        var
         rest$5 = fmtty$0[4],
         prec$1 = fmtty$0[3],
         pad$3 = fmtty$0[2],
         ty_rest$1 = fmtty_of_fmt(rest$5),
         prec_ty$1 = fmtty_of_precision_fmtty(prec$1, [4, ty_rest$1]);
        return fmtty_of_padding_fmtty(pad$3, prec_ty$1);
       case 7:
        var
         rest$6 = fmtty$0[4],
         prec$2 = fmtty$0[3],
         pad$4 = fmtty$0[2],
         ty_rest$2 = fmtty_of_fmt(rest$6),
         prec_ty$2 = fmtty_of_precision_fmtty(prec$2, [5, ty_rest$2]);
        return fmtty_of_padding_fmtty(pad$4, prec_ty$2);
       case 8:
        var
         rest$7 = fmtty$0[4],
         prec$3 = fmtty$0[3],
         pad$5 = fmtty$0[2],
         ty_rest$3 = fmtty_of_fmt(rest$7),
         prec_ty$3 = fmtty_of_precision_fmtty(prec$3, [6, ty_rest$3]);
        return fmtty_of_padding_fmtty(pad$5, prec_ty$3);
       case 9:
        var rest$8 = fmtty$0[2], pad$6 = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad$6, [7, fmtty_of_fmt(rest$8)]);
       case 10:
        var fmtty$1 = fmtty$0[1], fmtty$0 = fmtty$1; continue;
       case 11:
        var fmtty$2 = fmtty$0[2], fmtty$0 = fmtty$2; continue;
       case 12:
        var fmtty$3 = fmtty$0[2], fmtty$0 = fmtty$3; continue;
       case 13:
        var rest$9 = fmtty$0[3], ty = fmtty$0[2];
        return [8, ty, fmtty_of_fmt(rest$9)];
       case 14:
        var rest$10 = fmtty$0[3], ty$0 = fmtty$0[2];
        return [9, ty$0, ty$0, fmtty_of_fmt(rest$10)];
       case 15:
        var rest$11 = fmtty$0[1]; return [10, fmtty_of_fmt(rest$11)];
       case 16:
        var rest$12 = fmtty$0[1]; return [11, fmtty_of_fmt(rest$12)];
       case 17:
        var fmtty$4 = fmtty$0[2], fmtty$0 = fmtty$4; continue;
       case 18:
        var
         rest$13 = fmtty$0[2],
         formatting_gen = fmtty$0[1],
         _db_ = fmtty_of_fmt(rest$13);
        if(0 === formatting_gen[0])
         var fmt = formatting_gen[1][1], _dc_ = fmtty_of_fmt(fmt);
        else
         var fmt$0 = formatting_gen[1][1], _dc_ = fmtty_of_fmt(fmt$0);
        return caml_call2(CamlinternalFormatBasics[1], _dc_, _db_);
       case 19:
        var rest$14 = fmtty$0[1]; return [13, fmtty_of_fmt(rest$14)];
       case 20:
        var rest$15 = fmtty$0[3]; return [1, fmtty_of_fmt(rest$15)];
       case 21:
        var rest$16 = fmtty$0[2]; return [2, fmtty_of_fmt(rest$16)];
       case 22:
        var rest$17 = fmtty$0[1]; return [0, fmtty_of_fmt(rest$17)];
       case 23:
        var fmtty$5 = fmtty$0[2], ign = fmtty$0[1];
        if(typeof ign === "number")
         switch(ign){
           case 0:
            var fmtty$0 = fmtty$5; continue;
           case 1:
            var fmtty$0 = fmtty$5; continue;
           case 2:
            return [14, fmtty_of_fmt(fmtty$5)];
           default: var fmtty$0 = fmtty$5; continue;
         }
        switch(ign[0]){
          case 0:
           var fmtty$0 = fmtty$5; continue;
          case 1:
           var fmtty$0 = fmtty$5; continue;
          case 2:
           var fmtty$0 = fmtty$5; continue;
          case 3:
           var fmtty$0 = fmtty$5; continue;
          case 4:
           var fmtty$0 = fmtty$5; continue;
          case 5:
           var fmtty$0 = fmtty$5; continue;
          case 6:
           var fmtty$0 = fmtty$5; continue;
          case 7:
           var fmtty$0 = fmtty$5; continue;
          case 8:
           var fmtty$0 = fmtty$5; continue;
          case 9:
           var fmtty$6 = ign[2], _dd_ = fmtty_of_fmt(fmtty$5);
           return caml_call2(CamlinternalFormatBasics[1], fmtty$6, _dd_);
          case 10:
           var fmtty$0 = fmtty$5; continue;
          default: var fmtty$0 = fmtty$5; continue;
        }
       default:
        var rest$18 = fmtty$0[3], arity = fmtty$0[1];
        return fmtty_of_custom(arity, fmtty_of_fmt(rest$18));
     }
    }
   }
   function fmtty_of_precision_fmtty(prec, fmtty){
    return typeof prec === "number" ? prec ? [2, fmtty] : fmtty : fmtty;
   }
   var
    Type_mismatch =
      [248, cst_CamlinternalFormat_Type_mi, runtime.caml_fresh_oo_id(0)];
   function type_padding(pad, fmtty){
    if(typeof pad === "number") return [0, 0, fmtty];
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     return [0, [0, padty, w], fmtty];
    }
    if(typeof fmtty !== "number" && 2 === fmtty[0]){
     var rest = fmtty[1], padty$0 = pad[1];
     return [0, [1, padty$0], rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_padprec(pad, prec, fmtty){
    var match = type_padding(pad, fmtty);
    if(typeof prec !== "number"){
     var rest$1 = match[2], pad$2 = match[1], p = prec[1];
     return [0, pad$2, [0, p], rest$1];
    }
    if(! prec){
     var rest$0 = match[2], pad$1 = match[1];
     return [0, pad$1, 0, rest$0];
    }
    var match$0 = match[2];
    if(typeof match$0 !== "number" && 2 === match$0[0]){
     var rest = match$0[1], pad$0 = match[1];
     return [0, pad$0, 1, rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_format(fmt, fmtty){
    var _da_ = type_format_gen(fmt, fmtty);
    if(typeof _da_[2] !== "number")
     throw caml_maybe_attach_backtrace(Type_mismatch, 1);
    var fmt$0 = _da_[1];
    return fmt$0;
   }
   function type_ignored_param_one(ign, fmt, fmtty){
    var
     match = type_format_gen(fmt, fmtty),
     fmtty$0 = match[2],
     fmt$0 = match[1];
    return [0, [23, ign, fmt$0], fmtty$0];
   }
   function type_format_gen(fmt, fmtty0){
    if(typeof fmt === "number") return [0, 0, fmtty0];
    switch(fmt[0]){
      case 0:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest = fmtty0[1],
         fmt_rest = fmt[1],
         match = type_format_gen(fmt_rest, fmtty_rest),
         fmtty = match[2],
         fmt$0 = match[1];
        return [0, [0, fmt$0], fmtty];
       }
       break;
      case 1:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest$0 = fmtty0[1],
         fmt_rest$0 = fmt[1],
         match$0 = type_format_gen(fmt_rest$0, fmtty_rest$0),
         fmtty$0 = match$0[2],
         fmt$1 = match$0[1];
        return [0, [1, fmt$1], fmtty$0];
       }
       break;
      case 2:
       var
        fmt_rest$1 = fmt[2],
        pad = fmt[1],
        match$1 = type_padding(pad, fmtty0),
        pad$0 = match$1[1],
        match$2 = match$1[2];
       if(typeof match$2 !== "number" && 1 === match$2[0]){
        var
         fmtty_rest$1 = match$2[1],
         match$3 = type_format_gen(fmt_rest$1, fmtty_rest$1),
         fmtty$1 = match$3[2],
         fmt$2 = match$3[1];
        return [0, [2, pad$0, fmt$2], fmtty$1];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 3:
       var
        fmt_rest$2 = fmt[2],
        pad$1 = fmt[1],
        match$4 = type_padding(pad$1, fmtty0),
        pad$2 = match$4[1],
        match$5 = match$4[2];
       if(typeof match$5 !== "number" && 1 === match$5[0]){
        var
         fmtty_rest$2 = match$5[1],
         match$6 = type_format_gen(fmt_rest$2, fmtty_rest$2),
         fmtty$2 = match$6[2],
         fmt$3 = match$6[1];
        return [0, [3, pad$2, fmt$3], fmtty$2];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 4:
       var
        fmt_rest$3 = fmt[4],
        prec = fmt[3],
        pad$3 = fmt[2],
        iconv = fmt[1],
        match$7 = type_padprec(pad$3, prec, fmtty0),
        pad$4 = match$7[1],
        match$8 = match$7[3];
       if(typeof match$8 !== "number" && 2 === match$8[0]){
        var
         fmtty_rest$3 = match$8[1],
         prec$0 = match$7[2],
         match$9 = type_format_gen(fmt_rest$3, fmtty_rest$3),
         fmtty$3 = match$9[2],
         fmt$4 = match$9[1];
        return [0, [4, iconv, pad$4, prec$0, fmt$4], fmtty$3];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 5:
       var
        fmt_rest$4 = fmt[4],
        prec$1 = fmt[3],
        pad$5 = fmt[2],
        iconv$0 = fmt[1],
        match$10 = type_padprec(pad$5, prec$1, fmtty0),
        pad$6 = match$10[1],
        match$11 = match$10[3];
       if(typeof match$11 !== "number" && 3 === match$11[0]){
        var
         fmtty_rest$4 = match$11[1],
         prec$2 = match$10[2],
         match$12 = type_format_gen(fmt_rest$4, fmtty_rest$4),
         fmtty$4 = match$12[2],
         fmt$5 = match$12[1];
        return [0, [5, iconv$0, pad$6, prec$2, fmt$5], fmtty$4];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 6:
       var
        fmt_rest$5 = fmt[4],
        prec$3 = fmt[3],
        pad$7 = fmt[2],
        iconv$1 = fmt[1],
        match$13 = type_padprec(pad$7, prec$3, fmtty0),
        pad$8 = match$13[1],
        match$14 = match$13[3];
       if(typeof match$14 !== "number" && 4 === match$14[0]){
        var
         fmtty_rest$5 = match$14[1],
         prec$4 = match$13[2],
         match$15 = type_format_gen(fmt_rest$5, fmtty_rest$5),
         fmtty$5 = match$15[2],
         fmt$6 = match$15[1];
        return [0, [6, iconv$1, pad$8, prec$4, fmt$6], fmtty$5];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 7:
       var
        fmt_rest$6 = fmt[4],
        prec$5 = fmt[3],
        pad$9 = fmt[2],
        iconv$2 = fmt[1],
        match$16 = type_padprec(pad$9, prec$5, fmtty0),
        pad$10 = match$16[1],
        match$17 = match$16[3];
       if(typeof match$17 !== "number" && 5 === match$17[0]){
        var
         fmtty_rest$6 = match$17[1],
         prec$6 = match$16[2],
         match$18 = type_format_gen(fmt_rest$6, fmtty_rest$6),
         fmtty$6 = match$18[2],
         fmt$7 = match$18[1];
        return [0, [7, iconv$2, pad$10, prec$6, fmt$7], fmtty$6];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 8:
       var
        fmt_rest$7 = fmt[4],
        prec$7 = fmt[3],
        pad$11 = fmt[2],
        fconv = fmt[1],
        match$19 = type_padprec(pad$11, prec$7, fmtty0),
        pad$12 = match$19[1],
        match$20 = match$19[3];
       if(typeof match$20 !== "number" && 6 === match$20[0]){
        var
         fmtty_rest$7 = match$20[1],
         prec$8 = match$19[2],
         match$21 = type_format_gen(fmt_rest$7, fmtty_rest$7),
         fmtty$7 = match$21[2],
         fmt$8 = match$21[1];
        return [0, [8, fconv, pad$12, prec$8, fmt$8], fmtty$7];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 9:
       var
        fmt_rest$8 = fmt[2],
        pad$13 = fmt[1],
        match$22 = type_padding(pad$13, fmtty0),
        pad$14 = match$22[1],
        match$23 = match$22[2];
       if(typeof match$23 !== "number" && 7 === match$23[0]){
        var
         fmtty_rest$8 = match$23[1],
         match$24 = type_format_gen(fmt_rest$8, fmtty_rest$8),
         fmtty$8 = match$24[2],
         fmt$9 = match$24[1];
        return [0, [9, pad$14, fmt$9], fmtty$8];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 10:
       var
        fmt_rest$9 = fmt[1],
        match$25 = type_format_gen(fmt_rest$9, fmtty0),
        fmtty$9 = match$25[2],
        fmt$10 = match$25[1];
       return [0, [10, fmt$10], fmtty$9];
      case 11:
       var
        fmt_rest$10 = fmt[2],
        str = fmt[1],
        match$26 = type_format_gen(fmt_rest$10, fmtty0),
        fmtty$10 = match$26[2],
        fmt$11 = match$26[1];
       return [0, [11, str, fmt$11], fmtty$10];
      case 12:
       var
        fmt_rest$11 = fmt[2],
        chr = fmt[1],
        match$27 = type_format_gen(fmt_rest$11, fmtty0),
        fmtty$11 = match$27[2],
        fmt$12 = match$27[1];
       return [0, [12, chr, fmt$12], fmtty$11];
      case 13:
       if(typeof fmtty0 !== "number" && 8 === fmtty0[0]){
        var
         fmtty_rest$9 = fmtty0[2],
         sub_fmtty = fmtty0[1],
         fmt_rest$12 = fmt[3],
         sub_fmtty$0 = fmt[2],
         pad_opt = fmt[1];
        if(caml_notequal([0, sub_fmtty$0], [0, sub_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$28 = type_format_gen(fmt_rest$12, fmtty_rest$9),
         fmtty$12 = match$28[2],
         fmt$13 = match$28[1];
        return [0, [13, pad_opt, sub_fmtty, fmt$13], fmtty$12];
       }
       break;
      case 14:
       if(typeof fmtty0 !== "number" && 9 === fmtty0[0]){
        var
         fmtty_rest$10 = fmtty0[3],
         sub_fmtty1 = fmtty0[1],
         fmt_rest$13 = fmt[3],
         sub_fmtty$1 = fmt[2],
         pad_opt$0 = fmt[1],
         _c__ = [0, caml_call1(CamlinternalFormatBasics[2], sub_fmtty1)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub_fmtty$1)], _c__))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$29 =
           type_format_gen
            (fmt_rest$13,
             caml_call1(CamlinternalFormatBasics[2], fmtty_rest$10)),
         fmtty$13 = match$29[2],
         fmt$14 = match$29[1];
        return [0, [14, pad_opt$0, sub_fmtty1, fmt$14], fmtty$13];
       }
       break;
      case 15:
       if(typeof fmtty0 !== "number" && 10 === fmtty0[0]){
        var
         fmtty_rest$11 = fmtty0[1],
         fmt_rest$14 = fmt[1],
         match$30 = type_format_gen(fmt_rest$14, fmtty_rest$11),
         fmtty$14 = match$30[2],
         fmt$15 = match$30[1];
        return [0, [15, fmt$15], fmtty$14];
       }
       break;
      case 16:
       if(typeof fmtty0 !== "number" && 11 === fmtty0[0]){
        var
         fmtty_rest$12 = fmtty0[1],
         fmt_rest$15 = fmt[1],
         match$31 = type_format_gen(fmt_rest$15, fmtty_rest$12),
         fmtty$15 = match$31[2],
         fmt$16 = match$31[1];
        return [0, [16, fmt$16], fmtty$15];
       }
       break;
      case 17:
       var
        fmt_rest$16 = fmt[2],
        formatting_lit = fmt[1],
        match$32 = type_format_gen(fmt_rest$16, fmtty0),
        fmtty$16 = match$32[2],
        fmt$17 = match$32[1];
       return [0, [17, formatting_lit, fmt$17], fmtty$16];
      case 18:
       var fmt_rest$17 = fmt[2], formatting_gen = fmt[1];
       if(0 === formatting_gen[0]){
        var
         match$36 = formatting_gen[1],
         str$0 = match$36[2],
         fmt1 = match$36[1],
         match$37 = type_format_gen(fmt1, fmtty0),
         fmtty2 = match$37[2],
         fmt2 = match$37[1],
         match$38 = type_format_gen(fmt_rest$17, fmtty2),
         fmtty3 = match$38[2],
         fmt3 = match$38[1];
        return [0, [18, [0, [0, fmt2, str$0]], fmt3], fmtty3];
       }
       var
        match$39 = formatting_gen[1],
        str$1 = match$39[2],
        fmt1$0 = match$39[1],
        match$40 = type_format_gen(fmt1$0, fmtty0),
        fmtty2$0 = match$40[2],
        fmt2$0 = match$40[1],
        match$41 = type_format_gen(fmt_rest$17, fmtty2$0),
        fmtty3$0 = match$41[2],
        fmt3$0 = match$41[1];
       return [0, [18, [1, [0, fmt2$0, str$1]], fmt3$0], fmtty3$0];
      case 19:
       if(typeof fmtty0 !== "number" && 13 === fmtty0[0]){
        var
         fmtty_rest$13 = fmtty0[1],
         fmt_rest$18 = fmt[1],
         match$33 = type_format_gen(fmt_rest$18, fmtty_rest$13),
         fmtty$17 = match$33[2],
         fmt$18 = match$33[1];
        return [0, [19, fmt$18], fmtty$17];
       }
       break;
      case 20:
       if(typeof fmtty0 !== "number" && 1 === fmtty0[0]){
        var
         fmtty_rest$14 = fmtty0[1],
         fmt_rest$19 = fmt[3],
         char_set = fmt[2],
         width_opt = fmt[1],
         match$34 = type_format_gen(fmt_rest$19, fmtty_rest$14),
         fmtty$18 = match$34[2],
         fmt$19 = match$34[1];
        return [0, [20, width_opt, char_set, fmt$19], fmtty$18];
       }
       break;
      case 21:
       if(typeof fmtty0 !== "number" && 2 === fmtty0[0]){
        var
         fmtty_rest$15 = fmtty0[1],
         fmt_rest$20 = fmt[2],
         counter = fmt[1],
         match$35 = type_format_gen(fmt_rest$20, fmtty_rest$15),
         fmtty$19 = match$35[2],
         fmt$20 = match$35[1];
        return [0, [21, counter, fmt$20], fmtty$19];
       }
       break;
      case 23:
       var rest = fmt[2], ign = fmt[1];
       if(typeof ign !== "number")
        switch(ign[0]){
          case 0:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 1:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 2:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 3:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 4:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 5:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 6:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 7:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 8:
           var sub_fmtty$2 = ign[2], pad_opt$1 = ign[1];
           return type_ignored_param_one
                   ([8, pad_opt$1, sub_fmtty$2], rest, fmtty0);
          case 9:
           var
            sub_fmtty$3 = ign[2],
            pad_opt$2 = ign[1],
            _c$_ = type_ignored_format_substituti(sub_fmtty$3, rest, fmtty0),
            match$43 = _c$_[2],
            fmtty$21 = match$43[2],
            fmt$22 = match$43[1],
            sub_fmtty$4 = _c$_[1];
           return [0, [23, [9, pad_opt$2, sub_fmtty$4], fmt$22], fmtty$21];
          case 10:
           return type_ignored_param_one(ign, rest, fmtty0);
          default: return type_ignored_param_one(ign, rest, fmtty0);
        }
       switch(ign){
         case 0:
          return type_ignored_param_one(ign, rest, fmtty0);
         case 1:
          return type_ignored_param_one(ign, rest, fmtty0);
         case 2:
          if(typeof fmtty0 !== "number" && 14 === fmtty0[0]){
           var
            fmtty_rest$16 = fmtty0[1],
            match$42 = type_format_gen(rest, fmtty_rest$16),
            fmtty$20 = match$42[2],
            fmt$21 = match$42[1];
           return [0, [23, 2, fmt$21], fmtty$20];
          }
          throw caml_maybe_attach_backtrace(Type_mismatch, 1);
         default: return type_ignored_param_one(ign, rest, fmtty0);
       }
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_ignored_format_substituti(sub_fmtty, fmt, fmtty){
    if(typeof sub_fmtty === "number")
     return [0, 0, type_format_gen(fmt, fmtty)];
    switch(sub_fmtty[0]){
      case 0:
       if(typeof fmtty !== "number" && 0 === fmtty[0]){
        var
         fmtty_rest = fmtty[1],
         sub_fmtty_rest = sub_fmtty[1],
         match =
           type_ignored_format_substituti(sub_fmtty_rest, fmt, fmtty_rest),
         fmt$0 = match[2],
         sub_fmtty_rest$0 = match[1];
        return [0, [0, sub_fmtty_rest$0], fmt$0];
       }
       break;
      case 1:
       if(typeof fmtty !== "number" && 1 === fmtty[0]){
        var
         fmtty_rest$0 = fmtty[1],
         sub_fmtty_rest$1 = sub_fmtty[1],
         match$0 =
           type_ignored_format_substituti(sub_fmtty_rest$1, fmt, fmtty_rest$0),
         fmt$1 = match$0[2],
         sub_fmtty_rest$2 = match$0[1];
        return [0, [1, sub_fmtty_rest$2], fmt$1];
       }
       break;
      case 2:
       if(typeof fmtty !== "number" && 2 === fmtty[0]){
        var
         fmtty_rest$1 = fmtty[1],
         sub_fmtty_rest$3 = sub_fmtty[1],
         match$1 =
           type_ignored_format_substituti(sub_fmtty_rest$3, fmt, fmtty_rest$1),
         fmt$2 = match$1[2],
         sub_fmtty_rest$4 = match$1[1];
        return [0, [2, sub_fmtty_rest$4], fmt$2];
       }
       break;
      case 3:
       if(typeof fmtty !== "number" && 3 === fmtty[0]){
        var
         fmtty_rest$2 = fmtty[1],
         sub_fmtty_rest$5 = sub_fmtty[1],
         match$2 =
           type_ignored_format_substituti(sub_fmtty_rest$5, fmt, fmtty_rest$2),
         fmt$3 = match$2[2],
         sub_fmtty_rest$6 = match$2[1];
        return [0, [3, sub_fmtty_rest$6], fmt$3];
       }
       break;
      case 4:
       if(typeof fmtty !== "number" && 4 === fmtty[0]){
        var
         fmtty_rest$3 = fmtty[1],
         sub_fmtty_rest$7 = sub_fmtty[1],
         match$3 =
           type_ignored_format_substituti(sub_fmtty_rest$7, fmt, fmtty_rest$3),
         fmt$4 = match$3[2],
         sub_fmtty_rest$8 = match$3[1];
        return [0, [4, sub_fmtty_rest$8], fmt$4];
       }
       break;
      case 5:
       if(typeof fmtty !== "number" && 5 === fmtty[0]){
        var
         fmtty_rest$4 = fmtty[1],
         sub_fmtty_rest$9 = sub_fmtty[1],
         match$4 =
           type_ignored_format_substituti(sub_fmtty_rest$9, fmt, fmtty_rest$4),
         fmt$5 = match$4[2],
         sub_fmtty_rest$10 = match$4[1];
        return [0, [5, sub_fmtty_rest$10], fmt$5];
       }
       break;
      case 6:
       if(typeof fmtty !== "number" && 6 === fmtty[0]){
        var
         fmtty_rest$5 = fmtty[1],
         sub_fmtty_rest$11 = sub_fmtty[1],
         match$5 =
           type_ignored_format_substituti
            (sub_fmtty_rest$11, fmt, fmtty_rest$5),
         fmt$6 = match$5[2],
         sub_fmtty_rest$12 = match$5[1];
        return [0, [6, sub_fmtty_rest$12], fmt$6];
       }
       break;
      case 7:
       if(typeof fmtty !== "number" && 7 === fmtty[0]){
        var
         fmtty_rest$6 = fmtty[1],
         sub_fmtty_rest$13 = sub_fmtty[1],
         match$6 =
           type_ignored_format_substituti
            (sub_fmtty_rest$13, fmt, fmtty_rest$6),
         fmt$7 = match$6[2],
         sub_fmtty_rest$14 = match$6[1];
        return [0, [7, sub_fmtty_rest$14], fmt$7];
       }
       break;
      case 8:
       if(typeof fmtty !== "number" && 8 === fmtty[0]){
        var
         fmtty_rest$7 = fmtty[2],
         sub2_fmtty = fmtty[1],
         sub_fmtty_rest$15 = sub_fmtty[2],
         sub2_fmtty$0 = sub_fmtty[1];
        if(caml_notequal([0, sub2_fmtty$0], [0, sub2_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$7 =
           type_ignored_format_substituti
            (sub_fmtty_rest$15, fmt, fmtty_rest$7),
         fmt$8 = match$7[2],
         sub_fmtty_rest$16 = match$7[1];
        return [0, [8, sub2_fmtty, sub_fmtty_rest$16], fmt$8];
       }
       break;
      case 9:
       if(typeof fmtty !== "number" && 9 === fmtty[0]){
        var
         fmtty_rest$8 = fmtty[3],
         sub2_fmtty$1 = fmtty[2],
         sub1_fmtty = fmtty[1],
         sub_fmtty_rest$17 = sub_fmtty[3],
         sub2_fmtty$2 = sub_fmtty[2],
         sub1_fmtty$0 = sub_fmtty[1],
         _c8_ = [0, caml_call1(CamlinternalFormatBasics[2], sub1_fmtty)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub1_fmtty$0)], _c8_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var _c9_ = [0, caml_call1(CamlinternalFormatBasics[2], sub2_fmtty$1)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub2_fmtty$2)], _c9_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         sub_fmtty$0 = trans(symm(sub1_fmtty), sub2_fmtty$1),
         match$8 = fmtty_rel_det(sub_fmtty$0),
         f4 = match$8[4],
         f2 = match$8[2];
        f2(0);
        f4(0);
        var
         match$9 =
           type_ignored_format_substituti
            (caml_call1(CamlinternalFormatBasics[2], sub_fmtty_rest$17),
             fmt,
             fmtty_rest$8),
         fmt$9 = match$9[2],
         sub_fmtty_rest$18 = match$9[1];
        return [0,
                [9, sub1_fmtty, sub2_fmtty$1, symm(sub_fmtty_rest$18)],
                fmt$9];
       }
       break;
      case 10:
       if(typeof fmtty !== "number" && 10 === fmtty[0]){
        var
         fmtty_rest$9 = fmtty[1],
         sub_fmtty_rest$19 = sub_fmtty[1],
         match$10 =
           type_ignored_format_substituti
            (sub_fmtty_rest$19, fmt, fmtty_rest$9),
         fmt$10 = match$10[2],
         sub_fmtty_rest$20 = match$10[1];
        return [0, [10, sub_fmtty_rest$20], fmt$10];
       }
       break;
      case 11:
       if(typeof fmtty !== "number" && 11 === fmtty[0]){
        var
         fmtty_rest$10 = fmtty[1],
         sub_fmtty_rest$21 = sub_fmtty[1],
         match$11 =
           type_ignored_format_substituti
            (sub_fmtty_rest$21, fmt, fmtty_rest$10),
         fmt$11 = match$11[2],
         sub_fmtty_rest$22 = match$11[1];
        return [0, [11, sub_fmtty_rest$22], fmt$11];
       }
       break;
      case 13:
       if(typeof fmtty !== "number" && 13 === fmtty[0]){
        var
         fmtty_rest$11 = fmtty[1],
         sub_fmtty_rest$23 = sub_fmtty[1],
         match$12 =
           type_ignored_format_substituti
            (sub_fmtty_rest$23, fmt, fmtty_rest$11),
         fmt$12 = match$12[2],
         sub_fmtty_rest$24 = match$12[1];
        return [0, [13, sub_fmtty_rest$24], fmt$12];
       }
       break;
      case 14:
       if(typeof fmtty !== "number" && 14 === fmtty[0]){
        var
         fmtty_rest$12 = fmtty[1],
         sub_fmtty_rest$25 = sub_fmtty[1],
         match$13 =
           type_ignored_format_substituti
            (sub_fmtty_rest$25, fmt, fmtty_rest$12),
         fmt$13 = match$13[2],
         sub_fmtty_rest$26 = match$13[1];
        return [0, [14, sub_fmtty_rest$26], fmt$13];
       }
       break;
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function recast(fmt, fmtty){
    var _c7_ = symm(fmtty);
    return type_format(fmt, caml_call1(CamlinternalFormatBasics[2], _c7_));
   }
   function fix_padding(padty, width, str){
    var
     len = caml_ml_string_length(str),
     padty$0 = 0 <= width ? padty : 0,
     width$0 = caml_call1(Stdlib[18], width);
    if(width$0 <= len) return str;
    var
     _c6_ = 2 === padty$0 ? 48 : 32,
     res = caml_call2(Stdlib_Bytes[1], width$0, _c6_);
    switch(padty$0){
      case 0:
       caml_call5(Stdlib_String[48], str, 0, res, 0, len); break;
      case 1:
       caml_call5(Stdlib_String[48], str, 0, res, width$0 - len | 0, len);
       break;
      default:
       var switch$0 = 0;
       if(0 < len){
        var switch$1 = 0;
        if
         (43 !== caml_string_get(str, 0)
          && 45 !== caml_string_get(str, 0) && 32 !== caml_string_get(str, 0)){switch$0 = 1; switch$1 = 1;}
        if(! switch$1){
         caml_bytes_set(res, 0, caml_string_get(str, 0));
         caml_call5
          (Stdlib_String[48],
           str,
           1,
           res,
           (width$0 - len | 0) + 1 | 0,
           len - 1 | 0);
        }
       }
       else
        switch$0 = 1;
       if(switch$0){
        var switch$2 = 0;
        if(1 < len && 48 === caml_string_get(str, 0)){
         var switch$3 = 0;
         if(120 === caml_string_get(str, 1) || 88 === caml_string_get(str, 1))
          switch$3 = 1;
         if(switch$3){
          caml_bytes_set(res, 1, caml_string_get(str, 1));
          caml_call5
           (Stdlib_String[48],
            str,
            2,
            res,
            (width$0 - len | 0) + 2 | 0,
            len - 2 | 0);
          switch$2 = 1;
         }
        }
        if(! switch$2)
         caml_call5(Stdlib_String[48], str, 0, res, width$0 - len | 0, len);
       }
    }
    return caml_call1(Stdlib_Bytes[44], res);
   }
   function fix_int_precision(prec, str){
    var
     prec$0 = caml_call1(Stdlib[18], prec),
     len = caml_ml_string_length(str),
     c = caml_string_get(str, 0),
     switch$0 = 0;
    if(58 <= c){
     if(71 <= c){
      if(5 >= c - 97 >>> 0) switch$0 = 1;
     }
     else if(65 <= c) switch$0 = 1;
    }
    else{
     var switch$1 = 0;
     if(32 === c)
      switch$1 = 1;
     else if(43 <= c)
      switch(c - 43 | 0){
        case 5:
         if(len < (prec$0 + 2 | 0) && 1 < len){
          var switch$2 = 0;
          if
           (120 !== caml_string_get(str, 1) && 88 !== caml_string_get(str, 1))
           switch$2 = 1;
          if(! switch$2){
           var res$1 = caml_call2(Stdlib_Bytes[1], prec$0 + 2 | 0, 48);
           caml_bytes_set(res$1, 1, caml_string_get(str, 1));
           caml_call5
            (Stdlib_String[48],
             str,
             2,
             res$1,
             (prec$0 - len | 0) + 4 | 0,
             len - 2 | 0);
           return caml_call1(Stdlib_Bytes[44], res$1);
          }
         }
         switch$0 = 1;
         break;
        case 0:
        case 2:
         switch$1 = 1; break;
        case 1:
        case 3:
        case 4: break;
        default: switch$0 = 1;
      }
     if(switch$1 && len < (prec$0 + 1 | 0)){
      var res$0 = caml_call2(Stdlib_Bytes[1], prec$0 + 1 | 0, 48);
      caml_bytes_set(res$0, 0, c);
      caml_call5
       (Stdlib_String[48],
        str,
        1,
        res$0,
        (prec$0 - len | 0) + 2 | 0,
        len - 1 | 0);
      return caml_call1(Stdlib_Bytes[44], res$0);
     }
    }
    if(switch$0 && len < prec$0){
     var res = caml_call2(Stdlib_Bytes[1], prec$0, 48);
     caml_call5(Stdlib_String[48], str, 0, res, prec$0 - len | 0, len);
     return caml_call1(Stdlib_Bytes[44], res);
    }
    return str;
   }
   function string_to_caml_string(str){
    var
     str$0 = caml_call1(Stdlib_String[24], str),
     l = caml_ml_string_length(str$0),
     res = caml_call2(Stdlib_Bytes[1], l + 2 | 0, 34);
    caml_blit_string(str$0, 0, res, 1, l);
    return caml_call1(Stdlib_Bytes[44], res);
   }
   function format_of_fconv(fconv, prec){
    var
     prec$0 = caml_call1(Stdlib[18], prec),
     symb = char_of_fconv(_r_, fconv),
     buf = buffer_create(16);
    buffer_add_char(buf, 37);
    bprint_fconv_flag(buf, fconv);
    buffer_add_char(buf, 46);
    buffer_add_string(buf, caml_call1(Stdlib_Int[12], prec$0));
    buffer_add_char(buf, symb);
    return buffer_contents(buf);
   }
   function transform_int_alt(iconv, s){
    if(13 > iconv) return s;
    var n = [0, 0], _c1_ = caml_ml_string_length(s) - 1 | 0, _c0_ = 0;
    if(_c1_ >= 0){
     var i$0 = _c0_;
     for(;;){
      if(9 >= caml_string_unsafe_get(s, i$0) - 48 >>> 0) n[1]++;
      var _c5_ = i$0 + 1 | 0;
      if(_c1_ !== i$0){var i$0 = _c5_; continue;}
      break;
     }
    }
    var
     digits = n[1],
     buf =
       caml_create_bytes
        (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
     pos = [0, 0];
    function put(c){caml_bytes_set(buf, pos[1], c); pos[1]++; return 0;}
    var
     left = [0, ((digits - 1 | 0) % 3 | 0) + 1 | 0],
     _c3_ = caml_ml_string_length(s) - 1 | 0,
     _c2_ = 0;
    if(_c3_ >= 0){
     var i = _c2_;
     for(;;){
      var c = caml_string_unsafe_get(s, i);
      if(9 < c - 48 >>> 0)
       put(c);
      else{if(0 === left[1]){put(95); left[1] = 3;} left[1] += -1; put(c);}
      var _c4_ = i + 1 | 0;
      if(_c3_ !== i){var i = _c4_; continue;}
      break;
     }
    }
    return caml_call1(Stdlib_Bytes[44], buf);
   }
   function convert_int(iconv, n){
    switch(iconv){
      case 1:
       var _cZ_ = cst_d$0; break;
      case 2:
       var _cZ_ = cst_d$1; break;
      case 4:
       var _cZ_ = cst_i$1; break;
      case 5:
       var _cZ_ = cst_i$2; break;
      case 6:
       var _cZ_ = cst_x; break;
      case 7:
       var _cZ_ = cst_x$0; break;
      case 8:
       var _cZ_ = cst_X; break;
      case 9:
       var _cZ_ = cst_X$0; break;
      case 10:
       var _cZ_ = cst_o; break;
      case 11:
       var _cZ_ = cst_o$0; break;
      case 0:
      case 13:
       var _cZ_ = cst_d; break;
      case 3:
      case 14:
       var _cZ_ = cst_i$0; break;
      default: var _cZ_ = cst_u;
    }
    return transform_int_alt(iconv, caml_format_int(_cZ_, n));
   }
   function convert_int32(iconv, n){
    switch(iconv){
      case 1:
       var _cY_ = cst_ld$0; break;
      case 2:
       var _cY_ = cst_ld$1; break;
      case 4:
       var _cY_ = cst_li$1; break;
      case 5:
       var _cY_ = cst_li$2; break;
      case 6:
       var _cY_ = cst_lx; break;
      case 7:
       var _cY_ = cst_lx$0; break;
      case 8:
       var _cY_ = cst_lX; break;
      case 9:
       var _cY_ = cst_lX$0; break;
      case 10:
       var _cY_ = cst_lo; break;
      case 11:
       var _cY_ = cst_lo$0; break;
      case 0:
      case 13:
       var _cY_ = cst_ld; break;
      case 3:
      case 14:
       var _cY_ = cst_li$0; break;
      default: var _cY_ = cst_lu;
    }
    return transform_int_alt(iconv, caml_format_int(_cY_, n));
   }
   function convert_nativeint(iconv, n){
    switch(iconv){
      case 1:
       var _cX_ = cst_nd$0; break;
      case 2:
       var _cX_ = cst_nd$1; break;
      case 4:
       var _cX_ = cst_ni$1; break;
      case 5:
       var _cX_ = cst_ni$2; break;
      case 6:
       var _cX_ = cst_nx; break;
      case 7:
       var _cX_ = cst_nx$0; break;
      case 8:
       var _cX_ = cst_nX; break;
      case 9:
       var _cX_ = cst_nX$0; break;
      case 10:
       var _cX_ = cst_no; break;
      case 11:
       var _cX_ = cst_no$0; break;
      case 0:
      case 13:
       var _cX_ = cst_nd; break;
      case 3:
      case 14:
       var _cX_ = cst_ni$0; break;
      default: var _cX_ = cst_nu;
    }
    return transform_int_alt(iconv, caml_format_int(_cX_, n));
   }
   function convert_int64(iconv, n){
    switch(iconv){
      case 1:
       var _cW_ = cst_Ld$0; break;
      case 2:
       var _cW_ = cst_Ld$1; break;
      case 4:
       var _cW_ = cst_Li$1; break;
      case 5:
       var _cW_ = cst_Li$2; break;
      case 6:
       var _cW_ = cst_Lx; break;
      case 7:
       var _cW_ = cst_Lx$0; break;
      case 8:
       var _cW_ = cst_LX; break;
      case 9:
       var _cW_ = cst_LX$0; break;
      case 10:
       var _cW_ = cst_Lo; break;
      case 11:
       var _cW_ = cst_Lo$0; break;
      case 0:
      case 13:
       var _cW_ = cst_Ld; break;
      case 3:
      case 14:
       var _cW_ = cst_Li$0; break;
      default: var _cW_ = cst_Lu;
    }
    return transform_int_alt(iconv, runtime.caml_int64_format(_cW_, n));
   }
   function convert_float(fconv, prec, x){
    function hex(param){
     switch(fconv[1]){
       case 0:
        var sign = 45; break;
       case 1:
        var sign = 43; break;
       default: var sign = 32;
     }
     return runtime.caml_hexstring_of_float(x, prec, sign);
    }
    function caml_special_val(str){
     var match = runtime.caml_classify_float(x);
     return 3 === match
             ? x < 0. ? cst_neg_infinity : cst_infinity
             : 4 <= match ? cst_nan : str;
    }
    switch(fconv[2]){
      case 5:
       var
        str = caml_format_float(format_of_fconv(fconv, prec), x),
        len = caml_ml_string_length(str),
        i = 0;
       for(;;){
        if(i === len)
         var _cT_ = 0;
        else{
         var _cS_ = caml_string_get(str, i) - 46 | 0, switch$0 = 0;
         if(23 < _cS_ >>> 0){
          if(55 === _cS_) switch$0 = 1;
         }
         else if(21 < _cS_ - 1 >>> 0) switch$0 = 1;
         if(! switch$0){var i$0 = i + 1 | 0, i = i$0; continue;}
         var _cT_ = 1;
        }
        var _cU_ = _cT_ ? str : caml_call2(Stdlib[28], str, cst$17);
        return caml_special_val(_cU_);
       }
      case 6:
       return hex(0);
      case 7:
       var _cV_ = hex(0); return caml_call1(Stdlib_String[25], _cV_);
      case 8:
       return caml_special_val(hex(0));
      default: return caml_format_float(format_of_fconv(fconv, prec), x);
    }
   }
   function string_of_fmtty(fmtty){
    var buf = buffer_create(16);
    bprint_fmtty(buf, fmtty);
    return buffer_contents(buf);
   }
   function make_int_padding_precision(k, acc, fmt, pad, prec, trans, iconv){
    if(typeof pad === "number"){
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var str = fix_int_precision(p, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = caml_call2(trans, iconv, x);
                return make_printf(k, [4, acc, str], fmt);
               };
     var p = prec[1];
     return function(x){
      var str = fix_int_precision(p, caml_call2(trans, iconv, x));
      return make_printf(k, [4, acc, str], fmt);};
    }
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var
                 str =
                   fix_padding
                    (padty,
                     w,
                     fix_int_precision(p, caml_call2(trans, iconv, x)));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = fix_padding(padty, w, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               };
     var p$0 = prec[1];
     return function(x){
      var
       str =
         fix_padding
          (padty, w, fix_int_precision(p$0, caml_call2(trans, iconv, x)));
      return make_printf(k, [4, acc, str], fmt);};
    }
    var padty$0 = pad[1];
    if(typeof prec === "number")
     return prec
             ? function
              (w, p, x){
               var
                str =
                  fix_padding
                   (padty$0,
                    w,
                    fix_int_precision(p, caml_call2(trans, iconv, x)));
               return make_printf(k, [4, acc, str], fmt);
              }
             : function
              (w, x){
               var str = fix_padding(padty$0, w, caml_call2(trans, iconv, x));
               return make_printf(k, [4, acc, str], fmt);
              };
    var p$1 = prec[1];
    return function(w, x){
     var
      str =
        fix_padding
         (padty$0, w, fix_int_precision(p$1, caml_call2(trans, iconv, x)));
     return make_printf(k, [4, acc, str], fmt);};
   }
   function make_padding(k, acc, fmt, pad, trans){
    if(typeof pad === "number")
     return function(x){
      var new_acc = [4, acc, caml_call1(trans, x)];
      return make_printf(k, new_acc, fmt);};
    if(0 === pad[0]){
     var width = pad[2], padty = pad[1];
     return function(x){
      var new_acc = [4, acc, fix_padding(padty, width, caml_call1(trans, x))];
      return make_printf(k, new_acc, fmt);};
    }
    var padty$0 = pad[1];
    return function(w, x){
     var new_acc = [4, acc, fix_padding(padty$0, w, caml_call1(trans, x))];
     return make_printf(k, new_acc, fmt);};
   }
   function make_printf$0(counter, k, acc, fmt){
    var k$0 = k, acc$0 = acc, fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return caml_call1(k$0, acc$0);
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1];
        return function(c){
         var new_acc = [5, acc$0, c];
         return make_printf(k$0, new_acc, rest);};
       case 1:
        var rest$0 = fmt$0[1];
        return function(c){
         var
          str = caml_call1(Stdlib_Char[2], c),
          l = caml_ml_string_length(str),
          res = caml_call2(Stdlib_Bytes[1], l + 2 | 0, 39);
         caml_blit_string(str, 0, res, 1, l);
         var new_acc = [4, acc$0, caml_call1(Stdlib_Bytes[44], res)];
         return make_printf(k$0, new_acc, rest$0);};
       case 2:
        var rest$1 = fmt$0[2], pad = fmt$0[1];
        return make_padding
                (k$0, acc$0, rest$1, pad, function(str){return str;});
       case 3:
        var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
        return make_padding(k$0, acc$0, rest$2, pad$0, string_to_caml_string);
       case 4:
        var
         rest$3 = fmt$0[4],
         prec = fmt$0[3],
         pad$1 = fmt$0[2],
         iconv = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$3, pad$1, prec, convert_int, iconv);
       case 5:
        var
         rest$4 = fmt$0[4],
         prec$0 = fmt$0[3],
         pad$2 = fmt$0[2],
         iconv$0 = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$4, pad$2, prec$0, convert_int32, iconv$0);
       case 6:
        var
         rest$5 = fmt$0[4],
         prec$1 = fmt$0[3],
         pad$3 = fmt$0[2],
         iconv$1 = fmt$0[1];
        return make_int_padding_precision
                (k$0,
                 acc$0,
                 rest$5,
                 pad$3,
                 prec$1,
                 convert_nativeint,
                 iconv$1);
       case 7:
        var
         rest$6 = fmt$0[4],
         prec$2 = fmt$0[3],
         pad$4 = fmt$0[2],
         iconv$2 = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$6, pad$4, prec$2, convert_int64, iconv$2);
       case 8:
        var
         rest$7 = fmt$0[4],
         prec$3 = fmt$0[3],
         pad$5 = fmt$0[2],
         fconv = fmt$0[1];
        if(typeof pad$5 === "number"){
         if(typeof prec$3 === "number")
          return prec$3
                  ? function
                   (p, x){
                    var str = convert_float(fconv, p, x);
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   }
                  : function
                   (x){
                    var
                     str =
                       convert_float(fconv, default_float_precision(fconv), x);
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   };
         var p = prec$3[1];
         return function(x){
          var str = convert_float(fconv, p, x);
          return make_printf(k$0, [4, acc$0, str], rest$7);};
        }
        if(0 === pad$5[0]){
         var w = pad$5[2], padty = pad$5[1];
         if(typeof prec$3 === "number")
          return prec$3
                  ? function
                   (p, x){
                    var str = fix_padding(padty, w, convert_float(fconv, p, x));
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   }
                  : function
                   (x){
                    var
                     str =
                       convert_float(fconv, default_float_precision(fconv), x),
                     str$0 = fix_padding(padty, w, str);
                    return make_printf(k$0, [4, acc$0, str$0], rest$7);
                   };
         var p$0 = prec$3[1];
         return function(x){
          var str = fix_padding(padty, w, convert_float(fconv, p$0, x));
          return make_printf(k$0, [4, acc$0, str], rest$7);};
        }
        var padty$0 = pad$5[1];
        if(typeof prec$3 === "number")
         return prec$3
                 ? function
                  (w, p, x){
                   var
                    str = fix_padding(padty$0, w, convert_float(fconv, p, x));
                   return make_printf(k$0, [4, acc$0, str], rest$7);
                  }
                 : function
                  (w, x){
                   var
                    str =
                      convert_float(fconv, default_float_precision(fconv), x),
                    str$0 = fix_padding(padty$0, w, str);
                   return make_printf(k$0, [4, acc$0, str$0], rest$7);
                  };
        var p$1 = prec$3[1];
        return function(w, x){
         var str = fix_padding(padty$0, w, convert_float(fconv, p$1, x));
         return make_printf(k$0, [4, acc$0, str], rest$7);};
       case 9:
        var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
        return make_padding(k$0, acc$0, rest$8, pad$6, Stdlib[30]);
       case 10:
        var
         rest$9 = fmt$0[1],
         acc$1 = [7, acc$0],
         acc$0 = acc$1,
         fmt$0 = rest$9;
        continue;
       case 11:
        var
         rest$10 = fmt$0[2],
         str = fmt$0[1],
         acc$2 = [2, acc$0, str],
         acc$0 = acc$2,
         fmt$0 = rest$10;
        continue;
       case 12:
        var
         rest$11 = fmt$0[2],
         chr = fmt$0[1],
         acc$3 = [3, acc$0, chr],
         acc$0 = acc$3,
         fmt$0 = rest$11;
        continue;
       case 13:
        var
         rest$12 = fmt$0[3],
         sub_fmtty = fmt$0[2],
         ty = string_of_fmtty(sub_fmtty);
        return function(str){
         return make_printf(k$0, [4, acc$0, ty], rest$12);};
       case 14:
        var rest$13 = fmt$0[3], fmtty = fmt$0[2];
        return function(param){
         var fmt = param[1], _cR_ = recast(fmt, fmtty);
         return make_printf
                 (k$0,
                  acc$0,
                  caml_call2(CamlinternalFormatBasics[3], _cR_, rest$13));};
       case 15:
        var rest$14 = fmt$0[1];
        return function(f, x){
         return make_printf
                 (k$0,
                  [6, acc$0, function(o){return caml_call2(f, o, x);}],
                  rest$14);};
       case 16:
        var rest$15 = fmt$0[1];
        return function(f){return make_printf(k$0, [6, acc$0, f], rest$15);};
       case 17:
        var
         rest$16 = fmt$0[2],
         fmting_lit = fmt$0[1],
         acc$4 = [0, acc$0, fmting_lit],
         acc$0 = acc$4,
         fmt$0 = rest$16;
        continue;
       case 18:
        var _cP_ = fmt$0[1];
        if(0 === _cP_[0]){
         var
          rest$17 = fmt$0[2],
          fmt$1 = _cP_[1][1],
          k$3 =
            function(acc, k, rest){
             function k$0(kacc){
              return make_printf(k, [1, acc, [0, kacc]], rest);
             }
             return k$0;
            },
          k$1 = k$3(acc$0, k$0, rest$17),
          k$0 = k$1,
          acc$0 = 0,
          fmt$0 = fmt$1;
         continue;
        }
        var
         rest$18 = fmt$0[2],
         fmt$2 = _cP_[1][1],
         k$4 =
           function(acc, k, rest){
            function k$0(kacc){
             return make_printf(k, [1, acc, [1, kacc]], rest);
            }
            return k$0;
           },
         k$2 = k$4(acc$0, k$0, rest$18),
         k$0 = k$2,
         acc$0 = 0,
         fmt$0 = fmt$2;
        continue;
       case 19:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
       case 20:
        var
         rest$19 = fmt$0[3],
         new_acc = [8, acc$0, cst_Printf_bad_conversion];
        return function(param){return make_printf(k$0, new_acc, rest$19);};
       case 21:
        var rest$20 = fmt$0[2];
        return function(n){
         var new_acc = [4, acc$0, caml_format_int(cst_u$0, n)];
         return make_printf(k$0, new_acc, rest$20);};
       case 22:
        var rest$21 = fmt$0[1];
        return function(c){
         var new_acc = [5, acc$0, c];
         return make_printf(k$0, new_acc, rest$21);};
       case 23:
        var rest$22 = fmt$0[2], ign = fmt$0[1];
        if(counter >= 50)
         return caml_trampoline_return
                 (make_ignored_param$0, [0, k$0, acc$0, ign, rest$22]);
        var counter$1 = counter + 1 | 0;
        return make_ignored_param$0(counter$1, k$0, acc$0, ign, rest$22);
       default:
        var
         rest$23 = fmt$0[3],
         f = fmt$0[2],
         arity = fmt$0[1],
         _cQ_ = caml_call1(f, 0);
        if(counter >= 50)
         return caml_trampoline_return
                 (make_custom$0, [0, k$0, acc$0, rest$23, arity, _cQ_]);
        var counter$0 = counter + 1 | 0;
        return make_custom$0(counter$0, k$0, acc$0, rest$23, arity, _cQ_);
     }
    }
   }
   function make_ignored_param$0(counter, k, acc, ign, fmt){
    if(typeof ign === "number")
     switch(ign){
       case 0:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$0 = counter + 1 | 0;
        return make_invalid_arg(counter$0, k, acc, fmt);
       case 1:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$1 = counter + 1 | 0;
        return make_invalid_arg(counter$1, k, acc, fmt);
       case 2:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
       default:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$2 = counter + 1 | 0;
        return make_invalid_arg(counter$2, k, acc, fmt);
     }
    switch(ign[0]){
      case 0:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$3 = counter + 1 | 0;
       return make_invalid_arg(counter$3, k, acc, fmt);
      case 1:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$4 = counter + 1 | 0;
       return make_invalid_arg(counter$4, k, acc, fmt);
      case 2:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$5 = counter + 1 | 0;
       return make_invalid_arg(counter$5, k, acc, fmt);
      case 3:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$6 = counter + 1 | 0;
       return make_invalid_arg(counter$6, k, acc, fmt);
      case 4:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$7 = counter + 1 | 0;
       return make_invalid_arg(counter$7, k, acc, fmt);
      case 5:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$8 = counter + 1 | 0;
       return make_invalid_arg(counter$8, k, acc, fmt);
      case 6:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$9 = counter + 1 | 0;
       return make_invalid_arg(counter$9, k, acc, fmt);
      case 7:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$10 = counter + 1 | 0;
       return make_invalid_arg(counter$10, k, acc, fmt);
      case 8:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$11 = counter + 1 | 0;
       return make_invalid_arg(counter$11, k, acc, fmt);
      case 9:
       var fmtty = ign[2];
       if(counter >= 50)
        return caml_trampoline_return
                (make_from_fmtty$0, [0, k, acc, fmtty, fmt]);
       var counter$14 = counter + 1 | 0;
       return make_from_fmtty$0(counter$14, k, acc, fmtty, fmt);
      case 10:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$12 = counter + 1 | 0;
       return make_invalid_arg(counter$12, k, acc, fmt);
      default:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$13 = counter + 1 | 0;
       return make_invalid_arg(counter$13, k, acc, fmt);
    }
   }
   function make_from_fmtty$0(counter, k, acc, fmtty, fmt){
    if(typeof fmtty !== "number")
     switch(fmtty[0]){
       case 0:
        var rest = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest, fmt);};
       case 1:
        var rest$0 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$0, fmt);};
       case 2:
        var rest$1 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$1, fmt);};
       case 3:
        var rest$2 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$2, fmt);};
       case 4:
        var rest$3 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$3, fmt);};
       case 5:
        var rest$4 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$4, fmt);};
       case 6:
        var rest$5 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$5, fmt);};
       case 7:
        var rest$6 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$6, fmt);};
       case 8:
        var rest$7 = fmtty[2];
        return function(param){return make_from_fmtty(k, acc, rest$7, fmt);};
       case 9:
        var
         rest$8 = fmtty[3],
         ty2 = fmtty[2],
         ty1 = fmtty[1],
         ty = trans(symm(ty1), ty2);
        return function(param){
         return make_from_fmtty
                 (k,
                  acc,
                  caml_call2(CamlinternalFormatBasics[1], ty, rest$8),
                  fmt);};
       case 10:
        var rest$9 = fmtty[1];
        return function(param, _cO_){
         return make_from_fmtty(k, acc, rest$9, fmt);};
       case 11:
        var rest$10 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$10, fmt);};
       case 12:
        var rest$11 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$11, fmt);};
       case 13:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
     }
    if(counter >= 50)
     return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_invalid_arg(counter$0, k, acc, fmt);
   }
   function make_invalid_arg(counter, k, acc, fmt){
    var _cN_ = [8, acc, cst_Printf_bad_conversion$0];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, _cN_, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _cN_, fmt);
   }
   function make_custom$0(counter, k, acc, rest, arity, f){
    if(arity){
     var arity$0 = arity[1];
     return function(x){
      return make_custom(k, acc, rest, arity$0, caml_call1(f, x));};
    }
    var _cM_ = [4, acc, f];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, _cM_, rest]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _cM_, rest);
   }
   function make_printf(k, acc, fmt){
    return caml_trampoline(make_printf$0(0, k, acc, fmt));
   }
   function make_ignored_param(k, acc, ign, fmt){
    return caml_trampoline(make_ignored_param$0(0, k, acc, ign, fmt));
   }
   function make_from_fmtty(k, acc, fmtty, fmt){
    return caml_trampoline(make_from_fmtty$0(0, k, acc, fmtty, fmt));
   }
   function make_custom(k, acc, rest, arity, f){
    return caml_trampoline(make_custom$0(0, k, acc, rest, arity, f));
   }
   function fn_of_padding_precision(k, o, fmt, pad, prec){
    if(typeof pad === "number"){
     if(typeof prec !== "number"){
      var _cl_ = make_iprintf(k, o, fmt);
      return function(_cL_){return _cl_;};
     }
     if(prec){
      var _ci_ = make_iprintf(k, o, fmt), _cj_ = function(_cK_){return _ci_;};
      return function(_cJ_){return _cj_;};
     }
     var _ck_ = make_iprintf(k, o, fmt);
     return function(_cI_){return _ck_;};
    }
    if(0 === pad[0]){
     if(typeof prec !== "number"){
      var _cp_ = make_iprintf(k, o, fmt);
      return function(_cH_){return _cp_;};
     }
     if(prec){
      var _cm_ = make_iprintf(k, o, fmt), _cn_ = function(_cG_){return _cm_;};
      return function(_cF_){return _cn_;};
     }
     var _co_ = make_iprintf(k, o, fmt);
     return function(_cE_){return _co_;};
    }
    if(typeof prec !== "number"){
     var _cv_ = make_iprintf(k, o, fmt), _cw_ = function(_cD_){return _cv_;};
     return function(_cC_){return _cw_;};
    }
    if(prec){
     var
      _cq_ = make_iprintf(k, o, fmt),
      _cr_ = function(_cB_){return _cq_;},
      _cs_ = function(_cA_){return _cr_;};
     return function(_cz_){return _cs_;};
    }
    var _ct_ = make_iprintf(k, o, fmt);
    function _cu_(_cy_){return _ct_;}
    return function(_cx_){return _cu_;};
   }
   function make_iprintf$0(counter, k, o, fmt){
    var k$0 = k, fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return caml_call1(k$0, o);
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1], _by_ = make_iprintf(k$0, o, rest);
        return function(_ch_){return _by_;};
       case 1:
        var rest$0 = fmt$0[1], _bz_ = make_iprintf(k$0, o, rest$0);
        return function(_cg_){return _bz_;};
       case 2:
        var _bA_ = fmt$0[1];
        if(typeof _bA_ === "number"){
         var rest$1 = fmt$0[2], _bB_ = make_iprintf(k$0, o, rest$1);
         return function(_cf_){return _bB_;};
        }
        if(0 === _bA_[0]){
         var rest$2 = fmt$0[2], _bC_ = make_iprintf(k$0, o, rest$2);
         return function(_ce_){return _bC_;};
        }
        var
         rest$3 = fmt$0[2],
         _bD_ = make_iprintf(k$0, o, rest$3),
         _bE_ = function(_cd_){return _bD_;};
        return function(_cc_){return _bE_;};
       case 3:
        var _bF_ = fmt$0[1];
        if(typeof _bF_ === "number"){
         var rest$4 = fmt$0[2], _bG_ = make_iprintf(k$0, o, rest$4);
         return function(_cb_){return _bG_;};
        }
        if(0 === _bF_[0]){
         var rest$5 = fmt$0[2], _bH_ = make_iprintf(k$0, o, rest$5);
         return function(_ca_){return _bH_;};
        }
        var
         rest$6 = fmt$0[2],
         _bI_ = make_iprintf(k$0, o, rest$6),
         _bJ_ = function(_b$_){return _bI_;};
        return function(_b__){return _bJ_;};
       case 4:
        var rest$7 = fmt$0[4], prec = fmt$0[3], pad = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$7, pad, prec);
       case 5:
        var rest$8 = fmt$0[4], prec$0 = fmt$0[3], pad$0 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$8, pad$0, prec$0);
       case 6:
        var rest$9 = fmt$0[4], prec$1 = fmt$0[3], pad$1 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$9, pad$1, prec$1);
       case 7:
        var rest$10 = fmt$0[4], prec$2 = fmt$0[3], pad$2 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$10, pad$2, prec$2);
       case 8:
        var rest$11 = fmt$0[4], prec$3 = fmt$0[3], pad$3 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$11, pad$3, prec$3);
       case 9:
        var _bK_ = fmt$0[1];
        if(typeof _bK_ === "number"){
         var rest$12 = fmt$0[2], _bL_ = make_iprintf(k$0, o, rest$12);
         return function(_b9_){return _bL_;};
        }
        if(0 === _bK_[0]){
         var rest$13 = fmt$0[2], _bM_ = make_iprintf(k$0, o, rest$13);
         return function(_b8_){return _bM_;};
        }
        var
         rest$14 = fmt$0[2],
         _bN_ = make_iprintf(k$0, o, rest$14),
         _bO_ = function(_b7_){return _bN_;};
        return function(_b6_){return _bO_;};
       case 10:
        var rest$15 = fmt$0[1], fmt$0 = rest$15; continue;
       case 11:
        var rest$16 = fmt$0[2], fmt$0 = rest$16; continue;
       case 12:
        var rest$17 = fmt$0[2], fmt$0 = rest$17; continue;
       case 13:
        var rest$18 = fmt$0[3], _bP_ = make_iprintf(k$0, o, rest$18);
        return function(_b5_){return _bP_;};
       case 14:
        var rest$19 = fmt$0[3], fmtty = fmt$0[2];
        return function(param){
         var fmt = param[1], _b4_ = recast(fmt, fmtty);
         return make_iprintf
                 (k$0,
                  o,
                  caml_call2(CamlinternalFormatBasics[3], _b4_, rest$19));};
       case 15:
        var
         rest$20 = fmt$0[1],
         _bQ_ = make_iprintf(k$0, o, rest$20),
         _bR_ = function(_b3_){return _bQ_;};
        return function(_b2_){return _bR_;};
       case 16:
        var rest$21 = fmt$0[1], _bS_ = make_iprintf(k$0, o, rest$21);
        return function(_b1_){return _bS_;};
       case 17:
        var rest$22 = fmt$0[2], fmt$0 = rest$22; continue;
       case 18:
        var _bT_ = fmt$0[1];
        if(0 === _bT_[0]){
         var
          rest$23 = fmt$0[2],
          fmt$1 = _bT_[1][1],
          k$3 =
            function(k, rest){
             function k$0(koc){return make_iprintf(k, koc, rest);}
             return k$0;
            },
          k$1 = k$3(k$0, rest$23),
          k$0 = k$1,
          fmt$0 = fmt$1;
         continue;
        }
        var
         rest$24 = fmt$0[2],
         fmt$2 = _bT_[1][1],
         k$4 =
           function(k, rest){
            function k$0(koc){return make_iprintf(k, koc, rest);}
            return k$0;
           },
         k$2 = k$4(k$0, rest$24),
         k$0 = k$2,
         fmt$0 = fmt$2;
        continue;
       case 19:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
       case 20:
        var rest$25 = fmt$0[3], _bU_ = make_iprintf(k$0, o, rest$25);
        return function(_b0_){return _bU_;};
       case 21:
        var rest$26 = fmt$0[2], _bV_ = make_iprintf(k$0, o, rest$26);
        return function(_bZ_){return _bV_;};
       case 22:
        var rest$27 = fmt$0[1], _bW_ = make_iprintf(k$0, o, rest$27);
        return function(_bY_){return _bW_;};
       case 23:
        var rest$28 = fmt$0[2], ign = fmt$0[1], _bX_ = 0;
        return make_ignored_param
                (function(param){return caml_call1(k$0, o);},
                 _bX_,
                 ign,
                 rest$28);
       default:
        var rest$29 = fmt$0[3], arity = fmt$0[1];
        if(counter >= 50)
         return caml_trampoline_return
                 (fn_of_custom_arity$0, [0, k$0, o, rest$29, arity]);
        var counter$0 = counter + 1 | 0;
        return fn_of_custom_arity$0(counter$0, k$0, o, rest$29, arity);
     }
    }
   }
   function fn_of_custom_arity$0(counter, k, o, fmt, param){
    if(param){
     var arity = param[1], _bw_ = fn_of_custom_arity(k, o, fmt, arity);
     return function(_bx_){return _bw_;};
    }
    if(counter >= 50)
     return caml_trampoline_return(make_iprintf$0, [0, k, o, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_iprintf$0(counter$0, k, o, fmt);
   }
   function make_iprintf(k, o, fmt){
    return caml_trampoline(make_iprintf$0(0, k, o, fmt));
   }
   function fn_of_custom_arity(k, o, fmt, param){
    return caml_trampoline(fn_of_custom_arity$0(0, k, o, fmt, param));
   }
   function output_acc(o, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        output_acc(o, p);
        return caml_call2(Stdlib[66], o, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         output_acc(o, p$0);
         caml_call2(Stdlib[66], o, cst$18);
         var acc$0 = acc$1;
         continue;
        }
        var acc$2 = match[1];
        output_acc(o, p$0);
        caml_call2(Stdlib[66], o, cst$19);
        var acc$0 = acc$2;
        continue;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        output_acc(o, p$3);
        return caml_call1(f, o);
       case 7:
        var p$4 = acc$0[1];
        output_acc(o, p$4);
        return caml_call1(Stdlib[63], o);
       case 8:
        var msg = acc$0[2], p$5 = acc$0[1];
        output_acc(o, p$5);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        output_acc(o, p$1);
        return caml_call2(Stdlib[66], o, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        output_acc(o, p$2);
        return caml_call2(Stdlib[65], o, c);
     }
    }
   }
   function bufput_acc(b, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        bufput_acc(b, p);
        return caml_call2(Stdlib_Buffer[16], b, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         bufput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$20);
         var acc$0 = acc$1;
         continue;
        }
        var acc$2 = match[1];
        bufput_acc(b, p$0);
        caml_call2(Stdlib_Buffer[16], b, cst$21);
        var acc$0 = acc$2;
        continue;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        bufput_acc(b, p$3);
        return caml_call1(f, b);
       case 7:
        var acc$3 = acc$0[1], acc$0 = acc$3; continue;
       case 8:
        var msg = acc$0[2], p$4 = acc$0[1];
        bufput_acc(b, p$4);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        bufput_acc(b, p$1);
        return caml_call2(Stdlib_Buffer[16], b, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        bufput_acc(b, p$2);
        return caml_call2(Stdlib_Buffer[12], b, c);
     }
    }
   }
   function strput_acc(b, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        strput_acc(b, p);
        return caml_call2(Stdlib_Buffer[16], b, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         strput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$22);
         var acc$0 = acc$1;
         continue;
        }
        var acc$2 = match[1];
        strput_acc(b, p$0);
        caml_call2(Stdlib_Buffer[16], b, cst$23);
        var acc$0 = acc$2;
        continue;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        strput_acc(b, p$3);
        var _bv_ = caml_call1(f, 0);
        return caml_call2(Stdlib_Buffer[16], b, _bv_);
       case 7:
        var acc$3 = acc$0[1], acc$0 = acc$3; continue;
       case 8:
        var msg = acc$0[2], p$4 = acc$0[1];
        strput_acc(b, p$4);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        strput_acc(b, p$1);
        return caml_call2(Stdlib_Buffer[16], b, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        strput_acc(b, p$2);
        return caml_call2(Stdlib_Buffer[12], b, c);
     }
    }
   }
   function failwith_message(param){
    var fmt = param[1], buf = caml_call1(Stdlib_Buffer[1], 256);
    function k(acc){
     strput_acc(buf, acc);
     var _bu_ = caml_call1(Stdlib_Buffer[2], buf);
     return caml_call1(Stdlib[2], _bu_);
    }
    return make_printf(k, 0, fmt);
   }
   function open_box_of_string(str){
    if(runtime.caml_string_equal(str, cst$43)) return _x_;
    var len = caml_ml_string_length(str);
    function invalid_box(param){
     return caml_call1(failwith_message(_y_), str);
    }
    function parse_spaces(i){
     var i$0 = i;
     for(;;){
      if(i$0 === len) return i$0;
      var match = caml_string_get(str, i$0);
      if(9 !== match && 32 !== match) return i$0;
      var i$1 = i$0 + 1 | 0, i$0 = i$1;
     }
    }
    var wstart = parse_spaces(0), wend = wstart;
    for(;;){
     if(wend !== len && 25 >= caml_string_get(str, wend) - 97 >>> 0){var j = wend + 1 | 0, wend = j; continue;}
     var
      box_name = caml_call3(Stdlib_String[15], str, wstart, wend - wstart | 0),
      nstart = parse_spaces(wend),
      nend = nstart;
     for(;;){
      if(nend !== len){
       var match = caml_string_get(str, nend), switch$0 = 0;
       if(48 <= match){
        if(58 > match) switch$0 = 1;
       }
       else if(45 === match) switch$0 = 1;
       if(switch$0){var j$0 = nend + 1 | 0, nend = j$0; continue;}
      }
      if(nstart === nend)
       var indent = 0;
      else
       try{
        var
         _bs_ =
           runtime.caml_int_of_string
            (caml_call3(Stdlib_String[15], str, nstart, nend - nstart | 0)),
         indent = _bs_;
       }
       catch(_bt_){
        var _br_ = caml_wrap_exception(_bt_);
        if(_br_[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(_br_, 0);
        var indent = invalid_box(0);
       }
      var exp_end = parse_spaces(nend);
      if(exp_end !== len) invalid_box(0);
      var switch$1 = 0;
      if
       (caml_string_notequal(box_name, cst$43)
        && caml_string_notequal(box_name, "b"))
       var
        box_type =
          caml_string_notequal(box_name, "h")
           ? caml_string_notequal
              (box_name, "hov")
             ? caml_string_notequal
                (box_name, "hv")
               ? caml_string_notequal(box_name, "v") ? invalid_box(0) : 1
               : 2
             : 3
           : 0;
      else
       switch$1 = 1;
      if(switch$1) var box_type = 4;
      return [0, indent, box_type];
     }
    }
   }
   function make_padding_fmt_ebb(pad, fmt){
    if(typeof pad === "number") return [0, 0, fmt];
    if(0 === pad[0]){var w = pad[2], s = pad[1]; return [0, [0, s, w], fmt];}
    var s$0 = pad[1];
    return [0, [1, s$0], fmt];
   }
   function make_padprec_fmt_ebb(pad, prec, fmt){
    if(typeof prec === "number")
     var match = prec ? [0, 1, fmt] : [0, 0, fmt];
    else
     var p = prec[1], match = [0, [0, p], fmt];
    var prec$0 = match[1];
    if(typeof pad === "number") return [0, 0, prec$0, fmt];
    if(0 === pad[0]){
     var w = pad[2], s = pad[1];
     return [0, [0, s, w], prec$0, fmt];
    }
    var s$0 = pad[1];
    return [0, [1, s$0], prec$0, fmt];
   }
   function fmt_ebb_of_string(legacy_behavior, str){
    if(legacy_behavior)
     var flag = legacy_behavior[1], legacy_behavior$0 = flag;
    else
     var legacy_behavior$0 = 1;
    function invalid_format_message(str_ind, msg){
     return caml_call3(failwith_message(_z_), str, str_ind, msg);
    }
    function unexpected_end_of_format(end_ind){
     return invalid_format_message(end_ind, cst_unexpected_end_of_format);
    }
    function invalid_format_without(str_ind, c, s){
     return caml_call4(failwith_message(_A_), str, str_ind, c, s);
    }
    function expected_character(str_ind, expected, read){
     return caml_call4(failwith_message(_B_), str, str_ind, expected, read);
    }
    function add_literal(lit_start, str_ind, fmt){
     var size = str_ind - lit_start | 0;
     return 0 === size
             ? [0, fmt]
             : 1
               === size
               ? [0, [12, caml_string_get(str, lit_start), fmt]]
               : [0,
                 [11,
                  caml_call3(Stdlib_String[15], str, lit_start, size),
                  fmt]];
    }
    function parse(lit_start, end_ind){
     var str_ind = lit_start;
     for(;;){
      if(str_ind === end_ind) return add_literal(lit_start, str_ind, 0);
      var match = caml_string_get(str, str_ind);
      if(37 === match){
       var str_ind$2 = str_ind + 1 | 0;
       if(str_ind$2 === end_ind) unexpected_end_of_format(end_ind);
       var
        match$1 =
          95 === caml_string_get(str, str_ind$2)
           ? parse_flags(str_ind, str_ind$2 + 1 | 0, end_ind, 1)
           : parse_flags(str_ind, str_ind$2, end_ind, 0),
        fmt_rest = match$1[1];
       return add_literal(lit_start, str_ind, fmt_rest);
      }
      if(64 !== match){
       var str_ind$1 = str_ind + 1 | 0, str_ind = str_ind$1;
       continue;
      }
      var str_ind$0 = str_ind + 1 | 0;
      if(str_ind$0 === end_ind)
       var match$0 = _N_;
      else{
       var c = caml_string_get(str, str_ind$0), switch$0 = 0;
       if(65 <= c)
        if(94 <= c){
         var switcher = c - 123 | 0;
         if(2 < switcher >>> 0)
          switch$0 = 1;
         else
          switch(switcher){
            case 0:
             var match$0 = parse_tag(1, str_ind$0 + 1 | 0, end_ind); break;
            case 1:
             switch$0 = 1; break;
            default:
             var
              fmt_rest$2 = parse(str_ind$0 + 1 | 0, end_ind)[1],
              match$0 = [0, [17, 1, fmt_rest$2]];
          }
        }
        else if(91 <= c)
         switch(c - 91 | 0){
           case 0:
            var match$0 = parse_tag(0, str_ind$0 + 1 | 0, end_ind); break;
           case 1:
            switch$0 = 1; break;
           default:
            var
             fmt_rest$3 = parse(str_ind$0 + 1 | 0, end_ind)[1],
             match$0 = [0, [17, 0, fmt_rest$3]];
         }
        else
         switch$0 = 1;
       else if(10 === c)
        var
         fmt_rest$4 = parse(str_ind$0 + 1 | 0, end_ind)[1],
         match$0 = [0, [17, 3, fmt_rest$4]];
       else if(32 <= c)
        switch(c - 32 | 0){
          case 0:
           var
            fmt_rest$5 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, _O_, fmt_rest$5]];
           break;
          case 5:
           var switch$1 = 0;
           if
            ((str_ind$0 + 1 | 0) < end_ind
             && 37 === caml_string_get(str, str_ind$0 + 1 | 0))
            var
             fmt_rest$6 = parse(str_ind$0 + 2 | 0, end_ind)[1],
             match$0 = [0, [17, 6, fmt_rest$6]];
           else
            switch$1 = 1;
           if(switch$1)
            var
             fmt_rest$7 = parse(str_ind$0, end_ind)[1],
             match$0 = [0, [12, 64, fmt_rest$7]];
           break;
          case 12:
           var
            fmt_rest$8 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, _P_, fmt_rest$8]];
           break;
          case 14:
           var
            fmt_rest$9 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 4, fmt_rest$9]];
           break;
          case 27:
           var str_ind$3 = str_ind$0 + 1 | 0;
           try{
            var
             _bg_ = str_ind$3 === end_ind ? 1 : 0,
             _bh_ = _bg_ || (60 !== caml_string_get(str, str_ind$3) ? 1 : 0);
            if(_bh_) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
            var
             str_ind_1 = parse_spaces(str_ind$3 + 1 | 0, end_ind),
             match$2 = caml_string_get(str, str_ind_1),
             switch$2 = 0;
            if(48 <= match$2){
             if(58 > match$2) switch$2 = 1;
            }
            else if(45 === match$2) switch$2 = 1;
            if(! switch$2) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
            var
             match$3 = parse_integer(str_ind_1, end_ind),
             width = match$3[2],
             str_ind_2 = match$3[1],
             str_ind_3 = parse_spaces(str_ind_2, end_ind),
             switcher$0 = caml_string_get(str, str_ind_3) - 45 | 0,
             switch$3 = 0;
            if(12 < switcher$0 >>> 0)
             if(17 === switcher$0)
              var
               s =
                 caml_call3
                  (Stdlib_String[15],
                   str,
                   str_ind$3 - 2 | 0,
                   (str_ind_3 - str_ind$3 | 0) + 3 | 0),
               _bi_ = [0, s, width, 0],
               _bj_ = str_ind_3 + 1 | 0,
               formatting_lit$0 = _bi_,
               next_ind = _bj_;
             else
              switch$3 = 1;
            else if(1 < switcher$0 - 1 >>> 0){
             var
              match$4 = parse_integer(str_ind_3, end_ind),
              offset = match$4[2],
              str_ind_4 = match$4[1],
              str_ind_5 = parse_spaces(str_ind_4, end_ind);
             if(62 !== caml_string_get(str, str_ind_5))
              throw caml_maybe_attach_backtrace(Stdlib[8], 1);
             var
              s$0 =
                caml_call3
                 (Stdlib_String[15],
                  str,
                  str_ind$3 - 2 | 0,
                  (str_ind_5 - str_ind$3 | 0) + 3 | 0),
              _bk_ = [0, s$0, width, offset],
              _bl_ = str_ind_5 + 1 | 0,
              formatting_lit$0 = _bk_,
              next_ind = _bl_;
            }
            else
             switch$3 = 1;
            if(switch$3) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
           }
           catch(_bq_){
            var _bf_ = caml_wrap_exception(_bq_);
            if(_bf_ !== Stdlib[8] && _bf_[1] !== Stdlib[7])
             throw caml_maybe_attach_backtrace(_bf_, 0);
            var formatting_lit$0 = formatting_lit, next_ind = str_ind$3;
           }
           var
            fmt_rest$12 = parse(next_ind, end_ind)[1],
            match$0 = [0, [17, formatting_lit$0, fmt_rest$12]];
           break;
          case 28:
           var str_ind$4 = str_ind$0 + 1 | 0;
           try{
            var
             str_ind_1$0 = parse_spaces(str_ind$4, end_ind),
             match$6 = caml_string_get(str, str_ind_1$0),
             switch$4 = 0;
            if(48 <= match$6){
             if(58 > match$6) switch$4 = 1;
            }
            else if(45 === match$6) switch$4 = 1;
            if(switch$4){
             var
              match$7 = parse_integer(str_ind_1$0, end_ind),
              size = match$7[2],
              str_ind_2$0 = match$7[1],
              str_ind_3$0 = parse_spaces(str_ind_2$0, end_ind);
             if(62 !== caml_string_get(str, str_ind_3$0))
              throw caml_maybe_attach_backtrace(Stdlib[8], 1);
             var
              s$1 =
                caml_call3
                 (Stdlib_String[15],
                  str,
                  str_ind$4 - 2 | 0,
                  (str_ind_3$0 - str_ind$4 | 0) + 3 | 0),
              _bo_ = [0, [0, str_ind_3$0 + 1 | 0, [1, s$1, size]]];
            }
            else
             var _bo_ = 0;
            var _bn_ = _bo_;
           }
           catch(_bp_){
            var _bm_ = caml_wrap_exception(_bp_);
            if(_bm_ !== Stdlib[8] && _bm_[1] !== Stdlib[7])
             throw caml_maybe_attach_backtrace(_bm_, 0);
            var _bn_ = 0;
           }
           if(_bn_)
            var
             match$5 = _bn_[1],
             formatting_lit$1 = match$5[2],
             next_ind$0 = match$5[1],
             fmt_rest$13 = parse(next_ind$0, end_ind)[1],
             _be_ = [0, [17, formatting_lit$1, fmt_rest$13]];
           else
            var
             fmt_rest$14 = parse(str_ind$4, end_ind)[1],
             _be_ = [0, [17, _Q_, fmt_rest$14]];
           var match$0 = _be_;
           break;
          case 31:
           var
            fmt_rest$10 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 2, fmt_rest$10]];
           break;
          case 32:
           var
            fmt_rest$11 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 5, fmt_rest$11]];
           break;
          default: switch$0 = 1;
        }
       else
        switch$0 = 1;
       if(switch$0)
        var
         fmt_rest$1 = parse(str_ind$0 + 1 | 0, end_ind)[1],
         match$0 = [0, [17, [2, c], fmt_rest$1]];
      }
      var fmt_rest$0 = match$0[1];
      return add_literal(lit_start, str_ind, fmt_rest$0);
     }
    }
    function parse_conversion
    (pct_ind,
     str_ind,
     end_ind,
     plus,
     hash,
     space,
     ign,
     pad,
     prec,
     padprec,
     symb){
     var
      plus_used = [0, 0],
      hash_used = [0, 0],
      space_used = [0, 0],
      ign_used = [0, 0],
      pad_used = [0, 0],
      prec_used = [0, 0];
     function get_plus(param){plus_used[1] = 1; return plus;}
     function get_hash(param){hash_used[1] = 1; return hash;}
     function get_space(param){space_used[1] = 1; return space;}
     function get_ign(param){ign_used[1] = 1; return ign;}
     function get_pad(param){pad_used[1] = 1; return pad;}
     function get_prec(param){prec_used[1] = 1; return prec;}
     function get_padprec(param){pad_used[1] = 1; return padprec;}
     function get_int_pad(param){
      var pad = get_pad(0), match = get_prec(0);
      if(typeof match === "number" && ! match) return pad;
      if(typeof pad === "number") return 0;
      if(0 !== pad[0])
       return 2 <= pad[1]
               ? legacy_behavior$0
                 ? _H_
                 : incompatible_flag(pct_ind, str_ind, 48, cst_precision$1)
               : pad;
      if(2 > pad[1]) return pad;
      var n = pad[2];
      return legacy_behavior$0
              ? [0, 1, n]
              : incompatible_flag(pct_ind, str_ind, 48, cst_precision$0);
     }
     function check_no_0(symb, pad){
      if(typeof pad === "number") return pad;
      if(0 !== pad[0])
       return 2 <= pad[1]
               ? legacy_behavior$0
                 ? _I_
                 : incompatible_flag(pct_ind, str_ind, symb, cst_0$1)
               : pad;
      if(2 > pad[1]) return pad;
      var width = pad[2];
      return legacy_behavior$0
              ? [0, 1, width]
              : incompatible_flag(pct_ind, str_ind, symb, cst_0$0);
     }
     function opt_of_pad(c, pad){
      if(typeof pad === "number") return 0;
      if(0 === pad[0])
       switch(pad[1]){
         case 0:
          var width = pad[2];
          return legacy_behavior$0
                  ? [0, width]
                  : incompatible_flag(pct_ind, str_ind, c, cst$24);
         case 1:
          var width$0 = pad[2]; return [0, width$0];
         default:
          var width$1 = pad[2];
          return legacy_behavior$0
                  ? [0, width$1]
                  : incompatible_flag(pct_ind, str_ind, c, cst_0$2);
       }
      return incompatible_flag(pct_ind, str_ind, c, cst$25);
     }
     function get_pad_opt(c){return opt_of_pad(c, get_pad(0));}
     function get_padprec_opt(c){return opt_of_pad(c, get_padprec(0));}
     var switch$0 = 0;
     if(124 <= symb)
      switch$0 = 1;
     else
      switch(symb){
        case 33:
         var
          fmt_rest$5 = parse(str_ind, end_ind)[1],
          fmt_result = [0, [10, fmt_rest$5]];
         break;
        case 40:
         var
          sub_end = search_subformat_end(str_ind, end_ind, 41),
          fmt_rest$7 = parse(sub_end + 2 | 0, end_ind)[1],
          sub_fmt = parse(str_ind, sub_end)[1],
          sub_fmtty = fmtty_of_fmt(sub_fmt);
         if(get_ign(0))
          var
           ignored$2 = [9, get_pad_opt(95), sub_fmtty],
           _aN_ = [0, [23, ignored$2, fmt_rest$7]];
         else
          var _aN_ = [0, [14, get_pad_opt(40), sub_fmtty, fmt_rest$7]];
         var fmt_result = _aN_;
         break;
        case 44:
         var fmt_result = parse(str_ind, end_ind); break;
        case 67:
         var
          fmt_rest$10 = parse(str_ind, end_ind)[1],
          _aP_ =
            get_ign(0) ? [0, [23, 1, fmt_rest$10]] : [0, [1, fmt_rest$10]],
          fmt_result = _aP_;
         break;
        case 78:
         var fmt_rest$14 = parse(str_ind, end_ind)[1], counter$0 = 2;
         if(get_ign(0))
          var
           ignored$6 = [11, counter$0],
           _aV_ = [0, [23, ignored$6, fmt_rest$14]];
         else
          var _aV_ = [0, [21, counter$0, fmt_rest$14]];
         var fmt_result = _aV_;
         break;
        case 83:
         var
          pad$6 = check_no_0(symb, get_padprec(0)),
          fmt_rest$15 = parse(str_ind, end_ind)[1];
         if(get_ign(0))
          var
           ignored$7 = [1, get_padprec_opt(95)],
           _aW_ = [0, [23, ignored$7, fmt_rest$15]];
         else
          var
           match$5 = make_padding_fmt_ebb(pad$6, fmt_rest$15),
           fmt_rest$16 = match$5[2],
           pad$7 = match$5[1],
           _aW_ = [0, [3, pad$7, fmt_rest$16]];
         var fmt_result = _aW_;
         break;
        case 91:
         if(str_ind === end_ind) unexpected_end_of_format(end_ind);
         var
          char_set = create_char_set(0),
          add_char = function(c){return add_in_char_set(char_set, c);},
          add_range =
            function(c$0, c){
             if(c >= c$0){
              var i = c$0;
              for(;;){
               add_in_char_set(char_set, caml_call1(Stdlib[29], i));
               var _bd_ = i + 1 | 0;
               if(c !== i){var i = _bd_; continue;}
               break;
              }
             }
             return 0;
            },
          fail_single_percent =
            function(str_ind){
             return caml_call2(failwith_message(_R_), str, str_ind);
            },
          parse_char_set_content =
            function(counter, str_ind, end_ind){
             var str_ind$0 = str_ind;
             for(;;){
              if(str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
              var c = caml_string_get(str, str_ind$0);
              if(45 === c){
               add_char(45);
               var str_ind$1 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$1;
               continue;
              }
              if(93 === c) return str_ind$0 + 1 | 0;
              var _bc_ = str_ind$0 + 1 | 0;
              if(counter >= 50)
               return caml_trampoline_return
                       (parse_char_set_after_char$0, [0, _bc_, end_ind, c]);
              var counter$0 = counter + 1 | 0;
              return parse_char_set_after_char$0(counter$0, _bc_, end_ind, c);
             }
            },
          parse_char_set_after_char$0 =
            function(counter, str_ind, end_ind, c){
             var str_ind$0 = str_ind, c$0 = c;
             for(;;){
              if(str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
              var c$1 = caml_string_get(str, str_ind$0), switch$0 = 0;
              if(46 <= c$1){
               if(64 === c$1)
                switch$0 = 1;
               else if(93 === c$1){add_char(c$0); return str_ind$0 + 1 | 0;}
              }
              else if(37 === c$1)
               switch$0 = 1;
              else if(45 <= c$1){
               var str_ind$2 = str_ind$0 + 1 | 0;
               if(str_ind$2 === end_ind) unexpected_end_of_format(end_ind);
               var c$2 = caml_string_get(str, str_ind$2);
               if(37 === c$2){
                if((str_ind$2 + 1 | 0) === end_ind)
                 unexpected_end_of_format(end_ind);
                var c$3 = caml_string_get(str, str_ind$2 + 1 | 0);
                if(37 !== c$3 && 64 !== c$3)
                 return fail_single_percent(str_ind$2);
                add_range(c$0, c$3);
                var _ba_ = str_ind$2 + 2 | 0;
                if(counter >= 50)
                 return caml_trampoline_return
                         (parse_char_set_content, [0, _ba_, end_ind]);
                var counter$2 = counter + 1 | 0;
                return parse_char_set_content(counter$2, _ba_, end_ind);
               }
               if(93 === c$2){
                add_char(c$0);
                add_char(45);
                return str_ind$2 + 1 | 0;
               }
               add_range(c$0, c$2);
               var _bb_ = str_ind$2 + 1 | 0;
               if(counter >= 50)
                return caml_trampoline_return
                        (parse_char_set_content, [0, _bb_, end_ind]);
               var counter$1 = counter + 1 | 0;
               return parse_char_set_content(counter$1, _bb_, end_ind);
              }
              if(switch$0 && 37 === c$0){
               add_char(c$1);
               var _a$_ = str_ind$0 + 1 | 0;
               if(counter >= 50)
                return caml_trampoline_return
                        (parse_char_set_content, [0, _a$_, end_ind]);
               var counter$0 = counter + 1 | 0;
               return parse_char_set_content(counter$0, _a$_, end_ind);
              }
              if(37 === c$0) fail_single_percent(str_ind$0);
              add_char(c$0);
              var
               str_ind$1 = str_ind$0 + 1 | 0,
               str_ind$0 = str_ind$1,
               c$0 = c$1;
             }
            },
          parse_char_set_after_char =
            function(str_ind, end_ind, c){
             return caml_trampoline
                     (parse_char_set_after_char$0(0, str_ind, end_ind, c));
            };
         if(str_ind === end_ind) unexpected_end_of_format(end_ind);
         if(94 === caml_string_get(str, str_ind))
          var str_ind$0 = str_ind + 1 | 0, reverse = 1, str_ind$1 = str_ind$0;
         else
          var reverse = 0, str_ind$1 = str_ind;
         if(str_ind$1 === end_ind) unexpected_end_of_format(end_ind);
         var
          c = caml_string_get(str, str_ind$1),
          next_ind = parse_char_set_after_char(str_ind$1 + 1 | 0, end_ind, c),
          char_set$0 = freeze_char_set(char_set),
          char_set$1 = reverse ? rev_char_set(char_set$0) : char_set$0,
          fmt_rest$19 = parse(next_ind, end_ind)[1];
         if(get_ign(0))
          var
           ignored$9 = [10, get_pad_opt(95), char_set$1],
           _a1_ = [0, [23, ignored$9, fmt_rest$19]];
         else
          var _a1_ = [0, [20, get_pad_opt(91), char_set$1, fmt_rest$19]];
         var fmt_result = _a1_;
         break;
        case 97:
         var
          fmt_rest$20 = parse(str_ind, end_ind)[1],
          fmt_result = [0, [15, fmt_rest$20]];
         break;
        case 99:
         var
          char_format =
            function(fmt_rest){
             return get_ign(0) ? [0, [23, 0, fmt_rest]] : [0, [0, fmt_rest]];
            },
          fmt_rest$21 = parse(str_ind, end_ind)[1],
          match$7 = get_pad_opt(99);
         if(match$7){
          if(0 === match$7[1])
           var
            _a2_ =
              get_ign(0) ? [0, [23, 3, fmt_rest$21]] : [0, [22, fmt_rest$21]],
            _a3_ = _a2_;
          else
           var
            _a3_ =
              legacy_behavior$0
               ? char_format(fmt_rest$21)
               : invalid_format_message
                 (str_ind, cst_non_zero_widths_are_unsupp);
          var _a4_ = _a3_;
         }
         else
          var _a4_ = char_format(fmt_rest$21);
         var fmt_result = _a4_;
         break;
        case 114:
         var
          fmt_rest$22 = parse(str_ind, end_ind)[1],
          _a5_ =
            get_ign(0) ? [0, [23, 2, fmt_rest$22]] : [0, [19, fmt_rest$22]],
          fmt_result = _a5_;
         break;
        case 115:
         var
          pad$9 = check_no_0(symb, get_padprec(0)),
          fmt_rest$23 = parse(str_ind, end_ind)[1];
         if(get_ign(0))
          var
           ignored$10 = [0, get_padprec_opt(95)],
           _a6_ = [0, [23, ignored$10, fmt_rest$23]];
         else
          var
           match$8 = make_padding_fmt_ebb(pad$9, fmt_rest$23),
           fmt_rest$24 = match$8[2],
           pad$10 = match$8[1],
           _a6_ = [0, [2, pad$10, fmt_rest$24]];
         var fmt_result = _a6_;
         break;
        case 116:
         var
          fmt_rest$25 = parse(str_ind, end_ind)[1],
          fmt_result = [0, [16, fmt_rest$25]];
         break;
        case 123:
         var
          sub_end$0 = search_subformat_end(str_ind, end_ind, 125),
          sub_fmt$0 = parse(str_ind, sub_end$0)[1],
          fmt_rest$26 = parse(sub_end$0 + 2 | 0, end_ind)[1],
          sub_fmtty$0 = fmtty_of_fmt(sub_fmt$0);
         if(get_ign(0))
          var
           ignored$11 = [8, get_pad_opt(95), sub_fmtty$0],
           _a7_ = [0, [23, ignored$11, fmt_rest$26]];
         else
          var _a7_ = [0, [13, get_pad_opt(123), sub_fmtty$0, fmt_rest$26]];
         var fmt_result = _a7_;
         break;
        case 66:
        case 98:
         var
          pad$3 = check_no_0(symb, get_padprec(0)),
          fmt_rest$8 = parse(str_ind, end_ind)[1];
         if(get_ign(0))
          var
           ignored$3 = [7, get_padprec_opt(95)],
           _aO_ = [0, [23, ignored$3, fmt_rest$8]];
         else
          var
           match$3 = make_padding_fmt_ebb(pad$3, fmt_rest$8),
           fmt_rest$9 = match$3[2],
           pad$4 = match$3[1],
           _aO_ = [0, [9, pad$4, fmt_rest$9]];
         var fmt_result = _aO_;
         break;
        case 37:
        case 64:
         var
          fmt_rest$6 = parse(str_ind, end_ind)[1],
          fmt_result = [0, [12, symb, fmt_rest$6]];
         break;
        case 76:
        case 108:
        case 110:
         var switch$1 = 0;
         if(str_ind === end_ind)
          switch$1 = 1;
         else{
          var
           symb$0 = caml_string_get(str, str_ind),
           _a8_ = symb$0 - 88 | 0,
           switch$2 = 0;
          if(32 >= _a8_ >>> 0)
           switch(_a8_){
             case 0:
             case 12:
             case 17:
             case 23:
             case 29:
             case 32:
              var _aU_ = 1; switch$2 = 1; break;
           }
          if(! switch$2) var _aU_ = 0;
          if(_aU_) switch$0 = 1; else switch$1 = 1;
         }
         if(switch$1){
          var fmt_rest$13 = parse(str_ind, end_ind)[1], switch$3 = 0;
          if(108 <= symb){
           if(111 > symb)
            switch(symb - 108 | 0){
              case 0:
               var counter = 0; switch$3 = 1; break;
              case 1: break;
              default: var counter = 1; switch$3 = 1;
            }
          }
          else if(76 === symb){var counter = 2; switch$3 = 1;}
          if(! switch$3)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _V_], 1);
          if(get_ign(0))
           var
            ignored$5 = [11, counter],
            _aT_ = [0, [23, ignored$5, fmt_rest$13]];
          else
           var _aT_ = [0, [21, counter, fmt_rest$13]];
          var fmt_result = _aT_;
         }
         break;
        case 32:
        case 35:
        case 43:
        case 45:
        case 95:
         var
          fmt_result = caml_call3(failwith_message(_M_), str, pct_ind, symb);
         break;
        case 88:
        case 100:
        case 105:
        case 111:
        case 117:
        case 120:
         var
          _aX_ = get_space(0),
          _aY_ = get_hash(0),
          iconv$2 =
            compute_int_conv(pct_ind, str_ind, get_plus(0), _aY_, _aX_, symb),
          fmt_rest$17 = parse(str_ind, end_ind)[1];
         if(get_ign(0))
          var
           ignored$8 = [2, iconv$2, get_pad_opt(95)],
           _aZ_ = [0, [23, ignored$8, fmt_rest$17]];
         else
          var
           _a0_ = get_prec(0),
           match$6 = make_padprec_fmt_ebb(get_int_pad(0), _a0_, fmt_rest$17),
           fmt_rest$18 = match$6[3],
           prec$4 = match$6[2],
           pad$8 = match$6[1],
           _aZ_ = [0, [4, iconv$2, pad$8, prec$4, fmt_rest$18]];
         var fmt_result = _aZ_;
         break;
        case 69:
        case 70:
        case 71:
        case 72:
        case 101:
        case 102:
        case 103:
        case 104:
         var
          space$1 = get_space(0),
          hash$1 = get_hash(0),
          plus$2 = get_plus(0),
          flag =
            plus$2
             ? space$1
               ? legacy_behavior$0
                 ? 1
                 : incompatible_flag(pct_ind, str_ind, 32, cst$36)
               : 1
             : space$1 ? 2 : 0,
          switch$4 = 0;
         if(73 <= symb){
          var switcher = symb - 101 | 0;
          if(3 < switcher >>> 0)
           switch$4 = 1;
          else{
           switch(switcher){
             case 0:
              var _a9_ = 1; break;
             case 1:
              var _a9_ = 0; break;
             case 2:
              var _a9_ = 3; break;
             default: var _a9_ = 6;
           }
           var kind = _a9_;
          }
         }
         else if(69 <= symb){
          var switch$5 = 0;
          switch(symb - 69 | 0){
            case 0:
             var _a__ = 2; break;
            case 1:
             switch$4 = 1; switch$5 = 1; break;
            case 2:
             var _a__ = 4; break;
            default: var _a__ = 7;
          }
          if(! switch$5) var kind = _a__;
         }
         else
          switch$4 = 1;
         if(switch$4){
          var switch$6 = 0;
          if(hash$1){
           if(70 === symb){var kind = 8; switch$6 = 1;}
          }
          else if(70 === symb){var kind = 5; switch$6 = 1;}
          if(! switch$6)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
         }
         var
          fconv = [0, flag, kind],
          fmt_rest$11 = parse(str_ind, end_ind)[1];
         if(get_ign(0)){
          var match = get_prec(0);
          if(typeof match === "number")
           var
            _aQ_ = match ? incompatible_flag(pct_ind, str_ind, 95, cst$26) : 0;
          else
           var ndec = match[1], _aQ_ = [0, ndec];
          var
           ignored$4 = [6, get_pad_opt(95), _aQ_],
           _aR_ = [0, [23, ignored$4, fmt_rest$11]];
         }
         else
          var
           _aS_ = get_prec(0),
           match$4 = make_padprec_fmt_ebb(get_pad(0), _aS_, fmt_rest$11),
           fmt_rest$12 = match$4[3],
           prec$3 = match$4[2],
           pad$5 = match$4[1],
           _aR_ = [0, [8, fconv, pad$5, prec$3, fmt_rest$12]];
         var fmt_result = _aR_;
         break;
        default: switch$0 = 1;
      }
     if(switch$0){
      var switch$7 = 0;
      if(108 <= symb){
       if(111 > symb){
        var switch$8 = 0;
        switch(symb - 108 | 0){
          case 0:
           var
            _ax_ = caml_string_get(str, str_ind),
            _ay_ = get_space(0),
            _az_ = get_hash(0),
            iconv =
              compute_int_conv
               (pct_ind, str_ind + 1 | 0, get_plus(0), _az_, _ay_, _ax_),
            fmt_rest = parse(str_ind + 1 | 0, end_ind)[1];
           if(get_ign(0))
            var
             ignored = [3, iconv, get_pad_opt(95)],
             _aA_ = [0, [23, ignored, fmt_rest]];
           else
            var
             _aC_ = get_prec(0),
             match$0 = make_padprec_fmt_ebb(get_int_pad(0), _aC_, fmt_rest),
             fmt_rest$0 = match$0[3],
             prec$0 = match$0[2],
             pad$0 = match$0[1],
             _aA_ = [0, [5, iconv, pad$0, prec$0, fmt_rest$0]];
           var _aB_ = _aA_;
           switch$8 = 1;
           break;
          case 1: break;
          default:
           var
            _aD_ = caml_string_get(str, str_ind),
            _aE_ = get_space(0),
            _aF_ = get_hash(0),
            iconv$0 =
              compute_int_conv
               (pct_ind, str_ind + 1 | 0, get_plus(0), _aF_, _aE_, _aD_),
            fmt_rest$1 = parse(str_ind + 1 | 0, end_ind)[1];
           if(get_ign(0))
            var
             ignored$0 = [4, iconv$0, get_pad_opt(95)],
             _aG_ = [0, [23, ignored$0, fmt_rest$1]];
           else
            var
             _aH_ = get_prec(0),
             match$1 = make_padprec_fmt_ebb(get_int_pad(0), _aH_, fmt_rest$1),
             fmt_rest$2 = match$1[3],
             prec$1 = match$1[2],
             pad$1 = match$1[1],
             _aG_ = [0, [6, iconv$0, pad$1, prec$1, fmt_rest$2]];
           var _aB_ = _aG_;
           switch$8 = 1;
        }
        if(switch$8){var fmt_result = _aB_; switch$7 = 1;}
       }
      }
      else if(76 === symb){
       var
        _aI_ = caml_string_get(str, str_ind),
        _aJ_ = get_space(0),
        _aK_ = get_hash(0),
        iconv$1 =
          compute_int_conv
           (pct_ind, str_ind + 1 | 0, get_plus(0), _aK_, _aJ_, _aI_),
        fmt_rest$3 = parse(str_ind + 1 | 0, end_ind)[1];
       if(get_ign(0))
        var
         ignored$1 = [5, iconv$1, get_pad_opt(95)],
         _aL_ = [0, [23, ignored$1, fmt_rest$3]];
       else
        var
         _aM_ = get_prec(0),
         match$2 = make_padprec_fmt_ebb(get_int_pad(0), _aM_, fmt_rest$3),
         fmt_rest$4 = match$2[3],
         prec$2 = match$2[2],
         pad$2 = match$2[1],
         _aL_ = [0, [7, iconv$1, pad$2, prec$2, fmt_rest$4]];
       var fmt_result = _aL_;
       switch$7 = 1;
      }
      if(! switch$7)
       var
        fmt_result =
          caml_call3(failwith_message(_J_), str, str_ind - 1 | 0, symb);
     }
     if(1 - legacy_behavior$0){
      var _ao_ = 1 - plus_used[1], plus$0 = _ao_ ? plus : _ao_;
      if(plus$0) incompatible_flag(pct_ind, str_ind, symb, cst$27);
      var _ap_ = 1 - hash_used[1], hash$0 = _ap_ ? hash : _ap_;
      if(hash$0) incompatible_flag(pct_ind, str_ind, symb, cst$28);
      var _aq_ = 1 - space_used[1], space$0 = _aq_ ? space : _aq_;
      if(space$0) incompatible_flag(pct_ind, str_ind, symb, cst$29);
      var
       _ar_ = 1 - pad_used[1],
       _as_ = _ar_ ? caml_notequal([0, pad], _K_) : _ar_;
      if(_as_) incompatible_flag(pct_ind, str_ind, symb, cst_padding$0);
      var
       _at_ = 1 - prec_used[1],
       _au_ = _at_ ? caml_notequal([0, prec], _L_) : _at_;
      if(_au_){
       var _av_ = ign ? 95 : symb;
       incompatible_flag(pct_ind, str_ind, _av_, cst_precision$2);
      }
      var plus$1 = ign ? plus : ign;
      if(plus$1) incompatible_flag(pct_ind, str_ind, 95, cst$30);
     }
     var _aw_ = 1 - ign_used[1], ign$0 = _aw_ ? ign : _aw_;
     if(ign$0){
      var switch$9 = 0;
      if(38 <= symb){
       if(44 !== symb && 64 !== symb) switch$9 = 1;
      }
      else if(33 !== symb && 37 > symb) switch$9 = 1;
      var switch$10 = 0;
      if(switch$9 || ! legacy_behavior$0) switch$10 = 1;
      if(switch$10) incompatible_flag(pct_ind, str_ind, symb, cst$31);
     }
     return fmt_result;
    }
    function parse_after_precision
    (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad, prec){
     if(str_ind === end_ind) unexpected_end_of_format(end_ind);
     function parse_conv(padprec){
      return parse_conversion
              (pct_ind,
               str_ind + 1 | 0,
               end_ind,
               plus,
               hash,
               space,
               ign,
               pad,
               prec,
               padprec,
               caml_string_get(str, str_ind));
     }
     if(typeof pad !== "number") return parse_conv(pad);
     if(typeof prec === "number" && ! prec) return parse_conv(0);
     if(minus){
      if(typeof prec === "number") return parse_conv(_F_);
      var n = prec[1];
      return parse_conv([0, 0, n]);
     }
     if(typeof prec === "number") return parse_conv(_G_);
     var n$0 = prec[1];
     return parse_conv([0, 1, n$0]);
    }
    function parse_after_padding
    (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad){
     if(str_ind === end_ind) unexpected_end_of_format(end_ind);
     var symb = caml_string_get(str, str_ind);
     if(46 !== symb)
      return parse_conversion
              (pct_ind,
               str_ind + 1 | 0,
               end_ind,
               plus,
               hash,
               space,
               ign,
               pad,
               0,
               pad,
               symb);
     var str_ind$0 = str_ind + 1 | 0;
     if(str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
     function parse_literal(minus, str_ind){
      var
       match = parse_positive(str_ind, end_ind, 0),
       prec = match[2],
       new_ind = match[1];
      return parse_after_precision
              (pct_ind,
               new_ind,
               end_ind,
               minus,
               plus,
               hash,
               space,
               ign,
               pad,
               [0, prec]);
     }
     var symb$0 = caml_string_get(str, str_ind$0);
     if(48 <= symb$0){
      if(58 > symb$0) return parse_literal(minus, str_ind$0);
     }
     else if(42 <= symb$0)
      switch(symb$0 - 42 | 0){
        case 0:
         return parse_after_precision
                 (pct_ind,
                  str_ind$0 + 1 | 0,
                  end_ind,
                  minus,
                  plus,
                  hash,
                  space,
                  ign,
                  pad,
                  1);
        case 1:
        case 3:
         if(legacy_behavior$0){
          var
           _an_ = str_ind$0 + 1 | 0,
           minus$0 = minus || (45 === symb$0 ? 1 : 0);
          return parse_literal(minus$0, _an_);
         }
         break;
      }
     return legacy_behavior$0
             ? parse_after_precision
               (pct_ind,
                str_ind$0,
                end_ind,
                minus,
                plus,
                hash,
                space,
                ign,
                pad,
                _E_)
             : invalid_format_without(str_ind$0 - 1 | 0, 46, cst_precision);
    }
    function parse_flags(pct_ind, str_ind, end_ind, ign){
     var
      zero = [0, 0],
      minus = [0, 0],
      plus = [0, 0],
      space = [0, 0],
      hash = [0, 0];
     function set_flag(str_ind, flag){
      var _ak_ = flag[1], _al_ = _ak_ ? 1 - legacy_behavior$0 : _ak_;
      if(_al_){
       var _am_ = caml_string_get(str, str_ind);
       caml_call3(failwith_message(_C_), str, str_ind, _am_);
      }
      flag[1] = 1;
      return 0;
     }
     var str_ind$0 = str_ind;
     for(;;){
      if(str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
      var switcher = caml_string_get(str, str_ind$0) - 32 | 0;
      if(16 >= switcher >>> 0)
       switch(switcher){
         case 0:
          set_flag(str_ind$0, space);
          var str_ind$1 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$1;
          continue;
         case 3:
          set_flag(str_ind$0, hash);
          var str_ind$2 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$2;
          continue;
         case 11:
          set_flag(str_ind$0, plus);
          var str_ind$3 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$3;
          continue;
         case 13:
          set_flag(str_ind$0, minus);
          var str_ind$4 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$4;
          continue;
         case 16:
          set_flag(str_ind$0, zero);
          var str_ind$5 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$5;
          continue;
       }
      var
       space$0 = space[1],
       hash$0 = hash[1],
       plus$0 = plus[1],
       minus$0 = minus[1],
       zero$0 = zero[1];
      if(str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
      var
       padty =
         zero$0
          ? minus$0
            ? legacy_behavior$0
              ? 0
              : incompatible_flag(pct_ind, str_ind$0, 45, cst_0)
            : 2
          : minus$0 ? 0 : 1,
       match = caml_string_get(str, str_ind$0);
      if(48 <= match){
       if(58 > match){
        var
         match$0 = parse_positive(str_ind$0, end_ind, 0),
         width = match$0[2],
         new_ind = match$0[1];
        return parse_after_padding
                (pct_ind,
                 new_ind,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 [0, padty, width]);
       }
      }
      else if(42 === match)
       return parse_after_padding
               (pct_ind,
                str_ind$0 + 1 | 0,
                end_ind,
                minus$0,
                plus$0,
                hash$0,
                space$0,
                ign,
                [1, padty]);
      switch(padty){
        case 0:
         if(1 - legacy_behavior$0)
          invalid_format_without(str_ind$0 - 1 | 0, 45, cst_padding);
         return parse_after_padding
                 (pct_ind,
                  str_ind$0,
                  end_ind,
                  minus$0,
                  plus$0,
                  hash$0,
                  space$0,
                  ign,
                  0);
        case 1:
         return parse_after_padding
                 (pct_ind,
                  str_ind$0,
                  end_ind,
                  minus$0,
                  plus$0,
                  hash$0,
                  space$0,
                  ign,
                  0);
        default:
         return parse_after_padding
                 (pct_ind,
                  str_ind$0,
                  end_ind,
                  minus$0,
                  plus$0,
                  hash$0,
                  space$0,
                  ign,
                  _D_);
      }
     }
    }
    function parse_tag(is_open_tag, str_ind, end_ind){
     try{
      if(str_ind === end_ind) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      if(60 !== caml_string_get(str, str_ind))
       throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var ind = caml_call3(Stdlib_String[31], str, str_ind + 1 | 0, 62);
      if(end_ind <= ind) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var
       sub_str =
         caml_call3
          (Stdlib_String[15], str, str_ind, (ind - str_ind | 0) + 1 | 0),
       fmt_rest$0 = parse(ind + 1 | 0, end_ind)[1],
       sub_fmt = parse(str_ind, ind + 1 | 0)[1],
       sub_format$0 = [0, sub_fmt, sub_str],
       formatting$0 = is_open_tag ? [0, sub_format$0] : [1, sub_format$0],
       _ai_ = [0, [18, formatting$0, fmt_rest$0]];
      return _ai_;
     }
     catch(_aj_){
      var _ah_ = caml_wrap_exception(_aj_);
      if(_ah_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_ah_, 0);
      var
       fmt_rest = parse(str_ind, end_ind)[1],
       formatting = is_open_tag ? [0, sub_format] : [1, sub_format];
      return [0, [18, formatting, fmt_rest]];
     }
    }
    function parse_spaces(str_ind, end_ind){
     var str_ind$0 = str_ind;
     for(;;){
      if(str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
      if(32 !== caml_string_get(str, str_ind$0)) return str_ind$0;
      var str_ind$1 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$1;
     }
    }
    function parse_positive(str_ind, end_ind, acc){
     var str_ind$0 = str_ind, acc$0 = acc;
     for(;;){
      if(str_ind$0 === end_ind) unexpected_end_of_format(end_ind);
      var c = caml_string_get(str, str_ind$0);
      if(9 < c - 48 >>> 0) return [0, str_ind$0, acc$0];
      var new_acc = (acc$0 * 10 | 0) + (c - 48 | 0) | 0;
      if(Stdlib_Sys[12] < new_acc){
       var _ag_ = Stdlib_Sys[12];
       return caml_call3(failwith_message(_S_), str, new_acc, _ag_);
      }
      var
       str_ind$1 = str_ind$0 + 1 | 0,
       str_ind$0 = str_ind$1,
       acc$0 = new_acc;
     }
    }
    function parse_integer(str_ind, end_ind){
     if(str_ind === end_ind) unexpected_end_of_format(end_ind);
     var match = caml_string_get(str, str_ind);
     if(48 <= match){
      if(58 > match) return parse_positive(str_ind, end_ind, 0);
     }
     else if(45 === match){
      if((str_ind + 1 | 0) === end_ind) unexpected_end_of_format(end_ind);
      var c = caml_string_get(str, str_ind + 1 | 0);
      if(9 < c - 48 >>> 0)
       return expected_character(str_ind + 1 | 0, cst_digit, c);
      var
       match$0 = parse_positive(str_ind + 1 | 0, end_ind, 0),
       n = match$0[2],
       next_ind = match$0[1];
      return [0, next_ind, - n | 0];
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
    }
    function search_subformat_end(str_ind, end_ind, c){
     var str_ind$0 = str_ind;
     for(;;){
      if(str_ind$0 === end_ind)
       caml_call3(failwith_message(_U_), str, c, end_ind);
      if(37 !== caml_string_get(str, str_ind$0)){
       var str_ind$7 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$7;
       continue;
      }
      if((str_ind$0 + 1 | 0) === end_ind) unexpected_end_of_format(end_ind);
      if(caml_string_get(str, str_ind$0 + 1 | 0) === c) return str_ind$0;
      var match = caml_string_get(str, str_ind$0 + 1 | 0);
      if(95 <= match){
       if(123 <= match){
        if(126 > match)
         switch(match - 123 | 0){
           case 0:
            var
             sub_end = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 125),
             str_ind$2 = sub_end + 2 | 0,
             str_ind$0 = str_ind$2;
            continue;
           case 1: break;
           default:
            return expected_character(str_ind$0 + 1 | 0, cst_character, 125);
         }
       }
       else if(96 > match){
        if((str_ind$0 + 2 | 0) === end_ind) unexpected_end_of_format(end_ind);
        var match$0 = caml_string_get(str, str_ind$0 + 2 | 0);
        if(40 === match$0){
         var
          sub_end$0 = search_subformat_end(str_ind$0 + 3 | 0, end_ind, 41),
          str_ind$3 = sub_end$0 + 2 | 0,
          str_ind$0 = str_ind$3;
         continue;
        }
        if(123 === match$0){
         var
          sub_end$1 = search_subformat_end(str_ind$0 + 3 | 0, end_ind, 125),
          str_ind$4 = sub_end$1 + 2 | 0,
          str_ind$0 = str_ind$4;
         continue;
        }
        var str_ind$5 = str_ind$0 + 3 | 0, str_ind$0 = str_ind$5;
        continue;
       }
      }
      else{
       if(40 === match){
        var
         sub_end$2 = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 41),
         str_ind$6 = sub_end$2 + 2 | 0,
         str_ind$0 = str_ind$6;
        continue;
       }
       if(41 === match)
        return expected_character(str_ind$0 + 1 | 0, cst_character$0, 41);
      }
      var str_ind$1 = str_ind$0 + 2 | 0, str_ind$0 = str_ind$1;
     }
    }
    function incompatible_flag(pct_ind, str_ind, symb, option){
     var
      subfmt =
        caml_call3(Stdlib_String[15], str, pct_ind, str_ind - pct_ind | 0);
     return caml_call5
             (failwith_message(_Y_), str, pct_ind, option, symb, subfmt);
    }
    function compute_int_conv(pct_ind, str_ind, plus, hash, space, symb){
     var plus$0 = plus, hash$0 = hash, space$0 = space;
     for(;;){
      var switch$0 = 0;
      if(plus$0){
       if(hash$0)
        switch$0 = 1;
       else if(! space$0){
        if(100 === symb) return 1;
        if(105 === symb) return 4;
       }
      }
      else if(hash$0)
       if(space$0)
        switch$0 = 1;
       else{
        var switcher$0 = symb - 88 | 0;
        if(32 < switcher$0 >>> 0)
         switch$0 = 1;
        else
         switch(switcher$0){
           case 0:
            return 9;
           case 12:
            return 13;
           case 17:
            return 14;
           case 23:
            return 11;
           case 29:
            return 15;
           case 32:
            return 7;
           default: switch$0 = 1;
         }
       }
      else if(space$0){
       if(100 === symb) return 2;
       if(105 === symb) return 5;
      }
      else{
       var switcher$1 = symb - 88 | 0;
       if(32 >= switcher$1 >>> 0)
        switch(switcher$1){
          case 0:
           return 8;
          case 12:
           return 0;
          case 17:
           return 3;
          case 23:
           return 10;
          case 29:
           return 12;
          case 32:
           return 6;
        }
      }
      if(switch$0){
       var switcher = symb - 88 | 0;
       if(32 >= switcher >>> 0)
        switch(switcher){
          case 0:
           if(legacy_behavior$0) return 9; break;
          case 23:
           if(legacy_behavior$0) return 11; break;
          case 32:
           if(legacy_behavior$0) return 7; break;
          case 12:
          case 17:
          case 29:
           if(! legacy_behavior$0)
            return incompatible_flag(pct_ind, str_ind, symb, cst$35);
           var hash$0 = 0;
           continue;
        }
      }
      if(! plus$0){
       if(! space$0)
        throw caml_maybe_attach_backtrace([0, Assert_failure, _W_], 1);
       if(! legacy_behavior$0)
        return incompatible_flag(pct_ind, str_ind, symb, cst$34);
       var space$0 = 0;
       continue;
      }
      if(space$0){
       if(! legacy_behavior$0)
        return incompatible_flag(pct_ind, str_ind, 32, cst$32);
       var space$0 = 0;
       continue;
      }
      if(! legacy_behavior$0)
       return incompatible_flag(pct_ind, str_ind, symb, cst$33);
      var plus$0 = 0;
     }
    }
    return parse(0, caml_ml_string_length(str));
   }
   function format_of_string_fmtty(str, fmtty){
    var fmt = fmt_ebb_of_string(0, str)[1];
    try{var _ae_ = [0, type_format(fmt, fmtty), str]; return _ae_;}
    catch(_af_){
     var _ac_ = caml_wrap_exception(_af_);
     if(_ac_ !== Type_mismatch) throw caml_maybe_attach_backtrace(_ac_, 0);
     var _ad_ = string_of_fmtty(fmtty);
     return caml_call2(failwith_message(_Z_), str, _ad_);
    }
   }
   function format_of_string_format(str, param){
    var
     str$0 = param[2],
     fmt = param[1],
     fmt$0 = fmt_ebb_of_string(0, str)[1];
    try{
     var _aa_ = [0, type_format(fmt$0, fmtty_of_fmt(fmt)), str];
     return _aa_;
    }
    catch(_ab_){
     var _$_ = caml_wrap_exception(_ab_);
     if(_$_ === Type_mismatch)
      return caml_call2(failwith_message(___), str, str$0);
     throw caml_maybe_attach_backtrace(_$_, 0);
    }
   }
   var
    CamlinternalFormat =
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
   runtime.caml_register_global(197, CamlinternalFormat, "CamlinternalFormat");
   return;
  }
  (globalThis));

//# 15509 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    CamlinternalFormat = global_data.CamlinternalFormat,
    Stdlib = global_data.Stdlib;
   function kfprintf(k, o, param){
    var fmt = param[1], _g_ = 0;
    function _h_(acc){
     caml_call2(CamlinternalFormat[9], o, acc);
     return caml_call1(k, o);
    }
    return caml_call3(CamlinternalFormat[7], _h_, _g_, fmt);
   }
   function kbprintf(k, b, param){
    var fmt = param[1], _e_ = 0;
    function _f_(acc){
     caml_call2(CamlinternalFormat[10], b, acc);
     return caml_call1(k, b);
    }
    return caml_call3(CamlinternalFormat[7], _f_, _e_, fmt);
   }
   function ikfprintf(k, oc, param){
    var fmt = param[1];
    return caml_call3(CamlinternalFormat[8], k, oc, fmt);
   }
   function fprintf(oc, fmt){
    return kfprintf(function(_d_){return 0;}, oc, fmt);
   }
   function bprintf(b, fmt){
    return kbprintf(function(_c_){return 0;}, b, fmt);
   }
   function ifprintf(oc, fmt){
    return ikfprintf(function(_b_){return 0;}, oc, fmt);
   }
   function ibprintf(b, fmt){
    return ikfprintf(function(_a_){return 0;}, b, fmt);
   }
   function printf(fmt){return fprintf(Stdlib[39], fmt);}
   function eprintf(fmt){return fprintf(Stdlib[40], fmt);}
   function ksprintf(k, param){
    var fmt = param[1];
    function k$0(acc){
     var buf = caml_call1(Stdlib_Buffer[1], 64);
     caml_call2(CamlinternalFormat[11], buf, acc);
     return caml_call1(k, caml_call1(Stdlib_Buffer[2], buf));
    }
    return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
   }
   function sprintf(fmt){return ksprintf(function(s){return s;}, fmt);}
   var
    Stdlib_Printf =
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       ibprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ikfprintf,
       ksprintf];
   runtime.caml_register_global(3, Stdlib_Printf, "Stdlib__Printf");
   return;
  }
  (globalThis));

//# 16299 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_s = "%s\n",
    cst_Program_not_linked_with_g_$0 =
      "(Program not linked with -g, cannot print stack backtrace)\n",
    cst_characters = ", characters ",
    cst_Fatal_error_exception = "Fatal error: exception ",
    cst_Fatal_error_exception_s = "Fatal error: exception %s\n",
    cst_Uncaught_exception = "Uncaught exception: ",
    cst_Uncaught_exception_s = "Uncaught exception: %s\n",
    caml_check_bound = runtime.caml_check_bound,
    caml_get_exception_raw_backtra = runtime.caml_get_exception_raw_backtrace,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$4,
    cst$3 = cst$4,
    partial = [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]],
    cst$1 = cst$4,
    cst$2 = cst$4,
    cst = "_",
    locfmt =
      [0,
       [11,
        'File "',
        [2,
         0,
         [11,
          '", line ',
          [4,
           0,
           0,
           0,
           [11,
            cst_characters,
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [11, ": ", [2, 0, 0]]]]]]]]]],
       'File "%s", line %d, characters %d-%d: %s'],
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Obj = global_data.Stdlib__Obj,
    printers = caml_call1(Stdlib_Atomic[1], 0),
    _c_ = [0, [11, ", ", [2, 0, [2, 0, 0]]], ", %s%s"],
    _o_ =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s],
    _p_ =
      [0,
       [11,
        "Fatal error in uncaught exception handler: exception ",
        [2, 0, [12, 10, 0]]],
       "Fatal error in uncaught exception handler: exception %s\n"],
    cst_Fatal_error_out_of_memory_ =
      "Fatal error: out of memory in uncaught exception handler",
    _n_ =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s],
    _l_ = [0, [2, 0, [12, 10, 0]], cst_s],
    cst_Program_not_linked_with_g_ = cst_Program_not_linked_with_g_$0,
    _j_ = [0, [2, 0, [12, 10, 0]], cst_s],
    _k_ =
      [0,
       [11, cst_Program_not_linked_with_g_$0, 0],
       cst_Program_not_linked_with_g_$0],
    cst_Raised_at = "Raised at",
    cst_Re_raised_at = "Re-raised at",
    cst_Raised_by_primitive_operat = "Raised by primitive operation at",
    cst_Called_from = "Called from",
    cst_inlined = " (inlined)",
    _h_ =
      [0,
       [2,
        0,
        [12,
         32,
         [2,
          0,
          [11,
           ' in file "',
           [2,
            0,
            [12,
             34,
             [2,
              0,
              [11, ", line ", [4, 0, 0, 0, [11, cst_characters, partial]]]]]]]]]],
       '%s %s in file "%s"%s, line %d, characters %d-%d'],
    _i_ = [0, [2, 0, [11, " unknown location", 0]], "%s unknown location"],
    _g_ =
      [0,
       [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
       cst_Uncaught_exception_s],
    _f_ =
      [0,
       [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
       cst_Uncaught_exception_s],
    cst_Out_of_memory = "Out of memory",
    cst_Stack_overflow = "Stack overflow",
    cst_Pattern_matching_failed = "Pattern matching failed",
    cst_Assertion_failed = "Assertion failed",
    cst_Undefined_recursive_module = "Undefined recursive module",
    _d_ = [0, [12, 40, [2, 0, [2, 0, [12, 41, 0]]]], "(%s%s)"],
    _e_ = [0, [12, 40, [2, 0, [12, 41, 0]]], "(%s)"],
    _b_ = [0, [4, 0, 0, 0, 0], "%d"],
    _a_ = [0, [3, 0, 0], "%S"],
    _m_ =
      [0,
       cst$4,
       "(Cannot print locations:\n bytecode executable program file not found)",
       "(Cannot print locations:\n bytecode executable program file appears to be corrupt)",
       "(Cannot print locations:\n bytecode executable program file has wrong magic number)",
       "(Cannot print locations:\n bytecode executable program file cannot be opened;\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)"];
   function field(x, i){
    var f = x[1 + i];
    if(! caml_call1(Stdlib_Obj[1], f))
     return caml_call2(Stdlib_Printf[4], _b_, f);
    var _al_ = Stdlib_Obj[15];
    if(caml_obj_tag(f) === _al_) return caml_call2(Stdlib_Printf[4], _a_, f);
    var _am_ = Stdlib_Obj[16];
    return caml_obj_tag(f) === _am_ ? caml_call1(Stdlib[35], f) : cst;
   }
   function other_fields(x, i){
    if(x.length - 1 <= i) return cst$0;
    var _aj_ = other_fields(x, i + 1 | 0), _ak_ = field(x, i);
    return caml_call3(Stdlib_Printf[4], _c_, _ak_, _aj_);
   }
   function use_printers(x){
    var param = caml_call1(Stdlib_Atomic[2], printers);
    for(;;){
     if(! param) return 0;
     var tl = param[2], hd = param[1], switch$0 = 0;
     try{var val = caml_call1(hd, x);}catch(_ai_){switch$0 = 1;}
     if(! switch$0 && val){var s = val[1]; return [0, s];}
     var param = tl;
    }
   }
   function string_of_extension_constructo(t){
    if(0 === caml_obj_tag(t)){
     var constructor = t[1][1], match = t.length - 1;
     if(2 < match >>> 0)
      var
       _ae_ = other_fields(t, 2),
       _af_ = field(t, 1),
       _ah_ = caml_call3(Stdlib_Printf[4], _d_, _af_, _ae_);
     else
      switch(match){
        case 0:
         var _ah_ = cst$1; break;
        case 1:
         var _ah_ = cst$2; break;
        default:
         var
          _ag_ = field(t, 1),
          _ah_ = caml_call2(Stdlib_Printf[4], _e_, _ag_);
      }
     var match$0 = [0, constructor, [0, _ah_]];
    }
    else
     var match$0 = [0, t[1], 0];
    var fields_opt = match$0[2], constructor$0 = match$0[1];
    if(! fields_opt) return constructor$0;
    var f = fields_opt[1];
    return caml_call2(Stdlib[28], constructor$0, f);
   }
   function to_string_default(x){
    if(x === Stdlib[9]) return cst_Out_of_memory;
    if(x === Stdlib[10]) return cst_Stack_overflow;
    if(x[1] === Stdlib[4]){
     var match = x[2], char$0 = match[3], line = match[2], file = match[1];
     return caml_call6
             (Stdlib_Printf[4],
              locfmt,
              file,
              line,
              char$0,
              char$0 + 5 | 0,
              cst_Pattern_matching_failed);
    }
    if(x[1] === Stdlib[5]){
     var
      match$0 = x[2],
      char$1 = match$0[3],
      line$0 = match$0[2],
      file$0 = match$0[1];
     return caml_call6
             (Stdlib_Printf[4],
              locfmt,
              file$0,
              line$0,
              char$1,
              char$1 + 6 | 0,
              cst_Assertion_failed);
    }
    if(x[1] !== Stdlib[15]) return string_of_extension_constructo(x);
    var
     match$1 = x[2],
     char$2 = match$1[3],
     line$1 = match$1[2],
     file$1 = match$1[1];
    return caml_call6
            (Stdlib_Printf[4],
             locfmt,
             file$1,
             line$1,
             char$2,
             char$2 + 6 | 0,
             cst_Undefined_recursive_module);
   }
   function to_string(e){
    var match = use_printers(e);
    if(! match) return to_string_default(e);
    var s = match[1];
    return s;
   }
   function print(fct, arg){
    try{var _ad_ = caml_call1(fct, arg); return _ad_;}
    catch(x$0){
     var x = caml_wrap_exception(x$0), _ac_ = to_string(x);
     caml_call2(Stdlib_Printf[3], _f_, _ac_);
     caml_call1(Stdlib[63], Stdlib[40]);
     throw caml_maybe_attach_backtrace(x, 0);
    }
   }
   function catch$0(fct, arg){
    try{var _ab_ = caml_call1(fct, arg); return _ab_;}
    catch(x$0){
     var x = caml_wrap_exception(x$0);
     caml_call1(Stdlib[63], Stdlib[39]);
     var _aa_ = to_string(x);
     caml_call2(Stdlib_Printf[3], _g_, _aa_);
     return caml_call1(Stdlib[99], 2);
    }
   }
   function raw_backtrace_entries(bt){return bt;}
   function convert_raw_backtrace(bt){
    return [0, runtime.caml_convert_raw_backtrace(bt)];
   }
   function format_backtrace_slot(pos, slot){
    function info(is_raise){
     return is_raise
             ? 0 === pos ? cst_Raised_at : cst_Re_raised_at
             : 0 === pos ? cst_Raised_by_primitive_operat : cst_Called_from;
    }
    if(0 === slot[0]){
     var
      _U_ = slot[5],
      _V_ = slot[4],
      _W_ = slot[3],
      _X_ = slot[6] ? cst_inlined : cst$3,
      _Y_ = slot[2],
      _Z_ = slot[7],
      ___ = info(slot[1]);
     return [0,
             caml_call8
              (Stdlib_Printf[4], _h_, ___, _Z_, _Y_, _X_, _W_, _V_, _U_)];
    }
    if(slot[1]) return 0;
    var _$_ = info(0);
    return [0, caml_call2(Stdlib_Printf[4], _i_, _$_)];
   }
   function print_raw_backtrace(outchan, raw_backtrace){
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if(! backtrace) return caml_call2(Stdlib_Printf[1], outchan, _k_);
    var a = backtrace[1], _S_ = a.length - 1 - 1 | 0, _R_ = 0;
    if(_S_ >= 0){
     var i = _R_;
     for(;;){
      var match = format_backtrace_slot(i, caml_check_bound(a, i)[1 + i]);
      if(match){
       var str = match[1];
       caml_call3(Stdlib_Printf[1], outchan, _j_, str);
      }
      var _T_ = i + 1 | 0;
      if(_S_ !== i){var i = _T_; continue;}
      break;
     }
    }
    return 0;
   }
   function print_backtrace(outchan){
    return print_raw_backtrace(outchan, caml_get_exception_raw_backtra(0));
   }
   function raw_backtrace_to_string(raw_backtrace){
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if(! backtrace) return cst_Program_not_linked_with_g_;
    var
     a = backtrace[1],
     b = caml_call1(Stdlib_Buffer[1], 1024),
     _P_ = a.length - 1 - 1 | 0,
     _O_ = 0;
    if(_P_ >= 0){
     var i = _O_;
     for(;;){
      var match = format_backtrace_slot(i, caml_check_bound(a, i)[1 + i]);
      if(match){
       var str = match[1];
       caml_call3(Stdlib_Printf[5], b, _l_, str);
      }
      var _Q_ = i + 1 | 0;
      if(_P_ !== i){var i = _Q_; continue;}
      break;
     }
    }
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function backtrace_slot_is_raise(param){
    return 0 === param[0] ? param[1] : param[1];
   }
   function backtrace_slot_is_inline(param){return 0 === param[0] ? param[6] : 0;
   }
   function backtrace_slot_location(param){
    return 0 === param[0]
            ? [0, [0, param[2], param[3], param[4], param[5]]]
            : 0;
   }
   function backtrace_slot_defname(param){
    if(0 === param[0] && runtime.caml_string_notequal(param[7], cst$4))
     return [0, param[7]];
    return 0;
   }
   function backtrace_slots(raw_backtrace){
    var match = convert_raw_backtrace(raw_backtrace);
    if(! match) return 0;
    var backtrace = match[1], i$1 = backtrace.length - 1 - 1 | 0, i = i$1;
    for(;;){
     if(-1 === i)
      var _N_ = 0;
     else{
      var _M_ = 0 === caml_check_bound(backtrace, i)[1 + i][0] ? 1 : 0;
      if(! _M_){var i$0 = i - 1 | 0, i = i$0; continue;}
      var _N_ = _M_;
     }
     return _N_ ? [0, backtrace] : 0;
    }
   }
   function backtrace_slots_of_raw_entry(entry){return backtrace_slots([0, entry]);
   }
   function raw_backtrace_length(bt){return bt.length - 1;}
   function get_backtrace(param){
    return raw_backtrace_to_string(caml_get_exception_raw_backtra(0));
   }
   function register_printer(fn){
    for(;;){
     var
      old_printers = caml_call1(Stdlib_Atomic[2], printers),
      new_printers = [0, fn, old_printers],
      success =
        caml_call3(Stdlib_Atomic[5], printers, old_printers, new_printers),
      _L_ = 1 - success;
     if(_L_) continue;
     return _L_;
    }
   }
   function exn_slot(x){return 0 === caml_obj_tag(x) ? x[1] : x;}
   function exn_slot_id(x){var slot = exn_slot(x); return slot[2];}
   function exn_slot_name(x){var slot = exn_slot(x); return slot[1];}
   var errors = _m_.slice();
   function default_uncaught_exception_han(exn, raw_backtrace){
    var _I_ = to_string(exn);
    caml_call2(Stdlib_Printf[3], _n_, _I_);
    print_raw_backtrace(Stdlib[40], raw_backtrace);
    var status = runtime.caml_ml_debug_info_status(0);
    if(status < 0){
     var
      _J_ = caml_call1(Stdlib[18], status),
      _K_ = caml_check_bound(errors, _J_)[1 + _J_];
     caml_call1(Stdlib[53], _K_);
    }
    return caml_call1(Stdlib[63], Stdlib[40]);
   }
   var uncaught_exception_handler = [0, default_uncaught_exception_han];
   function set_uncaught_exception_handler(fn){
    uncaught_exception_handler[1] = fn;
    return 0;
   }
   var empty_backtrace = [0];
   function handle_uncaught_exception(exn$0, debugger_in_use){
    try{
     try{
      var
       raw_backtrace =
         debugger_in_use ? empty_backtrace : caml_get_exception_raw_backtra(0);
      try{caml_call1(Stdlib[103], 0);}catch(_H_){}
      try{
       var
        _D_ = caml_call2(uncaught_exception_handler[1], exn$0, raw_backtrace),
        _C_ = _D_;
      }
      catch(exn$1){
       var
        exn = caml_wrap_exception(exn$1),
        raw_backtrace$0 = caml_get_exception_raw_backtra(0),
        _A_ = to_string(exn$0);
       caml_call2(Stdlib_Printf[3], _o_, _A_);
       print_raw_backtrace(Stdlib[40], raw_backtrace);
       var _B_ = to_string(exn);
       caml_call2(Stdlib_Printf[3], _p_, _B_);
       print_raw_backtrace(Stdlib[40], raw_backtrace$0);
       var _C_ = caml_call1(Stdlib[63], Stdlib[40]);
      }
      var _E_ = _C_;
     }
     catch(_G_){
      var _z_ = caml_wrap_exception(_G_);
      if(_z_ !== Stdlib[9]) throw caml_maybe_attach_backtrace(_z_, 0);
      var _E_ = caml_call1(Stdlib[53], cst_Fatal_error_out_of_memory_);
     }
     return _E_;
    }
    catch(_F_){return 0;}
   }
   runtime.caml_register_named_value
    ("Printexc.handle_uncaught_exception", handle_uncaught_exception);
   function _q_(_y_){return runtime.caml_raw_backtrace_next_slot(_y_);}
   function _r_(_x_){return runtime.caml_convert_raw_backtrace_slot(_x_);}
   function _s_(_w_, _v_){return runtime.caml_raw_backtrace_slot(_w_, _v_);}
   var
    _t_ =
      [0,
       backtrace_slot_is_raise,
       backtrace_slot_is_inline,
       backtrace_slot_location,
       backtrace_slot_defname,
       format_backtrace_slot],
    Stdlib_Printexc =
      [0,
       to_string,
       to_string_default,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       runtime.caml_record_backtrace,
       runtime.caml_backtrace_status,
       register_printer,
       use_printers,
       raw_backtrace_entries,
       function(_u_){return caml_get_exception_raw_backtra(_u_);},
       print_raw_backtrace,
       raw_backtrace_to_string,
       default_uncaught_exception_han,
       set_uncaught_exception_handler,
       backtrace_slots,
       backtrace_slots_of_raw_entry,
       _t_,
       raw_backtrace_length,
       _s_,
       _r_,
       _q_,
       exn_slot_id,
       exn_slot_name,
       string_of_extension_constructo];
   runtime.caml_register_global(42, Stdlib_Printexc, "Stdlib__Printexc");
   return;
  }
  (globalThis));

//# 17033 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Digest_from_hex$1 = "Digest.from_hex",
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_md5_string = runtime.caml_md5_string,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_String = global_data.Stdlib__String,
    compare = Stdlib_String[9],
    equal = Stdlib_String[8],
    cst_Digest_from_hex$0 = cst_Digest_from_hex$1,
    cst_Digest_from_hex = cst_Digest_from_hex$1,
    cst_Digest_to_hex = "Digest.to_hex",
    cst_Digest_substring = "Digest.substring";
   function string(str){
    return caml_md5_string(str, 0, caml_ml_string_length(str));
   }
   function bytes(b){return string(caml_call1(Stdlib_Bytes[44], b));}
   function substring(str, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_string_length(str) - len | 0) >= ofs)
     return caml_md5_string(str, ofs, len);
    return caml_call1(Stdlib[1], cst_Digest_substring);
   }
   function subbytes(b, ofs, len){
    return substring(caml_call1(Stdlib_Bytes[44], b), ofs, len);
   }
   function file(filename){
    var ic = caml_call1(Stdlib[80], filename);
    try{var d = runtime.caml_md5_chan(ic, -1);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_call1(Stdlib[93], ic);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    caml_call1(Stdlib[93], ic);
    return d;
   }
   function output(chan, digest){return caml_call2(Stdlib[66], chan, digest);}
   function input(chan){return caml_call2(Stdlib[86], chan, 16);}
   function char_hex(n){var _e_ = 10 <= n ? 87 : 48; return n + _e_ | 0;}
   function to_hex(d){
    if(16 !== caml_ml_string_length(d))
     caml_call1(Stdlib[1], cst_Digest_to_hex);
    var result = caml_create_bytes(32), i = 0;
    for(;;){
     var x = caml_string_get(d, i);
     caml_bytes_unsafe_set(result, i * 2 | 0, char_hex(x >>> 4 | 0));
     caml_bytes_unsafe_set(result, (i * 2 | 0) + 1 | 0, char_hex(x & 15));
     var _d_ = i + 1 | 0;
     if(15 === i) return caml_call1(Stdlib_Bytes[44], result);
     var i = _d_;
    }
   }
   function from_hex(s){
    if(32 !== caml_ml_string_length(s))
     caml_call1(Stdlib[1], cst_Digest_from_hex);
    function digit(c){
     if(65 <= c){
      if(97 <= c){
       if(103 > c) return (c - 97 | 0) + 10 | 0;
      }
      else if(71 > c) return (c - 65 | 0) + 10 | 0;
     }
     else if(9 >= c - 48 >>> 0) return c - 48 | 0;
     throw caml_maybe_attach_backtrace
            ([0, Stdlib[6], cst_Digest_from_hex$0], 1);
    }
    var result = caml_create_bytes(16), i = 0;
    for(;;){
     var
      i$0 = 2 * i | 0,
      _a_ = digit(caml_string_get(s, i$0 + 1 | 0)),
      _b_ = (digit(caml_string_get(s, i$0)) << 4) + _a_ | 0;
     runtime.caml_bytes_set(result, i, caml_call1(Stdlib_Char[1], _b_));
     var _c_ = i + 1 | 0;
     if(15 === i) return caml_call1(Stdlib_Bytes[44], result);
     var i = _c_;
    }
   }
   var
    Stdlib_Digest =
      [0,
       compare,
       equal,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output,
       input,
       to_hex,
       from_hex];
   runtime.caml_register_global(8, Stdlib_Digest, "Stdlib__Digest");
   return;
  }
  (globalThis));

//# 17154 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Bigarray_Array3_of_array_n$1 =
      "Bigarray.Array3.of_array: non-cubic data",
    caml_ba_change_layout = runtime.caml_ba_change_layout,
    caml_ba_create = runtime.caml_ba_create,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_dim_2 = runtime.caml_ba_dim_2,
    caml_ba_kind = runtime.caml_ba_kind,
    caml_ba_num_dims = runtime.caml_ba_num_dims,
    caml_ba_reshape = runtime.caml_ba_reshape,
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_ba_set_2 = runtime.caml_ba_set_2,
    caml_ba_set_3 = runtime.caml_ba_set_3,
    caml_ba_set_generic = runtime.caml_ba_set_generic,
    caml_ba_slice = runtime.caml_ba_slice,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Sys = global_data.Stdlib__Sys,
    cst_Bigarray_array3_of_genarra = "Bigarray.array3_of_genarray",
    cst_Bigarray_array2_of_genarra = "Bigarray.array2_of_genarray",
    cst_Bigarray_array1_of_genarra = "Bigarray.array1_of_genarray",
    cst_Bigarray_array0_of_genarra = "Bigarray.array0_of_genarray",
    cst_Bigarray_Array3_of_array_n = cst_Bigarray_Array3_of_array_n$1,
    cst_Bigarray_Array3_of_array_n$0 = cst_Bigarray_Array3_of_array_n$1,
    cst_Bigarray_Array2_of_array_n =
      "Bigarray.Array2.of_array: non-rectangular data",
    float32 = 0,
    float64 = 1,
    int8_signed = 2,
    int8_unsigned = 3,
    int16_signed = 4,
    int16_unsigned = 5,
    int32 = 6,
    int64 = 7,
    int$0 = 8,
    nativeint = 9,
    complex32 = 10,
    complex64 = 11,
    char$0 = 12;
   function kind_size_in_bytes(param){
    switch(param){
      case 0:
       return 4;
      case 1:
       return 8;
      case 2:
       return 1;
      case 3:
       return 1;
      case 4:
       return 2;
      case 5:
       return 2;
      case 6:
       return 4;
      case 7:
       return 8;
      case 8:
       return Stdlib_Sys[9] / 8 | 0;
      case 9:
       return Stdlib_Sys[9] / 8 | 0;
      case 10:
       return 8;
      case 11:
       return 16;
      default: return 1;
    }
   }
   var c_layout = 0, fortran_layout = 1;
   function cloop(arr, idx, f, col, max){
    if(col === idx.length - 1)
     return caml_ba_set_generic(arr, idx, caml_call1(f, idx));
    var _am_ = caml_check_bound(max, col)[1 + col] - 1 | 0, _al_ = 0;
    if(_am_ >= 0){
     var j = _al_;
     for(;;){
      caml_check_bound(idx, col)[1 + col] = j;
      cloop(arr, idx, f, col + 1 | 0, max);
      var _an_ = j + 1 | 0;
      if(_am_ !== j){var j = _an_; continue;}
      break;
     }
    }
    return 0;
   }
   function floop(arr, idx, f, col, max){
    if(0 > col) return caml_ba_set_generic(arr, idx, caml_call1(f, idx));
    var _aj_ = caml_check_bound(max, col)[1 + col], _ai_ = 1;
    if(_aj_ >= 1){
     var j = _ai_;
     for(;;){
      caml_check_bound(idx, col)[1 + col] = j;
      floop(arr, idx, f, col - 1 | 0, max);
      var _ak_ = j + 1 | 0;
      if(_aj_ !== j){var j = _ak_; continue;}
      break;
     }
    }
    return 0;
   }
   function init(kind, layout, dims, f){
    var arr = caml_ba_create(kind, layout, dims), dlen = dims.length - 1;
    return layout
            ? (floop
               (arr, caml_make_vect(dlen, 1), f, dlen - 1 | 0, dims),
              arr)
            : (cloop(arr, caml_make_vect(dlen, 0), f, 0, dims), arr);
   }
   function dims(a){
    var
     n = caml_ba_num_dims(a),
     d = caml_make_vect(n, 0),
     _af_ = n - 1 | 0,
     _ae_ = 0;
    if(_af_ >= 0){
     var i = _ae_;
     for(;;){
      var _ag_ = runtime.caml_ba_dim(a, i);
      caml_check_bound(d, i)[1 + i] = _ag_;
      var _ah_ = i + 1 | 0;
      if(_af_ !== i){var i = _ah_; continue;}
      break;
     }
    }
    return d;
   }
   function size_in_bytes(arr){
    var
     _ac_ = dims(arr),
     _ad_ = caml_call3(Stdlib_Array[15], caml_mul, 1, _ac_);
    return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _ad_);
   }
   function create(kind, layout){return caml_ba_create(kind, layout, [0]);}
   function get(arr){return runtime.caml_ba_get_generic(arr, [0]);}
   function set(arr){
    var _aa_ = [0];
    return function(_ab_){return caml_ba_set_generic(arr, _aa_, _ab_);};
   }
   function size_in_bytes$0(arr){
    return kind_size_in_bytes(caml_ba_kind(arr));
   }
   function of_value(kind, layout, v){
    var a = create(kind, layout);
    set(a)(v);
    return a;
   }
   function create$0(kind, layout, dim){
    return caml_ba_create(kind, layout, [0, dim]);
   }
   function size_in_bytes$1(arr){
    var _$_ = caml_ba_dim_1(arr);
    return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _$_);
   }
   function slice(a, n){
    return runtime.caml_ba_layout(a)
            ? caml_ba_slice(a, [0, n])
            : caml_ba_slice(a, [0, n]);
   }
   function init$0(kind, layout, dim, f){
    var arr = create$0(kind, layout, dim);
    if(layout){
     var _Z_ = 1;
     if(dim >= 1){
      var i$0 = _Z_;
      for(;;){
       caml_ba_set_1(arr, i$0, caml_call1(f, i$0));
       var ___ = i$0 + 1 | 0;
       if(dim !== i$0){var i$0 = ___; continue;}
       break;
      }
     }
     return arr;
    }
    var _X_ = dim - 1 | 0, _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      caml_ba_set_1(arr, i, caml_call1(f, i));
      var _Y_ = i + 1 | 0;
      if(_X_ !== i){var i = _Y_; continue;}
      break;
     }
    }
    return arr;
   }
   function of_array(kind, layout, data){
    var
     ba = create$0(kind, layout, data.length - 1),
     ofs = layout ? 1 : 0,
     _U_ = data.length - 1 - 1 | 0,
     _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      caml_ba_set_1(ba, i + ofs | 0, caml_check_bound(data, i)[1 + i]);
      var _V_ = i + 1 | 0;
      if(_U_ !== i){var i = _V_; continue;}
      break;
     }
    }
    return ba;
   }
   function create$1(kind, layout, dim1, dim2){
    return caml_ba_create(kind, layout, [0, dim1, dim2]);
   }
   function size_in_bytes$2(arr){
    var _R_ = caml_ba_dim_2(arr), _S_ = caml_ba_dim_1(arr);
    return caml_mul(caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _S_), _R_);
   }
   function slice_left(a, n){return caml_ba_slice(a, [0, n]);}
   function slice_right(a, n){return caml_ba_slice(a, [0, n]);}
   function init$1(kind, layout, dim1, dim2, f){
    var arr = create$1(kind, layout, dim1, dim2);
    if(layout){
     var _N_ = 1;
     if(dim2 >= 1){
      var j$0 = _N_;
      for(;;){
       var _O_ = 1;
       if(dim1 >= 1){
        var i$0 = _O_;
        for(;;){
         caml_ba_set_2(arr, i$0, j$0, caml_call2(f, i$0, j$0));
         var _Q_ = i$0 + 1 | 0;
         if(dim1 !== i$0){var i$0 = _Q_; continue;}
         break;
        }
       }
       var _P_ = j$0 + 1 | 0;
       if(dim2 !== j$0){var j$0 = _P_; continue;}
       break;
      }
     }
     return arr;
    }
    var _I_ = dim1 - 1 | 0, _H_ = 0;
    if(_I_ >= 0){
     var i = _H_;
     for(;;){
      var _K_ = dim2 - 1 | 0, _J_ = 0;
      if(_K_ >= 0){
       var j = _J_;
       for(;;){
        caml_ba_set_2(arr, i, j, caml_call2(f, i, j));
        var _M_ = j + 1 | 0;
        if(_K_ !== j){var j = _M_; continue;}
        break;
       }
      }
      var _L_ = i + 1 | 0;
      if(_I_ !== i){var i = _L_; continue;}
      break;
     }
    }
    return arr;
   }
   function of_array$0(kind, layout, data){
    var
     dim1 = data.length - 1,
     dim2 = 0 === dim1 ? 0 : caml_check_bound(data, 0)[1].length - 1,
     ba = create$1(kind, layout, dim1, dim2),
     ofs = layout ? 1 : 0,
     _C_ = dim1 - 1 | 0,
     _B_ = 0;
    if(_C_ >= 0){
     var i = _B_;
     for(;;){
      var row = caml_check_bound(data, i)[1 + i];
      if(row.length - 1 !== dim2)
       caml_call1(Stdlib[1], cst_Bigarray_Array2_of_array_n);
      var _E_ = dim2 - 1 | 0, _D_ = 0;
      if(_E_ >= 0){
       var j = _D_;
       for(;;){
        caml_ba_set_2
         (ba, i + ofs | 0, j + ofs | 0, caml_check_bound(row, j)[1 + j]);
        var _G_ = j + 1 | 0;
        if(_E_ !== j){var j = _G_; continue;}
        break;
       }
      }
      var _F_ = i + 1 | 0;
      if(_C_ !== i){var i = _F_; continue;}
      break;
     }
    }
    return ba;
   }
   function create$2(kind, layout, dim1, dim2, dim3){
    return caml_ba_create(kind, layout, [0, dim1, dim2, dim3]);
   }
   function size_in_bytes$3(arr){
    var
     _y_ = runtime.caml_ba_dim_3(arr),
     _z_ = caml_ba_dim_2(arr),
     _A_ = caml_ba_dim_1(arr);
    return caml_mul
            (caml_mul
              (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _A_), _z_),
             _y_);
   }
   function slice_left_1(a, n, m){return caml_ba_slice(a, [0, n, m]);}
   function slice_right_1(a, n, m){return caml_ba_slice(a, [0, n, m]);}
   function slice_left_2(a, n){return caml_ba_slice(a, [0, n]);}
   function slice_right_2(a, n){return caml_ba_slice(a, [0, n]);}
   function init$2(kind, layout, dim1, dim2, dim3, f){
    var arr = create$2(kind, layout, dim1, dim2, dim3);
    if(layout){
     var _s_ = 1;
     if(dim3 >= 1){
      var k$0 = _s_;
      for(;;){
       var _t_ = 1;
       if(dim2 >= 1){
        var j$0 = _t_;
        for(;;){
         var _v_ = 1;
         if(dim1 >= 1){
          var i$0 = _v_;
          for(;;){
           caml_ba_set_3(arr, i$0, j$0, k$0, caml_call3(f, i$0, j$0, k$0));
           var _x_ = i$0 + 1 | 0;
           if(dim1 !== i$0){var i$0 = _x_; continue;}
           break;
          }
         }
         var _w_ = j$0 + 1 | 0;
         if(dim2 !== j$0){var j$0 = _w_; continue;}
         break;
        }
       }
       var _u_ = k$0 + 1 | 0;
       if(dim3 !== k$0){var k$0 = _u_; continue;}
       break;
      }
     }
     return arr;
    }
    var _k_ = dim1 - 1 | 0, _j_ = 0;
    if(_k_ >= 0){
     var i = _j_;
     for(;;){
      var _m_ = dim2 - 1 | 0, _l_ = 0;
      if(_m_ >= 0){
       var j = _l_;
       for(;;){
        var _p_ = dim3 - 1 | 0, _o_ = 0;
        if(_p_ >= 0){
         var k = _o_;
         for(;;){
          caml_ba_set_3(arr, i, j, k, caml_call3(f, i, j, k));
          var _r_ = k + 1 | 0;
          if(_p_ !== k){var k = _r_; continue;}
          break;
         }
        }
        var _q_ = j + 1 | 0;
        if(_m_ !== j){var j = _q_; continue;}
        break;
       }
      }
      var _n_ = i + 1 | 0;
      if(_k_ !== i){var i = _n_; continue;}
      break;
     }
    }
    return arr;
   }
   function of_array$1(kind, layout, data){
    var
     dim1 = data.length - 1,
     dim2 = 0 === dim1 ? 0 : caml_check_bound(data, 0)[1].length - 1,
     dim3 =
       0 === dim2
        ? 0
        : caml_check_bound(caml_check_bound(data, 0)[1], 0)[1].length - 1,
     ba = create$2(kind, layout, dim1, dim2, dim3),
     ofs = layout ? 1 : 0,
     _b_ = dim1 - 1 | 0,
     _a_ = 0;
    if(_b_ >= 0){
     var i = _a_;
     for(;;){
      var row = caml_check_bound(data, i)[1 + i];
      if(row.length - 1 !== dim2)
       caml_call1(Stdlib[1], cst_Bigarray_Array3_of_array_n);
      var _d_ = dim2 - 1 | 0, _c_ = 0;
      if(_d_ >= 0){
       var j = _c_;
       for(;;){
        var col = caml_check_bound(row, j)[1 + j];
        if(col.length - 1 !== dim3)
         caml_call1(Stdlib[1], cst_Bigarray_Array3_of_array_n$0);
        var _g_ = dim3 - 1 | 0, _f_ = 0;
        if(_g_ >= 0){
         var k = _f_;
         for(;;){
          caml_ba_set_3
           (ba,
            i + ofs | 0,
            j + ofs | 0,
            k + ofs | 0,
            caml_check_bound(col, k)[1 + k]);
          var _i_ = k + 1 | 0;
          if(_g_ !== k){var k = _i_; continue;}
          break;
         }
        }
        var _h_ = j + 1 | 0;
        if(_d_ !== j){var j = _h_; continue;}
        break;
       }
      }
      var _e_ = i + 1 | 0;
      if(_b_ !== i){var i = _e_; continue;}
      break;
     }
    }
    return ba;
   }
   function array0_of_genarray(a){
    return 0 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array0_of_genarra);
   }
   function array1_of_genarray(a){
    return 1 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array1_of_genarra);
   }
   function array2_of_genarray(a){
    return 2 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array2_of_genarra);
   }
   function array3_of_genarray(a){
    return 3 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array3_of_genarra);
   }
   function reshape_0(a){return caml_ba_reshape(a, [0]);}
   function reshape_1(a, dim1){return caml_ba_reshape(a, [0, dim1]);}
   function reshape_2(a, dim1, dim2){
    return caml_ba_reshape(a, [0, dim1, dim2]);
   }
   function reshape_3(a, dim1, dim2, dim3){
    return caml_ba_reshape(a, [0, dim1, dim2, dim3]);
   }
   var
    Stdlib_Bigarray =
      [0,
       float32,
       float64,
       complex32,
       complex64,
       int8_signed,
       int8_unsigned,
       int16_signed,
       int16_unsigned,
       int$0,
       int32,
       int64,
       nativeint,
       char$0,
       kind_size_in_bytes,
       c_layout,
       fortran_layout,
       [0, init, dims, size_in_bytes],
       [0,
        create,
        of_value,
        caml_ba_change_layout,
        size_in_bytes$0,
        get,
        set,
        of_value],
       [0,
        create$0,
        init$0,
        caml_ba_change_layout,
        size_in_bytes$1,
        slice,
        of_array],
       [0,
        create$1,
        init$1,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$2,
        init$2,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
   runtime.caml_register_global(10, Stdlib_Bigarray, "Stdlib__Bigarray");
   return;
  }
  (globalThis));

//# 17695 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_blit = runtime.caml_ba_blit,
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_lessequal = runtime.caml_lessequal,
    caml_lxm_next = runtime.caml_lxm_next,
    caml_mod = runtime.caml_mod,
    caml_notequal = runtime.caml_notequal,
    caml_sys_random_seed = runtime.caml_sys_random_seed;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib = global_data.Stdlib,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Digest = global_data.Stdlib__Digest,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    _j_ = runtime.caml_int64_create_lo_mi_hi(14371852, 15349651, 22696),
    _k_ = runtime.caml_int64_create_lo_mi_hi(12230193, 11438743, 35013),
    _l_ = runtime.caml_int64_create_lo_mi_hi(1424933, 15549263, 2083),
    _m_ = runtime.caml_int64_create_lo_mi_hi(9492471, 4696708, 43520),
    _f_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _h_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _i_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _g_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_Random_int64 = "Random.int64",
    cst_Random_int32 = "Random.int32",
    cst_Random_full_int = "Random.full_int",
    cst_Random_int = "Random.int",
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _e_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0);
   function create(param){return caml_call3(Stdlib_Bigarray[19][1], 7, 0, 4);}
   function set(s, i1, i2, i3, i4){
    caml_ba_set_1(s, 0, runtime.caml_int64_or(i1, _a_));
    caml_ba_set_1(s, 1, i2);
    var i3$0 = caml_notequal(i3, _b_) ? i3 : _e_;
    caml_ba_set_1(s, 2, i3$0);
    var i4$0 = caml_notequal(i4, _c_) ? i4 : _d_;
    return caml_ba_set_1(s, 3, i4$0);
   }
   function mk(i1, i2, i3, i4){
    var s = create(0);
    set(s, i1, i2, i3, i4);
    return s;
   }
   function copy(s){var s$0 = create(0); caml_ba_blit(s, s$0); return s$0;}
   function reinit(s, seed){
    var
     n = seed.length - 1,
     b = runtime.caml_create_bytes((n * 8 | 0) + 1 | 0),
     _p_ = n - 1 | 0,
     _o_ = 0;
    if(_p_ >= 0){
     var i = _o_;
     for(;;){
      var _t_ = caml_int64_of_int32(runtime.caml_check_bound(seed, i)[1 + i]);
      caml_call3(Stdlib_Bytes[86], b, i * 8 | 0, _t_);
      var _u_ = i + 1 | 0;
      if(_p_ !== i){var i = _u_; continue;}
      break;
     }
    }
    caml_bytes_set(b, n * 8 | 0, 1);
    var d1 = caml_call1(Stdlib_Digest[4], b);
    caml_bytes_set(b, n * 8 | 0, 2);
    var
     d2 = caml_call1(Stdlib_Digest[4], b),
     _q_ = caml_call2(Stdlib_String[64], d2, 8),
     _r_ = caml_call2(Stdlib_String[64], d2, 0),
     _s_ = caml_call2(Stdlib_String[64], d1, 8);
    return set(s, caml_call2(Stdlib_String[64], d1, 0), _s_, _r_, _q_);
   }
   function make(seed){var s = create(0); reinit(s, seed); return s;}
   function make_self_init(param){return make(caml_sys_random_seed(0));}
   function bits(s){
    return caml_int64_to_int32(caml_lxm_next(s)) & 1073741823;
   }
   function intaux(s, n){
    for(;;){
     var r = bits(s), v = caml_mod(r, n);
     if(((1073741823 - n | 0) + 1 | 0) < (r - v | 0)) continue;
     return v;
    }
   }
   function int$0(s, bound){
    if(1073741823 >= bound && 0 < bound) return intaux(s, bound);
    return caml_call1(Stdlib[1], cst_Random_int);
   }
   function full_int(s, bound){
    if(0 >= bound) return caml_call1(Stdlib[1], cst_Random_full_int);
    if(1073741823 >= bound) return intaux(s, bound);
    for(;;){
     var
      _n_ = Stdlib[19],
      r = caml_int64_to_int32(caml_lxm_next(s)) & _n_,
      v = caml_mod(r, bound);
     if(((Stdlib[19] - bound | 0) + 1 | 0) < (r - v | 0)) continue;
     return v;
    }
   }
   function bits32(s){return caml_int64_to_int32(caml_lxm_next(s));}
   function int32(s, bound){
    if(caml_lessequal(bound, 0))
     return caml_call1(Stdlib[1], cst_Random_int32);
    for(;;){
     var r = bits32(s) >>> 1 | 0, v = caml_mod(r, bound);
     if(caml_greaterthan(r - v | 0, (Stdlib_Int32[9] - bound | 0) + 1 | 0))
      continue;
     return v;
    }
   }
   var bits64 = caml_lxm_next;
   function int64(s, bound){
    if(caml_lessequal(bound, _g_))
     return caml_call1(Stdlib[1], cst_Random_int64);
    for(;;){
     var
      r = caml_int64_shift_right_unsigne(caml_lxm_next(s), 1),
      v = runtime.caml_int64_mod(r, bound);
     if
      (caml_greaterthan
        (caml_int64_sub(r, v),
         runtime.caml_int64_add(caml_int64_sub(Stdlib_Int64[9], bound), _f_)))
      continue;
     return v;
    }
   }
   var
    nativebits =
      32 === Stdlib_Nativeint[9]
       ? function(s){return bits32(s);}
       : function(s){return caml_int64_to_int32(caml_lxm_next(s));},
    nativeint =
      32 === Stdlib_Nativeint[9]
       ? function(s, bound){return int32(s, bound);}
       : function
        (s, bound){
         return caml_int64_to_int32(int64(s, caml_int64_of_int32(bound)));
        };
   function float$0(s, bound){
    for(;;){
     var b = caml_lxm_next(s), n = caml_int64_shift_right_unsigne(b, 11);
     if(caml_notequal(n, _h_))
      return runtime.caml_int64_to_float(n) * 1.1102230246251565e-16 * bound;
    }
   }
   function bool(s){return runtime.caml_lessthan(caml_lxm_next(s), _i_);}
   function split(s){
    var
     i1 = caml_lxm_next(s),
     i2 = caml_lxm_next(s),
     i3 = caml_lxm_next(s),
     i4 = caml_lxm_next(s);
    return mk(i1, i2, i3, i4);
   }
   function mk_default(param){return mk(_m_, _l_, _k_, _j_);}
   var random_key = caml_call2(Stdlib_Domain[10][1], [0, split], mk_default);
   function bits$0(param){
    return bits(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function int$1(bound){
    return int$0(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function full_int$0(bound){
    return full_int(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function int32$0(bound){
    return int32(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function nativeint$0(bound){
    return nativeint(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function int64$0(bound){
    return int64(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function float$1(scale){
    return float$0(caml_call1(Stdlib_Domain[10][2], random_key), scale);
   }
   function bool$0(param){
    return bool(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function bits32$0(param){
    return bits32(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function bits64$0(param){
    return caml_lxm_next(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function nativebits$0(param){
    return nativebits(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function full_init(seed){
    return reinit(caml_call1(Stdlib_Domain[10][2], random_key), seed);
   }
   function init(seed){return full_init([0, seed]);}
   function self_init(param){return full_init(caml_sys_random_seed(0));}
   function split$0(param){
    return split(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function get_state(param){
    return copy(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function set_state(s){
    return caml_ba_blit(s, caml_call1(Stdlib_Domain[10][2], random_key));
   }
   var
    Stdlib_Random =
      [0,
       init,
       full_init,
       self_init,
       bits$0,
       int$1,
       full_int$0,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       bits32$0,
       bits64$0,
       nativebits$0,
       [0,
        make,
        make_self_init,
        copy,
        bits,
        int$0,
        full_int,
        int32,
        nativeint,
        int64,
        float$0,
        bool,
        bits32,
        bits64,
        nativebits,
        split],
       get_state,
       set_state,
       split$0];
   runtime.caml_register_global(29, Stdlib_Random, "Stdlib__Random");
   return;
  }
  (globalThis));

//# 22653 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_register_named_value = runtime.caml_register_named_value,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    register = caml_register_named_value;
   function register_exception(name, exn){
    var
     _a_ = Stdlib_Obj[10],
     slot = runtime.caml_obj_tag(exn) === _a_ ? exn : exn[1];
    return caml_register_named_value(name, slot);
   }
   var Stdlib_Callback = [0, register, register_exception];
   runtime.caml_register_global(1, Stdlib_Callback, "Stdlib__Callback");
   return;
  }
  (globalThis));

//# 24561 "../../.js/default/stdlib/stdlib.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$19 = "",
    cst$23 = " ",
    cst_2$1 = " 2>",
    cst_2_1$1 = " 2>&1",
    cst$22 = " <",
    cst$21 = " >",
    cst$20 = '"',
    cst$24 = ".",
    cst$25 = "..",
    cst$28 = "../",
    cst$27 = "./",
    cst$26 = "/",
    cst_dev_null = "/dev/null",
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_get = runtime.caml_string_get,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$18 = cst$19,
    cst$17 = cst$19,
    cst$16 = cst$19,
    cst$8 = cst$21,
    cst$15 = cst$19,
    cst$9 = cst$22,
    cst$14 = cst$19,
    cst$10 = cst$23,
    cst$11 = cst$23,
    cst$12 = cst$20,
    cst$13 = cst$19,
    cst$6 = cst$20,
    cst$7 = cst$20,
    cst$4 = cst$19,
    cst = cst$21,
    cst$3 = cst$19,
    cst$0 = cst$22,
    cst$2 = cst$19,
    cst$1 = cst$23,
    null$0 = cst_dev_null,
    current_dir_name = cst$24,
    parent_dir_name = cst$25,
    dir_sep = cst$26,
    quotequote = "'\\''",
    null$1 = "NUL",
    current_dir_name$0 = cst$24,
    parent_dir_name$0 = cst$25,
    dir_sep$0 = "\\",
    cst$5 = cst$24,
    null$2 = cst_dev_null,
    current_dir_name$1 = cst$24,
    parent_dir_name$1 = cst$25,
    dir_sep$1 = cst$26,
    Stdlib = global_data.Stdlib,
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Sys = global_data.Stdlib__Sys,
    _i_ = [0, 7, 0],
    _h_ = [0, 1, [0, 3, [0, 5, 0]]],
    _e_ = [0, [2, 0, [4, 6, [0, 2, 6], 0, [2, 0, 0]]], "%s%06x%s"],
    cst_Filename_chop_extension = "Filename.chop_extension",
    cst_Filename_chop_suffix = "Filename.chop_suffix",
    _c_ = [0, cst$20, 0],
    cst_2_1$0 = cst_2_1$1,
    cst_2$0 = cst_2$1,
    cst_Filename_quote_command_bad = "Filename.quote_command: bad file name ",
    cst_2_1 = cst_2_1$1,
    cst_2 = cst_2$1,
    cst_tmp = "/tmp";
   function generic_basename(is_dir_sep, current_dir_name, name){
    if(caml_string_equal(name, cst$19)) return current_dir_name;
    var n$3 = caml_ml_string_length(name) - 1 | 0, n = n$3;
    for(;;){
     if(0 > n) return caml_call3(Stdlib_String[15], name, 0, 1);
     if(caml_call2(is_dir_sep, name, n)){
      var n$0 = n - 1 | 0, n = n$0;
      continue;
     }
     var p = n + 1 | 0, n$1 = n;
     for(;;){
      if(0 > n$1) return caml_call3(Stdlib_String[15], name, 0, p);
      if(caml_call2(is_dir_sep, name, n$1))
       return caml_call3
               (Stdlib_String[15], name, n$1 + 1 | 0, (p - n$1 | 0) - 1 | 0);
      var n$2 = n$1 - 1 | 0, n$1 = n$2;
     }
    }
   }
   function generic_dirname(is_dir_sep, current_dir_name, name){
    if(caml_string_equal(name, cst$19)) return current_dir_name;
    var n$5 = caml_ml_string_length(name) - 1 | 0, n = n$5;
    for(;;){
     if(0 > n) return caml_call3(Stdlib_String[15], name, 0, 1);
     if(caml_call2(is_dir_sep, name, n)){
      var n$0 = n - 1 | 0, n = n$0;
      continue;
     }
     var n$1 = n;
     for(;;){
      if(0 > n$1) return current_dir_name;
      if(! caml_call2(is_dir_sep, name, n$1)){
       var n$2 = n$1 - 1 | 0, n$1 = n$2;
       continue;
      }
      var n$3 = n$1;
      for(;;){
       if(0 > n$3) return caml_call3(Stdlib_String[15], name, 0, 1);
       if(! caml_call2(is_dir_sep, name, n$3))
        return caml_call3(Stdlib_String[15], name, 0, n$3 + 1 | 0);
       var n$4 = n$3 - 1 | 0, n$3 = n$4;
      }
     }
    }
   }
   function is_dir_sep(s, i){return 47 === caml_string_get(s, i) ? 1 : 0;}
   function is_relative(n){
    var
     _aK_ = caml_ml_string_length(n) < 1 ? 1 : 0,
     _aL_ = _aK_ || (47 !== caml_string_get(n, 0) ? 1 : 0);
    return _aL_;
   }
   function is_implicit(n){
    var _aF_ = is_relative(n);
    if(_aF_){
     var
      _aG_ = caml_ml_string_length(n) < 2 ? 1 : 0,
      _aH_ =
        _aG_
        ||
         caml_string_notequal(caml_call3(Stdlib_String[15], n, 0, 2), cst$27);
     if(_aH_)
      var
       _aI_ = caml_ml_string_length(n) < 3 ? 1 : 0,
       _aJ_ =
         _aI_
         ||
          caml_string_notequal(caml_call3(Stdlib_String[15], n, 0, 3), cst$28);
     else
      var _aJ_ = _aH_;
    }
    else
     var _aJ_ = _aF_;
    return _aJ_;
   }
   function check_suffix(name, suff){
    return caml_call2(Stdlib_String[11], suff, name);
   }
   function chop_suffix_opt(suffix, filename){
    var
     len_s = caml_ml_string_length(suffix),
     len_f = caml_ml_string_length(filename);
    if(len_s > len_f) return 0;
    var r = caml_call3(Stdlib_String[15], filename, len_f - len_s | 0, len_s);
    return caml_string_equal(r, suffix)
            ? [0,
              caml_call3(Stdlib_String[15], filename, 0, len_f - len_s | 0)]
            : 0;
   }
   try{var _k_ = caml_sys_getenv("TMPDIR"), temp_dir_name = _k_;}
   catch(_aE_){
    var _a_ = caml_wrap_exception(_aE_);
    if(_a_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a_, 0);
    var temp_dir_name = cst_tmp;
   }
   function quote(s){
    var
     l = caml_ml_string_length(s),
     b = caml_call1(Stdlib_Buffer[1], l + 20 | 0);
    caml_call2(Stdlib_Buffer[12], b, 39);
    var _aB_ = l - 1 | 0, _aA_ = 0;
    if(_aB_ >= 0){
     var i = _aA_;
     for(;;){
      if(39 === caml_string_get(s, i))
       caml_call2(Stdlib_Buffer[16], b, quotequote);
      else{
       var _aD_ = caml_string_get(s, i);
       caml_call2(Stdlib_Buffer[12], b, _aD_);
      }
      var _aC_ = i + 1 | 0;
      if(_aB_ !== i){var i = _aC_; continue;}
      break;
     }
    }
    caml_call2(Stdlib_Buffer[12], b, 39);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function quote_command(cmd, stdin, stdout, stderr, args){
    if(stderr){
     var f = stderr[1];
     if(caml_equal(stderr, stdout))
      var _ap_ = cst_2_1;
     else
      var _az_ = quote(f), _ap_ = caml_call2(Stdlib[28], cst_2, _az_);
     var _aq_ = _ap_;
    }
    else
     var _aq_ = cst$4;
    if(stdout)
     var
      f$0 = stdout[1],
      _ar_ = quote(f$0),
      _as_ = caml_call2(Stdlib[28], cst, _ar_);
    else
     var _as_ = cst$3;
    var _at_ = caml_call2(Stdlib[28], _as_, _aq_);
    if(stdin)
     var
      f$1 = stdin[1],
      _au_ = quote(f$1),
      _av_ = caml_call2(Stdlib[28], cst$0, _au_);
    else
     var _av_ = cst$2;
    var
     _aw_ = caml_call2(Stdlib[28], _av_, _at_),
     _ax_ = caml_call2(Stdlib_List[19], quote, [0, cmd, args]),
     _ay_ = caml_call2(Stdlib_String[6], cst$1, _ax_);
    return caml_call2(Stdlib[28], _ay_, _aw_);
   }
   function basename(_ao_){
    return generic_basename(is_dir_sep, current_dir_name, _ao_);
   }
   function dirname(_an_){
    return generic_dirname(is_dir_sep, current_dir_name, _an_);
   }
   var
    Unix =
      [0,
       null$0,
       current_dir_name,
       parent_dir_name,
       dir_sep,
       is_dir_sep,
       is_relative,
       is_implicit,
       check_suffix,
       chop_suffix_opt,
       temp_dir_name,
       quote,
       quote_command,
       basename,
       dirname];
   function is_dir_sep$0(s, i){
    var c = caml_string_get(s, i), _ak_ = 47 === c ? 1 : 0;
    if(_ak_)
     var _al_ = _ak_;
    else
     var _am_ = 92 === c ? 1 : 0, _al_ = _am_ || (58 === c ? 1 : 0);
    return _al_;
   }
   function is_relative$0(n){
    var
     _ae_ = caml_ml_string_length(n) < 1 ? 1 : 0,
     _af_ = _ae_ || (47 !== caml_string_get(n, 0) ? 1 : 0);
    if(_af_){
     var
      _ag_ = caml_ml_string_length(n) < 1 ? 1 : 0,
      _ah_ = _ag_ || (92 !== caml_string_get(n, 0) ? 1 : 0);
     if(_ah_)
      var
       _ai_ = caml_ml_string_length(n) < 2 ? 1 : 0,
       _aj_ = _ai_ || (58 !== caml_string_get(n, 1) ? 1 : 0);
     else
      var _aj_ = _ah_;
    }
    else
     var _aj_ = _af_;
    return _aj_;
   }
   function is_implicit$0(n){
    var _X_ = is_relative$0(n);
    if(_X_){
     var
      _Y_ = caml_ml_string_length(n) < 2 ? 1 : 0,
      _Z_ =
        _Y_
        ||
         caml_string_notequal(caml_call3(Stdlib_String[15], n, 0, 2), cst$27);
     if(_Z_){
      var
       ___ = caml_ml_string_length(n) < 2 ? 1 : 0,
       _$_ =
         ___
         ||
          caml_string_notequal(caml_call3(Stdlib_String[15], n, 0, 2), ".\\");
      if(_$_){
       var
        _aa_ = caml_ml_string_length(n) < 3 ? 1 : 0,
        _ab_ =
          _aa_
          ||
           caml_string_notequal
            (caml_call3(Stdlib_String[15], n, 0, 3), cst$28);
       if(_ab_)
        var
         _ac_ = caml_ml_string_length(n) < 3 ? 1 : 0,
         _ad_ =
           _ac_
           ||
            caml_string_notequal
             (caml_call3(Stdlib_String[15], n, 0, 3), "..\\");
       else
        var _ad_ = _ab_;
      }
      else
       var _ad_ = _$_;
     }
     else
      var _ad_ = _Z_;
    }
    else
     var _ad_ = _X_;
    return _ad_;
   }
   function check_suffix$0(name, suff){
    var
     _U_ = caml_ml_string_length(suff) <= caml_ml_string_length(name) ? 1 : 0;
    if(_U_)
     var
      s =
        caml_call3
         (Stdlib_String[15],
          name,
          caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
          caml_ml_string_length(suff)),
      _V_ = caml_call1(Stdlib_String[26], suff),
      _W_ = caml_string_equal(caml_call1(Stdlib_String[26], s), _V_);
    else
     var _W_ = _U_;
    return _W_;
   }
   function chop_suffix_opt$0(suffix, filename){
    var
     len_s = caml_ml_string_length(suffix),
     len_f = caml_ml_string_length(filename);
    if(len_s > len_f) return 0;
    var
     r = caml_call3(Stdlib_String[15], filename, len_f - len_s | 0, len_s),
     _T_ = caml_call1(Stdlib_String[26], suffix);
    return caml_string_equal(caml_call1(Stdlib_String[26], r), _T_)
            ? [0,
              caml_call3(Stdlib_String[15], filename, 0, len_f - len_s | 0)]
            : 0;
   }
   try{var _j_ = caml_sys_getenv("TEMP"), temp_dir_name$0 = _j_;}
   catch(_S_){
    var _b_ = caml_wrap_exception(_S_);
    if(_b_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_b_, 0);
    var temp_dir_name$0 = cst$5;
   }
   function quote$0(s){
    var
     l = caml_ml_string_length(s),
     b = caml_call1(Stdlib_Buffer[1], l + 20 | 0);
    caml_call2(Stdlib_Buffer[12], b, 34);
    function add_bs(n){
     var _Q_ = 1;
     if(n >= 1){
      var j = _Q_;
      for(;;){
       caml_call2(Stdlib_Buffer[12], b, 92);
       var _R_ = j + 1 | 0;
       if(n !== j){var j = _R_; continue;}
       break;
      }
     }
     return 0;
    }
    function loop$0(counter, i){
     var i$0 = i;
     for(;;){
      if(i$0 === l) return caml_call2(Stdlib_Buffer[12], b, 34);
      var c = caml_string_get(s, i$0);
      if(34 === c){
       var _O_ = 0;
       if(counter >= 50)
        return caml_trampoline_return(loop_bs, [0, _O_, i$0]);
       var counter$1 = counter + 1 | 0;
       return loop_bs(counter$1, _O_, i$0);
      }
      if(92 !== c){
       caml_call2(Stdlib_Buffer[12], b, c);
       var i$1 = i$0 + 1 | 0, i$0 = i$1;
       continue;
      }
      var _P_ = 0;
      if(counter >= 50) return caml_trampoline_return(loop_bs, [0, _P_, i$0]);
      var counter$0 = counter + 1 | 0;
      return loop_bs(counter$0, _P_, i$0);
     }
    }
    function loop_bs(counter, n, i){
     var n$0 = n, i$0 = i;
     for(;;){
      if(i$0 === l){caml_call2(Stdlib_Buffer[12], b, 34); return add_bs(n$0);}
      var match = caml_string_get(s, i$0);
      if(34 === match){
       add_bs((2 * n$0 | 0) + 1 | 0);
       caml_call2(Stdlib_Buffer[12], b, 34);
       var _N_ = i$0 + 1 | 0;
       if(counter >= 50) return caml_trampoline_return(loop$0, [0, _N_]);
       var counter$1 = counter + 1 | 0;
       return loop$0(counter$1, _N_);
      }
      if(92 === match){
       var i$1 = i$0 + 1 | 0, n$1 = n$0 + 1 | 0, n$0 = n$1, i$0 = i$1;
       continue;
      }
      add_bs(n$0);
      if(counter >= 50) return caml_trampoline_return(loop$0, [0, i$0]);
      var counter$0 = counter + 1 | 0;
      return loop$0(counter$0, i$0);
     }
    }
    function loop(i){return caml_trampoline(loop$0(0, i));}
    loop(0);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function quote_cmd_filename(f){
    if
     (!
      caml_call2(Stdlib_String[14], f, 34)
      && ! caml_call2(Stdlib_String[14], f, 37)){
     if(! caml_call2(Stdlib_String[14], f, 32)) return f;
     var _M_ = caml_call2(Stdlib[28], f, cst$6);
     return caml_call2(Stdlib[28], cst$7, _M_);
    }
    var _L_ = caml_call2(Stdlib[28], cst_Filename_quote_command_bad, f);
    return caml_call1(Stdlib[2], _L_);
   }
   function quote_command$0(cmd, stdin, stdout, stderr, args){
    if(stderr){
     var f = stderr[1];
     if(caml_equal(stderr, stdout))
      var _x_ = cst_2_1$0;
     else
      var
       _J_ = quote_cmd_filename(f),
       _x_ = caml_call2(Stdlib[28], cst_2$0, _J_);
     var _y_ = _x_;
    }
    else
     var _y_ = cst$16;
    var _z_ = [0, _y_, _c_];
    if(stdout)
     var
      f$0 = stdout[1],
      _A_ = quote_cmd_filename(f$0),
      _B_ = caml_call2(Stdlib[28], cst$8, _A_);
    else
     var _B_ = cst$15;
    var _C_ = [0, _B_, _z_];
    if(stdin)
     var
      f$1 = stdin[1],
      _D_ = quote_cmd_filename(f$1),
      _E_ = caml_call2(Stdlib[28], cst$9, _D_);
    else
     var _E_ = cst$14;
    var
     _G_ = caml_call2(Stdlib_List[19], quote$0, args),
     s = caml_call2(Stdlib_String[6], cst$10, _G_),
     b = caml_call1(Stdlib_Buffer[1], caml_ml_string_length(s) + 20 | 0),
     _F_ = [0, _E_, _C_];
    function _w_(c){
     var switch$0 = 0;
     if(62 <= c){
      var _K_ = c - 63 | 0;
      if(60 < _K_ >>> 0){
       if(62 > _K_) switch$0 = 1;
      }
      else if(31 === _K_) switch$0 = 1;
     }
     else
      if(42 <= c){
       if(60 === c) switch$0 = 1;
      }
      else if(33 <= c)
       switch(c - 33 | 0){case 2:case 3:case 6: break;default: switch$0 = 1;}
     return switch$0
             ? (caml_call2
                (Stdlib_Buffer[12], b, 94),
               caml_call2(Stdlib_Buffer[12], b, c))
             : caml_call2(Stdlib_Buffer[12], b, c);
    }
    caml_call2(Stdlib_String[29], _w_, s);
    var
     _H_ = [0, cst$11, [0, caml_call1(Stdlib_Buffer[2], b), _F_]],
     _I_ = [0, cst$12, [0, quote_cmd_filename(cmd), _H_]];
    return caml_call2(Stdlib_String[6], cst$13, _I_);
   }
   function drive_and_path(s){
    var _s_ = 2 <= caml_ml_string_length(s) ? 1 : 0;
    if(_s_){
     var param = caml_string_get(s, 0), switch$0 = 0;
     if(91 <= param){
      if(25 >= param - 97 >>> 0) switch$0 = 1;
     }
     else if(65 <= param) switch$0 = 1;
     var
      _t_ = switch$0 ? 1 : 0,
      _u_ = _t_ ? 58 === caml_string_get(s, 1) ? 1 : 0 : _t_;
    }
    else
     var _u_ = _s_;
    if(! _u_) return [0, cst$17, s];
    var
     _v_ =
       caml_call3(Stdlib_String[15], s, 2, caml_ml_string_length(s) - 2 | 0);
    return [0, caml_call3(Stdlib_String[15], s, 0, 2), _v_];
   }
   function dirname$0(s){
    var
     match = drive_and_path(s),
     path = match[2],
     drive = match[1],
     dir = generic_dirname(is_dir_sep$0, current_dir_name$0, path);
    return caml_call2(Stdlib[28], drive, dir);
   }
   function basename$0(s){
    var path = drive_and_path(s)[2];
    return generic_basename(is_dir_sep$0, current_dir_name$0, path);
   }
   var
    Win32 =
      [0,
       null$1,
       current_dir_name$0,
       parent_dir_name$0,
       dir_sep$0,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       temp_dir_name$0,
       quote$0,
       quote_command$0,
       basename$0,
       dirname$0];
   function basename$1(_r_){
    return generic_basename(is_dir_sep$0, current_dir_name$1, _r_);
   }
   function dirname$1(_q_){
    return generic_dirname(is_dir_sep$0, current_dir_name$1, _q_);
   }
   var
    Cygwin =
      [0,
       null$2,
       current_dir_name$1,
       parent_dir_name$1,
       dir_sep$1,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       temp_dir_name,
       quote,
       quote_command,
       basename$1,
       dirname$1],
    _d_ = Stdlib_Sys[4],
    Sysdeps =
      caml_string_notequal(_d_, "Cygwin")
       ? caml_string_notequal(_d_, "Win32") ? Unix : Win32
       : Cygwin,
    null$3 = Sysdeps[1],
    current_dir_name$2 = Sysdeps[2],
    parent_dir_name$2 = Sysdeps[3],
    dir_sep$2 = Sysdeps[4],
    is_dir_sep$1 = Sysdeps[5],
    is_relative$1 = Sysdeps[6],
    is_implicit$1 = Sysdeps[7],
    check_suffix$1 = Sysdeps[8],
    chop_suffix_opt$1 = Sysdeps[9],
    temp_dir_name$1 = Sysdeps[10],
    quote$1 = Sysdeps[11],
    quote_command$1 = Sysdeps[12],
    basename$2 = Sysdeps[13],
    dirname$2 = Sysdeps[14];
   function concat(dirname, filename){
    var l = caml_ml_string_length(dirname);
    if(0 !== l && ! is_dir_sep$1(dirname, l - 1 | 0)){
     var _p_ = caml_call2(Stdlib[28], dir_sep$2, filename);
     return caml_call2(Stdlib[28], dirname, _p_);
    }
    return caml_call2(Stdlib[28], dirname, filename);
   }
   function chop_suffix(name, suff){
    return check_suffix$1(name, suff)
            ? caml_call3
              (Stdlib_String[15],
               name,
               0,
               caml_ml_string_length(name) - caml_ml_string_length(suff) | 0)
            : caml_call1(Stdlib[1], cst_Filename_chop_suffix);
   }
   function extension_len(name){
    var i$3 = caml_ml_string_length(name) - 1 | 0, i0 = i$3;
    for(;;){
     if(0 <= i0 && ! is_dir_sep$1(name, i0)){
      if(46 !== caml_string_get(name, i0)){
       var i$2 = i0 - 1 | 0, i0 = i$2;
       continue;
      }
      var i$1 = i0 - 1 | 0, i = i$1;
      for(;;){
       if(0 <= i && ! is_dir_sep$1(name, i)){
        if(46 !== caml_string_get(name, i))
         return caml_ml_string_length(name) - i0 | 0;
        var i$0 = i - 1 | 0, i = i$0;
        continue;
       }
       return 0;
      }
     }
     return 0;
    }
   }
   function extension(name){
    var l = extension_len(name);
    return 0 === l
            ? cst$18
            : caml_call3
              (Stdlib_String[15],
               name,
               caml_ml_string_length(name) - l | 0,
               l);
   }
   function chop_extension(name){
    var l = extension_len(name);
    return 0 === l
            ? caml_call1(Stdlib[1], cst_Filename_chop_extension)
            : caml_call3
              (Stdlib_String[15],
               name,
               0,
               caml_ml_string_length(name) - l | 0);
   }
   function remove_extension(name){
    var l = extension_len(name);
    return 0 === l
            ? name
            : caml_call3
              (Stdlib_String[15],
               name,
               0,
               caml_ml_string_length(name) - l | 0);
   }
   var prng_key = caml_call2(Stdlib_Domain[10][1], 0, Stdlib_Random[15][2]);
   function temp_file_name(temp_dir, prefix, suffix){
    var
     random_state = caml_call1(Stdlib_Domain[10][2], prng_key),
     rnd = caml_call1(Stdlib_Random[15][4], random_state) & 16777215;
    return concat
            (temp_dir, caml_call4(Stdlib_Printf[4], _e_, prefix, rnd, suffix));
   }
   function _f_(param){return temp_dir_name$1;}
   var
    _g_ = [0, function(_o_){return _o_;}],
    current_temp_dir_name = caml_call2(Stdlib_Domain[10][1], _g_, _f_);
   function set_temp_dir_name(s){
    return caml_call2(Stdlib_Domain[10][3], current_temp_dir_name, s);
   }
   function get_temp_dir_name(param){
    return caml_call1(Stdlib_Domain[10][2], current_temp_dir_name);
   }
   function temp_file(opt, prefix, suffix){
    if(opt)
     var sth = opt[1], temp_dir = sth;
    else
     var temp_dir = caml_call1(Stdlib_Domain[10][2], current_temp_dir_name);
    var counter = 0;
    for(;;){
     var name = temp_file_name(temp_dir, prefix, suffix);
     try{
      runtime.caml_sys_close(runtime.caml_sys_open(name, _h_, 384));
      return name;
     }
     catch(e$0){
      var e = caml_wrap_exception(e$0);
      if(e[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(e, 0);
      if(1000 <= counter) throw caml_maybe_attach_backtrace(e, 0);
      var counter$0 = counter + 1 | 0, counter = counter$0;
      continue;
     }
    }
   }
   function open_temp_file(opt, _m_, _l_, prefix, suffix){
    if(opt) var sth = opt[1], mode = sth; else var mode = _i_;
    if(_m_) var sth$0 = _m_[1], perms = sth$0; else var perms = 384;
    if(_l_)
     var sth$1 = _l_[1], temp_dir = sth$1;
    else
     var temp_dir = caml_call1(Stdlib_Domain[10][2], current_temp_dir_name);
    var counter = 0;
    for(;;){
     var name = temp_file_name(temp_dir, prefix, suffix);
     try{
      var
       _n_ =
         [0,
          name,
          caml_call3(Stdlib[62], [0, 1, [0, 3, [0, 5, mode]]], perms, name)];
      return _n_;
     }
     catch(e$0){
      var e = caml_wrap_exception(e$0);
      if(e[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(e, 0);
      if(1000 <= counter) throw caml_maybe_attach_backtrace(e, 0);
      var counter$0 = counter + 1 | 0, counter = counter$0;
      continue;
     }
    }
   }
   var
    Stdlib_Filename =
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       chop_suffix_opt$1,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       null$3,
       temp_file,
       open_temp_file,
       get_temp_dir_name,
       set_temp_dir_name,
       quote$1,
       quote_command$1];
   runtime.caml_register_global(65, Stdlib_Filename, "Stdlib__Filename");
   return;
  }
  (globalThis));


//# 1 "../../src/.alg.objs/jsoo/default/alg.cma.js"
// Generated by js_of_ocaml
//# 3 "../../src/.alg.objs/jsoo/default/alg.cma.js"

//# 16 "../../src/.alg.objs/jsoo/default/alg.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List;
   function namer(eq){
    var n = [0, 0], names = [0, 0];
    return function(e){
     var _a_ = names[1];
     function _b_(param){var e$0 = param[1]; return caml_call2(eq, e, e$0);}
     if(1 - caml_call2(Stdlib_List[33], _b_, _a_)){
      names[1] = [0, [0, e, n[1]], names[1]];
      n[1]++;
     }
     var _c_ = names[1];
     function _d_(param){var e$0 = param[1]; return caml_call2(eq, e, e$0);}
     return caml_call2(Stdlib_List[38], _d_, _c_)[2];};
   }
   var Alg_Utils = [0, namer];
   runtime.caml_register_global(1, Alg_Utils, "Alg__Utils");
   return;
  }
  (globalThis));

//# 295 "../../src/.alg.objs/jsoo/default/alg.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$21 = "",
    cst_src_extlib_ml = "src/extlib.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$11 = "\xe2\x81\xb0",
    cst$12 = "\xc2\xb9",
    cst$13 = "\xc2\xb2",
    cst$14 = "\xc2\xb3",
    cst$15 = "\xe2\x81\xb4",
    cst$16 = "\xe2\x81\xb5",
    cst$17 = "\xe2\x81\xb6",
    cst$18 = "\xe2\x81\xb7",
    cst$19 = "\xe2\x81\xb8",
    cst$20 = "\xe2\x81\xb9",
    cst$10 = cst$21,
    cst$0 = "\xe2\x82\x80",
    cst$1 = "\xe2\x82\x81",
    cst$2 = "\xe2\x82\x82",
    cst$3 = "\xe2\x82\x83",
    cst$4 = "\xe2\x82\x84",
    cst$5 = "\xe2\x82\x85",
    cst$6 = "\xe2\x82\x86",
    cst$7 = "\xe2\x82\x87",
    cst$8 = "\xe2\x82\x88",
    cst$9 = "\xe2\x82\x89",
    cst = cst$21,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_List = global_data.Stdlib__List,
    _b_ = [0, cst_src_extlib_ml, 78, 16],
    _a_ = [0, cst_src_extlib_ml, 62, 16],
    cst_List_sub = "List.sub";
   function pair(x, y){return [0, x, y];}
   function unpair(f, param){
    var y = param[2], x = param[1];
    return caml_call2(f, x, y);
   }
   function modulo(x, y){
    var ans = runtime.caml_mod(x, y);
    return 0 <= ans ? ans : ans + y | 0;
   }
   var
    Int = [0, modulo],
    length = Stdlib_List[1],
    compare_lengths = Stdlib_List[2],
    compare_length_with = Stdlib_List[3],
    cons = Stdlib_List[4],
    hd = Stdlib_List[5],
    tl = Stdlib_List[6],
    nth = Stdlib_List[7],
    nth_opt = Stdlib_List[8],
    rev = Stdlib_List[9],
    init = Stdlib_List[10],
    append = Stdlib_List[11],
    rev_append = Stdlib_List[12],
    concat = Stdlib_List[13],
    flatten = Stdlib_List[14],
    equal = Stdlib_List[15],
    compare = Stdlib_List[16],
    iter = Stdlib_List[17],
    iteri = Stdlib_List[18],
    map = Stdlib_List[19],
    mapi = Stdlib_List[20],
    rev_map = Stdlib_List[21],
    filter_map = Stdlib_List[22],
    concat_map = Stdlib_List[23],
    fold_left_map = Stdlib_List[24],
    fold_left = Stdlib_List[25],
    fold_right = Stdlib_List[26],
    iter2 = Stdlib_List[27],
    map2 = Stdlib_List[28],
    rev_map2 = Stdlib_List[29],
    fold_left2 = Stdlib_List[30],
    fold_right2 = Stdlib_List[31],
    for_all = Stdlib_List[32],
    exists = Stdlib_List[33],
    for_all2 = Stdlib_List[34],
    exists2 = Stdlib_List[35],
    mem = Stdlib_List[36],
    memq = Stdlib_List[37],
    find = Stdlib_List[38],
    find_opt = Stdlib_List[39],
    find_map = Stdlib_List[40],
    filter = Stdlib_List[41],
    find_all = Stdlib_List[42],
    filteri = Stdlib_List[43],
    partition = Stdlib_List[44],
    partition_map = Stdlib_List[45],
    assoc = Stdlib_List[46],
    assoc_opt = Stdlib_List[47],
    assq = Stdlib_List[48],
    assq_opt = Stdlib_List[49],
    mem_assoc = Stdlib_List[50],
    mem_assq = Stdlib_List[51],
    remove_assoc = Stdlib_List[52],
    remove_assq = Stdlib_List[53],
    split = Stdlib_List[54],
    combine = Stdlib_List[55],
    sort = Stdlib_List[56],
    stable_sort = Stdlib_List[57],
    fast_sort = Stdlib_List[58],
    sort_uniq = Stdlib_List[59],
    merge = Stdlib_List[60],
    to_seq = Stdlib_List[61],
    of_seq = Stdlib_List[62];
   function index(p, l){
    var n = 0, param = l;
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l$0 = param[2], x = param[1];
     if(caml_call1(p, x)) return n;
     var n$0 = n + 1 | 0, n = n$0, param = l$0;
    }
   }
   function replace_nth(l, n, x){
    function k$1(_o_){return _o_;}
    var n$0 = n, k = k$1, param = l;
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l$0 = param[2], y = param[1];
     if(0 === n$0) return k([0, x, l$0]);
     var
      k$2 = function(k, y){function k$0(l){return k([0, y, l]);} return k$0;},
      k$0 = k$2(k, y),
      n$1 = n$0 - 1 | 0,
      n$0 = n$1,
      k = k$0,
      param = l$0;
    }
   }
   function replace_assoc(k, v, l){
    function _n_(param){
     var v$0 = param[2], k$0 = param[1];
     return runtime.caml_equal(k, k$0) ? [0, k, v] : [0, k$0, v$0];
    }
    return caml_call2(Stdlib_List[19], _n_, l);
   }
   function sub(l, ofs, len){
    var l$0 = l, ofs$0 = ofs;
    for(;;){
     if(0 === ofs$0 && 0 === len) return 0;
     if(! l$0) return caml_call1(Stdlib[1], cst_List_sub);
     var l$1 = l$0[2], x = l$0[1];
     if(0 === ofs$0) return [0, x, sub(l$1, ofs$0, len - 1 | 0)];
     var ofs$1 = ofs$0 - 1 | 0, l$0 = l$1, ofs$0 = ofs$1;
    }
   }
   var
    List =
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       concat,
       flatten,
       equal,
       compare,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       filter_map,
       concat_map,
       fold_left_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       filter,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       sort,
       stable_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq,
       index,
       replace_nth,
       replace_assoc,
       sub],
    make = Stdlib_String[1],
    init$0 = Stdlib_String[2],
    empty = Stdlib_String[3],
    of_bytes = Stdlib_String[4],
    to_bytes = Stdlib_String[5],
    concat$0 = Stdlib_String[6],
    cat = Stdlib_String[7],
    equal$0 = Stdlib_String[8],
    compare$0 = Stdlib_String[9],
    starts_with = Stdlib_String[10],
    ends_with = Stdlib_String[11],
    contains_from = Stdlib_String[12],
    rcontains_from = Stdlib_String[13],
    contains = Stdlib_String[14],
    sub$0 = Stdlib_String[15],
    split_on_char = Stdlib_String[16],
    map$0 = Stdlib_String[17],
    mapi$0 = Stdlib_String[18],
    fold_left$0 = Stdlib_String[19],
    fold_right$0 = Stdlib_String[20],
    for_all$0 = Stdlib_String[21],
    exists$0 = Stdlib_String[22],
    trim = Stdlib_String[23],
    escaped = Stdlib_String[24],
    uppercase_ascii = Stdlib_String[25],
    lowercase_ascii = Stdlib_String[26],
    capitalize_ascii = Stdlib_String[27],
    uncapitalize_ascii = Stdlib_String[28],
    iter$0 = Stdlib_String[29],
    iteri$0 = Stdlib_String[30],
    index_from = Stdlib_String[31],
    index_from_opt = Stdlib_String[32],
    rindex_from = Stdlib_String[33],
    rindex_from_opt = Stdlib_String[34],
    index$0 = Stdlib_String[35],
    index_opt = Stdlib_String[36],
    rindex = Stdlib_String[37],
    rindex_opt = Stdlib_String[38],
    to_seq$0 = Stdlib_String[39],
    to_seqi = Stdlib_String[40],
    of_seq$0 = Stdlib_String[41],
    get_utf_8_uchar = Stdlib_String[42],
    is_valid_utf_8 = Stdlib_String[43],
    get_utf_16be_uchar = Stdlib_String[44],
    is_valid_utf_16be = Stdlib_String[45],
    get_utf_16le_uchar = Stdlib_String[46],
    is_valid_utf_16le = Stdlib_String[47],
    blit = Stdlib_String[48],
    get_uint8 = Stdlib_String[49],
    get_int8 = Stdlib_String[50],
    get_uint16_ne = Stdlib_String[51],
    get_uint16_be = Stdlib_String[52],
    get_uint16_le = Stdlib_String[53],
    get_int16_ne = Stdlib_String[54],
    get_int16_be = Stdlib_String[55],
    get_int16_le = Stdlib_String[56],
    get_int32_ne = Stdlib_String[57],
    hash = Stdlib_String[58],
    seeded_hash = Stdlib_String[59],
    get_int32_be = Stdlib_String[60],
    get_int32_le = Stdlib_String[61],
    get_int64_ne = Stdlib_String[62],
    get_int64_be = Stdlib_String[63],
    get_int64_le = Stdlib_String[64];
   function subscript(s){
    function _m_(s, param){
     var switcher = param - 48 | 0;
     if(9 < switcher >>> 0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     switch(switcher){
       case 0:
        return cst$0;
       case 1:
        return cst$1;
       case 2:
        return cst$2;
       case 3:
        return cst$3;
       case 4:
        return cst$4;
       case 5:
        return cst$5;
       case 6:
        return cst$6;
       case 7:
        return cst$7;
       case 8:
        return cst$8;
       default: return cst$9;
     }
    }
    return caml_call3(Stdlib_String[19], _m_, cst, s);
   }
   function superscript(s){
    function _l_(s, param){
     var switcher = param - 48 | 0;
     if(9 < switcher >>> 0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     switch(switcher){
       case 0:
        return cst$11;
       case 1:
        return cst$12;
       case 2:
        return cst$13;
       case 3:
        return cst$14;
       case 4:
        return cst$15;
       case 5:
        return cst$16;
       case 6:
        return cst$17;
       case 7:
        return cst$18;
       case 8:
        return cst$19;
       default: return cst$20;
     }
    }
    return caml_call3(Stdlib_String[19], _l_, cst$10, s);
   }
   function find$0(p, s){
    var ans = [0, -1];
    try{
     var _i_ = caml_ml_string_length(s) - 1 | 0, _h_ = 0;
     if(_i_ >= 0){
      var i = _h_;
      for(;;){
       if(caml_call1(p, runtime.caml_string_get(s, i))){
        ans[1] = i;
        throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       }
       var _j_ = i + 1 | 0;
       if(_i_ !== i){var i = _j_; continue;}
       break;
      }
     }
     throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    }
    catch(_k_){
     var _g_ = caml_wrap_exception(_k_);
     if(_g_ === Stdlib[3]) return ans[1];
     throw caml_maybe_attach_backtrace(_g_, 0);
    }
   }
   function split_on_predicate(p, s){
    try{
     var
      n = find$0(p, s),
      _d_ =
        split_on_predicate
         (p,
          caml_call3
           (Stdlib_String[15],
            s,
            n + 1 | 0,
            caml_ml_string_length(s) - (n + 1 | 0) | 0)),
      _e_ = [0, caml_call3(Stdlib_String[15], s, 0, n), _d_];
     return _e_;
    }
    catch(_f_){
     var _c_ = caml_wrap_exception(_f_);
     if(_c_ === Stdlib[8]) return [0, s, 0];
     throw caml_maybe_attach_backtrace(_c_, 0);
    }
   }
   var
    String =
      [0,
       make,
       init$0,
       empty,
       of_bytes,
       to_bytes,
       concat$0,
       cat,
       equal$0,
       compare$0,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub$0,
       split_on_char,
       map$0,
       mapi$0,
       fold_left$0,
       fold_right$0,
       for_all$0,
       exists$0,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter$0,
       iteri$0,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index$0,
       index_opt,
       rindex,
       rindex_opt,
       to_seq$0,
       to_seqi,
       of_seq$0,
       get_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       is_valid_utf_16le,
       blit,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       hash,
       seeded_hash,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       subscript,
       superscript,
       find$0,
       split_on_predicate],
    Alg_Extlib = [0, pair, unpair, Int, List, String];
   runtime.caml_register_global(29, Alg_Extlib, "Alg__Extlib");
   return;
  }
  (globalThis));

//# 781 "../../src/.alg.objs/jsoo/default/alg.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$4,
    cst$0 = cst$4,
    cst$3 = cst$4,
    cst$2 = "+",
    cst$1 = cst$4,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    cst_X = "X^",
    cst_T = "T",
    cst_F = "F";
   function eq(x, y){return x === y ? 1 : 0;}
   function add(x, y){
    var x$0 = x || y;
    if(x$0) var y$0 = x ? y : x, _V_ = 1 - y$0; else var _V_ = x$0;
    return _V_;
   }
   var zero = 0;
   function neg(x){return x;}
   function mul(x, y){var y$0 = x ? y : x; return y$0;}
   var one = 1;
   function to_string(x){return x ? cst_T : cst_F;}
   var Bool = [0, eq, add, zero, neg, mul, one, to_string];
   function eq$0(x, y){return x === y ? 1 : 0;}
   function add$0(_U_, _T_){return _U_ + _T_ | 0;}
   var zero$0 = 0;
   function neg$0(x){return - x | 0;}
   var
    mul$0 = runtime.caml_mul,
    to_string$0 = Stdlib[33],
    Int = [0, eq$0, add$0, zero$0, neg$0, mul$0, 1, to_string$0];
   function eq$1(x, y){return x == y ? 1 : 0;}
   function add$1(_S_, _R_){return _S_ + _R_;}
   var zero$1 = 0.;
   function neg$1(x){return - x;}
   function mul$1(_Q_, _P_){return _Q_ * _P_;}
   var
    to_string$1 = Stdlib[35],
    Float = [0, eq$1, add$1, zero$1, neg$1, mul$1, 1., to_string$1];
   function Polynomial(R){
    function length(p){return p.length - 1;}
    function degree(p){
     var ans = [0, 0];
     try{
      var _K_ = p.length - 1 - 1 | 0;
      if(_K_ >= 0){
       var i = _K_;
       for(;;){
        var _M_ = caml_check_bound(p, i)[1 + i];
        if(1 - caml_call2(R[1], R[3], _M_)){
         ans[1] = i;
         throw caml_maybe_attach_backtrace(Stdlib[3], 1);
        }
        var _N_ = i - 1 | 0;
        if(0 !== i){var i = _N_; continue;}
        break;
       }
      }
      var _L_ = Stdlib[20];
      return _L_;
     }
     catch(_O_){
      var _J_ = caml_wrap_exception(_O_);
      if(_J_ === Stdlib[3]) return ans[1];
      throw caml_maybe_attach_backtrace(_J_, 0);
     }
    }
    function eq(p, q){
     var dp = degree(p), dq = degree(q);
     try{
      if(dp !== dq) throw caml_maybe_attach_backtrace(Stdlib[3], 1);
      var _D_ = dp - 1 | 0, _C_ = 0;
      if(_D_ >= 0){
       var i = _C_;
       for(;;){
        var
         _F_ = caml_check_bound(q, i)[1 + i],
         _G_ = caml_check_bound(p, i)[1 + i];
        if(1 - caml_call2(R[1], _G_, _F_))
         throw caml_maybe_attach_backtrace(Stdlib[3], 1);
        var _H_ = i + 1 | 0;
        if(_D_ !== i){var i = _H_; continue;}
        break;
       }
      }
      var _E_ = 1;
      return _E_;
     }
     catch(_I_){
      var _B_ = caml_wrap_exception(_I_);
      if(_B_ === Stdlib[3]) return 0;
      throw caml_maybe_attach_backtrace(_B_, 0);
     }
    }
    function compact(p){
     function _z_(i){return caml_check_bound(p, i)[1 + i];}
     var _A_ = degree(p);
     return caml_call2(Stdlib_Array[1], _A_, _z_);
    }
    function coeff(p, i){
     return i < p.length - 1 ? caml_check_bound(p, i)[1 + i] : R[3];
    }
    function init(n, f){return caml_call2(Stdlib_Array[1], n, f);}
    function add(p, q){
     var p$0 = p, q$0 = q;
     for(;;){
      var pl = p$0.length - 1, ql = q$0.length - 1;
      if(ql >= pl)
       return init
               (ql,
                function(i){
                 if(i >= pl) return caml_check_bound(q$0, i)[1 + i];
                 var
                  _x_ = caml_check_bound(q$0, i)[1 + i],
                  _y_ = caml_check_bound(p$0, i)[1 + i];
                 return caml_call2(R[2], _y_, _x_);
                });
      var _w_ = q$0, q$0 = p$0, p$0 = _w_;
     }
    }
    var zero = [0];
    function cmul(a, p){
     var _v_ = caml_call1(R[5], a);
     return caml_call2(Stdlib_Array[13], _v_, p);
    }
    function neg(p){return cmul(caml_call1(R[4], R[6]), p);}
    function sub(p, q){return add(p, neg(q));}
    function mul(p, q){
     function _o_(n){
      var ans = [0, R[3]], _q_ = 0;
      if(n >= 0){
       var i = _q_;
       for(;;){
        var
         _r_ = coeff(q, n - i | 0),
         _s_ = coeff(p, i),
         _t_ = caml_call2(R[5], _s_, _r_);
        ans[1] = caml_call2(R[2], ans[1], _t_);
        var _u_ = i + 1 | 0;
        if(n !== i){var i = _u_; continue;}
        break;
       }
      }
      return ans[1];
     }
     var _p_ = degree(q);
     return init(degree(p) + _p_ | 0, _o_);
    }
    var one = [0, R[6]];
    function to_string(p){
     var ans = [0, cst], _e_ = p.length - 1 - 1 | 0, _d_ = 0;
     if(_e_ >= 0){
      var i = _d_;
      for(;;){
       var _f_ = caml_check_bound(p, i)[1 + i];
       if(caml_call2(R[1], R[3], _f_))
        var _g_ = cst$0;
       else{
        if(0 === i)
         var _k_ = cst$3;
        else
         var
          _n_ = caml_call1(Stdlib[33], i),
          _k_ = caml_call2(Stdlib[28], cst_X, _n_);
        var
         _l_ = caml_check_bound(p, i)[1 + i],
         _m_ = caml_call1(R[7], _l_),
         _g_ = caml_call2(Stdlib[28], _m_, _k_);
       }
       var
        _h_ = 0 === i ? cst$1 : cst$2,
        _i_ = caml_call2(Stdlib[28], _h_, _g_);
       ans[1] = caml_call2(Stdlib[28], ans[1], _i_);
       var _j_ = i + 1 | 0;
       if(_e_ !== i){var i = _j_; continue;}
       break;
      }
     }
     return ans[1];
    }
    function monomial(c, n){
     var ans = runtime.caml_make_vect(n + 1 | 0, R[3]);
     caml_check_bound(ans, n)[1 + n] = c;
     return ans;
    }
    return [0,
            length,
            degree,
            eq,
            compact,
            coeff,
            init,
            add,
            zero,
            cmul,
            neg,
            sub,
            mul,
            one,
            to_string,
            monomial];
   }
   function PolynomialRing(_b_){
    var _c_ = Polynomial(_b_);
    return [0, _c_[3], _c_[7], _c_[8], _c_[10], _c_[12], _c_[13], _c_[14]];
   }
   function Op(R){
    var
     eq = R[1],
     add = R[2],
     zero = R[3],
     neg = R[4],
     one = R[6],
     to_string = R[7],
     _a_ = R[5];
    function mul(x, y){return caml_call2(_a_, y, x);}
    return [0, eq, add, zero, neg, mul, one, to_string];
   }
   var Alg_Ring = [0, Bool, Int, Float, Polynomial, PolynomialRing, Op];
   runtime.caml_register_global(12, Alg_Ring, "Alg__Ring");
   return;
  }
  (globalThis));

//# 1290 "../../src/.alg.objs/jsoo/default/alg.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$8 = "",
    cst$9 = ", ",
    cst_src_monoid_ml = "src/monoid.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$7 = cst$8,
    cst$6 = cst$8,
    cst$4 = cst$9,
    cst$5 = cst$9,
    cst$1 = "]",
    cst$2 = "|",
    cst$3 = "[",
    cst = "\xce\xb5",
    cst$0 = cst$8,
    Alg_Extlib = global_data.Alg__Extlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib = global_data.Stdlib,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Array = global_data.Stdlib__Array,
    _f_ = [0, cst_src_monoid_ml, 529, 13],
    _d_ = [0, [2, 0, [11, " -> ", [2, 0, 0]]], "%s -> %s"],
    _e_ =
      [0,
       [11, "< ", [2, 0, [11, " | ", [2, 0, [11, " >", 0]]]]],
       "< %s | %s >"],
    _c_ = [0, cst_src_monoid_ml, 288, 24],
    _b_ = [0, cst_src_monoid_ml, 178, 57],
    _a_ = [0, cst_src_monoid_ml, 51, 11];
   function ToAdditive(M){
    if(! M[7]) throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var eq = M[1], compare = M[6], add = M[2], zero = M[3], to_string = M[5];
    return [0, eq, compare, add, zero, to_string];
   }
   function simple_pow(one, mul, u, n){
    var ans = [0, one], _bv_ = 1;
    if(n >= 1){
     var for$0 = _bv_;
     for(;;){
      ans[1] = caml_call2(mul, ans[1], u);
      var _bw_ = for$0 + 1 | 0;
      if(n !== for$0){var for$0 = _bw_; continue;}
      break;
     }
    }
    return ans[1];
   }
   function Free(X){
    var is_commutative = 0;
    function mul(u, v){return caml_call2(Stdlib_Array[3], u, v);}
    var one = [0];
    function pow(u, n){return simple_pow(one, mul, u, n);}
    function inj(a){return [0, a];}
    function length(u){return u.length - 1;}
    function sub(u, o, l){return caml_call3(Stdlib_Array[5], u, o, l);}
    function eq(u, v){
     var ul = u.length - 1, vl = v.length - 1;
     if(ul !== vl) return 0;
     try{
      var _bp_ = ul - 1 | 0, _bo_ = 0;
      if(_bp_ >= 0){
       var i = _bo_;
       for(;;){
        var
         _br_ = caml_check_bound(v, i)[1 + i],
         _bs_ = caml_check_bound(u, i)[1 + i];
        if(1 - caml_call2(X[1], _bs_, _br_))
         throw caml_maybe_attach_backtrace(Stdlib[3], 1);
        var _bt_ = i + 1 | 0;
        if(_bp_ !== i){var i = _bt_; continue;}
        break;
       }
      }
      var _bq_ = 1;
      return _bq_;
     }
     catch(_bu_){
      var _bn_ = caml_wrap_exception(_bu_);
      if(_bn_ === Stdlib[3]) return 0;
      throw caml_maybe_attach_backtrace(_bn_, 0);
     }
    }
    function compare(u, v){
     var ul = u.length - 1, vl = v.length - 1, ans = [0, 0];
     try{
      var _bh_ = caml_call2(Stdlib[16], ul, vl) - 1 | 0, _bg_ = 0;
      if(_bh_ >= 0){
       var i = _bg_;
       for(;;){
        var
         _bj_ = caml_check_bound(v, i)[1 + i],
         _bk_ = caml_check_bound(u, i)[1 + i],
         c = caml_call2(X[3], _bk_, _bj_);
        if(0 !== c){
         ans[1] = c;
         throw caml_maybe_attach_backtrace(Stdlib[3], 1);
        }
        var _bl_ = i + 1 | 0;
        if(_bh_ !== i){var i = _bl_; continue;}
        break;
       }
      }
      var _bi_ = ul - vl | 0;
      return _bi_;
     }
     catch(_bm_){
      var _bf_ = caml_wrap_exception(_bm_);
      if(_bf_ === Stdlib[3]) return ans[1];
      throw caml_maybe_attach_backtrace(_bf_, 0);
     }
    }
    function peq(u, uoff, v, voff, len){
     try{
      var _a9_ = len - 1 | 0, _a8_ = 0;
      if(_a9_ >= 0){
       var i = _a8_;
       for(;;){
        var
         _a$_ = voff + i | 0,
         _bb_ = uoff + i | 0,
         _ba_ = caml_check_bound(v, _a$_)[1 + _a$_],
         _bc_ = caml_check_bound(u, _bb_)[1 + _bb_];
        if(1 - caml_call2(X[1], _bc_, _ba_))
         throw caml_maybe_attach_backtrace(Stdlib[3], 1);
        var _bd_ = i + 1 | 0;
        if(_a9_ !== i){var i = _bd_; continue;}
        break;
       }
      }
      var _a__ = 1;
      return _a__;
     }
     catch(_be_){
      var _a7_ = caml_wrap_exception(_be_);
      if(_a7_ === Stdlib[3]) return 0;
      throw caml_maybe_attach_backtrace(_a7_, 0);
     }
    }
    function to_string(u){
     if(eq(one, u)) return cst;
     var
      u$0 = caml_call1(Stdlib_Array[9], u),
      u$1 = caml_call2(Alg_Extlib[4][19], X[2], u$0);
     return caml_call2(Alg_Extlib[5][6], cst$0, u$1);
    }
    function Map(M){
     var E = caml_call1(Stdlib_Map[1], [0, X[3]]);
     function of_list(l){
      var _a6_ = caml_call1(Alg_Extlib[4][61], l);
      return caml_call1(E[40], _a6_);
     }
     function app(f, x){return caml_call2(E[28], x, f);}
     function bind(f, u){
      var _a3_ = M[3];
      function _a4_(y, x){
       var _a5_ = app(f, x);
       return caml_call2(M[2], y, _a5_);
      }
      return caml_call3(Stdlib_Array[15], _a4_, _a3_, u);
     }
     return [0, E, of_list, app, bind];
    }
    function included(u, v){
     var ul = u.length - 1, vl = v.length - 1;
     try{
      var _aZ_ = vl - ul | 0, _aY_ = 0;
      if(_aZ_ >= 0){
       var i = _aY_;
       for(;;){
        if(peq(u, 0, v, i, ul))
         throw caml_maybe_attach_backtrace(Stdlib[3], 1);
        var _a1_ = i + 1 | 0;
        if(_aZ_ !== i){var i = _a1_; continue;}
        break;
       }
      }
      var _a0_ = 0;
      return _a0_;
     }
     catch(_a2_){
      var _aX_ = caml_wrap_exception(_a2_);
      if(_aX_ === Stdlib[3]) return 1;
      throw caml_maybe_attach_backtrace(_aX_, 0);
     }
    }
    function unifier(opt, u, v){
     if(opt) var sth = opt[1], i = sth; else var i = 0;
     var ul = u.length - 1, vl = v.length - 1, ans = [0, 0];
     try{
      var _aU_ = ul - 1 | 0;
      if(_aU_ >= i){
       var i$0 = i;
       for(;;){
        if(peq(u, i$0, v, 0, caml_call2(Stdlib[16], ul - i$0 | 0, vl))){
         ans[1] = [0, i$0];
         throw caml_maybe_attach_backtrace(Stdlib[3], 1);
        }
        var _aV_ = i$0 + 1 | 0;
        if(_aU_ !== i$0){var i$0 = _aV_; continue;}
        break;
       }
      }
      throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     }
     catch(_aW_){
      var _aT_ = caml_wrap_exception(_aW_);
      if(_aT_ !== Stdlib[3]) throw caml_maybe_attach_backtrace(_aT_, 0);
      var match = ans[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
      var ans$0 = match[1];
      return ans$0;
     }
    }
    function ordered_unifiers(u, v){
     var ans = [0, 0], i = [0, 0];
     try{
      for(;;){
       var j = unifier([0, i[1]], u, v);
       ans[1] = [0, j, ans[1]];
       i[1] = j + 1 | 0;
      }
     }
     catch(_aS_){
      var _aR_ = caml_wrap_exception(_aS_);
      if(_aR_ === Stdlib[8]) return ans[1];
      throw caml_maybe_attach_backtrace(_aR_, 0);
     }
    }
    function ordered_unifiers_bicontext(u, v){
     var lu = u.length - 1, lv = v.length - 1, l = ordered_unifiers(u, v);
     function _aO_(i){
      if((i + lv | 0) <= lu){
       var _aP_ = sub(u, i + lv | 0, lu - (i + lv | 0) | 0);
       return [0, [0, one, one], [0, sub(u, 0, i), _aP_]];
      }
      var _aQ_ = [0, sub(u, 0, i), one];
      return [0, [0, one, sub(v, lu - i | 0, lv - (lu - i | 0) | 0)], _aQ_];
     }
     return caml_call2(Alg_Extlib[4][19], _aO_, l);
    }
    function unifiers_bicontext(u, v){
     var
      l = ordered_unifiers_bicontext(u, v),
      l$0 = ordered_unifiers_bicontext(v, u);
     function _aN_(param){var d = param[2], c = param[1]; return [0, d, c];}
     var l$1 = caml_call2(Alg_Extlib[4][19], _aN_, l$0);
     return caml_call2(Stdlib[37], l, l$1);
    }
    function lexicographic(leq, u, v){
     var ul = u.length - 1, vl = v.length - 1, ans = [0, 1];
     try{
      var _aG_ = caml_call2(Stdlib[16], ul, vl) - 1 | 0, _aF_ = 0;
      if(_aG_ >= 0){
       var i = _aF_;
       for(;;){
        var _aI_ = caml_check_bound(v, i)[1 + i];
        if(! caml_call2(leq, caml_check_bound(u, i)[1 + i], _aI_)){
         ans[1] = 0;
         throw caml_maybe_attach_backtrace(Stdlib[3], 1);
        }
        var
         _aJ_ = caml_check_bound(v, i)[1 + i],
         _aK_ = caml_check_bound(u, i)[1 + i];
        if(1 - caml_call2(X[1], _aK_, _aJ_))
         throw caml_maybe_attach_backtrace(Stdlib[3], 1);
        var _aL_ = i + 1 | 0;
        if(_aG_ !== i){var i = _aL_; continue;}
        break;
       }
      }
      var _aH_ = ul <= vl ? 1 : 0;
      return _aH_;
     }
     catch(_aM_){
      var _aE_ = caml_wrap_exception(_aM_);
      if(_aE_ === Stdlib[3]) return ans[1];
      throw caml_maybe_attach_backtrace(_aE_, 0);
     }
    }
    function deglex(leq, u, v){
     var ul = u.length - 1, vl = v.length - 1;
     return ul < vl ? 1 : vl < ul ? 0 : lexicographic(leq, u, v);
    }
    var Order = [0, lexicographic, deglex], empty = 0;
    function singleton(a){return [0, [0, a], 0];}
    function singletons(l){
     return caml_call2(Alg_Extlib[4][19], singleton, l);
    }
    function hd(l){return caml_call1(Alg_Extlib[4][5], l);}
    function tl(l){return caml_call1(Alg_Extlib[4][6], l);}
    function eq$0(c, d){
     var c$0 = c, d$0 = d;
     for(;;){
      if(! c$0) return d$0 ? 0 : 1;
      if(! d$0) return 0;
      var d$1 = d$0[2], v = d$0[1], c$1 = c$0[2], u = c$0[1], _aD_ = eq(u, v);
      if(! _aD_) return _aD_;
      var c$0 = c$1, d$0 = d$1;
     }
    }
    function compare$0(c, d){
     var c$0 = c, d$0 = d;
     for(;;){
      if(! c$0) return d$0 ? -1 : 0;
      if(! d$0) return 1;
      var
       d$1 = d$0[2],
       v = d$0[1],
       c$1 = c$0[2],
       u = c$0[1],
       cmp = compare(u, v);
      if(0 !== cmp) return cmp;
      var c$0 = c$1, d$0 = d$1;
     }
    }
    function extend(l, cc){
     function _av_(c$0){
      if(c$0){
       var u = c$0[1], len = u.length - 1;
       if(len){
        var c = c$0[2], ul = u.length - 1, ans = [0, 0], l1 = 0, param = l;
        for(;;){
         if(! param) return ans[1];
         var
          l2 = param[2],
          x = param[1],
          vl = x.length - 1,
          _ax_ = caml_call2(Stdlib[17], ul - vl | 0, 0),
          _ay_ = ul - 1 | 0;
         if(_ay_ >= _ax_){
          var i = _ax_;
          for(;;){
           try{
            if(1 - peq(u, i, x, 0, ul - i | 0))
             throw caml_maybe_attach_backtrace(Stdlib[3], 1);
            var
             i$0 = ul - i | 0,
             v = sub(x, i$0, vl - i$0 | 0),
             w = mul(u, v),
             f$0 =
               function(w){
                function f(u){
                 var _aC_ = included(u, w);
                 if(_aC_) throw caml_maybe_attach_backtrace(Stdlib[3], 1);
                 return _aC_;
                }
                return f;
               },
             f = f$0(w);
            caml_call2(Alg_Extlib[4][17], f, l1);
            caml_call2(Alg_Extlib[4][17], f, l2);
            if(included(x, sub(w, 0, w.length - 1 - 1 | 0)))
             throw caml_maybe_attach_backtrace(Stdlib[3], 1);
            ans[1] = [0, [0, v, [0, u, c]], ans[1]];
           }
           catch(_aB_){
            var _az_ = caml_wrap_exception(_aB_);
            if(_az_ !== Stdlib[3]) throw caml_maybe_attach_backtrace(_az_, 0);
           }
           var _aA_ = i + 1 | 0;
           if(_ay_ !== i){var i = _aA_; continue;}
           break;
          }
         }
         var h = [0, x, l1], l1 = h, param = l2;
        }
       }
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     }
     var _aw_ = caml_call2(Alg_Extlib[4][19], _av_, cc);
     return caml_call1(Alg_Extlib[4][13], _aw_);
    }
    function eval$0(l){
     var _au_ = caml_call1(Alg_Extlib[4][9], l);
     return caml_call3(Alg_Extlib[4][25], mul, one, _au_);
    }
    function length$0(l){return caml_call1(Alg_Extlib[4][1], l);}
    function to_string$0(c){
     var
      _aq_ = caml_call1(Alg_Extlib[4][9], c),
      _ar_ = caml_call2(Alg_Extlib[4][19], to_string, _aq_),
      _as_ = caml_call2(Alg_Extlib[5][6], cst$2, _ar_),
      _at_ = caml_call2(Stdlib[28], _as_, cst$1);
     return caml_call2(Stdlib[28], cst$3, _at_);
    }
    var
     Anick =
       [0,
        empty,
        singleton,
        singletons,
        hd,
        tl,
        eq,
        eq$0,
        compare$0,
        extend,
        eval$0,
        length$0,
        to_string$0];
    return [0,
            is_commutative,
            mul,
            one,
            pow,
            inj,
            length,
            sub,
            eq,
            compare,
            peq,
            to_string,
            Map,
            included,
            unifier,
            ordered_unifiers,
            ordered_unifiers_bicontext,
            unifiers_bicontext,
            Order,
            Anick];
   }
   function FreeMonoid(_ao_){
    var _ap_ = Free(_ao_);
    return [0, _ap_[8], _ap_[2], _ap_[3], _ap_[4], _ap_[11], _ap_[9], _ap_[1]];
   }
   function Pres(X){
    var W = Free(X);
    function make(generators, rules){return [0, generators, rules];}
    function to_string(pres){
     var _ag_ = pres[2];
     function _ah_(param){
      var
       v = param[2],
       u = param[1],
       _am_ = caml_call1(W[11], v),
       _an_ = caml_call1(W[11], u);
      return caml_call3(Stdlib_Printf[4], _d_, _an_, _am_);
     }
     var
      _ai_ = caml_call2(Alg_Extlib[4][19], _ah_, _ag_),
      _aj_ = caml_call1(caml_call1(Alg_Extlib[5][6], cst$4), _ai_),
      _ak_ = caml_call2(Alg_Extlib[4][19], X[2], pres[1]),
      _al_ = caml_call1(caml_call1(Alg_Extlib[5][6], cst$5), _ak_);
     return caml_call3(Stdlib_Printf[4], _e_, _al_, _aj_);
    }
    function orient(leq, pres){
     var _ae_ = pres[2];
     function _af_(param){
      var v = param[2], u = param[1];
      return caml_call2(leq, v, u) ? [0, u, v] : [0, v, u];
     }
     var rules = caml_call2(Alg_Extlib[4][19], _af_, _ae_);
     return [0, pres[1], rules];
    }
    function normalize(pres, u){
     try{
      var
       _Y_ = pres[2],
       _Z_ =
         function(param){var v = param[1]; return caml_call2(W[13], v, u);},
       match = caml_call2(Alg_Extlib[4][38], _Z_, _Y_),
       v = match[2],
       v$0 = match[1],
       i = caml_call3(W[14], 0, u, v$0),
       v1 = caml_call3(W[7], u, 0, i),
       ___ = i + caml_call1(W[6], v$0) | 0,
       _$_ = caml_call1(W[6], u) - ___ | 0,
       _aa_ = i + caml_call1(W[6], v$0) | 0,
       v2 = caml_call3(W[7], u, _aa_, _$_),
       _ab_ = caml_call2(W[2], v, v2),
       _ac_ = normalize(pres, caml_call2(W[2], v1, _ab_));
      return _ac_;
     }
     catch(_ad_){
      var _X_ = caml_wrap_exception(_ad_);
      if(_X_ === Stdlib[8]) return u;
      throw caml_maybe_attach_backtrace(_X_, 0);
     }
    }
    function add_rule(pres, param){
     var v = param[2], u = param[1];
     return [0, pres[1], [0, [0, u, v], pres[2]]];
    }
    function reduce(pres){
     var _U_ = pres[2];
     function _V_(param){
      var v = param[2], u = param[1];
      return [0, u, normalize(pres, v)];
     }
     var
      rules = caml_call2(Alg_Extlib[4][19], _V_, _U_),
      h = 0,
      param = rules;
     for(;;){
      if(! param){
       var rules$0 = caml_call1(Alg_Extlib[4][9], h);
       return [0, pres[1], rules$0];
      }
      var
       t = param[2],
       match = param[1],
       v = match[2],
       u = match[1],
       f$0 =
         function(u){
          function f(l){
           function _W_(param){
            var u$0 = param[1];
            return caml_call2(W[13], u$0, u);
           }
           return caml_call2(Alg_Extlib[4][33], _W_, l);
          }
          return f;
         },
       f = f$0(u);
      if(! f(h) && ! f(t)){
       var h$0 = [0, [0, u, v], h], h = h$0, param = t;
       continue;
      }
      var param = t;
     }
    }
    function complete(leq, pres){
     var
      pres$0 = orient(leq, pres),
      todo = caml_call1(Stdlib_Queue[2], 0),
      _K_ = pres$0[2];
     function _L_(r){return caml_call2(Stdlib_Queue[3], r, todo);}
     caml_call2(Alg_Extlib[4][17], _L_, _K_);
     var pres$1 = [0, pres$0];
     for(;;){
      if(caml_call1(Stdlib_Queue[13], todo)) return pres$1[1];
      var
       match = caml_call1(Stdlib_Queue[7], todo),
       u = match[2],
       u$0 = match[1],
       _M_ = pres$1[1][2],
       _N_ =
         function(u, u$0){
           return function(param){
            var
             v = param[2],
             v$0 = param[1],
             _O_ = caml_call2(W[17], u$0, v$0);
            function _P_(param){
             var
              _R_ = param[2],
              v2 = _R_[2],
              v1 = _R_[1],
              match = param[1],
              u2 = match[2],
              u1 = match[1],
              _S_ = caml_call2(W[2], u, u2),
              s1 = caml_call2(W[2], u1, _S_),
              _T_ = caml_call2(W[2], v, v2),
              s2 = caml_call2(W[2], v1, _T_),
              u$0 = normalize(pres$1[1], s1),
              v$0 = normalize(pres$1[1], s2),
              _Q_ = 1 - caml_call2(W[8], u$0, v$0);
             if(! _Q_) return _Q_;
             if(caml_call2(leq, v$0, u$0))
              var v$1 = v$0, u$1 = u$0;
             else
              var v$1 = u$0, u$1 = v$0;
             pres$1[1] = add_rule(pres$1[1], [0, u$1, v$1]);
             return caml_call2(Stdlib_Queue[4], [0, u$1, v$1], todo);
            }
            return caml_call2(Alg_Extlib[4][17], _P_, _O_);};
          }
          (u, u$0);
      caml_call2(Alg_Extlib[4][17], _N_, _M_);
     }
    }
    function Make(P){
     var p = P[1];
     function nf(_J_){return normalize(p, _J_);}
     var
      mul = W[2],
      one = W[3],
      pow = W[4],
      to_string = W[11],
      is_commutative = 0;
     function compare(u, v){
      var _H_ = nf(v), _I_ = nf(u);
      return caml_call2(W[9], _I_, _H_);
     }
     function eq(u, v){
      var _F_ = nf(v), _G_ = nf(u);
      return caml_call2(W[8], _G_, _F_);
     }
     return [0, eq, mul, one, pow, to_string, compare, is_commutative];
    }
    return [0,
            W,
            make,
            to_string,
            orient,
            normalize,
            add_rule,
            reduce,
            complete,
            Make];
   }
   function Generate(X){
    var Pres$0 = Pres(X);
    function intset(n){
     function aux(k){return n <= k ? 0 : [0, k, aux(k + 1 | 0)];}
     return aux(0);
    }
    return [0, Pres$0, intset];
   }
   function Multisets(X){
    var is_commutative = 1;
    function to_string(u){
     function _B_(s, param){
      var n = param[2], x = param[1];
      if(0 === n) return s;
      if(1 === n)
       var n$0 = cst$7;
      else
       var
        _E_ = caml_call1(Stdlib[33], n),
        n$0 = caml_call1(Alg_Extlib[5][66], _E_);
      var _C_ = caml_call1(X[2], x), _D_ = caml_call2(Stdlib[28], _C_, n$0);
      return caml_call2(Stdlib[28], s, _D_);
     }
     return caml_call3(Alg_Extlib[4][25], _B_, cst$6, u);
    }
    var empty = 0;
    function union(d$0, d){
     var _A_ = caml_call2(Stdlib[37], d$0, d);
     return caml_call1(caml_call1(Alg_Extlib[4][59], X[3]), _A_);
    }
    var Domain = [0, empty, union];
    function domain(u){
     function _z_(param){
      var n = param[2], x = param[1];
      return 0 < n ? [0, x] : 0;
     }
     return caml_call2(Alg_Extlib[4][22], _z_, u);
    }
    function occurrences(x, u){
     var match = caml_call2(Alg_Extlib[4][47], x, u);
     if(! match) return 0;
     var n = match[1];
     return n;
    }
    var one = 0;
    function mul(u, v){
     var
      _v_ = domain(v),
      _w_ = domain(u),
      d = caml_call2(Domain[2], _w_, _v_);
     function _x_(x){
      var _y_ = occurrences(x, v);
      return [0, x, occurrences(x, u) + _y_ | 0];
     }
     return caml_call2(Alg_Extlib[4][19], _x_, d);
    }
    function pow(u, n){
     function _u_(param){
      var m = param[2], x = param[1];
      return [0, x, caml_mul(m, n)];
     }
     return caml_call2(Alg_Extlib[4][19], _u_, u);
    }
    function included(u, v){
     function _t_(param){
      var n = param[2], x = param[1];
      return n <= occurrences(x, v) ? 1 : 0;
     }
     return caml_call2(Alg_Extlib[4][32], _t_, u);
    }
    function eq(u, v){
     var _s_ = included(u, v);
     return _s_ ? included(v, u) : _s_;
    }
    function normalize(u){
     function _p_(param){var n = param[2]; return 0 !== n ? 1 : 0;}
     var u$0 = caml_call2(Alg_Extlib[4][41], _p_, u);
     function _q_(param, _r_){
      var
       m = _r_[2],
       y = _r_[1],
       n = param[2],
       x = param[1],
       c = caml_call2(X[3], x, y);
      return 0 === c ? n - m | 0 : c;
     }
     return caml_call2(Alg_Extlib[4][56], _q_, u$0);
    }
    function compare(u, v){
     var u$0 = normalize(u), v$0 = normalize(v), u$1 = u$0, v$1 = v$0;
     for(;;){
      if(! u$1) return v$1 ? -1 : 0;
      var u$2 = u$1[2], _o_ = u$1[1], n = _o_[2], x = _o_[1];
      if(! v$1) return 1;
      var
       v$2 = v$1[2],
       match = v$1[1],
       m = match[2],
       y = match[1],
       c = caml_call2(X[3], x, y);
      if(0 !== c) return c;
      var c$0 = n - m | 0;
      if(0 !== c$0) return c$0;
      var u$1 = u$2, v$1 = v$2;
     }
    }
    function inj(x){return [0, [0, x, 1], 0];}
    function cmul(n, u){
     function _n_(param){
      var m = param[2], x = param[1];
      return [0, x, caml_mul(m, n)];
     }
     return caml_call2(Alg_Extlib[4][19], _n_, u);
    }
    function Map(M){
     if(! M[7])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     var E = caml_call1(Stdlib_Map[1], [0, X[3]]);
     function of_list(l){
      var _m_ = caml_call1(Alg_Extlib[4][61], l);
      return caml_call1(E[40], _m_);
     }
     function app(f, x){return caml_call2(E[28], x, f);}
     function bind(f, u){
      var _i_ = M[3];
      function _j_(v, param){
       var
        n = param[2],
        x = param[1],
        _k_ = app(f, x),
        _l_ = caml_call2(M[4], _k_, n);
       return caml_call2(M[2], v, _l_);
      }
      return caml_call3(Alg_Extlib[4][25], _j_, _i_, u);
     }
     return [0, E, of_list, app, bind];
    }
    return [0,
            is_commutative,
            to_string,
            Domain,
            domain,
            occurrences,
            one,
            mul,
            pow,
            included,
            eq,
            normalize,
            compare,
            inj,
            cmul,
            Map];
   }
   function MultisetsMonoid(_g_){
    var _h_ = Multisets(_g_);
    return [0, _h_[10], _h_[7], _h_[6], _h_[8], _h_[2], _h_[12], _h_[1]];
   }
   function Alphabet(M){
    var eq = M[1], to_string = M[5], compare = M[6];
    return [0, eq, to_string, compare];
   }
   var
    Alg_Monoid =
      [0,
       ToAdditive,
       simple_pow,
       Free,
       FreeMonoid,
       Pres,
       Generate,
       Multisets,
       MultisetsMonoid,
       Alphabet];
   runtime.caml_register_global(23, Alg_Monoid, "Alg__Monoid");
   return;
  }
  (globalThis));

//# 2110 "../../src/.alg.objs/jsoo/default/alg.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_matrix_ml = "src/matrix.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    cst$1 = " ",
    cst$0 = "\n",
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Array = global_data.Stdlib__Array,
    _b_ = [0, cst_src_matrix_ml, 60, 6],
    _a_ = [0, cst_src_matrix_ml, 54, 6];
   function Make(R){
    function zero(r, c){
     function _ag_(param){return runtime.caml_make_vect(c, R[3]);}
     return caml_call2(Stdlib_Array[1], r, _ag_);
    }
    function init(r, c, f){
     function _ae_(i){
      function _af_(j){return caml_call2(f, i, j);}
      return caml_call2(Stdlib_Array[1], c, _af_);
     }
     return caml_call2(Stdlib_Array[1], r, _ae_);
    }
    function rows(m){return m.length - 1;}
    function cols(m){return caml_check_bound(m, 0)[1].length - 1;}
    function get(m, i, j){
     return caml_check_bound(caml_check_bound(m, i)[1 + i], j)[1 + j];
    }
    function to_string(m){
     var ans = [0, cst], _Z_ = m.length - 1 - 1 | 0, _Y_ = 0;
     if(_Z_ >= 0){
      var i = _Y_;
      for(;;){
       var _$_ = cols(m) - 1 | 0, ___ = 0;
       if(_$_ >= 0){
        var j = ___;
        for(;;){
         if(0 !== j) ans[1] = caml_call2(Stdlib[28], ans[1], cst$1);
         var
          _ab_ = caml_check_bound(caml_check_bound(m, i)[1 + i], j)[1 + j],
          _ac_ = caml_call1(R[7], _ab_);
         ans[1] = caml_call2(Stdlib[28], ans[1], _ac_);
         var _ad_ = j + 1 | 0;
         if(_$_ !== j){var j = _ad_; continue;}
         break;
        }
       }
       ans[1] = caml_call2(Stdlib[28], ans[1], cst$0);
       var _aa_ = i + 1 | 0;
       if(_Z_ !== i){var i = _aa_; continue;}
       break;
      }
     }
     return ans[1];
    }
    function is_zero(m, i){
     var _W_ = caml_check_bound(m, i)[1 + i], _X_ = caml_call1(R[1], R[3]);
     return caml_call2(Stdlib_Array[20], _X_, _W_);
    }
    function replace(m, i, mi){
     function _V_(k){return k === i ? mi : caml_check_bound(m, k)[1 + k];}
     return caml_call2(Stdlib_Array[1], m.length - 1, _V_);
    }
    function exchange(m, i, j){
     function _U_(k){
      return k === i
              ? caml_check_bound(m, j)[1 + j]
              : k
                === j
                ? caml_check_bound(m, i)[1 + i]
                : caml_check_bound(m, k)[1 + k];
     }
     return caml_call2(Stdlib_Array[1], m.length - 1, _U_);
    }
    function mult(m, q, i){
     if(caml_call2(R[1], R[3], q))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     function _R_(k){
      var _T_ = caml_check_bound(caml_check_bound(m, i)[1 + i], k)[1 + k];
      return caml_call2(R[5], q, _T_);
     }
     var _S_ = cols(m), mi = caml_call2(Stdlib_Array[1], _S_, _R_);
     return replace(m, i, mi);
    }
    function madd(m, i, q, j){
     if(i === j)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     function _M_(k){
      var
       _O_ = caml_check_bound(caml_check_bound(m, j)[1 + j], k)[1 + k],
       _P_ = caml_call2(R[5], q, _O_),
       _Q_ = caml_check_bound(caml_check_bound(m, i)[1 + i], k)[1 + k];
      return caml_call2(R[2], _Q_, _P_);
     }
     var _N_ = cols(m), mi = caml_call2(Stdlib_Array[1], _N_, _M_);
     return replace(m, i, mi);
    }
    var Row = [0, is_zero, replace, exchange, mult, madd];
    function row_echelon(m){
     var
      m$0 = [0, m],
      ip = [0, 0],
      cols$0 = 0 === m$0[1].length - 1 ? 0 : cols(m$0[1]);
     try{
      var _v_ = cols$0 - 1 | 0, _u_ = 0;
      if(_v_ >= 0){
       var j = _u_;
       for(;;){
        if(m$0[1].length - 1 <= ip[1])
         throw caml_maybe_attach_backtrace(Stdlib[3], 1);
        var
         _x_ = ip[1],
         _y_ =
           caml_check_bound(caml_check_bound(m$0[1], _x_)[1 + _x_], j)[1 + j];
        if(caml_call2(R[1], R[3], _y_))
         try{
          var _G_ = ip[1] + 1 | 0, _H_ = m$0[1].length - 1 - 1 | 0;
          if(_H_ >= _G_){
           var i$0 = _G_;
           for(;;){
            var
             _I_ =
               caml_check_bound(caml_check_bound(m$0[1], i$0)[1 + i$0], j)
                [1 + j];
            if(1 - caml_call2(R[1], R[3], _I_)){
             m$0[1] = caml_call3(Row[3], m$0[1], ip[1], i$0);
             throw caml_maybe_attach_backtrace(Stdlib[3], 1);
            }
            var _J_ = i$0 + 1 | 0;
            if(_H_ !== i$0){var i$0 = _J_; continue;}
            break;
           }
          }
         }
         catch(_L_){
          var _z_ = caml_wrap_exception(_L_);
          if(_z_ !== Stdlib[3]) throw caml_maybe_attach_backtrace(_z_, 0);
         }
        var
         _A_ = ip[1],
         a =
           caml_check_bound(caml_check_bound(m$0[1], _A_)[1 + _A_], j)[1 + j];
        if(1 - caml_call2(R[1], R[3], a)){
         var _B_ = ip[1] + 1 | 0, _C_ = m$0[1].length - 1 - 1 | 0;
         if(_C_ >= _B_){
          var i = _B_;
          for(;;){
           var
            b = caml_check_bound(caml_check_bound(m$0[1], i)[1 + i], j)[1 + j];
           if(1 - caml_call2(R[1], R[3], b)){
            var _E_ = caml_call1(R[4], a);
            m$0[1] = caml_call3(Row[4], m$0[1], _E_, i);
            m$0[1] = caml_call4(Row[5], m$0[1], i, b, ip[1]);
           }
           var _F_ = i + 1 | 0;
           if(_C_ !== i){var i = _F_; continue;}
           break;
          }
         }
         ip[1]++;
        }
        var _D_ = j + 1 | 0;
        if(_v_ !== j){var j = _D_; continue;}
        break;
       }
      }
      var _w_ = m$0[1];
      return _w_;
     }
     catch(_K_){
      var _t_ = caml_wrap_exception(_K_);
      if(_t_ === Stdlib[3]) return m$0[1];
      throw caml_maybe_attach_backtrace(_t_, 0);
     }
    }
    function rank(m){
     var m$0 = row_echelon(m), n = [0, 0];
     try{
      var _p_ = m$0.length - 1 - 1 | 0, _o_ = 0;
      if(_p_ >= 0){
       var i = _o_;
       for(;;){
        if(caml_call2(Row[1], m$0, i))
         throw caml_maybe_attach_backtrace(Stdlib[3], 1);
        n[1]++;
        var _r_ = i + 1 | 0;
        if(_p_ !== i){var i = _r_; continue;}
        break;
       }
      }
      var _q_ = n[1];
      return _q_;
     }
     catch(_s_){
      var _n_ = caml_wrap_exception(_s_);
      if(_n_ === Stdlib[3]) return n[1];
      throw caml_maybe_attach_backtrace(_n_, 0);
     }
    }
    function nullity(m){return m.length - 1 - rank(m) | 0;}
    function Labeled(X){
     var
      include = caml_call1(Stdlib_Map[1], [0, X[3]]),
      empty = include[1],
      is_empty = include[2],
      mem = include[3],
      add = include[4],
      update = include[5],
      singleton = include[6],
      remove = include[7],
      merge = include[8],
      union = include[9],
      compare = include[10],
      equal = include[11],
      iter = include[12],
      fold = include[13],
      for_all = include[14],
      exists = include[15],
      filter = include[16],
      filter_map = include[17],
      partition = include[18],
      cardinal = include[19],
      bindings = include[20],
      min_binding = include[21],
      min_binding_opt = include[22],
      max_binding = include[23],
      max_binding_opt = include[24],
      choose = include[25],
      choose_opt = include[26],
      split = include[27],
      find = include[28],
      find_opt = include[29],
      find_first = include[30],
      find_first_opt = include[31],
      find_last = include[32],
      find_last_opt = include[33],
      map = include[34],
      mapi = include[35],
      to_seq = include[36],
      to_rev_seq = include[37],
      to_seq_from = include[38],
      add_seq = include[39],
      of_seq = include[40];
     function of_array(a){
      var ans = [0, empty], _k_ = a.length - 1 - 1 | 0, _j_ = 0;
      if(_k_ >= 0){
       var i = _j_;
       for(;;){
        var _l_ = ans[1];
        ans[1] = caml_call3(add, caml_check_bound(a, i)[1 + i], i, _l_);
        var _m_ = i + 1 | 0;
        if(_k_ !== i){var i = _m_; continue;}
        break;
       }
      }
      return ans[1];
     }
     var
      L =
        [0,
         empty,
         is_empty,
         mem,
         add,
         update,
         singleton,
         remove,
         merge,
         union,
         compare,
         equal,
         fold,
         for_all,
         exists,
         filter,
         filter_map,
         partition,
         cardinal,
         bindings,
         min_binding,
         min_binding_opt,
         max_binding,
         max_binding_opt,
         choose,
         choose_opt,
         split,
         find_opt,
         find_first,
         find_first_opt,
         find_last,
         find_last_opt,
         map,
         mapi,
         to_seq,
         to_rev_seq,
         to_seq_from,
         add_seq,
         of_seq,
         find,
         iter,
         of_array];
     function matrix(param){var m = param[3]; return m;}
     function zero$0(rows, cols){
      var
       m = zero(rows.length - 1, cols.length - 1),
       _i_ = caml_call1(L[41], cols);
      return [0, caml_call1(L[41], rows), _i_, m];
     }
     function set(param, i, j, x){
      var
       m = param[3],
       c = param[2],
       r = param[1],
       i$0 = caml_call2(L[39], i, r),
       j$0 = caml_call2(L[39], j, c);
      caml_check_bound(caml_check_bound(m, i$0)[1 + i$0], j$0)[1 + j$0] = x;
      return 0;
     }
     function get(param, i, j){
      var
       m = param[3],
       c = param[2],
       r = param[1],
       i$0 = caml_call2(L[39], i, r),
       j$0 = caml_call2(L[39], j, c);
      return caml_check_bound(caml_check_bound(m, i$0)[1 + i$0], j$0)[1 + j$0];
     }
     function rank$0(param){var m = param[3]; return rank(m);}
     function nullity$0(param){var m = param[3]; return nullity(m);}
     function iter_src(f, param){
      var r = param[1];
      function _h_(x, param){return caml_call1(f, x);}
      return caml_call2(L[40], _h_, r);
     }
     function iter_tgt(f, param){
      var c = param[2];
      function _g_(x, param){return caml_call1(f, x);}
      return caml_call2(L[40], _g_, c);
     }
     function iter$0(f, m){
      return iter_src
              (function(x){
                return iter_tgt(function(y){return caml_call2(f, x, y);}, m);
               },
               m);
     }
     return [0,
             L,
             matrix,
             zero$0,
             set,
             get,
             rank$0,
             nullity$0,
             iter_src,
             iter_tgt,
             iter$0];
    }
    return [0,
            zero,
            init,
            rows,
            cols,
            get,
            to_string,
            Row,
            row_echelon,
            rank,
            nullity,
            Labeled];
   }
   function Functor(R$0, R){
    var M = Make(R$0), M$0 = Make(R);
    function map(f, m){
     var r = caml_call1(M[3], m), c = 0 === r ? 0 : caml_call1(M[4], m);
     function _f_(i, j){return caml_call1(f, caml_call3(M[5], m, i, j));}
     return caml_call3(M$0[2], r, c, _f_);
    }
    function Labeled(X$0, X){
     var L = caml_call1(M[11], X$0), L$0 = caml_call1(M$0[11], X);
     function map$0(s, t, f, m){
      var m$0 = m[3], c = m[2], r = m[1];
      function lmap(f, l){
       var _c_ = L$0[1][1];
       function _d_(x, i, l){
        var _e_ = caml_call1(f, x);
        return caml_call3(L$0[1][4], _e_, i, l);
       }
       return caml_call3(L[1][12], _d_, l, _c_);
      }
      var r$0 = lmap(s, r), c$0 = lmap(t, c), m$1 = map(f, m$0);
      return [0, r$0, c$0, m$1];
     }
     return [0, L, L$0, map$0];
    }
    return [0, M, M$0, map, Labeled];
   }
   var Alg_Matrix = [0, Make, Functor];
   runtime.caml_register_global(9, Alg_Matrix, "Alg__Matrix");
   return;
  }
  (globalThis));

//# 2544 "../../src/.alg.objs/jsoo/default/alg.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$21 = "",
    cst$25 = "\n",
    cst$23 = "(",
    cst$22 = ")",
    cst$26 = ") = ",
    cst$24 = "*",
    cst$20 = "+",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$15 = cst$20,
    cst$16 = cst$21,
    cst$17 = cst$22,
    cst$18 = cst$23,
    cst$19 = cst$24,
    cst$14 = cst$21,
    cst$11 = cst$21,
    cst$12 = cst$25,
    cst$13 = ":\n",
    cst$9 = cst$21,
    cst$10 = " ",
    cst$8 = cst$21,
    cst$6 = cst$25,
    cst$7 = " -> ",
    cst$5 = cst$21,
    cst$0 = cst$20,
    cst$1 = cst$21,
    cst$2 = cst$24,
    cst$3 = cst$22,
    cst$4 = cst$23,
    cst = cst$21,
    Stdlib = global_data.Stdlib,
    Alg_Ring = global_data.Alg__Ring,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Map = global_data.Stdlib__Map,
    Alg_Matrix = global_data.Alg__Matrix,
    cst_d = "d",
    _b_ =
      [0,
       [11, "invalid: ", [4, 0, 0, 0, [12, 10, [10, 0]]]],
       "invalid: %d\n%!"],
    _c_ =
      [0,
       [11, "d(", [2, 0, [11, cst$26, [2, 0, [12, 10, [10, 0]]]]]],
       "d(%s) = %s\n%!"],
    _d_ =
      [0,
       [11, "d^2(", [2, 0, [11, cst$26, [2, 0, [12, 10, [10, 0]]]]]],
       "d^2(%s) = %s\n%!"],
    _a_ = [0, "src/module.ml", 237, 8],
    cst_0 = "0",
    cst_TODO_Module_FreeLeft_compa = "TODO: Module.FreeLeft.compare";
   function FreeLeft(R, X){
    var
     include = caml_call1(Stdlib_Map[1], [0, X[3]]),
     empty = include[1],
     is_empty = include[2],
     mem = include[3],
     update = include[5],
     singleton = include[6],
     remove = include[7],
     merge = include[8],
     union = include[9],
     compare = include[10],
     equal = include[11],
     iter = include[12],
     fold = include[13],
     for_all = include[14],
     exists = include[15],
     filter = include[16],
     filter_map = include[17],
     partition = include[18],
     cardinal = include[19],
     bindings = include[20],
     min_binding = include[21],
     min_binding_opt = include[22],
     max_binding = include[23],
     max_binding_opt = include[24],
     choose = include[25],
     choose_opt = include[26],
     split = include[27],
     find = include[28],
     find_opt = include[29],
     find_first = include[30],
     find_first_opt = include[31],
     find_last = include[32],
     find_last_opt = include[33],
     map = include[34],
     mapi = include[35],
     to_seq = include[36],
     to_rev_seq = include[37],
     to_seq_from = include[38],
     add_seq = include[39],
     of_seq = include[40],
     _w_ = include[4];
    function add(x, a, p){
     return caml_call2(R[1], R[3], a)
             ? caml_call2(remove, x, p)
             : caml_call3(_w_, x, a, p);
    }
    var
     E =
       [0,
        empty,
        is_empty,
        mem,
        update,
        singleton,
        remove,
        merge,
        union,
        compare,
        equal,
        iter,
        fold,
        for_all,
        exists,
        filter,
        filter_map,
        partition,
        cardinal,
        bindings,
        min_binding,
        min_binding_opt,
        max_binding,
        max_binding_opt,
        choose,
        choose_opt,
        split,
        find,
        find_opt,
        find_first,
        find_first_opt,
        find_last,
        find_last_opt,
        map,
        mapi,
        to_seq,
        to_rev_seq,
        to_seq_from,
        add_seq,
        of_seq,
        add],
     zero = E[1];
    function cinj(a, x){return caml_call3(E[40], x, a, zero);}
    function inj(x){return cinj(R[6], x);}
    function coeff(p, x){
     try{var _aU_ = caml_call2(E[27], x, p); return _aU_;}
     catch(_aV_){
      var _aT_ = caml_wrap_exception(_aV_);
      if(_aT_ === Stdlib[8]) return R[3];
      throw caml_maybe_attach_backtrace(_aT_, 0);
     }
    }
    function included(x, y){
     function _aS_(u, a){return runtime.caml_equal(coeff(y, u), a);}
     return caml_call2(E[13], _aS_, x);
    }
    function eq(x, y){
     var _aR_ = included(x, y);
     return _aR_ ? included(y, x) : _aR_;
    }
    function compare$0(param, _aQ_){
     return caml_call1(Stdlib[2], cst_TODO_Module_FreeLeft_compa);
    }
    function add_monomial(p, a, x){
     var _aP_ = coeff(p, x), a$0 = caml_call2(R[2], a, _aP_);
     return caml_call3(E[40], x, a$0, p);
    }
    function add$0(p, q){
     function _aO_(x, a, p){return add_monomial(p, a, x);}
     return caml_call3(E[12], _aO_, q, p);
    }
    function cmul(a, x){
     var _aN_ = caml_call1(R[5], a);
     return caml_call2(E[33], _aN_, x);
    }
    function neg(x){return cmul(caml_call1(R[4], R[6]), x);}
    function sub(x, y){return add$0(x, neg(y));}
    function to_string(x){
     if(eq(zero, x)) return cst_0;
     var ans = [0, cst];
     function _aH_(u, a){
      if(caml_string_notequal(ans[1], cst$21))
       ans[1] = caml_call2(Stdlib[28], ans[1], cst$0);
      if(caml_call2(R[1], a, R[6]))
       var a$0 = cst$1;
      else
       var
        _aK_ = caml_call2(Stdlib[28], cst$3, cst$2),
        _aL_ = caml_call1(R[7], a),
        _aM_ = caml_call2(Stdlib[28], _aL_, _aK_),
        a$0 = caml_call2(Stdlib[28], cst$4, _aM_);
      var
       _aI_ = caml_call1(X[2], u),
       _aJ_ = caml_call2(Stdlib[28], a$0, _aI_);
      ans[1] = caml_call2(Stdlib[28], ans[1], _aJ_);
      return 0;
     }
     caml_call2(E[11], _aH_, x);
     return ans[1];
    }
    function map$0(f, p){
     function _aG_(x, a, q){return add$0(q, cmul(a, caml_call1(f, x)));}
     return caml_call3(E[12], _aG_, p, zero);
    }
    function iter$0(f, p){
     function _aF_(x, a){return caml_call2(f, a, x);}
     return caml_call2(E[11], _aF_, p);
    }
    var E$0 = caml_call1(Stdlib_Map[1], [0, X[3]]);
    function set(f, x, p){return caml_call3(E$0[4], x, p, f);}
    function app(f, x){
     try{var _aD_ = caml_call2(E$0[28], x, f); return _aD_;}
     catch(_aE_){
      var _aC_ = caml_wrap_exception(_aE_);
      if(_aC_ === Stdlib[8]) return zero;
      throw caml_maybe_attach_backtrace(_aC_, 0);
     }
    }
    function bind(f, p){
     function _aB_(x, a, q){return add$0(q, cmul(a, app(f, x)));}
     return caml_call3(E$0[13], _aB_, p, zero);
    }
    var zero$0 = E$0[1];
    function to_string$0(f){
     function _av_(x, p, s){
      var
       _aw_ = to_string(p),
       _ax_ = caml_call2(Stdlib[28], _aw_, cst$6),
       _ay_ = caml_call2(Stdlib[28], cst$7, _ax_),
       _az_ = caml_call1(X[2], x),
       _aA_ = caml_call2(Stdlib[28], _az_, _ay_);
      return caml_call2(Stdlib[28], s, _aA_);
     }
     return caml_call3(E$0[13], _av_, f, cst$5);
    }
    var Map = [0, E$0, set, app, bind, zero$0, to_string$0];
    function make(gen){return gen;}
    function dim(pres){return pres.length - 1;}
    function presentation_to_string(pres){
     var ans = [0, cst$8];
     function _ar_(x){
      var
       _as_ = caml_call1(X[2], x),
       _at_ = runtime.caml_string_equal(ans[1], cst$21) ? cst$9 : cst$10,
       _au_ = caml_call2(Stdlib[28], _at_, _as_);
      ans[1] = caml_call2(Stdlib[28], ans[1], _au_);
      return 0;
     }
     caml_call2(Stdlib_Array[11], _ar_, pres);
     return ans[1];
    }
    var M = caml_call1(Alg_Matrix[1], R), L = caml_call1(M[11], X);
    function app$0(f, p){
     return map$0
             (function(x){
               var ans = [0, zero];
               function _ap_(y){
                var _aq_ = cinj(caml_call3(L[5], f, x, y), y);
                ans[1] = add$0(ans[1], _aq_);
                return 0;
               }
               caml_call2(L[9], _ap_, f);
               return ans[1];
              },
              p);
    }
    function zero$1(src, tgt){return caml_call2(L[3], src, tgt);}
    function of_map(f, src, tgt){
     var ans = zero$1(src, tgt);
     function _am_(x){
      var p = caml_call2(Map[3], f, x);
      return iter$0
              (function(a, y){
                var
                 _an_ = caml_call3(L[5], ans, x, y),
                 _ao_ = caml_call2(R[2], _an_, a);
                return caml_call4(L[4], ans, x, y, _ao_);
               },
               p);
     }
     caml_call2(Stdlib_Array[11], _am_, src);
     return ans;
    }
    function to_map(f){
     var ans = [0, Map[5]];
     function _aj_(x, y){
      var
       _ak_ = cinj(caml_call3(L[5], f, x, y), y),
       _al_ = add$0(caml_call2(Map[3], ans[1], x), _ak_);
      ans[1] = caml_call3(Map[2], ans[1], x, _al_);
      return 0;
     }
     caml_call2(L[10], _aj_, f);
     return ans[1];
    }
    var rank = L[6], nullity = L[7];
    function to_string$1(f){
     var _ai_ = to_map(f);
     return caml_call1(Map[6], _ai_);
    }
    var
     Map$0 =
       [0, M, L, app$0, zero$1, of_map, to_map, rank, nullity, to_string$1];
    function iter$1(f, pres){return caml_call2(Stdlib_Array[11], f, pres);}
    function modules(c){return c[1];}
    function maps(c){return c[2];}
    function length(c){return c[2].length - 1;}
    function make$0(modules, d){
     if(modules.length - 1 === (d.length - 1 + 1 | 0)) return [0, modules, d];
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    }
    function valid(c){
     try{
      var _N_ = length(c) - 1 | 0, _M_ = 1;
      if(_N_ >= 1){
       var i = _M_;
       for(;;){
        var _P_ = i + 1 | 0, _Q_ = caml_check_bound(c[1], _P_)[1 + _P_];
        iter$1
         (function(i){
            return function(x){
             var
              _T_ = inj(x),
              _U_ = caml_check_bound(c[2], i)[1 + i],
              _W_ = i - 1 | 0,
              _V_ = caml_call2(Map$0[3], _U_, _T_),
              _X_ = caml_check_bound(c[2], _W_)[1 + _W_],
              y = caml_call2(Map$0[3], _X_, _V_),
              _Y_ = 1 - eq(zero, y);
             if(! _Y_) return _Y_;
             caml_call2(Stdlib_Printf[2], _b_, i);
             var
              _Z_ = inj(x),
              ___ = caml_check_bound(c[2], i)[1 + i],
              _$_ = to_string(caml_call2(Map$0[3], ___, _Z_)),
              _aa_ = caml_call1(X[2], x);
             caml_call3(Stdlib_Printf[2], _c_, _aa_, _$_);
             var
              _ab_ = inj(x),
              _ac_ = caml_check_bound(c[2], i)[1 + i],
              _ae_ = i - 1 | 0,
              _ad_ = caml_call2(Map$0[3], _ac_, _ab_),
              _af_ = caml_check_bound(c[2], _ae_)[1 + _ae_],
              _ag_ = to_string(caml_call2(Map$0[3], _af_, _ad_)),
              _ah_ = caml_call1(X[2], x);
             caml_call3(Stdlib_Printf[2], _d_, _ah_, _ag_);
             throw caml_maybe_attach_backtrace(Stdlib[3], 1);};
           }
           (i),
          _Q_);
        var _R_ = i + 1 | 0;
        if(_N_ !== i){var i = _R_; continue;}
        break;
       }
      }
      var _O_ = 1;
      return _O_;
     }
     catch(_S_){
      var _L_ = caml_wrap_exception(_S_);
      if(_L_ === Stdlib[3]) return 0;
      throw caml_maybe_attach_backtrace(_L_, 0);
     }
    }
    function to_string$2(c){
     var ans = [0, cst$11], _C_ = length(c) - 1 | 0;
     if(_C_ >= 0){
      var i = _C_;
      for(;;){
       var
        _D_ = caml_check_bound(c[2], i)[1 + i],
        _E_ = caml_call1(Map$0[9], _D_),
        _F_ = caml_call2(Stdlib[28], _E_, cst$12),
        _G_ = caml_call2(Stdlib[28], cst$13, _F_),
        _H_ = caml_call1(Stdlib[33], i),
        _I_ = caml_call2(Stdlib[28], _H_, _G_),
        _J_ = caml_call2(Stdlib[28], cst_d, _I_);
       ans[1] = caml_call2(Stdlib[28], ans[1], _J_);
       var _K_ = i - 1 | 0;
       if(0 !== i){var i = _K_; continue;}
       break;
      }
     }
     return ans[1];
    }
    function betti(c){
     function _x_(i){
      if(0 === i)
       var ker = caml_check_bound(c[1], 0)[1].length - 1;
      else
       var
        _A_ = i - 1 | 0,
        _B_ = caml_check_bound(c[2], _A_)[1 + _A_],
        ker = caml_call1(Map$0[8], _B_);
      var
       _z_ = caml_check_bound(c[2], i)[1 + i],
       im = caml_call1(Map$0[7], _z_);
      return ker - im | 0;
     }
     var _y_ = length(c);
     return caml_call2(Stdlib_Array[1], _y_, _x_);
    }
    var
     Complex = [0, modules, maps, length, make$0, valid, to_string$2, betti],
     Pres =
       [0,
        make,
        dim,
        presentation_to_string,
        Map$0,
        iter$1,
        Complex,
        presentation_to_string];
    return [0,
            R,
            E,
            zero,
            cinj,
            inj,
            coeff,
            included,
            eq,
            compare$0,
            add_monomial,
            add$0,
            cmul,
            neg,
            sub,
            to_string,
            map$0,
            iter$0,
            Map,
            Pres];
   }
   function FreeLeftModule(_u_, _t_){
    var _v_ = FreeLeft(_u_, _t_);
    return [0,
            _v_[1],
            _v_[8],
            _v_[9],
            _v_[11],
            _v_[3],
            _v_[15],
            _v_[13],
            _v_[12]];
   }
   function Free(_s_, _r_){return FreeLeft(_s_, _r_);}
   function FreeRight(R, X){
    var
     include = FreeLeft(caml_call1(Alg_Ring[6], R), X),
     Ring = include[1],
     E = include[2],
     zero = include[3],
     inj = include[5],
     coeff = include[6],
     included = include[7],
     eq = include[8],
     compare = include[9],
     add_monomial = include[10],
     add = include[11],
     neg = include[13],
     sub = include[14],
     map = include[16],
     iter = include[17],
     Map = include[18],
     Pres = include[19],
     _h_ = include[4],
     _i_ = include[12];
    function cinj(x, a){return caml_call2(_h_, a, x);}
    function cmul(x, a){return caml_call2(_i_, a, x);}
    function to_string(x){
     var ans = [0, cst$14];
     function _j_(u, a){
      var _k_ = 1 - caml_call2(R[1], a, R[3]);
      if(_k_){
       if(caml_string_notequal(ans[1], cst$21))
        ans[1] = caml_call2(Stdlib[28], ans[1], cst$15);
       if(caml_call2(R[1], a, R[6]))
        var a$0 = cst$16;
       else
        var
         _o_ = caml_call1(R[7], a),
         _p_ = caml_call2(Stdlib[28], _o_, cst$17),
         _q_ = caml_call2(Stdlib[28], cst$18, _p_),
         a$0 = caml_call2(Stdlib[28], cst$19, _q_);
       var _l_ = caml_call1(X[2], u), _m_ = caml_call2(Stdlib[28], _l_, a$0);
       ans[1] = caml_call2(Stdlib[28], ans[1], _m_);
       var _n_ = 0;
      }
      else
       var _n_ = _k_;
      return _n_;
     }
     caml_call2(E[11], _j_, x);
     return ans[1];
    }
    return [0,
            Ring,
            E,
            zero,
            inj,
            coeff,
            included,
            eq,
            compare,
            add_monomial,
            add,
            neg,
            sub,
            map,
            iter,
            Map,
            Pres,
            cinj,
            cmul,
            to_string];
   }
   function FreeRightModule(_f_, _e_){
    var _g_ = FreeRight(_f_, _e_);
    return [0,
            _g_[1],
            _g_[7],
            _g_[8],
            _g_[10],
            _g_[3],
            _g_[19],
            _g_[11],
            _g_[18]];
   }
   var
    Alg_Module =
      [0, FreeLeft, FreeLeftModule, Free, FreeRight, FreeRightModule];
   runtime.caml_register_global(38, Alg_Module, "Alg__Module");
   return;
  }
  (globalThis));

//# 3115 "../../src/.alg.objs/jsoo/default/alg.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_algebra_ml = "src/algebra.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = " -> ",
    cst = " >",
    cst$1 = " , ",
    cst$2 = " | ",
    cst$3 = " ",
    cst$4 = "< ",
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Stdlib_String = global_data.Stdlib__String,
    Alg_Monoid = global_data.Alg__Monoid,
    Alg_Module = global_data.Alg__Module,
    Alg_Matrix = global_data.Alg__Matrix,
    _c_ = [0, cst_src_algebra_ml, 333, 16],
    _b_ = [0, cst_src_algebra_ml, 296, 30],
    cst_not_in_the_kernel = " not in the kernel.\n%!",
    _d_ =
      [0,
       [11, "failed (non-reducible): ", [2, 0, [12, 10, [10, 0]]]],
       "failed (non-reducible): %s\n%!"],
    _e_ = [0, [11, "leading: ", [2, 0, [12, 10, [10, 0]]]], "leading: %s\n%!"],
    _f_ = [0, cst_src_algebra_ml, 364, 14],
    _a_ = [0, cst_src_algebra_ml, 199, 6],
    cst_Alg_Algebra_Pres_K_X_Augme =
      "Alg.Algebra.Pres(K)(X).Augmentation.Invalid";
   function Free(K, M){
    var
     _cf_ = [0, M[1], M[5], M[6]],
     include = caml_call1(caml_call1(Alg_Module[1], K), _cf_),
     Ring = include[1],
     E = include[2],
     zero = include[3],
     cinj = include[4],
     inj = include[5],
     coeff = include[6],
     included = include[7],
     eq = include[8],
     compare = include[9],
     add_monomial = include[10],
     add = include[11],
     cmul = include[12],
     neg = include[13],
     sub = include[14],
     to_string = include[15],
     map = include[16],
     iter = include[17],
     Map = include[18],
     Pres = include[19],
     one = caml_call1(inj, M[3]);
    function mul_monomial(p, v){
     return caml_call2
             (map,
              function(u){return caml_call1(inj, caml_call2(M[2], u, v));},
              p);
    }
    function mul(p, q){
     return caml_call2(map, function(v){return mul_monomial(p, v);}, q);
    }
    function leading(leq, p){
     var a = [0, K[3]], u = [0, M[3]];
     caml_call2
      (iter,
       function(b, v){
        var
         _cg_ = caml_call2(leq, u[1], v),
         _ch_ = _cg_ ? (a[1] = b, u[1] = v, 0) : _cg_;
        return _ch_;
       },
       p);
     return [0, a[1], u[1]];
    }
    return [0,
            Ring,
            E,
            zero,
            cinj,
            inj,
            coeff,
            included,
            eq,
            compare,
            add_monomial,
            add,
            cmul,
            neg,
            sub,
            to_string,
            map,
            iter,
            Map,
            Pres,
            one,
            mul_monomial,
            mul,
            leading];
   }
   var OverRing = [0, Free];
   function Free$0(K, M){
    var
     include =
       caml_call1
        (caml_call1
          (OverRing[1], [0, K[1], K[2], K[3], K[4], K[5], K[6], K[7]]),
         M),
     Ring = include[1],
     E = include[2],
     zero = include[3],
     cinj = include[4],
     inj = include[5],
     coeff = include[6],
     included = include[7],
     eq = include[8],
     compare = include[9],
     add_monomial = include[10],
     add = include[11],
     cmul = include[12],
     neg = include[13],
     sub = include[14],
     to_string = include[15],
     map = include[16],
     iter = include[17],
     Map = include[18],
     Pres = include[19],
     one = include[20],
     mul_monomial = include[21],
     mul = include[22],
     leading = include[23];
    return [0,
            Ring,
            E,
            zero,
            cinj,
            inj,
            coeff,
            included,
            eq,
            compare,
            add_monomial,
            add,
            cmul,
            neg,
            sub,
            to_string,
            map,
            iter,
            Map,
            Pres,
            one,
            mul_monomial,
            mul,
            leading,
            K];
   }
   function FreeAlgebra(_cd_, _cc_){
    var _ce_ = Free$0(_cd_, _cc_);
    return [0,
            _ce_[8],
            _ce_[11],
            _ce_[3],
            _ce_[13],
            _ce_[22],
            _ce_[20],
            _ce_[15],
            _ce_[24],
            _ce_[12]];
   }
   function Pres(K, X){
    var
     M = caml_call1(Alg_Monoid[3], X),
     A = Free$0(K, [0, M[8], M[2], M[3], M[4], M[11], M[9], M[1]]);
    function free(leq, generators){return [0, leq, generators, 0];}
    function orient(pres, p){
     var
      match = caml_call2(A[23], pres[1], p),
      u = match[2],
      a = match[1],
      _ca_ = caml_call1(K[8], a),
      p$0 = caml_call2(A[12], _ca_, p),
      _cb_ = caml_call1(A[5], u),
      p$1 = caml_call2(A[14], _cb_, p$0);
     return [0, u, p$1];
    }
    function add_rule(pres, r){
     var rules = [0, r, pres[3]];
     return [0, pres[1], pres[2], rules];
    }
    function add_relation(pres, p){return add_rule(pres, orient(pres, p));}
    function make(leq, generators, pp){
     var _b$_ = free(leq, generators);
     return caml_call3(Stdlib_List[25], add_relation, _b$_, pp);
    }
    function heads(pres){
     var _b9_ = pres[3];
     function _b__(param){var u = param[1]; return u;}
     return caml_call2(Stdlib_List[19], _b__, _b9_);
    }
    function to_string(pres){
     var _bX_ = pres[3];
     function _bY_(param){
      var
       p = param[2],
       u = param[1],
       _b6_ = caml_call1(A[15], p),
       _b7_ = caml_call2(Stdlib[28], cst$0, _b6_),
       _b8_ = caml_call1(M[11], u);
      return caml_call2(Stdlib[28], _b8_, _b7_);
     }
     var
      _bZ_ = caml_call2(Stdlib_List[19], _bY_, _bX_),
      _b0_ = caml_call2(Stdlib_String[6], cst$1, _bZ_),
      _b1_ = caml_call2(Stdlib[28], _b0_, cst),
      _b2_ = caml_call2(Stdlib[28], cst$2, _b1_),
      _b3_ = caml_call2(Stdlib_List[19], X[2], pres[2]),
      _b4_ = caml_call2(Stdlib_String[6], cst$3, _b3_),
      _b5_ = caml_call2(Stdlib[28], _b4_, _b2_);
     return caml_call2(Stdlib[28], cst$4, _b5_);
    }
    function normalize(pres, p){
     var p$0 = [0, p], loop = [0, 1];
     for(;;){
      if(! loop[1]) return p$0[1];
      loop[1] = 0;
      var
       _bM_ = p$0[1],
       _bN_ =
         function(u){
          try{
           var
            _bP_ = pres[3],
            _bQ_ =
              function(param){
               var v = param[1];
               return caml_call2(M[13], v, u);
              },
            match = caml_call2(Stdlib_List[38], _bQ_, _bP_),
            v = match[2],
            v$0 = match[1];
           loop[1] = 1;
           var
            i = caml_call3(M[14], 0, u, v$0),
            v1 = caml_call3(M[7], u, 0, i),
            _bR_ = i + caml_call1(M[6], v$0) | 0,
            _bS_ = caml_call1(M[6], u) - _bR_ | 0,
            _bT_ = i + caml_call1(M[6], v$0) | 0,
            v2 = caml_call3(M[7], u, _bT_, _bS_),
            v1$0 = caml_call1(A[5], v1),
            v2$0 = caml_call1(A[5], v2),
            _bU_ = caml_call2(A[22], v, v2$0),
            _bV_ = caml_call2(A[22], v1$0, _bU_);
           return _bV_;
          }
          catch(_bW_){
           var _bO_ = caml_wrap_exception(_bW_);
           if(_bO_ === Stdlib[8]) return caml_call1(A[5], u);
           throw caml_maybe_attach_backtrace(_bO_, 0);
          }
         };
      p$0[1] = caml_call2(A[16], _bN_, _bM_);
     }
    }
    function buchberger(pres){
     var todo = caml_call1(Stdlib_Queue[2], 0), _bC_ = pres[3];
     function _bD_(r){return caml_call2(Stdlib_Queue[3], r, todo);}
     caml_call2(Stdlib_List[17], _bD_, _bC_);
     var pres$0 = [0, pres];
     for(;;){
      if(caml_call1(Stdlib_Queue[13], todo)) return pres$0[1];
      var
       match = caml_call1(Stdlib_Queue[7], todo),
       p = match[2],
       u = match[1],
       _bE_ = pres$0[1][3],
       _bF_ =
         function(p, u){
           return function(param){
            var q = param[2], v = param[1], _bG_ = caml_call2(M[17], u, v);
            function _bH_(param){
             var
              _bJ_ = param[2],
              v2 = _bJ_[2],
              v1 = _bJ_[1],
              match = param[1],
              u2 = match[2],
              u1 = match[1],
              u1$0 = caml_call1(A[5], u1),
              u2$0 = caml_call1(A[5], u2),
              v1$0 = caml_call1(A[5], v1),
              v2$0 = caml_call1(A[5], v2),
              _bK_ = caml_call2(A[22], p, u2$0),
              s1 = caml_call2(A[22], u1$0, _bK_),
              _bL_ = caml_call2(A[22], q, v2$0),
              s2 = caml_call2(A[22], v1$0, _bL_),
              s = caml_call2(A[14], s1, s2),
              s$0 = normalize(pres$0[1], s),
              _bI_ = 1 - caml_call2(A[8], A[3], s$0);
             if(! _bI_) return _bI_;
             var r = orient(pres$0[1], s$0);
             pres$0[1] = add_rule(pres$0[1], r);
             return caml_call2(Stdlib_Queue[4], r, todo);
            }
            return caml_call2(Stdlib_List[17], _bH_, _bG_);};
          }
          (p, u);
      caml_call2(Stdlib_List[17], _bF_, _bE_);
     }
    }
    function reduce(pres){
     var rules = pres[3];
     function _bA_(param){
      var p = param[2], u = param[1];
      return [0, u, normalize(pres, p)];
     }
     var
      rules$0 = caml_call2(Stdlib_List[19], _bA_, rules),
      acc = 0,
      param = rules$0;
     for(;;){
      if(! param){
       var rules$2 = caml_call1(Stdlib_List[9], acc);
       return [0, pres[1], pres[2], rules$2];
      }
      var
       rules$1 = param[2],
       match = param[1],
       p = match[2],
       u = match[1],
       f$0 =
         function(u){
          function f(l){
           function _bB_(param){
            var v = param[1];
            return caml_call2(M[13], v, u);
           }
           return caml_call2(Stdlib_List[33], _bB_, l);
          }
          return f;
         },
       f = f$0(u);
      if(! f(acc) && ! f(rules$1)){
       var acc$0 = [0, [0, u, p], acc], acc = acc$0, param = rules$1;
       continue;
      }
      var param = rules$1;
     }
    }
    function Algebra(P){
     var
      zero = A[3],
      eq = A[8],
      add = A[11],
      cmul = A[12],
      neg = A[13],
      to_string = A[15],
      one = A[20],
      mul = A[22],
      Field = A[24],
      _bz_ = P[1];
     function mul$0(p, q){return normalize(_bz_, caml_call2(mul, p, q));}
     return [0, eq, add, zero, neg, mul$0, one, to_string, Field, cmul];
    }
    var
     Invalid =
       [248, cst_Alg_Algebra_Pres_K_X_Augme, runtime.caml_fresh_oo_id(0)];
    function make$0(pres, eps){
     function eps$0(p){
      var ans = [0, K[3]];
      function _bw_(a, u){
       var _bx_ = caml_call1(eps, u), _by_ = caml_call2(K[5], a, _bx_);
       ans[1] = caml_call2(K[2], ans[1], _by_);
       return 0;
      }
      caml_call2(A[17], _bw_, p);
      return ans[1];
     }
     var _bq_ = eps$0(caml_call1(A[5], M[3]));
     if(! caml_call2(K[1], K[6], _bq_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var _br_ = pres[3];
     function _bs_(param){
      var
       p = param[2],
       u = param[1],
       _bt_ = eps$0(p),
       _bu_ = eps$0(caml_call1(A[5], u)),
       _bv_ = 1 - caml_call2(K[1], _bu_, _bt_);
      if(_bv_) throw caml_maybe_attach_backtrace(Invalid, 1);
      return _bv_;
     }
     caml_call2(Stdlib_List[17], _bs_, _br_);
     return eps$0;
    }
    function graded(pres){
     return make$0
             (pres,
              function(u){return caml_call2(M[8], M[3], u) ? K[6] : K[3];});
    }
    function monoid(pres){return make$0(pres, function(u){return K[6];});}
    var
     Augmentation = [0, Invalid, make$0, graded, monoid],
     _S_ = M[19],
     _T_ = [0, _S_[7], _S_[12], _S_[8]],
     Mod =
       caml_call1
        (caml_call1
          (Alg_Module[4], [0, A[8], A[11], A[3], A[13], A[22], A[20], A[15]]),
         _T_),
     to_string$0 = Mod[19],
     cmul = Mod[18],
     cinj = Mod[17],
     Pres = Mod[16],
     iter = Mod[14],
     map = Mod[13],
     sub = Mod[12],
     neg = Mod[11],
     add = Mod[10],
     add_monomial = Mod[9],
     compare = Mod[8],
     eq = Mod[7],
     included = Mod[6],
     coeff = Mod[5],
     inj = Mod[4],
     zero = Mod[3],
     E = Mod[2],
     Ring = Mod[1];
    function normalize$0(pres, p){
     var ans = [0, zero];
     caml_call2
      (iter,
       function(u, c){
        var u$0 = normalize(pres, u), _bp_ = caml_call2(cinj, c, u$0);
        ans[1] = caml_call2(add, ans[1], _bp_);
        return 0;
       },
       p);
     return ans[1];
    }
    var
     include = Mod[15],
     E$0 = include[1],
     set = include[2],
     app = include[3],
     zero$0 = include[5],
     to_string$1 = include[6],
     _U_ = include[4];
    function bind(pres, f, p){
     return normalize$0(pres, caml_call2(_U_, f, p));
    }
    var
     Map = [0, E$0, set, app, zero$0, to_string$1, bind],
     AMod =
       [0,
        Mod,
        Ring,
        E,
        zero,
        inj,
        coeff,
        included,
        eq,
        compare,
        add_monomial,
        add,
        neg,
        sub,
        map,
        iter,
        Pres,
        cinj,
        cmul,
        to_string$0,
        normalize$0,
        Map];
    function cinj$0(a, c, u){
     var _bo_ = caml_call2(A[4], a, u);
     return caml_call2(AMod[17], c, _bo_);
    }
    function cmul$0(a, cu){
     var _bn_ = caml_call2(A[12], a, A[20]);
     return caml_call2(AMod[18], cu, _bn_);
    }
    function iter$0(f, p){
     function _bl_(u, c){
      function _bm_(a, u){return caml_call3(f, a, c, u);}
      return caml_call2(A[17], _bm_, u);
     }
     return caml_call2(AMod[15], _bl_, p);
    }
    function map$0(f, p){
     var ans = [0, AMod[4]];
     iter$0
      (function(a, c, u){
        var _bk_ = cmul$0(a, caml_call2(f, c, u));
        ans[1] = caml_call2(AMod[11], ans[1], _bk_);
        return 0;
       },
       p);
     return ans[1];
    }
    var AKMod = [0, cinj$0, cmul$0, iter$0, map$0];
    function chains(pres, n){
     var cc = runtime.caml_make_vect(n + 1 | 0, [0, M[19][1], 0]);
     if(1 <= n){
      var _ba_ = caml_call1(M[19][3], pres[2]);
      caml_check_bound(cc, 1)[2] = _ba_;
     }
     var _bb_ = pres[3];
     function _bc_(_bj_){return _bj_[1];}
     var
      left = caml_call2(Stdlib_List[19], _bc_, _bb_),
      _be_ = n - 1 | 0,
      _bd_ = 1;
     if(_be_ >= 1){
      var i = _bd_;
      for(;;){
       var
        _bf_ = caml_check_bound(cc, i)[1 + i],
        _bh_ = i + 1 | 0,
        _bg_ = caml_call2(M[19][9], left, _bf_);
       caml_check_bound(cc, _bh_)[1 + _bh_] = _bg_;
       var _bi_ = i + 1 | 0;
       if(_be_ !== i){var i = _bi_; continue;}
       break;
      }
     }
     return cc;
    }
    function resolution_ch(augmentation, pres, n){
     var debug = 0;
     if(augmentation)
      var augmentation$0 = augmentation[1], augmentation$1 = augmentation$0;
     else
      var augmentation$1 = caml_call1(Augmentation[3], pres);
     var cc = chains(pres, n);
     function _ab_(param){return AMod[21][4];}
     var d = caml_call2(Stdlib_Array[1], n, _ab_), _ac_ = pres[2];
     function _ad_(x){
      var
       _a7_ = caml_call1(M[5], x),
       x$0 = caml_call1(A[5], _a7_),
       a = caml_call1(augmentation$1, x$0),
       _a6_ = caml_call2(A[4], a, M[3]),
       _a8_ = caml_call2(A[14], x$0, _a6_),
       _a9_ = caml_call2(AMod[17], M[19][1], _a8_),
       _a__ = caml_call1(M[19][2], x),
       _a$_ = caml_check_bound(d, 0)[1];
      d[1] = caml_call3(AMod[21][2], _a$_, _a__, _a9_);
      return debug;
     }
     caml_call2(Stdlib_List[17], _ad_, _ac_);
     function ch(n, p){
      function _ax_(u, c){
       if(caml_call1(M[19][11], c) === n) return 0;
       throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
      }
      caml_call2(AMod[15], _ax_, p);
      if(0 !== n){
       var
        _aQ_ = n - 1 | 0,
        _aR_ = caml_check_bound(d, _aQ_)[1 + _aQ_],
        _aS_ = caml_call3(AMod[21][6], pres, _aR_, p);
       if(! caml_call2(AMod[8], AMod[4], _aS_)) return AMod[4];
      }
      if(caml_call2(AMod[8], AMod[4], p)) return AMod[4];
      if(0 === n){
       var
        ans = [0, AMod[4]],
        _ay_ =
          function(a, c, u){
           if(0 === caml_call1(M[6], u)) return 0;
           var _a0_ = caml_call1(M[6], u) - 1 | 0, _aZ_ = 0;
           if(_a0_ >= 0){
            var i = _aZ_;
            for(;;){
             var
              v = caml_call3(M[7], u, 0, i),
              _a1_ = caml_check_bound(u, i)[1 + i],
              c$0 = caml_call1(M[19][2], _a1_),
              _a2_ = caml_call1(M[6], u) - (i + 1 | 0) | 0,
              u$0 = caml_call3(M[7], u, i + 1 | 0, _a2_),
              _a3_ = caml_call1(augmentation$1, caml_call1(A[5], v)),
              a$0 = caml_call2(K[5], a, _a3_),
              _a4_ = caml_call3(AKMod[1], a$0, c$0, u$0);
             ans[1] = caml_call2(AMod[11], ans[1], _a4_);
             var _a5_ = i + 1 | 0;
             if(_a0_ !== i){var i = _a5_; continue;}
             break;
            }
           }
           return 0;
          };
       caml_call2(AKMod[3], _ay_, p);
       return ans[1];
      }
      var
       a = [0, K[3]],
       c = [0, M[19][1]],
       u = [0, M[3]],
       cu = [0, M[3]],
       _az_ = n - 1 | 0,
       _aA_ = caml_check_bound(d, _az_)[1 + _az_],
       _aB_ = caml_call3(AMod[21][6], pres, _aA_, p);
      if(1 - caml_call2(AMod[8], AMod[4], _aB_)){
       var
        _aC_ = caml_call1(AMod[19], p),
        _aD_ = caml_call2(Stdlib[28], _aC_, cst_not_in_the_kernel);
       caml_call1(Stdlib[2], _aD_);
      }
      function _aE_(a$0, c$0, u$0){
       var
        _aW_ = caml_call1(M[19][10], c$0),
        cu$0 = caml_call2(M[2], _aW_, u$0),
        _aX_ = caml_call2(pres[1], cu[1], cu$0);
       if(_aX_){
        if(caml_call2(K[1], a$0, K[3]))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
        a[1] = a$0;
        c[1] = c$0;
        u[1] = u$0;
        cu[1] = cu$0;
        var _aY_ = 0;
       }
       else
        var _aY_ = _aX_;
       return _aY_;
      }
      caml_call2(AKMod[3], _aE_, p);
      var
       a$0 = a[1],
       c$0 = c[1],
       u$0 = u[1],
       cn = caml_call1(M[19][4], c$0),
       cnl = caml_call1(M[6], cn),
       cnu = caml_call2(M[2], cn, u$0),
       cnul = caml_call1(M[6], cnu),
       ans$0 = [0, -1];
      try{
       var _aK_ = cnul - 1 | 0, _aJ_ = 0;
       if(_aK_ >= 0){
        var i$0 = _aJ_;
        for(;;){
         var
          _aN_ = pres[3],
          _aO_ =
            function(i){
              return function(param){
               var
                v = param[1],
                vl = caml_call1(M[6], v),
                _aU_ = (i + vl | 0) <= cnul ? 1 : 0,
                _aV_ = _aU_ ? caml_call5(M[10], cnu, i, v, 0, vl) : _aU_;
               if(! _aV_) return _aV_;
               ans$0[1] = (i + vl | 0) - cnl | 0;
               throw caml_maybe_attach_backtrace(Stdlib[3], 1);};
             }
             (i$0);
         caml_call2(Stdlib_List[17], _aO_, _aN_);
         var _aP_ = i$0 + 1 | 0;
         if(_aK_ !== i$0){var i$0 = _aP_; continue;}
         break;
        }
       }
       var _aL_ = caml_call1(AMod[19], p);
       caml_call2(Stdlib_Printf[2], _d_, _aL_);
       var
        leading = caml_call3(AKMod[1], a$0, c$0, u$0),
        _aM_ = caml_call1(AMod[19], leading);
       caml_call2(Stdlib_Printf[2], _e_, _aM_);
       throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
      }
      catch(_aT_){
       var _aF_ = caml_wrap_exception(_aT_);
       if(_aF_ !== Stdlib[3]) throw caml_maybe_attach_backtrace(_aF_, 0);
       var
        i = ans$0[1],
        u$1 = caml_call3(M[7], u$0, 0, i),
        _aG_ = caml_call1(M[6], u$0) - i | 0,
        u$2 = caml_call3(M[7], u$0, i, _aG_),
        c$1 = [0, u$1, c$0],
        ans$1 = caml_call3(AKMod[1], a$0, c$1, u$2),
        ans$2 = caml_call2(AMod[20], pres, ans$1),
        _aH_ = caml_check_bound(d, n)[1 + n],
        ans$3 = caml_call3(AMod[21][6], pres, _aH_, ans$2),
        p$0 = caml_call2(AMod[13], p, ans$3),
        p$1 = caml_call2(AMod[20], pres, p$0),
        ans$4 = ch(n, p$1),
        _aI_ = caml_call2(AMod[11], ans$2, ans$4),
        ans$5 = caml_call2(AMod[20], pres, _aI_);
       return ans$5;
      }
     }
     var _af_ = n - 1 | 0, _ae_ = 1;
     if(_af_ >= 1){
      var i = _ae_;
      for(;;){
       var
        _aj_ = i + 1 | 0,
        _ak_ = caml_check_bound(cc, _aj_)[1 + _aj_],
        _al_ =
          function(i){
            return function(c){
             var
              u = caml_call1(M[19][4], c),
              c$0 = caml_call1(M[19][5], c),
              _as_ = caml_call1(A[5], u),
              _at_ = caml_call1(AMod[5], c$0),
              p = caml_call2(AMod[18], _at_, _as_),
              _au_ = i - 1 | 0,
              _av_ = caml_check_bound(d, _au_)[1 + _au_],
              p$0 = caml_call3(AMod[21][6], pres, _av_, p),
              p$1 = ch(i - 1 | 0, p$0),
              p$2 = caml_call2(AMod[13], p, p$1),
              p$3 = caml_call2(AMod[20], pres, p$2),
              _aw_ = caml_check_bound(d, i)[1 + i];
             d[1 + i] = caml_call3(AMod[21][2], _aw_, c, p$3);
             return 0;};
           }
           (i);
       caml_call2(Stdlib_List[17], _al_, _ak_);
       var _am_ = i + 1 | 0;
       if(_af_ !== i){var i = _am_; continue;}
       break;
      }
     }
     function _ag_(l){
      var _ar_ = caml_call1(Stdlib_Array[10], l);
      return caml_call1(AMod[16][1], _ar_);
     }
     var cc$0 = caml_call2(Stdlib_Array[13], _ag_, cc);
     function _ah_(i, d){
      var
       _ap_ = i + 1 | 0,
       _ao_ = caml_check_bound(cc$0, i)[1 + i],
       _aq_ = caml_check_bound(cc$0, _ap_)[1 + _ap_];
      return caml_call3(AMod[16][4][5], d, _aq_, _ao_);
     }
     var d$0 = caml_call2(Stdlib_Array[14], _ah_, d);
     function _ai_(i){return function(_an_){return ch(i, _an_);};}
     var s = caml_call2(Stdlib_Array[1], n - 2 | 0, _ai_);
     return [0, caml_call2(AMod[16][6][4], cc$0, d$0), s];
    }
    function resolution(augmentation, pres, n){
     return resolution_ch(augmentation, pres, n)[1];
    }
    var
     _V_ = M[19],
     _W_ = [0, _V_[7], _V_[12], _V_[8]],
     KMod =
       caml_call1
        (caml_call1
          (Alg_Module[3], [0, K[1], K[2], K[3], K[4], K[5], K[6], K[7]]),
         _W_),
     _X_ = [0, K[1], K[2], K[3], K[4], K[5], K[6], K[7]],
     MF =
       caml_call1
        (caml_call1
          (Alg_Matrix[2], [0, A[8], A[11], A[3], A[13], A[22], A[20], A[15]]),
         _X_),
     _Y_ = M[19],
     ___ = M[19],
     _Z_ = [0, _Y_[7], _Y_[12], _Y_[8]],
     MFL = caml_call1(caml_call1(MF[4], [0, ___[7], ___[12], ___[8]]), _Z_);
    function complex(augmentation, pres, n){
     if(augmentation)
      var augmentation$0 = augmentation[1], augmentation$1 = augmentation$0;
     else
      var augmentation$1 = caml_call1(Augmentation[3], pres);
     var
      r = resolution([0, augmentation$1], pres, n),
      cc = caml_call1(AMod[16][6][1], r),
      d = caml_call1(AMod[16][6][2], r);
     function id(x){return x;}
     function _$_(d){
      function _aa_(p){
       var p$0 = normalize(pres, p);
       return caml_call1(augmentation$1, p$0);
      }
      return caml_call4(MFL[3], id, id, _aa_, d);
     }
     var d$0 = caml_call2(Stdlib_Array[13], _$_, d);
     return caml_call2(KMod[19][6][4], cc, d$0);
    }
    function betti(augmentation, pres, n){
     var c = complex(augmentation, pres, n + 1 | 0);
     return caml_call1(KMod[19][6][7], c);
    }
    var
     Anick =
       [0,
        AMod,
        AKMod,
        chains,
        resolution_ch,
        resolution,
        KMod,
        MF,
        MFL,
        complex,
        betti];
    return [0,
            M,
            A,
            free,
            orient,
            add_rule,
            add_relation,
            make,
            heads,
            to_string,
            normalize,
            buchberger,
            reduce,
            Algebra,
            Augmentation,
            Anick];
   }
   function Generate(K, X){
    var Pres$0 = Pres(K, X);
    function intset(n){
     function aux(k){return n <= k ? 0 : [0, k, aux(k + 1 | 0)];}
     return aux(0);
    }
    function braid(leq, n){
     var generators = intset(n), relations = [0, 0], _E_ = n - 2 | 0, _D_ = 0;
     if(_E_ >= 0){
      var i$0 = _D_;
      for(;;){
       var
        _O_ = relations[1],
        _P_ = caml_call1(Pres$0[2][5], [0, i$0 + 1 | 0, i$0, i$0 + 1 | 0]),
        _Q_ = caml_call1(Pres$0[2][5], [0, i$0, i$0 + 1 | 0, i$0]);
       relations[1] = [0, caml_call2(Pres$0[2][14], _Q_, _P_), _O_];
       var _R_ = i$0 + 1 | 0;
       if(_E_ !== i$0){var i$0 = _R_; continue;}
       break;
      }
     }
     var _G_ = n - 1 | 0, _F_ = 0;
     if(_G_ >= 0){
      var i = _F_;
      for(;;){
       var _H_ = i + 2 | 0, _I_ = n - 1 | 0;
       if(_I_ >= _H_){
        var j = _H_;
        for(;;){
         var
          _K_ = relations[1],
          _L_ = caml_call1(Pres$0[2][5], [0, j, i]),
          _M_ = caml_call1(Pres$0[2][5], [0, i, j]);
         relations[1] = [0, caml_call2(Pres$0[2][14], _M_, _L_), _K_];
         var _N_ = j + 1 | 0;
         if(_I_ !== j){var j = _N_; continue;}
         break;
        }
       }
       var _J_ = i + 1 | 0;
       if(_G_ !== i){var i = _J_; continue;}
       break;
      }
     }
     var relations$0 = caml_call1(Stdlib_List[9], relations[1]);
     return caml_call3(Pres$0[7], leq, generators, relations$0);
    }
    function symmetric(leq, n){
     var generators = intset(n), relations = [0, 0], _v_ = n - 1 | 0, _u_ = 0;
     if(_v_ >= 0){
      var i = _u_;
      for(;;){
       var _w_ = i + 1 | 0, _x_ = n - 1 | 0;
       if(_x_ >= _w_){
        var j = _w_;
        for(;;){
         var
          _z_ = relations[1],
          _A_ = caml_call1(Pres$0[2][5], [0, j, i]),
          _B_ = caml_call1(Pres$0[2][5], [0, i, j]);
         relations[1] = [0, caml_call2(Pres$0[2][14], _B_, _A_), _z_];
         var _C_ = j + 1 | 0;
         if(_x_ !== j){var j = _C_; continue;}
         break;
        }
       }
       var _y_ = i + 1 | 0;
       if(_v_ !== i){var i = _y_; continue;}
       break;
      }
     }
     var relations$0 = caml_call1(Stdlib_List[9], relations[1]);
     return caml_call3(Pres$0[7], leq, generators, relations$0);
    }
    function exterior(leq, n){
     var generators = intset(n), relations = [0, 0], _h_ = n - 1 | 0, _g_ = 0;
     if(_h_ >= 0){
      var i$0 = _g_;
      for(;;){
       var _m_ = i$0 + 1 | 0, _n_ = n - 1 | 0;
       if(_n_ >= _m_){
        var j = _m_;
        for(;;){
         var
          _p_ = relations[1],
          _q_ = caml_call1(K[4], K[6]),
          _r_ = caml_call2(Pres$0[2][4], _q_, [0, j, i$0]),
          _s_ = caml_call1(Pres$0[2][5], [0, i$0, j]);
         relations[1] = [0, caml_call2(Pres$0[2][14], _s_, _r_), _p_];
         var _t_ = j + 1 | 0;
         if(_n_ !== j){var j = _t_; continue;}
         break;
        }
       }
       var _o_ = i$0 + 1 | 0;
       if(_h_ !== i$0){var i$0 = _o_; continue;}
       break;
      }
     }
     var _j_ = n - 1 | 0, _i_ = 0;
     if(_j_ >= 0){
      var i = _i_;
      for(;;){
       var _k_ = relations[1];
       relations[1] = [0, caml_call1(Pres$0[2][5], [0, i, i]), _k_];
       var _l_ = i + 1 | 0;
       if(_j_ !== i){var i = _l_; continue;}
       break;
      }
     }
     var relations$0 = caml_call1(Stdlib_List[9], relations[1]);
     return caml_call3(Pres$0[7], leq, generators, relations$0);
    }
    return [0, Pres$0, intset, braid, symmetric, exterior];
   }
   var Alg_Algebra = [0, OverRing, Free$0, FreeAlgebra, Pres, Generate];
   runtime.caml_register_global(30, Alg_Algebra, "Alg__Algebra");
   return;
  }
  (globalThis));

//# 4092 "../../src/.alg.objs/jsoo/default/alg.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$36 = "",
    cst$38 = "\n",
    cst_end_tikzcd = "\n\\end{tikzcd}\n\\]\n\n",
    cst$43 = " -",
    cst_s = "%s",
    cst_s_ar_d_s_s_ar_d_s = "%s\\ar[d,%s']&&%s\\ar[d,%s]\\\\\n",
    cst_s_ar_d_s_ar_r_s_s_ar_r_s_s =
      "%s\\ar[d,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n",
    cst$33 = "']&",
    cst$34 = "']&&",
    cst_ar_r = "']\\ar[r,",
    cst$40 = "(",
    cst$39 = ")",
    cst$44 = ",",
    cst$41 = "-",
    cst$42 = "-> ",
    cst$37 = ": ",
    cst_begin_tikzcd = "\\[\n\\begin{tikzcd}\n",
    cst$35 = "\\\\",
    cst_ar_d = "\\ar[d,",
    cst_ar_r$0 = "\\ar[r,",
    cst_ar_rr = "\\ar[rr,",
    cst_documentclass_a4paper_9pt_ =
      "\\documentclass[a4paper,9pt]{extarticle}\n\\usepackage[utf8x]{inputenc}\n\\usepackage{amsmath}\n\\usepackage{tikz-cd}\n\\usepackage[margin=1cm,includefoot]{geometry}\n\\title{Coherent presentation}\n\\author{ocaml-alg}\n\n\\begin{document}\n\\maketitle\n\n",
    cst_end_document = "\\end{document}\n",
    cst_section_Coherence = "\\section{Coherence}\n\n",
    cst$31 = "]&",
    cst$30 = "]\\\\\n",
    cst$32 = "]\\\\\n&&",
    cst_src_term_ml = "src/term.ml",
    cst_x$0 = "x",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_get = runtime.caml_string_get,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   function caml_call10(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9){
    return (f.l >= 0 ? f.l : f.l = f.length) == 10
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9]);
   }
   function caml_call12(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11){
    return (f.l >= 0 ? f.l : f.l = f.length) == 12
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11]);
   }
   function caml_call14
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
    return (f.l >= 0 ? f.l : f.l = f.length) == 14
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
            : runtime.caml_call_gen
              (f,
               [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13]);
   }
   function caml_call16
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15){
    return (f.l >= 0 ? f.l : f.l = f.length) == 16
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14,
               a15)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14,
                a15]);
   }
   function caml_call22
   (f,
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    a11,
    a12,
    a13,
    a14,
    a15,
    a16,
    a17,
    a18,
    a19,
    a20,
    a21){
    return (f.l >= 0 ? f.l : f.l = f.length) == 22
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14,
               a15,
               a16,
               a17,
               a18,
               a19,
               a20,
               a21)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14,
                a15,
                a16,
                a17,
                a18,
                a19,
                a20,
                a21]);
   }
   function caml_call24
   (f,
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    a11,
    a12,
    a13,
    a14,
    a15,
    a16,
    a17,
    a18,
    a19,
    a20,
    a21,
    a22,
    a23){
    return (f.l >= 0 ? f.l : f.l = f.length) == 24
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14,
               a15,
               a16,
               a17,
               a18,
               a19,
               a20,
               a21,
               a22,
               a23)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14,
                a15,
                a16,
                a17,
                a18,
                a19,
                a20,
                a21,
                a22,
                a23]);
   }
   function caml_call26
   (f,
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    a11,
    a12,
    a13,
    a14,
    a15,
    a16,
    a17,
    a18,
    a19,
    a20,
    a21,
    a22,
    a23,
    a24,
    a25){
    return (f.l >= 0 ? f.l : f.l = f.length) == 26
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14,
               a15,
               a16,
               a17,
               a18,
               a19,
               a20,
               a21,
               a22,
               a23,
               a24,
               a25)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14,
                a15,
                a16,
                a17,
                a18,
                a19,
                a20,
                a21,
                a22,
                a23,
                a24,
                a25]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    partial = [2, 0, 0],
    partial$0 = [2, 0, [11, cst_ar_d, [2, 0, [11, cst$32, [2, 0, 0]]]]],
    partial$1 =
      [2,
       0,
       [11,
        cst_ar_d,
        [2,
         0,
         [11, cst$32, [2, 0, [11, cst_ar_d, [2, 0, [11, cst$32, [2, 0, 0]]]]]]]]],
    partial$2 = [11, cst$32, [2, 0, 0]],
    partial$3 =
      [2,
       0,
       [11,
        cst_ar_d,
        [2,
         0,
         [11,
          cst$32,
          [2,
           0,
           [11,
            cst_ar_d,
            [2, 0, [11, cst$32, [2, 0, [11, cst_ar_d, [2, 0, partial$2]]]]]]]]]]],
    partial$4 =
      [11, cst$32, [2, 0, [11, cst_ar_d, [2, 0, [11, cst$32, [2, 0, 0]]]]]],
    partial$5 =
      [2,
       0,
       [11,
        cst_ar_d,
        [2,
         0,
         [11,
          cst$32,
          [2,
           0,
           [11,
            cst_ar_d,
            [2, 0, [11, cst$32, [2, 0, [11, cst_ar_d, [2, 0, partial$4]]]]]]]]]]],
    partial$6 = [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$33, [2, 0, 0]]]]],
    partial$7 =
      [2,
       0,
       [11,
        cst_ar_d,
        [2,
         0,
         [11,
          cst$30,
          [2, 0, [11, cst_ar_rr, [2, 0, [11, cst$34, [2, 0, 0]]]]]]]]],
    partial$8 = [11, "']&&&", [2, 0, 0]],
    partial$9 =
      [2,
       0,
       [11,
        cst_ar_r$0,
        [2,
         0,
         [11,
          cst$31,
          [2,
           0,
           [11,
            cst_ar_d,
            [2, 0, [11, cst$30, [2, 0, [11, "\\ar[rrr,", [2, 0, partial$8]]]]]]]]]]],
    partial$10 =
      [11,
       cst$30,
       [2,
        0,
        [11,
         cst_ar_r$0,
         [2,
          0,
          [11,
           cst$33,
           [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$33, [2, 0, 0]]]]]]]]]],
    partial$11 =
      [2,
       0,
       [11,
        cst_ar_d,
        [2,
         0,
         [11,
          cst$32,
          [2,
           0,
           [11,
            cst_ar_d,
            [2, 0, [11, cst$32, [2, 0, [11, cst_ar_d, [2, 0, partial$10]]]]]]]]]]],
    partial$12 =
      [2,
       0,
       [11,
        cst$30,
        [2,
         0,
         [11,
          cst_ar_r$0,
          [2,
           0,
           [11,
            cst$33,
            [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$33, [2, 0, 0]]]]]]]]]]],
    partial$13 =
      [11,
       cst$32,
       [2,
        0,
        [11,
         cst_ar_d,
         [2,
          0,
          [11,
           cst$32,
           [2,
            0,
            [11,
             cst_ar_d,
             [2, 0, [11, cst$32, [2, 0, [11, cst_ar_d, partial$12]]]]]]]]]]],
    partial$14 =
      [2,
       0,
       [11,
        cst_ar_d,
        [2,
         0,
         [11,
          cst$32,
          [2,
           0,
           [11,
            cst_ar_d,
            [2, 0, [11, cst$32, [2, 0, [11, cst_ar_d, [2, 0, partial$13]]]]]]]]]]],
    partial$15 = [11, cst_ar_r$0, [2, 0, [11, cst$33, [2, 0, 0]]]],
    partial$16 =
      [2,
       0,
       [11,
        cst$32,
        [2,
         0,
         [11,
          cst_ar_d,
          [2,
           0,
           [11,
            cst$30,
            [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$33, [2, 0, partial$15]]]]]]]]]]],
    partial$17 =
      [11,
       cst$32,
       [2,
        0,
        [11,
         cst_ar_d,
         [2,
          0,
          [11,
           cst$32,
           [2,
            0,
            [11,
             cst_ar_d,
             [2, 0, [11, cst$32, [2, 0, [11, cst_ar_d, partial$16]]]]]]]]]]],
    partial$18 =
      [2,
       0,
       [11,
        cst_ar_d,
        [2,
         0,
         [11,
          cst$32,
          [2,
           0,
           [11,
            cst_ar_d,
            [2, 0, [11, cst$32, [2, 0, [11, cst_ar_d, [2, 0, partial$17]]]]]]]]]]],
    partial$19 =
      [11,
       cst_ar_r$0,
       [2,
        0,
        [11,
         cst$33,
         [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$33, [2, 0, 0]]]]]]]],
    partial$20 =
      [2,
       0,
       [11,
        cst$32,
        [2,
         0,
         [11,
          cst_ar_d,
          [2,
           0,
           [11,
            cst$32,
            [2, 0, [11, cst_ar_d, [2, 0, [11, cst$30, [2, 0, partial$19]]]]]]]]]]],
    partial$21 =
      [11,
       cst$32,
       [2,
        0,
        [11,
         cst_ar_d,
         [2,
          0,
          [11,
           cst$32,
           [2,
            0,
            [11,
             cst_ar_d,
             [2, 0, [11, cst$32, [2, 0, [11, cst_ar_d, partial$20]]]]]]]]]]],
    partial$22 =
      [2,
       0,
       [11,
        cst_ar_d,
        [2,
         0,
         [11,
          cst$32,
          [2,
           0,
           [11,
            cst_ar_d,
            [2, 0, [11, cst$32, [2, 0, [11, cst_ar_d, [2, 0, partial$21]]]]]]]]]]],
    partial$23 = [2, 0, [11, cst_ar_d, [2, 0, [11, cst$30, 0]]]],
    partial$24 = [2, 0, [11, cst_ar_d, [2, 0, [11, cst$30, 0]]]],
    cst$26 = cst$36,
    cst$29 = "<-,",
    cst$27 = '}"',
    cst$28 = '"{',
    cst$24 = cst$36,
    cst$25 = cst$38,
    cst$23 = cst$38,
    cst$19 = ".",
    cst$20 = cst$39,
    cst$21 = cst$40,
    cst$22 = cst$41,
    cst$17 = cst$42,
    cst$18 = cst$43,
    cst$12 = cst$44,
    cst$13 = cst$39,
    cst$14 = cst$40,
    cst$15 = cst$42,
    cst$16 = cst$43,
    cst$11 = cst$38,
    cst$9 = " -> ",
    cst$10 = " : ",
    cst$8 = cst$41,
    cst$7 = "+",
    cst$6 = cst$36,
    cst$3 = "/",
    cst$2 = "]",
    cst$4 = cst$44,
    cst$5 = "[",
    cst = cst$39,
    cst$0 = cst$44,
    cst$1 = cst$40,
    Alg_Extlib = global_data.Alg__Extlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Stdlib_Array = global_data.Stdlib__Array,
    Alg_Monoid = global_data.Alg__Monoid,
    Alg_Ring = global_data.Alg__Ring,
    Alg_Utils = global_data.Alg__Utils,
    Alg_Algebra = global_data.Alg__Algebra,
    _ay_ =
      [0,
       [11,
        "\nelim rule: [",
        [2, 0, [11, "] => ", [2, 0, [12, 10, [10, 0]]]]]],
       "\nelim rule: [%s] => %s\n%!"],
    _ax_ = [0, cst_src_term_ml, 1423, 6],
    cst_tex = ".tex",
    cst_ocaml_alg = "ocaml-alg",
    _av_ =
      [0,
       [11,
        "cd ",
        [2,
         0,
         [11,
          " && pdflatex ",
          [2, 0, [11, " && evince `basename ", [2, 0, [11, " .tex`.pdf", 0]]]]]]],
       "cd %s && pdflatex %s && evince `basename %s .tex`.pdf"],
    _aw_ = [0, cst_src_term_ml, 1409, 6],
    _ae_ =
      [0,
       [2,
        0,
        [11,
         "\\ar[d,bend right,",
         [2, 0, [11, "']\\ar[d,bend left,", [2, 0, [11, cst$30, [2, 0, 0]]]]]]],
       "%s\\ar[d,bend right,%s']\\ar[d,bend left,%s]\\\\\n%s"],
    _af_ =
      [0,
       [2,
        0,
        [11,
         "\\ar[dr,",
         [2,
          0,
          [11,
           cst_ar_r,
           [2,
            0,
            [11,
             cst$31,
             [2, 0, [11, cst_ar_d, [2, 0, [11, "]\\\\\n&", partial]]]]]]]]]],
       "%s\\ar[dr,%s']\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&%s"],
    _ag_ =
      [0,
       [2,
        0,
        [11,
         "\\ar[drr,",
         [2,
          0,
          [11,
           cst_ar_r,
           [2,
            0,
            [11,
             cst$31,
             [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$31, partial$0]]]]]]]]]],
       "%s\\ar[drr,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&&%s"],
    _ah_ =
      [0,
       [2,
        0,
        [11,
         "\\ar[ddrr,",
         [2,
          0,
          [11,
           cst_ar_r,
           [2,
            0,
            [11,
             cst$31,
             [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$31, partial$1]]]]]]]]]],
       "%s\\ar[ddrr,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s"],
    _ai_ =
      [0,
       [2,
        0,
        [11,
         "\\ar[dddrr,",
         [2,
          0,
          [11,
           cst_ar_r,
           [2,
            0,
            [11,
             cst$31,
             [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$31, partial$3]]]]]]]]]],
       "%s\\ar[dddrr,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s"],
    _aj_ =
      [0,
       [2,
        0,
        [11,
         "\\ar[ddddrr,",
         [2,
          0,
          [11,
           cst_ar_r,
           [2,
            0,
            [11,
             cst$31,
             [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$31, partial$5]]]]]]]]]],
       "%s\\ar[ddddrr,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s"],
    _ak_ =
      [0,
       [2,
        0,
        [11,
         cst_ar_d,
         [2,
          0,
          [11,
           cst_ar_r,
           [2,
            0,
            [11,
             cst$31,
             [2, 0, [11, cst_ar_d, [2, 0, [11, cst$30, partial$6]]]]]]]]]],
       "%s\\ar[d,%s']\\ar[r,%s]&%s\\ar[d,%s]\\\\\n%s\\ar[r,%s']&%s"],
    _al_ =
      [0,
       [2,
        0,
        [11,
         cst_ar_d,
         [2,
          0,
          [11,
           cst_ar_r,
           [2,
            0,
            [11,
             cst$31,
             [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$31, partial$7]]]]]]]]]],
       "%s\\ar[d,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n%s\\ar[rr,%s']&&%s"],
    _am_ =
      [0,
       [2,
        0,
        [11,
         cst_ar_d,
         [2,
          0,
          [11,
           cst_ar_r,
           [2,
            0,
            [11,
             cst$31,
             [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$31, partial$9]]]]]]]]]],
       "%s\\ar[d,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n%s\\ar[rrr,%s']&&&%s"],
    _an_ =
      [0,
       [2,
        0,
        [11,
         "\\ar[ddd,",
         [2,
          0,
          [11,
           cst_ar_r,
           [2,
            0,
            [11,
             cst$31,
             [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$31, partial$11]]]]]]]]]],
       "%s\\ar[ddd,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n%s\\ar[r,%s']&%s\\ar[r,%s']&%s"],
    _ao_ =
      [0,
       [2,
        0,
        [11,
         "\\ar[dddddd,",
         [2,
          0,
          [11,
           cst_ar_r,
           [2,
            0,
            [11,
             cst$31,
             [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$31, partial$14]]]]]]]]]],
       "%s\\ar[dddddd,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n%s\\ar[r,%s']&%s\\ar[r,%s']&%s"],
    _ap_ =
      [0,
       [2,
        0,
        [11,
         "\\ar[ddddddd,",
         [2,
          0,
          [11,
           cst_ar_r,
           [2,
            0,
            [11,
             cst$31,
             [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$31, partial$18]]]]]]]]]],
       "%s\\ar[ddddddd,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n%s\\ar[r,%s']&%s\\ar[r,%s']&%s"],
    _aq_ =
      [0,
       [2,
        0,
        [11,
         "\\ar[dddddddd,",
         [2,
          0,
          [11,
           cst_ar_r,
           [2,
            0,
            [11,
             cst$31,
             [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$31, partial$22]]]]]]]]]],
       "%s\\ar[dddddddd,%s']\\ar[r,%s]&%s\\ar[r,%s]&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n&&%s\\ar[d,%s]\\\\\n%s\\ar[r,%s']&%s\\ar[r,%s']&%s"],
    _U_ =
      [0,
       [2,
        0,
        [11,
         cst_ar_d,
         [2,
          0,
          [11,
           cst_ar_r,
           [2,
            0,
            [11,
             cst$31,
             [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$31, partial$23]]]]]]]]]],
       cst_s_ar_d_s_ar_r_s_s_ar_r_s_s],
    _W_ =
      [0,
       [2,
        0,
        [11,
         cst_ar_d,
         [2, 0, [11, cst$34, [2, 0, [11, cst_ar_d, [2, 0, [11, cst$30, 0]]]]]]]],
       cst_s_ar_d_s_s_ar_d_s],
    _V_ =
      [0,
       [2, 0, [11, cst_ar_rr, [2, 0, [11, cst$34, [2, 0, 0]]]]],
       "%s\\ar[rr,%s']&&%s"],
    _X_ =
      [0,
       [2,
        0,
        [11,
         cst_ar_d,
         [2,
          0,
          [11,
           cst_ar_r,
           [2,
            0,
            [11,
             cst$31,
             [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$31, partial$24]]]]]]]]]],
       cst_s_ar_d_s_ar_r_s_s_ar_r_s_s],
    _Z_ =
      [0,
       [2,
        0,
        [11,
         cst_ar_d,
         [2, 0, [11, cst$34, [2, 0, [11, cst_ar_d, [2, 0, [11, cst$30, 0]]]]]]]],
       cst_s_ar_d_s_s_ar_d_s],
    _Y_ =
      [0,
       [2,
        0,
        [11,
         cst_ar_r$0,
         [2,
          0,
          [11,
           cst$33,
           [2, 0, [11, cst_ar_r$0, [2, 0, [11, cst$33, [2, 0, 0]]]]]]]]],
       "%s\\ar[r,%s']&%s\\ar[r,%s']&%s"],
    ___ =
      [0,
       [11, "TODO: ", [4, 0, 0, 0, [11, ", ", [4, 0, 0, 0, [12, 10, 0]]]]],
       "TODO: %d, %d\n"],
    _$_ = [0, [2, 0, 0], cst_s],
    _aa_ =
      [0, [11, "zzlen: ", [4, 0, 0, 0, [12, 10, [10, 0]]]], "zzlen: %d\n%!"],
    _ab_ = [0, [2, 0, 0], cst_s],
    _ad_ =
      [0, [11, cst_ar_r$0, [2, 0, [11, cst$31, [2, 0, 0]]]], "\\ar[r,%s]&%s"],
    _ac_ = [0, [11, cst$35, 0], cst$35],
    _S_ =
      [0,
       [11, "print ", [2, 0, [11, cst$37, [2, 0, [12, 10, [10, 0]]]]]],
       "print %s: %s\n%!"],
    _T_ =
      [0,
       [11, "split: ", [2, 0, [11, " / ", [2, 0, [12, 10, [10, 0]]]]]],
       "split: %s / %s\n%!"],
    _ar_ =
      [0,
       [11, "\\noindent\n\\subsection*{", [2, 0, [11, "}\n", 0]]],
       "\\noindent\n\\subsection*{%s}\n"],
    _as_ = [0, [11, cst_begin_tikzcd, 0], cst_begin_tikzcd],
    _at_ = [0, [11, cst_end_tikzcd, 0], cst_end_tikzcd],
    _P_ =
      [0,
       [2, 0, [11, " &: ", [2, 0, [11, " \\to ", [2, 0, [11, cst$35, 0]]]]]],
       "%s &: %s \\to %s\\\\"],
    _O_ =
      [0,
       [11, cst_documentclass_a4paper_9pt_, 0],
       cst_documentclass_a4paper_9pt_],
    _Q_ =
      [0,
       [11,
        "\\section{Rules}\n\n\\begin{align*}\n",
        [2, 0, [11, "\n\\end{align*}\n\n", 0]]],
       "\\section{Rules}\n\n\\begin{align*}\n%s\n\\end{align*}\n\n"],
    _R_ = [0, [11, cst_section_Coherence, 0], cst_section_Coherence],
    _au_ = [0, [11, cst_end_document, 0], cst_end_document],
    _N_ = [0, [2, 0, [11, cst$37, [2, 0, [12, 10, 0]]]], "%s: %s\n"],
    _M_ = [0, cst_src_term_ml, 1122, 6],
    _L_ = [0, cst_src_term_ml, 1123, 6],
    _K_ = [0, cst_src_term_ml, 1112, 6],
    _u_ = [0, 1],
    _v_ = [0, 1],
    _x_ = [0, cst_src_term_ml, 900, 14],
    _F_ = [0, cst_src_term_ml, 1045, 13],
    _H_ = [0, cst_src_term_ml, 1055, 13],
    _G_ = [0, cst_src_term_ml, 1052, 13],
    _J_ = [0, cst_src_term_ml, 1082, 84],
    _I_ = [0, cst_src_term_ml, 1067, 15],
    _y_ = [0, cst_src_term_ml, 1007, 10],
    _z_ = [0, cst_src_term_ml, 1008, 10],
    _B_ = [0, cst_src_term_ml, 1013, 18],
    _A_ = [0, cst_src_term_ml, 1014, 15],
    _E_ = [0, cst_src_term_ml, 1003, 6],
    _D_ = [0, cst_src_term_ml, 1017, 6],
    _C_ = [0, cst_src_term_ml, 1018, 6],
    _w_ = [0, cst_src_term_ml, 891, 6],
    _t_ =
      [0,
       [11, "not confluent:\n", [2, 0, [12, 10, [2, 0, [12, 10, [10, 0]]]]]],
       "not confluent:\n%s\n%s\n%!"],
    _s_ =
      [0,
       [11,
        "add ",
        [2, 0, [12, 10, [2, 0, [12, 10, [2, 0, [11, "\n\n", [10, 0]]]]]]]],
       "add %s\n%s\n%s\n\n%!"],
    cst_K = "K",
    _r_ = [0, cst_src_term_ml, 748, 12],
    _o_ = [0, cst_src_term_ml, 676, 9],
    _q_ = [0, cst_src_term_ml, 719, 31],
    _p_ = [0, cst_src_term_ml, 709, 21],
    _n_ = [0, cst_src_term_ml, 662, 6],
    _m_ = [0, cst_src_term_ml, 553, 6],
    _l_ = [0, cst_src_term_ml, 554, 6],
    _k_ = [0, cst_src_term_ml, 546, 6],
    _j_ = [0, cst_src_term_ml, 543, 20],
    _i_ = [0, cst_src_term_ml, 448, 14],
    _h_ = [0, cst_src_term_ml, 383, 2],
    cst_1 = "1",
    cst_0 = "0",
    cst_Not_inversible = "Not inversible.",
    _d_ = [0, cst_src_term_ml, 137, 16],
    _e_ = [0, cst_src_term_ml, 138, 16],
    _c_ = [0, cst_src_term_ml, 95, 6],
    _b_ = [0, cst_src_term_ml, 85, 2],
    _a_ = [0, cst_x$0, "y", "z", "t", "u", "v", "w"],
    cst_x = cst_x$0,
    cst_Alg_Term_Not_unifiable = "Alg.Term.Not_unifiable",
    cst_Alg_Term_RS_Not_confluent = "Alg.Term.RS.Not_confluent";
   function name(f){return f[2];}
   function weight(f){return f[1];}
   function arity(f){return f[3];}
   function make(to_string, opt, name, arity){
    if(opt) var sth = opt[1], weight = sth; else var weight = 0;
    if(to_string)
     var to_string$0 = to_string[1], to_string$1 = to_string$0;
    else
     var
      to_string$1 =
        function(a){
         var
          _iD_ = caml_call2(Alg_Extlib[5][6], cst$0, a),
          _iE_ = caml_call2(Stdlib[28], _iD_, cst),
          _iF_ = caml_call2(Stdlib[28], cst$1, _iE_);
         return caml_call2(Stdlib[28], name, _iF_);
        };
    return [0, weight, name, arity, to_string$1];
   }
   function eq(f1, f2){
    var _iA_ = caml_string_equal(f1[2], f2[2]);
    if(_iA_)
     var
      _iB_ = f1[3] === f2[3] ? 1 : 0,
      _iC_ = _iB_ ? f1[1] === f2[1] ? 1 : 0 : _iB_;
    else
     var _iC_ = _iA_;
    return _iC_;
   }
   function to_string(f, a){return caml_call1(f[4], a);}
   var Op = [0, name, weight, arity, make, eq, to_string], n = [0, -1];
   function fresh(param){n[1]++; return [0, n[1]];}
   function eq$0(x, y){return x === y ? 1 : 0;}
   var compare = runtime.caml_compare;
   function namer(param){
    var f = caml_call1(Alg_Utils[1], eq$0);
    return function(x){
     var
      _ix_ = caml_call1(f, x),
      _iy_ = caml_call1(Stdlib[33], _ix_),
      _iz_ = caml_call1(Alg_Extlib[5][65], _iy_);
     return caml_call2(Stdlib[28], cst_x, _iz_);};
   }
   function namer_natural(param){
    var f = caml_call1(Alg_Utils[1], eq$0), name = _a_.slice();
    return function(x){
     var _iw_ = caml_call1(f, x);
     return runtime.caml_check_bound(name, _iw_)[1 + _iw_];};
   }
   var
    to_string$0 = namer(0),
    Var = [0, fresh, eq$0, compare, namer, namer_natural, to_string$0];
   function var$0(param){return [1, caml_call1(Var[1], 0)];}
   function app(f, a){
    var _iv_ = caml_call1(Op[3], f);
    if(caml_call1(Alg_Extlib[4][1], a) === _iv_) return [0, f, a];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function parser(s){
    function term(s){
     var s$0 = caml_call1(Alg_Extlib[5][23], s);
     try{
      var
       n = caml_call2(Alg_Extlib[5][35], s$0, 40),
       f = caml_call3(Alg_Extlib[5][15], s$0, 0, n);
      if(41 !== caml_string_get(s$0, caml_ml_string_length(s$0) - 1 | 0))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
      var
       a =
         caml_call3
          (Alg_Extlib[5][15],
           s$0,
           n + 1 | 0,
           (caml_ml_string_length(s$0) - (n + 1 | 0) | 0) - 1 | 0);
      if(caml_string_equal(a, cst$36))
       var a$0 = 0;
      else
       var
        k = [0, 0],
        p =
          function(param){
           var switcher = param - 40 | 0;
           if(4 >= switcher >>> 0)
            switch(switcher){
              case 0:
               k[1]++; return 0;
              case 1:
               k[1] += -1; return 0;
              case 4:
               return 0 === k[1] ? 1 : 0;
            }
           return 0;
          },
        a$0 = caml_call2(Alg_Extlib[5][68], p, a);
      var
       a$1 = caml_call2(Alg_Extlib[4][19], term, a$0),
       _it_ = [0, 3257473, [0, f, a$1]];
      return _it_;
     }
     catch(_iu_){
      var _is_ = caml_wrap_exception(_iu_);
      if(_is_ === Stdlib[8]) return [0, 4298439, s$0];
      throw caml_maybe_attach_backtrace(_is_, 0);
     }
    }
    function step(s){
     var s$0 = caml_call1(Alg_Extlib[5][23], s);
     return 45 === caml_string_get(s$0, caml_ml_string_length(s$0) - 1 | 0)
             ? [0,
               3654865,
               term
                (caml_call3
                  (Alg_Extlib[5][15],
                   s$0,
                   0,
                   caml_ml_string_length(s$0) - 1 | 0))]
             : term(s$0);
    }
    var l = caml_call2(Alg_Extlib[5][16], 46, s);
    return 1 === caml_call1(Alg_Extlib[4][1], l)
            ? step(caml_call1(Alg_Extlib[4][5], l))
            : [0, 4150143, caml_call2(Alg_Extlib[4][19], step, l)];
   }
   var vars = [0, 0];
   function parse_var(x){
    if(1 - caml_call2(Alg_Extlib[4][50], x, vars[1])){
     var _ir_ = vars[1];
     vars[1] = [0, [0, x, caml_call1(Var[1], 0)], _ir_];
    }
    return caml_call2(Alg_Extlib[4][46], x, vars[1]);
   }
   function parse(ops, s){
    function aux(param){
     var _ip_ = param[1];
     if(4150143 <= _ip_){
      if(4298439 > _ip_)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      var x = param[2];
      return [1, parse_var(x)];
     }
     if(3654865 <= _ip_)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
     var match = param[2], a = match[2], f = match[1];
     function _iq_(o){return caml_string_equal(caml_call1(Op[1], o), f);}
     var
      f$0 = caml_call2(Alg_Extlib[4][38], _iq_, ops),
      a$0 = caml_call2(Alg_Extlib[4][19], aux, a);
     return app(f$0, a$0);
    }
    return aux(parser(s));
   }
   function eq$1(t1, t2){
    if(0 === t1[0]){
     var a1 = t1[2], f1 = t1[1];
     if(0 === t2[0]){
      var a2 = t2[2], f2 = t2[1], _il_ = caml_call2(Op[5], f1, f2);
      if(_il_){
       var
        _im_ = caml_call1(Alg_Extlib[4][1], a2),
        _in_ = caml_call1(Alg_Extlib[4][1], a1) === _im_ ? 1 : 0;
       if(_in_) return caml_call3(Alg_Extlib[4][34], eq$1, a1, a2);
       var _io_ = _in_;
      }
      else
       var _io_ = _il_;
      return _io_;
     }
    }
    else{
     var x = t1[1];
     if(0 !== t2[0]){var y = t2[1]; return caml_call2(Var[2], x, y);}
    }
    return 0;
   }
   function to_string$1(opt, param){
    if(opt) var sth = opt[1], var$0 = sth; else var var$0 = Var[6];
    if(0 === param[0]){
     var
      a = param[2],
      f = param[1],
      _ih_ = [0, var$0],
      _ii_ = function(_ik_){return to_string$1(_ih_, _ik_);},
      _ij_ = caml_call2(Alg_Extlib[4][19], _ii_, a);
     return caml_call2(Op[6], f, _ij_);
    }
    var x = param[1];
    return caml_call1(var$0, x);
   }
   function string_of_term(var$0){
    return function(_ig_){return to_string$1(var$0, _ig_);};
   }
   function is_var(param){return 0 === param[0] ? 0 : 1;}
   function get_var(param){
    if(0 === param[0]) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var x = param[1];
    return x;
   }
   function vars$0(t){
    function aux(vars, param){
     if(0 === param[0]){
      var a = param[2], _ie_ = function(vars, t){return aux(vars, t);};
      return caml_call3(Alg_Extlib[4][25], _ie_, vars, a);
     }
     var x = param[1], _if_ = caml_call1(Var[2], x);
     return caml_call2(Alg_Extlib[4][33], _if_, vars) ? vars : [0, x, vars];
    }
    var _id_ = aux(0, t);
    return caml_call1(Alg_Extlib[4][9], _id_);
   }
   function occurs(x, param){
    if(0 === param[0]){
     var a = param[2], _ib_ = function(_ic_){return occurs(x, _ic_);};
     return caml_call2(Alg_Extlib[4][33], _ib_, a);
    }
    var y = param[1];
    return caml_call2(Var[2], x, y);
   }
   function gt(ge_op, t, u){
    if(0 !== u[0]){
     var x = u[1], _ia_ = 1 - eq$1(t, u);
     return _ia_ ? occurs(x, t) : _ia_;
    }
    if(0 !== t[0]) return 0;
    var l2 = u[2], g = u[1], l1 = t[2], f = t[1];
    function _h8_(t){return ge(ge_op, t, u);}
    if(caml_call2(Alg_Extlib[4][33], _h8_, l1)) return 1;
    if(! caml_call2(Op[5], f, g)){
     if(! caml_call2(ge_op, f, g)) return 0;
     var _h$_ = function(u){return gt(ge_op, t, u);};
     return caml_call2(Alg_Extlib[4][32], _h$_, l2);
    }
    function _h9_(u){return gt(ge_op, t, u);}
    var _h__ = caml_call2(Alg_Extlib[4][32], _h9_, l2);
    if(! _h__) return _h__;
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0 && l2$0){
      var x2 = l2$0[1], l1$1 = l1$0[2], x1 = l1$0[1], l2$1 = l2$0[2];
      if(eq$1(x1, x2)){var l1$0 = l1$1, l2$0 = l2$1; continue;}
      if(gt(ge_op, x1, x2)) return 1;
     }
     return 0;
    }
   }
   function ge(ge_op, t, u){
    var _h7_ = eq$1(t, u);
    return _h7_ ? _h7_ : gt(ge_op, t, u);
   }
   var LPO = [0, gt, ge];
   function to_string$2(var$0, s){
    function _h0_(param){
     var
      t = param[2],
      x = param[1],
      _h4_ = to_string$1(var$0, [1, x]),
      _h5_ = caml_call2(Stdlib[28], cst$3, _h4_),
      _h6_ = to_string$1(var$0, t);
     return caml_call2(Stdlib[28], _h6_, _h5_);
    }
    var
     _h1_ = caml_call2(Alg_Extlib[4][19], _h0_, s),
     _h2_ = caml_call2(Alg_Extlib[5][6], cst$4, _h1_),
     _h3_ = caml_call2(Stdlib[28], _h2_, cst$2);
    return caml_call2(Stdlib[28], cst$5, _h3_);
   }
   var empty = 0;
   function id(vars){
    function _hZ_(x){return [0, x, [1, x]];}
    return caml_call2(Alg_Extlib[4][19], _hZ_, vars);
   }
   function rename(vars){
    function _hY_(x){return [0, x, [1, caml_call1(Var[1], 0)]];}
    return caml_call2(Alg_Extlib[4][19], _hY_, vars);
   }
   function simple(x, t){return [0, [0, x, t], 0];}
   function add(s, x, t){return [0, [0, x, t], s];}
   function find(s, x){
    var s$0 = s;
    for(;;){
     if(! s$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var s$1 = s$0[2], match = s$0[1], t = match[2], y = match[1];
     if(caml_call2(Var[2], x, y)) return t;
     var s$0 = s$1;
    }
   }
   function app$0(s, param){
    if(0 === param[0]){
     var
      a = param[2],
      g = param[1],
      _hT_ = function(_hX_){return app$0(s, _hX_);};
     return [0, g, caml_call2(Alg_Extlib[4][19], _hT_, a)];
    }
    var x = param[1];
    try{var _hV_ = find(s, x); return _hV_;}
    catch(_hW_){
     var _hU_ = caml_wrap_exception(_hW_);
     if(_hU_ === Stdlib[8]) return [1, x];
     throw caml_maybe_attach_backtrace(_hU_, 0);
    }
   }
   function compose(s$0, s){
    function _hS_(param){
     var t = param[2], x = param[1];
     return [0, x, app$0(s, t)];
    }
    return caml_call2(Alg_Extlib[4][19], _hS_, s$0);
   }
   function eq$2(s1, s2){
    function included(s1, s2){
     function _hR_(param){
      var t = param[2], x = param[1];
      return eq$1(t, app$0(s2, [1, x]));
     }
     return caml_call2(Alg_Extlib[4][32], _hR_, s1);
    }
    var _hQ_ = included(s1, s2);
    return _hQ_ ? included(s2, s1) : _hQ_;
   }
   function is_renaming(s){
    function _hP_(param){var t = param[2]; return is_var(t);}
    return caml_call2(Alg_Extlib[4][32], _hP_, s);
   }
   function is_injective_renaming(s){
    var vars = 0, param = s;
    for(;;){
     if(! param) return 1;
     var s$0 = param[2], t = param[1][2];
     if(! is_var(t)) return 0;
     var x = get_var(t), _hO_ = caml_call1(Var[2], x);
     if(caml_call2(Alg_Extlib[4][33], _hO_, vars)) return 0;
     var vars$0 = [0, x, vars], vars = vars$0, param = s$0;
    }
   }
   function inv(s){
    function _hN_(param){
     var t = param[2], x = param[1];
     if(0 === t[0]) return caml_call1(Stdlib[2], cst_Not_inversible);
     var y = t[1];
     return [0, y, [1, x]];
    }
    return caml_call2(Alg_Extlib[4][19], _hN_, s);
   }
   function domain(s){
    function _hL_(_hM_){return _hM_[1];}
    return caml_call2(Alg_Extlib[4][19], _hL_, s);
   }
   function in_dom(s, x){
    function _hK_(param){var y = param[1]; return caml_call2(Var[2], y, x);}
    return caml_call2(Alg_Extlib[4][33], _hK_, s);
   }
   function restrict(vars, s){
    function _hI_(param){
     var x = param[1], _hJ_ = caml_call1(Var[2], x);
     return caml_call2(Alg_Extlib[4][33], _hJ_, vars);
    }
    return caml_call2(Alg_Extlib[4][41], _hI_, s);
   }
   var
    Substitution =
      [0,
       to_string$2,
       empty,
       id,
       rename,
       simple,
       add,
       find,
       app$0,
       compose,
       eq$2,
       is_renaming,
       is_injective_renaming,
       inv,
       domain,
       in_dom,
       restrict],
    W = caml_call1(Alg_Monoid[7], [0, Var[2], Var[6], Var[3]]),
    _f_ = [0, W[10], W[7], W[6], W[8], W[2], W[12], W[1]],
    include = caml_call1(caml_call1(Alg_Algebra[1][1], Alg_Ring[2]), _f_),
    Ring = include[1],
    E = include[2],
    zero = include[3],
    cinj = include[4],
    inj = include[5],
    coeff = include[6],
    included = include[7],
    eq$3 = include[8],
    compare$0 = include[9],
    add_monomial = include[10],
    add$0 = include[11],
    cmul = include[12],
    neg = include[13],
    sub = include[14],
    map = include[16],
    iter = include[17],
    Map = include[18],
    Pres = include[19],
    one = include[20],
    mul_monomial = include[21],
    mul = include[22],
    leading = include[23],
    is_commutative = W[1];
   function to_string$3(p){
    if(caml_call2(eq$3, p, zero)) return cst_0;
    var ans = [0, cst$6];
    function w(s){ans[1] = caml_call2(Stdlib[28], ans[1], s); return 0;}
    caml_call2
     (iter,
      function(a, u){
       var
        a$0 =
          0 <= a
           ? runtime.caml_string_notequal(ans[1], cst$36) ? (w(cst$7), a) : a
           : (w(cst$8), - a | 0);
       if
        (caml_call2(Alg_Ring[2][1], a$0, Alg_Ring[2][6])
         && caml_call2(W[10], u, W[6]))
        return w(cst_1);
       if(1 - caml_call2(Alg_Ring[2][1], a$0, Alg_Ring[2][6]))
        w(caml_call1(Alg_Ring[2][7], a$0));
       var _hH_ = 1 - caml_call2(W[10], u, W[6]);
       return _hH_ ? w(caml_call1(W[2], u)) : _hH_;
      },
      p);
    return ans[1];
   }
   function var$1(x){return caml_call1(inj, caml_call1(W[13], x));}
   function pow(u, n){return caml_call4(Alg_Monoid[2], one, mul, u, n);}
   var
    P =
      [0,
       Ring,
       E,
       zero,
       cinj,
       inj,
       coeff,
       included,
       eq$3,
       compare$0,
       add_monomial,
       add$0,
       cmul,
       neg,
       sub,
       map,
       iter,
       Map,
       Pres,
       one,
       mul_monomial,
       mul,
       leading,
       is_commutative,
       to_string$3,
       var$1,
       pow],
    include$0 =
      caml_call1(W[15], [0, P[8], P[21], P[19], P[26], P[24], P[9], P[23]]),
    E$0 = include$0[1],
    of_list = include$0[2],
    app$1 = include$0[3],
    _g_ = include$0[4];
   function bind(s, p){
    function _hG_(u){return caml_call2(_g_, s, u);}
    return caml_call2(P[15], _hG_, p);
   }
   var
    S = [0, E$0, of_list, app$1, bind],
    Ring$0 = P[1],
    E$1 = P[2],
    zero$0 = P[3],
    cinj$0 = P[4],
    inj$0 = P[5],
    coeff$0 = P[6],
    included$0 = P[7],
    eq$4 = P[8],
    compare$1 = P[9],
    add_monomial$0 = P[10],
    add$1 = P[11],
    cmul$0 = P[12],
    neg$0 = P[13],
    sub$0 = P[14],
    map$0 = P[15],
    iter$0 = P[16],
    Map$0 = P[17],
    Pres$0 = P[18],
    one$0 = P[19],
    mul_monomial$0 = P[20],
    mul$0 = P[21],
    leading$0 = P[22],
    is_commutative$0 = P[23],
    to_string$4 = P[24],
    var$2 = P[25],
    pow$0 = P[26];
   function interpretation(op, t){
    if(0 === t[0]){
     var
      l = t[2],
      f = t[1],
      _hC_ = function(i){return caml_call1(Var[1], 0);},
      _hD_ = caml_call1(Op[3], f),
      v = caml_call2(Alg_Extlib[4][10], _hD_, _hC_),
      _hE_ = function(x, t){return [0, x, interpretation(op, t)];},
      s = caml_call3(Alg_Extlib[4][28], _hE_, v, l),
      s$0 = caml_call1(S[2], s),
      _hF_ = caml_call2(op, f, caml_call1(Stdlib_Array[10], v));
     return caml_call2(S[4], s$0, _hF_);
    }
    var x = t[1];
    return caml_call1(P[25], x);
   }
   var
    Polynomial =
      [0,
       W,
       P,
       S,
       Ring$0,
       E$1,
       zero$0,
       cinj$0,
       inj$0,
       coeff$0,
       included$0,
       eq$4,
       compare$1,
       add_monomial$0,
       add$1,
       cmul$0,
       neg$0,
       sub$0,
       map$0,
       iter$0,
       Map$0,
       Pres$0,
       one$0,
       mul_monomial$0,
       mul$0,
       leading$0,
       is_commutative$0,
       to_string$4,
       var$2,
       pow$0,
       interpretation],
    Interpretation = [0, Polynomial],
    Not_unifiable = [248, cst_Alg_Term_Not_unifiable, caml_fresh_oo_id(0)];
   function unify(t1, t2){
    var s$3 = Substitution[2], q$4 = [0, [0, t1, t2], 0], q = q$4, s = s$3;
    for(;;){
     if(! q){
      var _hA_ = caml_call2(Substitution[8], s, t2);
      if(eq$1(caml_call2(Substitution[8], s, t1), _hA_)) return s;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
     }
     var q$0 = q[2], p = q[1], t = p[1];
     if(0 !== t[0]){
      var t$0 = p[2], x$0 = t[1];
      if(occurs(x$0, t$0))
       throw caml_maybe_attach_backtrace(Not_unifiable, 1);
      var
       s$0 = caml_call2(Substitution[5], x$0, t$0),
       f = caml_call1(Substitution[8], s$0),
       _hz_ =
         function(f){
           return function(param){
            var t2 = param[2], t1 = param[1], _hB_ = caml_call1(f, t2);
            return [0, caml_call1(f, t1), _hB_];};
          }
          (f),
       q$3 = caml_call2(Alg_Extlib[4][19], _hz_, q$0),
       s$1 = caml_call2(Substitution[9], s, s$0),
       s$2 = caml_call3(Substitution[6], s$1, x$0, t$0),
       q = q$3,
       s = s$2;
      continue;
     }
     var match = p[2], a1 = t[2], f1 = t[1];
     if(0 !== match[0]){
      var x = p[2][1], q$2 = [0, [0, [1, x], t], q$0], q = q$2;
      continue;
     }
     var a2 = match[2], f2 = match[1];
     if(1 - caml_call2(Op[5], f1, f2))
      throw caml_maybe_attach_backtrace(Not_unifiable, 1);
     var
      _hy_ = caml_call3(Alg_Extlib[4][28], Alg_Extlib[1], a1, a2),
      q$1 = caml_call2(Stdlib[37], _hy_, q$0),
      q = q$1;
    }
   }
   function matches(t1, t2){
    var s$1 = Substitution[2], q$2 = [0, [0, t1, t2], 0], q = q$2, s = s$1;
    for(;;){
     if(! q) return s;
     var q$0 = q[2], p = q[1], match = p[1];
     if(0 === match[0]){
      var match$0 = p[2], a1 = match[2], f1 = match[1];
      if(0 !== match$0[0])
       throw caml_maybe_attach_backtrace(Not_unifiable, 1);
      var a2 = match$0[2], f2 = match$0[1];
      if(1 - caml_call2(Op[5], f1, f2))
       throw caml_maybe_attach_backtrace(Not_unifiable, 1);
      var
       _hx_ = caml_call3(Alg_Extlib[4][28], Alg_Extlib[1], a1, a2),
       q$1 = caml_call2(Stdlib[37], _hx_, q$0),
       q = q$1;
      continue;
     }
     var t = p[2], x = match[1];
     if(! caml_call2(Substitution[15], s, x)){
      var s$0 = caml_call3(Substitution[6], s, x, t), q = q$0, s = s$0;
      continue;
     }
     if(! eq$1(caml_call2(Substitution[8], s, [1, x]), t))
      throw caml_maybe_attach_backtrace(Not_unifiable, 1);
     var q = q$0;
    }
   }
   function equivalent(opt, t1){
    if(opt) var sth = opt[1], s = sth; else var s = Substitution[2];
    return function(t2){
     try{
      var q$2 = [0, [0, t1, t2], 0], q = q$2, s$0 = s;
      for(;;){
       if(! q){var _hv_ = 1; return _hv_;}
       var q$0 = q[2], p = q[1], _hs_ = p[1];
       if(0 === _hs_[0]){
        var match = p[2], a1 = _hs_[2], f1 = _hs_[1];
        if(0 === match[0]){
         var a2 = match[2], f2 = match[1];
         if(1 - caml_call2(Op[5], f1, f2))
          throw caml_maybe_attach_backtrace(Not_unifiable, 1);
         var
          _ht_ = caml_call3(Alg_Extlib[4][28], Alg_Extlib[1], a1, a2),
          q$1 = caml_call2(Stdlib[37], _ht_, q$0),
          q = q$1;
         continue;
        }
       }
       else{
        var x = _hs_[1], match$0 = p[2];
        if(0 !== match$0[0]){
         var y = match$0[1];
         if(! caml_call2(Substitution[15], s$0, x)){
          var
           s$1 = caml_call3(Substitution[6], s$0, x, [1, y]),
           q = q$0,
           s$0 = s$1;
          continue;
         }
         if(! eq$1(caml_call2(Substitution[8], s$0, [1, x]), [1, y]))
          throw caml_maybe_attach_backtrace(Not_unifiable, 1);
         var q = q$0;
         continue;
        }
       }
       throw caml_maybe_attach_backtrace(Not_unifiable, 1);
      }
     }
     catch(_hw_){
      var _hu_ = caml_wrap_exception(_hw_);
      if(_hu_ === Not_unifiable) return 0;
      throw caml_maybe_attach_backtrace(_hu_, 0);
     }};
   }
   function list_remove_nth(n, l){
    var n$0 = n, p = 0, param = l;
    for(;;){
     if(! param)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     var l$0 = param[2], x = param[1];
     if(0 === n$0) return [0, caml_call1(Alg_Extlib[4][9], p), l$0];
     var p$0 = [0, x, p], n$1 = n$0 - 1 | 0, n$0 = n$1, p = p$0, param = l$0;
    }
   }
   function make$0(r, s, t){return [0, r, s, t];}
   function of_string(ops, r, s, t){
    var s$0 = parse(ops, s), t$0 = parse(ops, t);
    return [0, r, s$0, t$0];
   }
   function name$0(param){var r = param[1]; return r;}
   function source(param){var s = param[2]; return s;}
   function target(param){var t = param[3]; return t;}
   function vars$1(r){return vars$0(r[2]);}
   function arity$0(r){
    var _hr_ = vars$1(r);
    return caml_call1(Alg_Extlib[4][1], _hr_);
   }
   function args(r, s){
    var vars = vars$1(r);
    function _hk_(param, _hn_){
     var y = _hn_[1], x = param[1];
     function _ho_(z){return caml_call2(Var[2], z, y);}
     var _hp_ = caml_call2(Alg_Extlib[4][63], _ho_, vars);
     function _hq_(z){return caml_call2(Var[2], z, x);}
     return caml_call2(Alg_Extlib[4][63], _hq_, vars) - _hp_ | 0;
    }
    var args = caml_call2(Alg_Extlib[4][56], _hk_, s);
    function _hl_(_hm_){return _hm_[2];}
    return caml_call2(Alg_Extlib[4][19], _hl_, args);
   }
   function args_subst(r, a){
    var _hi_ = vars$1(r);
    function _hj_(x, t){return [0, x, t];}
    return caml_call3(Alg_Extlib[4][28], _hj_, _hi_, a);
   }
   function to_string$5(var$0, r){
    var
     s = to_string$1(var$0, r[2]),
     t = to_string$1(var$0, r[3]),
     _hf_ = caml_call2(Stdlib[28], cst$9, t),
     _hg_ = caml_call2(Stdlib[28], s, _hf_),
     _hh_ = caml_call2(Stdlib[28], cst$10, _hg_);
    return caml_call2(Stdlib[28], r[1], _hh_);
   }
   function eq$5(r1, r2){return caml_string_equal(r1[1], r2[1]);}
   var
    Rule =
      [0,
       make$0,
       of_string,
       name$0,
       source,
       target,
       vars$1,
       arity$0,
       args,
       args_subst,
       to_string$5,
       eq$5];
   function operations(rs){return rs[1];}
   function rules(rs){return rs[2];}
   function filter(p, rs){
    var _he_ = caml_call2(Alg_Extlib[4][41], p, rs[2]);
    return [0, rs[1], _he_];
   }
   function make$1(operations, rules){return [0, operations, rules];}
   function empty$0(ops){return [0, ops, 0];}
   function to_string$6(opt, rs){
    if(opt) var sth = opt[1], var$0 = sth; else var var$0 = Var[4];
    var _ha_ = rs[2];
    function _hb_(r){
     var _hd_ = [0, caml_call1(var$0, 0)];
     return caml_call2(Rule[10], _hd_, r);
    }
    var _hc_ = caml_call2(Alg_Extlib[4][19], _hb_, _ha_);
    return caml_call2(Alg_Extlib[5][6], cst$11, _hc_);
   }
   function find$0(rs, r){
    var _g__ = rs[2];
    function _g$_(r$0){return caml_string_equal(caml_call1(Rule[3], r$0), r);}
    return caml_call2(Alg_Extlib[4][38], _g$_, _g__);
   }
   function of_term(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   }
   function tapp(f, a1, s, a2){
    var _g8_ = caml_call1(Op[3], f), _g9_ = caml_call1(Alg_Extlib[4][1], a2);
    if(((caml_call1(Alg_Extlib[4][1], a1) + 1 | 0) + _g9_ | 0) === _g8_)
     return [0, f, a1, s, a2];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   function rapp(r, s){
    var vr = caml_call1(Rule[6], r), vs = caml_call1(Substitution[14], s);
    function _g4_(x){
     var _g7_ = caml_call1(Var[2], x);
     return caml_call2(Alg_Extlib[4][33], _g7_, vs);
    }
    if(! caml_call2(Alg_Extlib[4][32], _g4_, vr))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
    function _g5_(x){
     var _g6_ = caml_call1(Var[2], x);
     return caml_call2(Alg_Extlib[4][33], _g6_, vr);
    }
    if(caml_call2(Alg_Extlib[4][32], _g5_, vs)) return [1, r, s];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
   }
   function subst(s, param){
    if(0 === param[0]){
     var
      a2 = param[4],
      st = param[3],
      a1 = param[2],
      f = param[1],
      _g0_ = caml_call1(Substitution[8], s),
      _g1_ = caml_call2(Alg_Extlib[4][19], _g0_, a2),
      _g2_ = subst(s, st),
      _g3_ = caml_call1(Substitution[8], s);
     return tapp(f, caml_call2(Alg_Extlib[4][19], _g3_, a1), _g2_, _g1_);
    }
    var s$0 = param[2], r = param[1];
    return rapp(r, caml_call2(Substitution[9], s$0, s));
   }
   function source$0(param){
    if(0 === param[0]){
     var
      a2 = param[4],
      s = param[3],
      a1 = param[2],
      f = param[1],
      _gX_ = [0, source$0(s), 0],
      _gY_ = caml_call2(Stdlib[37], _gX_, a2);
     return app(f, caml_call2(Stdlib[37], a1, _gY_));
    }
    var s$0 = param[2], r = param[1], _gZ_ = caml_call1(Rule[4], r);
    return caml_call2(Substitution[8], s$0, _gZ_);
   }
   function target$0(param){
    if(0 === param[0]){
     var
      a2 = param[4],
      s = param[3],
      a1 = param[2],
      f = param[1],
      _gU_ = [0, target$0(s), 0],
      _gV_ = caml_call2(Stdlib[37], _gU_, a2);
     return app(f, caml_call2(Stdlib[37], a1, _gV_));
    }
    var s$0 = param[2], r = param[1], _gW_ = caml_call1(Rule[5], r);
    return caml_call2(Substitution[8], s$0, _gW_);
   }
   function label(opt, param){
    if(opt) var sth = opt[1], var$0 = sth; else var var$0 = Var[6];
    if(0 === param[0]){
     var
      a2 = param[4],
      s = param[3],
      a1 = param[2],
      f = param[1],
      _gM_ = string_of_term([0, var$0]),
      a1$0 = caml_call2(Alg_Extlib[4][19], _gM_, a1),
      _gN_ = string_of_term([0, var$0]),
      a2$0 = caml_call2(Alg_Extlib[4][19], _gN_, a2),
      _gO_ = [0, label([0, var$0], s), 0],
      _gP_ = caml_call2(Stdlib[37], _gO_, a2$0),
      a = caml_call2(Stdlib[37], a1$0, _gP_);
     return caml_call2(Op[6], f, a);
    }
    var
     s$0 = param[2],
     r = param[1],
     a$0 = caml_call2(Rule[8], r, s$0),
     _gQ_ = string_of_term([0, var$0]),
     a$1 = caml_call2(Alg_Extlib[4][19], _gQ_, a$0),
     a$2 = caml_call2(Alg_Extlib[5][6], cst$12, a$1),
     _gR_ = caml_call2(Stdlib[28], a$2, cst$13),
     _gS_ = caml_call2(Stdlib[28], cst$14, _gR_),
     _gT_ = caml_call1(Rule[3], r);
    return caml_call2(Stdlib[28], _gT_, _gS_);
   }
   function to_string$7(var$0, s){
    var
     _gE_ = target$0(s),
     _gF_ = string_of_term(var$0)(_gE_),
     _gG_ = caml_call2(Stdlib[28], cst$15, _gF_),
     _gH_ = label(var$0, s),
     _gI_ = caml_call2(Stdlib[28], _gH_, _gG_),
     _gJ_ = caml_call2(Stdlib[28], cst$16, _gI_),
     _gK_ = source$0(s),
     _gL_ = string_of_term(var$0)(_gK_);
    return caml_call2(Stdlib[28], _gL_, _gJ_);
   }
   function rule(param){
    var param$0 = param;
    for(;;){
     if(0 === param$0[0]){var s = param$0[3], param$0 = s; continue;}
     var r = param$0[1];
     return r;
    }
   }
   function has_context(param){
    if(0 === param[0]) return 1;
    var s = param[2];
    return 1 - caml_call1(Substitution[12], s);
   }
   function eq$6(s1, s2){
    if(0 === s1[0]){
     var a2 = s1[4], s = s1[3], a1 = s1[2], f = s1[1];
     if(0 === s2[0]){
      var
       a2$0 = s2[4],
       s$0 = s2[3],
       a1$0 = s2[2],
       f$0 = s2[1],
       _gv_ = caml_call2(Op[5], f, f$0);
      if(_gv_){
       var
        _gw_ = caml_call1(Alg_Extlib[4][1], a1$0),
        _gx_ = caml_call1(Alg_Extlib[4][1], a1) === _gw_ ? 1 : 0;
       if(_gx_){
        var
         _gy_ = caml_call1(Alg_Extlib[4][1], a2$0),
         _gz_ = caml_call1(Alg_Extlib[4][1], a2) === _gy_ ? 1 : 0;
        if(_gz_){
         var _gA_ = caml_call3(Alg_Extlib[4][34], eq$1, a1, a1$0);
         if(_gA_){
          var _gB_ = eq$6(s, s$0);
          if(_gB_) return caml_call3(Alg_Extlib[4][34], eq$1, a2, a2$0);
          var _gC_ = _gB_;
         }
         else
          var _gC_ = _gA_;
        }
        else
         var _gC_ = _gz_;
       }
       else
        var _gC_ = _gx_;
      }
      else
       var _gC_ = _gv_;
      return _gC_;
     }
    }
    else{
     var s$1 = s1[2], r = s1[1];
     if(0 !== s2[0]){
      var s$2 = s2[2], r$0 = s2[1], _gD_ = caml_call2(Rule[11], r, r$0);
      return _gD_ ? caml_call2(Substitution[10], s$1, s$2) : _gD_;
     }
    }
    return 0;
   }
   function has_rule(r, param){
    var param$0 = param;
    for(;;){
     if(0 === param$0[0]){var s = param$0[3], param$0 = s; continue;}
     var r$0 = param$0[1];
     return caml_call2(Rule[11], r, r$0);
    }
   }
   var
    Step =
      [0,
       of_term,
       tapp,
       rapp,
       subst,
       source$0,
       target$0,
       label,
       to_string$7,
       rule,
       has_context,
       eq$6,
       has_rule];
   function steps(rs, t){
    function aux(r, ctx, t){
     if(0 !== t[0]) return 0;
     var a = t[2], f = t[1];
     try{
      var
       s$2 = matches(caml_call1(Rule[4], r), t),
       _gt_ = [0, caml_call1(ctx, caml_call2(Step[3], r, s$2)), 0],
       s = _gt_;
     }
     catch(_gu_){
      var _gr_ = caml_wrap_exception(_gu_);
      if(_gr_ !== Not_unifiable) throw caml_maybe_attach_backtrace(_gr_, 0);
      var s = 0;
     }
     function _gs_(i, t){
      var match = list_remove_nth(i, a), a2 = match[2], a1 = match[1];
      function ctx$0(t){
       return caml_call1(ctx, caml_call4(Step[2], f, a1, t, a2));
      }
      return aux(r, ctx$0, t);
     }
     var
      s$0 = caml_call2(Alg_Extlib[4][20], _gs_, a),
      s$1 = caml_call1(Alg_Extlib[4][14], s$0);
     return caml_call2(Stdlib[37], s$1, s);
    }
    var _gn_ = rs[2];
    function _go_(r){return aux(r, function(_gq_){return _gq_;}, t);}
    var _gp_ = caml_call2(Alg_Extlib[4][19], _go_, _gn_);
    return caml_call1(Alg_Extlib[4][14], _gp_);
   }
   function empty$1(t){return [0, t];}
   function source$1(param){
    var param$0 = param;
    for(;;){
     if(0 === param$0[0]){var t = param$0[1]; return t;}
     var p = param$0[1], param$0 = p;
    }
   }
   function target$1(param){
    if(0 === param[0]){var t = param[1]; return t;}
    var s = param[2];
    return caml_call1(Step[6], s);
   }
   function step(s){return [1, [0, caml_call1(Step[5], s)], s];}
   function append_step(p, s){
    var _gm_ = caml_call1(Step[5], s);
    if(eq$1(target$1(p), _gm_)) return [1, p, s];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
   }
   function to_string$8(var$0, param){
    if(0 === param[0]){var t = param[1]; return string_of_term(var$0)(t);}
    var
     s = param[2],
     p = param[1],
     src = to_string$8(var$0, p),
     lbl = caml_call2(Step[7], var$0, s),
     _gi_ = caml_call1(Step[6], s),
     tgt = string_of_term(var$0)(_gi_),
     _gj_ = caml_call2(Stdlib[28], cst$17, tgt),
     _gk_ = caml_call2(Stdlib[28], lbl, _gj_),
     _gl_ = caml_call2(Stdlib[28], cst$18, _gk_);
    return caml_call2(Stdlib[28], src, _gl_);
   }
   function append(p, param){
    if(0 !== param[0]){
     var s = param[2], q = param[1];
     return [1, append(p, q), s];
    }
    var t = param[1];
    if(eq$1(target$1(p), t)) return p;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
   }
   function toplevel_rules(param){
    if(0 === param[0]) return 0;
    var
     s = param[2],
     p = param[1],
     _gg_ = caml_call1(Step[10], s) ? 0 : [0, caml_call1(Step[9], s), 0],
     _gh_ = toplevel_rules(p);
    return caml_call2(Stdlib[37], _gh_, _gg_);
   }
   function eq$7(p$0, p){
    if(0 === p$0[0]){
     var t = p$0[1];
     if(0 === p[0]){var t$0 = p[1]; return eq$1(t, t$0);}
    }
    else{
     var s = p$0[2], p$1 = p$0[1];
     if(0 !== p[0]){
      var s$0 = p[2], p$2 = p[1], _gf_ = eq$7(p$1, p$2);
      return _gf_ ? caml_call2(Step[11], s, s$0) : _gf_;
     }
    }
    return 0;
   }
   function rules$0(param){
    if(0 === param[0]) return 0;
    var
     s = param[2],
     p = param[1],
     r = caml_call1(Step[9], s),
     rr = rules$0(p),
     _ge_ = caml_call1(Rule[11], r);
    return caml_call2(Alg_Extlib[4][33], _ge_, rr) ? rr : [0, r, rr];
   }
   function length(param){
    if(0 === param[0]) return 0;
    var p = param[1];
    return 1 + length(p) | 0;
   }
   function nth_step(n, p){
    var n$2 = (length(p) - 1 | 0) - n | 0, n$0 = n$2, param = p;
    for(;;){
     if(0 === param[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
     var s = param[2], p$0 = param[1];
     if(0 === n$0) return s;
     var n$1 = n$0 - 1 | 0, n$0 = n$1, param = p$0;
    }
   }
   function nth_term(n, p){
    var n$2 = length(p) - n | 0, n$0 = n$2, param = p;
    for(;;){
     if(0 === param[0]){
      var t = param[1];
      if(0 === n$0) return t;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
     }
     var s = param[2], p$0 = param[1];
     if(0 === n$0) return caml_call1(Step[6], s);
     var n$1 = n$0 - 1 | 0, n$0 = n$1, param = p$0;
    }
   }
   var
    Path =
      [0,
       empty$1,
       source$1,
       target$1,
       step,
       append_step,
       to_string$8,
       append,
       toplevel_rules,
       eq$7,
       rules$0,
       length,
       nth_step,
       nth_term];
   function normalize(rs, t){
    var p$1 = caml_call1(Path[1], t), p = p$1;
    for(;;){
     var s = steps(rs, caml_call1(Path[3], p));
     if(0 === s) return p;
     var
      _gd_ = caml_call1(Alg_Extlib[4][5], s),
      p$0 = caml_call2(Path[5], p, _gd_),
      p = p$0;
    }
   }
   function critical_rules(r1, r2){
    function aux(ctx, t){
     if(0 !== t[0]) return 0;
     var a = t[2], f = t[1];
     try{
      var
       t2 = caml_call1(Rule[4], r2),
       _f7_ = caml_call1(Rule[6], r2),
       n2 = caml_call1(Substitution[4], _f7_),
       s$2 = unify(t, caml_call2(Substitution[8], n2, t2)),
       _f8_ = caml_call1(Rule[6], r1),
       _f9_ = caml_call1(Substitution[3], _f8_),
       _f__ = caml_call2(Substitution[9], _f9_, s$2),
       step1 = caml_call2(Step[3], r1, _f__),
       _f$_ = caml_call1(ctx, caml_call2(Step[3], r2, n2)),
       step2 = caml_call2(Step[4], s$2, _f$_),
       _ga_ = caml_call1(Step[5], step2);
      if(! equivalent(0, caml_call1(Step[5], step1))(_ga_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
      var switch$0 = 0;
      if
       (caml_call2(Rule[11], r1, r2)
        && ! caml_call1(Step[10], step1) && ! caml_call1(Step[10], step2)){var _gb_ = 0; switch$0 = 1;}
      if(! switch$0) var _gb_ = [0, [0, step1, step2], 0];
      var s = _gb_;
     }
     catch(_gc_){
      var _f5_ = caml_wrap_exception(_gc_);
      if(_f5_ !== Not_unifiable) throw caml_maybe_attach_backtrace(_f5_, 0);
      var s = 0;
     }
     function _f6_(i, t){
      var match = list_remove_nth(i, a), a2 = match[2], a1 = match[1];
      function ctx$0(t){
       return caml_call1(ctx, caml_call4(Step[2], f, a1, t, a2));
      }
      return aux(ctx$0, t);
     }
     var
      s$0 = caml_call2(Alg_Extlib[4][20], _f6_, a),
      s$1 = caml_call1(Alg_Extlib[4][14], s$0);
     return caml_call2(Stdlib[37], s, s$1);
    }
    var _f3_ = caml_call1(Rule[4], r1);
    return aux(function(_f4_){return _f4_;}, _f3_);
   }
   function critical(rs){
    var _fU_ = rs[2];
    function _fV_(r1){
     var _f1_ = rs[2];
     function _f2_(r2){return critical_rules(r1, r2);}
     return caml_call2(Alg_Extlib[4][19], _f2_, _f1_);
    }
    var
     _fW_ = caml_call2(Alg_Extlib[4][19], _fV_, _fU_),
     _fX_ = caml_call1(Alg_Extlib[4][14], _fW_),
     steps = caml_call1(Alg_Extlib[4][14], _fX_);
    function sym(param){
     if(! param) return 0;
     var steps = param[2], match = param[1], s2 = match[2], s1 = match[1];
     function _fY_(param){
      var
       s1$0 = param[2],
       s2$0 = param[1],
       _fZ_ = caml_call2(Step[11], s1, s1$0),
       _f0_ = _fZ_ ? caml_call2(Step[11], s2, s2$0) : _fZ_;
      return 1 - _f0_;
     }
     var steps$0 = caml_call2(Alg_Extlib[4][41], _fY_, steps);
     return [0, [0, s1, s2], sym(steps$0)];
    }
    return sym(steps);
   }
   function orient(gt, rs){
    var _fS_ = rs[2];
    function _fT_(param){
     var u = param[3], t = param[2], n = param[1];
     return caml_call2(gt, t, u) ? [0, n, t, u] : [0, n, u, t];
    }
    var rules = caml_call2(Alg_Extlib[4][19], _fT_, _fS_);
    return [0, rs[1], rules];
   }
   function knuth_bendix(opt, namer, _ft_, rs){
    if(opt)
     var sth = opt[1], gt = sth;
    else
     var gt = caml_call1(LPO[1], runtime.caml_greaterequal);
    if(_ft_)
     var sth$0 = _ft_[1], callback = sth$0;
    else
     var callback = function(param){return 0;};
    var rs$0 = orient(gt, rs);
    if(namer)
     var namer$0 = namer[1], namer$1 = namer$0;
    else
     var
      n = [0, -1],
      namer$1 =
        function(param){
         n[1]++;
         var _fR_ = caml_call1(Stdlib[33], n[1]);
         return caml_call2(Stdlib[28], cst_K, _fR_);
        };
    var queue = [0, rs$0[2]], rules = [0, rs$0[2]];
    for(;;){
     if(0 === queue[1]) return [0, rs$0[1], rules[1]];
     var r = caml_call1(Alg_Extlib[4][5], queue[1]);
     queue[1] = caml_call1(Alg_Extlib[4][6], queue[1]);
     var
      _fu_ = rules[1],
      _fv_ =
        function(r){
          return function(s){
           var _fP_ = critical_rules(s, r), _fQ_ = critical_rules(r, s);
           return caml_call2(Stdlib[37], _fQ_, _fP_);};
         }
         (r),
      _fw_ = caml_call2(Alg_Extlib[4][19], _fv_, _fu_),
      cp = caml_call1(Alg_Extlib[4][14], _fw_),
      _fx_ =
        function(param){
         var
          s2 = param[2],
          s1 = param[1],
          rs = [0, rs$0[1], rules[1]],
          _fC_ = normalize(rs, caml_call1(Step[6], s1)),
          _fD_ = caml_call1(Path[4], s1),
          p1 = caml_call2(Path[7], _fD_, _fC_),
          _fE_ = normalize(rs, caml_call1(Step[6], s2)),
          _fF_ = caml_call1(Path[4], s2),
          p2 = caml_call2(Path[7], _fF_, _fE_),
          t1 = caml_call1(Path[3], p1),
          t2 = caml_call1(Path[3], p2),
          _fG_ = 1 - eq$1(t1, t2);
         if(! _fG_) return _fG_;
         if(caml_call2(gt, t1, t2))
          var t2$0 = t2, t1$0 = t1;
         else
          var t2$0 = t1, t1$0 = t2;
         var
          r = [0, caml_call1(namer$1, 0), t1$0, t2$0],
          _fH_ = caml_call2(Path[6], 0, p2),
          _fI_ = caml_call2(Path[6], 0, p1),
          _fJ_ = caml_call2(Rule[10], 0, r);
         caml_call4(Stdlib_Printf[2], _s_, _fJ_, _fI_, _fH_);
         rules[1] = [0, r, rules[1]];
         var _fy_ = rules[1];
         function _fz_(r){
          var t = r[3], s = r[2], n = r[1], _fK_ = rules[1];
          function _fL_(r$0){return 1 - caml_call2(Rule[11], r, r$0);}
          var
           rules$0 = caml_call2(Alg_Extlib[4][41], _fL_, _fK_),
           rs = [0, rs$0[1], rules$0],
           _fM_ = normalize(rs, t),
           _fN_ = caml_call1(Path[3], _fM_),
           _fO_ = normalize(rs, s);
          return [0, n, caml_call1(Path[3], _fO_), _fN_];
         }
         rules[1] = caml_call2(Alg_Extlib[4][19], _fz_, _fy_);
         var _fA_ = rules[1];
         function _fB_(param){
          var t = param[3], s = param[2];
          return 1 - eq$1(s, t);
         }
         rules[1] = caml_call2(Alg_Extlib[4][41], _fB_, _fA_);
         queue[1] = caml_call2(Stdlib[37], queue[1], [0, r, 0]);
         return 0;
        };
     caml_call2(Alg_Extlib[4][17], _fx_, cp);
     caml_call1(callback, [0, rs$0[1], rules[1]]);
    }
   }
   var
    Not_confluent = [248, cst_Alg_Term_RS_Not_confluent, caml_fresh_oo_id(0)];
   function squier(rs){
    var _fk_ = critical(rs);
    function _fl_(param){
     var
      s2 = param[2],
      s1 = param[1],
      _fm_ = normalize(rs, caml_call1(Step[6], s1)),
      _fn_ = caml_call1(Path[4], s1),
      p1 = caml_call2(Path[7], _fn_, _fm_),
      _fo_ = normalize(rs, caml_call1(Step[6], s2)),
      _fp_ = caml_call1(Path[4], s2),
      p2 = caml_call2(Path[7], _fp_, _fo_),
      _fq_ = caml_call1(Path[3], p2);
     if(! (1 - eq$1(caml_call1(Path[3], p1), _fq_))) return [0, p1, p2];
     var _fr_ = caml_call2(Path[6], 0, p2), _fs_ = caml_call2(Path[6], 0, p1);
     caml_call3(Stdlib_Printf[2], _t_, _fs_, _fr_);
     throw caml_maybe_attach_backtrace(Not_confluent, 1);
    }
    return caml_call2(Alg_Extlib[4][19], _fl_, _fk_);
   }
   function to_string$9(opt, var$0, param){
    if(opt) var sth = opt[1], pa = sth; else var pa = 0;
    switch(param[0]){
      case 0:
       var s = param[1]; return caml_call2(Step[7], var$0, s);
      case 1:
       var
        p2 = param[2],
        p1 = param[1],
        _ff_ = to_string$9(0, var$0, p2),
        _fg_ = caml_call2(Stdlib[28], cst$19, _ff_),
        _fh_ = to_string$9(_u_, var$0, p1),
        s$0 = caml_call2(Stdlib[28], _fh_, _fg_);
       if(! pa) return s$0;
       var _fi_ = caml_call2(Stdlib[28], s$0, cst$20);
       return caml_call2(Stdlib[28], cst$21, _fi_);
      case 2:
       var t = param[1]; return string_of_term(var$0)(t);
      default:
       var p = param[1], _fj_ = to_string$9(_v_, var$0, p);
       return caml_call2(Stdlib[28], _fj_, cst$22);
    }
   }
   function source$3(counter, param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var s = param$0[1]; return caml_call1(Step[5], s);
       case 1:
        var p = param$0[1], param$0 = p; continue;
       case 2:
        var t = param$0[1]; return t;
       default:
        var p$0 = param$0[1];
        if(counter >= 50) return caml_trampoline_return(target$3, [0, p$0]);
        var counter$0 = counter + 1 | 0;
        return target$3(counter$0, p$0);
     }
   }
   function target$3(counter, param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var s = param$0[1]; return caml_call1(Step[6], s);
       case 1:
        var p = param$0[2], param$0 = p; continue;
       case 2:
        var t = param$0[1]; return t;
       default:
        var p$0 = param$0[1];
        if(counter >= 50) return caml_trampoline_return(source$3, [0, p$0]);
        var counter$0 = counter + 1 | 0;
        return source$3(counter$0, p$0);
     }
   }
   function source$2(param){return caml_trampoline(source$3(0, param));}
   function target$2(param){return caml_trampoline(target$3(0, param));}
   function step$0(s){return [0, s];}
   function comp(p1, p2){
    var _fe_ = source$2(p2);
    if(eq$1(target$2(p1), _fe_)) return [1, p1, p2];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
   }
   function append$0(p1, p2){return comp(p1, p2);}
   function concat(param){
    if(! param)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _x_], 1);
    var p = param[1];
    if(! param[2]) return p;
    var l = param[2];
    return append$0(p, concat(l));
   }
   function inv$0(p){return [3, p];}
   function eq$8(p$0, p){
    var p$2 = p$0, p$1 = p;
    for(;;){
     switch(p$2[0]){
       case 0:
        if(0 === p$1[0]){
         var s = p$1[1], s$0 = p$2[1];
         return caml_call2(Step[11], s$0, s);
        }
        break;
       case 1:
        if(1 === p$1[0]){
         var
          q = p$1[2],
          p$3 = p$1[1],
          q$0 = p$2[2],
          p$4 = p$2[1],
          _fd_ = eq$8(p$4, p$3);
         if(! _fd_) return _fd_;
         var p$2 = q$0, p$1 = q;
         continue;
        }
        break;
       case 2:
        if(2 === p$1[0]){var t = p$1[1], t$0 = p$2[1]; return eq$1(t$0, t);}
        break;
       default:
        if(3 === p$1[0]){
         var p$5 = p$1[1], p$6 = p$2[1], p$2 = p$6, p$1 = p$5;
         continue;
        }
     }
     return 0;
    }
   }
   function length$0(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        return 1;
       case 1:
        var q = param$0[2], p = param$0[1], _fc_ = length$0(q);
        return length$0(p) + _fc_ | 0;
       case 2:
        return 0;
       default: var p$0 = param$0[1], param$0 = p$0; continue;
     }
   }
   function of_path(p){
    if(0 === p[0]){var t = p[1]; return [2, t];}
    var s = p[2], p$0 = p[1];
    return comp(of_path(p$0), [0, s]);
   }
   function map$1(tm, rs, param){
    switch(param[0]){
      case 0:
       var s = param[1]; return [0, caml_call1(rs, s)];
      case 1:
       var q = param[2], p = param[1], _fb_ = map$1(tm, rs, q);
       return [1, map$1(tm, rs, p), _fb_];
      case 2:
       var t = param[1]; return [2, caml_call1(tm, t)];
      default: var p$0 = param[1]; return [3, map$1(tm, rs, p$0)];
    }
   }
   function subst$0(s, param){
    switch(param[0]){
      case 0:
       var t = param[1]; return [0, caml_call2(Step[4], s, t)];
      case 1:
       var p2 = param[2], p1 = param[1], _fa_ = subst$0(s, p2);
       return [1, subst$0(s, p1), _fa_];
      case 2:
       var t$0 = param[1]; return [2, caml_call2(Substitution[8], s, t$0)];
      default: var p = param[1]; return [3, subst$0(s, p)];
    }
   }
   function rule_occurences(r, param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var s = param$0[1]; return caml_call2(Step[12], r, s) ? 1 : 0;
       case 1:
        var q = param$0[2], p = param$0[1], _e$_ = rule_occurences(r, q);
        return rule_occurences(r, p) + _e$_ | 0;
       case 2:
        return 0;
       default: var p$0 = param$0[1], param$0 = p$0; continue;
     }
   }
   function rule_algebraic_occurences(r, param){
    switch(param[0]){
      case 0:
       var s = param[1]; return caml_call2(Step[12], r, s) ? 1 : 0;
      case 1:
       var q = param[2], p = param[1], _e__ = rule_algebraic_occurences(r, q);
       return rule_algebraic_occurences(r, p) + _e__ | 0;
      case 2:
       return 0;
      default:
       var p$0 = param[1]; return - rule_algebraic_occurences(r, p$0) | 0;
    }
   }
   function is_id(param){return 2 === param[0] ? 1 : 0;}
   function is_inv(param){return 3 === param[0] ? 1 : 0;}
   function has_rule$0(r, p){return 0 < rule_occurences(r, p) ? 1 : 0;}
   function canonize(p){
    var p$0 = p;
    for(;;)
     switch(p$0[0]){
       case 0:
        var s = p$0[1]; return [0, s];
       case 1:
        var p$1 = p$0[1];
        if(2 === p$1[0]){var p$11 = p$0[2], p$0 = p$11; continue;}
        if(2 === p$0[2][0]){var p$0 = p$1; continue;}
        switch(p$1[0]){
          case 1:
           var
            r = p$0[2],
            q = p$1[2],
            p$5 = p$1[1],
            p$6 = [1, p$5, [1, q, r]],
            p$0 = p$6;
           continue;
          case 3:
           var match$1 = p$1[1];
           if(0 !== match$1[0]){
            var q$0 = p$0[2], p$10 = [1, canonize(p$1), q$0], p$0 = p$10;
            continue;
           }
           var p$7 = p$0[2], s$3 = match$1[1], p$8 = canonize(p$7);
           switch(p$8[0]){
             case 0:
              var s$4 = p$8[1];
              if(caml_call2(Step[11], s$3, s$4))
               return [2, caml_call1(Step[6], s$4)];
              break;
             case 1:
              var match$2 = p$8[1];
              if(0 === match$2[0]){
               var p$9 = p$8[2], s$5 = match$2[1];
               if(caml_call2(Step[11], s$3, s$5)) return p$9;
              }
              break;
             case 2:
              return [3, [0, s$3]];
           }
           return [1, [3, [0, s$3]], p$8];
          default:
           var p$2 = p$0[2], s$0 = p$1[1], p$3 = canonize(p$2);
           switch(p$3[0]){
             case 1:
              var _e9_ = p$3[1];
              if(3 === _e9_[0]){
               var match = _e9_[1];
               if(0 === match[0]){
                var p$4 = p$3[2], s$1 = match[1];
                if(caml_call2(Step[11], s$0, s$1)) return p$4;
               }
              }
              break;
             case 2:
              return [0, s$0];
             case 3:
              var match$0 = p$3[1];
              if(0 === match$0[0]){
               var s$2 = match$0[1];
               if(caml_call2(Step[11], s$0, s$2))
                return [2, caml_call1(Step[5], s$0)];
              }
              break;
           }
           return [1, [0, s$0], p$3];
        }
       case 2:
        var t = p$0[1]; return [2, t];
       default:
        var match$3 = p$0[1];
        switch(match$3[0]){
          case 0:
           var s$6 = match$3[1]; return [3, [0, s$6]];
          case 1:
           var
            q$1 = match$3[2],
            p$12 = match$3[1],
            p$13 = [1, [3, q$1], [3, p$12]],
            p$0 = p$13;
           continue;
          case 2:
           var t$0 = match$3[1]; return [2, t$0];
          default: var p$14 = match$3[1], p$0 = p$14; continue;
        }
     }
   }
   function value(r, p){
    var p$0 = canonize(p);
    if(1 !== rule_occurences(r, p$0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
    var
     p$1 = -1 === rule_algebraic_occurences(r, p$0) ? canonize([3, p$0]) : p$0,
     prefix$2 = [0, [2, source$2(p$1)], 0],
     prefix = prefix$2,
     s = p$1;
    for(;;){
     var switch$0 = 0;
     switch(s[0]){
       case 0:
        switch$0 = 1; break;
       case 1:
        var s$1 = s[1], switch$1 = 0;
        switch(s$1[0]){
          case 0:
           var match = s$1[1];
           if(1 === match[0]){
            var p$3 = s[2], s$2 = match[2], r$0 = match[1];
            if(caml_call2(Rule[11], r, r$0)){
             if(has_rule$0(r, p$3))
              throw caml_maybe_attach_backtrace([0, Assert_failure, _y_], 1);
             if(! caml_call1(Substitution[11], s$2))
              throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
             var
              prefix$1 = concat(caml_call1(Alg_Extlib[4][9], prefix)),
              _e6_ = concat([0, [3, prefix$1], [0, [3, p$3], 0]]),
              v = canonize(subst$0(caml_call1(Substitution[13], s$2), _e6_)),
              _e7_ = caml_call1(Rule[4], r);
             if(! eq$1(source$2(v), _e7_))
              throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
             var _e8_ = caml_call1(Rule[5], r);
             if(eq$1(target$2(v), _e8_)) return v;
             throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
            }
           }
           var p$2 = s[2];
           switch$1 = 1;
           break;
          case 3:
           if(0 === s$1[1][0]){var p$2 = s[2]; switch$1 = 1;} break;
        }
        if(switch$1){
         var prefix$0 = [0, s$1, prefix], prefix = prefix$0, s = p$2;
         continue;
        }
        break;
       case 2:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
       default: if(0 === s[1][0]) switch$0 = 1;
     }
     if(! switch$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
     var s$0 = [1, s, [2, target$2(s)]], s = s$0;
    }
   }
   function replace_rule(r, pr, p){
    function rs_ctx$1(_e5_){return _e5_;}
    function tm_ctx$1(_e4_){return _e4_;}
    switch(p[0]){
      case 0:
       var s$2 = p[1], tm_ctx = tm_ctx$1, rs_ctx = rs_ctx$1, param = s$2;
       for(;;){
        if(0 === param[0]){
         var
          a2 = param[4],
          s = param[3],
          a1 = param[2],
          f = param[1],
          tm_ctx$2 =
            function(tm_ctx, a2, a1, f){
             function tm_ctx$0(t){
              var _e3_ = caml_call2(Stdlib[37], [0, t, 0], a2);
              return tm_ctx(app(f, caml_call2(Stdlib[37], a1, _e3_)));
             }
             return tm_ctx$0;
            },
          tm_ctx$0 = tm_ctx$2(tm_ctx, a2, a1, f),
          rs_ctx$2 =
            function(rs_ctx, a2, a1, f){
             function rs_ctx$0(s){
              return rs_ctx(caml_call4(Step[2], f, a1, s, a2));
             }
             return rs_ctx$0;
            },
          rs_ctx$0 = rs_ctx$2(rs_ctx, a2, a1, f),
          tm_ctx = tm_ctx$0,
          rs_ctx = rs_ctx$0,
          param = s;
         continue;
        }
        var r$0 = param[1], s$0 = param[2];
        if(caml_call2(Rule[11], r, r$0))
         return map$1(tm_ctx, rs_ctx, subst$0(s$0, pr));
        var s$1 = param[2];
        return [0, rs_ctx(caml_call2(Step[3], r$0, s$1))];
       }
      case 1:
       var q = p[2], p$0 = p[1], _e2_ = replace_rule(r, pr, q);
       return comp(replace_rule(r, pr, p$0), _e2_);
      case 2:
       var t = p[1]; return [2, t];
      default: var p$1 = p[1]; return [3, replace_rule(r, pr, p$1)];
    }
   }
   function nth_step$0(n, param){
    var n$0 = n, param$0 = param;
    for(;;){
     switch(param$0[0]){
       case 0:
        var s = param$0[1]; if(0 === n$0) return [0, 1, s]; break;
       case 1:
        var match = param$0[1];
        switch(match[0]){
          case 0:
           var p = param$0[2], s$0 = match[1];
           if(0 === n$0) return [0, 1, s$0];
           var n$1 = n$0 - 1 | 0, n$0 = n$1, param$0 = p;
           continue;
          case 3:
           var match$0 = match[1];
           if(0 === match$0[0]){
            var p$0 = param$0[2], s$1 = match$0[1];
            if(0 === n$0) return [0, 0, s$1];
            var n$2 = n$0 - 1 | 0, n$0 = n$2, param$0 = p$0;
            continue;
           }
           break;
        }
        break;
       case 3:
        var match$1 = param$0[1];
        if(0 === match$1[0]){
         var s$2 = match$1[1];
         if(0 === n$0) return [0, 0, s$2];
        }
        break;
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
    }
   }
   function nth_term$0(n, p){
    var n$0 = n, p$0 = p;
    for(;;){
     var switch$0 = 0;
     switch(p$0[0]){
       case 1:
        var p$1 = p$0[1], switch$1 = 0;
        switch(p$1[0]){
          case 0:
           var q = p$0[2]; switch$1 = 1; break;
          case 3:
           if(0 === p$1[1][0]){var q = p$0[2]; switch$1 = 1;} break;
        }
        if(switch$1){
         if(0 === n$0) return source$2(p$1);
         var n$1 = n$0 - 1 | 0, n$0 = n$1, p$0 = q;
         continue;
        }
        break;
       case 3:
        if(0 === p$0[1][0]) switch$0 = 1; break;
       case 2: break;
       default: switch$0 = 1;
     }
     if(! switch$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
     if(0 === n$0) return source$2(p$0);
     if(1 === n$0) return target$2(p$0);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _G_], 1);
    }
   }
   function to_list(param){
    switch(param[0]){
      case 0:
       var s = param[1]; return [0, [0, s], 0];
      case 1:
       var q = param[2], p = param[1], _eX_ = to_list(q), _eY_ = to_list(p);
       return caml_call2(Stdlib[37], _eY_, _eX_);
      case 2:
       return 0;
      default:
       var
        p$0 = param[1],
        _eZ_ = to_list(p$0),
        _e0_ = caml_call1(Alg_Extlib[4][9], _eZ_),
        _e1_ = function(p){return [3, p];};
       return caml_call2(Alg_Extlib[4][19], _e1_, _e0_);
    }
   }
   function parse$0(rs, s){
    function unid(param){
     if(2 !== param[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _I_], 1);
     var t = param[1];
     return t;
    }
    function aux(param){
     var _eM_ = param[1];
     if(4150143 <= _eM_){
      if(4298439 <= _eM_){
       var x = param[2], x$0 = parse_var(x);
       return [2, [1, x$0]];
      }
      var l = param[2];
      return concat(caml_call2(Alg_Extlib[4][19], aux, l));
     }
     if(3654865 <= _eM_){var p = param[2]; return [3, aux(p)];}
     var
      match = param[2],
      a = match[2],
      f = match[1],
      a$0 = caml_call2(Alg_Extlib[4][19], aux, a);
     try{
      var
       _eP_ = rs[1],
       _eQ_ = function(o){return caml_string_equal(caml_call1(Op[1], o), f);},
       f$0 = caml_call2(Alg_Extlib[4][38], _eQ_, _eP_);
      if(caml_call2(Alg_Extlib[4][32], is_id, a$0))
       var
        a$2 = caml_call2(Alg_Extlib[4][19], unid, a$0),
        t = app(f$0, a$2),
        _eR_ = [2, t];
      else{
       try{
        var
         _eT_ = function(p){return 1 - is_id(p);},
         n = caml_call2(Alg_Extlib[4][63], _eT_, a$0);
       }
       catch(_eW_){
        var _eS_ = caml_wrap_exception(_eW_);
        if(_eS_ === Stdlib[8])
         throw caml_maybe_attach_backtrace([0, Assert_failure, _J_], 1);
        throw caml_maybe_attach_backtrace(_eS_, 0);
       }
       var
        t$0 = caml_call2(Alg_Extlib[4][7], a$0, n),
        match$0 = list_remove_nth(n, a$0),
        a2 = match$0[2],
        a1 = match$0[1],
        a1$0 = caml_call2(Alg_Extlib[4][19], unid, a1),
        a2$0 = caml_call2(Alg_Extlib[4][19], unid, a2),
        tm_ctx =
          function(t){
           var _eV_ = caml_call2(Stdlib[37], [0, t, 0], a2$0);
           return app(f$0, caml_call2(Stdlib[37], a1$0, _eV_));
          },
        rs_ctx = function(t){return caml_call4(Step[2], f$0, a1$0, t, a2$0);},
        _eR_ = map$1(tm_ctx, rs_ctx, t$0);
      }
      return _eR_;
     }
     catch(_eU_){
      var _eN_ = caml_wrap_exception(_eU_);
      if(_eN_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_eN_, 0);
      var
       r = find$0(rs, f),
       a$1 = caml_call2(Alg_Extlib[4][19], unid, a$0),
       _eO_ = caml_call1(Rule[6], r),
       s = caml_call3(Alg_Extlib[4][28], Alg_Extlib[1], _eO_, a$1);
      return [0, caml_call2(Step[3], r, s)];
     }
    }
    return aux(parser(s));
   }
   var
    Zigzag =
      [0,
       to_string$9,
       source$2,
       target$2,
       step$0,
       comp,
       append$0,
       concat,
       inv$0,
       eq$8,
       length$0,
       of_path,
       map$1,
       subst$0,
       rule_occurences,
       rule_algebraic_occurences,
       is_id,
       is_inv,
       has_rule$0,
       canonize,
       value,
       replace_rule,
       nth_step$0,
       nth_term$0,
       to_list,
       parse$0];
   function make$2(p){
    var _eL_ = caml_call1(Zigzag[3], p);
    if(eq$1(caml_call1(Zigzag[2], p), _eL_)) return p;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _K_], 1);
   }
   var to_string$10 = Zigzag[1], comp$0 = Zigzag[5], inv$1 = Zigzag[8];
   function of_cell(p1, p2){
    var _eJ_ = caml_call1(Zigzag[2], p2);
    if(! eq$1(caml_call1(Zigzag[2], p1), _eJ_))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _M_], 1);
    var _eK_ = caml_call1(Zigzag[3], p2);
    if(eq$1(caml_call1(Zigzag[3], p1), _eK_))
     return caml_call2(comp$0, p1, caml_call1(inv$1, p2));
    throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
   }
   var
    canonize$0 = Zigzag[19],
    value$0 = Zigzag[20],
    replace_rule$0 = Zigzag[21],
    length$1 = Zigzag[10];
   function rotate(k, p){
    var
     n = caml_call1(length$1, p),
     k$0 = caml_call2(Alg_Extlib[3][1], k, n),
     l = caml_call1(Zigzag[24], p),
     l1 = caml_call3(Alg_Extlib[4][66], l, 0, k$0),
     l2 = caml_call3(Alg_Extlib[4][66], l, k$0, n - k$0 | 0),
     l1$0 = caml_call1(Zigzag[7], l1),
     l2$0 = caml_call1(Zigzag[7], l2);
    return caml_call2(Zigzag[5], l2$0, l1$0);
   }
   var
    Loop =
      [0,
       make$2,
       to_string$10,
       comp$0,
       inv$1,
       of_cell,
       canonize$0,
       value$0,
       replace_rule$0,
       length$1,
       rotate];
   function name$1(c){return c[1];}
   function loop(c){return c[2];}
   function make$3(name, loop){return [0, name, loop];}
   function to_string$11(var$0, c){
    var
     p = caml_call1(Loop[6], c[2]),
     _eI_ = caml_call3(Loop[2], 0, [0, var$0], p);
    return caml_call3(Stdlib_Printf[4], _N_, c[1], _eI_);
   }
   function rotate$0(n, c){
    var _eH_ = caml_call2(Loop[10], n, c[2]);
    return [0, c[1], _eH_];
   }
   function value$1(r, c){return caml_call2(Loop[7], r, c[2]);}
   function replace_rule$1(r, v, c){
    var _eG_ = caml_call3(Loop[8], r, v, c[2]);
    return [0, c[1], _eG_];
   }
   var
    Path$0 = [0],
    Coherence =
      [0,
       name$1,
       loop,
       make$3,
       to_string$11,
       rotate$0,
       value$1,
       replace_rule$1,
       Path$0];
   function rs(crs){return crs[1];}
   function rules$1(crs){return crs[1][2];}
   function coherence(crs){return crs[2];}
   function set_rules(crs, rules){return [0, [0, crs[1][1], rules], crs[2]];}
   function to_string$12(opt, crs){
    if(opt) var sth = opt[1], var$0 = sth; else var var$0 = Var[4];
    var _eD_ = crs[2];
    function _eE_(c){
     var _eF_ = caml_call1(var$0, 0);
     return caml_call2(Coherence[4], _eF_, c);
    }
    var
     coherence = caml_call2(Alg_Extlib[4][19], _eE_, _eD_),
     coherence$0 = caml_call2(Alg_Extlib[5][6], cst$23, coherence);
    return coherence$0;
   }
   function to_tex(opt, crs){
    if(opt) var sth = opt[1], var$0 = sth; else var var$0 = Var[5];
    var ans = [0, cst$24];
    function print(s){
     function _eC_(s){ans[1] = caml_call2(Stdlib[28], ans[1], s); return 0;}
     return caml_call2(Stdlib_Printf[10], _eC_, s);
    }
    print(_O_);
    var _aN_ = rules$1(crs);
    function _aO_(r){
     var
      var$1 = caml_call1(var$0, 0),
      _ez_ = caml_call1(Rule[4], r),
      s = string_of_term([0, var$1])(_ez_),
      _eA_ = caml_call1(Rule[5], r),
      t = string_of_term([0, var$1])(_eA_),
      _eB_ = caml_call1(Rule[3], r);
     return caml_call4(Stdlib_Printf[4], _P_, _eB_, s, t);
    }
    var
     rules = caml_call2(Alg_Extlib[4][19], _aO_, _aN_),
     rules$0 = caml_call2(Alg_Extlib[5][6], cst$25, rules);
    caml_call1(print(_Q_), rules$0);
    print(_R_);
    var _aP_ = crs[2];
    function _aQ_(c){
     var
      _aR_ = caml_call1(Coherence[2], c),
      p = caml_call1(Loop[6], _aR_),
      _aS_ = caml_call3(Loop[2], 0, 0, p),
      _aT_ = caml_call1(Coherence[1], c);
     caml_call3(Stdlib_Printf[2], _S_, _aT_, _aS_);
     var l = caml_call1(Zigzag[24], p);
     if(0 !== l) caml_call1(Zigzag[7], l);
     var n = caml_call1(Alg_Extlib[4][1], l);
     if(0 === n)
      var p2 = p, p1 = p;
     else
      try{
       var k = caml_call2(Alg_Extlib[4][63], Zigzag[17], l);
       if(0 === k) throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       var
        l1$0 = caml_call3(Alg_Extlib[4][66], l, 0, k),
        l2$0 = caml_call3(Alg_Extlib[4][66], l, k, n - k | 0);
       if(1 - caml_call2(Alg_Extlib[4][32], Zigzag[17], l2$0))
        throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       var
        p1$1 = caml_call1(Zigzag[7], l1$0),
        _a0_ = caml_call1(Zigzag[7], l2$0),
        _a1_ = caml_call1(Zigzag[8], _a0_),
        p2$1 = caml_call1(Zigzag[19], _a1_),
        _a2_ = caml_call1(Alg_Extlib[4][1], l2$0);
       if(_a2_ < caml_call1(Alg_Extlib[4][1], l1$0))
        var p2$2 = p1$1, p1$2 = p2$1;
       else
        var p2$2 = p2$1, p1$2 = p1$1;
       var
        p2$3 = caml_call1(Zigzag[19], p2$2),
        _a3_ = caml_call1(Zigzag[19], p1$2),
        p2 = p2$3,
        p1 = _a3_;
      }
      catch(_ey_){
       var _aX_ = caml_wrap_exception(_ey_);
       if(_aX_ !== Stdlib[3] && _aX_ !== Stdlib[8])
        throw caml_maybe_attach_backtrace(_aX_, 0);
       var
        l1 = caml_call3(Alg_Extlib[4][66], l, 0, n / 2 | 0),
        l2 = caml_call3(Alg_Extlib[4][66], l, n / 2 | 0, n - (n / 2 | 0) | 0),
        _aY_ = caml_call1(Zigzag[7], l2),
        _aZ_ = caml_call1(Zigzag[8], _aY_),
        p2$0 = caml_call1(Zigzag[19], _aZ_),
        p1$0 = caml_call1(Zigzag[7], l1),
        p2 = p2$0,
        p1 = p1$0;
      }
     var
      _aU_ = caml_call3(Zigzag[1], 0, 0, p2),
      _aV_ = caml_call3(Zigzag[1], 0, 0, p1);
     caml_call3(Stdlib_Printf[2], _T_, _aV_, _aU_);
     var var$1 = caml_call1(var$0, 0);
     function st(n, p){
      var
       match = caml_call2(Zigzag[22], n, p),
       s = match[2],
       d = match[1],
       d$0 = d ? cst$26 : cst$29,
       s$0 = caml_call2(Step[7], [0, var$1], s),
       _ew_ = caml_call2(Stdlib[28], s$0, cst$27),
       _ex_ = caml_call2(Stdlib[28], cst$28, _ew_);
      return caml_call2(Stdlib[28], d$0, _ex_);
     }
     function tm(n, p){
      var _ev_ = caml_call2(Zigzag[23], n, p);
      return string_of_term([0, var$1])(_ev_);
     }
     function cd(param){
      var
       l1 = caml_call1(Zigzag[10], p1),
       l2 = caml_call1(Zigzag[10], p2),
       _a4_ = l1 - 1 | 0;
      if(2 >= _a4_ >>> 0)
       switch(_a4_){
         case 0:
          var switcher = l2 - 1 | 0;
          if(5 >= switcher >>> 0)
           switch(switcher){
             case 0:
              var
               _bP_ = tm(1, p1),
               _bQ_ = st(0, p2),
               _bR_ = st(0, p1),
               _bS_ = tm(0, p1);
              return caml_call4(print(_ae_), _bS_, _bR_, _bQ_, _bP_);
             case 1:
              var
               _bT_ = tm(2, p2),
               _bU_ = st(1, p2),
               _bV_ = tm(1, p2),
               _bW_ = st(0, p2),
               _bX_ = st(0, p1),
               _bY_ = tm(0, p1);
              return caml_call6
                      (print(_af_), _bY_, _bX_, _bW_, _bV_, _bU_, _bT_);
             case 2:
              var
               _bZ_ = tm(3, p2),
               _b0_ = st(2, p2),
               _b1_ = tm(2, p2),
               _b2_ = st(1, p2),
               _b3_ = tm(1, p2),
               _b4_ = st(0, p2),
               _b5_ = st(0, p1),
               _b6_ = tm(0, p1);
              return caml_call8
                      (print(_ag_),
                       _b6_,
                       _b5_,
                       _b4_,
                       _b3_,
                       _b2_,
                       _b1_,
                       _b0_,
                       _bZ_);
             case 3:
              var
               _b7_ = tm(4, p2),
               _b8_ = st(3, p2),
               _b9_ = tm(3, p2),
               _b__ = st(2, p2),
               _b$_ = tm(2, p2),
               _ca_ = st(1, p2),
               _cb_ = tm(1, p2),
               _cc_ = st(0, p2),
               _cd_ = st(0, p1),
               _ce_ = tm(0, p1);
              return caml_call10
                      (print(_ah_),
                       _ce_,
                       _cd_,
                       _cc_,
                       _cb_,
                       _ca_,
                       _b$_,
                       _b__,
                       _b9_,
                       _b8_,
                       _b7_);
             case 4:
              var
               _cf_ = tm(5, p2),
               _cg_ = st(4, p2),
               _ch_ = tm(4, p2),
               _ci_ = st(3, p2),
               _cj_ = tm(3, p2),
               _ck_ = st(2, p2),
               _cl_ = tm(2, p2),
               _cm_ = st(1, p2),
               _cn_ = tm(1, p2),
               _co_ = st(0, p2),
               _cp_ = st(0, p1),
               _cq_ = tm(0, p1);
              return caml_call12
                      (print(_ai_),
                       _cq_,
                       _cp_,
                       _co_,
                       _cn_,
                       _cm_,
                       _cl_,
                       _ck_,
                       _cj_,
                       _ci_,
                       _ch_,
                       _cg_,
                       _cf_);
             default:
              var
               _cr_ = tm(6, p2),
               _cs_ = st(5, p2),
               _ct_ = tm(5, p2),
               _cu_ = st(4, p2),
               _cv_ = tm(4, p2),
               _cw_ = st(3, p2),
               _cx_ = tm(3, p2),
               _cy_ = st(2, p2),
               _cz_ = tm(2, p2),
               _cA_ = st(1, p2),
               _cB_ = tm(1, p2),
               _cC_ = st(0, p2),
               _cD_ = st(0, p1),
               _cE_ = tm(0, p1);
              return caml_call14
                      (print(_aj_),
                       _cE_,
                       _cD_,
                       _cC_,
                       _cB_,
                       _cA_,
                       _cz_,
                       _cy_,
                       _cx_,
                       _cw_,
                       _cv_,
                       _cu_,
                       _ct_,
                       _cs_,
                       _cr_);
           }
          break;
         case 1:
          var switcher$0 = l2 - 2 | 0;
          if(2 >= switcher$0 >>> 0)
           switch(switcher$0){
             case 0:
              var
               _cF_ = tm(2, p1),
               _cG_ = st(1, p1),
               _cH_ = tm(1, p1),
               _cI_ = st(1, p2),
               _cJ_ = tm(1, p2),
               _cK_ = st(0, p2),
               _cL_ = st(0, p1),
               _cM_ = tm(0, p1);
              return caml_call8
                      (print(_ak_),
                       _cM_,
                       _cL_,
                       _cK_,
                       _cJ_,
                       _cI_,
                       _cH_,
                       _cG_,
                       _cF_);
             case 1:
              var
               _cN_ = tm(2, p1),
               _cO_ = st(1, p1),
               _cP_ = tm(1, p1),
               _cQ_ = st(2, p2),
               _cR_ = tm(2, p2),
               _cS_ = st(1, p2),
               _cT_ = tm(1, p2),
               _cU_ = st(0, p2),
               _cV_ = st(0, p1),
               _cW_ = tm(0, p1);
              return caml_call10
                      (print(_al_),
                       _cW_,
                       _cV_,
                       _cU_,
                       _cT_,
                       _cS_,
                       _cR_,
                       _cQ_,
                       _cP_,
                       _cO_,
                       _cN_);
             default:
              var
               _cX_ = tm(2, p1),
               _cY_ = st(1, p1),
               _cZ_ = tm(1, p1),
               _c0_ = st(3, p2),
               _c1_ = tm(3, p2),
               _c2_ = st(2, p2),
               _c3_ = tm(2, p2),
               _c4_ = st(1, p2),
               _c5_ = tm(1, p2),
               _c6_ = st(0, p2),
               _c7_ = st(0, p1),
               _c8_ = tm(0, p1);
              return caml_call12
                      (print(_am_),
                       _c8_,
                       _c7_,
                       _c6_,
                       _c5_,
                       _c4_,
                       _c3_,
                       _c2_,
                       _c1_,
                       _c0_,
                       _cZ_,
                       _cY_,
                       _cX_);
           }
          break;
         default:
          var switcher$1 = l2 - 5 | 0;
          if(5 >= switcher$1 >>> 0)
           switch(switcher$1){
             case 0:
              var
               _c9_ = tm(3, p1),
               _c__ = st(2, p1),
               _c$_ = tm(2, p1),
               _da_ = st(1, p1),
               _db_ = tm(1, p1),
               _dc_ = st(4, p2),
               _dd_ = tm(4, p2),
               _de_ = st(3, p2),
               _df_ = tm(3, p2),
               _dg_ = st(2, p2),
               _dh_ = tm(2, p2),
               _di_ = st(1, p2),
               _dj_ = tm(1, p2),
               _dk_ = st(0, p2),
               _dl_ = st(0, p1),
               _dm_ = tm(0, p1);
              return caml_call16
                      (print(_an_),
                       _dm_,
                       _dl_,
                       _dk_,
                       _dj_,
                       _di_,
                       _dh_,
                       _dg_,
                       _df_,
                       _de_,
                       _dd_,
                       _dc_,
                       _db_,
                       _da_,
                       _c$_,
                       _c__,
                       _c9_);
             case 3:
              var
               _dn_ = tm(3, p1),
               _do_ = st(2, p1),
               _dp_ = tm(2, p1),
               _dq_ = st(1, p1),
               _dr_ = tm(1, p1),
               _ds_ = st(7, p2),
               _dt_ = tm(7, p2),
               _du_ = st(6, p2),
               _dv_ = tm(6, p2),
               _dw_ = st(5, p2),
               _dx_ = tm(5, p2),
               _dy_ = st(4, p2),
               _dz_ = tm(4, p2),
               _dA_ = st(3, p2),
               _dB_ = tm(3, p2),
               _dC_ = st(2, p2),
               _dD_ = tm(2, p2),
               _dE_ = st(1, p2),
               _dF_ = tm(1, p2),
               _dG_ = st(0, p2),
               _dH_ = st(0, p1),
               _dI_ = tm(0, p1);
              return caml_call22
                      (print(_ao_),
                       _dI_,
                       _dH_,
                       _dG_,
                       _dF_,
                       _dE_,
                       _dD_,
                       _dC_,
                       _dB_,
                       _dA_,
                       _dz_,
                       _dy_,
                       _dx_,
                       _dw_,
                       _dv_,
                       _du_,
                       _dt_,
                       _ds_,
                       _dr_,
                       _dq_,
                       _dp_,
                       _do_,
                       _dn_);
             case 4:
              var
               _dJ_ = tm(3, p1),
               _dK_ = st(2, p1),
               _dL_ = tm(2, p1),
               _dM_ = st(1, p1),
               _dN_ = tm(1, p1),
               _dO_ = st(8, p2),
               _dP_ = tm(8, p2),
               _dQ_ = st(7, p2),
               _dR_ = tm(7, p2),
               _dS_ = st(6, p2),
               _dT_ = tm(6, p2),
               _dU_ = st(5, p2),
               _dV_ = tm(5, p2),
               _dW_ = st(4, p2),
               _dX_ = tm(4, p2),
               _dY_ = st(3, p2),
               _dZ_ = tm(3, p2),
               _d0_ = st(2, p2),
               _d1_ = tm(2, p2),
               _d2_ = st(1, p2),
               _d3_ = tm(1, p2),
               _d4_ = st(0, p2),
               _d5_ = st(0, p1),
               _d6_ = tm(0, p1);
              return caml_call24
                      (print(_ap_),
                       _d6_,
                       _d5_,
                       _d4_,
                       _d3_,
                       _d2_,
                       _d1_,
                       _d0_,
                       _dZ_,
                       _dY_,
                       _dX_,
                       _dW_,
                       _dV_,
                       _dU_,
                       _dT_,
                       _dS_,
                       _dR_,
                       _dQ_,
                       _dP_,
                       _dO_,
                       _dN_,
                       _dM_,
                       _dL_,
                       _dK_,
                       _dJ_);
             case 5:
              var
               _d7_ = tm(3, p1),
               _d8_ = st(2, p1),
               _d9_ = tm(2, p1),
               _d__ = st(1, p1),
               _d$_ = tm(1, p1),
               _ea_ = st(9, p2),
               _eb_ = tm(9, p2),
               _ec_ = st(8, p2),
               _ed_ = tm(8, p2),
               _ee_ = st(7, p2),
               _ef_ = tm(7, p2),
               _eg_ = st(6, p2),
               _eh_ = tm(6, p2),
               _ei_ = st(5, p2),
               _ej_ = tm(5, p2),
               _ek_ = st(4, p2),
               _el_ = tm(4, p2),
               _em_ = st(3, p2),
               _en_ = tm(3, p2),
               _eo_ = st(2, p2),
               _ep_ = tm(2, p2),
               _eq_ = st(1, p2),
               _er_ = tm(1, p2),
               _es_ = st(0, p2),
               _et_ = st(0, p1),
               _eu_ = tm(0, p1);
              return caml_call26
                      (print(_aq_),
                       _eu_,
                       _et_,
                       _es_,
                       _er_,
                       _eq_,
                       _ep_,
                       _eo_,
                       _en_,
                       _em_,
                       _el_,
                       _ek_,
                       _ej_,
                       _ei_,
                       _eh_,
                       _eg_,
                       _ef_,
                       _ee_,
                       _ed_,
                       _ec_,
                       _eb_,
                       _ea_,
                       _d$_,
                       _d__,
                       _d9_,
                       _d8_,
                       _d7_);
           }
       }
      if(2 <= l1 && l2 === (l1 + 1 | 0)){
       var
        _a5_ = st(2, p2),
        _a6_ = tm(2, p2),
        _a7_ = st(1, p2),
        _a8_ = tm(1, p2),
        _a9_ = st(0, p2),
        _a__ = st(0, p1),
        _a$_ = tm(0, p1);
       caml_call7(print(_U_), _a$_, _a__, _a9_, _a8_, _a7_, _a6_, _a5_);
       var _bb_ = l1 - 2 | 0, _ba_ = 1;
       if(_bb_ >= 1){
        var i$0 = _ba_;
        for(;;){
         var
          _bf_ = st(i$0 + 2 | 0, p2),
          _bg_ = tm(i$0 + 2 | 0, p2),
          _bh_ = st(i$0, p1),
          _bi_ = tm(i$0, p1);
         caml_call4(print(_W_), _bi_, _bh_, _bg_, _bf_);
         var _bj_ = i$0 + 1 | 0;
         if(_bb_ !== i$0){var i$0 = _bj_; continue;}
         break;
        }
       }
       var
        i = l1 - 1 | 0,
        _bc_ = tm(i + 2 | 0, p2),
        _bd_ = st(i, p1),
        _be_ = tm(i, p1);
       return caml_call3(print(_V_), _be_, _bd_, _bc_);
      }
      if(3 <= l1 && l2 === l1){
       var
        _bk_ = st(2, p2),
        _bl_ = tm(2, p2),
        _bm_ = st(1, p2),
        _bn_ = tm(1, p2),
        _bo_ = st(0, p2),
        _bp_ = st(0, p1),
        _bq_ = tm(0, p1);
       caml_call7(print(_X_), _bq_, _bp_, _bo_, _bn_, _bm_, _bl_, _bk_);
       var _bs_ = l1 - 3 | 0, _br_ = 1;
       if(_bs_ >= 1){
        var i$2 = _br_;
        for(;;){
         var
          _by_ = st(i$2 + 2 | 0, p2),
          _bz_ = tm(i$2 + 2 | 0, p2),
          _bA_ = st(i$2, p1),
          _bB_ = tm(i$2, p1);
         caml_call4(print(_Z_), _bB_, _bA_, _bz_, _by_);
         var _bC_ = i$2 + 1 | 0;
         if(_bs_ !== i$2){var i$2 = _bC_; continue;}
         break;
        }
       }
       var
        i$1 = l1 - 2 | 0,
        _bt_ = tm(i$1 + 2 | 0, p2),
        _bu_ = st(i$1 + 1 | 0, p1),
        _bv_ = tm(i$1 + 1 | 0, p1),
        _bw_ = st(i$1, p1),
        _bx_ = tm(i$1, p1);
       return caml_call5(print(_Y_), _bx_, _bw_, _bv_, _bu_, _bt_);
      }
      var
       _bD_ = caml_call1(Zigzag[8], p2),
       _bE_ = caml_call2(Zigzag[6], p1, _bD_),
       p = caml_call1(Zigzag[19], _bE_);
      caml_call3(Stdlib_Printf[2], ___, l1, l2);
      if(caml_call1(Zigzag[16], p)){
       var _bF_ = caml_call3(Zigzag[1], 0, [0, var$1], p);
       return caml_call1(print(_$_), _bF_);
      }
      var l = caml_call1(Zigzag[10], p);
      caml_call2(Stdlib_Printf[2], _aa_, l);
      var _bH_ = (l - 1 | 0) / 2 | 0, n = 2, _bG_ = 0;
      if(_bH_ >= 0){
       var i$3 = _bG_;
       for(;;){
        var _bI_ = tm(i$3 * 2 | 0, p);
        caml_call1(print(_ab_), _bI_);
        var
         _bK_ = caml_call2(Stdlib[16], n, l - (i$3 * 2 | 0) | 0) - 1 | 0,
         _bJ_ = 0;
        if(_bK_ >= 0){
         var j = _bJ_;
         for(;;){
          var
           _bM_ = tm(((i$3 * 2 | 0) + j | 0) + 1 | 0, p),
           _bN_ = st((i$3 * 2 | 0) + j | 0, p);
          caml_call2(print(_ad_), _bN_, _bM_);
          var _bO_ = j + 1 | 0;
          if(_bK_ !== j){var j = _bO_; continue;}
          break;
         }
        }
        print(_ac_);
        var _bL_ = i$3 + 1 | 0;
        if(_bH_ !== i$3){var i$3 = _bL_; continue;}
        break;
       }
      }
      return 0;
     }
     var _aW_ = caml_call1(Coherence[1], c);
     caml_call1(print(_ar_), _aW_);
     print(_as_);
     cd(0);
     return print(_at_);
    }
    caml_call2(Alg_Extlib[4][17], _aQ_, _aP_);
    print(_au_);
    return ans[1];
   }
   function view_pdf(var$0, rs){
    var
     match = caml_call5(Stdlib_Filename[17], 0, 0, 0, cst_ocaml_alg, cst_tex),
     oc = match[2],
     fname = match[1],
     _aL_ = to_tex(var$0, rs);
    caml_call2(Stdlib[66], oc, _aL_);
    caml_call1(Stdlib[76], oc);
    var
     _aM_ = caml_call1(Stdlib_Filename[18], 0),
     cmd = caml_call4(Stdlib_Printf[4], _av_, _aM_, fname, fname);
    if(0 === runtime.caml_sys_system_command(cmd)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _aw_], 1);
   }
   function make$4(rs, coherence){return [0, rs, coherence];}
   function find_rule(crs, r){return find$0(crs[1], r);}
   function find$1(rs, crs){
    var _aJ_ = rs[2];
    function _aK_(c){
     return caml_string_equal(caml_call1(Coherence[1], c), crs);
    }
    return caml_call2(Alg_Extlib[4][38], _aK_, _aJ_);
   }
   function add_coherence(crs, c, p){
    var _aH_ = caml_call1(Zigzag[3], p);
    if(! eq$1(caml_call1(Zigzag[2], p), _aH_))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ax_], 1);
    var
     _aI_ = [0, caml_call2(Coherence[3], c, p), 0],
     coherence = caml_call2(Stdlib[37], crs[2], _aI_);
    return [0, crs[1], coherence];
   }
   function rotate$1(crs, cname, n){
    var _aF_ = crs[2];
    function _aG_(c){
     return caml_string_equal(caml_call1(Coherence[1], c), cname)
             ? caml_call2(Coherence[5], n, c)
             : c;
    }
    var coherence = caml_call2(Alg_Extlib[4][19], _aG_, _aF_);
    return [0, crs[1], coherence];
   }
   function elim_rule(crs, r, c){
    var
     r$0 = find_rule(crs, r),
     c$0 = find$1(crs, c),
     v = caml_call2(Coherence[6], r$0, c$0),
     var$0 = caml_call1(Var[5], 0),
     _az_ = caml_call3(Zigzag[1], 0, [0, var$0], v),
     _aA_ = caml_call2(Rule[10], [0, var$0], r$0);
    caml_call3(Stdlib_Printf[2], _ay_, _aA_, _az_);
    var _aB_ = rules$1(crs);
    function _aC_(r){return 1 - caml_call2(Rule[11], r$0, r);}
    var rules = caml_call2(Alg_Extlib[4][41], _aC_, _aB_), _aD_ = crs[2];
    function _aE_(c){return caml_call3(Coherence[7], r$0, v, c);}
    var coherence = caml_call2(Alg_Extlib[4][19], _aE_, _aD_);
    return [0, [0, crs[1][1], rules], coherence];
   }
   var
    Morphism = [0],
    Coherent =
      [0,
       rs,
       rules$1,
       coherence,
       set_rules,
       to_string$12,
       to_tex,
       view_pdf,
       make$4,
       find_rule,
       find$1,
       add_coherence,
       rotate$1,
       elim_rule,
       Morphism],
    RS =
      [0,
       list_remove_nth,
       Rule,
       operations,
       rules,
       filter,
       make$1,
       empty$0,
       to_string$6,
       find$0,
       Step,
       steps,
       Path,
       normalize,
       critical_rules,
       critical,
       orient,
       knuth_bendix,
       Not_confluent,
       squier,
       Zigzag,
       Loop,
       Coherence,
       Coherent],
    Alg_Term =
      [0,
       Op,
       Var,
       var$0,
       app,
       parser,
       parse_var,
       parse,
       eq$1,
       eq$1,
       to_string$1,
       string_of_term,
       is_var,
       get_var,
       vars$0,
       occurs,
       LPO,
       Substitution,
       Interpretation,
       Not_unifiable,
       unify,
       matches,
       equivalent,
       RS];
   runtime.caml_register_global(129, Alg_Term, "Alg__Term");
   return;
  }
  (globalThis));


//# 1 "../../.js/default/js_of_ocaml-compiler.runtime/jsoo_runtime.cma.js"
// Generated by js_of_ocaml
//# 3 "../../.js/default/js_of_ocaml-compiler.runtime/jsoo_runtime.cma.js"

//# 18 "../../.js/default/js_of_ocaml-compiler.runtime/jsoo_runtime.cma.js"
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    s = "5.4.0",
    git_version = "c1a8c4a",
    Jsoo_runtime_Runtime_version = [0, s, git_version];
   runtime.caml_register_global
    (2, Jsoo_runtime_Runtime_version, "Jsoo_runtime__Runtime_version");
   return;
  }
  (globalThis));

//# 33 "../../.js/default/js_of_ocaml-compiler.runtime/jsoo_runtime.cma.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Jsoo_runtime_Runtime_version = global_data.Jsoo_runtime__Runtime_version,
    Stdlib_Callback = global_data.Stdlib__Callback,
    Js = [0],
    Config = [0],
    version = Jsoo_runtime_Runtime_version[1],
    git_version = Jsoo_runtime_Runtime_version[2],
    Sys = [0, Config, version, git_version],
    Exn = [248, "Jsoo_runtime.Error.Exn", runtime.caml_fresh_oo_id(0)];
   caml_call2(Stdlib_Callback[2], "jsError", [0, Exn, [0]]);
   function raise(exn){throw exn;}
   var
    Error =
      [0,
       raise,
       runtime.caml_exn_with_js_backtrace,
       runtime.caml_js_error_option_of_exception,
       Exn],
    For_compatibility_only = [0],
    Bigstring = [0],
    Typed_array = [0, Bigstring],
    Int64 = [0],
    Jsoo_runtime =
      [0, Js, Sys, Error, For_compatibility_only, Typed_array, Int64];
   runtime.caml_register_global(5, Jsoo_runtime, "Jsoo_runtime");
   return;
  }
  (globalThis));


//# 1 "../../.js/default/js_of_ocaml/js_of_ocaml.cma.js"
// Generated by js_of_ocaml
//# 3 "../../.js/default/js_of_ocaml/js_of_ocaml.cma.js"

//# 19 "../../.js/default/js_of_ocaml/js_of_ocaml.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Char = global_data.Stdlib__Char,
    Poly = [0];
   function max(x, y){return y <= x ? x : y;}
   function min(x, y){return x <= y ? x : y;}
   var
    Int_replace_polymorphic_compar = [0, max, min],
    make = Stdlib_String[1],
    init = Stdlib_String[2],
    empty = Stdlib_String[3],
    of_bytes = Stdlib_String[4],
    to_bytes = Stdlib_String[5],
    concat = Stdlib_String[6],
    cat = Stdlib_String[7],
    compare = Stdlib_String[9],
    starts_with = Stdlib_String[10],
    ends_with = Stdlib_String[11],
    contains_from = Stdlib_String[12],
    rcontains_from = Stdlib_String[13],
    contains = Stdlib_String[14],
    sub = Stdlib_String[15],
    split_on_char = Stdlib_String[16],
    map = Stdlib_String[17],
    mapi = Stdlib_String[18],
    fold_left = Stdlib_String[19],
    fold_right = Stdlib_String[20],
    for_all = Stdlib_String[21],
    exists = Stdlib_String[22],
    trim = Stdlib_String[23],
    escaped = Stdlib_String[24],
    uppercase_ascii = Stdlib_String[25],
    lowercase_ascii = Stdlib_String[26],
    capitalize_ascii = Stdlib_String[27],
    uncapitalize_ascii = Stdlib_String[28],
    iter = Stdlib_String[29],
    iteri = Stdlib_String[30],
    index_from = Stdlib_String[31],
    index_from_opt = Stdlib_String[32],
    rindex_from = Stdlib_String[33],
    rindex_from_opt = Stdlib_String[34],
    index = Stdlib_String[35],
    index_opt = Stdlib_String[36],
    rindex = Stdlib_String[37],
    rindex_opt = Stdlib_String[38],
    to_seq = Stdlib_String[39],
    to_seqi = Stdlib_String[40],
    of_seq = Stdlib_String[41],
    get_utf_8_uchar = Stdlib_String[42],
    is_valid_utf_8 = Stdlib_String[43],
    get_utf_16be_uchar = Stdlib_String[44],
    is_valid_utf_16be = Stdlib_String[45],
    get_utf_16le_uchar = Stdlib_String[46],
    is_valid_utf_16le = Stdlib_String[47],
    blit = Stdlib_String[48],
    get_uint8 = Stdlib_String[49],
    get_int8 = Stdlib_String[50],
    get_uint16_ne = Stdlib_String[51],
    get_uint16_be = Stdlib_String[52],
    get_uint16_le = Stdlib_String[53],
    get_int16_ne = Stdlib_String[54],
    get_int16_be = Stdlib_String[55],
    get_int16_le = Stdlib_String[56],
    get_int32_ne = Stdlib_String[57],
    hash = Stdlib_String[58],
    seeded_hash = Stdlib_String[59],
    get_int32_be = Stdlib_String[60],
    get_int32_le = Stdlib_String[61],
    get_int64_ne = Stdlib_String[62],
    get_int64_be = Stdlib_String[63],
    get_int64_le = Stdlib_String[64],
    equal = runtime.caml_string_equal,
    String =
      [0,
       make,
       init,
       empty,
       of_bytes,
       to_bytes,
       concat,
       cat,
       compare,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       is_valid_utf_16le,
       blit,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       hash,
       seeded_hash,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       equal],
    chr = Stdlib_Char[1],
    escaped$0 = Stdlib_Char[2],
    lowercase_ascii$0 = Stdlib_Char[3],
    uppercase_ascii$0 = Stdlib_Char[4],
    compare$0 = Stdlib_Char[5];
   function equal$0(x, y){return x === y ? 1 : 0;}
   var
    Char =
      [0,
       chr,
       escaped$0,
       lowercase_ascii$0,
       uppercase_ascii$0,
       compare$0,
       equal$0],
    max$0 = Int_replace_polymorphic_compar[1],
    min$0 = Int_replace_polymorphic_compar[2],
    Js_of_ocaml_Import =
      [0, Poly, Int_replace_polymorphic_compar, String, Char, max$0, min$0];
   runtime.caml_register_global(2, Js_of_ocaml_Import, "Js_of_ocaml__Import");
   return;
  }
  (globalThis));

//# 188 "../../.js/default/js_of_ocaml/js_of_ocaml.cma.js"
(function
  (globalThis){
   "use strict";
   var
    jsoo_exports = typeof module === "object" && module.exports || globalThis,
    runtime = globalThis.jsoo_runtime,
    cst_parseFloat$0 = "parseFloat",
    cst_parseInt$0 = "parseInt",
    caml_js_get = runtime.caml_js_get,
    caml_js_set = runtime.caml_js_set,
    caml_js_wrap_callback = runtime.caml_js_wrap_callback,
    caml_string_of_jsstring = runtime.caml_string_of_jsstring;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Js_of_ocaml_Import = global_data.Js_of_ocaml__Import,
    Stdlib = global_data.Stdlib,
    Jsoo_runtime = global_data.Jsoo_runtime,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    global = globalThis,
    Unsafe = [0, global],
    null$0 = null,
    undefined$0 = undefined,
    cst_function = "function",
    cst_parseFloat = cst_parseFloat$0,
    cst_parseInt = cst_parseInt$0;
   function return$0(_z_){return _z_;}
   function map(x, f){return x == null$0 ? null$0 : caml_call1(f, x);}
   function bind(x, f){return x == null$0 ? null$0 : caml_call1(f, x);}
   function test(x){return 1 - (x == null$0 ? 1 : 0);}
   function iter(x, f){
    var _y_ = 1 - (x == null$0 ? 1 : 0);
    return _y_ ? caml_call1(f, x) : _y_;
   }
   function case$0(x, f, g){
    return x == null$0 ? caml_call1(f, 0) : caml_call1(g, x);
   }
   function get(x, f){return x == null$0 ? caml_call1(f, 0) : x;}
   function option(x){if(! x) return null$0; var x$0 = x[1]; return x$0;}
   function to_option(x){
    function _x_(x){return [0, x];}
    return case$0(x, function(param){return 0;}, _x_);
   }
   var
    Opt =
      [0,
       null$0,
       return$0,
       map,
       bind,
       test,
       iter,
       case$0,
       get,
       option,
       to_option];
   function return$1(_w_){return _w_;}
   function map$0(x, f){
    return x === undefined$0 ? undefined$0 : caml_call1(f, x);
   }
   function bind$0(x, f){
    return x === undefined$0 ? undefined$0 : caml_call1(f, x);
   }
   function test$0(x){return x !== undefined$0 ? 1 : 0;}
   function iter$0(x, f){
    var _v_ = x !== undefined$0 ? 1 : 0;
    return _v_ ? caml_call1(f, x) : _v_;
   }
   function case$1(x, f, g){
    return x === undefined$0 ? caml_call1(f, 0) : caml_call1(g, x);
   }
   function get$0(x, f){return x === undefined$0 ? caml_call1(f, 0) : x;}
   function option$0(x){
    if(! x) return undefined$0;
    var x$0 = x[1];
    return x$0;
   }
   function to_option$0(x){
    function _u_(x){return [0, x];}
    return case$1(x, function(param){return 0;}, _u_);
   }
   var
    Optdef =
      [0,
       undefined$0,
       return$1,
       map$0,
       bind$0,
       test$0,
       iter$0,
       case$1,
       get$0,
       option$0,
       to_option$0];
   function coerce(x, f, g){
    function _s_(param){return caml_call1(g, x);}
    var _t_ = caml_call1(f, x);
    return caml_call2(Opt[8], _t_, _s_);
   }
   function coerce_opt(x, f, g){
    function _q_(param){return caml_call1(g, x);}
    var _r_ = caml_call2(Opt[4], x, f);
    return caml_call2(Opt[8], _r_, _q_);
   }
   var
    true$0 = true,
    false$0 = false,
    nfc = "NFC",
    nfd = "NFD",
    nfkc = "NFKC",
    nfkd = "NFKD",
    t0 = Unsafe[1],
    string_constr = t0.String,
    t1 = Unsafe[1],
    regExp = t1.RegExp,
    t2 = Unsafe[1],
    object_constructor = t2.Object;
   function object_keys(o){return object_constructor.keys(o);}
   var
    t5 = Unsafe[1],
    array_constructor = t5.Array,
    array_get = caml_js_get,
    array_set = caml_js_set;
   function array_map(f, a){
    return a.map
            (caml_js_wrap_callback
              (function(x, idx, param){return caml_call1(f, x);}));
   }
   function array_mapi(f, a){
    return a.map
            (caml_js_wrap_callback
              (function(x, idx, param){return caml_call2(f, idx, x);}));
   }
   function str_array(_p_){return _p_;}
   function match_result(_o_){return _o_;}
   var
    t8 = Unsafe[1],
    date_constr = t8.Date,
    t9 = Unsafe[1],
    math = t9.Math,
    t10 = Unsafe[1],
    error_constr = t10.Error,
    include = Jsoo_runtime[3],
    raise = include[1],
    exn_with_js_backtrace = include[2],
    of_exn = include[3],
    Error = include[4];
   function name(t11){return caml_string_of_jsstring(t11.name);}
   function message(t12){return caml_string_of_jsstring(t12.message);}
   function stack(t13){
    var _n_ = caml_call2(Opt[3], t13.stack, caml_string_of_jsstring);
    return caml_call1(Opt[10], _n_);
   }
   function to_string(e){return caml_string_of_jsstring(e.toString());}
   function raise_js_error(e){return caml_call1(raise, e);}
   function string_of_error(e){return to_string(e);}
   var t15 = Unsafe[1], JSON = t15.JSON;
   function decodeURI(s){var t16 = Unsafe[1]; return t16.decodeURI(s);}
   function decodeURIComponent(s){
    var t17 = Unsafe[1];
    return t17.decodeURIComponent(s);
   }
   function encodeURI(s){var t18 = Unsafe[1]; return t18.encodeURI(s);}
   function encodeURIComponent(s){
    var t19 = Unsafe[1];
    return t19.encodeURIComponent(s);
   }
   function escape(s){var t20 = Unsafe[1]; return t20.escape(s);}
   function unescape(s){var t21 = Unsafe[1]; return t21.unescape(s);}
   function isNaN(i){var t22 = Unsafe[1]; return t22.isNaN(i) | 0;}
   function parseInt(s){
    var t23 = Unsafe[1], s$0 = t23.parseInt(s);
    return isNaN(s$0) ? caml_call1(Stdlib[2], cst_parseInt) : s$0;
   }
   function parseFloat(s){
    var t24 = Unsafe[1], s$0 = t24.parseFloat(s);
    return isNaN(s$0) ? caml_call1(Stdlib[2], cst_parseFloat) : s$0;
   }
   function _a_(param){
    if(param[1] !== Error) return 0;
    var e = param[2];
    return [0, to_string(e)];
   }
   caml_call1(Stdlib_Printexc[9], _a_);
   function _b_(e){
    return e instanceof array_constructor
            ? 0
            : [0, caml_string_of_jsstring(e.toString())];
   }
   caml_call1(Stdlib_Printexc[9], _b_);
   function export_js(field, x){
    var _l_ = caml_string_of_jsstring(typeof x), switch$0 = 0;
    if
     (caml_call2(Js_of_ocaml_Import[3][64], _l_, cst_function) && 0 < x.length){var _m_ = caml_js_wrap_callback(x); switch$0 = 1;}
    if(! switch$0) var _m_ = x;
    return jsoo_exports[field] = _m_;
   }
   function export$0(field, x){
    return export_js(runtime.caml_jsstring_of_string(field), x);
   }
   function export_all(obj){
    var keys = object_keys(obj);
    return keys.forEach
            (caml_js_wrap_callback
              (function(key, param, _k_){return export_js(key, obj[key]);}));
   }
   var _c_ = runtime.caml_js_error_of_exception;
   function _d_(_j_){return _j_;}
   var
    _e_ =
      [0,
       to_string,
       name,
       message,
       stack,
       raise,
       exn_with_js_backtrace,
       of_exn,
       Error,
       function(_i_){return _i_;},
       _d_];
   function _f_(_h_){return _h_;}
   var
    Js_of_ocaml_Js =
      [0,
       null$0,
       function(_g_){return _g_;},
       undefined$0,
       _f_,
       Opt,
       Optdef,
       true$0,
       false$0,
       nfd,
       nfc,
       nfkd,
       nfkc,
       string_constr,
       regExp,
       regExp,
       regExp,
       object_keys,
       array_constructor,
       array_constructor,
       array_get,
       array_set,
       array_map,
       array_mapi,
       str_array,
       match_result,
       date_constr,
       date_constr,
       date_constr,
       date_constr,
       date_constr,
       date_constr,
       date_constr,
       date_constr,
       date_constr,
       math,
       error_constr,
       _e_,
       JSON,
       decodeURI,
       decodeURIComponent,
       encodeURI,
       encodeURIComponent,
       escape,
       unescape,
       isNaN,
       parseInt,
       parseFloat,
       coerce,
       coerce_opt,
       export$0,
       export_all,
       Unsafe,
       string_of_error,
       raise_js_error,
       exn_with_js_backtrace,
       _c_,
       Error];
   runtime.caml_register_global(43, Js_of_ocaml_Js, "Js_of_ocaml__Js");
   return;
  }
  (globalThis));

//# 486 "../../.js/default/js_of_ocaml/js_of_ocaml.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Js_of_ocaml_Js = global_data.Js_of_ocaml__Js,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List,
    _a_ = [0, "lib/js_of_ocaml/dom.ml", 351, 67];
   function list_of_nodeList(nodeList){
    var length = nodeList.length, acc = 0, i = 0;
    for(;;){
     if(i >= length) return caml_call1(Stdlib_List[9], acc);
     var
      _l_ = nodeList.item(i),
      match = caml_call1(Js_of_ocaml_Js[5][10], _l_);
     if(match){
      var
       e = match[1],
       i$0 = i + 1 | 0,
       acc$0 = [0, e, acc],
       acc = acc$0,
       i = i$0;
      continue;
     }
     var i$1 = i + 1 | 0, i = i$1;
    }
   }
   var
    disconnected = 1,
    preceding = 2,
    following = 4,
    contains = 8,
    contained_by = 16,
    implementation_specific = 32;
   function has(t, mask){return (t & mask) === mask ? 1 : 0;}
   function add(x, y){return x | y;}
   var
    DocumentPosition =
      [0,
       disconnected,
       preceding,
       following,
       contains,
       contained_by,
       implementation_specific,
       has,
       add,
       add];
   function appendChild(p, n){p.appendChild(n); return 0;}
   function removeChild(p, n){p.removeChild(n); return 0;}
   function replaceChild(p, n, o){p.replaceChild(n, o); return 0;}
   function insertBefore(p, n, o){p.insertBefore(n, o); return 0;}
   function nodeType(t13){
    var match = t13.nodeType;
    if(match)
     switch(match - 1 | 0){
       case 0:
        return [0, t13];
       case 1:
        return [1, t13];
       case 2:
       case 3:
        return [2, t13];
     }
    return [3, t13];
   }
   function cast(t14, t){
    return t14.nodeType === t
            ? caml_call1(Js_of_ocaml_Js[2], t14)
            : Js_of_ocaml_Js[1];
   }
   function element(e){return cast(e, 1);}
   function text(t15){
    if(3 !== t15.nodeType && 4 !== t15.nodeType) return Js_of_ocaml_Js[1];
    return caml_call1(Js_of_ocaml_Js[2], t15);
   }
   function attr(e){return cast(e, 2);}
   var no_handler = Js_of_ocaml_Js[1];
   function handler(f){
    var
     _j_ =
       runtime.caml_js_wrap_callback_unsafe
        (function(e){
          var _k_ = caml_call1(Js_of_ocaml_Js[2], e);
          if(caml_call1(Js_of_ocaml_Js[5][5], _k_)){
           var res = caml_call1(f, e);
           if(1 - (res | 0)) e.preventDefault();
           return res;
          }
          var t18 = event, res$0 = caml_call1(f, t18);
          if(1 - (res$0 | 0)) t18.returnValue = res$0;
          return res$0;
         });
    return caml_call1(Js_of_ocaml_Js[2], _j_);
   }
   function full_handler(f){
    var
     _h_ =
       runtime.caml_js_wrap_meth_callback_unsafe
        (function(this$0, e){
          var _i_ = caml_call1(Js_of_ocaml_Js[2], e);
          if(caml_call1(Js_of_ocaml_Js[5][5], _i_)){
           var res = caml_call2(f, this$0, e);
           if(1 - (res | 0)) e.preventDefault();
           return res;
          }
          var t21 = event, res$0 = caml_call2(f, this$0, t21);
          if(1 - (res$0 | 0)) t21.returnValue = res$0;
          return res$0;
         });
    return caml_call1(Js_of_ocaml_Js[2], _h_);
   }
   function invoke_handler(f, this$0, event){return f.call(this$0, event);}
   function eventTarget(t24){
    function _e_(param){
     function _g_(param){throw caml_maybe_attach_backtrace(Stdlib[8], 1);}
     return caml_call2(Js_of_ocaml_Js[5][8], t24.srcElement, _g_);
    }
    var
     target = caml_call2(Js_of_ocaml_Js[5][8], t24.target, _e_),
     t25 = Js_of_ocaml_Js[52][1];
    if(! (target instanceof t25.Node)) return target;
    if(3 !== target.nodeType) return target;
    function _f_(param){
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    }
    return caml_call2(Js_of_ocaml_Js[5][8], target.parentNode, _f_);
   }
   var make = runtime.caml_jsstring_of_string, Event = [0, make];
   function addEventListenerWithOptions(t28, typ, capture, once, passive, h){
    if(t28.addEventListener === Js_of_ocaml_Js[3]){
     var
      ev = "on".concat(typ),
      callback =
        function(e){
         var _b_ = [0, h, e, [0]];
         return function(_c_, _d_){
          return runtime.caml_js_call(_b_, _c_, _d_);};
        };
     t28.attachEvent(ev, callback);
     return function(param){return t28.detachEvent(ev, callback);};
    }
    var opts = {};
    function iter(t, f){
     if(! t) return 0;
     var b = t[1];
     return caml_call1(f, b);
    }
    iter(capture, function(t37){return opts.capture = t37;});
    iter(once, function(t39){return opts.once = t39;});
    iter(passive, function(t41){return opts.passive = t41;});
    t28.addEventListener(typ, h, opts);
    return function(param){return t28.removeEventListener(typ, h, opts);};
   }
   function addEventListener(e, typ, h, capt){
    return addEventListenerWithOptions(e, typ, [0, capt], 0, 0, h);
   }
   function removeEventListener(id){return caml_call1(id, 0);}
   function preventDefault(t51){
    if(caml_call1(Js_of_ocaml_Js[6][5], t51.preventDefault))
     return t51.preventDefault();
    var t53 = ! ! 0;
    return t51.returnValue = t53;
   }
   function createCustomEvent(bubbles, cancelable, detail, typ){
    function opt_iter(f, param){
     if(! param) return 0;
     var x = param[1];
     return caml_call1(f, x);
    }
    var opts = {};
    opt_iter
     (function(x){var t55 = ! ! x; return opts.bubbles = t55;}, bubbles);
    opt_iter
     (function(x){var t57 = ! ! x; return opts.cancelable = t57;}, cancelable);
    opt_iter
     (function(x){
       var t59 = caml_call1(Js_of_ocaml_Js[2], x);
       return opts.detail = t59;
      },
      detail);
    var t61 = Js_of_ocaml_Js[52][1], constr = t61.CustomEvent;
    return new constr(typ, opts);
   }
   var
    Js_of_ocaml_Dom =
      [0,
       DocumentPosition,
       insertBefore,
       replaceChild,
       removeChild,
       appendChild,
       list_of_nodeList,
       nodeType,
       [0, element, text, attr],
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       Event,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       preventDefault,
       createCustomEvent];
   runtime.caml_register_global(42, Js_of_ocaml_Dom, "Js_of_ocaml__Dom");
   return;
  }
  (globalThis));

//# 972 "../../.js/default/js_of_ocaml/js_of_ocaml.cma.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    cst$0 = '"',
    cst_a$1 = "a",
    cst_area$1 = "area",
    cst_audio$1 = "audio",
    cst_base$1 = "base",
    cst_blockquote$1 = "blockquote",
    cst_body$1 = "body",
    cst_br$1 = "br",
    cst_button$1 = "button",
    cst_canvas$1 = "canvas",
    cst_caption$1 = "caption",
    cst_code$0 = "code",
    cst_col$1 = "col",
    cst_colgroup$1 = "colgroup",
    cst_del$1 = "del",
    cst_div$1 = "div",
    cst_dl$1 = "dl",
    cst_embed$1 = "embed",
    cst_fieldset$1 = "fieldset",
    cst_form$1 = "form",
    cst_frame$1 = "frame",
    cst_frameset$1 = "frameset",
    cst_h1$1 = "h1",
    cst_h2$1 = "h2",
    cst_h3$1 = "h3",
    cst_h4$1 = "h4",
    cst_h5$1 = "h5",
    cst_h6$1 = "h6",
    cst_head$1 = "head",
    cst_hr$1 = "hr",
    cst_html$1 = "html",
    cst_iframe$1 = "iframe",
    cst_img$1 = "img",
    cst_input$1 = "input",
    cst_ins$1 = "ins",
    cst_label$1 = "label",
    cst_legend$1 = "legend",
    cst_li$1 = "li",
    cst_lib_js_of_ocaml_dom_html_m = "lib/js_of_ocaml/dom_html.ml",
    cst_link$1 = "link",
    cst_map$1 = "map",
    cst_meta$1 = "meta",
    cst_mouseout = "mouseout",
    cst_mouseover = "mouseover",
    cst_object$1 = "object",
    cst_ol$1 = "ol",
    cst_optgroup$1 = "optgroup",
    cst_option$1 = "option",
    cst_p$1 = "p",
    cst_param$1 = "param",
    cst_pre$1 = "pre",
    cst_q$1 = "q",
    cst_script$1 = "script",
    cst_select$1 = "select",
    cst_style$1 = "style",
    cst_table$1 = "table",
    cst_tbody$1 = "tbody",
    cst_td$1 = "td",
    cst_textarea$1 = "textarea",
    cst_tfoot$1 = "tfoot",
    cst_th$1 = "th",
    cst_thead$1 = "thead",
    cst_title$1 = "title",
    cst_tr$1 = "tr",
    cst_ul$1 = "ul",
    cst_video$1 = "video",
    caml_js_html_escape = runtime.caml_js_html_escape,
    caml_jsstring_of_string = runtime.caml_jsstring_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_string_of_jsstring = runtime.caml_string_of_jsstring,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Js_of_ocaml_Js = global_data.Js_of_ocaml__Js,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Js_of_ocaml_Dom = global_data.Js_of_ocaml__Dom,
    onIE = runtime.caml_js_on_ie(0) | 0,
    no_handler = Js_of_ocaml_Dom[9],
    handler = Js_of_ocaml_Dom[10],
    full_handler = Js_of_ocaml_Dom[11],
    invoke_handler = Js_of_ocaml_Dom[12],
    click = caml_call1(Js_of_ocaml_Dom[14][1], "click"),
    copy = caml_call1(Js_of_ocaml_Dom[14][1], "copy"),
    cut = caml_call1(Js_of_ocaml_Dom[14][1], "cut"),
    paste = caml_call1(Js_of_ocaml_Dom[14][1], "paste"),
    dblclick = caml_call1(Js_of_ocaml_Dom[14][1], "dblclick"),
    mousedown = caml_call1(Js_of_ocaml_Dom[14][1], "mousedown"),
    mouseup = caml_call1(Js_of_ocaml_Dom[14][1], "mouseup"),
    mouseover = caml_call1(Js_of_ocaml_Dom[14][1], cst_mouseover),
    mousemove = caml_call1(Js_of_ocaml_Dom[14][1], "mousemove"),
    mouseout = caml_call1(Js_of_ocaml_Dom[14][1], cst_mouseout),
    keypress = caml_call1(Js_of_ocaml_Dom[14][1], "keypress"),
    keydown = caml_call1(Js_of_ocaml_Dom[14][1], "keydown"),
    keyup = caml_call1(Js_of_ocaml_Dom[14][1], "keyup"),
    mousewheel = caml_call1(Js_of_ocaml_Dom[14][1], "mousewheel"),
    wheel = caml_call1(Js_of_ocaml_Dom[14][1], "wheel"),
    DOMMouseScroll = caml_call1(Js_of_ocaml_Dom[14][1], "DOMMouseScroll"),
    touchstart = caml_call1(Js_of_ocaml_Dom[14][1], "touchstart"),
    touchmove = caml_call1(Js_of_ocaml_Dom[14][1], "touchmove"),
    touchend = caml_call1(Js_of_ocaml_Dom[14][1], "touchend"),
    touchcancel = caml_call1(Js_of_ocaml_Dom[14][1], "touchcancel"),
    dragstart = caml_call1(Js_of_ocaml_Dom[14][1], "dragstart"),
    dragend = caml_call1(Js_of_ocaml_Dom[14][1], "dragend"),
    dragenter = caml_call1(Js_of_ocaml_Dom[14][1], "dragenter"),
    dragover = caml_call1(Js_of_ocaml_Dom[14][1], "dragover"),
    dragleave = caml_call1(Js_of_ocaml_Dom[14][1], "dragleave"),
    drag = caml_call1(Js_of_ocaml_Dom[14][1], "drag"),
    drop = caml_call1(Js_of_ocaml_Dom[14][1], "drop"),
    hashchange = caml_call1(Js_of_ocaml_Dom[14][1], "hashchange"),
    change = caml_call1(Js_of_ocaml_Dom[14][1], "change"),
    input = caml_call1(Js_of_ocaml_Dom[14][1], cst_input$1),
    timeupdate = caml_call1(Js_of_ocaml_Dom[14][1], "timeupdate"),
    submit = caml_call1(Js_of_ocaml_Dom[14][1], "submit"),
    scroll = caml_call1(Js_of_ocaml_Dom[14][1], "scroll"),
    focus = caml_call1(Js_of_ocaml_Dom[14][1], "focus"),
    blur = caml_call1(Js_of_ocaml_Dom[14][1], "blur"),
    load = caml_call1(Js_of_ocaml_Dom[14][1], "load"),
    unload = caml_call1(Js_of_ocaml_Dom[14][1], "unload"),
    beforeunload = caml_call1(Js_of_ocaml_Dom[14][1], "beforeunload"),
    resize = caml_call1(Js_of_ocaml_Dom[14][1], "resize"),
    orientationchange =
      caml_call1(Js_of_ocaml_Dom[14][1], "orientationchange"),
    popstate = caml_call1(Js_of_ocaml_Dom[14][1], "popstate"),
    error = caml_call1(Js_of_ocaml_Dom[14][1], "error"),
    abort = caml_call1(Js_of_ocaml_Dom[14][1], "abort"),
    select = caml_call1(Js_of_ocaml_Dom[14][1], cst_select$1),
    online = caml_call1(Js_of_ocaml_Dom[14][1], "online"),
    offline = caml_call1(Js_of_ocaml_Dom[14][1], "offline"),
    checking = caml_call1(Js_of_ocaml_Dom[14][1], "checking"),
    noupdate = caml_call1(Js_of_ocaml_Dom[14][1], "noupdate"),
    downloading = caml_call1(Js_of_ocaml_Dom[14][1], "downloading"),
    progress = caml_call1(Js_of_ocaml_Dom[14][1], "progress"),
    updateready = caml_call1(Js_of_ocaml_Dom[14][1], "updateready"),
    cached = caml_call1(Js_of_ocaml_Dom[14][1], "cached"),
    obsolete = caml_call1(Js_of_ocaml_Dom[14][1], "obsolete"),
    domContentLoaded = caml_call1(Js_of_ocaml_Dom[14][1], "DOMContentLoaded"),
    animationstart = caml_call1(Js_of_ocaml_Dom[14][1], "animationstart"),
    animationend = caml_call1(Js_of_ocaml_Dom[14][1], "animationend"),
    animationiteration =
      caml_call1(Js_of_ocaml_Dom[14][1], "animationiteration"),
    animationcancel = caml_call1(Js_of_ocaml_Dom[14][1], "animationcancel"),
    transitionrun = caml_call1(Js_of_ocaml_Dom[14][1], "transitionrun"),
    transitionstart = caml_call1(Js_of_ocaml_Dom[14][1], "transitionstart"),
    transitionend = caml_call1(Js_of_ocaml_Dom[14][1], "transitionend"),
    transitioncancel = caml_call1(Js_of_ocaml_Dom[14][1], "transitioncancel"),
    canplay = caml_call1(Js_of_ocaml_Dom[14][1], "canplay"),
    canplaythrough = caml_call1(Js_of_ocaml_Dom[14][1], "canplaythrough"),
    durationchange = caml_call1(Js_of_ocaml_Dom[14][1], "durationchange"),
    emptied = caml_call1(Js_of_ocaml_Dom[14][1], "emptied"),
    ended = caml_call1(Js_of_ocaml_Dom[14][1], "ended"),
    gotpointercapture =
      caml_call1(Js_of_ocaml_Dom[14][1], "gotpointercapture"),
    loadeddata = caml_call1(Js_of_ocaml_Dom[14][1], "loadeddata"),
    loadedmetadata = caml_call1(Js_of_ocaml_Dom[14][1], "loadedmetadata"),
    loadstart = caml_call1(Js_of_ocaml_Dom[14][1], "loadstart"),
    lostpointercapture =
      caml_call1(Js_of_ocaml_Dom[14][1], "lostpointercapture"),
    message = caml_call1(Js_of_ocaml_Dom[14][1], "message"),
    pause = caml_call1(Js_of_ocaml_Dom[14][1], "pause"),
    play = caml_call1(Js_of_ocaml_Dom[14][1], "play"),
    playing = caml_call1(Js_of_ocaml_Dom[14][1], "playing"),
    pointerenter = caml_call1(Js_of_ocaml_Dom[14][1], "pointerenter"),
    pointercancel = caml_call1(Js_of_ocaml_Dom[14][1], "pointercancel"),
    pointerdown = caml_call1(Js_of_ocaml_Dom[14][1], "pointerdown"),
    pointerleave = caml_call1(Js_of_ocaml_Dom[14][1], "pointerleave"),
    pointermove = caml_call1(Js_of_ocaml_Dom[14][1], "pointermove"),
    pointerout = caml_call1(Js_of_ocaml_Dom[14][1], "pointerout"),
    pointerover = caml_call1(Js_of_ocaml_Dom[14][1], "pointerover"),
    pointerup = caml_call1(Js_of_ocaml_Dom[14][1], "pointerup"),
    ratechange = caml_call1(Js_of_ocaml_Dom[14][1], "ratechange"),
    seeked = caml_call1(Js_of_ocaml_Dom[14][1], "seeked"),
    seeking = caml_call1(Js_of_ocaml_Dom[14][1], "seeking"),
    stalled = caml_call1(Js_of_ocaml_Dom[14][1], "stalled"),
    suspend = caml_call1(Js_of_ocaml_Dom[14][1], "suspend"),
    volumechange = caml_call1(Js_of_ocaml_Dom[14][1], "volumechange"),
    waiting = caml_call1(Js_of_ocaml_Dom[14][1], "waiting"),
    make = Js_of_ocaml_Dom[14][1],
    addEventListener = Js_of_ocaml_Dom[16],
    addEventListenerWithOptions = Js_of_ocaml_Dom[15],
    removeEventListener = Js_of_ocaml_Dom[17],
    createCustomEvent = Js_of_ocaml_Dom[19],
    d = "2d",
    _d_ = [0, cst_lib_js_of_ocaml_dom_html_m, 2896, 58],
    _c_ = [0, cst_lib_js_of_ocaml_dom_html_m, 2895, 61],
    cst_video$0 = cst_video$1,
    cst_audio$0 = cst_audio$1,
    cst_ul$0 = cst_ul$1,
    cst_tr$0 = cst_tr$1,
    cst_title$0 = cst_title$1,
    cst_thead$0 = cst_thead$1,
    cst_th$0 = cst_th$1,
    cst_tfoot$0 = cst_tfoot$1,
    cst_textarea$0 = cst_textarea$1,
    cst_td$0 = cst_td$1,
    cst_tbody$0 = cst_tbody$1,
    cst_table$0 = cst_table$1,
    cst_style$0 = cst_style$1,
    cst_select$0 = cst_select$1,
    cst_script$0 = cst_script$1,
    cst_q$0 = cst_q$1,
    cst_pre$0 = cst_pre$1,
    cst_param$0 = cst_param$1,
    cst_p$0 = cst_p$1,
    cst_option$0 = cst_option$1,
    cst_optgroup$0 = cst_optgroup$1,
    cst_ol$0 = cst_ol$1,
    cst_object$0 = cst_object$1,
    cst_meta$0 = cst_meta$1,
    cst_map$0 = cst_map$1,
    cst_link$0 = cst_link$1,
    cst_li$0 = cst_li$1,
    cst_legend$0 = cst_legend$1,
    cst_label$0 = cst_label$1,
    cst_ins$0 = cst_ins$1,
    cst_input$0 = cst_input$1,
    cst_img$0 = cst_img$1,
    cst_iframe$0 = cst_iframe$1,
    cst_html$0 = cst_html$1,
    cst_hr$0 = cst_hr$1,
    cst_head$0 = cst_head$1,
    cst_h6$0 = cst_h6$1,
    cst_h5$0 = cst_h5$1,
    cst_h4$0 = cst_h4$1,
    cst_h3$0 = cst_h3$1,
    cst_h2$0 = cst_h2$1,
    cst_h1$0 = cst_h1$1,
    cst_frame$0 = cst_frame$1,
    cst_frameset$0 = cst_frameset$1,
    cst_form$0 = cst_form$1,
    cst_embed$0 = cst_embed$1,
    cst_fieldset$0 = cst_fieldset$1,
    cst_dl$0 = cst_dl$1,
    cst_div$0 = cst_div$1,
    cst_del$0 = cst_del$1,
    cst_colgroup$0 = cst_colgroup$1,
    cst_col$0 = cst_col$1,
    cst_caption$0 = cst_caption$1,
    cst_canvas$0 = cst_canvas$1,
    cst_button$0 = cst_button$1,
    cst_br$0 = cst_br$1,
    cst_body$0 = cst_body$1,
    cst_blockquote$0 = cst_blockquote$1,
    cst_base$0 = cst_base$1,
    cst_area$0 = cst_area$1,
    cst_a$0 = cst_a$1,
    cst_canvas = cst_canvas$1,
    cst_video = cst_video$1,
    cst_audio = cst_audio$1,
    cst_iframe = cst_iframe$1,
    cst_frame = cst_frame$1,
    cst_frameset = cst_frameset$1,
    cst_address = "address",
    cst_noscript = "noscript",
    cst_dt = "dt",
    cst_dd = "dd",
    cst_abbr = "abbr",
    cst_var = "var",
    cst_kbd = "kbd",
    cst_samp = "samp",
    cst_code = cst_code$0,
    cst_dfn = "dfn",
    cst_cite = "cite",
    cst_strong = "strong",
    cst_em = "em",
    cst_small = "small",
    cst_big = "big",
    cst_b = "b",
    cst_i = "i",
    cst_tt = "tt",
    cst_span = "span",
    cst_sup = "sup",
    cst_sub = "sub",
    cst_td = cst_td$1,
    cst_th = cst_th$1,
    cst_tr = cst_tr$1,
    cst_tbody = cst_tbody$1,
    cst_tfoot = cst_tfoot$1,
    cst_thead = cst_thead$1,
    cst_colgroup = cst_colgroup$1,
    cst_col = cst_col$1,
    cst_caption = cst_caption$1,
    cst_table = cst_table$1,
    cst_script = cst_script$1,
    cst_area = cst_area$1,
    cst_map = cst_map$1,
    cst_param = cst_param$1,
    cst_object = cst_object$1,
    cst_img = cst_img$1,
    cst_a = cst_a$1,
    cst_del = cst_del$1,
    cst_ins = cst_ins$1,
    cst_hr = cst_hr$1,
    cst_br = cst_br$1,
    cst_pre = cst_pre$1,
    cst_blockquote = cst_blockquote$1,
    cst_q = cst_q$1,
    cst_h6 = cst_h6$1,
    cst_h5 = cst_h5$1,
    cst_h4 = cst_h4$1,
    cst_h3 = cst_h3$1,
    cst_h2 = cst_h2$1,
    cst_h1 = cst_h1$1,
    cst_p = cst_p$1,
    cst_embed = cst_embed$1,
    cst_div = cst_div$1,
    cst_li = cst_li$1,
    cst_dl = cst_dl$1,
    cst_ol = cst_ol$1,
    cst_ul = cst_ul$1,
    cst_legend = cst_legend$1,
    cst_fieldset = cst_fieldset$1,
    cst_label = cst_label$1,
    cst_button = cst_button$1,
    cst_textarea = cst_textarea$1,
    cst_input = cst_input$1,
    cst_select = cst_select$1,
    cst_option = cst_option$1,
    cst_optgroup = cst_optgroup$1,
    cst_form = cst_form$1,
    cst_body = cst_body$1,
    cst_style = cst_style$1,
    cst_base = cst_base$1,
    cst_meta = cst_meta$1,
    cst_title = cst_title$1,
    cst_link = cst_link$1,
    cst_head = cst_head$1,
    cst_html = cst_html$1,
    _a_ =
      [0,
       [11, "getElementById_exn: ", [3, 0, [11, " not found", 0]]],
       "getElementById_exn: %S not found"],
    cst_Js_of_ocaml_Dom_html_Canva =
      "Js_of_ocaml__Dom_html.Canvas_not_available";
   function location_origin(loc){
    function _ay_(o){return o;}
    function _az_(param){
     var protocol = loc.protocol, hostname = loc.hostname, port = loc.port;
     if(0 === protocol.length && 0 === hostname.length) return cst;
     var origin = protocol.concat("//", hostname);
     return 0 < port.length ? origin.concat(":", loc.port) : origin;
    }
    return caml_call3(Js_of_ocaml_Js[6][7], loc.origin, _az_, _ay_);
   }
   var window = Js_of_ocaml_Js[52][1], document = window.document;
   function getElementById(id){
    function _av_(pnode){return pnode;}
    function _aw_(param){throw caml_maybe_attach_backtrace(Stdlib[8], 1);}
    var _ax_ = document.getElementById(caml_jsstring_of_string(id));
    return caml_call3(Js_of_ocaml_Js[5][7], _ax_, _aw_, _av_);
   }
   function getElementById_exn(id){
    function _ar_(pnode){return pnode;}
    function _as_(param){
     var _au_ = caml_call2(Stdlib_Printf[4], _a_, id);
     return caml_call1(Stdlib[2], _au_);
    }
    var _at_ = document.getElementById(caml_jsstring_of_string(id));
    return caml_call3(Js_of_ocaml_Js[5][7], _at_, _as_, _ar_);
   }
   function getElementById_opt(id){
    var _aq_ = document.getElementById(caml_jsstring_of_string(id));
    return caml_call1(Js_of_ocaml_Js[5][10], _aq_);
   }
   function getElementById_coerce(id, coerce){
    function _am_(e){
     var _ap_ = caml_call1(coerce, e);
     return caml_call1(Js_of_ocaml_Js[5][10], _ap_);
    }
    function _an_(param){return 0;}
    var _ao_ = document.getElementById(caml_jsstring_of_string(id));
    return caml_call3(Js_of_ocaml_Js[5][7], _ao_, _an_, _am_);
   }
   function opt_iter(x, f){
    if(! x) return 0;
    var v = x[1];
    return caml_call1(f, v);
   }
   function createElement(doc, name){
    return doc.createElement(caml_jsstring_of_string(name));
   }
   function unsafeCreateElement(doc, name){return createElement(doc, name);}
   var createElementSyntax = [0, 785140586];
   function unsafeCreateElementEx(type, name, doc, elt){
    for(;;){
     if(0 === type && 0 === name) return createElement(doc, elt);
     var _ag_ = createElementSyntax[1];
     if(785140586 === _ag_){
      try{
       var
        t49 = document.createElement('<input name="x">'),
        _aj_ = t49.tagName.toLowerCase() === cst_input$1 ? 1 : 0,
        _ak_ = _aj_ ? t49.name === "x" ? 1 : 0 : _aj_,
        _ah_ = _ak_;
      }
      catch(_al_){var _ah_ = 0;}
      var _ai_ = _ah_ ? 982028505 : -1003883683;
      createElementSyntax[1] = _ai_;
      continue;
     }
     if(982028505 <= _ag_){
      var a = new Js_of_ocaml_Js[18];
      a.push("<", caml_jsstring_of_string(elt));
      opt_iter
       (type,
        function(t){
         a.push(' type="', caml_js_html_escape(t), cst$0);
         return 0;
        });
      opt_iter
       (name,
        function(n){
         a.push(' name="', caml_js_html_escape(n), cst$0);
         return 0;
        });
      a.push(">");
      return doc.createElement(a.join(cst));
     }
     var res = createElement(doc, elt);
     opt_iter(type, function(t25){return res.type = t25;});
     opt_iter(name, function(t27){return res.name = t27;});
     return res;
    }
   }
   function createHtml(doc){return unsafeCreateElement(doc, cst_html);}
   function createHead(doc){return unsafeCreateElement(doc, cst_head);}
   function createLink(doc){return unsafeCreateElement(doc, cst_link);}
   function createTitle(doc){return unsafeCreateElement(doc, cst_title);}
   function createMeta(doc){return unsafeCreateElement(doc, cst_meta);}
   function createBase(doc){return unsafeCreateElement(doc, cst_base);}
   function createStyle(doc){return unsafeCreateElement(doc, cst_style);}
   function createBody(doc){return unsafeCreateElement(doc, cst_body);}
   function createForm(doc){return unsafeCreateElement(doc, cst_form);}
   function createOptgroup(doc){
    return unsafeCreateElement(doc, cst_optgroup);
   }
   function createOption(doc){return unsafeCreateElement(doc, cst_option);}
   function createSelect(type, name, doc){
    return unsafeCreateElementEx(type, name, doc, cst_select);
   }
   function createInput(type, name, doc){
    return unsafeCreateElementEx(type, name, doc, cst_input);
   }
   function createTextarea(type, name, doc){
    return unsafeCreateElementEx(type, name, doc, cst_textarea);
   }
   function createButton(type, name, doc){
    return unsafeCreateElementEx(type, name, doc, cst_button);
   }
   function createLabel(doc){return unsafeCreateElement(doc, cst_label);}
   function createFieldset(doc){
    return unsafeCreateElement(doc, cst_fieldset);
   }
   function createLegend(doc){return unsafeCreateElement(doc, cst_legend);}
   function createUl(doc){return unsafeCreateElement(doc, cst_ul);}
   function createOl(doc){return unsafeCreateElement(doc, cst_ol);}
   function createDl(doc){return unsafeCreateElement(doc, cst_dl);}
   function createLi(doc){return unsafeCreateElement(doc, cst_li);}
   function createDiv(doc){return unsafeCreateElement(doc, cst_div);}
   function createEmbed(doc){return unsafeCreateElement(doc, cst_embed);}
   function createP(doc){return unsafeCreateElement(doc, cst_p);}
   function createH1(doc){return unsafeCreateElement(doc, cst_h1);}
   function createH2(doc){return unsafeCreateElement(doc, cst_h2);}
   function createH3(doc){return unsafeCreateElement(doc, cst_h3);}
   function createH4(doc){return unsafeCreateElement(doc, cst_h4);}
   function createH5(doc){return unsafeCreateElement(doc, cst_h5);}
   function createH6(doc){return unsafeCreateElement(doc, cst_h6);}
   function createQ(doc){return unsafeCreateElement(doc, cst_q);}
   function createBlockquote(doc){
    return unsafeCreateElement(doc, cst_blockquote);
   }
   function createPre(doc){return unsafeCreateElement(doc, cst_pre);}
   function createBr(doc){return unsafeCreateElement(doc, cst_br);}
   function createHr(doc){return unsafeCreateElement(doc, cst_hr);}
   function createIns(doc){return unsafeCreateElement(doc, cst_ins);}
   function createDel(doc){return unsafeCreateElement(doc, cst_del);}
   function createA(doc){return unsafeCreateElement(doc, cst_a);}
   function createImg(doc){return unsafeCreateElement(doc, cst_img);}
   function createObject(doc){return unsafeCreateElement(doc, cst_object);}
   function createParam(doc){return unsafeCreateElement(doc, cst_param);}
   function createMap(doc){return unsafeCreateElement(doc, cst_map);}
   function createArea(doc){return unsafeCreateElement(doc, cst_area);}
   function createScript(doc){return unsafeCreateElement(doc, cst_script);}
   function createTable(doc){return unsafeCreateElement(doc, cst_table);}
   function createCaption(doc){return unsafeCreateElement(doc, cst_caption);}
   function createCol(doc){return unsafeCreateElement(doc, cst_col);}
   function createColgroup(doc){
    return unsafeCreateElement(doc, cst_colgroup);
   }
   function createThead(doc){return unsafeCreateElement(doc, cst_thead);}
   function createTfoot(doc){return unsafeCreateElement(doc, cst_tfoot);}
   function createTbody(doc){return unsafeCreateElement(doc, cst_tbody);}
   function createTr(doc){return unsafeCreateElement(doc, cst_tr);}
   function createTh(doc){return unsafeCreateElement(doc, cst_th);}
   function createTd(doc){return unsafeCreateElement(doc, cst_td);}
   function createSub(doc){return createElement(doc, cst_sub);}
   function createSup(doc){return createElement(doc, cst_sup);}
   function createSpan(doc){return createElement(doc, cst_span);}
   function createTt(doc){return createElement(doc, cst_tt);}
   function createI(doc){return createElement(doc, cst_i);}
   function createB(doc){return createElement(doc, cst_b);}
   function createBig(doc){return createElement(doc, cst_big);}
   function createSmall(doc){return createElement(doc, cst_small);}
   function createEm(doc){return createElement(doc, cst_em);}
   function createStrong(doc){return createElement(doc, cst_strong);}
   function createCite(doc){return createElement(doc, cst_cite);}
   function createDfn(doc){return createElement(doc, cst_dfn);}
   function createCode(doc){return createElement(doc, cst_code);}
   function createSamp(doc){return createElement(doc, cst_samp);}
   function createKbd(doc){return createElement(doc, cst_kbd);}
   function createVar(doc){return createElement(doc, cst_var);}
   function createAbbr(doc){return createElement(doc, cst_abbr);}
   function createDd(doc){return createElement(doc, cst_dd);}
   function createDt(doc){return createElement(doc, cst_dt);}
   function createNoscript(doc){return createElement(doc, cst_noscript);}
   function createAddress(doc){return createElement(doc, cst_address);}
   function createFrameset(doc){
    return unsafeCreateElement(doc, cst_frameset);
   }
   function createFrame(doc){return unsafeCreateElement(doc, cst_frame);}
   function createIframe(doc){return unsafeCreateElement(doc, cst_iframe);}
   function createAudio(doc){return unsafeCreateElement(doc, cst_audio);}
   function createVideo(doc){return unsafeCreateElement(doc, cst_video);}
   var
    Canvas_not_available =
      [248, cst_Js_of_ocaml_Dom_html_Canva, runtime.caml_fresh_oo_id(0)];
   function createCanvas(doc){
    var t52 = unsafeCreateElement(doc, cst_canvas);
    if(1 - caml_call1(Js_of_ocaml_Js[5][5], t52.getContext))
     throw caml_maybe_attach_backtrace(Canvas_not_available, 1);
    return t52;
   }
   var
    t53 = Js_of_ocaml_Js[52][1],
    html_element = t53.HTMLElement,
    _b_ = Js_of_ocaml_Js[3],
    element =
      caml_call1(Js_of_ocaml_Js[4], html_element) === _b_
       ? function
        (t54){
         var _af_ = Js_of_ocaml_Js[3];
         return caml_call1(Js_of_ocaml_Js[4], t54.innerHTML) === _af_
                 ? Js_of_ocaml_Js[1]
                 : caml_call1(Js_of_ocaml_Js[2], t54);
        }
       : function
        (e){
         return e instanceof html_element
                 ? caml_call1(Js_of_ocaml_Js[2], e)
                 : Js_of_ocaml_Js[1];
        };
   function unsafeCoerce(tag, t55){
    return t55.tagName.toLowerCase() === caml_jsstring_of_string(tag)
            ? caml_call1(Js_of_ocaml_Js[2], t55)
            : Js_of_ocaml_Js[1];
   }
   function a(e){return unsafeCoerce(cst_a$0, e);}
   function area(e){return unsafeCoerce(cst_area$0, e);}
   function base(e){return unsafeCoerce(cst_base$0, e);}
   function blockquote(e){return unsafeCoerce(cst_blockquote$0, e);}
   function body(e){return unsafeCoerce(cst_body$0, e);}
   function br(e){return unsafeCoerce(cst_br$0, e);}
   function button(e){return unsafeCoerce(cst_button$0, e);}
   function canvas(e){return unsafeCoerce(cst_canvas$0, e);}
   function caption(e){return unsafeCoerce(cst_caption$0, e);}
   function col(e){return unsafeCoerce(cst_col$0, e);}
   function colgroup(e){return unsafeCoerce(cst_colgroup$0, e);}
   function del(e){return unsafeCoerce(cst_del$0, e);}
   function div(e){return unsafeCoerce(cst_div$0, e);}
   function dl(e){return unsafeCoerce(cst_dl$0, e);}
   function fieldset(e){return unsafeCoerce(cst_fieldset$0, e);}
   function embed(e){return unsafeCoerce(cst_embed$0, e);}
   function form(e){return unsafeCoerce(cst_form$0, e);}
   function frameset(e){return unsafeCoerce(cst_frameset$0, e);}
   function frame(e){return unsafeCoerce(cst_frame$0, e);}
   function h1(e){return unsafeCoerce(cst_h1$0, e);}
   function h2(e){return unsafeCoerce(cst_h2$0, e);}
   function h3(e){return unsafeCoerce(cst_h3$0, e);}
   function h4(e){return unsafeCoerce(cst_h4$0, e);}
   function h5(e){return unsafeCoerce(cst_h5$0, e);}
   function h6(e){return unsafeCoerce(cst_h6$0, e);}
   function head(e){return unsafeCoerce(cst_head$0, e);}
   function hr(e){return unsafeCoerce(cst_hr$0, e);}
   function html(e){return unsafeCoerce(cst_html$0, e);}
   function iframe(e){return unsafeCoerce(cst_iframe$0, e);}
   function img(e){return unsafeCoerce(cst_img$0, e);}
   function input$0(e){return unsafeCoerce(cst_input$0, e);}
   function ins(e){return unsafeCoerce(cst_ins$0, e);}
   function label(e){return unsafeCoerce(cst_label$0, e);}
   function legend(e){return unsafeCoerce(cst_legend$0, e);}
   function li(e){return unsafeCoerce(cst_li$0, e);}
   function link(e){return unsafeCoerce(cst_link$0, e);}
   function map(e){return unsafeCoerce(cst_map$0, e);}
   function meta(e){return unsafeCoerce(cst_meta$0, e);}
   function object(e){return unsafeCoerce(cst_object$0, e);}
   function ol(e){return unsafeCoerce(cst_ol$0, e);}
   function optgroup(e){return unsafeCoerce(cst_optgroup$0, e);}
   function option(e){return unsafeCoerce(cst_option$0, e);}
   function p(e){return unsafeCoerce(cst_p$0, e);}
   function param(e){return unsafeCoerce(cst_param$0, e);}
   function pre(e){return unsafeCoerce(cst_pre$0, e);}
   function q(e){return unsafeCoerce(cst_q$0, e);}
   function script(e){return unsafeCoerce(cst_script$0, e);}
   function select$0(e){return unsafeCoerce(cst_select$0, e);}
   function style(e){return unsafeCoerce(cst_style$0, e);}
   function table(e){return unsafeCoerce(cst_table$0, e);}
   function tbody(e){return unsafeCoerce(cst_tbody$0, e);}
   function td(e){return unsafeCoerce(cst_td$0, e);}
   function textarea(e){return unsafeCoerce(cst_textarea$0, e);}
   function tfoot(e){return unsafeCoerce(cst_tfoot$0, e);}
   function th(e){return unsafeCoerce(cst_th$0, e);}
   function thead(e){return unsafeCoerce(cst_thead$0, e);}
   function title(e){return unsafeCoerce(cst_title$0, e);}
   function tr(e){return unsafeCoerce(cst_tr$0, e);}
   function ul(e){return unsafeCoerce(cst_ul$0, e);}
   function audio(e){return unsafeCoerce(cst_audio$0, e);}
   function video(e){return unsafeCoerce(cst_video$0, e);}
   function unsafeCoerceEvent(constr, ev){
    var _ae_ = Js_of_ocaml_Js[3];
    if(caml_call1(Js_of_ocaml_Js[4], constr) !== _ae_ && ev instanceof constr)
     return caml_call1(Js_of_ocaml_Js[2], ev);
    return Js_of_ocaml_Js[1];
   }
   function mouseEvent(ev){
    var t57 = Js_of_ocaml_Js[52][1];
    return unsafeCoerceEvent(t57.MouseEvent, ev);
   }
   function keyboardEvent(ev){
    var t58 = Js_of_ocaml_Js[52][1];
    return unsafeCoerceEvent(t58.KeyboardEvent, ev);
   }
   function wheelEvent(ev){
    var t59 = Js_of_ocaml_Js[52][1];
    return unsafeCoerceEvent(t59.WheelEvent, ev);
   }
   function mouseScrollEvent(ev){
    var t60 = Js_of_ocaml_Js[52][1];
    return unsafeCoerceEvent(t60.MouseScrollEvent, ev);
   }
   function popStateEvent(ev){
    var t61 = Js_of_ocaml_Js[52][1];
    return unsafeCoerceEvent(t61.PopStateEvent, ev);
   }
   function messageEvent(ev){
    var t62 = Js_of_ocaml_Js[52][1];
    return unsafeCoerceEvent(t62.MessageEvent, ev);
   }
   var eventTarget = Js_of_ocaml_Dom[13];
   function eventRelatedTarget(t64){
    function _ab_(param){
     var match = caml_string_of_jsstring(t64.type);
     if(! caml_string_notequal(match, cst_mouseout)){
      var
       _ad_ =
         function(param){
          throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
         };
      return caml_call2(Js_of_ocaml_Js[6][8], t64.toElement, _ad_);
     }
     if(caml_string_notequal(match, cst_mouseover)) return Js_of_ocaml_Js[1];
     function _ac_(param){
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     }
     return caml_call2(Js_of_ocaml_Js[6][8], t64.fromElement, _ac_);
    }
    return caml_call2(Js_of_ocaml_Js[6][8], t64.relatedTarget, _ab_);
   }
   function eventAbsolutePosition(t72){
    var body = document.body, html = document.documentElement;
    return [0,
            (t72.clientX + body.scrollLeft | 0) + html.scrollLeft | 0,
            (t72.clientY + body.scrollTop | 0) + html.scrollTop | 0];
   }
   function eventAbsolutePosition$0(t76){
    function _Z_(x){
     function _$_(y){return [0, x, y];}
     function _aa_(param){return eventAbsolutePosition(t76);}
     return caml_call3(Js_of_ocaml_Js[6][7], t76.pageY, _aa_, _$_);
    }
    function ___(param){return eventAbsolutePosition(t76);}
    return caml_call3(Js_of_ocaml_Js[6][7], t76.pageX, ___, _Z_);
   }
   function elementClientPosition(e){
    var
     t83 = e.getBoundingClientRect(),
     body = document.body,
     html = document.documentElement;
    return [0,
            ((t83.left | 0) - body.clientLeft | 0) - html.clientLeft | 0,
            ((t83.top | 0) - body.clientTop | 0) - html.clientTop | 0];
   }
   function getDocumentScroll(param){
    var body = document.body, html = document.documentElement;
    return [0,
            body.scrollLeft + html.scrollLeft | 0,
            body.scrollTop + html.scrollTop | 0];
   }
   function buttonPressed(t93){
    function _X_(x){return x;}
    function _Y_(param){
     var switcher = t93.button - 1 | 0;
     if(3 >= switcher >>> 0)
      switch(switcher){
        case 0:
         return 1;
        case 1:
         return 3;
        case 2: break;
        default: return 2;
      }
     return 0;
    }
    return caml_call3(Js_of_ocaml_Js[6][7], t93.which, _Y_, _X_);
   }
   function addMousewheelEventListenerWith(e, capture, once, passive, h){
    return caml_call6
            (addEventListenerWithOptions,
             e,
             wheel,
             capture,
             once,
             passive,
             caml_call1
              (handler,
               function(t94){
                function _V_(param){return 0;}
                var
                 dx =
                   (-
                   caml_call2(Js_of_ocaml_Js[6][8], t94.wheelDeltaX, _V_)
                   | 0)
                   / 40
                   | 0;
                function _W_(param){return t94.wheelDelta;}
                var
                 dy =
                   (-
                   caml_call2(Js_of_ocaml_Js[6][8], t94.wheelDeltaY, _W_)
                   | 0)
                   / 40
                   | 0;
                return caml_call3(h, t94, dx, dy);
               }));
   }
   function addMousewheelEventListener(e, h, capt){
    return addMousewheelEventListenerWith(e, [0, capt], 0, 0, h);
   }
   function try_code(v){
    var
     match = caml_string_of_jsstring(v),
     switch$0 = caml_string_compare(match, "KeyH");
    if(0 <= switch$0){
     if(0 >= switch$0) return 8;
     var switch$1 = caml_string_compare(match, "Numpad4");
     if(0 <= switch$1){
      if(0 >= switch$1) return 72;
      var switch$2 = caml_string_compare(match, "PageUp");
      if(0 <= switch$2){
       if(0 >= switch$2) return 98;
       var switch$3 = caml_string_compare(match, "ShiftRight");
       if(0 <= switch$3){
        if(0 >= switch$3) return 91;
        if(! caml_string_notequal(match, "Slash")) return 55;
        if(! caml_string_notequal(match, "Space")) return 41;
        if(! caml_string_notequal(match, "Tab")) return 39;
        if(! caml_string_notequal(match, "VolumeDown")) return 103;
        if(! caml_string_notequal(match, "VolumeMute")) return 102;
        if(! caml_string_notequal(match, "VolumeUp")) return 104;
       }
       else{
        if(! caml_string_notequal(match, "Pause")) return 123;
        if(! caml_string_notequal(match, "Period")) return 54;
        if(! caml_string_notequal(match, "PrintScreen")) return 120;
        if(! caml_string_notequal(match, "Quote")) return 50;
        if(! caml_string_notequal(match, "ScrollLock")) return 119;
        if(! caml_string_notequal(match, "Semicolon")) return 49;
        if(! caml_string_notequal(match, "ShiftLeft")) return 90;
       }
      }
      else{
       var switch$4 = caml_string_compare(match, "NumpadDivide");
       if(0 <= switch$4){
        if(0 >= switch$4) return 84;
        if(! caml_string_notequal(match, "NumpadEnter")) return 83;
        if(! caml_string_notequal(match, "NumpadEqual")) return 82;
        if(! caml_string_notequal(match, "NumpadMultiply")) return 78;
        if(! caml_string_notequal(match, "NumpadSubtract")) return 79;
        if(! caml_string_notequal(match, "OSLeft")) return 117;
        if(! caml_string_notequal(match, "OSRight")) return 118;
        if(! caml_string_notequal(match, "PageDown")) return 99;
       }
       else{
        if(! caml_string_notequal(match, "Numpad5")) return 73;
        if(! caml_string_notequal(match, "Numpad6")) return 74;
        if(! caml_string_notequal(match, "Numpad7")) return 75;
        if(! caml_string_notequal(match, "Numpad8")) return 76;
        if(! caml_string_notequal(match, "Numpad9")) return 77;
        if(! caml_string_notequal(match, "NumpadAdd")) return 80;
        if(! caml_string_notequal(match, "NumpadDecimal")) return 81;
       }
      }
     }
     else{
      var switch$5 = caml_string_compare(match, "KeyX");
      if(0 <= switch$5){
       if(0 >= switch$5) return 24;
       var switch$6 = caml_string_compare(match, "MetaRight");
       if(0 <= switch$6){
        if(0 >= switch$6) return 89;
        if(! caml_string_notequal(match, "Minus")) return 37;
        if(! caml_string_notequal(match, "NumLock")) return 85;
        if(! caml_string_notequal(match, "Numpad0")) return 68;
        if(! caml_string_notequal(match, "Numpad1")) return 69;
        if(! caml_string_notequal(match, "Numpad2")) return 70;
        if(! caml_string_notequal(match, "Numpad3")) return 71;
       }
       else{
        if(! caml_string_notequal(match, "KeyY")) return 25;
        if(! caml_string_notequal(match, "KeyZ")) return 26;
        if(! caml_string_notequal(match, "MediaPlayPause")) return 107;
        if(! caml_string_notequal(match, "MediaStop")) return 108;
        if(! caml_string_notequal(match, "MediaTrackNext")) return 106;
        if(! caml_string_notequal(match, "MediaTrackPrevious")) return 105;
        if(! caml_string_notequal(match, "MetaLeft")) return 88;
       }
      }
      else{
       var switch$7 = caml_string_compare(match, "KeyP");
       if(0 <= switch$7){
        if(0 >= switch$7) return 16;
        if(! caml_string_notequal(match, "KeyQ")) return 17;
        if(! caml_string_notequal(match, "KeyR")) return 18;
        if(! caml_string_notequal(match, "KeyS")) return 19;
        if(! caml_string_notequal(match, "KeyT")) return 20;
        if(! caml_string_notequal(match, "KeyU")) return 21;
        if(! caml_string_notequal(match, "KeyV")) return 22;
        if(! caml_string_notequal(match, "KeyW")) return 23;
       }
       else{
        if(! caml_string_notequal(match, "KeyI")) return 9;
        if(! caml_string_notequal(match, "KeyJ")) return 10;
        if(! caml_string_notequal(match, "KeyK")) return 11;
        if(! caml_string_notequal(match, "KeyL")) return 12;
        if(! caml_string_notequal(match, "KeyM")) return 13;
        if(! caml_string_notequal(match, "KeyN")) return 14;
        if(! caml_string_notequal(match, "KeyO")) return 15;
       }
      }
     }
    }
    else{
     var switch$8 = caml_string_compare(match, "Digit6");
     if(0 <= switch$8){
      if(0 >= switch$8) return 33;
      var switch$9 = caml_string_compare(match, "F6");
      if(0 <= switch$9){
       if(0 >= switch$9) return 61;
       var switch$10 = caml_string_compare(match, "KeyA");
       if(0 <= switch$10){
        if(0 >= switch$10) return 1;
        if(! caml_string_notequal(match, "KeyB")) return 2;
        if(! caml_string_notequal(match, "KeyC")) return 3;
        if(! caml_string_notequal(match, "KeyD")) return 4;
        if(! caml_string_notequal(match, "KeyE")) return 5;
        if(! caml_string_notequal(match, "KeyF")) return 6;
        if(! caml_string_notequal(match, "KeyG")) return 7;
       }
       else{
        if(! caml_string_notequal(match, "F7")) return 62;
        if(! caml_string_notequal(match, "F8")) return 63;
        if(! caml_string_notequal(match, "F9")) return 64;
        if(! caml_string_notequal(match, "Home")) return 100;
        if(! caml_string_notequal(match, "Insert")) return 44;
        if(! caml_string_notequal(match, "IntlBackslash")) return 121;
        if(! caml_string_notequal(match, "IntlYen")) return 122;
       }
      }
      else{
       var switch$11 = caml_string_compare(match, "F1");
       if(0 <= switch$11){
        if(0 >= switch$11) return 56;
        if(! caml_string_notequal(match, "F10")) return 65;
        if(! caml_string_notequal(match, "F11")) return 66;
        if(! caml_string_notequal(match, "F12")) return 67;
        if(! caml_string_notequal(match, "F2")) return 57;
        if(! caml_string_notequal(match, "F3")) return 58;
        if(! caml_string_notequal(match, "F4")) return 59;
        if(! caml_string_notequal(match, "F5")) return 60;
       }
       else{
        if(! caml_string_notequal(match, "Digit7")) return 34;
        if(! caml_string_notequal(match, "Digit8")) return 35;
        if(! caml_string_notequal(match, "Digit9")) return 36;
        if(! caml_string_notequal(match, "End")) return 101;
        if(! caml_string_notequal(match, "Enter")) return 40;
        if(! caml_string_notequal(match, "Equal")) return 38;
        if(! caml_string_notequal(match, "Escape")) return 42;
       }
      }
     }
     else{
      var switch$12 = caml_string_compare(match, "BrowserRefresh");
      if(0 <= switch$12){
       if(0 >= switch$12) return 113;
       var switch$13 = caml_string_compare(match, "Delete");
       if(0 <= switch$13){
        if(0 >= switch$13) return 45;
        if(! caml_string_notequal(match, "Digit0")) return 27;
        if(! caml_string_notequal(match, "Digit1")) return 28;
        if(! caml_string_notequal(match, "Digit2")) return 29;
        if(! caml_string_notequal(match, "Digit3")) return 30;
        if(! caml_string_notequal(match, "Digit4")) return 31;
        if(! caml_string_notequal(match, "Digit5")) return 32;
       }
       else{
        if(! caml_string_notequal(match, "BrowserSearch")) return 110;
        if(! caml_string_notequal(match, "BrowserStop")) return 114;
        if(! caml_string_notequal(match, "CapsLock")) return 46;
        if(! caml_string_notequal(match, "Comma")) return 53;
        if(! caml_string_notequal(match, "ContextMenu")) return 109;
        if(! caml_string_notequal(match, "ControlLeft")) return 86;
        if(! caml_string_notequal(match, "ControlRight")) return 87;
       }
      }
      else{
       var switch$14 = caml_string_compare(match, "Backslash");
       if(0 <= switch$14){
        if(0 >= switch$14) return 52;
        if(! caml_string_notequal(match, "Backspace")) return 43;
        if(! caml_string_notequal(match, "BracketLeft")) return 47;
        if(! caml_string_notequal(match, "BracketRight")) return 48;
        if(! caml_string_notequal(match, "BrowserBack")) return 116;
        if(! caml_string_notequal(match, "BrowserFavorites")) return 112;
        if(! caml_string_notequal(match, "BrowserForward")) return 115;
        if(! caml_string_notequal(match, "BrowserHome")) return 111;
       }
       else{
        if(! caml_string_notequal(match, "AltLeft")) return 92;
        if(! caml_string_notequal(match, "AltRight")) return 93;
        if(! caml_string_notequal(match, "ArrowDown")) return 97;
        if(! caml_string_notequal(match, "ArrowLeft")) return 94;
        if(! caml_string_notequal(match, "ArrowRight")) return 95;
        if(! caml_string_notequal(match, "ArrowUp")) return 96;
        if(! caml_string_notequal(match, "Backquote")) return 51;
       }
      }
     }
    }
    return 0;
   }
   function try_key_code_left(param){
    if(19 <= param){
     if(91 === param) return 88;
    }
    else if(16 <= param)
     switch(param - 16 | 0){
       case 0:
        return 90;
       case 1:
        return 86;
       default: return 92;
     }
    return 0;
   }
   function try_key_code_right(param){
    if(19 <= param){
     if(91 === param) return 89;
    }
    else if(16 <= param)
     switch(param - 16 | 0){
       case 0:
        return 91;
       case 1:
        return 87;
       default: return 93;
     }
    return 0;
   }
   function try_key_code_numpad(param){
    if(47 <= param){
     var switcher = param - 96 | 0;
     if(15 >= switcher >>> 0)
      switch(switcher){
        case 0:
         return 68;
        case 1:
         return 69;
        case 2:
         return 70;
        case 3:
         return 71;
        case 4:
         return 72;
        case 5:
         return 73;
        case 6:
         return 74;
        case 7:
         return 75;
        case 8:
         return 76;
        case 9:
         return 77;
        case 10:
         return 78;
        case 11:
         return 80;
        case 12: break;
        case 13:
         return 79;
        case 14:
         return 81;
        default: return 84;
      }
    }
    else if(12 <= param)
     switch(param - 12 | 0){
       case 0:
        return 73;
       case 1:
        return 83;
       case 21:
        return 77;
       case 22:
        return 71;
       case 23:
        return 69;
       case 24:
        return 75;
       case 25:
        return 72;
       case 26:
        return 76;
       case 27:
        return 74;
       case 28:
        return 70;
       case 33:
        return 68;
       case 34:
        return 81;
     }
    return 0;
   }
   function try_key_code_normal(param){
    var switcher = param - 8 | 0;
    if(214 >= switcher >>> 0){
     var _U_ = switcher;
     if(67 <= _U_)
      switch(_U_){
        case 67:
         return 11;
        case 68:
         return 12;
        case 69:
         return 13;
        case 70:
         return 14;
        case 71:
         return 15;
        case 72:
         return 16;
        case 73:
         return 17;
        case 74:
         return 18;
        case 75:
         return 19;
        case 76:
         return 20;
        case 77:
         return 21;
        case 78:
         return 22;
        case 79:
         return 23;
        case 80:
         return 24;
        case 81:
         return 25;
        case 82:
         return 26;
        case 85:
         return 109;
        case 104:
         return 56;
        case 105:
         return 57;
        case 106:
         return 58;
        case 107:
         return 59;
        case 108:
         return 60;
        case 109:
         return 61;
        case 110:
         return 62;
        case 111:
         return 63;
        case 112:
         return 64;
        case 113:
         return 65;
        case 114:
         return 66;
        case 115:
         return 67;
        case 137:
         return 119;
        case 178:
         return 49;
        case 179:
         return 38;
        case 180:
         return 53;
        case 181:
         return 37;
        case 182:
         return 54;
        case 183:
         return 55;
        case 184:
         return 51;
        case 211:
         return 47;
        case 212:
         return 52;
        case 213:
         return 48;
        case 214:
         return 50;
      }
     else
      switch(_U_){
        case 0:
         return 43;
        case 1:
         return 39;
        case 5:
         return 40;
        case 11:
         return 123;
        case 12:
         return 46;
        case 19:
         return 42;
        case 24:
         return 41;
        case 25:
         return 98;
        case 26:
         return 99;
        case 27:
         return 101;
        case 28:
         return 100;
        case 29:
         return 94;
        case 30:
         return 96;
        case 31:
         return 95;
        case 32:
         return 97;
        case 34:
         return 120;
        case 37:
         return 44;
        case 38:
         return 45;
        case 40:
         return 27;
        case 41:
         return 28;
        case 42:
         return 29;
        case 43:
         return 30;
        case 44:
         return 31;
        case 45:
         return 32;
        case 46:
         return 33;
        case 47:
         return 34;
        case 48:
         return 35;
        case 49:
         return 36;
        case 57:
         return 1;
        case 58:
         return 2;
        case 59:
         return 3;
        case 60:
         return 4;
        case 61:
         return 5;
        case 62:
         return 6;
        case 63:
         return 7;
        case 64:
         return 8;
        case 65:
         return 9;
        case 66:
         return 10;
      }
    }
    return 0;
   }
   function make_unidentified(param){return 0;}
   function run_next(value, f, v){return v ? v : caml_call1(f, value);}
   function symbol(x, f){return caml_call1(f, x);}
   function of_event(evt){
    var _N_ = evt.keyCode;
    function _O_(_T_){return run_next(_N_, try_key_code_normal, _T_);}
    var switcher = evt.location - 1 | 0;
    if(2 < switcher >>> 0)
     var _P_ = make_unidentified;
    else
     switch(switcher){
       case 0:
        var
         _K_ = evt.keyCode,
         _P_ = function(_R_){return run_next(_K_, try_key_code_left, _R_);};
        break;
       case 1:
        var
         _L_ = evt.keyCode,
         _P_ = function(_Q_){return run_next(_L_, try_key_code_right, _Q_);};
        break;
       default:
        var
         _M_ = evt.keyCode,
         _P_ = function(_S_){return run_next(_M_, try_key_code_numpad, _S_);};
     }
    var value = evt.code;
    return symbol
            (symbol
              (symbol
                (0,
                 function(v){
                  return v
                          ? v
                          : caml_call3
                            (Js_of_ocaml_Js[6][7], value, make_unidentified, try_code);
                 }),
               _P_),
             _O_);
   }
   function char_of_int(value){
    if(0 >= value) return 0;
    try{var _I_ = [0, caml_call1(Stdlib_Uchar[8], value)]; return _I_;}
    catch(_J_){return 0;}
   }
   function empty_string(param){return cst;}
   function none(param){return 0;}
   function of_event$0(t100){
    var
     t101 = caml_call2(Js_of_ocaml_Js[6][8], t100.key, empty_string),
     match = t101.length;
    return 0 === match
            ? caml_call3
              (Js_of_ocaml_Js[6][7], t100.charCode, none, char_of_int)
            : 1 === match ? char_of_int(t101.charCodeAt(0) | 0) : 0;
   }
   function element$0(_H_){return _H_;}
   function tagged(t105){
    var tag = runtime.caml_string_of_jsbytes(t105.tagName.toLowerCase());
    if(0 === runtime.caml_ml_string_length(tag)) return [61, t105];
    var switcher = runtime.caml_string_unsafe_get(tag, 0) - 97 | 0;
    if(21 >= switcher >>> 0)
     switch(switcher){
       case 0:
        return caml_string_notequal(tag, cst_a$1)
                ? caml_string_notequal
                   (tag, cst_area$1)
                  ? caml_string_notequal
                     (tag, cst_audio$1)
                    ? [61, t105]
                    : [2, t105]
                  : [1, t105]
                : [0, t105];
       case 1:
        return caml_string_notequal(tag, cst_base$1)
                ? caml_string_notequal
                   (tag, cst_blockquote$1)
                  ? caml_string_notequal
                     (tag, cst_body$1)
                    ? caml_string_notequal
                       (tag, cst_br$1)
                      ? caml_string_notequal
                         (tag, cst_button$1)
                        ? [61, t105]
                        : [7, t105]
                      : [6, t105]
                    : [5, t105]
                  : [4, t105]
                : [3, t105];
       case 2:
        return caml_string_notequal(tag, cst_canvas$1)
                ? caml_string_notequal
                   (tag, cst_caption$1)
                  ? caml_string_notequal
                     (tag, cst_col$1)
                    ? caml_string_notequal
                       (tag, cst_colgroup$1)
                      ? [61, t105]
                      : [11, t105]
                    : [10, t105]
                  : [9, t105]
                : [8, t105];
       case 3:
        return caml_string_notequal(tag, cst_del$1)
                ? caml_string_notequal
                   (tag, cst_div$1)
                  ? caml_string_notequal
                     (tag, cst_dl$1)
                    ? [61, t105]
                    : [14, t105]
                  : [13, t105]
                : [12, t105];
       case 4:
        return caml_string_notequal(tag, cst_embed$1)
                ? [61, t105]
                : [15, t105];
       case 5:
        return caml_string_notequal(tag, cst_fieldset$1)
                ? caml_string_notequal
                   (tag, cst_form$1)
                  ? caml_string_notequal
                     (tag, cst_frame$1)
                    ? caml_string_notequal
                       (tag, cst_frameset$1)
                      ? [61, t105]
                      : [18, t105]
                    : [19, t105]
                  : [17, t105]
                : [16, t105];
       case 7:
        return caml_string_notequal(tag, cst_h1$1)
                ? caml_string_notequal
                   (tag, cst_h2$1)
                  ? caml_string_notequal
                     (tag, cst_h3$1)
                    ? caml_string_notequal
                       (tag, cst_h4$1)
                      ? caml_string_notequal
                         (tag, cst_h5$1)
                        ? caml_string_notequal
                           (tag, cst_h6$1)
                          ? caml_string_notequal
                             (tag, cst_head$1)
                            ? caml_string_notequal
                               (tag, cst_hr$1)
                              ? caml_string_notequal
                                 (tag, cst_html$1)
                                ? [61, t105]
                                : [28, t105]
                              : [27, t105]
                            : [26, t105]
                          : [25, t105]
                        : [24, t105]
                      : [23, t105]
                    : [22, t105]
                  : [21, t105]
                : [20, t105];
       case 8:
        return caml_string_notequal(tag, cst_iframe$1)
                ? caml_string_notequal
                   (tag, cst_img$1)
                  ? caml_string_notequal
                     (tag, cst_input$1)
                    ? caml_string_notequal
                       (tag, cst_ins$1)
                      ? [61, t105]
                      : [32, t105]
                    : [31, t105]
                  : [30, t105]
                : [29, t105];
       case 11:
        return caml_string_notequal(tag, cst_label$1)
                ? caml_string_notequal
                   (tag, cst_legend$1)
                  ? caml_string_notequal
                     (tag, cst_li$1)
                    ? caml_string_notequal
                       (tag, cst_link$1)
                      ? [61, t105]
                      : [36, t105]
                    : [35, t105]
                  : [34, t105]
                : [33, t105];
       case 12:
        return caml_string_notequal(tag, cst_map$1)
                ? caml_string_notequal
                   (tag, cst_meta$1)
                  ? [61, t105]
                  : [38, t105]
                : [37, t105];
       case 14:
        return caml_string_notequal(tag, cst_object$1)
                ? caml_string_notequal
                   (tag, cst_ol$1)
                  ? caml_string_notequal
                     (tag, cst_optgroup$1)
                    ? caml_string_notequal
                       (tag, cst_option$1)
                      ? [61, t105]
                      : [42, t105]
                    : [41, t105]
                  : [40, t105]
                : [39, t105];
       case 15:
        return caml_string_notequal(tag, cst_p$1)
                ? caml_string_notequal
                   (tag, cst_param$1)
                  ? caml_string_notequal
                     (tag, cst_pre$1)
                    ? [61, t105]
                    : [45, t105]
                  : [44, t105]
                : [43, t105];
       case 16:
        return caml_string_notequal(tag, cst_q$1) ? [61, t105] : [46, t105];
       case 18:
        return caml_string_notequal(tag, cst_script$1)
                ? caml_string_notequal
                   (tag, cst_select$1)
                  ? caml_string_notequal
                     (tag, cst_style$1)
                    ? [61, t105]
                    : [49, t105]
                  : [48, t105]
                : [47, t105];
       case 19:
        return caml_string_notequal(tag, cst_table$1)
                ? caml_string_notequal
                   (tag, cst_tbody$1)
                  ? caml_string_notequal
                     (tag, cst_td$1)
                    ? caml_string_notequal
                       (tag, cst_textarea$1)
                      ? caml_string_notequal
                         (tag, cst_tfoot$1)
                        ? caml_string_notequal
                           (tag, cst_th$1)
                          ? caml_string_notequal
                             (tag, cst_thead$1)
                            ? caml_string_notequal
                               (tag, cst_title$1)
                              ? caml_string_notequal
                                 (tag, cst_tr$1)
                                ? [61, t105]
                                : [58, t105]
                              : [57, t105]
                            : [56, t105]
                          : [55, t105]
                        : [54, t105]
                      : [53, t105]
                    : [52, t105]
                  : [51, t105]
                : [50, t105];
       case 20:
        return caml_string_notequal(tag, cst_ul$1) ? [61, t105] : [59, t105];
       case 21:
        return caml_string_notequal(tag, cst_video$1)
                ? [61, t105]
                : [60, t105];
     }
    return [61, t105];
   }
   function opt_tagged(e){
    function _F_(e){return [0, tagged(e)];}
    function _G_(param){return 0;}
    return caml_call3(Js_of_ocaml_Js[5][7], e, _G_, _F_);
   }
   function taggedEvent(ev){
    function _n_(ev){return [0, ev];}
    function _o_(param){
     function _q_(ev){return [1, ev];}
     function _r_(param){
      function _t_(ev){return [3, ev];}
      function _u_(param){
       function _w_(ev){return [4, ev];}
       function _x_(param){
        function _z_(ev){return [5, ev];}
        function _A_(param){
         function _C_(ev){return [2, ev];}
         function _D_(param){return [6, ev];}
         var _E_ = messageEvent(ev);
         return caml_call3(Js_of_ocaml_Js[5][7], _E_, _D_, _C_);
        }
        var _B_ = popStateEvent(ev);
        return caml_call3(Js_of_ocaml_Js[5][7], _B_, _A_, _z_);
       }
       var _y_ = mouseScrollEvent(ev);
       return caml_call3(Js_of_ocaml_Js[5][7], _y_, _x_, _w_);
      }
      var _v_ = wheelEvent(ev);
      return caml_call3(Js_of_ocaml_Js[5][7], _v_, _u_, _t_);
     }
     var _s_ = keyboardEvent(ev);
     return caml_call3(Js_of_ocaml_Js[5][7], _s_, _r_, _q_);
    }
    var _p_ = mouseEvent(ev);
    return caml_call3(Js_of_ocaml_Js[5][7], _p_, _o_, _n_);
   }
   function opt_taggedEvent(ev){
    function _l_(ev){return [0, taggedEvent(ev)];}
    function _m_(param){return 0;}
    return caml_call3(Js_of_ocaml_Js[5][7], ev, _m_, _l_);
   }
   function stopPropagation(t109){
    function _j_(param){return t109.stopPropagation();}
    function _k_(param){
     var t108 = Js_of_ocaml_Js[7];
     return t109.cancelBubble = t108;
    }
    return caml_call3(Js_of_ocaml_Js[6][7], t109.stopPropagation, _k_, _j_);
   }
   var
    requestAnimationFrame =
      runtime.caml_js_pure_expr
       (function(param){
         var
          l =
            [0,
             window.requestAnimationFrame,
             [0,
              window.mozRequestAnimationFrame,
              [0,
               window.webkitRequestAnimationFrame,
               [0,
                window.oRequestAnimationFrame,
                [0, window.msRequestAnimationFrame, 0]]]]];
         try{
          var
           _g_ = function(c){return caml_call1(Js_of_ocaml_Js[6][5], c);},
           req = caml_call2(Stdlib_List[38], _g_, l),
           _h_ = function(callback){return req(callback);};
          return _h_;
         }
         catch(_i_){
          var _f_ = caml_wrap_exception(_i_);
          if(_f_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_f_, 0);
          var
           now = function(param){return (new Js_of_ocaml_Js[26]).getTime();},
           last = [0, now(0)];
          return function(callback){
           var
            t = now(0),
            dt = last[1] + 16.666666666666668 - t,
            dt$0 = dt < 0. ? 0. : dt;
           last[1] = t;
           window.setTimeout(callback, dt$0);
           return 0;};
         }
        });
   function hasPushState(param){
    var t122 = window.history;
    return caml_call1(Js_of_ocaml_Js[6][5], t122.pushState);
   }
   function hasPlaceholder(param){
    var t123 = createInput(0, 0, document);
    return caml_call1(Js_of_ocaml_Js[6][5], t123.placeholder);
   }
   function hasRequired(param){
    var t124 = createInput(0, 0, document);
    return caml_call1(Js_of_ocaml_Js[6][5], t124.required);
   }
   var overflow_limit = 2147483000.;
   function setTimeout(callback, d){
    var id = [0, 0];
    function loop(d, param){
     if(2147483000. < d)
      var remain = d - 2147483000., step = overflow_limit;
     else
      var remain = 0., step = d;
     var
      cb = remain == 0. ? callback : function(_e_){return loop(remain, _e_);};
     id[1] = [0, window.setTimeout(runtime.caml_js_wrap_callback(cb), step)];
     return 0;
    }
    loop(d, 0);
    return id;
   }
   function clearTimeout(id){
    var match = id[1];
    if(! match) return 0;
    var x = match[1];
    id[1] = 0;
    return window.clearTimeout(x);
   }
   function js_array_of_collection(c){return [].slice.call(c);}
   var
    Js_of_ocaml_Dom_html =
      [0,
       d,
       document,
       getElementById_opt,
       getElementById_exn,
       getElementById_coerce,
       getElementById,
       location_origin,
       window,
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       eventRelatedTarget,
       [0,
        click,
        copy,
        cut,
        paste,
        dblclick,
        mousedown,
        mouseup,
        mouseover,
        mousemove,
        mouseout,
        keypress,
        keydown,
        keyup,
        mousewheel,
        DOMMouseScroll,
        wheel,
        touchstart,
        touchmove,
        touchend,
        touchcancel,
        dragstart,
        dragend,
        dragenter,
        dragover,
        dragleave,
        drag,
        drop,
        hashchange,
        change,
        input,
        timeupdate,
        submit,
        scroll,
        focus,
        blur,
        load,
        unload,
        beforeunload,
        resize,
        orientationchange,
        popstate,
        error,
        abort,
        select,
        online,
        offline,
        checking,
        noupdate,
        downloading,
        progress,
        updateready,
        cached,
        obsolete,
        domContentLoaded,
        animationstart,
        animationend,
        animationiteration,
        animationcancel,
        transitionrun,
        transitionstart,
        transitionend,
        transitioncancel,
        canplay,
        canplaythrough,
        durationchange,
        emptied,
        ended,
        gotpointercapture,
        loadeddata,
        loadedmetadata,
        loadstart,
        lostpointercapture,
        message,
        pause,
        play,
        playing,
        pointerenter,
        pointercancel,
        pointerdown,
        pointerleave,
        pointermove,
        pointerout,
        pointerover,
        pointerup,
        ratechange,
        seeked,
        seeking,
        stalled,
        suspend,
        volumechange,
        waiting,
        make],
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       addMousewheelEventListenerWith,
       addMousewheelEventListener,
       createCustomEvent,
       buttonPressed,
       eventAbsolutePosition$0,
       elementClientPosition,
       getDocumentScroll,
       [0, of_event, try_key_code_normal],
       [0, of_event$0],
       createHtml,
       createHead,
       createLink,
       createTitle,
       createMeta,
       createBase,
       createStyle,
       createBody,
       createForm,
       createOptgroup,
       createOption,
       createSelect,
       createInput,
       createTextarea,
       createButton,
       createLabel,
       createFieldset,
       createLegend,
       createUl,
       createOl,
       createDl,
       createLi,
       createDiv,
       createEmbed,
       createP,
       createH1,
       createH2,
       createH3,
       createH4,
       createH5,
       createH6,
       createQ,
       createBlockquote,
       createPre,
       createBr,
       createHr,
       createIns,
       createDel,
       createA,
       createImg,
       createObject,
       createParam,
       createMap,
       createArea,
       createScript,
       createTable,
       createCaption,
       createCol,
       createColgroup,
       createThead,
       createTfoot,
       createTbody,
       createTr,
       createTh,
       createTd,
       createSub,
       createSup,
       createSpan,
       createTt,
       createI,
       createB,
       createBig,
       createSmall,
       createEm,
       createStrong,
       createCite,
       createDfn,
       createCode,
       createSamp,
       createKbd,
       createVar,
       createAbbr,
       createDd,
       createDt,
       createNoscript,
       createAddress,
       createFrameset,
       createFrame,
       createIframe,
       createAudio,
       createVideo,
       Canvas_not_available,
       createCanvas,
       element$0,
       tagged,
       opt_tagged,
       taggedEvent,
       opt_taggedEvent,
       stopPropagation,
       [0,
        element,
        a,
        area,
        audio,
        base,
        blockquote,
        body,
        br,
        button,
        canvas,
        caption,
        col,
        colgroup,
        del,
        div,
        embed,
        dl,
        fieldset,
        form,
        frameset,
        frame,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        head,
        hr,
        html,
        iframe,
        img,
        input$0,
        ins,
        label,
        legend,
        li,
        link,
        map,
        meta,
        object,
        ol,
        optgroup,
        option,
        p,
        param,
        pre,
        q,
        script,
        select$0,
        style,
        table,
        tbody,
        td,
        textarea,
        tfoot,
        th,
        thead,
        title,
        tr,
        ul,
        video,
        mouseEvent,
        keyboardEvent,
        wheelEvent,
        mouseScrollEvent,
        popStateEvent,
        messageEvent],
       setTimeout,
       clearTimeout,
       js_array_of_collection,
       requestAnimationFrame,
       runtime.caml_js_html_entities,
       onIE,
       hasPushState,
       hasPlaceholder,
       hasRequired];
   runtime.caml_register_global
    (553, Js_of_ocaml_Dom_html, "Js_of_ocaml__Dom_html");
   return;
  }
  (globalThis));

//# 6971 "../../.js/default/js_of_ocaml/js_of_ocaml.cma.js"
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    console = runtime.caml_js_get_console(0),
    Js_of_ocaml_Firebug = [0, console];
   runtime.caml_register_global
    (0, Js_of_ocaml_Firebug, "Js_of_ocaml__Firebug");
   return;
  }
  (globalThis));


//# 1 ".kb.eobjs/jsoo/dune__exe.cmo.js"
// Generated by js_of_ocaml
//# 3 ".kb.eobjs/jsoo/dune__exe.cmo.js"

//# 5 ".kb.eobjs/jsoo/dune__exe.cmo.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Dune_exe = [0];
   runtime.caml_register_global(0, Dune_exe, "Dune__exe");
   return;
  }
  (globalThis));


//# 1 ".kb.eobjs/jsoo/dune__exe__ParserRefs.cmo.js"
// Generated by js_of_ocaml
//# 3 ".kb.eobjs/jsoo/dune__exe__ParserRefs.cmo.js"

//# 5 ".kb.eobjs/jsoo/dune__exe__ParserRefs.cmo.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    syms = [0, 0],
    Dune_exe_ParserRefs = [0, syms];
   runtime.caml_register_global
    (0, Dune_exe_ParserRefs, "Dune__exe__ParserRefs");
   return;
  }
  (globalThis));


//# 1 ".kb.eobjs/jsoo/dune__exe__Parser.cmo.js"
// Generated by js_of_ocaml
//# 3 ".kb.eobjs/jsoo/dune__exe__Parser.cmo.js"

//# 6 ".kb.eobjs/jsoo/dune__exe__Parser.cmo.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_equal = runtime.caml_string_equal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    yylhs =
      "\xff\xff\x01\0\x02\0\x02\0\x03\0\x04\0\x04\0\x05\0\x05\0\x05\0\0\0",
    yylen = "\x02\0\x02\0\0\0\x02\0\x03\0\x04\0\x01\0\x03\0\x01\0\0\0\x02\0",
    yydefred =
      "\0\0\0\0\0\0\0\0\n\0\0\0\0\0\0\0\0\0\x01\0\x03\0\0\0\0\0\0\0\x04\0\0\0\x05\0\x07\0",
    yydgoto = "\x02\0\x04\0\x05\0\x06\0\x07\0\r\0",
    yysindex =
      "\x03\0\x01\xff\0\0\x03\xff\0\0\x06\0\x01\xff\x04\xff\x01\xff\0\0\0\0\x01\xff\x06\xff\x05\xff\0\0\x01\xff\0\0\0\0",
    yyrindex =
      "\0\0\x0b\0\0\0\x01\0\0\0\0\0\x0b\0\0\0\t\xff\0\0\0\0\0\0\n\xff\0\0\0\0\t\xff\0\0\0\0",
    yygindex = "\0\0\0\0\b\0\0\0\xf8\xff\x02\0",
    yytable =
      "\f\0\x06\0\x03\0\x0e\0\x01\0\b\0\t\0\f\0\x10\0\x0b\0\x0f\0\x02\0\t\0\b\0\n\0\0\0\0\0\x11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\0\0\x06\0\x06\0\x06\0",
    yycheck =
      "\b\0\0\0\x01\x01\x0b\0\x01\0\x02\x01\0\0\x0f\0\x03\x01\x05\x01\x04\x01\0\0\x03\x01\x03\x01\x06\0\xff\xff\xff\xff\x0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x01\xff\xff\x03\x01\x04\x01\x05\x01",
    yynames_const = "LPAR\0RPAR\0COMMA\0EQ\0EOF\0",
    yynames_block = "IDENT\0",
    Stdlib_Parsing = global_data.Stdlib__Parsing,
    Stdlib = global_data.Stdlib,
    Alg_Term = global_data.Alg__Term,
    Stdlib_List = global_data.Stdlib__List,
    Dune_exe_ParserRefs = global_data.Dune__exe__ParserRefs,
    vars = [0, 0],
    cst_parser = "parser",
    cst_arity_mismatch_for = "arity mismatch for ",
    _a_ = [0, 258, 259, 260, 261, 0, 0];
   function app(f$0, args){
    var _p_ = Dune_exe_ParserRefs[1][1];
    function _q_(g){
     return caml_string_equal(caml_call1(Alg_Term[1][1], g), f$0);
    }
    var
     f = caml_call2(Stdlib_List[38], _q_, _p_),
     _r_ = caml_call1(Alg_Term[1][3], f);
    if(caml_call1(Stdlib_List[1], args) !== _r_){
     var
      _s_ = caml_call1(Alg_Term[1][1], f),
      _t_ = caml_call2(Stdlib[28], cst_arity_mismatch_for, _s_);
     caml_call1(Stdlib[2], _t_);
    }
    return caml_call2(Alg_Term[4], f, args);
   }
   var
    yytransl_const = _a_.slice(),
    yytransl_block = [0, 257, 0],
    yytablesize = 262;
   function _b_(caml_parser_env){
    var _o_ = caml_call2(Stdlib_Parsing[14], caml_parser_env, 0);
    throw caml_maybe_attach_backtrace([0, Stdlib_Parsing[12], _o_], 1);
   }
   function _c_(caml_parser_env){return 0;}
   function _d_(caml_parser_env){
    var _1 = caml_call2(Stdlib_Parsing[14], caml_parser_env, 0);
    return [0, _1, 0];
   }
   function _e_(caml_parser_env){
    var
     _1 = caml_call2(Stdlib_Parsing[14], caml_parser_env, 2),
     _3 = caml_call2(Stdlib_Parsing[14], caml_parser_env, 0);
    return [0, _1, _3];
   }
   function _f_(caml_parser_env){
    var
     _1 = caml_call2(Stdlib_Parsing[14], caml_parser_env, 0),
     _m_ = Dune_exe_ParserRefs[1][1];
    function _n_(g){
     return caml_string_equal(caml_call1(Alg_Term[1][1], g), _1);
    }
    if(caml_call2(Stdlib_List[33], _n_, _m_)) return app(_1, 0);
    if(1 - caml_call2(Stdlib_List[50], _1, vars[1])){
     var _l_ = vars[1];
     vars[1] = [0, [0, _1, caml_call1(Alg_Term[3], 0)], _l_];
    }
    return caml_call2(Stdlib_List[46], _1, vars[1]);
   }
   function _g_(caml_parser_env){
    var
     _1 = caml_call2(Stdlib_Parsing[14], caml_parser_env, 3),
     _3 = caml_call2(Stdlib_Parsing[14], caml_parser_env, 1);
    return app(_1, _3);
   }
   function _h_(caml_parser_env){
    var
     _1 = caml_call2(Stdlib_Parsing[14], caml_parser_env, 2),
     _3 = caml_call2(Stdlib_Parsing[14], caml_parser_env, 0);
    return [0, _1, _3];
   }
   function _i_(caml_parser_env){
    var
     _1 = caml_call2(Stdlib_Parsing[14], caml_parser_env, 1),
     _2 = caml_call2(Stdlib_Parsing[14], caml_parser_env, 0);
    return [0, _1, _2];
   }
   function _j_(caml_parser_env){return 0;}
   function _k_(caml_parser_env){
    var _1 = caml_call2(Stdlib_Parsing[14], caml_parser_env, 1);
    return _1;
   }
   var
    yyact =
      [0,
       function(param){return caml_call1(Stdlib[2], cst_parser);},
       _k_,
       _j_,
       _i_,
       _h_,
       _g_,
       _f_,
       _e_,
       _d_,
       _c_,
       _b_],
    yytables =
      [0,
       yyact,
       yytransl_const,
       yytransl_block,
       yylhs,
       yylen,
       yydefred,
       yydgoto,
       yysindex,
       yyrindex,
       yygindex,
       yytablesize,
       yytable,
       yycheck,
       Stdlib_Parsing[16],
       yynames_const,
       yynames_block];
   function main(lexfun, lexbuf){
    return caml_call4(Stdlib_Parsing[13], yytables, 1, lexfun, lexbuf);
   }
   var Dune_exe_Parser = [0, main];
   runtime.caml_register_global(19, Dune_exe_Parser, "Dune__exe__Parser");
   return;
  }
  (globalThis));


//# 1 ".kb.eobjs/jsoo/dune__exe__Lexer.cmo.js"
// Generated by js_of_ocaml
//# 3 ".kb.eobjs/jsoo/dune__exe__Lexer.cmo.js"

//# 6 ".kb.eobjs/jsoo/dune__exe__Lexer.cmo.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    ocaml_lex_tables =
      [0,
       "\0\0\xf9\xff\x02\0\x1a\0\xfc\xff\xfd\xff\xfe\xff\xff\xff",
       "\xff\xff\xff\xff\x05\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff",
       "\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0",
       "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\x02\0\x02\0\x02\0\0\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\x02\0\0\0\0\0\0\0\0\0\0\0\x06\0\x05\0\0\0\0\0\x04\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\x02\0\x02\0\0\0\xff\xff\x02\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\x02\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       cst,
       cst,
       cst,
       cst,
       cst,
       cst],
    Stdlib_Lexing = global_data.Stdlib__Lexing;
   function token$0(counter, lexbuf){
    var _a_ = 0;
    if(counter >= 50)
     return caml_trampoline_return(ocaml_lex_token_rec$0, [0, lexbuf, _a_]);
    var counter$0 = counter + 1 | 0;
    return ocaml_lex_token_rec$0(counter$0, lexbuf, _a_);
   }
   function ocaml_lex_token_rec$0(counter, lexbuf, ocaml_lex_state){
    var ocaml_lex_state$0 = ocaml_lex_state;
    for(;;){
     var
      ocaml_lex_state$1 =
        caml_call3
         (Stdlib_Lexing[20], ocaml_lex_tables, ocaml_lex_state$0, lexbuf);
     if(6 < ocaml_lex_state$1 >>> 0){
      caml_call1(lexbuf[1], lexbuf);
      var ocaml_lex_state$0 = ocaml_lex_state$1;
      continue;
     }
     switch(ocaml_lex_state$1){
       case 0:
        return 3;
       case 1:
        return 0;
       case 2:
        return 1;
       case 3:
        return 2;
       case 4:
        var s = caml_call3(Stdlib_Lexing[16], lexbuf, lexbuf[5], lexbuf[6]);
        return [0, s];
       case 5:
        if(counter >= 50) return caml_trampoline_return(token$0, [0, lexbuf]);
        var counter$0 = counter + 1 | 0;
        return token$0(counter$0, lexbuf);
       default: return 4;
     }
    }
   }
   function token(lexbuf){return caml_trampoline(token$0(0, lexbuf));}
   function ocaml_lex_token_rec(lexbuf, ocaml_lex_state){
    return caml_trampoline(ocaml_lex_token_rec$0(0, lexbuf, ocaml_lex_state));
   }
   var Dune_exe_Lexer = [0, ocaml_lex_tables, token, ocaml_lex_token_rec];
   runtime.caml_register_global(2, Dune_exe_Lexer, "Dune__exe__Lexer");
   return;
  }
  (globalThis));


//# 1 ".kb.eobjs/jsoo/dune__exe__Kb.cmo.js"
// Generated by js_of_ocaml
//# 3 ".kb.eobjs/jsoo/dune__exe__Kb.cmo.js"

//# 6 ".kb.eobjs/jsoo/dune__exe__Kb.cmo.js"
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_sub$0 = "<\/sub>",
    cst_br$0 = "<br/>",
    caml_jsstring_of_string = runtime.caml_jsstring_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_of_jsstring = runtime.caml_string_of_jsstring,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Alg_Term = global_data.Alg__Term,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Alg_Utils = global_data.Alg__Utils,
    Stdlib_List = global_data.Stdlib__List,
    Js_of_ocaml_Js = global_data.Js_of_ocaml__Js,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Js_of_ocaml_Dom_html = global_data.Js_of_ocaml__Dom_html,
    Dune_exe_ParserRefs = global_data.Dune__exe__ParserRefs,
    Stdlib_Lexing = global_data.Stdlib__Lexing,
    Dune_exe_Lexer = global_data.Dune__exe__Lexer,
    Dune_exe_Parser = global_data.Dune__exe__Parser,
    Assert_failure = global_data.Assert_failure,
    Js_of_ocaml_Firebug = global_data.Js_of_ocaml__Firebug,
    doc = Js_of_ocaml_Dom_html[2],
    _c_ =
      [0,
       [2,
        0,
        [11,
         "<h3>C<sub>",
         [4,
          0,
          0,
          0,
          [11,
           "<\/sub><\/h3><p>",
           [2, 0, [11, cst_br$0, [2, 0, [11, "<\/p>", [10, 0]]]]]]]]],
       "%s<h3>C<sub>%d<\/sub><\/h3><p>%s<br/>%s<\/p>%!"],
    _b_ =
      [0, [11, "K<sub>", [4, 0, 0, 0, [11, cst_sub$0, 0]]], "K<sub>%d<\/sub>"],
    cst_br = cst_br$0,
    cst_Started_computation = "Started computation...",
    cst_Parsing_rewriting_system = "Parsing rewriting system...",
    cst_Parsed = "Parsed: ",
    cst_Computing_Knuth_Bendix_com = "Computing Knuth-Bendix completion...",
    cst_Computing_Squier_completio = "Computing Squier completion...",
    cst_Done = "Done.",
    cst_Error = "Error: ",
    cst_em = "<\/em>",
    cst_em_style_color_red = '<em style="color:red">',
    cst_sub = cst_sub$0,
    cst_R_sub = "R<sub>",
    cst_unknown_arity = "unknown arity",
    _a_ = [0, "tools/kb/kb.ml", 17, 38];
   function button(txt, action){
    var
     button_type = "button",
     t1 = caml_call3(Js_of_ocaml_Dom_html[40], [0, button_type], 0, doc),
     t0 = caml_jsstring_of_string(txt);
    t1.value = t0;
    function _E_(param){caml_call1(action, 0); return Js_of_ocaml_Js[7];}
    var t2 = caml_call1(Js_of_ocaml_Dom_html[10], _E_);
    t1.onclick = t2;
    return t1;
   }
   function debug(s){
    return Js_of_ocaml_Firebug[1].debug(caml_jsstring_of_string(s));
   }
   function jsget(x){
    function _D_(param){
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    }
    return caml_call2(Js_of_ocaml_Js[5][8], x, _D_);
   }
   function parse_rs(syms, rules){
    var
     s = caml_call2(Stdlib_String[16], 44, syms),
     s$0 = caml_call2(Stdlib_List[19], Stdlib_String[23], s);
    function _v_(s){return caml_call2(Stdlib_String[16], 58, s);}
    var s$1 = caml_call2(Stdlib_List[19], _v_, s$0), w = [0, 0];
    function _w_(param){
     if(param){
      var match = param[2];
      if(match){
       var n = match[1], f = param[1];
       w[1] += -1;
       var _C_ = runtime.caml_int_of_string(n);
       return caml_call4(Alg_Term[1][4], 0, [0, w[1]], f, _C_);
      }
     }
     return caml_call1(Stdlib[2], cst_unknown_arity);
    }
    var s$2 = caml_call2(Stdlib_List[19], _w_, s$1);
    Dune_exe_ParserRefs[1][1] = s$2;
    var
     _x_ = caml_call2(Stdlib_Lexing[3], 0, rules),
     rs = caml_call2(Dune_exe_Parser[1], Dune_exe_Lexer[2], _x_),
     n = [0, 0];
    function _y_(param){
     var t = param[2], s = param[1];
     n[1]++;
     var
      _z_ = caml_call1(Stdlib[33], n[1]),
      _A_ = caml_call2(Stdlib[28], _z_, cst_sub),
      _B_ = caml_call2(Stdlib[28], cst_R_sub, _A_);
     return caml_call3(Alg_Term[23][2][1], _B_, s, t);
    }
    var rs$0 = caml_call2(Stdlib_List[19], _y_, rs);
    return caml_call2(Alg_Term[23][6], s$2, rs$0);
   }
   function replace(c, t, s){
    try{
     var
      n = caml_call2(Stdlib_String[35], s, c),
      _q_ =
        caml_call3
         (Stdlib_String[15],
          s,
          n + 1 | 0,
          runtime.caml_ml_string_length(s) - (n + 1 | 0) | 0),
      _r_ = caml_call2(Stdlib[28], t, _q_),
      _s_ = caml_call3(Stdlib_String[15], s, 0, n),
      _t_ = replace(c, t, caml_call2(Stdlib[28], _s_, _r_));
     return _t_;
    }
    catch(_u_){
     var _p_ = caml_wrap_exception(_u_);
     if(_p_ === Stdlib[8]) return s;
     throw caml_maybe_attach_backtrace(_p_, 0);
    }
   }
   function run(param){
    var
     _d_ = jsget(doc.getElementById("symbols")),
     syms = jsget(caml_call1(Js_of_ocaml_Dom_html[117][55], _d_)),
     _e_ = jsget(doc.getElementById("rules")),
     rules = jsget(caml_call1(Js_of_ocaml_Dom_html[117][55], _e_)),
     completion = jsget(doc.getElementById("completion")),
     squier = jsget(doc.getElementById("squier")),
     t27 = jsget(doc.getElementById("go")),
     status = jsget(doc.getElementById("status"));
    function status$0(s){
     var t18 = caml_jsstring_of_string(s);
     return status.innerHTML = t18;
    }
    function error(s){
     var _o_ = caml_call2(Stdlib[28], s, cst_em);
     return status$0(caml_call2(Stdlib[28], cst_em_style_color_red, _o_));
    }
    function _f_(param){
     try{
      status$0(cst_Started_computation);
      var
       syms$0 = caml_string_of_jsstring(syms.value),
       rules$0 = caml_string_of_jsstring(rules.value);
      status$0(cst_Parsing_rewriting_system);
      var
       rs = parse_rs(syms$0, rules$0),
       _g_ = caml_call2(Alg_Term[23][8], 0, rs);
      status$0(caml_call2(Stdlib[28], cst_Parsed, _g_));
      status$0(cst_Computing_Knuth_Bendix_com);
      var
       display =
         function(rs){
          var
           t22 =
             caml_jsstring_of_string
              (replace
                (10,
                 cst_br,
                 caml_call2(Alg_Term[23][8], [0, Alg_Term[2][5]], rs)));
          return completion.innerHTML = t22;
         },
       n = [0, 0],
       namer =
         function(param){
          n[1]++;
          return caml_call2(Stdlib_Printf[4], _b_, n[1]);
         },
       rs$0 = caml_call4(Alg_Term[23][17], 0, [0, namer], [0, display], rs);
      display(rs$0);
      status$0(cst_Computing_Squier_completio);
      var
       sq = caml_call1(Alg_Term[23][19], rs$0),
       _h_ =
         function(param, _m_){
          var
           s2 = _m_[2],
           s1 = _m_[1],
           s2$0 = param[2],
           s1$0 = param[1],
           _n_ = caml_call2(Alg_Term[23][12][9], s1$0, s1);
          return _n_ ? caml_call2(Alg_Term[23][12][9], s2$0, s2) : _n_;
         },
       rule_name = caml_call1(Alg_Utils[1], _h_),
       ans = [0, cst],
       _i_ =
         function(param){
          var
           s2 = param[2],
           s1 = param[1],
           n = caml_call1(rule_name, [0, s1, s2]) + 1 | 0,
           var$0 = caml_call1(Alg_Term[2][5], 0),
           _k_ = caml_call2(Alg_Term[23][12][6], [0, var$0], s2),
           _l_ = caml_call2(Alg_Term[23][12][6], [0, var$0], s1);
          ans[1] = caml_call5(Stdlib_Printf[4], _c_, ans[1], n, _l_, _k_);
          return 0;
         };
      caml_call2(Stdlib_List[17], _i_, sq);
      var sqs = ans[1], t24 = caml_jsstring_of_string(sqs);
      squier.innerHTML = t24;
      status$0(cst_Done);
      var _j_ = Js_of_ocaml_Js[7];
      return _j_;
     }
     catch(e$0){
      var e = caml_wrap_exception(e$0);
      if(e === Stdlib[3]) return Js_of_ocaml_Js[8];
      if(e[1] === Stdlib[7]){
       var s = e[2];
       error(caml_call2(Stdlib[28], cst_Error, s));
       return Js_of_ocaml_Js[8];
      }
      error(caml_call1(Stdlib_Printexc[1], e));
      return Js_of_ocaml_Js[8];
     }
    }
    var t26 = caml_call1(Js_of_ocaml_Dom_html[10], _f_);
    t27.onclick = t26;
    return Js_of_ocaml_Js[7];
   }
   var
    t28 = caml_call1(Js_of_ocaml_Dom_html[10], run),
    t29 = Js_of_ocaml_Dom_html[8];
   t29.onload = t28;
   var Dune_exe_Kb = [0, doc, button, debug, jsget, parse_rs, replace, run];
   runtime.caml_register_global(55, Dune_exe_Kb, "Dune__exe__Kb");
   return;
  }
  (globalThis));


//# 1 "../../.js/default/stdlib/std_exit.cmo.js"
// Generated by js_of_ocaml
//# 3 "../../.js/default/stdlib/std_exit.cmo.js"

//# 6 "../../.js/default/stdlib/std_exit.cmo.js"
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib;
   caml_call1(Stdlib[103], 0);
   var Std_exit = [0];
   runtime.caml_register_global(1, Std_exit, "Std_exit");
   return;
  }
  (globalThis));


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJrYi5iYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJjYW1sX2ludDY0X2lzX3plcm8iLCJ4IiwiY2FtbF9zdHJfcmVwZWF0IiwibiIsInMiLCJyIiwibCIsImNhbWxfaW50NjRfb2Zmc2V0IiwiTWF0aCIsImNhbWxfcmFpc2VfY29uc3RhbnQiLCJ0YWciLCJjYW1sX2dsb2JhbF9kYXRhIiwiY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSIsIk1sSW50NjQiLCJsbyIsIm1pIiwiaGkiLCJ0aGlzIiwieGhpIiwiaCIsInNpZ24iLCJvZmZzZXQiLCJtb2R1bHVzIiwiZGl2aXNvciIsInF1b3RpZW50IiwieSIsInEiLCJjYW1sX2ludDY0X29mX2ludDMyIiwiY2FtbF9pbnQ2NF90b19pbnQzMiIsImNhbWxfaW50NjRfaXNfbmVnYXRpdmUiLCJjYW1sX2ludDY0X25lZyIsImNhbWxfanNieXRlc19vZl9zdHJpbmciLCJqc29vX3N5c19nZXRlbnYiLCJwcm9jZXNzIiwiZ2xvYmFsVGhpcyIsInVuZGVmaW5lZCIsImNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnIiwiaSIsImNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlIiwiZXhuIiwiZm9yY2UiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3JhaXNlX3dpdGhfYXJnIiwiYXJnIiwiY2FtbF9zdHJpbmdfb2ZfanNieXRlcyIsImNhbWxfcmFpc2Vfd2l0aF9zdHJpbmciLCJtc2ciLCJjYW1sX2ludmFsaWRfYXJndW1lbnQiLCJjYW1sX3BhcnNlX2Zvcm1hdCIsImZtdCIsImxlbiIsImYiLCJjIiwiY2FtbF9maW5pc2hfZm9ybWF0dGluZyIsInJhd2J1ZmZlciIsImJ1ZmZlciIsImNhbWxfaW50NjRfZm9ybWF0Iiwid2Jhc2UiLCJjdnRibCIsInAiLCJjYW1sX2V4cG0xX2Zsb2F0IiwiY2FtbF9tbF9jb25kaXRpb25fYnJvYWRjYXN0IiwidCIsImpzb29faXNfYXNjaWkiLCJjYW1sX3V0ZjE2X29mX3V0ZjgiLCJiIiwiYzEiLCJjMiIsInYiLCJqIiwiU3RyaW5nIiwiY2FtbF9qc3N0cmluZ19vZl9zdHJpbmciLCJmc19ub2RlX3N1cHBvcnRlZCIsIm1ha2VfcGF0aF9pc19hYnNvbHV0ZSIsInBvc2l4IiwicGF0aCIsIndpbjMyIiwic3BsaXREZXZpY2VSZSIsInJlc3VsdCIsImRldmljZSIsImlzVW5jIiwiQm9vbGVhbiIsInJvb3QiLCJzZXAiLCJwYXRoX2lzX2Fic29sdXRlIiwiY2FtbF90cmFpbGluZ19zbGFzaCIsIm5hbWUiLCJjYW1sX2N1cnJlbnRfZGlyIiwiY2FtbF9tYWtlX3BhdGgiLCJjb21wMCIsImNvbXAiLCJuY29tcCIsImNhbWxfdXRmOF9vZl91dGYxNiIsImQiLCJjYW1sX3N0cmluZ19vZl9qc3N0cmluZyIsInVuaXhfZXJyb3IiLCJtYWtlX3VuaXhfZXJyX2FyZ3MiLCJjb2RlIiwic3lzY2FsbCIsImVycm5vIiwidmFyaWFudCIsIm51bGwiLCJhcmdzIiwiY2FtbF9uYW1lZF92YWx1ZXMiLCJjYW1sX25hbWVkX3ZhbHVlIiwibm0iLCJjYW1sX3JhaXNlX3dpdGhfYXJncyIsImNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyIsImEiLCJjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzIiwiTWxCeXRlcyIsImNvbnRlbnRzIiwibGVuZ3RoIiwiY29udGVudCIsImNhbWxfaXNfbWxfYnl0ZXMiLCJjYW1sX2lzX21sX3N0cmluZyIsImNhbWxfYnl0ZXNfb2ZfYXJyYXkiLCJVaW50OEFycmF5IiwiY2FtbF9ieXRlc19vZl9qc2J5dGVzIiwiY2FtbF9ieXRlc19vZl9zdHJpbmciLCJjYW1sX3JhaXNlX3N5c19lcnJvciIsImNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlIiwiY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IiwiY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyIsImNhbWxfY3JlYXRlX2J5dGVzIiwiY2FtbF9tbF9ieXRlc19sZW5ndGgiLCJjYW1sX2JsaXRfYnl0ZXMiLCJzMSIsImkxIiwiczIiLCJpMiIsIk1sRmlsZSIsIk1sRmFrZUZpbGUiLCJvbGQiLCJidWYiLCJwb3MiLCJjbGVuIiwibmV3X3N0ciIsIm9sZF9kYXRhIiwiZGF0YSIsIk1sRmFrZUZkIiwiZmlsZSIsImZsYWdzIiwiTWxGYWtlRGV2aWNlIiwicmVzIiwiU3ltYm9sIiwibmFtZV9zbGFzaCIsIm1vZGUiLCJyYWlzZV91bml4IiwicGFyZW50IiwiUmVnRXhwIiwic2VlbiIsIm0iLCJlbnRyeSIsIm9rIiwiQXJyYXkiLCJieXRlcyIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQiLCJjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZyIsImNhbWxfYnl0ZXNfYm91bmRfZXJyb3IiLCJjYW1sX2J5dGVzX3Vuc2FmZV9zZXQiLCJjYW1sX2J5dGVzX3NldCIsIk1sTm9kZUZkIiwiZmQiLCJyZXF1aXJlIiwiZXJyIiwiYnVmX29mZnNldCIsInJlYWQiLCJNbE5vZGVEZXZpY2UiLCJjb25zdHMiLCJrZXkiLCJpc0NoYXJhY3RlckRldmljZSIsIm8iLCJqc19zdGF0cyIsInRvX2RpciIsInRhcmdldCIsImxpbmsiLCJmaWxlX2tpbmQiLCJjYW1sX2dldF9yb290IiwiY2FtbF9mYWlsd2l0aCIsImNhbWxfcm9vdCIsImpzb29fbW91bnRfcG9pbnQiLCJyZXNvbHZlX2ZzX2RldmljZSIsImNhbWxfc3lzX2lzX2RpcmVjdG9yeSIsImNhbWxfcmFpc2Vfbm90X2ZvdW5kIiwiY2FtbF9zeXNfZ2V0ZW52Iiwic2hpZnRfcmlnaHRfbmF0IiwibmF0MSIsIm9mczEiLCJsZW4xIiwibmF0MiIsIm9mczIiLCJuYml0cyIsIndyYXAiLCJjYW1sX2dyX3N0YXRlIiwiY2FtbF9ncl9zdGF0ZV9nZXQiLCJjYW1sX2dyX3BvaW50X2NvbG9yIiwiaW0iLCJjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfcmVzb2x2ZSIsIk1sT2JqZWN0VGFibGUiLCJOYWl2ZUxvb2t1cCIsIm9ianMiLCJjYW1sX3N5c19yZW5hbWUiLCJvX3Jvb3QiLCJuX3Jvb3QiLCJjYW1sX2xvZzEwX2Zsb2F0IiwiY2FtbF9ydW50aW1lX3dhcm5pbmdzIiwiY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyIsImJvb2wiLCJjYW1sX2NsYXNzaWZ5X2Zsb2F0IiwiaXNGaW5pdGUiLCJpc05hTiIsImNhbWxfbWxfY2hhbm5lbHMiLCJjYW1sX3JlZmlsbCIsImNoYW4iLCJzdHIiLCJzdHJfYSIsIm5yZWFkIiwiY2FtbF9hcnJheV9ib3VuZF9lcnJvciIsImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lIiwiY2hhbmlkIiwicHJldl9tYXgiLCJjYW1sX2djX21pbm9yIiwidW5pdCIsImNhbWxfbWxfY29uZGl0aW9uX25ldyIsImNhbWxfaW50NjRfb2ZfYnl0ZXMiLCJjYW1sX2JhX3VpbnQ4X2dldDY0IiwiYmEiLCJpMCIsIm9mcyIsImIxIiwiYjIiLCJiMyIsImI0IiwiYjUiLCJiNiIsImI3IiwiYjgiLCJjYW1sX2ludDY0X3RvX2J5dGVzIiwiY2FtbF9pbnQ2NF9tYXJzaGFsIiwid3JpdGVyIiwic2l6ZXMiLCJjYW1sX2JhX251bV9kaW1zIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImUiLCJjYW1sX2NyZWF0ZV9maWxlIiwianNvb19jcmVhdGVfZmlsZSIsImNhbWxfZnNfaW5pdCIsInRtcCIsImNhbWxfZ2V0X2NvbnRpbnVhdGlvbl9jYWxsc3RhY2siLCJjYW1sX3BhcnNlcl90cmFjZSIsImNhbWxfc2V0X3BhcnNlcl90cmFjZSIsIm9sZGZsYWciLCJjYW1sX2xpc3Rfb2ZfanNfYXJyYXkiLCJjYW1sX211bCIsImNhbWxfaGFzaF9taXhfaW50IiwibnVtX2RpZ2l0c19uYXQiLCJuYXQiLCJjYW1sX2hhc2hfbmF0IiwiY2FtbF9jYWxsX2dlbiIsImFyZ3NMZW4iLCJnIiwibmFyZ3MiLCJleHRyYV9hcmdzIiwiYXJndW1lbnRzIiwiY2FtbF9jYWxsYmFjayIsImNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHMiLCJjYW1sX3N5c19jaGRpciIsImRpciIsImNhbWxfb2JqX3VwZGF0ZV90YWciLCJjYW1sX2xhenlfdXBkYXRlX3RvX2ZvcmNpbmciLCJjYW1sX2djX2NvdW50ZXJzIiwiY2FtbF9ncl9zeW5jaHJvbml6ZSIsImNhbWxfdW5peF9jbG9zZWRpciIsImRpcl9oYW5kbGUiLCJjYW1sX3VuaXhfb3BlbmRpciIsImNhbWxfdW5peF9yZXdpbmRkaXIiLCJuZXdfZGlyX2hhbmRsZSIsImNhbWxfcmFpc2VfZW5kX29mX2ZpbGUiLCJjYW1sX3VuaXhfcmVhZGRpciIsImNhbWxfdW5peF9maW5kZmlyc3QiLCJwYXRoX2pzIiwiZmlyc3RfZW50cnkiLCJjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWciLCJsb2cyX29rIiwianNvb19mbG9vcl9sb2cyIiwiSW5maW5pdHkiLCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQiLCJmbG9hdDMyYSIsIkZsb2F0MzJBcnJheSIsImludDMyYSIsIkludDMyQXJyYXkiLCJjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSIsImNhbWxfaW50NjRfYml0c19vZl9mbG9hdCIsImV4cCIsImsiLCJyMyIsInIyIiwicjEiLCJjYW1sX2JhX3NlcmlhbGl6ZSIsInN6IiwiY29tcGxleCIsImNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQiLCJraW5kIiwiY2FtbF9iYV9jcmVhdGVfYnVmZmVyIiwic2l6ZSIsInZpZXciLCJGbG9hdDY0QXJyYXkiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiVWludDE2QXJyYXkiLCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMiLCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMiLCJOYU4iLCJjYW1sX2JhX2dldF9zaXplIiwiZGltcyIsIm5fZGltcyIsImNhbWxfaW50NjRfY3JlYXRlX2xvX2hpIiwiY2FtbF9pbnQ2NF9oaTMyIiwiY2FtbF9pbnQ2NF9sbzMyIiwiY2FtbF9iYV9jdXN0b21fbmFtZSIsIk1sX0JpZ2FycmF5IiwibGF5b3V0IiwicmUiLCJ0b3RhbCIsImsxIiwiazIiLCJNbF9CaWdhcnJheV9jXzFfMSIsImNhbWxfYmFfY3JlYXRlX3Vuc2FmZSIsInNpemVfcGVyX2VsZW1lbnQiLCJjYW1sX2JhX2Rlc2VyaWFsaXplIiwicmVhZGVyIiwibnVtX2RpbXMiLCJzaXplX2RpbSIsInNpemVfZGltX2hpIiwic2l6ZV9kaW1fbG8iLCJzaXh0eSIsImludDY0IiwiY2FtbF9iYV9jb21wYXJlIiwiY2FtbF9oYXNoX21peF9pbnQ2NCIsImNhbWxfaGFzaF9taXhfZmxvYXQiLCJ2MCIsImNhbWxfYmFfaGFzaCIsIm51bV9lbHRzIiwidyIsImNhbWxfaW50MzJfdW5tYXJzaGFsIiwiY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsIiwiY2FtbF9pbnQ2NF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X2NvbXBhcmUiLCJjYW1sX2ludDY0X2hhc2giLCJjYW1sX2N1c3RvbV9vcHMiLCJjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20iLCJjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20iLCJudW0iLCJjdXN0b20iLCJzd2FwIiwiY2FtbF9jb21wYXJlX3ZhbF90YWciLCJOdW1iZXIiLCJjYW1sX2ludF9jb21wYXJlIiwiY2FtbF9zdHJpbmdfY29tcGFyZSIsImNhbWxfYnl0ZXNfY29tcGFyZSIsImNhbWxfY29tcGFyZV92YWwiLCJzdGFjayIsInRhZ19hIiwidGFnX2IiLCJjYW1sX2dyZWF0ZXJ0aGFuIiwiZGl2X2hlbHBlciIsInoiLCJkaXZfZGlnaXRfbmF0IiwibmF0cSIsIm9mc3EiLCJuYXRyIiwib2ZzciIsInJlbSIsIm51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdCIsInNoaWZ0X2xlZnRfbmF0IiwiTWxOYXQiLCJjcmVhdGVfbmF0IiwiYXJyIiwic2V0X3RvX3plcm9fbmF0IiwiaW5jcl9uYXQiLCJjYXJyeV9pbiIsImNhcnJ5IiwiYWRkX25hdCIsImxlbjIiLCJuYXRfb2ZfYXJyYXkiLCJtdWx0X2RpZ2l0X25hdCIsIm5hdDMiLCJvZnMzIiwieDEiLCJ4MiIsIngzIiwiZGVjcl9uYXQiLCJib3Jyb3ciLCJzdWJfbmF0IiwiY29tcGFyZV9uYXQiLCJkaXZfbmF0IiwicXVvIiwiY2FtbF9iYV9ibGl0Iiwic3JjIiwiZHN0IiwiaXNfZGlnaXRfaW50IiwiY2FtbF9pbnQ2NF9kaXYiLCJjYW1sX2pzX2h0bWxfZW50aXRpZXMiLCJlbnRpdHkiLCJ0ZW1wIiwiZG9jdW1lbnQiLCJjYW1sX3N0cmluZ191bnNhZmVfc2V0IiwiY2FtbF9pbnQ2NF9vZl9mbG9hdCIsImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0IiwiY2FtbF9iYV9zZXRfMiIsImNhbWxfYXJndiIsIm1haW4iLCJhcmd2IiwiYXJnczIiLCJjYW1sX2V4ZWN1dGFibGVfbmFtZSIsImNhbWxfanNfZXZhbF9zdHJpbmciLCJldmFsIiwic2VyaWFsaXplX25hdCIsImNhbWxfbWVtcHJvZl9zZXQiLCJfY29udHJvbCIsImNhbWxfc3lzX2V4aXQiLCJjYW1sX2NoYW5uZWxfZGVzY3JpcHRvciIsImNhbWxfanNfZnJvbV9hcnJheSIsImNhbWxfYmFfcmVzaGFwZSIsInZpbmQiLCJuZXdfZGltIiwiY2FtbF9vb19sYXN0X2lkIiwiY2FtbF9zZXRfb29faWQiLCJjYW1sX2dyX2ZpbGxfcmVjdCIsImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhIiwic3RyMSIsInBvczEiLCJiYTIiLCJwb3MyIiwic2xpY2UiLCJjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUiLCJqc25hbWUiLCJjYW1sX2dldF9nbG9iYWxfZGF0YSIsImNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQiLCJjYW1sX2JhX3VpbnQ4X2dldDE2IiwiY2FtbF9jb21wYXJlIiwiY2FtbF9NRDVUcmFuc2Zvcm0iLCJhZGQiLCJ4eCIsImZmIiwiZ2ciLCJoaCIsImlpIiwiY2FtbF9NRDVVcGRhdGUiLCJjdHgiLCJpbnB1dCIsImlucHV0X2xlbiIsImluX2J1ZiIsImlucHV0X3BvcyIsIm1pc3NpbmciLCJjYW1sX3J1bnRpbWVfZXZlbnRzX3JlYWRfcG9sbCIsImN1cnNvciIsImNhbGxiYWNrcyIsImNhbWxfZnJlc2hfb29faWQiLCJjYW1sX2ludDY0X3RvX2Zsb2F0IiwiY2FtbF9iYV9nZXRfMSIsImNhbWxfYmlnc3RyaW5nX21lbWNtcCIsImNhbWxfbmV3X3N0cmluZyIsImNhbWxfZXJmX2Zsb2F0IiwiYTEiLCJhMiIsImEzIiwiYTQiLCJhNSIsImNhbWxfYmFfdWludDhfZ2V0MzIiLCJjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoIiwiY2FtbF9zdHJfaW5pdGlhbGl6ZSIsImNhbWxfb2JqX2Jsb2NrIiwiY2FtbF9ncl9jbGVhcl9ncmFwaCIsImJpZ3N0cmluZ190b19hcnJheV9idWZmZXIiLCJicyIsImNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQiLCJfdW5pdCIsImx4b3JfZGlnaXRfbmF0IiwiY2FtbF9vYmpfYWRkX29mZnNldCIsImNhbWxfZmluYWxfcmVsZWFzZSIsImNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSIsImNhbWxfanNfdG9fYXJyYXkiLCJjYW1sX3N5c19pc19yZWd1bGFyX2ZpbGUiLCJjYW1sX2dyX3Bsb3QiLCJjb2xvciIsImNhbWxfYnl0ZXNfc2V0NjQiLCJpNjQiLCJjYW1sX3N0cmluZ19zZXQxNiIsImkxNiIsImNhbWxfaW50NjRfYnN3YXAiLCJjYW1sX2djX21ham9yIiwiY2FtbF9sZXhfYXJyYXkiLCJjYW1sX2xleF9lbmdpbmUiLCJ0YmwiLCJzdGFydF9zdGF0ZSIsImxleGJ1ZiIsImxleF9idWZmZXIiLCJsZXhfYnVmZmVyX2xlbiIsImxleF9zdGFydF9wb3MiLCJsZXhfY3Vycl9wb3MiLCJsZXhfbGFzdF9wb3MiLCJsZXhfbGFzdF9hY3Rpb24iLCJsZXhfZW9mX3JlYWNoZWQiLCJsZXhfYmFzZSIsImxleF9iYWNrdHJrIiwibGV4X2RlZmF1bHQiLCJsZXhfdHJhbnMiLCJsZXhfY2hlY2siLCJzdGF0ZSIsImJhc2UiLCJiYWNrdHJrIiwiY2FtbF9zeXNfZmlsZV9leGlzdHMiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9hcnJheV9zdWIiLCJjYW1sX2J5dGVzX2VxdWFsIiwiY2FtbF9ncl9zaXplX3giLCJjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzIiwiY2FtbF9hdG9taWNfZmV0Y2hfYWRkIiwicmVmIiwib3NfdHlwZSIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4iLCJjYW1sX2Nvc2hfZmxvYXQiLCJNbE11dGV4IiwiY2FtbF9tbF9tdXRleF9uZXciLCJjYW1sX2VwaGVfa2V5X29mZnNldCIsImNhbWxfZXBoZV9jaGVja19rZXkiLCJ3ZWFrIiwiY2FtbF9oYXNoX21peF9maW5hbCIsImNhbWxfZ3JfdGV4dF9zaXplIiwidHh0IiwiY2FtbF9sZXhfcnVuX21lbSIsIm1lbSIsImN1cnJfcG9zIiwiY2FtbF9sZXhfcnVuX3RhZyIsImNhbWxfbmV3X2xleF9lbmdpbmUiLCJsZXhfbWVtIiwibGV4X2Jhc2VfY29kZSIsImxleF9iYWNrdHJrX2NvZGUiLCJsZXhfZGVmYXVsdF9jb2RlIiwibGV4X3RyYW5zX2NvZGUiLCJsZXhfY2hlY2tfY29kZSIsImxleF9jb2RlIiwicGNfb2ZmIiwicHN0YXRlIiwiYmFzZV9jb2RlIiwiY2FtbF9iYV91aW50OF9zZXQ2NCIsImNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSIsImNhbWxfbGVzc2VxdWFsIiwiY2FtbF9hY29zaF9mbG9hdCIsImNhbWxfTUQ1SW5pdCIsIkFycmF5QnVmZmVyIiwiYjMyIiwiVWludDMyQXJyYXkiLCJjYW1sX21sX2ZsdXNoIiwiY2FtbF9zZWVrX291dCIsImNhbWxfbWxfc2Vla19vdXRfNjQiLCJjb21wYXJlX25hdF9yZWFsIiwiY2FtbF9nY19zZXQiLCJjYW1sX2pzX2dldCIsImNhbWxfdW5peF9pc2F0dHkiLCJmaWxlRGVzY3JpcHRvciIsInR0eSIsImNhbWxfbWxfc2V0X2J1ZmZlcmVkIiwiY2FtbF9nY19jb21wYWN0aW9uIiwiY2FtbF9lcGhlX2dldF9rZXkiLCJjYW1sX3VuaXhfbG9jYWx0aW1lIiwiRGF0ZSIsImRfbnVtIiwiamFudWFyeWZpcnN0IiwiZG95IiwiamFuIiwianVsIiwic3RkVGltZXpvbmVPZmZzZXQiLCJjYW1sX3VuaXhfbWt0aW1lIiwidG0iLCJ0bTIiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhIiwiY2FtbF9zeXNfZmRzIiwiY2FtbF9zeXNfY2xvc2UiLCJjYW1sX21sX2Nsb3NlX2NoYW5uZWwiLCJjYW1sX2F0b21pY19leGNoYW5nZSIsImNhbWxfc3lzX2lzYXR0eSIsIl9jaGFuIiwiaXNfZGlnaXRfemVybyIsImNhbWxfdW5peF9sc3RhdCIsImNhbWxfdW5peF9sc3RhdF82NCIsImNhbWxfanNfc2V0IiwiY2FtbF9hcnJheV9nZXQiLCJhcnJheSIsImluZGV4IiwiY2FtbF9jb250aW51YXRpb25fdXNlX25vZXhjIiwiY29udCIsImNhbWxfdW5peF9ybWRpciIsImNhbWxfbG9nMl9mbG9hdCIsImNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudCIsImNhbWxfcnVudGltZV9ldmVudHNfcmVzdW1lIiwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUiLCJjYW1sX2ludDY0X3N1YiIsImNhbWxfc2Vla19pbiIsImNhbWxfbWxfc2Vla19pbl82NCIsImNhbWxfZG9tYWluX2lkIiwiY2FtbF9tbF9tdXRleF91bmxvY2siLCJjYW1sX2RvbWFpbl9sYXRlc3RfaWR4IiwiY2FtbF9kb21haW5fc3Bhd24iLCJtdXRleCIsImlkIiwiY2FtbF91bml4X21rZGlyIiwicGVybSIsImNhbWxfaW50NjRfc2hpZnRfbGVmdCIsImNhbWxfbm90ZXF1YWwiLCJjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSIsImNhbWxfanNfd3JhcF9jYWxsYmFjayIsIkZ1bmN0aW9uIiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2siLCJjYW1sX2lzX2pzIiwiY2FtbF9sYXp5X3VwZGF0ZV90b19mb3J3YXJkIiwiY2FtbF9iYV9kaW0iLCJjYW1sX2JhX2RpbV8xIiwiY2FtbF9qc19tZXRoX2NhbGwiLCJjYW1sX2VwaGVfZGF0YV9vZmZzZXQiLCJjYW1sX3dlYWtfY3JlYXRlIiwiY2FtbF9lcGhlX2NyZWF0ZSIsImNhbWxfanNfdG9fYnl0ZV9zdHJpbmciLCJjYW1sX3RyYW1wb2xpbmUiLCJjYW1sX21heWJlX3ByaW50X3N0YXRzIiwiY2FtbF9ieXRlc191bnNhZmVfZ2V0IiwiY2FtbF9ieXRlc19nZXQ2NCIsImNhbWxfY3VzdG9tX2V2ZW50X2luZGV4IiwiY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3JlZ2lzdGVyIiwiZXZlbnRfbmFtZSIsImV2ZW50X3RhZyIsImV2ZW50X3R5cGUiLCJjYW1sX3VuaXhfaGFzX3N5bWxpbmsiLCJjYW1sX2VwaGVfc2V0X2tleSIsIk9iamVjdCIsImNhbWxfZXBoZV91bnNldF9rZXkiLCJjb3VudCIsImNhbWxfd2Vha19zZXQiLCJjYW1sX3N5c19yZW1vdmUiLCJjYW1sX3N0cmluZ19ib3VuZF9lcnJvciIsImNhbWxfc3RyaW5nX2dldDMyIiwiY2FtbF9ieXRlc19nZXQiLCJjYW1sX2h5cG90X2Zsb2F0IiwiY2FtbF9qc19jYWxsIiwiY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSIsImNhbWxfdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nIiwiY2FtbF9oYXNoX21peF9ieXRlc19hcnIiLCJjYW1sX2hhc2hfbWl4X2pzYnl0ZXMiLCJjYW1sX21sX2J5dGVzX2NvbnRlbnQiLCJjYW1sX2hhc2hfbWl4X2J5dGVzIiwiY2FtbF9ieXRlc19sZXNzdGhhbiIsImNhbWxfZXJmY19mbG9hdCIsImNhbWxfZ3JfZmlsbF9wb2x5IiwiYXIiLCJjYW1sX2djX3F1aWNrX3N0YXQiLCJjYW1sX21sX2lucHV0X2NoYXIiLCJjYW1sX21sX2lucHV0X2ludCIsImNhbWxfZ3JfZGlzcGxheV9tb2RlIiwiY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzIiwibnRoX2RpZ2l0X25hdCIsImNhbWxfYXJyYXlfYmxpdCIsImNhbWxfZmxvYXRfb2Zfc3RyaW5nIiwibTMiLCJtYW50aXNzYSIsInBhcnNlSW50IiwiZXhwb25lbnQiLCJjYW1sX3N5c19nZXRjd2QiLCJjYW1sX2ludDY0X2FkZCIsImNhbWxfaW50NjRfbXVsIiwiY2FtbF9pbnQ2NF91bHQiLCJjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UiLCJjYW1sX3BhcnNlX2RpZ2l0IiwiY2FtbF9pbnQ2NF9vZl9zdHJpbmciLCJiYXNlNjQiLCJ0aHJlc2hvbGQiLCJjYW1sX2JhX3NldF8xIiwiY2FtbF9pbnQ2NF94b3IiLCJjYW1sX2ludDY0X29yIiwiY2FtbF9seG1fbmV4dCIsInNoaWZ0X2wiLCJzaGlmdF9yIiwib3IiLCJ4b3IiLCJtdWwiLCJyb3RsIiwiZ2V0Iiwic2V0IiwiTSIsImRhYmEiLCJxMCIsInExIiwic3QiLCJ4MCIsImNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4iLCJjYW1sX2xpc3RfdG9fanNfYXJyYXkiLCJjYW1sX291dHB1dF92YWwiLCJXcml0ZXIiLCJ2YWx1ZSIsIm5vX3NoYXJpbmciLCJjbG9zdXJlcyIsImNvbnNvbGUiLCJpbnRlcm5fb2JqX3RhYmxlIiwibWVtbyIsImV4aXN0aW5nX29mZnNldCIsImV4dGVybl9yZWMiLCJvcHMiLCJzel8zMl82NCIsImhlYWRlcl9wb3MiLCJvbGRfcG9zIiwidHlwZV9vZl92IiwiY2FtbF9zdHJpbmdfb2ZfYXJyYXkiLCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmciLCJjYW1sX3JhaXNlX25vdF9hX2RpciIsImNhbWxfc3lzX3N5c3RlbV9jb21tYW5kIiwiY21kIiwiY2hpbGRfcHJvY2VzcyIsImNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uIiwiY2FtbF91bml4X2dldHVpZCIsImRlc2VyaWFsaXplX25hdCIsImluaXRpYWxpemVfbmF0IiwiY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyIsImNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3ciLCJVSW50OEFycmF5UmVhZGVyIiwiY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSIsInJlYWR2bHEiLCJvdmVyZmxvdyIsIm43IiwiaGVhZGVyX2xlbiIsImRhdGFfbGVuIiwiTWxTdHJpbmdSZWFkZXIiLCJ6c3RkX2RlY29tcHJlc3MiLCJhYiIsInU4IiwidTE2IiwidTMyIiwiaTMyIiwic2xjIiwiZmlsbCIsImNwdyIsImVjIiwiaW5kIiwibnQiLCJFcnJvciIsInJiIiwicnpmaCIsImRhdCIsIm4zIiwiZmxnIiwic3MiLCJjYyIsImRmIiwiZmNmIiwiYnQiLCJkYiIsImRpIiwiZnNiIiwiZnNzIiwid3MiLCJ3YiIsIm1zYiIsInZhbCIsImJpdHMiLCJyZnNlIiwibWFsIiwidHBvcyIsImFsIiwicHJvYnMiLCJzeW0iLCJodCIsImZyZXEiLCJkc3RhdGUiLCJuc3RhdGUiLCJiYjEiLCJzeW1zIiwiY2J0IiwibXNrIiwibXNrMWZiIiwibXN2Iiwic3ZhbCIsInJidCIsInN5bXBvcyIsInNzdGVwIiwic21hc2siLCJzZiIsIm5zIiwibmIiLCJyaHUiLCJ3YyIsImhiIiwiaHciLCJyYyIsInJpIiwiX2EiLCJlYnQiLCJmZHQiLCJlcG9zIiwibGIiLCJzdDEiLCJzdDIiLCJidHIxIiwiYnRyMiIsImZwb3MiLCJieXRlIiwid2VzIiwid3QiLCJtYiIsInRzIiwiaGJ1ZiIsInB2IiwiZGxsdCIsImRtbHQiLCJkb2N0IiwiYjJibCIsImJsIiwibGxiIiwibGxibCIsIm1sYiIsIm1sYmwiLCJkaHUiLCJvdXQiLCJodSIsImViIiwiYnRyIiwiZGh1NCIsInN6MSIsInN6MiIsInN6MyIsInJ6YiIsImIwIiwiYnR5cGUiLCJsYnQiLCJsc3MiLCJsY3MiLCJzNCIsInNwbCIsImh1ZCIsInNjbSIsImR0cyIsIm1kIiwicmJ1ZiIsIl9iIiwibWx0Iiwib2N0IiwibGx0Iiwic3BvcyIsIm91YnQiLCJsc3QiLCJvc3QiLCJtc3QiLCJsbGMiLCJsYnRyIiwibWxjIiwibWJ0ciIsIm9mYyIsIm9idHIiLCJvZnAiLCJvZmYiLCJtbCIsImxsIiwiaWR4Iiwic3RpbiIsImNjdCIsImJ1ZnMiLCJvbCIsImNoayIsImJsayIsImNhbWxfZmxvYXRfb2ZfYnl0ZXMiLCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIiwibWFnaWMiLCJjb21wcmVzc2VkIiwidW5jb21wcmVzc2VkX2RhdGFfbGVuIiwibnVtX29iamVjdHMiLCJfc2l6ZV8zMiIsIl9zaXplXzY0Iiwib2JqX2NvdW50ZXIiLCJpbnRlcm5fcmVjIiwiaGVhZGVyIiwiZXhwZWN0ZWRfc2l6ZSIsImNhbWxfc3RyaW5nX29mX2J5dGVzIiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzIiwiY2FtbF9pbnB1dF92YWx1ZSIsImJsb2NrIiwiY2FtbF9pbnB1dF92YWx1ZV90b19vdXRzaWRlX2hlYXAiLCJjYW1sX2F0b21pY19jYXMiLCJjYW1sX2NvcHlzaWduX2Zsb2F0IiwiY2FtbF9ncl9zZXRfdGV4dF9zaXplIiwiY2FtbF9hdG9taWNfbG9hZCIsImNhbWxfTUQ1RmluYWwiLCJjYW1sX21kNV9ieXRlcyIsImNhbWxfYmFfc2V0X2dlbmVyaWMiLCJjYW1sX21sX2NvbmRpdGlvbl93YWl0IiwibXV0ZXh0IiwiY2FtbF9zdHJpbmdfbGVzc2VxdWFsIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsIiwiY2FtbF9uZXh0YWZ0ZXJfZmxvYXQiLCJvbmUiLCJjYW1sX2dyX3NpemVfeSIsImNhbWxfcG9zX2luIiwiY2FtbF9tbF9wb3NfaW4iLCJjYW1sX2ludDY0X2FuZCIsImNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSIsImNhbWxfcnVudGltZV9ldmVudHNfcGF1c2UiLCJjYW1sX3VuaXhfdW5saW5rIiwiY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZSIsImZzIiwiZmQyIiwiTWxGYWtlRmRfb3V0IiwiY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCIsImNhbWxfc3lzX29wZW4iLCJfcGVybXMiLCJjYW1sX3N0cmluZ19nZXQiLCJyZV9tYXRjaCIsInJlX3dvcmRfbGV0dGVycyIsIm9wY29kZXMiLCJpc193b3JkX2xldHRlciIsImluX2JpdHNldCIsInJlX21hdGNoX2ltcGwiLCJwYXJ0aWFsIiwicHJvZyIsImNwb29sIiwibm9ybXRhYmxlIiwibnVtZ3JvdXBzIiwibnVtcmVnaXN0ZXJzIiwic3RhcnRjaGFycyIsInBjIiwicXVpdCIsImdyb3VwcyIsInJlX3JlZ2lzdGVyIiwiYmFja3RyYWNrIiwiaXRlbSIsInB1c2giLCJhY2NlcHQiLCJwcmVmaXhfbWF0Y2giLCJvcCIsInNhcmciLCJ1YXJnIiwiZ3JvdXAiLCJyZV9zZWFyY2hfYmFja3dhcmQiLCJjYW1sX2pzX2Zyb21fc3RyaW5nIiwiY2FtbF9iYV9zdWIiLCJjaGFuZ2VkX2RpbSIsIm5ld19kaW1zIiwibmV3X2RhdGEiLCJjYW1sX2djX2Z1bGxfbWFqb3IiLCJjYW1sX21sX211dGV4X3RyeV9sb2NrIiwiY2FtbF9ieXRlc19zZXQzMiIsImNhbWxfZ3Jfc2lnaW9fc2lnbmFsIiwiY2FtbF9iYV91aW50OF9zZXQzMiIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IiwiY2FtbF91bml4X2dtdGltZSIsImNhbWxfc2lnbmJpdF9mbG9hdCIsImNhbWxfZ3JfY3VycmVudF94IiwiY2FtbF9ncl9zZXRfbGluZV93aWR0aCIsImNhbWxfZ3Jfc2V0X2ZvbnQiLCJjYW1sX2dyX3NldF9jb2xvciIsImNvbnZlcnQiLCJudW1iZXIiLCJjX3N0ciIsImNhbWxfZ3JfbW92ZXRvIiwiY2FtbF9ncl9yZXNpemVfd2luZG93IiwiY2FtbF9ncl9zdGF0ZV9pbml0IiwiY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5IiwidGEiLCJVaW50OENsYW1wZWRBcnJheSIsImNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSIsImNhbWxfbWxfc2Vla19vdXQiLCJjYW1sX2pzX3R5cGVvZiIsImNhbWxfaGFzaF9taXhfc3RyaW5nIiwiY2FtbF9zdHJpbmdfaGFzaCIsImNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlIiwiY2FtbF9ncl9saW5ldG8iLCJjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5IiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlIiwiY2FtbF9iYV9kaW1fMyIsImNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24iLCJjYW1sX2Zvcm1hdF9leGNlcHRpb24iLCJidWNrZXQiLCJzdGFydCIsImNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uIiwiaGFuZGxlciIsImF0X2V4aXQiLCJjYW1sX2VwaGVfY2hlY2tfZGF0YSIsImNhbWxfYnl0ZXNfZ2V0MTYiLCJjYW1sX29ial9tYWtlX2ZvcndhcmQiLCJjYW1sX2pzX2Zyb21fYm9vbCIsImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZSIsImNhbWxfZXhwMl9mbG9hdCIsImNhbWxfZ3JfY2xvc2VfZ3JhcGgiLCJjYW1sX21sX2RvbWFpbl9jcHVfcmVsYXgiLCJjYW1sX2NyZWF0ZV9zdHJpbmciLCJjYW1sX21sX2lucHV0X2Jsb2NrIiwiYXZhaWwiLCJjYW1sX21kNV9jaGFuIiwidG9yZWFkIiwiY2FtbF9hdGFuaF9mbG9hdCIsImNhbWxfbWxfY29uZGl0aW9uX3NpZ25hbCIsImNhbWxfdW5peF9maW5kbmV4dCIsImNhbWxfbWxfb3V0cHV0X2J5dGVzIiwiY2FtbF9tbF9vdXRwdXQiLCJjYW1sX21sX2RvbWFpbl9pZCIsImNhbWxfZXBoZV9nZXRfZGF0YSIsImNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlIiwiY2FtbF90cmFtcG9saW5lX3JldHVybiIsImNhbWxfbWxfaXNfYnVmZmVyZWQiLCJjYW1sX2FycmF5X2FwcGVuZCIsImwxIiwibDIiLCJjYW1sX3VuaXhfZ2V0dGltZW9mZGF5IiwiY2FtbF91bml4X3RpbWUiLCJjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbCIsImNhbWxfcnVudGltZV9ldmVudHNfY3JlYXRlX2N1cnNvciIsImNhbWxfZmlsbF9ieXRlcyIsImNhbWxfanNfZXhwciIsImNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkIiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMiLCJjYW1sX2V2ZW50bG9nX3Jlc3VtZSIsImNhbWxfbWQ1X3N0cmluZyIsImNhbWxfYXJyYXlfb2Zfc3RyaW5nIiwiY2FtbF9zdHJpbmdfZXF1YWwiLCJjYW1sX2pzb29fZmxhZ3NfdXNlX2pzX3N0cmluZyIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciIsInJlX3JlcGxhY2VtZW50X3RleHQiLCJyZXBsIiwib3JpZyIsImN1ciIsImVuZCIsImNhbWxfcHVyZV9qc19leHByIiwiY2FtbF9ibGl0X3N0cmluZyIsImJsaXRfbmF0IiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyIsImJhMSIsImJ5dGVzMiIsImNhbWxfdW5peF9zdGF0IiwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSIsImpzb29fY3JlYXRlX2ZpbGVfZXh0ZXJuIiwiY2FtbF91bml4X3N0YXRfNjQiLCJjYW1sX3RvX2pzX3N0cmluZyIsImNhbWxfbWxfbXV0ZXhfbG9jayIsInJlX3NlYXJjaF9mb3J3YXJkIiwiY2FtbF9tYWtlX3ZlY3QiLCJpbml0IiwiY2FtbF9tbF9zZWVrX2luIiwiY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnkiLCJjYW1sX21sX291dHB1dF9jaGFyIiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyIiwiY2FtbF9vYmpfaXNfYmxvY2siLCJjYW1sX29ial9zZXRfcmF3X2ZpZWxkIiwiY2FtbF9qc192YXIiLCJjYW1sX3RydW5jX2Zsb2F0IiwiY2FtbF9lcGhlX3Vuc2V0X2RhdGEiLCJjYW1sX2VwaGVfc2V0X2RhdGEiLCJjYW1sX2VwaGVfYmxpdF9kYXRhIiwiY2FtbF9pc19wcmludGFibGUiLCJjYW1sX2J5dGVzX2xlc3NlcXVhbCIsImNhbWxfYXJyYXlfb2ZfYnl0ZXMiLCJjYW1sX2VxdWFsIiwicmVfcGFydGlhbF9tYXRjaCIsImNhbWxfc3lzX3JhbmRvbV9zZWVkIiwibm93IiwiYWxsX2ZpbmFsaXplcnMiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlIiwiY2IiLCJjYW1sX2JhX2dldF8yIiwiY2FtbF9iYV91aW50OF9zZXQxNiIsImNhbWxfbGF6eV9yZXNldF90b19sYXp5IiwiY2FtbF9qc19kZWxldGUiLCJjYW1sX2ludF9vZl9zdHJpbmciLCJjYW1sX2xpc3RfbW91bnRfcG9pbnQiLCJwcmV2IiwiY2FtbF9tYXJzaGFsX2NvbnN0YW50cyIsImNhbWxfb2JqX3Jhd19maWVsZCIsImNhbWxfanNfZXF1YWxzIiwiY2FtbF9vYmpfY29tcGFyZV9hbmRfc3dhcCIsImJpZ3N0cmluZ190b190eXBlZF9hcnJheSIsImNhbWxfZ3JfYXJjX2F1eCIsImN4IiwiY3kiLCJyeSIsInJ4Iiwicm90IiwieFBvcyIsInlQb3MiLCJ4UG9zX3ByZXYiLCJ5UG9zX3ByZXYiLCJzcGFjZSIsImRlbHRhIiwiY2FtbF9ncl9maWxsX2FyYyIsImNhbWxfYmFfc2xpY2UiLCJudW1faW5kcyIsInN1Yl9kaW1zIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrX3Vuc2FmZSIsImNhbWxfYmFfa2luZCIsImNhbWxfYWxsb2NfZHVtbXlfaW5maXgiLCJjYW1sX2pzX2Z1bl9jYWxsIiwiY2FtbF9nY19tYWpvcl9zbGljZSIsIndvcmsiLCJjYW1sX2pzX3B1cmVfZXhwciIsImNvbXBhcmVfZGlnaXRzX25hdCIsImNhbWxfbWxfaW5wdXQiLCJjYW1sX2dyX3dhaXRfZXZlbnQiLCJfZXZsIiwiY2FtbF9ncl9zaWdpb19oYW5kbGVyIiwiY2FtbF9oYXNoX21peF9iaWdzdHJpbmciLCJjYW1sX3JlY29yZF9iYWNrdHJhY2UiLCJjYW1sX3VuaXhfY2xlYW51cCIsImNhbWxfc3lzX2dldF9jb25maWciLCJjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUiLCJjYW1sX29ial9pc19zaGFyZWQiLCJjYW1sX21sX291dF9jaGFubmVsc19saXN0IiwiY2FtbF9hc2luaF9mbG9hdCIsImNhbWxfcG9zX291dCIsImJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIiLCJjYW1sX21vZCIsImNhbWxfYmFfaW5pdCIsImNhbWxfdW5peF9maWxlZGVzY3Jfb2ZfZmQiLCJyZV9zdHJpbmdfbWF0Y2giLCJCaWdTdHJpbmdSZWFkZXIiLCJjYW1sX2dyX2R1bXBfaW1hZ2UiLCJjYW1sX2JhX2dldF9nZW5lcmljIiwiY2FtbF91bml4X3N0YXJ0dXAiLCJjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlIiwiY2FtbF9mb3JtYXRfZmxvYXQiLCJ0b0ZpeGVkIiwiZHAiLCJwcmVjIiwiY2FtbF9tb3VudF9hdXRvbG9hZCIsImNhbWxfc3RyaW5nX2xlc3N0aGFuIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW4iLCJjYW1sX2RpdiIsImNhbWxfb2JqX2R1cCIsImNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5IiwiY2FtbF9tZW1wcm9mX3N0YXJ0IiwicmF0ZSIsInN0YWNrX3NpemUiLCJ0cmFja2VyIiwiY2FtbF9zeXNfZ2V0X2FyZ3YiLCJjYW1sX21sX2RvbWFpbl9zZXRfbmFtZSIsIl9uYW1lIiwiY2FtbF9qc190b19ib29sIiwiY2FtbF9ncl9jcmVhdGVfaW1hZ2UiLCJjYW1sX2VwaGVfZ2V0X2tleV9jb3B5IiwiY2FtbF9sZXNzdGhhbiIsImNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QiLCJjYW1sX2J1aWxkX3N5bWJvbHMiLCJ0b2MiLCJzeW1iIiwiY2FtbF9yZWdpc3Rlcl9nbG9iYWwiLCJuYW1lX29wdCIsIm5pZCIsIm11bHRfbmF0IiwibGVuMyIsInNxdWFyZV9uYXQiLCJjYW1sX2pzX2Zyb21fZmxvYXQiLCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIiwiY2FtbF9nY19zdGF0IiwiY2FtbF9nZXRfbWFqb3JfY3JlZGl0IiwiY2FtbF9zeXNfbW9kaWZ5X2FyZ3YiLCJjYW1sX21ldGhvZF9jYWNoZSIsImNhbWxfZ2V0X3B1YmxpY19tZXRob2QiLCJvYmoiLCJjYWNoZWlkIiwibWV0aHMiLCJsaSIsImNhbWxfanNfZ2V0X2NvbnNvbGUiLCJjYW1sX3N5c191bnNhZmVfZ2V0ZW52IiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4iLCJyZWZpbGwiLCJjaGFubmVsIiwiYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IiwiY2FtbF9yb3VuZF9mbG9hdCIsImNhbWxfb2pzX25ld19hcnIiLCJGIiwiY29tcGxlbWVudF9uYXQiLCJjYW1sX2RvbWFpbl9kbHMiLCJjYW1sX2RvbWFpbl9kbHNfc2V0IiwiY2FtbF9vYmpfdGFnIiwiY2FtbF9sYXp5X3JlYWRfcmVzdWx0IiwiY2FtbF9qc19yZWdleHBzIiwiY2FtbF9qc19odG1sX2VzY2FwZSIsImNhbWxfYmFfZGltXzIiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMiLCJjYW1sX3NpbmhfZmxvYXQiLCJjYW1sX2xkZXhwX2Zsb2F0IiwiY2FtbF9ncl9zdGF0ZV9zZXQiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0IiwiYXJpdHkiLCJjYW1sX2djX21pbm9yX3dvcmRzIiwiY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2siLCJsYW5kX2RpZ2l0X25hdCIsImNhbWxfaW50NjRfbW9kIiwiY2FtbF9vYmpfc2V0X3RhZyIsImNhbWxfaW50MzJfYnN3YXAiLCJjYW1sX2JhX3NldF8zIiwiY2FtbF9qc19pbnN0YW5jZW9mIiwiY2FtbF9nZXRfbWFqb3JfYnVja2V0IiwibnRoX2RpZ2l0X25hdF9uYXRpdmUiLCJzZXRfZGlnaXRfbmF0X25hdGl2ZSIsImRpZ2l0IiwiY2FtbF9zdHJpbmdfc2V0NjQiLCJjYW1sX2dyX3N0YXRlX2NyZWF0ZSIsImNhbnZhcyIsImNvbnRleHQiLCJjYW1sX2dyX2RyYXdfYXJjIiwiY2FtbF9iYV9tYXBfZmlsZSIsInZmZCIsInNoYXJlZCIsImNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGUiLCJhcmduIiwiY2FtbF9iYV9jcmVhdGVfZnJvbSIsImRhdGExIiwiZGF0YTIiLCJqc3R5cCIsImNhbWxfdGFuaF9mbG9hdCIsImNhbWxfcnVudGltZV9ldmVudHNfc3RhcnQiLCJjYW1sX2dyX2RyYXdfc3RyIiwiZHgiLCJjYW1sX2dyX2RyYXdfc3RyaW5nIiwiY2FtbF9ncl9kcmF3X2NoYXIiLCJjYW1sX3VubW91bnQiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhIiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyIsImNhbWxfbWxfcG9zX2luXzY0IiwiY2FtbF9ncl9kcmF3X2ltYWdlIiwiaW1hZ2UiLCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSIsIl9jaGFubmVsIiwiY2FtbF9zdHJpbmdfc2V0IiwiY2FtbF9zeXNfcm1kaXIiLCJjYW1sX3VuaXhfc3ltbGluayIsInNyY19yb290IiwiZHN0X3Jvb3QiLCJjYW1sX21sX3Bvc19vdXQiLCJjYW1sX3NwYWNldGltZV9lbmFibGVkIiwiY2FtbF9ieXRlc19ub3RlcXVhbCIsImNhbWxfcnVudGltZV9wYXJhbWV0ZXJzIiwiY2FtbF9qc19vYmplY3QiLCJjYW1sX2JhX2NyZWF0ZSIsImRpbXNfbWwiLCJjYW1sX2dyX3JlbWVtYmVyX21vZGUiLCJjYW1sX2ZtYV9mbG9hdCIsIlNQTElUIiwiTUlOX1ZBTFVFIiwiRVBTSUxPTiIsIkMiLCJBIiwiQiIsIm11bHRpcGx5IiwiYXQiLCJhaGkiLCJhbG8iLCJiaGkiLCJibG8iLCJhZGp1c3QiLCJzY2FsZSIsInhzIiwieXMiLCJ6cyIsInh5IiwidSIsImNhbWxfcmVjb21tZW5kZWRfZG9tYWluX2NvdW50IiwiY2FtbF9ic3dhcDE2IiwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyIiwiY2FtbF9ncl9kcmF3X3JlY3QiLCJjYW1sX3N0cmluZ19nZXQxNiIsImNhbWxfb3V0cHV0X3ZhbHVlIiwiY2FtbF9iYV9nZXRfMyIsImNhbWxfZXBoZV9ibGl0X2tleSIsImNhbWxfaW5pdGlhbF90aW1lIiwiY2FtbF9zeXNfdGltZSIsImNhbWxfc3lzX3RpbWVfaW5jbHVkZV9jaGlsZHJlbiIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX3VuaXhfZ2V0cHd1aWQiLCJjYW1sX2hhc2giLCJsaW1pdCIsInNlZWQiLCJxdWV1ZSIsInJkIiwid3IiLCJjYW1sX2JhX3RvX3R5cGVkX2FycmF5IiwiY2FtbF9kb21haW5fZGxzX2dldCIsImNhbWxfYnl0ZXNfZ2V0MzIiLCJjYW1sX2ZyZXhwX2Zsb2F0IiwibmVnIiwiY2FtbF9zdHJpbmdfZ2V0NjQiLCJjYW1sX2pzX2Vycm9yX29wdGlvbl9vZl9leGNlcHRpb24iLCJjYW1sX21sX3Bvc19vdXRfNjQiLCJjYW1sX3VuaXhfZmluZGNsb3NlIiwiY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3ciLCJjYW1sX2Zsb2F0YXJyYXlfYmxpdCIsImNhbWxfZ2V0X21pbm9yX2ZyZWUiLCJjYW1sX3NldF9zdGF0aWNfZW52IiwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0IiwiY2FtbF9qc19uZXciLCJjYW1sX2dyX2N1cnJlbnRfeSIsImNhbWxfZm9ybWF0X2ludCIsImpzb29fZWZmZWN0X25vdF9zdXBwb3J0ZWQiLCJjYW1sX21sX2RvbWFpbl91bmlxdWVfdG9rZW5fIiwiY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuIiwiY2FtbF9jb250aW51YXRpb25fdXNlX2FuZF91cGRhdGVfaGFuZGxlcl9ub2V4YyIsImh2YWwiLCJoZXhuIiwiaGVmZiIsImNhbWxfb2JqX3RydW5jYXRlIiwiY2FtbF9qc190b19zdHJpbmciLCJpc19kaWdpdF9vZGQiLCJjYW1sX3J1bnRpbWVfdmFyaWFudCIsImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCIsImJ1ZmZlcmVkIiwiY2FtbF9hcnJheV9jb25jYXQiLCJjYW1sX2dyX29wZW5fZ3JhcGgiLCJpbmZvIiwic3BlY3MiLCJzdGF0dXMiLCJ3aW4iLCJkb2MiLCJ0aXRsZSIsImJvZHkiLCJjYW1sX21ha2VfZmxvYXRfdmVjdCIsImNhbWxfY2JydF9mbG9hdCIsImNhbWxfZXZlbnRsb2dfcGF1c2UiLCJjYW1sX21lbXByb2Zfc3RvcCIsImNhbWxfZ3JlYXRlcmVxdWFsIiwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UiLCJjYW1sX2xvZzFwX2Zsb2F0IiwiY2FtbF9ydW50aW1lX2V2ZW50c19mcmVlX2N1cnNvciIsImNhbWxfbGF6eV9tYWtlX2ZvcndhcmQiLCJsb3JfZGlnaXRfbmF0IiwiY2FtbF9ncl9ibGl0X2ltYWdlIiwiaW0yIiwiY2FtbF9ncl93aW5kb3dfaWQiLCJjYW1sX2pzX29uX2llIiwidWEiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IiwiY2FtbF9iYV9sYXlvdXQiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImNhbWxfYXJyYXlfc2V0IiwibmV3dmFsIiwiY2FtbF9hbGxvY19zdGFjayIsImh2IiwiaHgiLCJoZiIsImNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsIiwic2V0X2RpZ2l0X25hdCIsImNhbWxfYnl0ZXNfc2V0MTYiLCJjYW1sX2dyX2RvY19vZl9zdGF0ZSIsImNhbWxfbWxfb3V0cHV0X2ludCIsImNhbWxfb2JqX3dpdGhfdGFnIiwiY2FtbF9tbF9jaGFubmVsX3NpemUiLCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCIsImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0Iiwic3R5bGUiLCJleHBfc2lnbiIsInNpZ25fc3RyIiwiY3N0IiwieF9zdHIiLCJjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfd3JpdGUiLCJldmVudCIsImV2ZW50X2NvbnRlbnQiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QiLCJjYW1sX3VuaXhfcmVhZGxpbmsiLCJjYW1sX2JhY2t0cmFjZV9zdGF0dXMiLCJjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIiLCJjYW1sX3N5c19hcmd2IiwiY2FtbF9iYV9maWxsIiwiY2FtbF9tb2RmX2Zsb2F0IiwiY2FtbF9nY19nZXQiLCJjYW1sX2Zsb2F0X2NvbXBhcmUiLCJjYW1sX3N0cmluZ19zZXQzMiIsImNhbWxfcGFyc2VfZW5naW5lIiwidGFibGVzIiwiZW52IiwiRVJSQ09ERSIsImxvb3AiLCJ0ZXN0c2hpZnQiLCJzaGlmdCIsInNoaWZ0X3JlY292ZXIiLCJyZWR1Y2UiLCJSRUFEX1RPS0VOIiwiUkFJU0VfUEFSU0VfRVJST1IiLCJHUk9XX1NUQUNLU18xIiwiR1JPV19TVEFDS1NfMiIsIkNPTVBVVEVfU0VNQU5USUNfQUNUSU9OIiwiQ0FMTF9FUlJPUl9GVU5DVElPTiIsImVudl9zX3N0YWNrIiwiZW52X3Zfc3RhY2siLCJlbnZfc3ltYl9zdGFydF9zdGFjayIsImVudl9zeW1iX2VuZF9zdGFjayIsImVudl9zdGFja3NpemUiLCJlbnZfc3RhY2tiYXNlIiwiZW52X2N1cnJfY2hhciIsImVudl9sdmFsIiwiZW52X3N5bWJfc3RhcnQiLCJlbnZfc3ltYl9lbmQiLCJlbnZfYXNwIiwiZW52X3J1bGVfbGVuIiwiZW52X3J1bGVfbnVtYmVyIiwiZW52X3NwIiwiZW52X3N0YXRlIiwiZW52X2VycmZsYWciLCJ0YmxfdHJhbnNsX2NvbnN0IiwidGJsX3RyYW5zbF9ibG9jayIsInRibF9saHMiLCJ0YmxfbGVuIiwidGJsX2RlZnJlZCIsInRibF9kZ290byIsInRibF9zaW5kZXgiLCJ0YmxfcmluZGV4IiwidGJsX2dpbmRleCIsInRibF90YWJsZXNpemUiLCJ0YmxfdGFibGUiLCJ0YmxfY2hlY2siLCJ0YmxfbmFtZXNfY29uc3QiLCJ0YmxfbmFtZXNfYmxvY2siLCJsb2ciLCJ0b2tlbl9uYW1lIiwibmFtZXMiLCJwcmludF90b2tlbiIsInRvayIsInRva2VuIiwibjEiLCJuMiIsInN0YXRlMSIsInNwIiwiZXJyZmxhZyIsImFzcCIsImNhbWxfanNvb19mbGFnc19lZmZlY3RzIiwiY2FtbF91cGRhdGVfZHVtbXkiLCJjYW1sX2FycmF5X2ZpbGwiLCJjYW1sX3N5c19ta2RpciIsImNhbWxfc3RyaW5nX25vdGVxdWFsIiwiY2FtbF9ieXRlc19ncmVhdGVydGhhbiIsImNhbWxfZ3JfbWFrZV9pbWFnZSIsImNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0IiwiY2FtbF9yZWFkX2ZpbGVfY29udGVudCIsImNhbWxfanNfdG9fZmxvYXQiLCJjYW1sX3NldHVwX3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIiwib3JpZ2luIiwiZXJhc2VfcmVsIiwicmVzdCIsInJlc3QkMCIsInJlc3QkMSIsInJlc3QkMiIsInJlc3QkMyIsInJlc3QkNCIsInJlc3QkNSIsInJlc3QkNiIsInJlc3QkNyIsInR5IiwicmVzdCQ4IiwidHkxIiwicmVzdCQ5IiwicmVzdCQxMCIsInJlc3QkMTEiLCJyZXN0JDEyIiwicmVzdCQxMyIsImNvbmNhdF9mbXR0eSIsImZtdHR5MSIsImZtdHR5MiIsInR5MiIsImNvbmNhdF9mbXQiLCJmbXQxIiwiZm10MiIsInBhZCIsInBhZCQwIiwicHJlYyIsInBhZCQxIiwiaWNvbnYiLCJwcmVjJDAiLCJwYWQkMiIsImljb252JDAiLCJwcmVjJDEiLCJwYWQkMyIsImljb252JDEiLCJwcmVjJDIiLCJwYWQkNCIsImljb252JDIiLCJwcmVjJDMiLCJwYWQkNSIsImZjb252IiwicGFkJDYiLCJzdHIiLCJjaHIiLCJmbXR0eSIsInBhZCQ3IiwiZm10dHkkMCIsInBhZCQ4IiwicmVzdCQxNCIsInJlc3QkMTUiLCJyZXN0JDE2IiwiZm10aW5nX2xpdCIsInJlc3QkMTciLCJmbXRpbmdfZ2VuIiwicmVzdCQxOCIsInJlc3QkMTkiLCJjaGFyX3NldCIsIndpZHRoX29wdCIsInJlc3QkMjAiLCJjb3VudGVyIiwicmVzdCQyMSIsInJlc3QkMjIiLCJpZ24iLCJyZXN0JDIzIiwiZiIsImFyaXR5IiwiZmFpbHdpdGgiLCJzIiwiaW52YWxpZF9hcmciLCJtaW4iLCJ4IiwieSIsIm1heCIsImFicyIsImxub3QiLCJpbmZpbml0eSIsIm5lZ19pbmZpbml0eSIsIm5hbiIsIm1heF9mbG9hdCIsIm1pbl9mbG9hdCIsImVwc2lsb25fZmxvYXQiLCJtYXhfaW50IiwibWluX2ludCIsInN5bWJvbCIsInMxIiwiczIiLCJsMSIsImwyIiwiY2hhcl9vZl9pbnQiLCJuIiwic3RyaW5nX29mX2Jvb2wiLCJiIiwiYm9vbF9vZl9zdHJpbmciLCJib29sX29mX3N0cmluZ19vcHQiLCJzdHJpbmdfb2ZfaW50IiwiaW50X29mX3N0cmluZ19vcHQiLCJ2YWxpZF9mbG9hdF9sZXhlbSIsImwiLCJpIiwiaSQwIiwic3RyaW5nX29mX2Zsb2F0IiwiZmxvYXRfb2Zfc3RyaW5nX29wdCIsInN5bWJvbCQwIiwidGwiLCJoZCIsInN0ZGluIiwic3Rkb3V0Iiwic3RkZXJyIiwib3Blbl9vdXRfZ2VuIiwibW9kZSIsInBlcm0iLCJuYW1lIiwiYyIsIm9wZW5fb3V0Iiwib3Blbl9vdXRfYmluIiwiZmx1c2hfYWxsIiwiYSIsIm91dHB1dF9ieXRlcyIsIm9jIiwib3V0cHV0X3N0cmluZyIsIm91dHB1dCIsIm9mcyIsImxlbiIsIm91dHB1dF9zdWJzdHJpbmciLCJvdXRwdXRfdmFsdWUiLCJjaGFuIiwidiIsImNsb3NlX291dCIsImNsb3NlX291dF9ub2VyciIsIm9wZW5faW5fZ2VuIiwib3Blbl9pbiIsIm9wZW5faW5fYmluIiwiaW5wdXQiLCJpYyIsInVuc2FmZV9yZWFsbHlfaW5wdXQiLCJvZnMkMCIsImxlbiQwIiwiciIsImxlbiQxIiwib2ZzJDEiLCJyZWFsbHlfaW5wdXQiLCJyZWFsbHlfaW5wdXRfc3RyaW5nIiwiaW5wdXRfbGluZSIsImJ1aWxkX3Jlc3VsdCIsImJ1ZiIsInBvcyQwIiwiYWNjdSIsImJlZyIsImFjY3UkMCIsInJlcyIsImNsb3NlX2luX25vZXJyIiwicHJpbnRfY2hhciIsInByaW50X3N0cmluZyIsInByaW50X2J5dGVzIiwicHJpbnRfaW50IiwicHJpbnRfZmxvYXQiLCJwcmludF9lbmRsaW5lIiwicHJpbnRfbmV3bGluZSIsInByZXJyX2NoYXIiLCJwcmVycl9zdHJpbmciLCJwcmVycl9ieXRlcyIsInByZXJyX2ludCIsInByZXJyX2Zsb2F0IiwicHJlcnJfZW5kbGluZSIsInByZXJyX25ld2xpbmUiLCJyZWFkX2xpbmUiLCJyZWFkX2ludCIsInJlYWRfaW50X29wdCIsInJlYWRfZmxvYXQiLCJyZWFkX2Zsb2F0X29wdCIsInN0cmluZ19vZl9mb3JtYXQiLCJzeW1ib2wkMSIsInN0cjIiLCJzdHIxIiwiZXhpdF9mdW5jdGlvbiIsImF0X2V4aXQiLCJmX3lldF90b19ydW4iLCJvbGRfZXhpdCIsIm5ld19leGl0JDAiLCJuZXdfZXhpdCIsInN1Y2Nlc3MiLCJkb19kb21haW5fbG9jYWxfYXRfZXhpdCIsImRvX2F0X2V4aXQiLCJleGl0IiwicmV0Y29kZSIsImxlZnQiLCJyaWdodCIsImlzX2xlZnQiLCJpc19yaWdodCIsImZpbmRfbGVmdCIsImZpbmRfcmlnaHQiLCJtYXBfbGVmdCIsImUiLCJtYXBfcmlnaHQiLCJtYXAiLCJ2JDAiLCJmb2xkIiwiZXF1YWwiLCJlMSIsImUyIiwidjEiLCJ2MiIsInYxJDAiLCJ2MiQwIiwiY29tcGFyZSIsIm9jYW1sX3ZlcnNpb24iLCJvY2FtbF9yZWxlYXNlIiwiZXhlY3V0YWJsZV9uYW1lIiwib3NfdHlwZSIsImJhY2tlbmRfdHlwZSIsInVuaXgiLCJ3aW4zMiIsImN5Z3dpbiIsIm1heF9hcnJheV9sZW5ndGgiLCJtYXhfZmxvYXRhcnJheV9sZW5ndGgiLCJtYXhfc3RyaW5nX2xlbmd0aCIsImJpZ19lbmRpYW4iLCJ3b3JkX3NpemUiLCJpbnRfc2l6ZSIsImdldGVudl9vcHQiLCJpbnRlcmFjdGl2ZSIsInNldF9zaWduYWwiLCJzaWdfbnVtIiwic2lnX2JlaCIsInNpZ2FicnQiLCJzaWdhbHJtIiwic2lnZnBlIiwic2lnaHVwIiwic2lnaWxsIiwic2lnaW50Iiwic2lna2lsbCIsInNpZ3BpcGUiLCJzaWdxdWl0Iiwic2lnc2VndiIsInNpZ3Rlcm0iLCJzaWd1c3IxIiwic2lndXNyMiIsInNpZ2NobGQiLCJzaWdjb250Iiwic2lnc3RvcCIsInNpZ3RzdHAiLCJzaWd0dGluIiwic2lndHRvdSIsInNpZ3Z0YWxybSIsInNpZ3Byb2YiLCJzaWdidXMiLCJzaWdwb2xsIiwic2lnc3lzIiwic2lndHJhcCIsInNpZ3VyZyIsInNpZ3hjcHUiLCJzaWd4ZnN6IiwiY2F0Y2hfYnJlYWsiLCJvbiIsImRldmVsb3BtZW50X3ZlcnNpb24iLCJpc19ibG9jayIsImRvdWJsZV9maWVsZCIsInNldF9kb3VibGVfZmllbGQiLCJmaXJzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3IiLCJsYXN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl8iLCJmb3JjaW5nX3RhZyIsImNvbnRfdGFnIiwibGF6eV90YWciLCJjbG9zdXJlX3RhZyIsIm9iamVjdF90YWciLCJpbmZpeF90YWciLCJmb3J3YXJkX3RhZyIsIm5vX3NjYW5fdGFnIiwiYWJzdHJhY3RfdGFnIiwic3RyaW5nX3RhZyIsImRvdWJsZV90YWciLCJkb3VibGVfYXJyYXlfdGFnIiwiY3VzdG9tX3RhZyIsImludF90YWciLCJvdXRfb2ZfaGVhcF90YWciLCJ1bmFsaWduZWRfdGFnIiwiaW5mbyIsIm9iaiIsInN0YXJ0X2VudiIsIm9mX3ZhbCIsInNsb3QiLCJpZCIsIm1heF9lcGhlX2xlbmd0aCIsImNyZWF0ZSIsImxlbmd0aCIsInJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IiwibyIsIm1zZyIsImdldF9rZXkiLCJnZXRfa2V5X2NvcHkiLCJzZXRfa2V5IiwidW5zZXRfa2V5IiwiY2hlY2tfa2V5IiwiYmxpdF9rZXkiLCJvMSIsIm8yIiwic2V0IiwiaW5jciIsImRlY3IiLCJmb3JjZV9nZW5fbGF6eV9ibG9jayIsIm9ubHlfdmFsIiwiYmxrIiwiY2xvc3VyZSQwIiwicmVzdWx0JDAiLCJjbG9zdXJlIiwicmVzdWx0IiwiZSQwIiwiZm9yY2VfbGF6eV9ibG9jayIsImZvcmNlX2dlbiIsImx6diIsInQiLCJmb3JjZV92YWwiLCJmcm9tX2Z1biIsImZyb21fdmFsIiwiaXNfdmFsIiwibWFwX3ZhbCIsImVtcHR5IiwicmV0dXJuJDAiLCJjb25zIiwibmV4dCIsImFwcGVuZCIsInNlcTEiLCJzZXEyIiwic2VxIiwiZmlsdGVyX21hcCIsInNlcSQwIiwiZmlsdGVyIiwiY29uY2F0IiwiZmxhdF9tYXAiLCJmb2xkX2xlZnQiLCJhY2MiLCJhY2MkMCIsImFjYyQxIiwiaXRlciIsInVuZm9sZCIsInUiLCJ1JDAiLCJpc19lbXB0eSIsInhzIiwidW5jb25zIiwieHMkMCIsInhzJDEiLCJpdGVyaSIsImZvbGRfbGVmdGkiLCJhY2N1JDEiLCJmb3JfYWxsIiwicCIsImV4aXN0cyIsImZpbmQiLCJmaW5kX21hcCIsIml0ZXIyIiwieXMiLCJ5cyQwIiwieXMkMSIsImZvbGRfbGVmdDIiLCJmb3JfYWxsMiIsImV4aXN0czIiLCJlcSIsImNtcCIsImluaXRfYXV4IiwiaiIsImluaXQiLCJyZXBlYXQiLCJmb3JldmVyIiwiY3ljbGVfbm9uZW1wdHkiLCJjeWNsZSIsIml0ZXJhdGUxIiwiaXRlcmF0ZSIsIm1hcGlfYXV4IiwibWFwaSIsInRhaWxfc2NhbiIsInMkMCIsInNjYW4iLCJ0YWtlX2F1eCIsInRha2UiLCJkcm9wIiwibiQwIiwibiQxIiwidGFrZV93aGlsZSIsImRyb3Bfd2hpbGUiLCJub2RlIiwiZ3JvdXAiLCJ0b19sYXp5IiwiZmFpbHVyZSIsIm1lbW9pemUiLCJvbmNlIiwiYWN0aW9uIiwiemlwIiwibWFwMiIsImludGVybGVhdmUiLCJzb3J0ZWRfbWVyZ2UxIiwic29ydGVkX21lcmdlIiwibWFwX2ZzdCIsInh5cyIsInh5cyQwIiwibWFwX3NuZCIsInVuemlwIiwiZmlsdGVyX21hcF9maW5kX2xlZnRfbWFwIiwiZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCIsInoiLCJwYXJ0aXRpb25fbWFwIiwicGFydGl0aW9uIiwicGVlbCIsInhzcyIsInRyYW5zcG9zZSIsInRhaWxzIiwiaGVhZHMiLCJyZW1haW5kZXJzIiwieHNzJDAiLCJ0YWlscyQwIiwiaGVhZHMkMCIsIm1hcF9wcm9kdWN0IiwicHJvZHVjdCIsIm9mX2Rpc3BlbnNlciIsIml0IiwidG9fZGlzcGVuc2VyIiwiaW50cyIsIm5vbmUiLCJzb21lIiwidmFsdWUiLCJkZWZhdWx0JDAiLCJnZXQiLCJiaW5kIiwiam9pbiIsImlzX25vbmUiLCJpc19zb21lIiwibzAiLCJ2MCIsInRvX3Jlc3VsdCIsInRvX2xpc3QiLCJ0b19zZXEiLCJvayIsImVycm9yIiwiZ2V0X29rIiwiZ2V0X2Vycm9yIiwibWFwX2Vycm9yIiwiaXRlcl9lcnJvciIsImlzX29rIiwiaXNfZXJyb3IiLCJyMCIsInIxIiwiZTAiLCJ0b19vcHRpb24iLCJ0b19mbG9hdCIsInRvX3N0cmluZyIsImVzY2FwZWQiLCJsb3dlcmNhc2VfYXNjaWkiLCJ1cHBlcmNhc2VfYXNjaWkiLCJjMSIsImMyIiwiZXJyX25vX3ByZWQiLCJlcnJfbm9fc3VjYyIsImxvX2JvdW5kIiwiaGlfYm91bmQiLCJib20iLCJyZXAiLCJzdWNjIiwicHJlZCIsImlzX3ZhbGlkIiwib2ZfaW50IiwiaXNfY2hhciIsIm9mX2NoYXIiLCJ0b19jaGFyIiwidW5zYWZlX3RvX2NoYXIiLCJoYXNoIiwidXRmX2RlY29kZV9pc192YWxpZCIsImQiLCJ1dGZfZGVjb2RlX2xlbmd0aCIsInV0Zl9kZWNvZGVfdWNoYXIiLCJ1dGZfZGVjb2RlIiwidXRmX2RlY29kZV9pbnZhbGlkIiwidXRmXzhfYnl0ZV9sZW5ndGgiLCJ1dGZfMTZfYnl0ZV9sZW5ndGgiLCJsJDAiLCJudGgiLCJsJDEiLCJudGhfb3B0IiwicmV2X2FwcGVuZCIsImwxJDAiLCJsMiQwIiwibDEkMSIsImwyJDEiLCJyZXYiLCJyZXZfaW5pdF90aHJlc2hvbGQiLCJmbGF0dGVuIiwicmV2X21hcCIsImZvbGRfcmlnaHQiLCJhMiIsImExIiwicmV2X21hcDIiLCJmb2xkX3JpZ2h0MiIsIm1lbSIsIm1lbXEiLCJhc3NvYyIsImFzc29jX29wdCIsImFzc3EiLCJhc3NxX29wdCIsIm1lbV9hc3NvYyIsIm1lbV9hc3NxIiwicmVtb3ZlX2Fzc29jIiwicGFpciIsInJlbW92ZV9hc3NxIiwiZmluZF9vcHQiLCJmaW5kX2FsbCIsImZpbHRlcmkiLCJjb25jYXRfbWFwIiwiZm9sZF9sZWZ0X21hcCIsImxfYWNjdSIsIngkMCIsInllcyIsIm5vIiwic3BsaXQiLCJyeSIsInJ4IiwiY29tYmluZSIsIm1lcmdlIiwidDIiLCJoMiIsInQxIiwiaDEiLCJzdGFibGVfc29ydCIsInNvcnQiLCJ4MiIsIngxIiwidGwkMSIsIngzIiwieDIkMCIsIngxJDAiLCJuMSIsIm4yIiwicmV2X3NvcnQiLCJ0bCQwIiwic29ydF91bmlxIiwiYyQwIiwiYyQxIiwiYyQyIiwiYyQzIiwiYyQ0IiwiYyQ1IiwiYyQ2IiwiYWNjdSQyIiwiY29tcGFyZV9sZW5ndGhzIiwiY29tcGFyZV9sZW5ndGhfd2l0aCIsImF1eCIsInRhaWwiLCJvZl9zZXEiLCJkaXJlY3QiLCJkZXB0aCIsInplcm8iLCJvbmUiLCJtaW51c19vbmUiLCJsb2dub3QiLCJtYWtlIiwiY29weSIsIm9mX3N0cmluZyIsInN1YiIsInN1Yl9zdHJpbmciLCJleHRlbmQiLCJkc3RvZmYiLCJzcmNvZmYiLCJjcHlsZW4iLCJmaWxsIiwiYmxpdCIsIm9mczEiLCJvZnMyIiwiYmxpdF9zdHJpbmciLCJzZXAiLCJzZXBsZW4iLCJkc3QiLCJwb3MiLCJoZCQwIiwiY2F0IiwiaXNfc3BhY2UiLCJ0cmltIiwidW5zYWZlX2VzY2FwZSIsImIkMCIsImFwcGx5MSIsImNhcGl0YWxpemVfYXNjaWkiLCJ1bmNhcGl0YWxpemVfYXNjaWkiLCJzdGFydHNfd2l0aCIsInByZWZpeCIsImxlbl9zIiwibGVuX3ByZSIsImVuZHNfd2l0aCIsInN1ZmZpeCIsImxlbl9zdWYiLCJkaWZmIiwiaW5kZXhfcmVjIiwibGltIiwiaSQxIiwiaW5kZXgiLCJpbmRleF9yZWNfb3B0IiwiaW5kZXhfb3B0IiwiaW5kZXhfZnJvbSIsImluZGV4X2Zyb21fb3B0IiwicmluZGV4X3JlYyIsInJpbmRleCIsInJpbmRleF9mcm9tIiwicmluZGV4X3JlY19vcHQiLCJyaW5kZXhfb3B0IiwicmluZGV4X2Zyb21fb3B0IiwiY29udGFpbnNfZnJvbSIsImNvbnRhaW5zIiwicmNvbnRhaW5zX2Zyb20iLCJzcGxpdF9vbl9jaGFyIiwidG9fc2VxaSIsIm5ld19sZW4iLCJuZXdfYnVmIiwidW5zYWZlX2dldF91aW50MTZfbGUiLCJ1bnNhZmVfZ2V0X3VpbnQxNl9iZSIsImdldF9pbnQ4IiwiZ2V0X3VpbnQxNl9sZSIsImdldF91aW50MTZfYmUiLCJnZXRfaW50MTZfbmUiLCJnZXRfaW50MTZfbGUiLCJnZXRfaW50MTZfYmUiLCJnZXRfaW50MzJfbGUiLCJnZXRfaW50MzJfYmUiLCJnZXRfaW50NjRfbGUiLCJnZXRfaW50NjRfYmUiLCJ1bnNhZmVfc2V0X3VpbnQxNl9sZSIsInVuc2FmZV9zZXRfdWludDE2X2JlIiwic2V0X2ludDE2X2xlIiwic2V0X2ludDE2X2JlIiwic2V0X2ludDMyX2xlIiwic2V0X2ludDMyX2JlIiwic2V0X2ludDY0X2xlIiwic2V0X2ludDY0X2JlIiwic2V0X3VpbnQ4Iiwic2V0X3VpbnQxNl9uZSIsImRlY19pbnZhbGlkIiwiZGVjX3JldCIsIm5vdF9pbl94ODBfdG9feEJGIiwibm90X2luX3hBMF90b194QkYiLCJub3RfaW5feDgwX3RvX3g5RiIsIm5vdF9pbl94OTBfdG9feEJGIiwibm90X2luX3g4MF90b194OEYiLCJ1dGZfOF91Y2hhcl8zIiwiYjAiLCJiMSIsImIyIiwidXRmXzhfdWNoYXJfNCIsImIzIiwiZ2V0X3V0Zl84X3VjaGFyIiwiaSQ0IiwiYjEkMSIsImkkNSIsImIyJDEiLCJpJDYiLCJpJDEwIiwiYjEkMyIsImkkMTEiLCJiMiQzIiwiaSQxMiIsImIzJDEiLCJpJDciLCJiMSQyIiwiaSQ4IiwiYjIkMiIsImkkOSIsImIzJDAiLCJpJDEzIiwiYjEkNCIsImkkMTQiLCJiMiQ0IiwiaSQyIiwiYjEkMCIsImkkMyIsImIyJDAiLCJpJDE1IiwiYjEkNSIsInNldF91dGZfOF91Y2hhciIsImxhc3QkMSIsImxhc3QkMCIsImxhc3QiLCJpc192YWxpZF91dGZfOCIsImxhc3QkMyIsImxhc3QkMiIsImxhc3QkNCIsImxhc3QkNSIsImdldF91dGZfMTZiZV91Y2hhciIsImhpIiwibG8iLCJzZXRfdXRmXzE2YmVfdWNoYXIiLCJ1JDEiLCJpc192YWxpZF91dGZfMTZiZSIsImdldF91dGZfMTZsZV91Y2hhciIsInNldF91dGZfMTZsZV91Y2hhciIsImlzX3ZhbGlkX3V0Zl8xNmxlIiwiYnRzIiwiYm9zIiwib2ZfYnl0ZXMiLCJ0b19ieXRlcyIsImciLCJ0b19idWZmZXIiLCJidWZmIiwiZmxhZ3MiLCJoZWFkZXJfc2l6ZSIsImRhdGFfc2l6ZSIsInRvdGFsX3NpemUiLCJmcm9tX2J5dGVzIiwiZnJvbV9zdHJpbmciLCJtYWtlX21hdHJpeCIsInN4Iiwic3kiLCJsYSIsImxiIiwicmVzJDAiLCJsaXN0X2xlbmd0aCIsIm9mX2xpc3QiLCJpbnB1dF9hcnJheSIsImVsdCIsIm91dHB1dF9hcnJheSIsImVsdCQwIiwiYWNjJDIiLCJhMCIsImJpIiwiYWkiLCJuYSIsIm5iIiwibWF4c29uIiwiaTMxIiwiZSQxIiwiaiQwIiwiZmF0aGVyIiwic3JjMW9mcyIsInNyYzFsZW4iLCJzcmMyIiwic3JjMm9mcyIsInNyYzJsZW4iLCJkc3RvZnMiLCJzcmMxciIsInNyYzJyIiwiczIkMSIsInMxJDEiLCJpMSIsImkyIiwiaTIkMCIsImQkMCIsInMyJDAiLCJpMSQwIiwiZCQxIiwiczEkMCIsImlzb3J0dG8iLCJzcmNvZnMiLCJzb3J0dG8iLCJpc19maW5pdGUiLCJpc19pbmZpbml0ZSIsImlzX25hbiIsImVwc2lsb24iLCJvZl9zdHJpbmdfb3B0IiwicGkiLCJpc19pbnRlZ2VyIiwibWluX21heCIsIm1pbl9udW0iLCJtYXhfbnVtIiwibWluX21heF9udW0iLCJ1bnNhZmVfZmlsbCIsImNoZWNrIiwiaGxlbiIsInNyYyIsInNvZnMiLCJkb2ZzIiwiaCIsIm1lbV9pZWVlIiwibWFwX3RvX2FycmF5IiwibWFwX2Zyb21fYXJyYXkiLCJtYXhfaW50JDAiLCJ1bnNpZ25lZF90b19pbnQiLCJ1bnNpZ25lZF9jb21wYXJlIiwibSIsInVuc2lnbmVkX2RpdiIsInEiLCJ1bnNpZ25lZF9yZW0iLCJzaXplIiwiZHVtbXlfcG9zIiwiemVyb19wb3MiLCJlbmdpbmUiLCJ0YmwiLCJzdGF0ZSIsIm5ld19lbmdpbmUiLCJmcm9tX2Z1bmN0aW9uIiwib3B0IiwicmVhZF9mdW4iLCJzdGgiLCJ3aXRoX3Bvc2l0aW9ucyIsImF1eF9idWZmZXIiLCJsZXhidWYiLCJyZWFkIiwibmV3bGVuIiwibmV3YnVmIiwiZnJvbV9jaGFubmVsIiwic2V0X3Bvc2l0aW9uIiwicG9zaXRpb24iLCJzZXRfZmlsZW5hbWUiLCJmbmFtZSIsImxleGVtZSIsInN1Yl9sZXhlbWUiLCJzdWJfbGV4ZW1lX29wdCIsInN1Yl9sZXhlbWVfY2hhciIsInN1Yl9sZXhlbWVfY2hhcl9vcHQiLCJsZXhlbWVfY2hhciIsImxleGVtZV9zdGFydCIsImxleGVtZV9lbmQiLCJsZXhlbWVfc3RhcnRfcCIsImxleGVtZV9lbmRfcCIsIm5ld19saW5lIiwibGNwIiwiZmx1c2hfaW5wdXQiLCJlbnYiLCJncm93X3N0YWNrcyIsIm9sZHNpemUiLCJuZXdzaXplIiwibmV3X3MiLCJuZXdfdiIsIm5ld19zdGFydCIsIm5ld19lbmQiLCJjbGVhcl9wYXJzZXIiLCJjdXJyZW50X2xvb2thaGVhZF9mdW4iLCJ5eXBhcnNlIiwidGFibGVzIiwic3RhcnQiLCJsZXhlciIsImluaXRfYXNwIiwiaW5pdF9zcCIsImluaXRfc3RhY2tiYXNlIiwiaW5pdF9zdGF0ZSIsImluaXRfY3Vycl9jaGFyIiwiaW5pdF9sdmFsIiwiaW5pdF9lcnJmbGFnIiwiY21kIiwiYXJnIiwiYXJnJDAiLCJleG4kMCIsImV4biIsImN1cnJfY2hhciIsInRvayIsInBlZWtfdmFsIiwic3ltYm9sX3N0YXJ0X3BvcyIsInN0IiwiZW4iLCJzeW1ib2xfZW5kX3BvcyIsInJoc19zdGFydF9wb3MiLCJyaHNfZW5kX3BvcyIsInN5bWJvbF9zdGFydCIsInN5bWJvbF9lbmQiLCJyaHNfc3RhcnQiLCJyaHNfZW5kIiwiaXNfY3VycmVudF9sb29rYWhlYWQiLCJwYXJzZV9lcnJvciIsImhlaWdodCIsImhsIiwiaCQwIiwiaHIiLCJiYWwiLCJsciIsImx2IiwibGwiLCJscnIiLCJscnYiLCJscmwiLCJyciIsInJ2IiwicmwiLCJybHIiLCJybHYiLCJybGwiLCJhZGQiLCJzaW5nbGV0b24iLCJhZGRfbWluX2VsZW1lbnQiLCJhZGRfbWF4X2VsZW1lbnQiLCJyaCIsImxoIiwibWluX2VsdCIsIm1pbl9lbHRfb3B0IiwibWF4X2VsdCIsIm1heF9lbHRfb3B0IiwicmVtb3ZlX21pbl9lbHQiLCJyJDAiLCJwcmVzIiwicHJlcyQwIiwicmVtb3ZlIiwidW5pb24iLCJyMiIsInIyJDAiLCJyMSQwIiwiaW50ZXIiLCJzcGxpdF9iaXMiLCJkaXNqb2ludCIsImNvbnNfZW51bSIsImUyJDIiLCJlMSQyIiwiZTIkMCIsImUxJDAiLCJlMiQxIiwiZTEkMSIsInN1YnNldCIsInB2IiwibGYiLCJsdCIsInJmIiwicnQiLCJjYXJkaW5hbCIsImVsZW1lbnRzX2F1eCIsImVsZW1lbnRzIiwiZmluZF9maXJzdCIsInYwJDEiLCJ2MCQwIiwiZmluZF9maXJzdF9vcHQiLCJmaW5kX2xhc3QiLCJmaW5kX2xhc3Rfb3B0IiwidHJ5X2pvaW4iLCJ2JDEiLCJ4MCIsImwkMyIsImwkNCIsIngwJDAiLCJsJDUiLCJ4MCQxIiwibmwiLCJtaWQiLCJsJDIiLCJ4NCIsImFkZF9zZXEiLCJzZXFfb2ZfZW51bSIsInNub2NfZW51bSIsInJldl9zZXFfb2ZfZW51bSIsInRvX3Jldl9zZXEiLCJ0b19zZXFfZnJvbSIsImxvdyIsImxkIiwibHJkIiwicmQiLCJybGQiLCJkYXRhIiwiZDAkMSIsImQwIiwiZDAkMCIsIm1pbl9iaW5kaW5nIiwibWluX2JpbmRpbmdfb3B0IiwibWF4X2JpbmRpbmciLCJtYXhfYmluZGluZ19vcHQiLCJyZW1vdmVfbWluX2JpbmRpbmciLCJ1cGRhdGUiLCJkYXRhJDAiLCJtJDAiLCJhZGRfbWluX2JpbmRpbmciLCJrIiwiYWRkX21heF9iaW5kaW5nIiwiY29uY2F0X29yX2pvaW4iLCJkMSIsImQyIiwiZDIkMCIsImQxJDAiLCJkMiQxIiwiZDEkMSIsInB2ZCIsImZ2ZCIsIm0xIiwibTIiLCJiaW5kaW5nc19hdXgiLCJiaW5kaW5ncyIsImNsZWFyIiwicHVzaCIsInBvcCIsInBvcF9vcHQiLCJ0b3AiLCJ0b3Bfb3B0IiwiY2VsbCIsIm1hdGNoIiwicGVlayIsImNvbnRlbnQiLCJwZWVrX29wdCIsInRha2Vfb3B0IiwiY2VsbCQwIiwicV9yZXMiLCJwcmV2IiwicHJldiQwIiwidHJhbnNmZXIiLCJxMSIsInEyIiwiY29udGVudHMiLCJidWZmZXIiLCJyZXNldCIsImlubmVyIiwicmVzaXplIiwibW9yZSIsIm9sZF9wb3MiLCJvbGRfbGVuIiwibmV3X2J1ZmZlciIsImFkZF9jaGFyIiwidWNoYXJfdXRmXzhfYnl0ZV9sZW5ndGhfbWF4IiwidWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heCIsImFkZF91dGZfOF91Y2hhciIsImFkZF91dGZfMTZiZV91Y2hhciIsImFkZF91dGZfMTZsZV91Y2hhciIsImFkZF9zdWJzdHJpbmciLCJvZmZzZXQiLCJuZXdfcG9zaXRpb24iLCJhZGRfc3ViYnl0ZXMiLCJhZGRfc3RyaW5nIiwiYWRkX2J5dGVzIiwiYWRkX2J1ZmZlciIsImJzIiwiYWRkX2NoYW5uZWwiLCJ0b19yZWFkJDEiLCJhbHJlYWR5X3JlYWQiLCJ0b19yZWFkIiwiYWxyZWFkeV9yZWFkJDAiLCJ0b19yZWFkJDAiLCJvdXRwdXRfYnVmZmVyIiwiYWRkX3N1YnN0aXR1dGUiLCJsaW0kMSIsInByZXZpb3VzIiwicHJldmlvdXMkMCIsInN0YXJ0JDAiLCJvcGVuaW5nIiwibGltJDAiLCJzdG9wJDAiLCJrJDIiLCJjbG9zaW5nIiwic3RvcCIsImskMCIsImskMSIsIm5leHRfaSIsImlkZW50IiwidHJ1bmNhdGUiLCJhZGRfaW50OCIsImFkZF9pbnQxNl9uZSIsImFkZF9pbnQzMl9uZSIsImFkZF9pbnQ2NF9uZSIsImFkZF9pbnQxNl9sZSIsImFkZF9pbnQxNl9iZSIsImFkZF9pbnQzMl9sZSIsImFkZF9pbnQzMl9iZSIsImFkZF9pbnQ2NF9sZSIsImFkZF9pbnQ2NF9iZSIsInJlbGVhc2UiLCJhY3F1aXJlIiwidHJ5X2FjcXVpcmUiLCJyZXQiLCJnZXRfdmFsdWUiLCJtYWtlJDAiLCJyZWxlYXNlJDAiLCJhY3F1aXJlJDAiLCJ0cnlfYWNxdWlyZSQwIiwiY3B1X3JlbGF4IiwidW5pcXVlX3ZhbHVlIiwiY3JlYXRlX2RscyIsImtleV9jb3VudGVyIiwicGFyZW50X2tleXMiLCJuZXdfa2V5Iiwic3BsaXRfZnJvbV9wYXJlbnQiLCJpbml0X29ycGhhbiIsImlkeCIsImtpIiwibWF5YmVfZ3JvdyIsInN6IiwibmV3X3N6IiwibmV3X3N0IiwiZ2V0X2lkIiwiZG9tYWluIiwic2VsZiIsImlzX21haW5fZG9tYWluIiwiZmlyc3RfZG9tYWluX3NwYXduZWQiLCJmaXJzdF9zcGF3bl9mdW5jdGlvbiIsImJlZm9yZV9maXJzdF9zcGF3biIsIm9sZF9mIiwibmV3X2YiLCJhdF9leGl0X2tleSIsInNwYXduIiwicGsiLCJ0ZXJtX211dGV4IiwidGVybV9jb25kaXRpb24iLCJ0ZXJtX3N0YXRlIiwiYm9keSIsImV4JDAiLCJleCIsInJlY29tbWVuZGVkX2RvbWFpbl9jb3VudCIsInN1Yl9mb3JtYXQiLCJmb3JtYXR0aW5nX2xpdCIsImNyZWF0ZV9jaGFyX3NldCIsImFkZF9pbl9jaGFyX3NldCIsInN0cl9pbmQiLCJtYXNrIiwiZnJlZXplX2NoYXJfc2V0IiwicmV2X2NoYXJfc2V0IiwiY2hhcl9zZXQkMCIsImlzX2luX2NoYXJfc2V0IiwicGFkX29mX3BhZF9vcHQiLCJwYWRfb3B0Iiwid2lkdGgiLCJwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQiLCJmbXQiLCJwYWRfb3B0JDAiLCJwYWRfb3B0JDEiLCJwYWRfb3B0JDIiLCJwYWRfb3B0JDMiLCJwYWRfb3B0JDQiLCJwcmVjX29wdCIsInBhZF9vcHQkNSIsIm5kZWMiLCJwYWRfb3B0JDYiLCJwYWRfb3B0JDciLCJwYWRfb3B0JDgiLCJkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiIsImJ1ZmZlcl9jcmVhdGUiLCJpbml0X3NpemUiLCJidWZmZXJfY2hlY2tfc2l6ZSIsIm92ZXJoZWFkIiwibWluX2xlbiIsIm5ld19zdHIiLCJidWZmZXJfYWRkX2NoYXIiLCJidWZmZXJfYWRkX3N0cmluZyIsInN0cl9sZW4iLCJidWZmZXJfY29udGVudHMiLCJjaGFyX29mX2ljb252IiwiY2hhcl9vZl9mY29udiIsImNGIiwiYnByaW50X3BhZHR5IiwicGFkdHkiLCJicHJpbnRfaWdub3JlZF9mbGFnIiwiaWduX2ZsYWciLCJicHJpbnRfcGFkX29wdCIsImJwcmludF9wYWRkaW5nIiwicGFkdHkkMCIsImJwcmludF9wcmVjaXNpb24iLCJicHJpbnRfaWNvbnZfZmxhZyIsImJwcmludF9hbHRpbnRfZm10IiwiYnByaW50X2Zjb252X2ZsYWciLCJzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQiLCJzdHIkMCIsImJwcmludF9jaGFyX2xpdGVyYWwiLCJicHJpbnRfc3RyaW5nX2xpdGVyYWwiLCJicHJpbnRfZm10dHkiLCJmbXR0eSQxIiwiZm10dHkkMiIsImZtdHR5JDMiLCJmbXR0eSQ0IiwiZm10dHkkNSIsImZtdHR5JDYiLCJmbXR0eSQ3IiwiZm10dHkkOCIsImZtdHR5JDkiLCJzdWJfZm10dHkiLCJmbXR0eSQxMCIsInN1Yl9mbXR0eSQwIiwiZm10dHkkMTEiLCJmbXR0eSQxMiIsImZtdHR5JDEzIiwiZm10dHkkMTQiLCJmbXR0eSQxNSIsImludF9vZl9jdXN0b21fYXJpdHkiLCJzdHJpbmdfb2ZfZm10IiwiZm10aXRlciIsImZtdCQwIiwiaWduX2ZsYWckMCIsInN0ciQxIiwiaXNfYWxvbmUkMCIsImlzX2Fsb25lIiwiYWZ0ZXIiLCJiZWZvcmUiLCJqJDEiLCJmbXQkMSIsInN5bW0iLCJmbXR0eV9yZWxfZGV0IiwiZGUiLCJlZCIsImFmIiwiZmEiLCJkZSQwIiwiZWQkMCIsImFmJDAiLCJmYSQwIiwiZGUkMSIsImVkJDEiLCJhZiQxIiwiZmEkMSIsImRlJDIiLCJlZCQyIiwiYWYkMiIsImZhJDIiLCJkZSQzIiwiZWQkMyIsImFmJDMiLCJmYSQzIiwiZGUkNCIsImVkJDQiLCJhZiQ0IiwiZmEkNCIsImRlJDUiLCJlZCQ1IiwiYWYkNSIsImZhJDUiLCJkZSQ2IiwiZWQkNiIsImFmJDYiLCJmYSQ2IiwiZGUkNyIsImVkJDciLCJhZiQ3IiwiZmEkNyIsImRlJDgiLCJlZCQ4IiwiYWYkOCIsImZhJDgiLCJ0cmFucyIsImpkIiwiZGoiLCJnYSIsImFnIiwiZGUkOSIsImVkJDkiLCJhZiQ5IiwiZmEkOSIsImRlJDEwIiwiZWQkMTAiLCJhZiQxMCIsImZhJDEwIiwiZGUkMTEiLCJlZCQxMSIsImFmJDExIiwiZmEkMTEiLCJkZSQxMiIsImVkJDEyIiwiYWYkMTIiLCJmYSQxMiIsImRlJDEzIiwiZWQkMTMiLCJhZiQxMyIsImZhJDEzIiwicmVzdDEiLCJyZXN0MiIsInJlc3QxJDAiLCJyZXN0MiQwIiwicmVzdDEkMSIsInJlc3QyJDEiLCJyZXN0MSQyIiwicmVzdDIkMiIsInJlc3QxJDMiLCJyZXN0MiQzIiwicmVzdDEkNCIsInJlc3QyJDQiLCJyZXN0MSQ1IiwicmVzdDIkNSIsInJlc3QxJDYiLCJyZXN0MiQ2IiwicmVzdDEkNyIsInR5MSQwIiwicmVzdDIkNyIsInR5MiQwIiwicmVzdDEkOCIsInR5MTIiLCJ0eTExIiwicmVzdDIkOCIsInR5MjIiLCJ0eTIxIiwiZjQiLCJmMiIsInJlc3QxJDkiLCJyZXN0MiQ5IiwicmVzdDEkMTAiLCJyZXN0MiQxMCIsInJlc3QxJDExIiwicmVzdDIkMTEiLCJyZXN0MSQxMiIsInJlc3QyJDEyIiwicmVzdDEkMTMiLCJyZXN0MiQxMyIsImZtdHR5X29mX3BhZGRpbmdfZm10dHkiLCJmbXR0eV9vZl9jdXN0b20iLCJhcml0eSQwIiwiZm10dHlfb2ZfZm10IiwidHlfcmVzdCIsInByZWNfdHkiLCJmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkiLCJ0eV9yZXN0JDAiLCJwcmVjX3R5JDAiLCJ0eV9yZXN0JDEiLCJwcmVjX3R5JDEiLCJ0eV9yZXN0JDIiLCJwcmVjX3R5JDIiLCJ0eV9yZXN0JDMiLCJwcmVjX3R5JDMiLCJ0eSQwIiwiZm9ybWF0dGluZ19nZW4iLCJ0eXBlX3BhZGRpbmciLCJ3IiwidHlwZV9wYWRwcmVjIiwidHlwZV9mb3JtYXQiLCJ0eXBlX2Zvcm1hdF9nZW4iLCJ0eXBlX2lnbm9yZWRfcGFyYW1fb25lIiwiZm10dHkwIiwiZm10dHlfcmVzdCIsImZtdF9yZXN0IiwiZm10dHlfcmVzdCQwIiwiZm10X3Jlc3QkMCIsImZtdF9yZXN0JDEiLCJmbXR0eV9yZXN0JDEiLCJmbXQkMiIsImZtdF9yZXN0JDIiLCJmbXR0eV9yZXN0JDIiLCJmbXQkMyIsImZtdF9yZXN0JDMiLCJmbXR0eV9yZXN0JDMiLCJmbXQkNCIsImZtdF9yZXN0JDQiLCJmbXR0eV9yZXN0JDQiLCJmbXQkNSIsImZtdF9yZXN0JDUiLCJmbXR0eV9yZXN0JDUiLCJwcmVjJDQiLCJmbXQkNiIsImZtdF9yZXN0JDYiLCJwcmVjJDUiLCJwYWQkOSIsInBhZCQxMCIsImZtdHR5X3Jlc3QkNiIsInByZWMkNiIsImZtdCQ3IiwiZm10X3Jlc3QkNyIsInByZWMkNyIsInBhZCQxMSIsInBhZCQxMiIsImZtdHR5X3Jlc3QkNyIsInByZWMkOCIsImZtdCQ4IiwiZm10X3Jlc3QkOCIsInBhZCQxMyIsInBhZCQxNCIsImZtdHR5X3Jlc3QkOCIsImZtdCQ5IiwiZm10X3Jlc3QkOSIsImZtdCQxMCIsImZtdF9yZXN0JDEwIiwiZm10JDExIiwiZm10X3Jlc3QkMTEiLCJmbXQkMTIiLCJmbXR0eV9yZXN0JDkiLCJmbXRfcmVzdCQxMiIsImZtdCQxMyIsImZtdHR5X3Jlc3QkMTAiLCJzdWJfZm10dHkxIiwiZm10X3Jlc3QkMTMiLCJzdWJfZm10dHkkMSIsImZtdCQxNCIsImZtdHR5X3Jlc3QkMTEiLCJmbXRfcmVzdCQxNCIsImZtdCQxNSIsImZtdHR5X3Jlc3QkMTIiLCJmbXRfcmVzdCQxNSIsImZtdCQxNiIsImZtdF9yZXN0JDE2IiwiZm10dHkkMTYiLCJmbXQkMTciLCJmbXRfcmVzdCQxNyIsImZtdHR5MyIsImZtdDMiLCJmbXQxJDAiLCJmbXR0eTIkMCIsImZtdDIkMCIsImZtdHR5MyQwIiwiZm10MyQwIiwiZm10dHlfcmVzdCQxMyIsImZtdF9yZXN0JDE4IiwiZm10dHkkMTciLCJmbXQkMTgiLCJmbXR0eV9yZXN0JDE0IiwiZm10X3Jlc3QkMTkiLCJmbXR0eSQxOCIsImZtdCQxOSIsImZtdHR5X3Jlc3QkMTUiLCJmbXRfcmVzdCQyMCIsImZtdHR5JDE5IiwiZm10JDIwIiwic3ViX2ZtdHR5JDIiLCJzdWJfZm10dHkkMyIsInR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aSIsImZtdHR5JDIxIiwiZm10JDIyIiwic3ViX2ZtdHR5JDQiLCJmbXR0eV9yZXN0JDE2IiwiZm10dHkkMjAiLCJmbXQkMjEiLCJzdWJfZm10dHlfcmVzdCIsInN1Yl9mbXR0eV9yZXN0JDAiLCJzdWJfZm10dHlfcmVzdCQxIiwic3ViX2ZtdHR5X3Jlc3QkMiIsInN1Yl9mbXR0eV9yZXN0JDMiLCJzdWJfZm10dHlfcmVzdCQ0Iiwic3ViX2ZtdHR5X3Jlc3QkNSIsInN1Yl9mbXR0eV9yZXN0JDYiLCJzdWJfZm10dHlfcmVzdCQ3Iiwic3ViX2ZtdHR5X3Jlc3QkOCIsInN1Yl9mbXR0eV9yZXN0JDkiLCJzdWJfZm10dHlfcmVzdCQxMCIsInN1Yl9mbXR0eV9yZXN0JDExIiwic3ViX2ZtdHR5X3Jlc3QkMTIiLCJzdWJfZm10dHlfcmVzdCQxMyIsInN1Yl9mbXR0eV9yZXN0JDE0Iiwic3ViMl9mbXR0eSIsInN1Yl9mbXR0eV9yZXN0JDE1Iiwic3ViMl9mbXR0eSQwIiwic3ViX2ZtdHR5X3Jlc3QkMTYiLCJzdWIyX2ZtdHR5JDEiLCJzdWIxX2ZtdHR5Iiwic3ViX2ZtdHR5X3Jlc3QkMTciLCJzdWIyX2ZtdHR5JDIiLCJzdWIxX2ZtdHR5JDAiLCJzdWJfZm10dHlfcmVzdCQxOCIsInN1Yl9mbXR0eV9yZXN0JDE5Iiwic3ViX2ZtdHR5X3Jlc3QkMjAiLCJzdWJfZm10dHlfcmVzdCQyMSIsInN1Yl9mbXR0eV9yZXN0JDIyIiwic3ViX2ZtdHR5X3Jlc3QkMjMiLCJzdWJfZm10dHlfcmVzdCQyNCIsInN1Yl9mbXR0eV9yZXN0JDI1Iiwic3ViX2ZtdHR5X3Jlc3QkMjYiLCJyZWNhc3QiLCJmaXhfcGFkZGluZyIsIndpZHRoJDAiLCJmaXhfaW50X3ByZWNpc2lvbiIsInJlcyQxIiwic3RyaW5nX3RvX2NhbWxfc3RyaW5nIiwiZm9ybWF0X29mX2Zjb252Iiwic3ltYiIsInRyYW5zZm9ybV9pbnRfYWx0IiwiZGlnaXRzIiwicHV0IiwiY29udmVydF9pbnQiLCJjb252ZXJ0X2ludDMyIiwiY29udmVydF9uYXRpdmVpbnQiLCJjb252ZXJ0X2ludDY0IiwiY29udmVydF9mbG9hdCIsImhleCIsInNpZ24iLCJjYW1sX3NwZWNpYWxfdmFsIiwic3RyaW5nX29mX2ZtdHR5IiwibWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24iLCJtYWtlX3ByaW50ZiIsInAkMCIsInAkMSIsIm1ha2VfcGFkZGluZyIsIm5ld19hY2MiLCJtYWtlX3ByaW50ZiQwIiwiYWNjJDMiLCJhY2MkNCIsImskMyIsImthY2MiLCJrJDQiLCJtYWtlX2lnbm9yZWRfcGFyYW0kMCIsIm1ha2VfY3VzdG9tJDAiLCJtYWtlX2ludmFsaWRfYXJnIiwibWFrZV9mcm9tX2ZtdHR5JDAiLCJtYWtlX2Zyb21fZm10dHkiLCJtYWtlX2N1c3RvbSIsIm1ha2VfaWdub3JlZF9wYXJhbSIsImZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIiwibWFrZV9pcHJpbnRmIiwibWFrZV9pcHJpbnRmJDAiLCJrb2MiLCJyZXN0JDI0IiwicmVzdCQyNSIsInJlc3QkMjYiLCJyZXN0JDI3IiwicmVzdCQyOCIsInJlc3QkMjkiLCJmbl9vZl9jdXN0b21fYXJpdHkkMCIsImZuX29mX2N1c3RvbV9hcml0eSIsIm91dHB1dF9hY2MiLCJwJDMiLCJwJDQiLCJwJDUiLCJwJDIiLCJidWZwdXRfYWNjIiwic3RycHV0X2FjYyIsImZhaWx3aXRoX21lc3NhZ2UiLCJvcGVuX2JveF9vZl9zdHJpbmciLCJpbnZhbGlkX2JveCIsInBhcnNlX3NwYWNlcyIsIndzdGFydCIsIndlbmQiLCJib3hfbmFtZSIsIm5zdGFydCIsIm5lbmQiLCJpbmRlbnQiLCJleHBfZW5kIiwiYm94X3R5cGUiLCJtYWtlX3BhZGRpbmdfZm10X2ViYiIsIm1ha2VfcGFkcHJlY19mbXRfZWJiIiwiZm10X2ViYl9vZl9zdHJpbmciLCJsZWdhY3lfYmVoYXZpb3IiLCJmbGFnIiwibGVnYWN5X2JlaGF2aW9yJDAiLCJpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIiwidW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IiwiZW5kX2luZCIsImludmFsaWRfZm9ybWF0X3dpdGhvdXQiLCJleHBlY3RlZF9jaGFyYWN0ZXIiLCJleHBlY3RlZCIsImFkZF9saXRlcmFsIiwibGl0X3N0YXJ0IiwicGFyc2UiLCJzdHJfaW5kJDIiLCJwYXJzZV9mbGFncyIsInN0cl9pbmQkMSIsInN0cl9pbmQkMCIsInBhcnNlX3RhZyIsInN0cl9pbmQkMyIsInN0cl9pbmRfMSIsInBhcnNlX2ludGVnZXIiLCJzdHJfaW5kXzIiLCJzdHJfaW5kXzMiLCJmb3JtYXR0aW5nX2xpdCQwIiwibmV4dF9pbmQiLCJzdHJfaW5kXzQiLCJzdHJfaW5kXzUiLCJzdHJfaW5kJDQiLCJzdHJfaW5kXzEkMCIsInN0cl9pbmRfMiQwIiwic3RyX2luZF8zJDAiLCJzJDEiLCJmb3JtYXR0aW5nX2xpdCQxIiwibmV4dF9pbmQkMCIsInBhcnNlX2NvbnZlcnNpb24iLCJwY3RfaW5kIiwicGx1cyIsInNwYWNlIiwicGFkcHJlYyIsInBsdXNfdXNlZCIsImhhc2hfdXNlZCIsInNwYWNlX3VzZWQiLCJpZ25fdXNlZCIsInBhZF91c2VkIiwicHJlY191c2VkIiwiZ2V0X3BsdXMiLCJnZXRfaGFzaCIsImdldF9zcGFjZSIsImdldF9pZ24iLCJnZXRfcGFkIiwiZ2V0X3ByZWMiLCJnZXRfcGFkcHJlYyIsImdldF9pbnRfcGFkIiwiaW5jb21wYXRpYmxlX2ZsYWciLCJjaGVja19ub18wIiwib3B0X29mX3BhZCIsIndpZHRoJDEiLCJnZXRfcGFkX29wdCIsImdldF9wYWRwcmVjX29wdCIsImZtdF9yZXN1bHQiLCJzdWJfZW5kIiwic2VhcmNoX3N1YmZvcm1hdF9lbmQiLCJzdWJfZm10IiwiaWdub3JlZCQyIiwiY291bnRlciQwIiwiaWdub3JlZCQ2IiwiaWdub3JlZCQ3IiwiYWRkX3JhbmdlIiwiZmFpbF9zaW5nbGVfcGVyY2VudCIsInBhcnNlX2NoYXJfc2V0X2NvbnRlbnQiLCJwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyJDAiLCJwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIiwicmV2ZXJzZSIsImNoYXJfc2V0JDEiLCJpZ25vcmVkJDkiLCJjaGFyX2Zvcm1hdCIsImZtdF9yZXN0JDIxIiwiZm10X3Jlc3QkMjIiLCJmbXRfcmVzdCQyMyIsImlnbm9yZWQkMTAiLCJmbXRfcmVzdCQyNCIsImZtdF9yZXN0JDI1Iiwic3ViX2VuZCQwIiwic3ViX2ZtdCQwIiwiZm10X3Jlc3QkMjYiLCJpZ25vcmVkJDExIiwiaWdub3JlZCQzIiwic3ltYiQwIiwiaWdub3JlZCQ1IiwiY29tcHV0ZV9pbnRfY29udiIsImlnbm9yZWQkOCIsInNwYWNlJDEiLCJoYXNoJDEiLCJwbHVzJDIiLCJraW5kIiwiaWdub3JlZCQ0IiwiaWdub3JlZCIsImlnbm9yZWQkMCIsImlnbm9yZWQkMSIsInBsdXMkMCIsImhhc2gkMCIsInNwYWNlJDAiLCJwbHVzJDEiLCJpZ24kMCIsInBhcnNlX2FmdGVyX3ByZWNpc2lvbiIsIm1pbnVzIiwicGFyc2VfY29udiIsInBhcnNlX2FmdGVyX3BhZGRpbmciLCJwYXJzZV9saXRlcmFsIiwicGFyc2VfcG9zaXRpdmUiLCJuZXdfaW5kIiwibWludXMkMCIsInNldF9mbGFnIiwic3RyX2luZCQ1IiwiemVybyQwIiwiaXNfb3Blbl90YWciLCJpbmQiLCJzdWJfc3RyIiwic3ViX2Zvcm1hdCQwIiwiZm9ybWF0dGluZyQwIiwiZm9ybWF0dGluZyIsInN0cl9pbmQkNyIsInN1Yl9lbmQkMSIsInN1Yl9lbmQkMiIsInN0cl9pbmQkNiIsIm9wdGlvbiIsInN1YmZtdCIsImZvcm1hdF9vZl9zdHJpbmdfZm10dHkiLCJmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCIsImtmcHJpbnRmIiwia2JwcmludGYiLCJpa2ZwcmludGYiLCJmcHJpbnRmIiwiYnByaW50ZiIsImlmcHJpbnRmIiwiaWJwcmludGYiLCJwcmludGYiLCJlcHJpbnRmIiwia3NwcmludGYiLCJzcHJpbnRmIiwiYXNzb2MzIiwieTIiLCJ5MSIsIm1ha2Vfc3ltbGlzdCIsImhlbHBfYWN0aW9uIiwiYWRkX2hlbHAiLCJzcGVjbGlzdCIsImFkZDEiLCJhZGQyIiwidXNhZ2VfYiIsImVycm1zZyIsImRvYyIsInNwZWMiLCJrZXkiLCJ1c2FnZV9zdHJpbmciLCJ1c2FnZSIsImN1cnJlbnQiLCJwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY18iLCJhbGxvd19leHBhbmQiLCJhcmd2IiwiYW5vbmZ1biIsImluaXRwb3MiLCJjb252ZXJ0X2Vycm9yIiwicHJvZ25hbWUiLCJmb2xsb3ckMCIsImtleXdvcmQiLCJub19hcmckMCIsImZvbGxvdyIsIm5vX2FyZyIsImdldF9hcmckMCIsImdldF9hcmciLCJjb25zdW1lX2FyZyQwIiwiY29uc3VtZV9hcmciLCJ0cmVhdF9hY3Rpb24kMCIsInRyZWF0X2FjdGlvbiIsImYkMCIsImYkMSIsInIkMSIsImYkMiIsImFyZyQxIiwiciQyIiwiYXJnJDIiLCJmJDMiLCJhcmckMyIsIngkMSIsInIkMyIsImFyZyQ0IiwieCQyIiwic3BlY3MiLCJmJDQiLCJhcmckNSIsImYkNSIsImYkNiIsImYkNyIsImFyZyQ2IiwibmV3YXJnIiwicGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMiLCJwYXJzZV9hcmd2X2R5bmFtaWMiLCJjdXJyZW50JDAiLCJwYXJzZV9hcmd2IiwibXNnJDAiLCJtc2ckMSIsInBhcnNlX2R5bmFtaWMiLCJwYXJzZV9leHBhbmQiLCJzZWNvbmRfd29yZCIsImxvb3AiLCJtYXhfYXJnX2xlbiIsImN1ciIsImt3ZCIsInJlcGxhY2VfbGVhZGluZ190YWIiLCJzZWVuIiwiYWxpZ24iLCJsaW1pdCIsImNvbXBsZXRlZCIsImtzZCIsImN1dGNvbCQwIiwic3BhY2VzJDAiLCJzcGVjJDAiLCJjdXRjb2wiLCJrd2RfbGVuIiwic3BhY2VzIiwicmVhZF9hdXgiLCJmaWxlIiwid29yZHMiLCJzdGFzaCIsIndvcmQiLCJ3b3JkJDAiLCJyZWFkX2FyZyIsInJlYWRfYXJnMCIsIndyaXRlX2F1eCIsImFyZ3MiLCJ3cml0ZV9hcmciLCJ3cml0ZV9hcmcwIiwibG9jZm10IiwicHJpbnRlcnMiLCJmaWVsZCIsIm90aGVyX2ZpZWxkcyIsInVzZV9wcmludGVycyIsInN0cmluZ19vZl9leHRlbnNpb25fY29uc3RydWN0byIsImNvbnN0cnVjdG9yIiwiZmllbGRzX29wdCIsImNvbnN0cnVjdG9yJDAiLCJ0b19zdHJpbmdfZGVmYXVsdCIsImNoYXIkMCIsImxpbmUiLCJjaGFyJDEiLCJsaW5lJDAiLCJmaWxlJDAiLCJjaGFyJDIiLCJsaW5lJDEiLCJmaWxlJDEiLCJwcmludCIsImZjdCIsImNhdGNoJDAiLCJyYXdfYmFja3RyYWNlX2VudHJpZXMiLCJidCIsImNvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImZvcm1hdF9iYWNrdHJhY2Vfc2xvdCIsImlzX3JhaXNlIiwicHJpbnRfcmF3X2JhY2t0cmFjZSIsIm91dGNoYW4iLCJyYXdfYmFja3RyYWNlIiwiYmFja3RyYWNlIiwicHJpbnRfYmFja3RyYWNlIiwicmF3X2JhY2t0cmFjZV90b19zdHJpbmciLCJiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZSIsInBhcmFtIiwiYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lIiwiYmFja3RyYWNlX3Nsb3RfbG9jYXRpb24iLCJiYWNrdHJhY2Vfc2xvdF9kZWZuYW1lIiwiYmFja3RyYWNlX3Nsb3RzIiwiYmFja3RyYWNlX3Nsb3RzX29mX3Jhd19lbnRyeSIsImVudHJ5IiwicmF3X2JhY2t0cmFjZV9sZW5ndGgiLCJnZXRfYmFja3RyYWNlIiwicmVnaXN0ZXJfcHJpbnRlciIsImZuIiwib2xkX3ByaW50ZXJzIiwibmV3X3ByaW50ZXJzIiwiZXhuX3Nsb3QiLCJleG5fc2xvdF9pZCIsImV4bl9zbG90X25hbWUiLCJlcnJvcnMiLCJkZWZhdWx0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW4iLCJzdGF0dXMiLCJ1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsInNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsImVtcHR5X2JhY2t0cmFjZSIsImhhbmRsZV91bmNhdWdodF9leGNlcHRpb24iLCJkZWJ1Z2dlcl9pbl91c2UiLCJleG4kMSIsInJhd19iYWNrdHJhY2UkMCIsImNvbnN0JDAiLCJmbGlwIiwibmVnYXRlIiwicHJvdGVjdCIsImZpbmFsbHkkMCIsIndvcmsiLCJmaW5hbGx5X25vX2V4biIsIndvcmtfZXhuJDAiLCJ3b3JrX2V4biIsIndvcmtfYnQiLCJldmVudGxvZ19wYXVzZSIsImV2ZW50bG9nX3Jlc3VtZSIsInByaW50X3N0YXQiLCJhbGxvY2F0ZWRfYnl0ZXMiLCJtYSIsInBybyIsIm1pIiwiY3JlYXRlX2FsYXJtIiwiZGVsZXRlX2FsYXJtIiwibnVsbF90cmFja2VyIiwic2FtcGxpbmdfcmF0ZSIsInRyYWNrZXIiLCJjYWxsc3RhY2tfc2l6ZSIsInN0cmluZyIsImJ5dGVzIiwic3Vic3RyaW5nIiwic3ViYnl0ZXMiLCJmaWxlbmFtZSIsImRpZ2VzdCIsImNoYXJfaGV4IiwidG9faGV4IiwiZnJvbV9oZXgiLCJkaWdpdCIsImZsb2F0MzIiLCJmbG9hdDY0IiwiaW50OF9zaWduZWQiLCJpbnQ4X3Vuc2lnbmVkIiwiaW50MTZfc2lnbmVkIiwiaW50MTZfdW5zaWduZWQiLCJpbnQzMiIsImludDY0IiwiaW50JDAiLCJuYXRpdmVpbnQiLCJjb21wbGV4MzIiLCJjb21wbGV4NjQiLCJraW5kX3NpemVfaW5fYnl0ZXMiLCJjX2xheW91dCIsImZvcnRyYW5fbGF5b3V0IiwiY2xvb3AiLCJhcnIiLCJjb2wiLCJmbG9vcCIsImxheW91dCIsImRpbXMiLCJkbGVuIiwic2l6ZV9pbl9ieXRlcyIsInNpemVfaW5fYnl0ZXMkMCIsIm9mX3ZhbHVlIiwiY3JlYXRlJDAiLCJkaW0iLCJzaXplX2luX2J5dGVzJDEiLCJzbGljZSIsImluaXQkMCIsIm9mX2FycmF5IiwiYmEiLCJjcmVhdGUkMSIsImRpbTEiLCJkaW0yIiwic2l6ZV9pbl9ieXRlcyQyIiwic2xpY2VfbGVmdCIsInNsaWNlX3JpZ2h0IiwiaW5pdCQxIiwib2ZfYXJyYXkkMCIsInJvdyIsImNyZWF0ZSQyIiwiZGltMyIsInNpemVfaW5fYnl0ZXMkMyIsInNsaWNlX2xlZnRfMSIsInNsaWNlX3JpZ2h0XzEiLCJzbGljZV9sZWZ0XzIiLCJzbGljZV9yaWdodF8yIiwiaW5pdCQyIiwib2ZfYXJyYXkkMSIsImFycmF5MF9vZl9nZW5hcnJheSIsImFycmF5MV9vZl9nZW5hcnJheSIsImFycmF5Ml9vZl9nZW5hcnJheSIsImFycmF5M19vZl9nZW5hcnJheSIsInJlc2hhcGVfMCIsInJlc2hhcGVfMSIsInJlc2hhcGVfMiIsInJlc2hhcGVfMyIsImkzIiwiaTQiLCJpMyQwIiwiaTQkMCIsIm1rIiwicmVpbml0Iiwic2VlZCIsIm1ha2Vfc2VsZl9pbml0IiwiYml0cyIsImludGF1eCIsImJvdW5kIiwiZnVsbF9pbnQiLCJiaXRzMzIiLCJiaXRzNjQiLCJuYXRpdmViaXRzIiwiZmxvYXQkMCIsImJvb2wiLCJta19kZWZhdWx0IiwicmFuZG9tX2tleSIsImJpdHMkMCIsImludCQxIiwiZnVsbF9pbnQkMCIsImludDMyJDAiLCJuYXRpdmVpbnQkMCIsImludDY0JDAiLCJmbG9hdCQxIiwic2NhbGUiLCJib29sJDAiLCJiaXRzMzIkMCIsImJpdHM2NCQwIiwibmF0aXZlYml0cyQwIiwiZnVsbF9pbml0Iiwic2VsZl9pbml0Iiwic3BsaXQkMCIsImdldF9zdGF0ZSIsInNldF9zdGF0ZSIsIm9uZ29pbmdfdHJhdmVyc2FsIiwiZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCIsInBhcmFtcyIsInJhbmRvbWl6ZWRfZGVmYXVsdCIsInJhbmRvbWl6ZWQiLCJyYW5kb21pemUiLCJpc19yYW5kb21pemVkIiwicHJuZ19rZXkiLCJwb3dlcl8yX2Fib3ZlIiwiaW5pdGlhbF9zaXplIiwicmFuZG9tIiwiY29weV9idWNrZXRsaXN0Iiwia2V5JDAiLCJuZXh0JDAiLCJpbnNlcnRfYWxsX2J1Y2tldHMiLCJpbmRleGZ1biIsImlucGxhY2UiLCJvZGF0YSIsIm5kYXRhIiwibnNpemUiLCJuZGF0YV90YWlsIiwibmlkeCIsIm1hdGNoJDAiLCJvc2l6ZSIsIm9sZF90cmF2IiwiZmlsdGVyX21hcF9pbnBsYWNlIiwiYnVja2V0X2xlbmd0aCIsInN0YXRzIiwibWJsIiwiaGlzdG8iLCJ0YmxfZGF0YSIsImJ1Y2siLCJidWNrJDAiLCJidWNrJDEiLCJ0b19zZXFfa2V5cyIsInRvX3NlcV92YWx1ZXMiLCJrZXlfaW5kZXgiLCJidWNrZXQiLCJrMSIsIm5leHQxIiwiazIiLCJuZXh0MiIsImszIiwiZDMiLCJuZXh0MyIsImZpbmRfaW5fYnVja2V0IiwicmVwbGFjZSIsInJlcGxhY2Vfc2VxIiwic2VlZGVkX2hhc2giLCJoYXNoX3BhcmFtIiwicmVidWlsZCIsImdldF9jb3B5IiwiYXIiLCJlbXB0eWJ1Y2tldCIsImdldF9pbmRleCIsInN6JDAiLCJzeiQxIiwiY291bnRfYnVja2V0IiwiY291bnQiLCJhZGRfYXV4Iiwic2V0dGVyIiwiYnVja2V0JDAiLCJoYXNoZXMiLCJuZXdzeiIsIm5ld2J1Y2tldCQwIiwibmV3aGFzaGVzIiwiaGJ1Y2tldCIsInByZXZfbGVuIiwibGl2ZSIsImokMiIsIm5ld2J1Y2tldCIsIm9sZGxlbiIsIm5ld3QiLCJvYiIsIm9pIiwib2giLCJzZXR0ZXIkMCIsIm5pIiwiZmluZF9vciIsImlmbm90Zm91bmQiLCJmaW5kX3NoYWRvdyIsImlmZm91bmQiLCJsZW5zIiwidG90bGVuIiwidW5rbm93biIsInBwX2VucXVldWUiLCJ0b2tlbiIsInBwX2luZmluaXR5IiwicHBfb3V0cHV0X3N0cmluZyIsInBwX291dHB1dF9uZXdsaW5lIiwiZm9ybWF0X3BwX3RleHQiLCJ0ZXh0IiwiZm9ybWF0X3N0cmluZyIsImJyZWFrX25ld19saW5lIiwicmVhbF9pbmRlbnQiLCJicmVha19saW5lIiwiYnJlYWtfc2FtZV9saW5lIiwiZm9ybWF0X3BwX3Rva2VuIiwic2l6ZSQwIiwidGFicyIsImFkZF90YWIiLCJscyIsInRhZ19uYW1lIiwibWFya2VyIiwiYnJlYWtzIiwiZml0cyIsIm9mZiIsImJveF90eXBlJDAiLCJvZmYkMCIsImluc2VydGlvbl9wb2ludCIsInRhYnMkMCIsImZpcnN0IiwiaGVhZCIsInRhYiIsIm9mZiQxIiwiaW5zZXJ0aW9uX3BvaW50JDAiLCJ3aWR0aCQyIiwiYm94X3R5cGUkMSIsInRib3giLCJ0YWdfbmFtZSQwIiwibWFya2VyJDAiLCJhZHZhbmNlX2xlZnQiLCJwZW5kaW5nX2NvdW50IiwiZW5xdWV1ZV9hZHZhbmNlIiwiZW5xdWV1ZV9zdHJpbmdfYXMiLCJpbml0aWFsaXplX3NjYW5fc3RhY2siLCJzdGFjayIsInF1ZXVlX2VsZW0iLCJzZXRfc2l6ZSIsImxlZnRfdG90YWwiLCJzY2FuX3B1c2giLCJlbGVtIiwicHBfb3Blbl9ib3hfZ2VuIiwiYnJfdHkiLCJwcF9jbG9zZV9ib3giLCJwcF9vcGVuX3N0YWciLCJwcF9jbG9zZV9zdGFnIiwicHBfc2V0X3ByaW50X3RhZ3MiLCJwcF9zZXRfbWFya190YWdzIiwicHBfZ2V0X3ByaW50X3RhZ3MiLCJwcF9nZXRfbWFya190YWdzIiwicHBfc2V0X3RhZ3MiLCJwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb24iLCJwcF9zZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb24iLCJwY3QiLCJwb3QiLCJtY3QiLCJtb3QiLCJwcF9yaW5pdCIsInBwX2ZsdXNoX3F1ZXVlIiwicHBfcHJpbnRfYXNfc2l6ZSIsInBwX3ByaW50X2FzIiwiaXNpemUiLCJwcF9wcmludF9zdHJpbmciLCJwcF9wcmludF9ieXRlcyIsInBwX3ByaW50X2ludCIsInBwX3ByaW50X2Zsb2F0IiwicHBfcHJpbnRfYm9vbCIsInBwX3ByaW50X2NoYXIiLCJwcF9vcGVuX2hib3giLCJwcF9vcGVuX3Zib3giLCJwcF9vcGVuX2h2Ym94IiwicHBfb3Blbl9ob3Zib3giLCJwcF9vcGVuX2JveCIsInBwX3ByaW50X25ld2xpbmUiLCJwcF9wcmludF9mbHVzaCIsInBwX2ZvcmNlX25ld2xpbmUiLCJwcF9wcmludF9pZl9uZXdsaW5lIiwicHBfcHJpbnRfY3VzdG9tX2JyZWFrIiwicHBfcHJpbnRfYnJlYWsiLCJwcF9wcmludF9zcGFjZSIsInBwX3ByaW50X2N1dCIsInBwX29wZW5fdGJveCIsInBwX2Nsb3NlX3Rib3giLCJwcF9wcmludF90YnJlYWsiLCJwcF9wcmludF90YWIiLCJwcF9zZXRfdGFiIiwicHBfc2V0X21heF9ib3hlcyIsInBwX2dldF9tYXhfYm94ZXMiLCJwcF9vdmVyX21heF9ib3hlcyIsInBwX3NldF9lbGxpcHNpc190ZXh0IiwicHBfZ2V0X2VsbGlwc2lzX3RleHQiLCJwcF9saW1pdCIsInBwX3NldF9tYXhfaW5kZW50IiwicHBfZ2V0X21heF9pbmRlbnQiLCJwcF9zZXRfbWFyZ2luIiwibmV3X21heF9pbmRlbnQiLCJ2YWxpZGF0ZV9nZW9tZXRyeSIsIm1hcmdpbiIsIm1heF9pbmRlbnQiLCJjaGVja19nZW9tZXRyeSIsImdlb21ldHJ5IiwicHBfZ2V0X21hcmdpbiIsInBwX3NldF9mdWxsX2dlb21ldHJ5IiwicHBfc2V0X2dlb21ldHJ5IiwicHBfc2FmZV9zZXRfZ2VvbWV0cnkiLCJwcF9nZXRfZ2VvbWV0cnkiLCJwcF91cGRhdGVfZ2VvbWV0cnkiLCJwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGkiLCJwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGkiLCJkaXNwbGF5X25ld2xpbmUiLCJibGFua19saW5lIiwiZGlzcGxheV9ibGFua3MiLCJwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwiZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnIiwiZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZyIsImRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWciLCJkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZyIsInBwX21ha2VfZm9ybWF0dGVyIiwicHBfcXVldWUiLCJzeXNfdG9rIiwic2Nhbl9zdGFjayIsImZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIiwib3V0X2Z1bnMiLCJtYWtlX2Zvcm1hdHRlciIsImZsdXNoIiwicHBmIiwiZm9ybWF0dGVyX29mX291dF9jaGFubmVsIiwiZm9ybWF0dGVyX29mX2J1ZmZlciIsInBwX2J1ZmZlcl9zaXplIiwicHBfbWFrZV9idWZmZXIiLCJzdGRidWYiLCJzdGRfZm9ybWF0dGVyIiwiZXJyX2Zvcm1hdHRlciIsInN0cl9mb3JtYXR0ZXIiLCJzdGRidWZfa2V5Iiwic3RyX2Zvcm1hdHRlcl9rZXkiLCJidWZmZXJlZF9vdXRfc3RyaW5nIiwiYnVmZmVyZWRfb3V0X2ZsdXNoIiwic3RkX2J1Zl9rZXkiLCJlcnJfYnVmX2tleSIsInN0ZF9mb3JtYXR0ZXJfa2V5IiwiZXJyX2Zvcm1hdHRlcl9rZXkiLCJnZXRfc3RkX2Zvcm1hdHRlciIsImdldF9lcnJfZm9ybWF0dGVyIiwiZ2V0X3N0cl9mb3JtYXR0ZXIiLCJnZXRfc3RkYnVmIiwiZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciIsImZsdXNoX3N0cl9mb3JtYXR0ZXIiLCJtYWtlX3N5bmNocm9uaXplZF9mb3JtYXR0ZXIiLCJvdXRwdXQkMCIsImZsdXNoJDAiLCJzeW5jaHJvbml6ZWRfZm9ybWF0dGVyX29mX291dF8iLCJtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwic29iIiwiZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJmbHVzaF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiaXRlbXMiLCJhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0iLCJpdGVtIiwiZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9iIiwib3Blbl9oYm94Iiwib3Blbl92Ym94Iiwib3Blbl9odmJveCIsIm9wZW5faG92Ym94Iiwib3Blbl9ib3giLCJjbG9zZV9ib3giLCJvcGVuX3N0YWciLCJjbG9zZV9zdGFnIiwicHJpbnRfYXMiLCJwcmludF9ib29sIiwicHJpbnRfYnJlYWsiLCJwcmludF9jdXQiLCJwcmludF9zcGFjZSIsImZvcmNlX25ld2xpbmUiLCJwcmludF9mbHVzaCIsInByaW50X2lmX25ld2xpbmUiLCJvcGVuX3Rib3giLCJjbG9zZV90Ym94IiwicHJpbnRfdGJyZWFrIiwic2V0X3RhYiIsInByaW50X3RhYiIsInNldF9tYXJnaW4iLCJnZXRfbWFyZ2luIiwic2V0X21heF9pbmRlbnQiLCJnZXRfbWF4X2luZGVudCIsInNldF9nZW9tZXRyeSIsInNhZmVfc2V0X2dlb21ldHJ5IiwiZ2V0X2dlb21ldHJ5IiwidXBkYXRlX2dlb21ldHJ5Iiwic2V0X21heF9ib3hlcyIsImdldF9tYXhfYm94ZXMiLCJvdmVyX21heF9ib3hlcyIsInNldF9lbGxpcHNpc190ZXh0IiwiZ2V0X2VsbGlwc2lzX3RleHQiLCJzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwic2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMiLCJzZXRfcHJpbnRfdGFncyIsImdldF9wcmludF90YWdzIiwic2V0X21hcmtfdGFncyIsImdldF9tYXJrX3RhZ3MiLCJzZXRfdGFncyIsInBwX3ByaW50X2xpc3QiLCJwcF92Iiwib3B0JDAiLCJwcF9zZXAiLCJvcHQkMSIsInBwX3ByaW50X3NlcSIsInNlcSQxIiwic2VxJDIiLCJwcF9wcmludF90ZXh0IiwicHBfcHJpbnRfb3B0aW9uIiwicHBfcHJpbnRfcmVzdWx0IiwicHBfcHJpbnRfZWl0aGVyIiwiY29tcHV0ZV90YWciLCJ0YWdfYWNjIiwib3V0cHV0X2Zvcm1hdHRpbmdfbGl0IiwiYnR5IiwicCQ2IiwicCQ3Iiwic2l6ZSQxIiwicCQ4Iiwia2RwcmludGYiLCJkcHJpbnRmIiwia2FzcHJpbnRmIiwiYXNwcmludGYiLCJmbHVzaF9zdGFuZGFyZF9mb3JtYXR0ZXJzIiwiZnMiLCJmcyQwIiwibnVsbF9jaGFyIiwibmV4dF9jaGFyIiwiaWIiLCJwZWVrX2NoYXIiLCJjaGVja2VkX3BlZWtfY2hhciIsImVuZF9vZl9pbnB1dCIsImJlZ2lubmluZ19vZl9pbnB1dCIsIm5hbWVfb2ZfaW5wdXQiLCJjaGFyX2NvdW50IiwiaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIiLCJ0b2tlbl9zdHJpbmciLCJ0b2tlbl9idWZmZXIiLCJza2lwX2NoYXIiLCJpZ25vcmVfY2hhciIsInN0b3JlX2NoYXIiLCJkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplIiwiaW5hbWUiLCJzY2FuX2Nsb3NlX2F0X2VuZCIsInNjYW5fcmFpc2VfYXRfZW5kIiwiZnJvbV9pYyIsInNjYW5fY2xvc2VfaWMiLCJlb2YiLCJvcGVuX2luX2ZpbGUiLCJjbG9zZV9pbiIsImljJDAiLCJiYWRfaW5wdXQiLCJiYWRfaW5wdXRfZXNjYXBlIiwiYmFkX3Rva2VuX2xlbmd0aCIsIm1lc3NhZ2UiLCJiYWRfZmxvYXQiLCJiYWRfaGV4X2Zsb2F0IiwiY2hhcmFjdGVyX21pc21hdGNoIiwiY2kiLCJjaGVja190aGlzX2NoYXIiLCJjaGVja19jaGFyIiwidG9rZW5fY2hhciIsInRva2VuX2Jvb2wiLCJpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciIsInRva2VuX2ludF9saXRlcmFsIiwiY29udiIsInRva2VuX2Zsb2F0Iiwic2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIiLCJzY2FuX2RlY2ltYWxfZGlnaXRfcGx1cyIsInNjYW5fZGlnaXRfcGx1cyIsImJhc2lzIiwiZGlnaXRwIiwid2lkdGgkMyIsImlzX2JpbmFyeV9kaWdpdCIsInNjYW5fYmluYXJ5X2ludCIsImlzX29jdGFsX2RpZ2l0Iiwic2Nhbl9vY3RhbF9pbnQiLCJpc19oZXhhX2RpZ2l0Iiwic2Nhbl9oZXhhZGVjaW1hbF9pbnQiLCJzY2FuX3NpZ24iLCJzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWwiLCJzY2FuX2ludF9jb252ZXJzaW9uIiwic2Nhbl9mcmFjdGlvbmFsX3BhcnQiLCJzY2FuX2V4cG9uZW50X3BhcnQiLCJzY2FuX2Zsb2F0IiwicHJlY2lzaW9uIiwicHJlY2lzaW9uJDAiLCJjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyIsImxvd2VyY2FzZSIsInNjYW5faGV4X2Zsb2F0Iiwid2lkdGgkNCIsIndpZHRoJDUiLCJ3aWR0aCQ2Iiwid2lkdGgkMTAiLCJ3aWR0aCQ3Iiwid2lkdGgkOCIsIndpZHRoJDkiLCJzY2FuX2NhbWxfZmxvYXRfcmVzdCIsIndpZHRoX3ByZWNpc2lvbiIsImZyYWNfd2lkdGgiLCJzY2FuX2NhbWxfZmxvYXQiLCJzY2FuX3N0cmluZyIsInN0cCIsImhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIiLCJjaGVja19uZXh0X2NoYXIiLCJjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIiLCJjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyIsInNjYW5fYmFja3NsYXNoX2NoYXIiLCJjMCIsImdldF9kaWdpdCIsImdldF9kaWdpdCQwIiwiYzEkMCIsImMyJDAiLCJzY2FuX2NhbWxfc3RyaW5nIiwiZmluZF9zdG9wJDAiLCJza2lwX3NwYWNlcyIsImZpbmRfc3RvcCIsInNjYW5fY2hhcnNfaW5fY2hhcl9zZXQiLCJzY2FuX2luZGljIiwic2Nhbl9jaGFycyIsInNjYW5mX2JhZF9pbnB1dCIsIndpZHRoX29mX3BhZF9vcHQiLCJzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IiwiZm10aW5nIiwidGFrZV9mb3JtYXRfcmVhZGVycyQwIiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyQwIiwicmVhZGVyIiwibmV3X2siLCJyZWFkZXJzX3Jlc3QiLCJ0YWtlX2Zvcm1hdF9yZWFkZXJzIiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyIsInBhZF9wcmVjX3NjYW5mIiwicmVhZGVycyIsIm1ha2Vfc2NhbmYiLCJzY2FuJDAiLCJzdHJfcmVzdCIsInNjYW4kMSIsInNjYW4kMiIsInNjYW4kMyIsInNjYW4kNCIsImNvbnYkMCIsInNjYW4kNSIsImNvbnYkMSIsInNjYW4kNiIsImNvbnYkMiIsInNjYW4kNyIsInNjYW4kOCIsImZtdGluZ19saXQkMCIsInN0cCQwIiwicyQyIiwic3RyX3Jlc3QkMCIsImFyZ19yZXN0Iiwia3NjYW5mX2dlbiIsImVmIiwiYXJncyQxIiwiZXhjJDAiLCJleGMiLCJhcmdzJDAiLCJrc2NhbmYiLCJrc2NhbmZfb3B0IiwiYnNjYW5mIiwiYnNjYW5mX29wdCIsImtzc2NhbmYiLCJzc2NhbmYiLCJzc2NhbmZfb3B0Iiwic2NhbmYiLCJzY2FuZl9vcHQiLCJic2NhbmZfZm9ybWF0IiwiZm9ybWF0Iiwic3NjYW5mX2Zvcm1hdCIsImZvcm1hdF9mcm9tX3N0cmluZyIsInVuZXNjYXBlZCIsInJlZ2lzdGVyIiwicmVnaXN0ZXJfZXhjZXB0aW9uIiwibyQwIiwiaW5pdGlhbF9vYmplY3Rfc2l6ZSIsImR1bW15X2l0ZW0iLCJwdWJsaWNfbWV0aG9kX2xhYmVsIiwidGFnIiwiY29tcGFyZSQwIiwiY29tcGFyZSQxIiwiZHVtbXlfdGFibGUiLCJ0YWJsZV9jb3VudCIsImR1bW15X21ldCIsImZpdF9zaXplIiwibmV3X3RhYmxlIiwicHViX2xhYmVscyIsIm1ldGhvZHMiLCJhcnJheSIsIm5ld19zaXplIiwib2xkX3NpemUiLCJuZXdfYnVjayIsIm1ldGhvZF9jb3VudCIsImluc3RfdmFyX2NvdW50IiwibmV3X21ldGhvZCIsInRhYmxlIiwiZ2V0X21ldGhvZF9sYWJlbCIsImxhYmVsIiwiZ2V0X21ldGhvZF9sYWJlbHMiLCJuYW1lcyIsInNldF9tZXRob2QiLCJlbGVtZW50IiwiZ2V0X21ldGhvZCIsIm5hcnJvdyIsInZhcnMiLCJ2aXJ0X21ldGhzIiwiY29uY3JfbWV0aHMiLCJ2YXJzJDAiLCJ2aXJ0X21ldGhzJDAiLCJjb25jcl9tZXRocyQwIiwidmlydF9tZXRoX2xhYnMiLCJjb25jcl9tZXRoX2xhYnMiLCJsYWIiLCJ0dmFycyIsImJ5X25hbWUiLCJieV9sYWJlbCIsIm1ldCIsImhtIiwid2lkZW4iLCJzYXZlZF92YXJzIiwic2F2ZWRfaGlkZGVuX21ldGhzIiwibmV3X3ZhcmlhYmxlIiwidG9fYXJyYXkiLCJuZXdfbWV0aG9kc192YXJpYWJsZXMiLCJtZXRocyIsInZhbHMiLCJtZXRocyQwIiwibm1ldGhzIiwibnZhbHMiLCJnZXRfdmFyaWFibGUiLCJnZXRfdmFyaWFibGVzIiwiYWRkX2luaXRpYWxpemVyIiwiY3JlYXRlX3RhYmxlIiwicHVibGljX21ldGhvZHMiLCJ0YWdzIiwiaW5pdF9jbGFzcyIsImluaGVyaXRzIiwiY2xhIiwic3VwZXIkMCIsIm5tIiwibWFrZV9jbGFzcyIsInB1Yl9tZXRocyIsImNsYXNzX2luaXQiLCJlbnZfaW5pdCIsIm1ha2VfY2xhc3Nfc3RvcmUiLCJpbml0X3RhYmxlIiwiZHVtbXlfY2xhc3MiLCJsb2MiLCJ1bmRlZiIsImNyZWF0ZV9vYmplY3QiLCJjcmVhdGVfb2JqZWN0X29wdCIsIm9ial8wIiwiaXRlcl9mIiwicnVuX2luaXRpYWxpemVycyIsImluaXRzIiwicnVuX2luaXRpYWxpemVyc19vcHQiLCJjcmVhdGVfb2JqZWN0X2FuZF9ydW5faW5pdGlhbGkiLCJnZXRfZGF0YSIsImJ1aWxkX3BhdGgiLCJrZXlzIiwibG9va3VwX3RhYmxlcyIsInJvb3QiLCJyb290X2RhdGEiLCJ0YWJsZXMkMCIsInRhYmxlcyQxIiwidGFibGVzX2RhdGEiLCJuZXdfY2FjaGUiLCJzZXRfbWV0aG9kcyIsImNsbyIsImNsbyQwIiwibiQyIiwibiQzIiwibiQ0IiwibiQ1IiwibiQ2IiwieCQzIiwibiQ3IiwieCQ0IiwibiQ4IiwibiQ5IiwieCQ1IiwiZiQ4IiwiZSQyIiwibiQxMCIsIngkNiIsImYkOSIsIm4kMTEiLCJ4JDciLCJuJDEyIiwieCQ4IiwibiQxMyIsIm4kMTQiLCJlJDMiLCJuJDE1IiwibSQxIiwibSQyIiwieCQ5IiwibSQzIiwibiQxNiIsIm0kNCIsImUkNCIsIm4kMTciLCJtJDUiLCJuJDE4IiwiaW5pdF9tb2RfYmxvY2siLCJjb21wcyQwIiwibW9kdSIsInNoYXBlIiwiZm4kMCIsImNvbXBzIiwiaW5pdF9tb2QiLCJ1cGRhdGVfbW9kX2Jsb2NrIiwiY2wiLCJ1cGRhdGVfbW9kIiwicHJuZyIsImhrZXkiLCJjbGVhbiIsImRvX2J1Y2tldCIsImluc2VydF9idWNrZXQiLCJjb250YWluZXIiLCJyZW1vdmVfYnVja2V0IiwiaGsiLCJidWNrZXRfbGVuZ3RoX2FsaXZlIiwic3RhdHNfYWxpdmUiLCJzZXRfZGF0YSIsImVwaCIsInF1ZXJ5Iiwic2V0X2tleV9kYXRhIiwidGVzdF9rZXkiLCJ0JDAiLCJnZXRfa2V5MSIsInNldF9rZXkxIiwiZ2V0X2tleTIiLCJzZXRfa2V5MiIsImdldF9kYXRhJDAiLCJzZXRfZGF0YSQwIiwibWFrZSQxIiwia2V5MSIsImtleTIiLCJxdWVyeSQwIiwiazIkMCIsImsxJDAiLCJlcXVhbCQwIiwic2VlZGVkX2hhc2gkMCIsIm1ha2UkMiIsImFkZCQwIiwidGVzdF9rZXlzIiwicmVtb3ZlJDAiLCJmaW5kJDAiLCJsZW5ndGgkMCIsImNsZWFyJDAiLCJsZW5ndGgkMSIsImdldF9rZXkkMCIsInNldF9rZXkkMCIsImdldF9kYXRhJDEiLCJzZXRfZGF0YSQxIiwibWFrZSQzIiwicXVlcnkkMSIsIm1ha2UkNCIsImFkZCQxIiwidGVzdF9rZXlzJDAiLCJyZW1vdmUkMSIsImZpbmQkMSIsImxlbmd0aCQyIiwiY2xlYXIkMSIsIm51bGwkMCIsImN1cnJlbnRfZGlyX25hbWUiLCJwYXJlbnRfZGlyX25hbWUiLCJkaXJfc2VwIiwicXVvdGVxdW90ZSIsIm51bGwkMSIsImN1cnJlbnRfZGlyX25hbWUkMCIsInBhcmVudF9kaXJfbmFtZSQwIiwiZGlyX3NlcCQwIiwibnVsbCQyIiwiY3VycmVudF9kaXJfbmFtZSQxIiwicGFyZW50X2Rpcl9uYW1lJDEiLCJkaXJfc2VwJDEiLCJnZW5lcmljX2Jhc2VuYW1lIiwiaXNfZGlyX3NlcCIsImdlbmVyaWNfZGlybmFtZSIsImlzX3JlbGF0aXZlIiwiaXNfaW1wbGljaXQiLCJjaGVja19zdWZmaXgiLCJzdWZmIiwiY2hvcF9zdWZmaXhfb3B0IiwibGVuX2YiLCJ0ZW1wX2Rpcl9uYW1lIiwicXVvdGUiLCJxdW90ZV9jb21tYW5kIiwiYmFzZW5hbWUiLCJkaXJuYW1lIiwiaXNfZGlyX3NlcCQwIiwiaXNfcmVsYXRpdmUkMCIsImlzX2ltcGxpY2l0JDAiLCJjaGVja19zdWZmaXgkMCIsImNob3Bfc3VmZml4X29wdCQwIiwidGVtcF9kaXJfbmFtZSQwIiwicXVvdGUkMCIsImFkZF9icyIsImxvb3AkMCIsImxvb3BfYnMiLCJxdW90ZV9jbWRfZmlsZW5hbWUiLCJxdW90ZV9jb21tYW5kJDAiLCJkcml2ZV9hbmRfcGF0aCIsImRpcm5hbWUkMCIsInBhdGgiLCJkcml2ZSIsImRpciIsImJhc2VuYW1lJDAiLCJiYXNlbmFtZSQxIiwiZGlybmFtZSQxIiwibnVsbCQzIiwiY3VycmVudF9kaXJfbmFtZSQyIiwicGFyZW50X2Rpcl9uYW1lJDIiLCJkaXJfc2VwJDIiLCJpc19kaXJfc2VwJDEiLCJpc19yZWxhdGl2ZSQxIiwiaXNfaW1wbGljaXQkMSIsImNoZWNrX3N1ZmZpeCQxIiwiY2hvcF9zdWZmaXhfb3B0JDEiLCJ0ZW1wX2Rpcl9uYW1lJDEiLCJxdW90ZSQxIiwicXVvdGVfY29tbWFuZCQxIiwiYmFzZW5hbWUkMiIsImRpcm5hbWUkMiIsImNob3Bfc3VmZml4IiwiZXh0ZW5zaW9uX2xlbiIsImkwIiwiZXh0ZW5zaW9uIiwiY2hvcF9leHRlbnNpb24iLCJyZW1vdmVfZXh0ZW5zaW9uIiwidGVtcF9maWxlX25hbWUiLCJ0ZW1wX2RpciIsInJhbmRvbV9zdGF0ZSIsInJuZCIsImN1cnJlbnRfdGVtcF9kaXJfbmFtZSIsInNldF90ZW1wX2Rpcl9uYW1lIiwiZ2V0X3RlbXBfZGlyX25hbWUiLCJ0ZW1wX2ZpbGUiLCJvcGVuX3RlbXBfZmlsZSIsInN0aCQwIiwicGVybXMiLCJzdGgkMSIsIm5lZyIsImNvbmoiLCJtdWwiLCJkaXYiLCJpbnYiLCJub3JtMiIsIm5vcm0iLCJwb2xhciIsInNxcnQiLCJxJDAiLCJ3JDAiLCJleHAiLCJsb2ciLCJwb3ciLCJvcGVuX2JpbiIsIm9wZW5fdGV4dCIsIm9wZW5fZ2VuIiwid2l0aF9vcGVuIiwib3BlbmZ1biIsIndpdGhfb3Blbl9iaW4iLCJ3aXRoX29wZW5fdGV4dCIsIndpdGhfb3Blbl9nZW4iLCJzZWVrIiwiY2xvc2UiLCJjbG9zZV9ub2VyciIsImlucHV0X2NoYXIiLCJpbnB1dF9ieXRlIiwicmVhZF91cHRvIiwiZW5zdXJlIiwibmV3X2xlbiQwIiwibmV3X2xlbiQxIiwiaW5wdXRfYWxsIiwiY2h1bmtfc2l6ZSIsImluaXRpYWxfc2l6ZSQwIiwiaW5pdGlhbF9zaXplJDEiLCJucmVhZCIsImJ1ZiQyIiwiYnVmJDAiLCJidWYkMSIsInJlbSIsInNldF9iaW5hcnlfbW9kZSIsIm91dHB1dF9jaGFyIiwib3V0cHV0X2J5dGUiLCJwcmludGVyIiwiY29udGludWUkMCIsImRpc2NvbnRpbnVlIiwiZGlzY29udGludWVfd2l0aF9iYWNrdHJhY2UiLCJtYXRjaF93aXRoIiwiY29tcCIsImhhbmRsZXIiLCJlZmZjIiwiZWZmIiwibGFzdF9maWJlciIsInRyeV93aXRoIiwiZmliZXIiLCJjb250aW51ZV9nZW4iLCJyZXN1bWVfZnVuIiwiY29udGludWVfd2l0aCIsImRpc2NvbnRpbnVlX3dpdGgiLCJkaXNjb250aW51ZV93aXRoX2JhY2t0cmFjZSQwIiwibmFtZXIiLCJlcSIsIm4iLCJuYW1lcyIsImUiLCJlJDAiLCJjIiwiZCIsInRvX3N0cmluZyIsImNvbXBhcmUiLCJsZXEiLCJnZXEiLCJlcSQwIiwidG9fc3RyaW5nJDAiLCJzIiwiY29tcGFyZSQwIiwiZXEkMSIsImkiLCJqIiwidG9fc3RyaW5nJDEiLCJjb21wYXJlJDEiLCJsZXEkMCIsImdlcSQwIiwiZXEkMiIsImNvbXBhcmUkMiIsInRvX3N0cmluZyQyIiwiYiIsImEiLCJiJDAiLCJhJDAiLCJjJDAiLCJjb21wIiwiY29tcCQwIiwidSIsInYiLCJ4IiwiZW1wdHkiLCJvZl9saXN0IiwibCIsImFkZCIsIm1lbSIsIml0ZXIiLCJmIiwieSIsInUkMCIsInYkMCIsInYkMSIsInUkMSIsImFwcCIsInBhaXIiLCJ1bnBhaXIiLCJtb2R1bG8iLCJhbnMiLCJpbmRleCIsInAiLCJsJDAiLCJyZXBsYWNlX250aCIsIm4kMCIsImsiLCJyZXBsYWNlX2Fzc29jIiwiayQwIiwic3ViIiwib2ZzIiwibGVuIiwib2ZzJDAiLCJsJDEiLCJvZnMkMSIsInN1YnNjcmlwdCIsInN1cGVyc2NyaXB0IiwiZmluZCQwIiwic3BsaXRfb25fcHJlZGljYXRlIiwieCQwIiwieSQwIiwiemVybyIsIm5lZyIsIm11bCIsIm9uZSIsImFkZCQwIiwiemVybyQwIiwibmVnJDAiLCJtdWwkMCIsImFkZCQxIiwiemVybyQxIiwibmVnJDEiLCJtdWwkMSIsImxlbmd0aCIsImRlZ3JlZSIsInEiLCJkcCIsImRxIiwiY29tcGFjdCIsImNvZWZmIiwiaW5pdCIsInAkMCIsInEkMCIsInBsIiwicWwiLCJjbXVsIiwibW9ub21pYWwiLCJpbnYiLCJpbnYkMCIsImludiQxIiwiZ2NkIiwiYiQxIiwiY2Fub25pemUiLCJkJDAiLCJkaXYiLCJkYiIsInIiLCJkciIsInQiLCJzaW1wbGVfcG93IiwiaXNfY29tbXV0YXRpdmUiLCJwb3ciLCJpbmoiLCJvIiwidWwiLCJ2bCIsInBlcSIsInVvZmYiLCJ2b2ZmIiwiYmluZCIsImluY2x1ZGVkIiwidW5pZmllciIsIm9wdCIsInN0aCIsImkkMCIsImFucyQwIiwib3JkZXJlZF91bmlmaWVycyIsIm9yZGVyZWRfdW5pZmllcnNfYmljb250ZXh0IiwibHUiLCJsdiIsInVuaWZpZXJzX2JpY29udGV4dCIsImxleGljb2dyYXBoaWMiLCJkZWdsZXgiLCJzaW5nbGV0b24iLCJzaW5nbGV0b25zIiwiaGQiLCJ0bCIsImQkMSIsImMkMSIsImNtcCIsImV4dGVuZCIsImNjIiwibDEiLCJsMiIsInciLCJmJDAiLCJldmFsJDAiLCJsZW5ndGgkMCIsIm1ha2UiLCJnZW5lcmF0b3JzIiwicnVsZXMiLCJwcmVzIiwib3JpZW50Iiwibm9ybWFsaXplIiwidjEiLCJ2MiIsImFkZF9ydWxlIiwicmVkdWNlIiwiaCIsInJ1bGVzJDAiLCJjb21wbGV0ZSIsInByZXMkMCIsInRvZG8iLCJwcmVzJDEiLCJ1MiIsInUxIiwiczEiLCJzMiIsIm5mIiwiaW50c2V0IiwiYXV4IiwidW5pb24iLCJkb21haW4iLCJvY2N1cnJlbmNlcyIsIm0iLCJ1JDIiLCJ2JDIiLCJyb3dzIiwiY29scyIsImdldCIsImlzX3plcm8iLCJyZXBsYWNlIiwibWkiLCJleGNoYW5nZSIsIm11bHQiLCJtYWRkIiwicm93X2VjaGVsb24iLCJtJDAiLCJpcCIsImNvbHMkMCIsInJhbmsiLCJudWxsaXR5IiwiZmluZCIsIm9mX2FycmF5IiwibWF0cml4Iiwic2V0IiwiaiQwIiwicmFuayQwIiwibnVsbGl0eSQwIiwiaXRlcl9zcmMiLCJpdGVyX3RndCIsIml0ZXIkMCIsIm1hcCIsIm1hcCQwIiwibG1hcCIsInIkMCIsIm0kMSIsImNpbmoiLCJhZGRfbW9ub21pYWwiLCJnZW4iLCJkaW0iLCJwcmVzZW50YXRpb25fdG9fc3RyaW5nIiwiYXBwJDAiLCJzcmMiLCJ0Z3QiLCJvZl9tYXAiLCJ0b19tYXAiLCJpdGVyJDEiLCJtb2R1bGVzIiwibWFwcyIsIm1ha2UkMCIsInZhbGlkIiwiYmV0dGkiLCJrZXIiLCJpbSIsIm11bF9tb25vbWlhbCIsImxlYWRpbmciLCJmcmVlIiwicCQxIiwiYWRkX3JlbGF0aW9uIiwicHAiLCJoZWFkcyIsImxvb3AiLCJ2MSQwIiwidjIkMCIsImJ1Y2hiZXJnZXIiLCJ1MSQwIiwidTIkMCIsInMkMCIsImFjYyIsInJ1bGVzJDIiLCJydWxlcyQxIiwiZXBzIiwiZXBzJDAiLCJncmFkZWQiLCJtb25vaWQiLCJub3JtYWxpemUkMCIsImNpbmokMCIsImNtdWwkMCIsImN1IiwiY2hhaW5zIiwibGVmdCIsInJlc29sdXRpb25fY2giLCJhdWdtZW50YXRpb24iLCJkZWJ1ZyIsImF1Z21lbnRhdGlvbiQwIiwiYXVnbWVudGF0aW9uJDEiLCJjaCIsImN1JDAiLCJjbiIsImNubCIsImNudSIsImNudWwiLCJhbnMkMSIsImFucyQyIiwiYW5zJDMiLCJhbnMkNCIsImFucyQ1IiwicCQyIiwicCQzIiwiY2MkMCIsInJlc29sdXRpb24iLCJjb21wbGV4IiwiaWQiLCJicmFpZCIsInJlbGF0aW9ucyIsInJlbGF0aW9ucyQwIiwic3ltbWV0cmljIiwiZXh0ZXJpb3IiLCJuYW1lIiwid2VpZ2h0IiwiYXJpdHkiLCJmMSIsImYyIiwiZnJlc2giLCJuYW1lcl9uYXR1cmFsIiwidmFyJDAiLCJwYXJzZXIiLCJ0ZXJtIiwiYSQxIiwic3RlcCIsInZhcnMiLCJwYXJzZV92YXIiLCJwYXJzZSIsIm9wcyIsInQxIiwidDIiLCJhMSIsImEyIiwic3RyaW5nX29mX3Rlcm0iLCJpc192YXIiLCJnZXRfdmFyIiwidmFycyQwIiwib2NjdXJzIiwiZ3QiLCJnZV9vcCIsImciLCJnZSIsImwxJDAiLCJsMiQwIiwieDIiLCJsMSQxIiwieDEiLCJsMiQxIiwicmVuYW1lIiwic2ltcGxlIiwicyQxIiwiY29tcG9zZSIsImlzX3JlbmFtaW5nIiwiaXNfaW5qZWN0aXZlX3JlbmFtaW5nIiwiaW5fZG9tIiwicmVzdHJpY3QiLCJ0b19zdHJpbmckMyIsInZhciQxIiwiaXNfY29tbXV0YXRpdmUkMCIsInRvX3N0cmluZyQ0IiwidmFyJDIiLCJwb3ckMCIsImludGVycHJldGF0aW9uIiwib3AiLCJ1bmlmeSIsInMkMyIsInEkNCIsInQkMCIsInEkMyIsInMkMiIsInEkMiIsInEkMSIsIm1hdGNoZXMiLCJlcXVpdmFsZW50IiwibGlzdF9yZW1vdmVfbnRoIiwib2Zfc3RyaW5nIiwibmFtZSQwIiwic291cmNlIiwidGFyZ2V0IiwidmFycyQxIiwiYXJpdHkkMCIsImFyZ3MiLCJ6IiwiYXJnc19zdWJzdCIsInRvX3N0cmluZyQ1IiwiZXEkNSIsInIxIiwicjIiLCJvcGVyYXRpb25zIiwicnMiLCJmaWx0ZXIiLCJtYWtlJDEiLCJlbXB0eSQwIiwidG9fc3RyaW5nJDYiLCJvZl90ZXJtIiwidGFwcCIsInJhcHAiLCJ2ciIsInZzIiwic3Vic3QiLCJzdCIsInNvdXJjZSQwIiwidGFyZ2V0JDAiLCJsYWJlbCIsImExJDAiLCJhMiQwIiwiYSQyIiwidG9fc3RyaW5nJDciLCJydWxlIiwiaGFzX2NvbnRleHQiLCJlcSQ2IiwiaGFzX3J1bGUiLCJzdGVwcyIsImN0eCIsImN0eCQwIiwiZW1wdHkkMSIsInNvdXJjZSQxIiwidGFyZ2V0JDEiLCJhcHBlbmRfc3RlcCIsInRvX3N0cmluZyQ4IiwibGJsIiwiYXBwZW5kIiwidG9wbGV2ZWxfcnVsZXMiLCJlcSQ3IiwicnIiLCJudGhfc3RlcCIsIm50aF90ZXJtIiwiY3JpdGljYWxfcnVsZXMiLCJuMiIsInN0ZXAxIiwic3RlcDIiLCJjcml0aWNhbCIsInN5bSIsInMxJDAiLCJzMiQwIiwic3RlcHMkMCIsImtudXRoX2JlbmRpeCIsInN0aCQwIiwiY2FsbGJhY2siLCJycyQwIiwibmFtZXIkMCIsIm5hbWVyJDEiLCJxdWV1ZSIsImNwIiwicDEiLCJwMiIsInQyJDAiLCJ0MSQwIiwic3F1aWVyIiwidG9fc3RyaW5nJDkiLCJwYSIsInNvdXJjZSQzIiwidGFyZ2V0JDMiLCJzb3VyY2UkMiIsInRhcmdldCQyIiwic3RlcCQwIiwiYXBwZW5kJDAiLCJjb25jYXQiLCJlcSQ4IiwicCQ0IiwicCQ1IiwicCQ2Iiwib2ZfcGF0aCIsIm1hcCQxIiwidG0iLCJzdWJzdCQwIiwicnVsZV9vY2N1cmVuY2VzIiwicnVsZV9hbGdlYnJhaWNfb2NjdXJlbmNlcyIsImlzX2lkIiwiaXNfaW52IiwiaGFzX3J1bGUkMCIsInAkMTEiLCJwJDEwIiwicCQ3IiwicCQ4IiwicyQ0IiwicCQ5IiwicyQ1IiwicyQ2IiwicCQxMiIsInAkMTMiLCJwJDE0IiwidmFsdWUiLCJwcmVmaXgiLCJwcmVmaXgkMSIsInJlcGxhY2VfcnVsZSIsInByIiwidG1fY3R4IiwicnNfY3R4IiwidG1fY3R4JDIiLCJ0bV9jdHgkMCIsInJzX2N0eCQyIiwicnNfY3R4JDAiLCJudGhfc3RlcCQwIiwibnRoX3Rlcm0kMCIsInRvX2xpc3QiLCJwYXJzZSQwIiwidW5pZCIsIm1ha2UkMiIsInRvX3N0cmluZyQxMCIsIm9mX2NlbGwiLCJjYW5vbml6ZSQwIiwidmFsdWUkMCIsInJlcGxhY2VfcnVsZSQwIiwibGVuZ3RoJDEiLCJyb3RhdGUiLCJuYW1lJDEiLCJtYWtlJDMiLCJ0b19zdHJpbmckMTEiLCJyb3RhdGUkMCIsInZhbHVlJDEiLCJyZXBsYWNlX3J1bGUkMSIsImNycyIsImNvaGVyZW5jZSIsInNldF9ydWxlcyIsInRvX3N0cmluZyQxMiIsImNvaGVyZW5jZSQwIiwidG9fdGV4IiwicHJpbnQiLCJwMSQxIiwicDIkMSIsInAyJDIiLCJwMSQyIiwicDIkMCIsInAxJDAiLCJjZCIsImkkMiIsImkkMSIsImkkMyIsInZpZXdfcGRmIiwib2MiLCJmbmFtZSIsImNtZCIsIm1ha2UkNCIsImZpbmRfcnVsZSIsImZpbmQkMSIsImFkZF9jb2hlcmVuY2UiLCJyb3RhdGUkMSIsImNuYW1lIiwiZWxpbV9ydWxlIiwiYWYiLCJhdyIsImF3bCIsIngkMSIsImF3JDAiLCJhaSIsImV4cG4iLCJoYWRhbWFyZCIsInN0YXIiLCJwb2x5bm9taWFsIiwicmF0aW9uYWwiLCJsaXN0IiwiY2VsbCIsIndoaXNrZXIiLCJjMiIsImMxIiwiYXV4JDAiLCJ3JDAiLCJ3JDEiLCJib3VuZGFyeSIsIm1lbSQwIiwiZGltJDAiLCJsYWJlbCQwIiwic3JjJDAiLCJ0Z3QkMCIsInZlcnRpY2VzIiwiZWRnZXMiLCJhZGRfdmVydGV4IiwiYWRkX2VkZ2UiLCJ2ZXJ0ZXhfcHJlZCIsInZlcnRleF9zdWNjIiwiZWRnZV9wcmVkIiwiZWRnZV9zdWNjIiwiZWRnZSIsImhhc192ZXJ0ZXgiLCJ2ZXJ0aWNlcyQwIiwiZWRnZXMkMCIsImFkZDAiLCJmcmVzaCQwIiwiYWRkX29iamVjdCIsImFkZF9tb3JwaGlzbSIsIm1vcnBoaXNtIiwiZ3JhcGgiLCJyZWxhdGlvbnMkMSIsImxldHRlciIsInVuaW9ucyIsInIkMSIsInIkMiIsInNpbXBsIiwiciQzIiwiciQ0IiwiciQ1Iiwic2ltcGwkMCIsInNlcmllcyIsInN0YXRlcyIsImF1dCIsInRyYW5zIiwiYWRkX3RyYW5zaXRpb24iLCJiYiIsImJiJDAiLCJ0cmFuc2l0aW9ucyIsImNyZWF0ZSIsImluaXRpYWwiLCJ0ZXJtaW5hbCIsInRlcm1pbmFsJDAiLCJrbGVlbmUiLCJqaiIsInJyJDAiLCJyciQyIiwic3MiLCJyciQxIiwidmVyc2lvbiIsImdpdF92ZXJzaW9uIiwicmFpc2UiLCJtYXgiLCJ4IiwieSIsIm1pbiIsImVxdWFsIiwiZXF1YWwkMCIsIm1heCQwIiwibWluJDAiLCJnbG9iYWwiLCJudWxsJDAiLCJ1bmRlZmluZWQkMCIsInJldHVybiQwIiwibWFwIiwiZiIsImJpbmQiLCJ0ZXN0IiwiaXRlciIsImNhc2UkMCIsImciLCJnZXQiLCJvcHRpb24iLCJ4JDAiLCJ0b19vcHRpb24iLCJyZXR1cm4kMSIsIm1hcCQwIiwiYmluZCQwIiwidGVzdCQwIiwiaXRlciQwIiwiY2FzZSQxIiwiZ2V0JDAiLCJvcHRpb24kMCIsInRvX29wdGlvbiQwIiwiY29lcmNlIiwiY29lcmNlX29wdCIsInRydWUkMCIsImZhbHNlJDAiLCJuZmMiLCJuZmQiLCJuZmtjIiwibmZrZCIsInN0cmluZ19jb25zdHIiLCJyZWdFeHAiLCJvYmplY3RfY29uc3RydWN0b3IiLCJvYmplY3Rfa2V5cyIsIm8iLCJhcnJheV9jb25zdHJ1Y3RvciIsImFycmF5X2dldCIsImFycmF5X3NldCIsImFycmF5X21hcCIsImEiLCJpZHgiLCJhcnJheV9tYXBpIiwic3RyX2FycmF5IiwibWF0Y2hfcmVzdWx0IiwiZGF0ZV9jb25zdHIiLCJtYXRoIiwiZXJyb3JfY29uc3RyIiwiZXhuX3dpdGhfanNfYmFja3RyYWNlIiwibmFtZSIsIm1lc3NhZ2UiLCJzdGFjayIsInRvX3N0cmluZyIsImUiLCJyYWlzZV9qc19lcnJvciIsInN0cmluZ19vZl9lcnJvciIsIkpTT04iLCJkZWNvZGVVUkkiLCJzIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZW5jb2RlVVJJIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZXNjYXBlIiwidW5lc2NhcGUiLCJpc05hTiIsImkiLCJwYXJzZUludCIsInMkMCIsInBhcnNlRmxvYXQiLCJleHBvcnRfanMiLCJmaWVsZCIsImV4cG9ydCQwIiwiZXhwb3J0X2FsbCIsIm9iaiIsImtleXMiLCJrZXkiLCJsaXN0X29mX25vZGVMaXN0IiwibGVuZ3RoIiwiYWNjIiwiaSQwIiwiYWNjJDAiLCJpJDEiLCJkaXNjb25uZWN0ZWQiLCJwcmVjZWRpbmciLCJmb2xsb3dpbmciLCJjb250YWlucyIsImNvbnRhaW5lZF9ieSIsImltcGxlbWVudGF0aW9uX3NwZWNpZmljIiwiaGFzIiwidCIsIm1hc2siLCJhZGQiLCJhcHBlbmRDaGlsZCIsInAiLCJuIiwicmVtb3ZlQ2hpbGQiLCJyZXBsYWNlQ2hpbGQiLCJpbnNlcnRCZWZvcmUiLCJub2RlVHlwZSIsInQxMyIsImNhc3QiLCJ0MTQiLCJlbGVtZW50IiwidGV4dCIsImF0dHIiLCJub19oYW5kbGVyIiwiaGFuZGxlciIsInJlcyIsImZ1bGxfaGFuZGxlciIsInRoaXMkMCIsImludm9rZV9oYW5kbGVyIiwiZXZlbnQiLCJldmVudFRhcmdldCIsIm1ha2UiLCJhZGRFdmVudExpc3RlbmVyV2l0aE9wdGlvbnMiLCJ0MjgiLCJ0eXAiLCJjYXB0dXJlIiwib25jZSIsInBhc3NpdmUiLCJoIiwiZXYiLCJjYWxsYmFjayIsImIiLCJhZGRFdmVudExpc3RlbmVyIiwiY2FwdCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJpZCIsInByZXZlbnREZWZhdWx0IiwiY3JlYXRlQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImRldGFpbCIsIm9wdF9pdGVyIiwiY29uc3RyIiwiYXJyYXlCdWZmZXIiLCJpbnQ4QXJyYXkiLCJ1aW50OEFycmF5IiwiaW50MTZBcnJheSIsInVpbnQxNkFycmF5IiwiaW50MzJBcnJheSIsInVpbnQzMkFycmF5IiwiZmxvYXQzMkFycmF5IiwiZmxvYXQ2NEFycmF5Iiwic2V0IiwidiIsInVuc2FmZV9nZXQiLCJkYXRhVmlldyIsIm9mX2FycmF5QnVmZmVyIiwiYWIiLCJ1aW50OCIsImJsb2JfY29uc3RyIiwiZmlsdGVyX21hcCIsInEiLCJ2JDAiLCJibG9iX3JhdyIsImNvbnRlbnRUeXBlIiwiZW5kaW5ncyIsIm9wdGlvbnMiLCJvcHRpb25zJDAiLCJibG9iX2Zyb21fc3RyaW5nIiwiYmxvYl9mcm9tX2FueSIsImwiLCJhJDAiLCJsJDAiLCJmaWxlbmFtZSIsIm5hbWUkMCIsImRvY19jb25zdHIiLCJkb2N1bWVudCIsImJsb2IiLCJzdHJpbmciLCJsb2Fkc3RhcnQiLCJwcm9ncmVzcyIsImFib3J0IiwiZXJyb3IiLCJsb2FkIiwibG9hZGVuZCIsImZpbGVSZWFkZXIiLCJvbklFIiwiY2xpY2siLCJjb3B5IiwiY3V0IiwicGFzdGUiLCJkYmxjbGljayIsIm1vdXNlZG93biIsIm1vdXNldXAiLCJtb3VzZW92ZXIiLCJtb3VzZW1vdmUiLCJtb3VzZW91dCIsImtleXByZXNzIiwia2V5ZG93biIsImtleXVwIiwibW91c2V3aGVlbCIsIndoZWVsIiwiRE9NTW91c2VTY3JvbGwiLCJ0b3VjaHN0YXJ0IiwidG91Y2htb3ZlIiwidG91Y2hlbmQiLCJ0b3VjaGNhbmNlbCIsImRyYWdzdGFydCIsImRyYWdlbmQiLCJkcmFnZW50ZXIiLCJkcmFnb3ZlciIsImRyYWdsZWF2ZSIsImRyYWciLCJkcm9wIiwiaGFzaGNoYW5nZSIsImNoYW5nZSIsImlucHV0IiwidGltZXVwZGF0ZSIsInN1Ym1pdCIsInNjcm9sbCIsImZvY3VzIiwiYmx1ciIsInVubG9hZCIsImJlZm9yZXVubG9hZCIsInJlc2l6ZSIsIm9yaWVudGF0aW9uY2hhbmdlIiwicG9wc3RhdGUiLCJzZWxlY3QiLCJvbmxpbmUiLCJvZmZsaW5lIiwiY2hlY2tpbmciLCJub3VwZGF0ZSIsImRvd25sb2FkaW5nIiwidXBkYXRlcmVhZHkiLCJjYWNoZWQiLCJvYnNvbGV0ZSIsImRvbUNvbnRlbnRMb2FkZWQiLCJhbmltYXRpb25zdGFydCIsImFuaW1hdGlvbmVuZCIsImFuaW1hdGlvbml0ZXJhdGlvbiIsImFuaW1hdGlvbmNhbmNlbCIsInRyYW5zaXRpb25ydW4iLCJ0cmFuc2l0aW9uc3RhcnQiLCJ0cmFuc2l0aW9uZW5kIiwidHJhbnNpdGlvbmNhbmNlbCIsImNhbnBsYXkiLCJjYW5wbGF5dGhyb3VnaCIsImR1cmF0aW9uY2hhbmdlIiwiZW1wdGllZCIsImVuZGVkIiwiZ290cG9pbnRlcmNhcHR1cmUiLCJsb2FkZWRkYXRhIiwibG9hZGVkbWV0YWRhdGEiLCJsb3N0cG9pbnRlcmNhcHR1cmUiLCJwYXVzZSIsInBsYXkiLCJwbGF5aW5nIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmNhbmNlbCIsInBvaW50ZXJkb3duIiwicG9pbnRlcmxlYXZlIiwicG9pbnRlcm1vdmUiLCJwb2ludGVyb3V0IiwicG9pbnRlcm92ZXIiLCJwb2ludGVydXAiLCJyYXRlY2hhbmdlIiwic2Vla2VkIiwic2Vla2luZyIsInN0YWxsZWQiLCJzdXNwZW5kIiwidm9sdW1lY2hhbmdlIiwid2FpdGluZyIsImQiLCJsb2NhdGlvbl9vcmlnaW4iLCJvcmlnaW4iLCJ3aW5kb3ciLCJnZXRFbGVtZW50QnlJZCIsInBub2RlIiwiZ2V0RWxlbWVudEJ5SWRfZXhuIiwiZ2V0RWxlbWVudEJ5SWRfb3B0IiwiZ2V0RWxlbWVudEJ5SWRfY29lcmNlIiwiY3JlYXRlRWxlbWVudCIsImRvYyIsInVuc2FmZUNyZWF0ZUVsZW1lbnQiLCJjcmVhdGVFbGVtZW50U3ludGF4IiwidW5zYWZlQ3JlYXRlRWxlbWVudEV4IiwidHlwZSIsImVsdCIsImNyZWF0ZUh0bWwiLCJjcmVhdGVIZWFkIiwiY3JlYXRlTGluayIsImNyZWF0ZVRpdGxlIiwiY3JlYXRlTWV0YSIsImNyZWF0ZUJhc2UiLCJjcmVhdGVTdHlsZSIsImNyZWF0ZUJvZHkiLCJjcmVhdGVGb3JtIiwiY3JlYXRlT3B0Z3JvdXAiLCJjcmVhdGVPcHRpb24iLCJjcmVhdGVTZWxlY3QiLCJjcmVhdGVJbnB1dCIsImNyZWF0ZVRleHRhcmVhIiwiY3JlYXRlQnV0dG9uIiwiY3JlYXRlTGFiZWwiLCJjcmVhdGVGaWVsZHNldCIsImNyZWF0ZUxlZ2VuZCIsImNyZWF0ZVVsIiwiY3JlYXRlT2wiLCJjcmVhdGVEbCIsImNyZWF0ZUxpIiwiY3JlYXRlRGl2IiwiY3JlYXRlRW1iZWQiLCJjcmVhdGVQIiwiY3JlYXRlSDEiLCJjcmVhdGVIMiIsImNyZWF0ZUgzIiwiY3JlYXRlSDQiLCJjcmVhdGVINSIsImNyZWF0ZUg2IiwiY3JlYXRlUSIsImNyZWF0ZUJsb2NrcXVvdGUiLCJjcmVhdGVQcmUiLCJjcmVhdGVCciIsImNyZWF0ZUhyIiwiY3JlYXRlSW5zIiwiY3JlYXRlRGVsIiwiY3JlYXRlQSIsImNyZWF0ZUltZyIsImNyZWF0ZU9iamVjdCIsImNyZWF0ZVBhcmFtIiwiY3JlYXRlTWFwIiwiY3JlYXRlQXJlYSIsImNyZWF0ZVNjcmlwdCIsImNyZWF0ZVRhYmxlIiwiY3JlYXRlQ2FwdGlvbiIsImNyZWF0ZUNvbCIsImNyZWF0ZUNvbGdyb3VwIiwiY3JlYXRlVGhlYWQiLCJjcmVhdGVUZm9vdCIsImNyZWF0ZVRib2R5IiwiY3JlYXRlVHIiLCJjcmVhdGVUaCIsImNyZWF0ZVRkIiwiY3JlYXRlU3ViIiwiY3JlYXRlU3VwIiwiY3JlYXRlU3BhbiIsImNyZWF0ZVR0IiwiY3JlYXRlSSIsImNyZWF0ZUIiLCJjcmVhdGVCaWciLCJjcmVhdGVTbWFsbCIsImNyZWF0ZUVtIiwiY3JlYXRlU3Ryb25nIiwiY3JlYXRlQ2l0ZSIsImNyZWF0ZURmbiIsImNyZWF0ZUNvZGUiLCJjcmVhdGVTYW1wIiwiY3JlYXRlS2JkIiwiY3JlYXRlVmFyIiwiY3JlYXRlQWJiciIsImNyZWF0ZURkIiwiY3JlYXRlRHQiLCJjcmVhdGVOb3NjcmlwdCIsImNyZWF0ZUFkZHJlc3MiLCJjcmVhdGVGcmFtZXNldCIsImNyZWF0ZUZyYW1lIiwiY3JlYXRlSWZyYW1lIiwiY3JlYXRlQXVkaW8iLCJjcmVhdGVWaWRlbyIsImNyZWF0ZUNhbnZhcyIsImh0bWxfZWxlbWVudCIsInQ1NCIsInVuc2FmZUNvZXJjZSIsInRhZyIsInQ1NSIsImFyZWEiLCJiYXNlIiwiYmxvY2txdW90ZSIsImJvZHkiLCJiciIsImJ1dHRvbiIsImNhbnZhcyIsImNhcHRpb24iLCJjb2wiLCJjb2xncm91cCIsImRlbCIsImRpdiIsImRsIiwiZmllbGRzZXQiLCJlbWJlZCIsImZvcm0iLCJmcmFtZXNldCIsImZyYW1lIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2IiwiaGVhZCIsImhyIiwiaHRtbCIsImlmcmFtZSIsImltZyIsImlucHV0JDAiLCJpbnMiLCJsYWJlbCIsImxlZ2VuZCIsImxpIiwibGluayIsIm1ldGEiLCJvYmplY3QiLCJvbCIsIm9wdGdyb3VwIiwicGFyYW0iLCJwcmUiLCJzY3JpcHQiLCJzZWxlY3QkMCIsInN0eWxlIiwidGFibGUiLCJ0Ym9keSIsInRkIiwidGV4dGFyZWEiLCJ0Zm9vdCIsInRoIiwidGhlYWQiLCJ0aXRsZSIsInRyIiwidWwiLCJhdWRpbyIsInZpZGVvIiwidW5zYWZlQ29lcmNlRXZlbnQiLCJtb3VzZUV2ZW50Iiwia2V5Ym9hcmRFdmVudCIsIndoZWVsRXZlbnQiLCJtb3VzZVNjcm9sbEV2ZW50IiwicG9wU3RhdGVFdmVudCIsIm1lc3NhZ2VFdmVudCIsImV2ZW50UmVsYXRlZFRhcmdldCIsImV2ZW50QWJzb2x1dGVQb3NpdGlvbiIsImV2ZW50QWJzb2x1dGVQb3NpdGlvbiQwIiwiZWxlbWVudENsaWVudFBvc2l0aW9uIiwiZ2V0RG9jdW1lbnRTY3JvbGwiLCJidXR0b25QcmVzc2VkIiwiYWRkTW91c2V3aGVlbEV2ZW50TGlzdGVuZXJXaXRoIiwiZHgiLCJkeSIsImFkZE1vdXNld2hlZWxFdmVudExpc3RlbmVyIiwidHJ5X2NvZGUiLCJ0cnlfa2V5X2NvZGVfbGVmdCIsInRyeV9rZXlfY29kZV9yaWdodCIsInRyeV9rZXlfY29kZV9udW1wYWQiLCJ0cnlfa2V5X2NvZGVfbm9ybWFsIiwibWFrZV91bmlkZW50aWZpZWQiLCJydW5fbmV4dCIsInZhbHVlIiwic3ltYm9sIiwib2ZfZXZlbnQiLCJjaGFyX29mX2ludCIsImVtcHR5X3N0cmluZyIsIm5vbmUiLCJvZl9ldmVudCQwIiwiZWxlbWVudCQwIiwidGFnZ2VkIiwidDEwNSIsIm9wdF90YWdnZWQiLCJ0YWdnZWRFdmVudCIsIm9wdF90YWdnZWRFdmVudCIsInN0b3BQcm9wYWdhdGlvbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImMiLCJyZXEiLCJub3ciLCJsYXN0IiwiZHQiLCJkdCQwIiwiaGFzUHVzaFN0YXRlIiwiaGFzUGxhY2Vob2xkZXIiLCJoYXNSZXF1aXJlZCIsIm92ZXJmbG93X2xpbWl0Iiwic2V0VGltZW91dCIsImxvb3AiLCJyZW1haW4iLCJzdGVwIiwiY2IiLCJjbGVhclRpbWVvdXQiLCJqc19hcnJheV9vZl9jb2xsZWN0aW9uIiwiZm9ybURhdGEiLCJmb3JtRGF0YV9mb3JtIiwiaGF2ZV9jb250ZW50IiwiZm9ybV9lbGVtZW50cyIsImkkMiIsInN0aCIsIm5hbWUkMSIsImxpc3QiLCJmaWxlIiwiYXBwZW5kIiwiZm9ybV9jb250ZW50cyIsImZvcm1fZWx0IiwiZW1wdHlfZm9ybV9jb250ZW50cyIsInBvc3RfZm9ybV9jb250ZW50cyIsImNvbnRlbnRzIiwiZ2V0X2Zvcm1fY29udGVudHMiLCJyZWFkeXN0YXRlY2hhbmdlIiwidGltZW91dCIsIndvcmtlciIsImNyZWF0ZSIsImltcG9ydF9zY3JpcHRzIiwic2NyaXB0cyIsInNldF9vbm1lc3NhZ2UiLCJqc19oYW5kbGVyIiwicG9zdF9tZXNzYWdlIiwibXNnIiwid2ViU29ja2V0IiwiaXNfc3VwcG9ydGVkIiwiZGVmYXVsdENvbnRleHRBdHRyaWJ1dGVzIiwid2ViZ2xjb250ZXh0bG9zdCIsIndlYmdsY29udGV4dHJlc3RvcmVkIiwid2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvciIsImdldENvbnRleHQiLCJjdHgiLCJnZXRDb250ZXh0V2l0aEF0dHJpYnV0ZXMiLCJhdHRyaWJzIiwicmVnZXhwIiwicmVnZXhwX2Nhc2VfZm9sZCIsInJlZ2V4cF93aXRoX2ZsYWciLCJibHVudF9zdHJfYXJyYXlfZ2V0Iiwic3RyaW5nX21hdGNoIiwic2VhcmNoIiwicmVzX3ByZSIsIm1hdGNoZWRfc3RyaW5nIiwiciIsIm1hdGNoZWRfZ3JvdXAiLCJxdW90ZV9yZXBsX3JlIiwicXVvdGVfcmVwbCIsImdsb2JhbF9yZXBsYWNlIiwic19ieSIsInJlcGxhY2VfZmlyc3QiLCJ0MjkiLCJmbGFncyIsImxpc3Rfb2ZfanNfYXJyYXkiLCJpZHgkMSIsImFjY3UiLCJpZHgkMCIsImFjY3UkMCIsInNwbGl0IiwiYm91bmRlZF9zcGxpdCIsInF1b3RlX3JlIiwicXVvdGUiLCJyZWdleHBfc3RyaW5nIiwicmVnZXhwX3N0cmluZ19jYXNlX2ZvbGQiLCJpbnRlcnJ1cHQiLCJwbHVzX3JlIiwidXJsZGVjb2RlX2pzX3N0cmluZ19zdHJpbmciLCJ1cmxkZWNvZGUiLCJ1cmxlbmNvZGUiLCJvcHQiLCJ3aXRoX3BsdXMiLCJkZWZhdWx0X2h0dHBfcG9ydCIsImRlZmF1bHRfaHR0cHNfcG9ydCIsInBhdGhfb2ZfcGF0aF9zdHJpbmciLCJhdXgiLCJqIiwid29yZCIsImVuY29kZV9hcmd1bWVudHMiLCJkZWNvZGVfYXJndW1lbnRzX2pzX3N0cmluZyIsImxlbiIsImluZGV4IiwiZGVjb2RlX2FyZ3VtZW50cyIsInVybF9yZSIsImZpbGVfcmUiLCJ1cmxfb2ZfanNfc3RyaW5nIiwiaGFuZGxlIiwicHJvdF9zdHJpbmciLCJzc2wiLCJwYXRoX3N0ciIsInVybCIsInVybF9vZl9zdHJpbmciLCJzdHJpbmdfb2ZfdXJsIiwiZnJhZyIsImFyZ3MiLCJwYXRoIiwicG9ydCIsImhvc3QiLCJmcmFnJDAiLCJhcmdzJDAiLCJwYXRoJDAiLCJwb3J0JDAiLCJob3N0JDAiLCJmcmFnJDEiLCJhcmdzJDEiLCJwYXRoJDEiLCJwcm90b2NvbCIsInBhdGhfc3RyaW5nIiwiYXJndW1lbnRzJDAiLCJnZXRfZnJhZ21lbnQiLCJyZXMkMCIsInNldF9mcmFnbWVudCIsInUiLCJhc19zdHJpbmciLCJ1cGRhdGVfZmlsZSIsImNvbnRlbnQiLCJvYyIsInNldF9jaGFubmVsX2ZsdXNoZXIiLCJvdXRfY2hhbm5lbCIsImYkMCIsInNldF9jaGFubmVsX2ZpbGxlciIsImluX2NoYW5uZWwiLCJtb3VudCIsInByZWZpeCIsInVubW91bnQiLCJqc19vZl9vY2FtbF92ZXJzaW9uIiwiZW1wdHlfcmVzaXplX29ic2VydmVyX29wdGlvbnMiLCJyZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJub2RlIiwiYm94Iiwib2JzIiwicGVyZm9ybWFuY2VPYnNlcnZlciIsImVudHJ5X3R5cGVzIiwiZW1wdHlfbXV0YXRpb25fb2JzZXJ2ZXJfaW5pdCIsIm11dGF0aW9uT2JzZXJ2ZXIiLCJjaGlsZF9saXN0IiwiYXR0cmlidXRlcyIsImNoYXJhY3Rlcl9kYXRhIiwic3VidHJlZSIsImF0dHJpYnV0ZV9vbGRfdmFsdWUiLCJjaGFyYWN0ZXJfZGF0YV9vbGRfdmFsdWUiLCJhdHRyaWJ1dGVfZmlsdGVyIiwiayIsInJlbW92ZSIsImZpbmQiLCJqc29uIiwicmV2aXZlciIsImlucHV0X3Jldml2ZXIiLCJ1bnNhZmVfaW5wdXQiLCJtbEludDY0X2NvbnN0ciIsIm91dHB1dF9yZXZpdmVyIiwib3V0cHV0Iiwic3RyaW5nX29mX25hbWUiLCJuYW1lX29mX3N0cmluZyIsInJnYl9vZl9uYW1lIiwicmdiIiwiaHNsIiwic3RyaW5nX29mX3QiLCJiJDAiLCJnJDAiLCJyJDAiLCJiJDEiLCJnJDEiLCJyJDEiLCJiJDIiLCJnJDIiLCJyJDIiLCJhJDEiLCJoJDAiLCJoZXhfb2ZfcmdiIiwiYmx1ZSIsImdyZWVuIiwicmVkIiwiaW5fcmFuZ2UiLCJqc190X29mX2pzX3N0cmluZyIsInJnYl9yZSIsInJnYl9wY3RfcmUiLCJyZ2JhX3JlIiwicmdiYV9wY3RfcmUiLCJoc2xfcmUiLCJoc2xhX3JlIiwianMiLCJjbiIsIm1sIiwiZmFpbCIsInJlX3JnYiIsInJlX3JnYl9wY3QiLCJyZV9oc2wiLCJpX29mX3NfbyIsImZfb2ZfcyIsImFscGhhIiwicmVkJDAiLCJncmVlbiQwIiwiYmx1ZSQwIiwiYWxwaGEkMCIsInJlZCQxIiwiZ3JlZW4kMSIsImJsdWUkMSIsImFscGhhJDEiLCJzdHJpbmdfb2ZfdCQwIiwiZiQxIiwiZiQyIiwiZiQzIiwiZiQ0IiwiZiQ1IiwiZiQ2IiwiZiQ3IiwiZiQ4IiwiZiQ5IiwiZiQxMCIsImYkMTEiLCJmJDEyIiwianMkMCIsIm1sJDAiLCJyZSIsInN0cmluZ19vZl90JDEiLCJqcyQxIiwibWwkMSIsImxpc3RlbiIsInRhcmdldCIsInN0b3BfbGlzdGVuIiwieG1sbnMiLCJjcmVhdGVBbHRHbHlwaCIsImNyZWF0ZUFsdEdseXBoRGVmIiwiY3JlYXRlQWx0R2x5cGhJdGVtIiwiY3JlYXRlQW5pbWF0ZSIsImNyZWF0ZUFuaW1hdGVDb2xvciIsImNyZWF0ZUFuaW1hdGVNb3Rpb24iLCJjcmVhdGVBbmltYXRlVHJhbnNmb3JtIiwiY3JlYXRlQ2lyY2xlIiwiY3JlYXRlQ2xpcFBhdGgiLCJjcmVhdGVDdXJzb3IiLCJjcmVhdGVEZWZzIiwiY3JlYXRlRGVzYyIsImNyZWF0ZUVsbGlwc2UiLCJjcmVhdGVGaWx0ZXIiLCJjcmVhdGVGb250IiwiY3JlYXRlRm9udEZhY2UiLCJjcmVhdGVGb250RmFjZUZvcm1hdCIsImNyZWF0ZUZvbnRGYWNlTmFtZSIsImNyZWF0ZUZvbnRGYWNlU3JjIiwiY3JlYXRlRm9udEZhY2VVcmkiLCJjcmVhdGVGb3JlaWduT2JqZWN0IiwiY3JlYXRlRyIsImNyZWF0ZUdseXBoIiwiY3JlYXRlR2x5cGhSZWYiLCJjcmVhdGVoa2VybiIsImNyZWF0ZUltYWdlIiwiY3JlYXRlTGluZUVsZW1lbnQiLCJjcmVhdGVMaW5lYXJFbGVtZW50IiwiY3JlYXRlTWFzayIsImNyZWF0ZU1ldGFEYXRhIiwiY3JlYXRlTWlzc2luZ0dseXBoIiwiY3JlYXRlTVBhdGgiLCJjcmVhdGVQYXRoIiwiY3JlYXRlUGF0dGVybiIsImNyZWF0ZVBvbHlnb24iLCJjcmVhdGVQb2x5bGluZSIsImNyZWF0ZVJhZGlhbGdyYWRpZW50IiwiY3JlYXRlUmVjdCIsImNyZWF0ZVNldCIsImNyZWF0ZVN0b3AiLCJjcmVhdGVTdmciLCJjcmVhdGVTd2l0Y2giLCJjcmVhdGVTeW1ib2wiLCJjcmVhdGVUZXh0RWxlbWVudCIsImNyZWF0ZVRleHRwYXRoIiwiY3JlYXRlVHJlZiIsImNyZWF0ZVRzcGFuIiwiY3JlYXRlVXNlIiwiY3JlYXRlVmlldyIsImNyZWF0ZXZrZXJuIiwic3ZnX2VsZW1lbnQiLCJ0OCIsImFsdEdseXBoIiwiYWx0R2x5cGhEZWYiLCJhbHRHbHlwaEl0ZW0iLCJhbmltYXRlIiwiYW5pbWF0ZUNvbG9yIiwiYW5pbWF0ZU1vdGlvbiIsImFuaW1hdGVUcmFuc2Zvcm0iLCJjaXJjbGUiLCJjbGlwUGF0aCIsImN1cnNvciIsImRlZnMiLCJkZXNjIiwiZWxsaXBzZSIsImZpbHRlciIsImZvbnQiLCJmb250RmFjZSIsImZvbnRGYWNlRm9ybWF0IiwiZm9udEZhY2VOYW1lIiwiZm9udEZhY2VTcmMiLCJmb250RmFjZVVyaSIsImZvcmVpZ25PYmplY3QiLCJnbHlwaCIsImdseXBoUmVmIiwiaGtlcm4iLCJpbWFnZSIsImxpbmVFbGVtZW50IiwibGluZWFyRWxlbWVudCIsIm1ldGFEYXRhIiwibWlzc2luZ0dseXBoIiwibVBhdGgiLCJwYXR0ZXJuIiwicG9seWdvbiIsInBvbHlsaW5lIiwicmFkaWFsZ3JhZGllbnQiLCJyZWN0Iiwic3RvcCIsInN2ZyIsInN3aXRjaCQwIiwidGV4dEVsZW1lbnQiLCJ0ZXh0cGF0aCIsInRyZWYiLCJ0c3BhbiIsInVzZSIsInZpZXciLCJ2a2VybiIsIndpdGhDcmVkZW50aWFscyIsImV2ZW50U291cmNlIiwiZXZlbnRTb3VyY2Vfb3B0aW9ucyIsImNvbnNvbGUiLCJlbXB0eV9wb3NpdGlvbl9vcHRpb25zIiwiZ2VvbG9jYXRpb24iLCJlbXB0eV9pbnRlcnNlY3Rpb25fb2JzZXJ2ZXJfb3AiLCJpbnRlcnNlY3Rpb25PYnNlcnZlcl91bnNhZmUiLCJvYmplY3Rfb3B0aW9ucyIsIm9wdGlvbnMkMSIsIm9wdGlvbnMkMiIsImludGwiLCJjb2xsYXRvcl9jb25zdHIiLCJkYXRlVGltZUZvcm1hdF9jb25zdHIiLCJudW1iZXJGb3JtYXRfY29uc3RyIiwicGx1cmFsUnVsZXNfY29uc3RyIiwic3ltcyIsInl5bGhzIiwieXlsZW4iLCJ5eWRlZnJlZCIsInl5ZGdvdG8iLCJ5eXNpbmRleCIsInl5cmluZGV4IiwieXlnaW5kZXgiLCJ5eXRhYmxlIiwieXljaGVjayIsInl5bmFtZXNfY29uc3QiLCJ5eW5hbWVzX2Jsb2NrIiwidmFycyIsImFwcCIsImYkMCIsImFyZ3MiLCJnIiwiZiIsInl5dHJhbnNsX2NvbnN0IiwieXl0cmFuc2xfYmxvY2siLCJ5eXRhYmxlc2l6ZSIsImNhbWxfcGFyc2VyX2VudiIsIl8xIiwiXzMiLCJfMiIsInl5YWN0IiwieXl0YWJsZXMiLCJtYWluIiwibGV4ZnVuIiwibGV4YnVmIiwib2NhbWxfbGV4X3RhYmxlcyIsInRva2VuJDAiLCJsZXhidWYiLCJvY2FtbF9sZXhfdG9rZW5fcmVjJDAiLCJvY2FtbF9sZXhfc3RhdGUiLCJvY2FtbF9sZXhfc3RhdGUkMCIsIm9jYW1sX2xleF9zdGF0ZSQxIiwicyIsInRva2VuIiwib2NhbWxfbGV4X3Rva2VuX3JlYyIsImRvYyIsImJ1dHRvbiIsInR4dCIsImFjdGlvbiIsImJ1dHRvbl90eXBlIiwiZGVidWciLCJzIiwianNnZXQiLCJ4IiwicGFyc2VfcnMiLCJzeW1zIiwicnVsZXMiLCJzJDAiLCJzJDEiLCJ3IiwibiIsImYiLCJzJDIiLCJycyIsInQiLCJycyQwIiwicmVwbGFjZSIsImMiLCJydW4iLCJzdGF0dXMkMCIsImVycm9yIiwic3ltcyQwIiwicnVsZXMkMCIsImRpc3BsYXkiLCJuYW1lciIsInNxIiwiczIiLCJzMSIsInMyJDAiLCJzMSQwIiwicnVsZV9uYW1lIiwiYW5zIiwidmFyJDAiLCJzcXMiLCJlJDAiLCJlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vK2ludDY0LmpzIiwiL2J1aWx0aW4vK21sQnl0ZXMuanMiLCIvYnVpbHRpbi8rZmFpbC5qcyIsIi9idWlsdGluLytzdGRsaWIuanMiLCIvYnVpbHRpbi8rc3lzLmpzIiwiL2J1aWx0aW4vK2JhY2t0cmFjZS5qcyIsIi9idWlsdGluLytqc2xpYi5qcyIsIi9idWlsdGluLytmb3JtYXQuanMiLCIvYnVpbHRpbi8raWVlZV83NTQuanMiLCIvYnVpbHRpbi8rZWZmZWN0LmpzIiwiL2J1aWx0aW4vK2ZzX25vZGUuanMiLCIvYnVpbHRpbi8rZnMuanMiLCIvYnVpbHRpbi8rdW5peC5qcyIsIi9idWlsdGluLytmc19mYWtlLmpzIiwiL2J1aWx0aW4vK25hdC5qcyIsIi9idWlsdGluLytncmFwaGljcy5qcyIsIi9idWlsdGluLytydW50aW1lX2V2ZW50cy5qcyIsIi9idWlsdGluLyttYXJzaGFsLmpzIiwiL2J1aWx0aW4vK2lvLmpzIiwiL2J1aWx0aW4vK2djLmpzIiwiL2J1aWx0aW4vK2JpZ2FycmF5LmpzIiwiL2J1aWx0aW4vK3BhcnNpbmcuanMiLCIvYnVpbHRpbi8raW50cy5qcyIsIi9idWlsdGluLytoYXNoLmpzIiwiL2J1aWx0aW4vK29iai5qcyIsIi9idWlsdGluLytjb21wYXJlLmpzIiwiL2J1aWx0aW4vK2pzbGliX2pzX29mX29jYW1sLmpzIiwiL2J1aWx0aW4vK2JpZ3N0cmluZy5qcyIsIi9idWlsdGluLyttZDUuanMiLCIvYnVpbHRpbi8rc3RyLmpzIiwiL2J1aWx0aW4vK2xleGluZy5qcyIsIi9idWlsdGluLythcnJheS5qcyIsIi9idWlsdGluLytkb21haW4uanMiLCIvYnVpbHRpbi8rc3luYy5qcyIsIi9idWlsdGluLyt3ZWFrLmpzIiwiL2J1aWx0aW4vK3BybmcuanMiLCIvYnVpbHRpbi8renN0ZC5qcyIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL2NhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL3N0ZGxpYi5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL2VpdGhlci5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL3N5cy5tbC5pbiIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL29iai5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL2F0b21pYy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL2NhbWxpbnRlcm5hbExhenkubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9vY2FtbC9sYXp5Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvc2VxLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvb3B0aW9uLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvcmVzdWx0Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvYm9vbC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL2NoYXIubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9vY2FtbC91Y2hhci5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL2xpc3QubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9vY2FtbC9pbnQubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9vY2FtbC9ieXRlcy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL3N0cmluZy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL3VuaXQubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9vY2FtbC9tYXJzaGFsLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvYXJyYXkubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9vY2FtbC9mbG9hdC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL2ludDMyLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvaW50NjQubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9vY2FtbC9uYXRpdmVpbnQubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9vY2FtbC9sZXhpbmcubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9vY2FtbC9wYXJzaW5nLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvc2V0Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvbWFwLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvc3RhY2subWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9vY2FtbC9xdWV1ZS5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL2J1ZmZlci5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL3NlbWFwaG9yZS5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL2RvbWFpbi5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL2NhbWxpbnRlcm5hbEZvcm1hdC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL3ByaW50Zi5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL2FyZy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL3ByaW50ZXhjLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvZnVuLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvZ2MubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9vY2FtbC9kaWdlc3QubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9vY2FtbC9iaWdhcnJheS5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL3JhbmRvbS5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL2hhc2h0YmwubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9vY2FtbC93ZWFrLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvZm9ybWF0Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvc2NhbmYubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9vY2FtbC9jYWxsYmFjay5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL2NhbWxpbnRlcm5hbE9PLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvY2FtbGludGVybmFsTW9kLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvZXBoZW1lcm9uLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvZmlsZW5hbWUubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9vY2FtbC9jb21wbGV4Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvaW5fY2hhbm5lbC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL291dF9jaGFubmVsLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvb2NhbWwvZWZmZWN0Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fYnVpbGQvZGVmYXVsdC9zcmMvdXRpbHMubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19idWlsZC9kZWZhdWx0L3NyYy9hbHBoYWJldC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvc3JjL2V4dGxpYi5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvc3JjL3JpbmcubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19idWlsZC9kZWZhdWx0L3NyYy9maWVsZC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvc3JjL21vbm9pZC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvc3JjL21hdHJpeC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvc3JjL21vZHVsZS5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvc3JjL2FsZ2VicmEubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19idWlsZC9kZWZhdWx0L3NyYy90ZXJtLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fYnVpbGQvZGVmYXVsdC9zcmMvc2ltcGxpY2lhbC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvc3JjL3Nlcmllcy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvc3JjL3ByZWNhdGVnb3J5Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fYnVpbGQvZGVmYXVsdC9zcmMvaHlwZXJncmFwaC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvc3JjL2dyYXBoLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fYnVpbGQvZGVmYXVsdC9zcmMvZ2xvYnVsYXIubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19idWlsZC9kZWZhdWx0L3NyYy9jYXRlZ29yeS5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvc3JjL2F1dG9tYXRvbi5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL2pzX29mX29jYW1sLWNvbXBpbGVyL3J1bnRpbWUvanNvb19ydW50aW1lX18ubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9qc19vZl9vY2FtbC1jb21waWxlci9ydW50aW1lL2pzb29fcnVudGltZS5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL2pzX29mX29jYW1sL2pzX29mX29jYW1sX18ubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9qc19vZl9vY2FtbC9pbXBvcnQubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9qc19vZl9vY2FtbC9qcy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL2pzX29mX29jYW1sL2RvbS5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL2pzX29mX29jYW1sL3R5cGVkX2FycmF5Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvanNfb2Zfb2NhbWwvZmlsZS5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL2pzX29mX29jYW1sL2RvbV9odG1sLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvanNfb2Zfb2NhbWwvZm9ybS5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL2pzX29mX29jYW1sL3htbEh0dHBSZXF1ZXN0Lm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvanNfb2Zfb2NhbWwvd29ya2VyLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvanNfb2Zfb2NhbWwvd2ViU29ja2V0cy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL2pzX29mX29jYW1sL3dlYkdMLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvanNfb2Zfb2NhbWwvcmVnZXhwLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvanNfb2Zfb2NhbWwvdXJsLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvanNfb2Zfb2NhbWwvc3lzX2pzLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvanNfb2Zfb2NhbWwvcmVzaXplT2JzZXJ2ZXIubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9qc19vZl9vY2FtbC9wZXJmb3JtYW5jZU9ic2VydmVyLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvanNfb2Zfb2NhbWwvbXV0YXRpb25PYnNlcnZlci5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL2pzX29mX29jYW1sL2pzdGFibGUubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9qc19vZl9vY2FtbC9qc29uLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvanNfb2Zfb2NhbWwvY1NTLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvanNfb2Zfb2NhbWwvZG9tX2V2ZW50cy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL2pzX29mX29jYW1sL2RvbV9zdmcubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9qc19vZl9vY2FtbC9ldmVudFNvdXJjZS5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL2pzX29mX29jYW1sL2ZpcmVidWcubWwiLCIvaG9tZS9ydW5uZXIvd29yay9vY2FtbC1hbGcvb2NhbWwtYWxnL19vcGFtL2xpYi9qc19vZl9vY2FtbC9nZW9sb2NhdGlvbi5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL2pzX29mX29jYW1sL2ludGVyc2VjdGlvbk9ic2VydmVyLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fb3BhbS9saWIvanNfb2Zfb2NhbWwvaW50bC5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvdG9vbHMva2IvcGFyc2VyUmVmcy5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvdG9vbHMva2IvcGFyc2VyLm1seSIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvdG9vbHMva2IvcGFyc2VyLm1sIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fYnVpbGQvZGVmYXVsdC90b29scy9rYi9sZXhlci5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX2J1aWxkL2RlZmF1bHQvdG9vbHMva2IvbGV4ZXIubWxsIiwiL2hvbWUvcnVubmVyL3dvcmsvb2NhbWwtYWxnL29jYW1sLWFsZy9fYnVpbGQvZGVmYXVsdC90b29scy9rYi9rYi5tbCIsIi9ob21lL3J1bm5lci93b3JrL29jYW1sLWFsZy9vY2FtbC1hbGcvX29wYW0vbGliL29jYW1sL3N0ZF9leGl0Lm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QSxDOztHOzs7UTtTOzs7RztJO0k7STtHO0U7Ozs7R0EwT0EsU0FBU0EsbUJBQW1CQyxHQUFLLFNBQVFBLFdBQVk7R0N6THJELFNBQVNDLGdCQUFnQkMsR0FBR0M7SUFDMUIsR0FBR0QsUUFBUTtJQUNYLEdBQUlDLFVBQVUsT0FBUUEsU0FBU0Q7SUFDL0IsSUFBSUUsUUFBUUM7SUFDWixPQUFRO0tBQ04sR0FBSUgsT0FBT0UsS0FBS0Q7S0FDaEJEO0tBQ0EsR0FBSUEsUUFBUSxPQUFPRTtLQUNuQkQsS0FBS0E7S0FDTEU7S0FDQSxHQUFJQSxRQUNGRjs7R0FLTjtHRDdDc0IsSUFBbEJHLG9CQUFvQkM7R0VBeEIsU0FBU0Msb0JBQXFCQyxLQUFPLE1BQU1BLElBQUs7R0M0SDNCLElBQWpCQztHRHJGSixTQUFTQztJQUNQSCxvQkFBb0JFO0dBQ3RCO0dGckNBLFNBQVNFLFFBQVNDLElBQUdDLElBQUdDO0lBQ3RCQyxVQUFVSDtJQUNWRyxVQUFVRjtJQUNWRSxVQUFVRDtHQUNaO0dBQ0FIO0dBQ0FBO2VBQ0UsV0FBV0EsUUFBUUksU0FBUUEsU0FBUUEsU0FEWjtHQUl6Qko7YUFBdUNaO0tBQ3JDLEdBQUlnQixVQUFVaEIsTUFBTTtLQUNwQixHQUFJZ0IsVUFBVWhCLE1BQU07S0FDcEIsR0FBSWdCLFVBQVVoQixN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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7OztHOzs7Ozs7Rzs7Ozs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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UUFFQUM7UUFFQUM7UUFFQUM7UUFFQXRKO09BT0ZDO09BRkFVO09BSUFFO09BbTVEQXNUO09BWUFHO09BNzVEQXRUO09BczREQWtUO09BbEJBSDtPQU1BQztPQU9BQztXQThjRWUsVUF2R0FMO1dBMEhBUztPQTcwQkY3SztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUdBQztPQUdBQztPQUdBQztPQUdBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQztPQUVBQzs7T0FJQUM7T0ErcUJBNkY7T0FvRUFDO09Bd0hBRTtPQVdBQztPQTBCQUM7T0FFQUM7O1FBMTRCRXRXO1FBa0JBOUQ7UUFFQXVVO1FBb0hBc0Q7UUFsSEFyRDtRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQU1BRztRQUpBRjtRQUVBQztRQUlBRTtRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBQztRQUVBOVk7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V0FBSkM7V0FBTEM7V0FBSEM7V0FBb0IsTUFBQSxnQ0FBcEJBLE1BQVFGO1VBQVksNkNBQWpCQyxNQUFTRjtTQUErQztPQUF6RkksWUFBWTtPQUNaQzs7O1VBRUY7V0FBU0w7V0FBSEM7V0FDQ2pCLElBQUksV0FKVG9CLGVBR0lILElBQUdEO1dBRUZNLFFBQU07V0FDNkYsTUFBQSxvQ0FEbkdBLFFBRkVOO1dBR3FFLE1BQUEsb0NBRHZFTSxRQUZETDtVQUZKSSxTQUtRLGtDQUxSQSxRQUdLckI7O1NBR047TUFMSCxpQ0FKRWU7TUFZa0IsSUFYbEJRLE1BRUVGLFFBU2dCLE1BQUEsd0JBWGxCRTs7TUE1QlRkO01BeUNLO01BQUE7O1dBUUFlO1VBQUFDLHdCQUFBRDtTQUFBQyxpQkFKQTtTQUlBQTtXQUhRbEMsSUFHUmtDO09BaERMZixNQThDVyxrQ0FERW5CO09BQ1I7O01BOUNMbUIsTUFpRFcsK0JBRE5lO01BQ0E7O0lBQ1M7SUEvQ2hCLFVBQUE7O0lBREY7R0FtRFE7R0FHZ0I7SUFBQSxNQUFBLHFDQWhFdEJqQjtJQWdFc0I7O3lCQXBHdEJ2QixLQUNBQyxRQU9BSSxPQUVBRSxPQUVBRSxVQWlCSVksU0FPSkU7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7Ozs7O0dDekJJO0dBQUE7OztFIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG52YXIgY2FtbF9pbnQ2NF9vZmZzZXQgPSBNYXRoLnBvdygyLCAtMjQpO1xuXG4vL1Byb3ZpZGVzOiBNbEludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldCwgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gTWxJbnQ2NCAobG8sbWksaGkpIHtcbiAgdGhpcy5sbyA9IGxvICYgMHhmZmZmZmY7XG4gIHRoaXMubWkgPSBtaSAmIDB4ZmZmZmZmO1xuICB0aGlzLmhpID0gaGkgJiAweGZmZmY7XG59XG5NbEludDY0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX2pcIlxuTWxJbnQ2NC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8sdGhpcy5taSx0aGlzLmhpKTtcbn1cblxuTWxJbnQ2NC5wcm90b3R5cGUudWNvbXBhcmUgPSBmdW5jdGlvbiAoeCkge1xuICBpZiAodGhpcy5oaSA+IHguaGkpIHJldHVybiAxO1xuICBpZiAodGhpcy5oaSA8IHguaGkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubWkgPiB4Lm1pKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubWkgPCB4Lm1pKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLmxvID4geC5sbykgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmxvIDwgeC5sbykgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgaGkgPSB0aGlzLmhpIDw8IDE2O1xuICB2YXIgeGhpID0geC5oaSA8PCAxNjtcbiAgaWYgKGhpID4geGhpKSByZXR1cm4gMTtcbiAgaWYgKGhpIDwgeGhpKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLm1pID4geC5taSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLm1pIDwgeC5taSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5sbyA+IHgubG8pIHJldHVybiAxO1xuICBpZiAodGhpcy5sbyA8IHgubG8pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsbyA9IC0gdGhpcy5sbztcbiAgdmFyIG1pID0gLSB0aGlzLm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gLSB0aGlzLmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyArIHgubG87XG4gIHZhciBtaSA9IHRoaXMubWkgKyB4Lm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gdGhpcy5oaSArIHguaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvIC0geC5sbztcbiAgdmFyIG1pID0gdGhpcy5taSAtIHgubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSB0aGlzLmhpIC0geC5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gKiB4LmxvO1xuICB2YXIgbWkgPSAoKGxvICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB0aGlzLm1pICogeC5sbyArIHRoaXMubG8gKiB4Lm1pO1xuICB2YXIgaGkgPSAoKG1pICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB0aGlzLmhpICogeC5sbyArIHRoaXMubWkgKiB4Lm1pICsgdGhpcy5sbyAqIHguaGk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLmxvfHRoaXMubWl8dGhpcy5oaSkgPT0gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMuaGkgPDwgMTYpIDwgMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvICYgeC5sbywgdGhpcy5taSAmIHgubWksIHRoaXMuaGkgJiB4LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG98eC5sbywgdGhpcy5taXx4Lm1pLCB0aGlzLmhpfHguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG9eeC5sbywgdGhpcy5taV54Lm1pLCB0aGlzLmhpXnguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfbGVmdCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICBpZiAocyA8IDI0KSB7XG4gICAgcmV0dXJuIG5ldyBNbEludDY0ICh0aGlzLmxvIDw8IHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5taSA8PCBzKSB8ICh0aGlzLmxvID4+ICgyNCAtIHMpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmhpIDw8IHMpIHwgKHRoaXMubWkgPj4gKDI0IC0gcykpKTtcbiAgfVxuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG8gPDwgKHMgLSAyNCksXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5taSA8PCAocyAtIDI0KSkgfCAodGhpcy5sbyA+PiAoNDggLSBzKSkpO1xuICByZXR1cm4gbmV3IE1sSW50NjQoMCwgMCwgdGhpcy5sbyA8PCAocyAtIDQ4KSlcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X3JpZ2h0X3Vuc2lnbmVkID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLmxvID4+IHMpIHwgKHRoaXMubWkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMubWkgPj4gcykgfCAodGhpcy5oaSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5oaSA+PiBzKSk7XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLm1pID4+IChzIC0gMjQpKSB8ICh0aGlzLmhpIDw8ICg0OCAtIHMpKSxcbiAgICAgICh0aGlzLmhpID4+IChzIC0gMjQpKSxcbiAgICAgIDApO1xuICByZXR1cm4gbmV3IE1sSW50NjQgKHRoaXMuaGkgPj4gKHMgLSA0OCksIDAsIDApO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfcmlnaHQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgdmFyIGggPSAodGhpcy5oaSA8PCAxNikgPj4gMTY7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLmxvID4+IHMpIHwgKHRoaXMubWkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMubWkgPj4gcykgfCAoaCA8PCAoMjQgLSBzKSksXG4gICAgICAoKHRoaXMuaGkgPDwgMTYpID4+IHMpID4+PiAxNik7XG4gIHZhciBzaWduID0gKHRoaXMuaGkgPDwgMTYpID4+IDMxO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5taSA+PiAocyAtIDI0KSkgfCAodGhpcy5oaSA8PCAoNDggLSBzKSksXG4gICAgICAodGhpcy5oaSA8PCAxNikgPj4gKHMgLSAyNCkgPj4gMTYsXG4gICAgICBzaWduICYgMHhmZmZmKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0ICgodGhpcy5oaSA8PCAxNikgPj4gKHMgLSAzMiksIHNpZ24sIHNpZ24pO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubHNsMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oaSA9ICh0aGlzLmhpIDw8IDEpIHwgKHRoaXMubWkgPj4gMjMpO1xuICB0aGlzLm1pID0gKCh0aGlzLm1pIDw8IDEpIHwgKHRoaXMubG8gPj4gMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLmxvID0gKHRoaXMubG8gPDwgMSkgJiAweGZmZmZmZjtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxzcjEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubG8gPSAoKHRoaXMubG8gPj4+IDEpIHwgKHRoaXMubWkgPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLm1pID0gKCh0aGlzLm1pID4+PiAxKSB8ICh0aGlzLmhpIDw8IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5oaSA9IHRoaXMuaGkgPj4+IDE7XG59XG5NbEludDY0LnByb3RvdHlwZS51ZGl2bW9kID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciBtb2R1bHVzID0gdGhpcy5jb3B5KCk7XG4gIHZhciBkaXZpc29yID0geC5jb3B5KCk7XG4gIHZhciBxdW90aWVudCA9IG5ldyBNbEludDY0KDAsMCwwKTtcbiAgd2hpbGUgKG1vZHVsdXMudWNvbXBhcmUoZGl2aXNvcikgPiAwKSB7XG4gICAgb2Zmc2V0Kys7XG4gICAgZGl2aXNvci5sc2wxKCk7XG4gIH1cbiAgd2hpbGUgKG9mZnNldCA+PSAwKSB7XG4gICAgb2Zmc2V0IC0tO1xuICAgIHF1b3RpZW50LmxzbDEoKTtcbiAgICBpZiAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+PSAwKSB7XG4gICAgICBxdW90aWVudC5sbyArKztcbiAgICAgIG1vZHVsdXMgPSBtb2R1bHVzLnN1YihkaXZpc29yKTtcbiAgICB9XG4gICAgZGl2aXNvci5sc3IxKCk7XG4gIH1cbiAgcmV0dXJuIHsgcXVvdGllbnQgOiBxdW90aWVudCwgbW9kdWx1cyA6IG1vZHVsdXMgfTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uICh5KVxue1xuICB2YXIgeCA9IHRoaXM7XG4gIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHguaGkgXiB5LmhpO1xuICBpZiAoeC5oaSAmIDB4ODAwMCkgeCA9IHgubmVnKCk7XG4gIGlmICh5LmhpICYgMHg4MDAwKSB5ID0geS5uZWcoKTtcbiAgdmFyIHEgPSB4LnVkaXZtb2QoeSkucXVvdGllbnQ7XG4gIGlmIChzaWduICYgMHg4MDAwKSBxID0gcS5uZWcoKTtcbiAgcmV0dXJuIHE7XG59XG5NbEludDY0LnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAoeSlcbntcbiAgdmFyIHggPSB0aGlzO1xuICBpZiAoeS5pc1plcm8oKSkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgdmFyIHNpZ24gPSB4LmhpO1xuICBpZiAoeC5oaSAmIDB4ODAwMCkgeCA9IHgubmVnKCk7XG4gIGlmICh5LmhpICYgMHg4MDAwKSB5ID0geS5uZWcoKTtcbiAgdmFyIHIgPSB4LnVkaXZtb2QoeSkubW9kdWx1cztcbiAgaWYgKHNpZ24gJiAweDgwMDApIHIgPSByLm5lZygpO1xuICByZXR1cm4gcjtcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sbyB8ICh0aGlzLm1pIDw8IDI0KTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvRmxvYXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoKHRoaXMuaGkgPDwgMTYpICogTWF0aC5wb3coMiwgMzIpICsgdGhpcy5taSAqIE1hdGgucG93KDIsIDI0KSkgKyB0aGlzLmxvO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFt0aGlzLmhpID4+IDgsXG4gICAgICAgICAgdGhpcy5oaSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5taSA+PiAxNixcbiAgICAgICAgICAodGhpcy5taSA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5taSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5sbyA+PiAxNixcbiAgICAgICAgICAodGhpcy5sbyA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5sbyAmIDB4ZmZdO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubG8zMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubG8gfCAoKHRoaXMubWkgJiAweGZmKSA8PCAyNCk7XG59XG5NbEludDY0LnByb3RvdHlwZS5oaTMyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKCh0aGlzLm1pID4+PiA4KSAmIDB4ZmZmZikgfCAodGhpcy5oaSA8PCAxNik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdWx0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3VsdCh4LHkpIHsgcmV0dXJuIHgudWNvbXBhcmUoeSkgPCAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jb21wYXJlKHgseSwgdG90YWwpIHsgcmV0dXJuIHguY29tcGFyZSh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbmVnIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X25lZyAoeCkgeyByZXR1cm4geC5uZWcoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYWRkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FkZCAoeCwgeSkgeyByZXR1cm4geC5hZGQoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3N1YiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zdWIgKHgsIHkpIHsgcmV0dXJuIHguc3ViKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tdWwgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2ludDY0X211bCh4LHkpIHsgcmV0dXJuIHgubXVsKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc196ZXJvIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX3plcm8oeCkgeyByZXR1cm4gK3guaXNaZXJvKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSB7IHJldHVybiAreC5pc05lZygpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYW5kIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FuZCAoeCwgeSkgeyByZXR1cm4geC5hbmQoeSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vciAoeCwgeSkgeyByZXR1cm4geC5vcih5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3hvciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF94b3IgKHgsIHkpIHsgcmV0dXJuIHgueG9yKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfbGVmdChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfcmlnaHRfdW5zaWduZWQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0ICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X3JpZ2h0KHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9kaXYgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZGl2ICh4LCB5KSB7IHJldHVybiB4LmRpdih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbW9kIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X21vZCAoeCwgeSkgeyByZXR1cm4geC5tb2QoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2ludDMyIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2ludDMyICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh4ICYgMHhmZmZmZmYsICh4ID4+IDI0KSAmIDB4ZmZmZmZmLCAoeCA+PiAzMSkgJiAweGZmZmYpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9faW50MzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9faW50MzIgKHgpIHsgcmV0dXJuIHgudG9JbnQoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fZmxvYXQgKHgpIHsgcmV0dXJuIHgudG9GbG9hdCAoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2Zsb2F0ICh4KSB7XG4gIGlmICh4IDwgMCkgeCA9IE1hdGguY2VpbCh4KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KFxuICAgIHggJiAweGZmZmZmZixcbiAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCkgJiAweGZmZmZmZixcbiAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZm9ybWF0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSwgY2FtbF9pbnQ2NF9uZWdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdG9faW50MzJcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zvcm1hdCAoZm10LCB4KSB7XG4gIHZhciBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgaWYgKGYuc2lnbmVkY29udiAmJiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpKSB7XG4gICAgZi5zaWduID0gLTE7IHggPSBjYW1sX2ludDY0X25lZyh4KTtcbiAgfVxuICB2YXIgYnVmZmVyID0gXCJcIjtcbiAgdmFyIHdiYXNlID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihmLmJhc2UpO1xuICB2YXIgY3Z0YmwgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgZG8ge1xuICAgIHZhciBwID0geC51ZGl2bW9kKHdiYXNlKTtcbiAgICB4ID0gcC5xdW90aWVudDtcbiAgICBidWZmZXIgPSBjdnRibC5jaGFyQXQoY2FtbF9pbnQ2NF90b19pbnQzMihwLm1vZHVsdXMpKSArIGJ1ZmZlcjtcbiAgfSB3aGlsZSAoISBjYW1sX2ludDY0X2lzX3plcm8oeCkpO1xuICBpZiAoZi5wcmVjID49IDApIHtcbiAgICBmLmZpbGxlciA9ICcgJztcbiAgICB2YXIgbiA9IGYucHJlYyAtIGJ1ZmZlci5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBidWZmZXIgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBidWZmZXI7XG4gIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgYnVmZmVyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSwgY2FtbF9mYWlsd2l0aCwgY2FtbF9wYXJzZV9kaWdpdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF91bHRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYWRkLCBjYW1sX2ludDY0X211bCwgY2FtbF9pbnQ2NF9uZWdcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCxjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX3N0cmluZyhzKSB7XG4gIHZhciByID0gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKTtcbiAgdmFyIGkgPSByWzBdLCBzaWduID0gclsxXSwgYmFzZSA9IHJbMl07XG4gIHZhciBiYXNlNjQgPSBjYW1sX2ludDY0X29mX2ludDMyKGJhc2UpO1xuICB2YXIgdGhyZXNob2xkID1cbiAgICAgIG5ldyBNbEludDY0KDB4ZmZmZmZmLCAweGZmZmZmZmYsIDB4ZmZmZikudWRpdm1vZChiYXNlNjQpLnF1b3RpZW50O1xuICB2YXIgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICBmb3IgKDs7KSB7XG4gICAgaSsrO1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gbXVsdGlwbGljYXRpb24gYmFzZSAqIHJlcyAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdCh0aHJlc2hvbGQsIHJlcykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAgIGQgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICAgIHJlcyA9IGNhbWxfaW50NjRfYWRkKGNhbWxfaW50NjRfbXVsKGJhc2U2NCwgcmVzKSwgZCk7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIGFkZGl0aW9uIChiYXNlICogcmVzKSArIGQgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQocmVzLCBkKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgaWYgKGJhc2UgPT0gMTAgJiYgY2FtbF9pbnQ2NF91bHQobmV3IE1sSW50NjQoMCwgMCwgMHg4MDAwKSwgcmVzKSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgaWYgKHNpZ24gPCAwKSByZXMgPSBjYW1sX2ludDY0X25lZyhyZXMpO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkobG8sIG1pLCBoaSl7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKVxufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGxvLCBoaSl7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgbG8gJiAweGZmZmZmZixcbiAgICAoKGxvID4+PiAyNCkgJiAweGZmKSB8ICgoaGkgJiAweGZmZmYpIDw8IDgpLFxuICAgIChoaSA+Pj4gMTYpICYgMHhmZmZmKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbG8zMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9sbzMyKHYpeyByZXR1cm4gdi5sbzMyKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2hpMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaGkzMih2KXsgcmV0dXJuIHYuaGkzMigpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9ieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChhWzddIDw8IDAgfCAoYVs2XSA8PCA4KSB8IChhWzVdIDw8IDE2KSxcbiAgICAgICAgICAgICAgICAgICAgIGFbNF0gPDwgMCB8IChhWzNdIDw8IDgpIHwgKGFbMl0gPDwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgYVsxXSA8PCAwIHwgKGFbMF0gPDwgOCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19ieXRlcyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19ieXRlcyh4KSB7IHJldHVybiB4LnRvQXJyYXkoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGFzaCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oYXNoKHYpe1xuICByZXR1cm4gKHYubG8zMigpKSBeICh2LmhpMzIoKSlcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMC0yMDE0IErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIEFuIE9DYW1sIHN0cmluZyBpcyBhbiBvYmplY3Qgd2l0aCB0aHJlZSBmaWVsZHM6XG4vLyAtIHRhZyAndCdcbi8vIC0gbGVuZ3RoICdsJ1xuLy8gLSBjb250ZW50cyAnYydcbi8vXG4vLyBUaGUgY29udGVudHMgb2YgdGhlIHN0cmluZyBjYW4gYmUgZWl0aGVyIGEgSmF2YVNjcmlwdCBhcnJheSBvclxuLy8gYSBKYXZhU2NyaXB0IHN0cmluZy4gVGhlIGxlbmd0aCBvZiB0aGlzIHN0cmluZyBjYW4gYmUgbGVzcyB0aGFuIHRoZVxuLy8gbGVuZ3RoIG9mIHRoZSBPQ2FtbCBzdHJpbmcuIEluIHRoaXMgY2FzZSwgcmVtYWluaW5nIGJ5dGVzIGFyZVxuLy8gYXNzdW1lZCB0byBiZSB6ZXJvZXMuIEFycmF5cyBhcmUgbXV0YWJsZSBidXQgY29uc3VtZXMgbW9yZSBtZW1vcnlcbi8vIHRoYW4gc3RyaW5ncy4gQSBjb21tb24gcGF0dGVybiBpcyB0byBzdGFydCBmcm9tIGFuIGVtcHR5IHN0cmluZyBhbmRcbi8vIHByb2dyZXNzaXZlbHkgZmlsbCBpdCBmcm9tIHRoZSBzdGFydC4gUGFydGlhbCBzdHJpbmdzIG1ha2VzIGl0XG4vLyBwb3NzaWJsZSB0byBpbXBsZW1lbnQgdGhpcyBlZmZpY2llbnRseS5cbi8vXG4vLyBXaGVuIGNvbnZlcnRpbmcgdG8gYW5kIGZyb20gVVRGLTE2LCB3ZSBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgdGhlXG4vLyBzdHJpbmcgaXMgY29tcG9zZWQgb25seSBvZiBBU0NJSSBjaGFyYWN0ZXJzIChpbiB3aGljaCBjYXNlLCBub1xuLy8gY29udmVyc2lvbiBuZWVkcyB0byBiZSBwZXJmb3JtZWQpIG9yIG5vdC5cbi8vXG4vLyBUaGUgc3RyaW5nIHRhZyBjYW4gdGh1cyB0YWtlIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuLy8gICBmdWxsIHN0cmluZyAgICAgQllURSB8IFVOS05PV046ICAgICAgMFxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IEFTQ0lJOiAgICAgICAgOVxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IE5PVF9BU0NJSTogICAgOFxuLy8gICBzdHJpbmcgcHJlZml4ICAgUEFSVElBTDogICAgICAgICAgICAgMlxuLy8gICBhcnJheSAgICAgICAgICAgQVJSQVk6ICAgICAgICAgICAgICAgNFxuLy9cbi8vIE9uZSBjYW4gdXNlIGJpdCBtYXNraW5nIHRvIGRpc2NyaW1pbmF0ZSB0aGVzZSBkaWZmZXJlbnQgY2FzZXM6XG4vLyAgIGtub3duX2VuY29kaW5nKHgpID0geCY4XG4vLyAgIGlzX2FzY2lpKHgpID0gICAgICAgeCYxXG4vLyAgIGtpbmQoeCkgPSAgICAgICAgICAgeCY2XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9zdHJfcmVwZWF0KG4sIHMpIHtcbiAgaWYobiA9PSAwKSByZXR1cm4gXCJcIjtcbiAgaWYgKHMucmVwZWF0KSB7cmV0dXJuIHMucmVwZWF0KG4pO30gLy8gRUNNQXNjcmlwdCA2IGFuZCBGaXJlZm94IDI0K1xuICB2YXIgciA9IFwiXCIsIGwgPSAwO1xuICBmb3IoOzspIHtcbiAgICBpZiAobiAmIDEpIHIgKz0gcztcbiAgICBuID4+PSAxO1xuICAgIGlmIChuID09IDApIHJldHVybiByO1xuICAgIHMgKz0gcztcbiAgICBsKys7XG4gICAgaWYgKGwgPT0gOSkge1xuICAgICAgcy5zbGljZSgwLDEpOyAvLyBmbGF0dGVuIHRoZSBzdHJpbmdcbiAgICAgIC8vIHRoZW4sIHRoZSBmbGF0dGVuaW5nIG9mIHRoZSB3aG9sZSBzdHJpbmcgd2lsbCBiZSBmYXN0ZXIsXG4gICAgICAvLyBhcyBpdCB3aWxsIGJlIGNvbXBvc2VkIG9mIGxhcmdlciBwaWVjZXNcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG4vL1dlYWtkZWZcbi8vIFByZSBFQ01BU2NyaXB0IDUsIFthcHBseV0gd291bGQgbm90IHN1cHBvcnQgYXJyYXktbGlrZSBvYmplY3QuXG4vLyBJbiBzdWNoIHNldHVwLCBUeXBlZF9hcnJheSB3b3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBwb2x5ZmlsbCwgYW5kIFtmLmFwcGx5XSB3b3VsZFxuLy8gZmFpbCBoZXJlLiBNYXJrIHRoZSBwcmltaXRpdmUgYXMgV2Vha2RlZiwgc28gdGhhdCBwZW9wbGUgY2FuIG92ZXJyaWRlIGl0IGVhc2lseS5cbmZ1bmN0aW9uIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyAoYSwgaSwgbGVuKSB7XG4gIHZhciBmID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgaWYgKGkgPT0gMCAmJiBsZW4gPD0gNDA5NiAmJiBsZW4gPT0gYS5sZW5ndGgpIHJldHVybiBmLmFwcGx5IChudWxsLCBhKTtcbiAgdmFyIHMgPSBcIlwiO1xuICBmb3IgKDsgMCA8IGxlbjsgaSArPSAxMDI0LGxlbi09MTAyNClcbiAgICBzICs9IGYuYXBwbHkgKG51bGwsIGEuc2xpY2UoaSxpICsgTWF0aC5taW4obGVuLCAxMDI0KSkpO1xuICByZXR1cm4gcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF91dGY4X29mX3V0ZjE2XG5mdW5jdGlvbiBjYW1sX3V0Zjhfb2ZfdXRmMTYocykge1xuICBmb3IgKHZhciBiID0gXCJcIiwgdCA9IGIsIGMsIGQsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyAoaiA8IGwpICYmIChjID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGMwIHwgKGMgPj4gNikpO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweGQ4MDAgfHwgYyA+PSAweGRmZmYpIHtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGUwIHwgKGMgPj4gMTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gNikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfSBlbHNlIGlmIChjID49IDB4ZGJmZiB8fCBpICsgMSA9PSBsIHx8XG4gICAgICAgICAgICAgICAoZCA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGQgPiAweGRmZmYpIHtcbiAgICAgIC8vIFVubWF0Y2hlZCBzdXJyb2dhdGUgcGFpciwgcmVwbGFjZWQgYnkgXFx1ZmZmZCAocmVwbGFjZW1lbnQgY2hhcmFjdGVyKVxuICAgICAgdCArPSBcIlxceGVmXFx4YmZcXHhiZFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgICBjID0gKGMgPDwgMTApICsgZCAtIDB4MzVmZGMwMDtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGYwIHwgKGMgPj4gMTgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gMTIpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGNhbWxfdXRmMTZfb2ZfdXRmOChzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gXCJcIiwgYywgYzEsIGMyLCB2LCBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYzEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMxIDwgMHg4MCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyAoaiA8IGwpICYmIChjMSA9IHMuY2hhckNvZGVBdChqKSkgPCAweDgwOyBqKyspO1xuICAgICAgaWYgKGogLSBpID4gNTEyKSB7IHQuc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiOyBiICs9IHMuc2xpY2UoaSwgaikgfVxuICAgICAgZWxzZSB0ICs9IHMuc2xpY2UoaSwgaik7XG4gICAgICBpZiAoaiA9PSBsKSBicmVhaztcbiAgICAgIGkgPSBqO1xuICAgIH1cbiAgICB2ID0gMTtcbiAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSkge1xuICAgICAgYyA9IGMyICsgKGMxIDw8IDYpO1xuICAgICAgaWYgKGMxIDwgMHhlMCkge1xuICAgICAgICB2ID0gYyAtIDB4MzA4MDtcbiAgICAgICAgaWYgKHYgPCAweDgwKSB2ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSAyO1xuICAgICAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSkge1xuICAgICAgICAgIGMgPSBjMiArIChjIDw8IDYpO1xuICAgICAgICAgIGlmIChjMSA8IDB4ZjApIHtcbiAgICAgICAgICAgIHYgPSBjIC0gMHhlMjA4MDtcbiAgICAgICAgICAgIGlmICgodiA8IDB4ODAwKSB8fCAoKHYgPj0gMHhkN2ZmKSAmJiAodiA8IDB4ZTAwMCkpKSB2ID0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdiA9IDM7XG4gICAgICAgICAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSAmJlxuICAgICAgICAgICAgICAgIChjMSA8IDB4ZjUpKSB7XG4gICAgICAgICAgICAgIHYgPSBjMiAtIDB4M2M4MjA4MCArIChjIDw8IDYpO1xuICAgICAgICAgICAgICBpZiAodiA8IDB4MTAwMDAgfHwgdiA+IDB4MTBmZmZmKSB2ID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHYgPCA0KSB7IC8vIEludmFsaWQgc2VxdWVuY2VcbiAgICAgIGkgLT0gdjtcbiAgICAgIHQgKz0gXCJcXHVmZmZkXCI7XG4gICAgfSBlbHNlIGlmICh2ID4gMHhmZmZmKVxuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDdjMCArICh2ID4+IDEwKSwgMHhkYzAwICsgKHYgJiAweDNGRikpXG4gICAgZWxzZVxuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHYpO1xuICAgIGlmICh0Lmxlbmd0aCA+IDEwMjQpIHt0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjt9XG4gIH1cbiAgcmV0dXJuIGIrdDtcbn1cblxuLy9Qcm92aWRlczoganNvb19pc19hc2NpaVxuZnVuY3Rpb24ganNvb19pc19hc2NpaSAocykge1xuICAvLyBUaGUgcmVndWxhciBleHByZXNzaW9uIGdldHMgYmV0dGVyIGF0IGFyb3VuZCB0aGlzIHBvaW50IGZvciBhbGwgYnJvd3NlcnNcbiAgaWYgKHMubGVuZ3RoIDwgMjQpIHtcbiAgICAvLyBTcGlkZXJtb25rZXkgZ2V0cyBtdWNoIHNsb3dlciB3aGVuIHMubGVuZ3RoID49IDI0IChvbiA2NCBiaXQgYXJjaHMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSBpZiAocy5jaGFyQ29kZUF0KGkpID4gMTI3KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZVxuICAgIHJldHVybiAhL1teXFx4MDAtXFx4N2ZdLy50ZXN0KHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHN3aXRjaCAocy50ICYgNikge1xuICBkZWZhdWx0OiAvKiBQQVJUSUFMICovXG4gICAgaWYgKGkgPj0gcy5jLmxlbmd0aCkgcmV0dXJuIDA7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICByZXR1cm4gcy5jLmNoYXJDb2RlQXQoaSk7XG4gIGNhc2UgNDogLyogQVJSQVkgKi9cbiAgICByZXR1cm4gcy5jW2ldXG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYykge1xuICAvLyBUaGUgT0NhbWwgY29tcGlsZXIgdXNlcyBDaGFyLnVuc2FmZV9jaHIgb24gaW50ZWdlcnMgbGFyZ2VyIHRoYW4gMjU1IVxuICBjICY9IDB4ZmY7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykge1xuICAgIGlmIChpID09IHMuYy5sZW5ndGgpIHtcbiAgICAgIHMuYyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgIGlmIChpICsgMSA9PSBzLmwpIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheSAocyk7XG4gIH1cbiAgcy5jW2ldID0gYztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSAxKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDMpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDMpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDIpLFxuICAgICAgYjQgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCB8IGIzIDw8IDE2IHwgYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSA3KSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQ2NChzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQgKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0IChzLCBpLCBjKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldCAocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDE2KHMsaSxpMTYpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAxKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMiA9IDB4RkYgJiBpMTYgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkxNjtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDE2KHMsaSxpMTYpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0MTZcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDE2XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQxNihzLGksaTE2KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQzMihzLGksaTMyKXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjQgPSAweEZGICYgaTMyID4+IDI0LFxuICAgICAgYjMgPSAweEZGICYgaTMyID4+IDE2LFxuICAgICAgYjIgPSAweEZGICYgaTMyID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMzI7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAyLCBiMyk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDMsIGI0KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQzMlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDMyKHMsaSxpMzIpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQzMihzLGksaTMyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gY2FtbF9pbnQ2NF90b19ieXRlcyhpNjQpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgNyAtIGosIGFbal0pO1xuICB9XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDY0KHMsaSxpNjQpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0NjRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDY0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQ2NChzLGksaTY0KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0IChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGY4X29mX3V0ZjE2LCBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nIChzKSB7XG4gIHZhciB0YWcgPSA5IC8qIEJZVEVTIHwgQVNDSUkgKi87XG4gIGlmICghanNvb19pc19hc2NpaShzKSlcbiAgICB0YWcgPSA4IC8qIEJZVEVTIHwgTk9UX0FTQ0lJICovLCBzID0gY2FtbF91dGY4X29mX3V0ZjE2KHMpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXModGFnLCBzLCBzLmxlbmd0aCk7XG59XG5cblxuLy9Qcm92aWRlczogTWxCeXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywganNvb19pc19hc2NpaSwgY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBNbEJ5dGVzICh0YWcsIGNvbnRlbnRzLCBsZW5ndGgpIHtcbiAgdGhpcy50PXRhZzsgdGhpcy5jPWNvbnRlbnRzOyB0aGlzLmw9bGVuZ3RoO1xufVxuTWxCeXRlcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICBzd2l0Y2ggKHRoaXMudCkge1xuICBjYXNlIDk6IC8qQllURVMgfCBBU0NJSSovXG4gICAgcmV0dXJuIHRoaXMuYztcbiAgZGVmYXVsdDpcbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHRoaXMpO1xuICBjYXNlIDA6IC8qQllURVMgfCBVTktPV04qL1xuICAgIGlmIChqc29vX2lzX2FzY2lpKHRoaXMuYykpIHtcbiAgICAgIHRoaXMudCA9IDk7IC8qQllURVMgfCBBU0NJSSovXG4gICAgICByZXR1cm4gdGhpcy5jO1xuICAgIH1cbiAgICB0aGlzLnQgPSA4OyAvKkJZVEVTIHwgTk9UX0FTQ0lJKi9cbiAgY2FzZSA4OiAvKkJZVEVTIHwgTk9UX0FTQ0lJKi9cbiAgICByZXR1cm4gdGhpcy5jO1xuICB9XG59O1xuTWxCeXRlcy5wcm90b3R5cGUudG9VdGYxNiA9IGZ1bmN0aW9uICgpe1xuICB2YXIgciA9IHRoaXMudG9TdHJpbmcoKTtcbiAgaWYodGhpcy50ID09IDkpIHJldHVybiByXG4gIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0Zjgocik7XG59XG5NbEJ5dGVzLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uICgpe1xuICB2YXIgY29udGVudCA9IHRoaXMudCA9PSA0ID8gdGhpcy5jLnNsaWNlKCkgOiB0aGlzLmM7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0aGlzLnQsY29udGVudCx0aGlzLmwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cl9yZXBlYXQsIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlc1xuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyAocykge1xuICAvKiBBc3N1bWVzIG5vdCBCWVRFUyAqL1xuICBpZiAocy50ID09IDIgLyogUEFSVElBTCAqLylcbiAgICBzLmMgKz0gY2FtbF9zdHJfcmVwZWF0KHMubCAtIHMuYy5sZW5ndGgsICdcXDAnKVxuICBlbHNlXG4gICAgcy5jID0gY2FtbF9zdWJhcnJheV90b19qc2J5dGVzIChzLmMsIDAsIHMuYy5sZW5ndGgpO1xuICBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkgKHMpIHtcbiAgLyogQXNzdW1lcyBub3QgQVJSQVkgKi9cbiAgdmFyIGEgPSBuZXcgVWludDhBcnJheShzLmwpO1xuICB2YXIgYiA9IHMuYywgbCA9IGIubGVuZ3RoLCBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIGFbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gIGZvciAobCA9IHMubDsgaSA8IGw7IGkrKykgYVtpXSA9IDA7XG4gIHMuYyA9IGE7XG4gIHMudCA9IDQ7IC8qIEFSUkFZICovXG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyAocykge1xuICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgcmV0dXJuIHMuYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nIChzKSB7XG4gIHZhciBsID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocyxpKTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9zdHJpbmcobGVuKSB7XG4gIGlmKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9jcmVhdGVfc3RyaW5nKGxlbikge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHJpbmcuY3JlYXRlXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9ieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcyxjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2J5dGVzKGxlbikge1xuICBpZiAobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQnl0ZXMuY3JlYXRlXCIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMobGVuPzI6OSxcIlwiLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2FycmF5IChhKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhhLDAsYS5sZW5ndGgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9hcnJheSAoYSkge1xuICBpZighIChhIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICBhID0gbmV3IFVpbnQ4QXJyYXkoYSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKDQsYSxhLmxlbmd0aCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfY29tcGFyZSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2NvbXBhcmUoczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8IHMyLmMpPy0xOihzMS5jID4gczIuYyk/MTowO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19lcXVhbChzMSwgczIpIHtcbiAgaWYoczEgPT09IHMyKSByZXR1cm4gMTtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jID09IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX25vdGVxdWFsKHMxLCBzMikgeyByZXR1cm4gMS1jYW1sX3N0cmluZ19lcXVhbChzMSwgczIpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19lcXVhbFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9ieXRlc19lcXVhbChzMSwgczIpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPD0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWxcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMixzMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzZXF1YWwoczIsczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ncmVhdGVydGhhblxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczIsIHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVydGhhblxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzdGhhblxuZnVuY3Rpb24gY2FtbF9ieXRlc19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczIsIHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWxsX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cl9yZXBlYXQsIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuLy9BbGlhczogY2FtbF9maWxsX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9maWxsX2J5dGVzKHMsIGksIGwsIGMpIHtcbiAgaWYgKGwgPiAwKSB7XG4gICAgaWYgKGkgPT0gMCAmJiAobCA+PSBzLmwgfHwgKHMudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgbCA+PSBzLmMubGVuZ3RoKSkpIHtcbiAgICAgIGlmIChjID09IDApIHtcbiAgICAgICAgcy5jID0gXCJcIjtcbiAgICAgICAgcy50ID0gMjsgLyogUEFSVElBTCAqL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcy5jID0gY2FtbF9zdHJfcmVwZWF0IChsLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgcy50ID0gKGwgPT0gcy5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICAgICAgZm9yIChsICs9IGk7IGkgPCBsOyBpKyspIHMuY1tpXSA9IGM7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcywgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JsaXRfYnl0ZXMoczEsIGkxLCBzMiwgaTIsIGxlbikge1xuICBpZiAobGVuID09IDApIHJldHVybiAwO1xuICBpZiAoKGkyID09IDApICYmXG4gICAgICAobGVuID49IHMyLmwgfHwgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGxlbiA+PSBzMi5jLmxlbmd0aCkpKSB7XG4gICAgczIuYyA9IChzMS50ID09IDQgLyogQVJSQVkgKi8pP1xuICAgICAgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKHMxLmMsIGkxLCBsZW4pOlxuICAgICAgKGkxID09IDAgJiYgczEuYy5sZW5ndGggPT0gbGVuKT9zMS5jOnMxLmMuc3Vic3RyKGkxLCBsZW4pO1xuICAgIHMyLnQgPSAoczIuYy5sZW5ndGggPT0gczIubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICB9IGVsc2UgaWYgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGkyID09IHMyLmMubGVuZ3RoKSB7XG4gICAgczIuYyArPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIHtcbiAgICBpZiAoczIudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkoczIpO1xuICAgIHZhciBjMSA9IHMxLmMsIGMyID0gczIuYztcbiAgICBpZiAoczEudCA9PSA0IC8qIEFSUkFZICovKSB7XG4gICAgICBpZiAoaTIgPD0gaTEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGwgPSBNYXRoLm1pbiAobGVuLCBjMS5sZW5ndGggLSBpMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykgYzIgW2kyICsgaV0gPSBjMS5jaGFyQ29kZUF0KGkxICsgaSk7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBjMiBbaTIgKyBpXSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2JsaXRfc3RyaW5nKGEsYixjLGQsZSkge1xuICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9zdHJpbmcoYSksYixjLGQsZSk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX21sX2J5dGVzX2xlbmd0aChzKSB7IHJldHVybiBzLmwgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgcmV0dXJuIHMuY2hhckNvZGVBdChpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ191bnNhZmVfc2V0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGggY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIHtcbiAgcmV0dXJuIHMubGVuZ3RoXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2NvbXBhcmUgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfY29tcGFyZShzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8IHMyKT8tMTooczEgPiBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19lcXVhbChzMSwgczIpIHtcbiAgaWYoczEgPT09IHMyKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiAoczEgPD0gczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc3RoYW4gY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIHJldHVybiAoczEgPCBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSB7XG4gIChzLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzLmMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHgpIHsgcmV0dXJuIHggfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNieXRlc19vZl9zdHJpbmcoeCkgeyByZXR1cm4geCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0ZjE2X29mX3V0Zjhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykge1xuICBpZihqc29vX2lzX2FzY2lpKHMpKVxuICAgIHJldHVybiBzO1xuICByZXR1cm4gY2FtbF91dGYxNl9vZl91dGY4KHMpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0Zjhfb2ZfdXRmMTYsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHMpIHtcbiAgaWYgKGpzb29faXNfYXNjaWkocykpXG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocylcbiAgZWxzZSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjYW1sX3V0Zjhfb2ZfdXRmMTYocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhzKSB7IHJldHVybiBuZXcgTWxCeXRlcygwLHMscy5sZW5ndGgpOyB9XG5cblxuLy8gVGhlIHNlY3Rpb24gYmVsb3cgc2hvdWxkIGJlIHVzZWQgd2hlbiB1c2UtanMtc3RyaW5nPWZhbHNlXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSkge1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYykge1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0KHMsaSxjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIHtcbiAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2NvbXBhcmVcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfY29tcGFyZVxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfY29tcGFyZShzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfY29tcGFyZShzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZXF1YWxcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19lcXVhbChzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzZXF1YWwoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSB7IHJldHVybiBzIH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpIHsgcmV0dXJuIHMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykgeyByZXR1cm4gY2FtbF9ieXRlc19vZl9qc2J5dGVzKHMpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNieXRlc19vZl9zdHJpbmcocykge1xuICAocy50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIHMuYyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocyl7XG4gIHJldHVybiBzLnRvVXRmMTYoKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZ1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmcocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfYnl0ZXMocykge1xuICByZXR1cm4gKHMgaW5zdGFuY2VvZiBNbEJ5dGVzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ieXRlc19jb250ZW50XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX2J5dGVzX2NvbnRlbnQocykge1xuICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICByZXR1cm4gcy5jO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHMuY1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfc3RyaW5nKHMpIHtcbiAgcmV0dXJuICh0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIiAmJiAhL1teXFx4MDAtXFx4ZmZdLy50ZXN0KHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfaXNfbWxfYnl0ZXMocyk7XG59XG5cbi8vIFRoZSBmdW5jdGlvbnMgYmVsb3cgYXJlIGRlcHJlY2F0ZWRcblxuLy9Qcm92aWRlczogY2FtbF9qc190b19ieXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9qc190b19ieXRlX3N0cmluZyhzKSB7IHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9uZXdfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX25ld19zdHJpbmcgKHMpIHsgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocylcbn1cblxuLy9Qcm92aWRlczogY2FtbF90b19qc19zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF90b19qc19zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc190b19zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX3RvX3N0cmluZyAocykge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocyk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2FycmF5X29mX3N0cmluZyh4KSB7IHJldHVybiBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZyh4KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfb2ZfYnl0ZXMoeCkgeyByZXR1cm4gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyh4KSB9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1JhaXNlIGV4Y2VwdGlvblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2NvbnN0YW50IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfY29uc3RhbnQgKHRhZykgeyB0aHJvdyB0YWc7IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX2FyZyAoY29uc3QsIG11dGFibGUpXG4vL1JlcXVpcmVzOiBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgYXJnKSB7IHRocm93IGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZShbMCwgdGFnLCBhcmddKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfYXJncyAoY29uc3QsIG11dGFibGUpXG4vL1JlcXVpcmVzOiBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9hcmdzICh0YWcsIGFyZ3MpIHsgdGhyb3cgY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlKFswLCB0YWddLmNvbmNhdChhcmdzKSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZyAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX2FyZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX3N0cmluZyAodGFnLCBtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX2FyZyAodGFnLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG1zZykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZhaWx3aXRoIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmFpbHdpdGggKG1zZykge1xuICBpZighY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlKVxuICAgIGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZT1bMjQ4LGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJGYWlsdXJlXCIpLC0zXTtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsIG1zZyk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfaW52YWxpZF9hcmd1bWVudCAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5JbnZhbGlkX2FyZ3VtZW50LCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkVuZF9vZl9maWxlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5EaXZpc2lvbl9ieV96ZXJvKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLk5vdF9mb3VuZCk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbF9nZW4gKGNvbnN0LCBzaGFsbG93KVxuLy9JZjogIWVmZmVjdHNcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF9jYWxsX2dlbihmLCBhcmdzKSB7XG4gIHZhciBuID0gKGYubCA+PSAwKT9mLmw6KGYubCA9IGYubGVuZ3RoKTtcbiAgdmFyIGFyZ3NMZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIGQgPSBuIC0gYXJnc0xlbjtcbiAgaWYgKGQgPT0gMClcbiAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTtcbiAgZWxzZSBpZiAoZCA8IDApIHtcbiAgICB2YXIgZyA9IGYuYXBwbHkobnVsbCxhcmdzLnNsaWNlKDAsbikpO1xuICAgIGlmKHR5cGVvZiBnICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBnO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGcsYXJncy5zbGljZShuKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgc3dpdGNoIChkKSB7XG4gICAgY2FzZSAxOiB7XG4gICAgICB2YXIgZyA9IGZ1bmN0aW9uICh4KXtcbiAgICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3NMZW4gKyAxKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3NMZW47IGkrKyApIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgICAgbmFyZ3NbYXJnc0xlbl0gPSB4O1xuICAgICAgICByZXR1cm4gZi5hcHBseShudWxsLCBuYXJncylcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAyOiB7XG4gICAgICB2YXIgZyA9IGZ1bmN0aW9uICh4LCB5KXtcbiAgICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3NMZW4gKyAyKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3NMZW47IGkrKyApIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgICAgbmFyZ3NbYXJnc0xlbl0gPSB4O1xuICAgICAgICBuYXJnc1thcmdzTGVuICsgMV0gPSB5O1xuICAgICAgICByZXR1cm4gZi5hcHBseShudWxsLCBuYXJncylcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdmFyIGcgPSBmdW5jdGlvbiAoKXtcbiAgICAgICAgdmFyIGV4dHJhX2FyZ3MgPSAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKT8xOmFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCtleHRyYV9hcmdzKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKysgKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSBuYXJnc1thcmdzLmxlbmd0aCtpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgbmFyZ3MpXG4gICAgICB9O1xuICAgIH19XG4gICAgZy5sID0gZDtcbiAgICByZXR1cm4gZztcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuIChjb25zdCwgc2hhbGxvdylcbi8vSWY6IGVmZmVjdHNcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF9jYWxsX2dlbihmLCBhcmdzKSB7XG4gIHZhciBuID0gKGYubCA+PSAwKT9mLmw6KGYubCA9IGYubGVuZ3RoKTtcbiAgdmFyIGFyZ3NMZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIGQgPSBuIC0gYXJnc0xlbjtcbiAgaWYgKGQgPT0gMCkge1xuICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9IGVsc2UgaWYgKGQgPCAwKSB7XG4gICAgdmFyIHJlc3QgPSBhcmdzLnNsaWNlKG4gLSAxKTtcbiAgICB2YXIgayA9IGFyZ3MgW2FyZ3NMZW4gLSAxXTtcbiAgICBhcmdzID0gYXJncy5zbGljZSgwLCBuKTtcbiAgICBhcmdzW24gLSAxXSA9IGZ1bmN0aW9uIChnKSB7XG4gICAgICBpZiAodHlwZW9mIGcgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGsoZyk7XG4gICAgICB2YXIgYXJncyA9IHJlc3Quc2xpY2UoKTtcbiAgICAgIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9IGs7XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihnLCBhcmdzKTsgfTtcbiAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzTGVuLS07XG4gICAgdmFyIGsgPSBhcmdzIFthcmdzTGVuXTtcbiAgICBzd2l0Y2ggKGQpIHtcbiAgICBjYXNlIDE6IHtcbiAgICAgIHZhciBnID0gZnVuY3Rpb24gKHgsIHkpe1xuICAgICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJnc0xlbiArIDIpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJnc0xlbjsgaSsrICkgbmFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgICBuYXJnc1thcmdzTGVuXSA9IHg7XG4gICAgICAgIG5hcmdzW2FyZ3NMZW4gKyAxXSA9IHk7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KG51bGwsIG5hcmdzKVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIDI6IHtcbiAgICAgIHZhciBnID0gZnVuY3Rpb24gKHgsIHksIHope1xuICAgICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJnc0xlbiArIDMpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJnc0xlbjsgaSsrICkgbmFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgICBuYXJnc1thcmdzTGVuXSA9IHg7XG4gICAgICAgIG5hcmdzW2FyZ3NMZW4gKyAxXSA9IHk7XG4gICAgICAgIG5hcmdzW2FyZ3NMZW4gKyAyXSA9IHo7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KG51bGwsIG5hcmdzKVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB2YXIgZyA9IGZ1bmN0aW9uICgpe1xuICAgICAgICB2YXIgZXh0cmFfYXJncyA9IChhcmd1bWVudHMubGVuZ3RoID09IDApPzE6YXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3NMZW4gKyBleHRyYV9hcmdzKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3NMZW47IGkrKyApIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApXG4gICAgICAgICAgbmFyZ3NbYXJnc0xlbiArIGldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBuYXJncylcbiAgICAgIH07XG4gICAgfX1cbiAgICBnLmwgPSBkICsgMTtcbiAgICByZXR1cm4gayhnKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlc1xudmFyIGNhbWxfbmFtZWRfdmFsdWVzID0ge307XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUgKGNvbnN0LG11dGFibGUpXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZShubSx2KSB7XG4gIGNhbWxfbmFtZWRfdmFsdWVzW2NhbWxfanNieXRlc19vZl9zdHJpbmcobm0pXSA9IHY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlc1xuZnVuY3Rpb24gY2FtbF9uYW1lZF92YWx1ZShubSkge1xuICByZXR1cm4gY2FtbF9uYW1lZF92YWx1ZXNbbm1dXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbnZhciBjYW1sX2dsb2JhbF9kYXRhID0gWzBdO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2J1aWxkX3N5bWJvbHNcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J1aWxkX3N5bWJvbHModG9jKSB7XG4gIHZhciBzeW1iO1xuICB3aGlsZSh0b2MpIHtcbiAgICBpZihjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh0b2NbMV1bMV0pID09IFwiU1lKU1wiKSB7XG4gICAgICBzeW1iID0gdG9jWzFdWzJdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGVsc2UgdG9jID0gdG9jWzJdXG4gIH1cbiAgdmFyIHIgPSB7fTtcbiAgaWYoc3ltYikge1xuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBzeW1iLmxlbmd0aDsgaSsrKXtcbiAgICAgIHJbY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoc3ltYltpXVsxXSldID0gc3ltYltpXVsyXVxuICAgIH1cbiAgfVxuICByZXR1cm4gcjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKGNvbnN0LCBzaGFsbG93LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfY2FsbGJhY2ssIGNhbWxfYnVpbGRfc3ltYm9sc1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKG4sIHYsIG5hbWVfb3B0KSB7XG4gIGlmIChuYW1lX29wdCkge1xuICAgIHZhciBuYW1lID0gbmFtZV9vcHQ7XG4gICAgaWYoZ2xvYmFsVGhpcy50b3BsZXZlbFJlbG9jKSB7XG4gICAgICBuID0gY2FtbF9jYWxsYmFjayhnbG9iYWxUaGlzLnRvcGxldmVsUmVsb2MsIFtuYW1lXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNhbWxfZ2xvYmFsX2RhdGEudG9jKSB7XG4gICAgICBpZighY2FtbF9nbG9iYWxfZGF0YS5zeW1ib2xzKSB7XG4gICAgICAgIGNhbWxfZ2xvYmFsX2RhdGEuc3ltYm9scyA9IGNhbWxfYnVpbGRfc3ltYm9scyhjYW1sX2dsb2JhbF9kYXRhLnRvYylcbiAgICAgIH1cbiAgICAgIHZhciBuaWQgPSBjYW1sX2dsb2JhbF9kYXRhLnN5bWJvbHNbbmFtZV1cbiAgICAgIGlmKG5pZCA+PSAwKVxuICAgICAgICBuID0gbmlkXG4gICAgICBlbHNlIHtcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImNhbWxfcmVnaXN0ZXJfZ2xvYmFsOiBjYW5ub3QgbG9jYXRlIFwiICsgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbWxfZ2xvYmFsX2RhdGFbbiArIDFdID0gdjtcbiAgaWYobmFtZV9vcHQpIGNhbWxfZ2xvYmFsX2RhdGFbbmFtZV9vcHRdID0gdjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfZ2xvYmFsX2RhdGEgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9nZXRfZ2xvYmFsX2RhdGEgKCkgeyByZXR1cm4gY2FtbF9nbG9iYWxfZGF0YTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX3ByaW50YWJsZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2lzX3ByaW50YWJsZShjKSB7IHJldHVybiArKGMgPiAzMSAmJiBjIDwgMTI3KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21heWJlX3ByaW50X3N0YXRzXG5mdW5jdGlvbiBjYW1sX21heWJlX3ByaW50X3N0YXRzKHVuaXQpIHsgcmV0dXJuIDAgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBTeXNcblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuU3lzX2Vycm9yLCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19leGl0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4aXQgKGNvZGUpIHtcbiAgaWYoZ2xvYmFsVGhpcy5xdWl0KSBnbG9iYWxUaGlzLnF1aXQoY29kZSk7XG4gIC8vbm9kZWpzXG4gIGlmKGdsb2JhbFRoaXMucHJvY2VzcyAmJiBnbG9iYWxUaGlzLnByb2Nlc3MuZXhpdClcbiAgICBnbG9iYWxUaGlzLnByb2Nlc3MuZXhpdChjb2RlKTtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiRnVuY3Rpb24gJ2V4aXQnIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvbihleG4pe1xuICBzd2l0Y2goZXhuWzJdKSB7XG4gIGNhc2UgLTg6IC8vIE1hdGNoX2ZhaWx1cmVcbiAgY2FzZSAtMTE6IC8vIEFzc2VydF9mYWlsdXJlXG4gIGNhc2UgLTEyOiAvLyBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZVxuICAgIHJldHVybiAxO1xuICBkZWZhdWx0OlxuICAgIHJldHVybiAwO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2V4Y2VwdGlvblxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9mb3JtYXRfZXhjZXB0aW9uKGV4bil7XG4gIHZhciByID0gXCJcIjtcbiAgaWYoZXhuWzBdID09IDApIHtcbiAgICByICs9IGV4blsxXVsxXTtcbiAgICBpZihleG4ubGVuZ3RoID09IDMgJiYgZXhuWzJdWzBdID09IDAgJiYgY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvbihleG5bMV0pKSB7XG5cbiAgICAgIHZhciBidWNrZXQgPSBleG5bMl07XG4gICAgICB2YXIgc3RhcnQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSAyXG4gICAgICB2YXIgYnVja2V0ID0gZXhuO1xuICAgIH1cbiAgICByICs9IFwiKFwiO1xuICAgIGZvcih2YXIgaSA9IHN0YXJ0OyBpIDwgYnVja2V0Lmxlbmd0aDsgaSArKyl7XG4gICAgICBpZihpID4gc3RhcnQpIHIrPVwiLCBcIjtcbiAgICAgIHZhciB2ID0gYnVja2V0W2ldXG4gICAgICBpZih0eXBlb2YgdiA9PSBcIm51bWJlclwiKVxuICAgICAgICByKz0gdi50b1N0cmluZygpO1xuICAgICAgZWxzZSBpZih2IGluc3RhbmNlb2YgTWxCeXRlcyl7XG4gICAgICAgIHIrPSAnXCInICsgdi50b1N0cmluZygpICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYodHlwZW9mIHYgPT0gXCJzdHJpbmdcIil7XG4gICAgICAgIHIrPSAnXCInICsgdi50b1N0cmluZygpICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIGVsc2UgciArPSBcIl9cIjtcbiAgICB9XG4gICAgciArPSBcIilcIlxuICB9IGVsc2UgaWYgKGV4blswXSA9PSAyNDgpe1xuICAgIHIgKz0gZXhuWzFdXG4gIH1cbiAgcmV0dXJuIHJcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb25cbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfZm9ybWF0X2V4Y2VwdGlvbiwgY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb24oZXJyKXtcbiAgaWYoZXJyIGluc3RhbmNlb2YgQXJyYXkgJiYgKGVyclswXSA9PSAwIHx8IGVyclswXSA9PSAyNDgpKSB7XG4gICAgdmFyIGhhbmRsZXIgPSBjYW1sX25hbWVkX3ZhbHVlKFwiUHJpbnRleGMuaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblwiKTtcbiAgICBpZihoYW5kbGVyKSBjYW1sX2NhbGxiYWNrKGhhbmRsZXIsIFtlcnIsZmFsc2VdKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBtc2cgPSBjYW1sX2Zvcm1hdF9leGNlcHRpb24oZXJyKTtcbiAgICAgIHZhciBhdF9leGl0ID0gY2FtbF9uYW1lZF92YWx1ZShcIlBlcnZhc2l2ZXMuZG9fYXRfZXhpdFwiKTtcbiAgICAgIGlmKGF0X2V4aXQpIGNhbWxfY2FsbGJhY2soYXRfZXhpdCwgWzBdKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uIFwiICsgbXNnICsgXCJcXG5cIik7XG4gICAgICBpZihlcnIuanNfZXJyb3IpIHRocm93IGVyci5qc19lcnJvcjtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZXRfc3RhdGljX2VudlxuZnVuY3Rpb24gY2FtbF9zZXRfc3RhdGljX2VudihrLHYpe1xuICBpZighZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnYpXG4gICAgZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnYgPSB7fVxuICBnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudltrXSA9IHY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX3N5c19nZXRlbnYgKGNvbnN0KVxuZnVuY3Rpb24ganNvb19zeXNfZ2V0ZW52KG4pIHtcbiAgdmFyIHByb2Nlc3MgPSBnbG9iYWxUaGlzLnByb2Nlc3M7XG4gIC8vbm9kZWpzIGVudlxuICBpZihwcm9jZXNzXG4gICAgICYmIHByb2Nlc3MuZW52XG4gICAgICYmIHByb2Nlc3MuZW52W25dICE9IHVuZGVmaW5lZClcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnZbbl07XG4gIGlmKGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52XG4gICAgICYmIGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52W25dKVxuICAgIHJldHVybiBnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudltuXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRlbnYgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19zeXNfZ2V0ZW52XG5mdW5jdGlvbiBjYW1sX3N5c19nZXRlbnYgKG5hbWUpIHtcbiAgdmFyIHIgPSBqc29vX3N5c19nZXRlbnYoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSkpO1xuICBpZihyID09PSB1bmRlZmluZWQpXG4gICAgY2FtbF9yYWlzZV9ub3RfZm91bmQgKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c191bnNhZmVfZ2V0ZW52XG4vL1JlcXVpcmVzOiBjYW1sX3N5c19nZXRlbnZcbmZ1bmN0aW9uIGNhbWxfc3lzX3Vuc2FmZV9nZXRlbnYobmFtZSl7XG4gIHJldHVybiBjYW1sX3N5c19nZXRlbnYgKG5hbWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG52YXIgY2FtbF9hcmd2ID0gKChmdW5jdGlvbiAoKSB7XG4gIHZhciBwcm9jZXNzID0gZ2xvYmFsVGhpcy5wcm9jZXNzO1xuICB2YXIgbWFpbiA9IFwiYS5vdXRcIjtcbiAgdmFyIGFyZ3MgPSBbXVxuXG4gIGlmKHByb2Nlc3NcbiAgICAgJiYgcHJvY2Vzcy5hcmd2XG4gICAgICYmIHByb2Nlc3MuYXJndi5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGFyZ3YgPSBwcm9jZXNzLmFyZ3ZcbiAgICAvL25vZGVqc1xuICAgIG1haW4gPSBhcmd2WzFdO1xuICAgIGFyZ3MgPSBhcmd2LnNsaWNlKDIpO1xuICB9XG5cbiAgdmFyIHAgPSBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhtYWluKTtcbiAgdmFyIGFyZ3MyID0gWzAsIHBdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKylcbiAgICBhcmdzMi5wdXNoKGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGFyZ3NbaV0pKTtcbiAgcmV0dXJuIGFyZ3MyO1xufSkoKSlcblxuLy9Qcm92aWRlczogY2FtbF9leGVjdXRhYmxlX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxudmFyIGNhbWxfZXhlY3V0YWJsZV9uYW1lID0gY2FtbF9hcmd2WzFdXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldF9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldF9hcmd2IChhKSB7XG4gIHJldHVybiBbMCwgY2FtbF9hcmd2WzFdLCBjYW1sX2FyZ3ZdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX2FyZ3YgKGEpIHtcbiAgcmV0dXJuIGNhbWxfYXJndjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfbW9kaWZ5X2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfbW9kaWZ5X2FyZ3YoYXJnKXtcbiAgY2FtbF9hcmd2ID0gYXJnO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxuZnVuY3Rpb24gY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lKGEpe1xuICByZXR1cm4gY2FtbF9leGVjdXRhYmxlX25hbWVcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZChjbWQpe1xuICB2YXIgY21kID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoY21kKTtcbiAgaWYgKHR5cGVvZiByZXF1aXJlICE9IFwidW5kZWZpbmVkXCIpe1xuICAgIHZhciBjaGlsZF9wcm9jZXNzID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpO1xuICAgIGlmKGNoaWxkX3Byb2Nlc3MgJiYgY2hpbGRfcHJvY2Vzcy5leGVjU3luYylcbiAgICAgIHRyeSB7XG4gICAgICAgIGNoaWxkX3Byb2Nlc3MuZXhlY1N5bmMoY21kLHtzdGRpbzogJ2luaGVyaXQnfSk7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9XG4gIH1cbiAgZWxzZSByZXR1cm4gMTI3O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kKGNtZCl7XG4gIHJldHVybiAxMjc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3RpbWUgbXV0YWJsZVxudmFyIGNhbWxfaW5pdGlhbF90aW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAqIDAuMDAxO1xuZnVuY3Rpb24gY2FtbF9zeXNfdGltZSAoKSB7XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICByZXR1cm4gbm93ICogMC4wMDEgLSBjYW1sX2luaXRpYWxfdGltZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuXG4vL1JlcXVpcmVzOiBjYW1sX3N5c190aW1lXG5mdW5jdGlvbiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW4oYikge1xuICByZXR1cm4gY2FtbF9zeXNfdGltZSgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yYW5kb21fc2VlZCBtdXRhYmxlXG4vL1RoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gYW4gYXJyYXkgc2luY2UgT0NhbWwgNC4wLi4uXG5mdW5jdGlvbiBjYW1sX3N5c19yYW5kb21fc2VlZCAoKSB7XG4gIGlmIChnbG9iYWxUaGlzLmNyeXB0bykge1xuICAgICBpZiAoZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgdmFyIGEgPSBnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IEludDMyQXJyYXkoNCkpO1xuICAgICAgIHJldHVybiBbMCwgYVswXSwgYVsxXSwgYVsyXSwgYVszXV07XG4gICAgIH0gZWxzZSBpZiAoZ2xvYmFsVGhpcy5jcnlwdG8ucmFuZG9tQnl0ZXMpIHtcbiAgICAgICB2YXIgYSA9IG5ldyBJbnQzMkFycmF5KGdsb2JhbFRoaXMuY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KS5idWZmZXIpO1xuICAgICAgIHJldHVybiBbMCwgYVswXSwgYVsxXSwgYVsyXSwgYVszXV07XG4gICAgIH1cbiAgfVxuICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgdmFyIHggPSBub3deMHhmZmZmZmZmZipNYXRoLnJhbmRvbSgpO1xuICByZXR1cm4gWzAseF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfaW50X3NpemUgKCkgeyByZXR1cm4gMzI7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSBjb25zdFxuLy8gbWF4X2ludCAvIDQgc28gdGhhdCB0aGUgZm9sbG93aW5nIGRvZXMgbm90IG92ZXJmbG93XG4vL2xldCBtYXhfc3RyaW5nX2xlbmd0aCA9IHdvcmRfc2l6ZSAvIDggKiBtYXhfYXJyYXlfbGVuZ3RoIC0gMTs7XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplICgpIHsgcmV0dXJuICgweDdGRkZGRkZGLzQpIHwgMDt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IGNvbnN0XG4vL1JlcXVpcmVzOiBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCAoKSB7IHJldHVybiBvc190eXBlID09IFwiVW5peFwiID8gMSA6IDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiBjb25zdFxuLy9SZXF1aXJlczogb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyICgpIHsgcmV0dXJuIG9zX3R5cGUgPT0gXCJXaW4zMlwiID8gMSA6IDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gY29uc3Rcbi8vUmVxdWlyZXM6IG9zX3R5cGVcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gKCkgeyByZXR1cm4gb3NfdHlwZSA9PSBcIkN5Z3dpblwiID8gMSA6IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgKCkge1xuICByZXR1cm4gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJqc19vZl9vY2FtbFwiKV07XG59XG5cbi8vUHJvdmlkZXM6IG9zX3R5cGVcbnZhciBvc190eXBlID0gKGdsb2JhbFRoaXMucHJvY2VzcyAmJlxuICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtICYmXG4gICAgICAgICAgICAgICBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0gPT0gXCJ3aW4zMlwiKSA/IFwiQ3lnd2luXCIgOiBcIlVuaXhcIjtcblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfY29uZmlnIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfY29uZmlnICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG9zX3R5cGUpLCAzMiwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzYXR0eVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNhdHR5KF9jaGFuKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfdmFyaWFudFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3ZhcmlhbnQoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVyc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyKCl7cmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xudmFyIGNhbWxfcnVudGltZV93YXJuaW5ncyA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3Ncbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyAoYm9vbCkge1xuICBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSBib29sO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQgKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3J1bnRpbWVfd2FybmluZ3M7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3NwYWNldGltZV9lbmFibGVkKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9uYWtlZF9wb2ludGVyc19jaGVja2VkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQoX3VuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lKF9jaGFubmVsKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJTcGFjZXRpbWUgcHJvZmlsaW5nIG9ubHkgd29ya3MgZm9yIG5hdGl2ZSBjb2RlXCIpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzX3JlZ3VsYXJfZmlsZVxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzX3JlZ3VsYXJfZmlsZShuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJldHVybiByb290LmRldmljZS5pc0ZpbGUocm9vdC5yZXN0KTtcbn1cbi8vQWx3YXlzXG4vL1JlcXVpcmVzOiBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9zZXR1cF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlcigpIHtcbiAgdmFyIHByb2Nlc3MgPSBnbG9iYWxUaGlzLnByb2Nlc3M7XG4gIGlmKHByb2Nlc3MgJiYgcHJvY2Vzcy5vbikge1xuICAgIHByb2Nlc3Mub24oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZnVuY3Rpb24gKGVyciwgb3JpZ2luKSB7XG4gICAgICBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbihlcnIpO1xuICAgICAgcHJvY2Vzcy5leGl0ICgyKTtcbiAgICB9KVxuICB9XG4gIGVsc2UgaWYoZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKXtcbiAgICBnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgaWYoZXZlbnQuZXJyb3Ipe1xuICAgICAgICBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbihldmVudC5lcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNhbWxfc2V0dXBfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIoKTtcbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cblxuLy9Qcm92aWRlczogY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWdcbi8vUmVxdWlyZXM6IGpzb29fc3lzX2dldGVudlxudmFyIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnID0gRkxBRyhcIndpdGgtanMtZXJyb3JcIik7XG5cbihmdW5jdGlvbiAoKSB7XG4gIHZhciByID0ganNvb19zeXNfZ2V0ZW52KFwiT0NBTUxSVU5QQVJBTVwiKVxuICBpZihyICE9PSB1bmRlZmluZWQpe1xuICAgIHZhciBsID0gci5zcGxpdChcIixcIik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGwubGVuZ3RoOyBpKyspe1xuICAgICAgaWYobFtpXSA9PSBcImJcIikgeyBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZmxhZyA9IDE7IGJyZWFrIH1cbiAgICAgIGVsc2UgaWYgKGxbaV0uc3RhcnRzV2l0aChcImI9XCIpKSB7XG4gICAgICAgIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnID0gKyhsW2ldLnNsaWNlKDIpKX1cbiAgICAgIGVsc2UgY29udGludWU7XG4gICAgfVxuICB9XG59KSAoKVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9iYWNrdHJhY2Vfc3RhdHVzXG4vL1JlcXVpcmVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZmxhZ1xuZnVuY3Rpb24gY2FtbF9iYWNrdHJhY2Vfc3RhdHVzIChfdW5pdCkgeyByZXR1cm4gY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWcgPyAxIDogMDsgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnXG5mdW5jdGlvbiBjYW1sX3JlY29yZF9iYWNrdHJhY2UgKGIpIHsgY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWcgPSBiOyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlICgpIHsgcmV0dXJuIFswXTsgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aCgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3RcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90ICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2Vfc2xvdDogaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZShleG4sIGJ0KSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayAoKSB7IHJldHVybiBbMF07IH1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdCgpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3B1cmVfZXhwciBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc19wdXJlX2V4cHIgKGYpIHsgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgWzBdKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3NldCAobXV0YWJsZSwgY29uc3QsIG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX2pzX3NldChvLGYsdikgeyBvW2ZdPXY7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2dldCAobXV0YWJsZSwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2dldChvLGYpIHsgcmV0dXJuIG9bZl07IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZGVsZXRlIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZGVsZXRlKG8sZikgeyBkZWxldGUgb1tmXTsgcmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaW5zdGFuY2VvZiAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19pbnN0YW5jZW9mKG8sYykgeyByZXR1cm4gKG8gaW5zdGFuY2VvZiBjKSA/IDEgOiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdHlwZW9mIChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdHlwZW9mKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmUocmVzKSB7XG4gIHZhciBjID0gMTtcbiAgd2hpbGUocmVzICYmIHJlcy5qb29fdHJhbXApe1xuICAgIHJlcyA9IHJlcy5qb29fdHJhbXAuYXBwbHkobnVsbCwgcmVzLmpvb19hcmdzKTtcbiAgICBjKys7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVfcmV0dXJuXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuKGYsYXJncykge1xuICByZXR1cm4ge2pvb190cmFtcDpmLGpvb19hcmdzOmFyZ3N9O1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfc3RhY2tfZGVwdGhcbi8vSWY6IGVmZmVjdHNcbnZhciBjYW1sX3N0YWNrX2RlcHRoID0gMDtcblxuLy9Qcm92aWRlczpjYW1sX3N0YWNrX2NoZWNrX2RlcHRoXG4vL0lmOiBlZmZlY3RzXG4vL1JlcXVpcmVzOmNhbWxfc3RhY2tfZGVwdGhcbmZ1bmN0aW9uIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgoKSB7XG4gICAgcmV0dXJuIC0tY2FtbF9zdGFja19kZXB0aCA+IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbGJhY2tcbi8vSWY6ICFlZmZlY3RzXG4vL1JlcXVpcmVzOmNhbWxfY2FsbF9nZW5cbnZhciBjYW1sX2NhbGxiYWNrID0gY2FtbF9jYWxsX2dlbjtcblxuLy9Qcm92aWRlczogY2FtbF9jYWxsYmFja1xuLy9JZjogZWZmZWN0c1xuLy9SZXF1aXJlczpjYW1sX3N0YWNrX2RlcHRoLCBjYW1sX2NhbGxfZ2VuLCBjYW1sX2V4bl9zdGFjaywgY2FtbF9maWJlcl9zdGFjaywgY2FtbF93cmFwX2V4Y2VwdGlvbiwgY2FtbF9yZXN1bWVfc3RhY2ssIGNhbWxfZnJlc2hfb29faWQsIGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnRcbmZ1bmN0aW9uIGNhbWxfY2FsbGJhY2soZixhcmdzKSB7XG4gIGZ1bmN0aW9uIHVuY2F1Z2h0X2VmZmVjdF9oYW5kbGVyKGVmZixrLG1zKSB7XG4gICAgLy8gUmVzdW1lcyB0aGUgY29udGludWF0aW9uIGsgYnkgcmFpc2luZyBleGNlcHRpb24gVW5oYW5kbGVkLlxuICAgIGNhbWxfcmVzdW1lX3N0YWNrKGtbMV0sbXMpO1xuICAgIHZhciBleG4gPSBjYW1sX25hbWVkX3ZhbHVlKFwiRWZmZWN0LlVuaGFuZGxlZFwiKTtcbiAgICBpZihleG4pIGNhbWxfcmFpc2Vfd2l0aF9hcmcoZXhuLCBlZmYpO1xuICAgIGVsc2Uge1xuICAgICAgZXhuID0gWzI0OCxjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiRWZmZWN0LlVuaGFuZGxlZFwiKSwgY2FtbF9mcmVzaF9vb19pZCgwKV07XG4gICAgICBjYW1sX3JhaXNlX2NvbnN0YW50KGV4bik7XG4gICAgfVxuICB9XG4gIHZhciBzYXZlZF9zdGFja19kZXB0aCA9IGNhbWxfc3RhY2tfZGVwdGg7XG4gIHZhciBzYXZlZF9leG5fc3RhY2sgPSBjYW1sX2V4bl9zdGFjaztcbiAgdmFyIHNhdmVkX2ZpYmVyX3N0YWNrID0gY2FtbF9maWJlcl9zdGFjaztcbiAgdHJ5IHtcbiAgICBjYW1sX2V4bl9zdGFjayA9IDA7XG4gICAgY2FtbF9maWJlcl9zdGFjayA9XG4gICAgICB7aDpbMCwgMCwgMCwgdW5jYXVnaHRfZWZmZWN0X2hhbmRsZXJdLCByOntrOjAsIHg6MCwgZTowfX07XG4gICAgdmFyIHJlcyA9IHtqb29fdHJhbXA6IGYsXG4gICAgICAgICAgICAgICBqb29fYXJnczogYXJncy5jb25jYXQoZnVuY3Rpb24gKHgpe3JldHVybiB4O30pfTtcbiAgICBkbyB7XG4gICAgICBjYW1sX3N0YWNrX2RlcHRoID0gNDA7XG4gICAgICB0cnkge1xuICAgICAgICByZXMgPSBjYW1sX2NhbGxfZ2VuKHJlcy5qb29fdHJhbXAsIHJlcy5qb29fYXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIEhhbmRsZSBleGNlcHRpb24gY29taW5nIGZyb20gSmF2YVNjcmlwdCBvciBmcm9tIHRoZSBydW50aW1lLiAqL1xuICAgICAgICBpZiAoIWNhbWxfZXhuX3N0YWNrKSB0aHJvdyBlO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGNhbWxfZXhuX3N0YWNrWzFdO1xuICAgICAgICBjYW1sX2V4bl9zdGFjayA9IGNhbWxfZXhuX3N0YWNrWzJdO1xuICAgICAgICByZXMgPSB7am9vX3RyYW1wOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgam9vX2FyZ3M6IFtjYW1sX3dyYXBfZXhjZXB0aW9uKGUpXX07XG4gICAgICB9XG4gICAgfSB3aGlsZShyZXMgJiYgcmVzLmpvb19hcmdzKVxuICB9IGZpbmFsbHkge1xuICAgIGNhbWxfc3RhY2tfZGVwdGggPSBzYXZlZF9zdGFja19kZXB0aDtcbiAgICBjYW1sX2V4bl9zdGFjayA9IHNhdmVkX2V4bl9zdGFjaztcbiAgICBjYW1sX2ZpYmVyX3N0YWNrID0gc2F2ZWRfZmliZXJfc3RhY2s7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19qc1xuZnVuY3Rpb24gY2FtbF9pc19qcygpIHtcbiAgcmV0dXJuIDE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNvb19mbGFnc191c2VfanNfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzb29fZmxhZ3NfdXNlX2pzX3N0cmluZyh1bml0KXtcbiAgcmV0dXJuIEZMQUcoXCJ1c2UtanMtc3RyaW5nXCIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNvb19mbGFnc19lZmZlY3RzXG5mdW5jdGlvbiBjYW1sX2pzb29fZmxhZ3NfZWZmZWN0cyh1bml0KXtcbiAgcmV0dXJuIEZMQUcoXCJlZmZlY3RzXCIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd3JhcF9leGNlcHRpb24gY29uc3QgKG11dGFibGUpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nLGNhbWxfbmFtZWRfdmFsdWVcbmZ1bmN0aW9uIGNhbWxfd3JhcF9leGNlcHRpb24oZSkge1xuICBpZiAoRkxBRyhcImV4Y3dyYXBcIikpIHtcbiAgICBpZihlIGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBlO1xuICAgIHZhciBleG47XG4gICAgLy9TdGFja19vdmVyZmxvdzogY2hyb21lLCBzYWZhcmlcbiAgICBpZihnbG9iYWxUaGlzLlJhbmdlRXJyb3JcbiAgICAgICAmJiBlIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5SYW5nZUVycm9yXG4gICAgICAgJiYgZS5tZXNzYWdlXG4gICAgICAgJiYgZS5tZXNzYWdlLm1hdGNoKC9tYXhpbXVtIGNhbGwgc3RhY2svaSkpXG4gICAgICBleG4gPSBjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93O1xuICAgIC8vU3RhY2tfb3ZlcmZsb3c6IGZpcmVmb3hcbiAgICBlbHNlIGlmKGdsb2JhbFRoaXMuSW50ZXJuYWxFcnJvclxuICAgICAgICYmIGUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkludGVybmFsRXJyb3JcbiAgICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL3RvbyBtdWNoIHJlY3Vyc2lvbi9pKSlcbiAgICAgIGV4biA9IGNhbWxfZ2xvYmFsX2RhdGEuU3RhY2tfb3ZlcmZsb3c7XG4gICAgLy9XcmFwIEVycm9yIGluIEpzLkVycm9yIGV4Y2VwdGlvblxuICAgIGVsc2UgaWYoZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRXJyb3IgJiYgY2FtbF9uYW1lZF92YWx1ZShcImpzRXJyb3JcIikpXG4gICAgICBleG4gPSBbMCxjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSxlXTtcbiAgICBlbHNlXG4gICAgICAvL2ZhbGxiYWNrOiB3cmFwcGVkIGluIEZhaWx1cmVcbiAgICAgIGV4biA9IFswLGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSxjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoU3RyaW5nKGUpKV07XG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGVycm9yIGF0IGhhbmQsIGxldCdzIHVzZSBpdC5cbiAgICBpZiAoZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRXJyb3IpXG4gICAgICBleG4uanNfZXJyb3IgPSBlO1xuICAgIHJldHVybiBleG47XG4gIH0gZWxzZVxuICAgIHJldHVybiBlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZmxhZ1xuZnVuY3Rpb24gY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlKGV4biwgZm9yY2UpIHtcbiAgaWYoY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWcpXG4gICAgcmV0dXJuIGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlKGV4biwgZm9yY2UpO1xuICBlbHNlIHJldHVybiBleG5cbn1cblxuLy8gRXhwZXJpbWVudGFsXG4vL1Byb3ZpZGVzOiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UoZXhuLCBmb3JjZSkge1xuICAvL25ldmVyIHJlcmFpc2UgZm9yIGNvbnN0YW50IGV4blxuICBpZighZXhuLmpzX2Vycm9yIHx8IGZvcmNlIHx8IGV4blswXSA9PSAyNDgpIGV4bi5qc19lcnJvciA9IG5ldyBnbG9iYWxUaGlzLkVycm9yKFwiSnMgZXhjZXB0aW9uIGNvbnRhaW5pbmcgYmFja3RyYWNlXCIpO1xuICByZXR1cm4gZXhuO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb3B0aW9uX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vcHRpb25fb2ZfZXhjZXB0aW9uKGV4bikge1xuICBpZihleG4uanNfZXJyb3IpIHsgcmV0dXJuIFswLCBleG4uanNfZXJyb3JdOyB9XG4gIHJldHVybiAwO1xufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Jvb2woeCkgeyByZXR1cm4gISF4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19ib29sKHgpIHsgcmV0dXJuICt4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19mbG9hdCh4KSB7IHJldHVybiB4OyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2FycmF5KGEpIHtcbiAgcmV0dXJuIGEuc2xpY2UoMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2FycmF5KGEpIHtcbiAgdmFyIGxlbiA9IGEubGVuZ3RoO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGJbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGxlbjtpKyspIGJbaSsxXSA9IGFbaV07XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkgY29uc3QgKG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkoYSl7XG4gIHZhciBsID0gMDtcbiAgZm9yKHZhciBpPWEubGVuZ3RoIC0gMTsgaT49MDsgaS0tKXtcbiAgICB2YXIgZSA9IGFbaV07XG4gICAgbCA9IFswLGUsbF07XG4gIH1cbiAgcmV0dXJuIGxcbn1cblxuLy9Qcm92aWRlczogY2FtbF9saXN0X3RvX2pzX2FycmF5IGNvbnN0IChtdXRhYmxlKVxuZnVuY3Rpb24gY2FtbF9saXN0X3RvX2pzX2FycmF5KGwpe1xuICB2YXIgYSA9IFtdO1xuICBmb3IoOyBsICE9PSAwOyBsID0gbFsyXSkge1xuICAgIGEucHVzaChsWzFdKTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc192YXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdmFyKHgpIHtcbiAgdmFyIHggPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh4KTtcbiAgLy9DaGVja3MgdGhhdCB4IGhhcyB0aGUgZm9ybSBpZGVudFsuaWRlbnRdKlxuICBpZigheC5tYXRjaCgvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKihcXC5bYS16QS1aXyRdW2EtekEtWl8kMC05XSopKiQvKSl7XG4gICAgY29uc29sZS5lcnJvcihcImNhbWxfanNfdmFyOiBcXFwiXCIgKyB4ICsgXCJcXFwiIGlzIG5vdCBhIHZhbGlkIEphdmFTY3JpcHQgdmFyaWFibGUuIGNvbnRpbnVpbmcgLi5cIik7XG4gICAgLy9jb25zb2xlLmVycm9yKFwiSnMuVW5zYWZlLmV2YWxfc3RyaW5nXCIpXG4gIH1cbiAgcmV0dXJuIGV2YWwoeCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2NhbGwgKGNvbnN0LCBtdXRhYmxlLCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX2NhbGwoZiwgbywgYXJncykgeyByZXR1cm4gZi5hcHBseShvLCBjYW1sX2pzX2Zyb21fYXJyYXkoYXJncykpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Z1bl9jYWxsIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19mdW5fY2FsbChmLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAxOiByZXR1cm4gZigpO1xuICBjYXNlIDI6IHJldHVybiBmIChhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gZiAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICBjYXNlIDg6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSxhWzddKTtcbiAgfVxuICByZXR1cm4gZi5hcHBseShudWxsLCBjYW1sX2pzX2Zyb21fYXJyYXkoYSkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19tZXRoX2NhbGwgKG11dGFibGUsIGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19tZXRoX2NhbGwobywgZiwgYXJncykge1xuICByZXR1cm4gb1tjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhmKV0uYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbmV3IChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19uZXcoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDI6IHJldHVybiBuZXcgYyAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICBjYXNlIDg6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgY2FtbF9qc19mcm9tX2FycmF5KGEpKTsgfVxuICBGLnByb3RvdHlwZSA9IGMucHJvdG90eXBlO1xuICByZXR1cm4gbmV3IEY7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX29qc19uZXdfYXJyIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9vanNfbmV3X2FycihjLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAwOiByZXR1cm4gbmV3IGM7XG4gIGNhc2UgMTogcmV0dXJuIG5ldyBjIChhWzBdKTtcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgfVxuICBmdW5jdGlvbiBGKCkgeyByZXR1cm4gYy5hcHBseSh0aGlzLCBhKTsgfVxuICBGLnByb3RvdHlwZSA9IGMucHJvdG90eXBlO1xuICByZXR1cm4gbmV3IEY7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZihsZW4gPiAwKXtcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzID0gW3VuZGVmaW5lZF07XG4gICAgfVxuICAgIHZhciByZXMgPSBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpO1xuICAgIHJldHVybiAocmVzIGluc3RhbmNlb2YgRnVuY3Rpb24pP2NhbWxfanNfd3JhcF9jYWxsYmFjayhyZXMpOnJlcztcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBbYXJnc10pO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0KGFyaXR5LCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyaXR5KTtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCwgYXJpdHkpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBhcmdzKTtcbiAgfTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja191bnNhZmUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFjaywgY2FtbF9qc19mdW5jdGlvbl9hcml0eVxuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX3Vuc2FmZShmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGNhbWxfanNfZnVuY3Rpb25fYXJpdHkoZik7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpOyB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrLCBjYW1sX2pzX3dyYXBfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgdmFyIHJlcyA9IGNhbWxfY2FsbGJhY2soZixhcmdzKTtcbiAgICByZXR1cm4gKHJlcyBpbnN0YW5jZW9mIEZ1bmN0aW9uKT9jYW1sX2pzX3dyYXBfY2FsbGJhY2socmVzKTpyZXM7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLFt0aGlzLGFyZ3NdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSArIDEpO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoLCBhcml0eSlcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFjaywgY2FtbF9qc19mdW5jdGlvbl9hcml0eVxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gY2FtbF9qc19mdW5jdGlvbl9hcml0eShmKSAtIDE7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpOyB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnVuY3Rpb25fYXJpdHlcbi8vSWY6ICFlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5KGYpIHtcbiAgcmV0dXJuIChmLmwgPj0gMCk/Zi5sOihmLmwgPSBmLmxlbmd0aClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mdW5jdGlvbl9hcml0eVxuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9qc19mdW5jdGlvbl9hcml0eShmKSB7XG4gIC8vIEZ1bmN0aW9ucyBoYXZlIGFuIGFkZGl0aW9uYWwgY29udGludWF0aW9uIHBhcmFtZXRlci4gVGhpcyBzaG91bGRcbiAgLy8gbm90IGJlIHZpc2libGUgd2hlbiBjYWxsaW5nIHRoZW0gZnJvbSBKYXZhU2NyaXB0XG4gIHJldHVybiAoKGYubCA+PSAwKT9mLmw6KGYubCA9IGYubGVuZ3RoKSkgLSAxXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXF1YWxzIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZXF1YWxzICh4LCB5KSB7IHJldHVybiArKHggPT0geSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19ldmFsX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19ldmFsX3N0cmluZyAocykge3JldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXhwciAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19leHByKHMpIHtcbiAgY29uc29sZS5lcnJvcihcImNhbWxfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXFxuXCIpO1xuICByZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3B1cmVfanNfZXhwciBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9wdXJlX2pzX2V4cHIgKHMpe1xuICBjb25zb2xlLmVycm9yKFwiY2FtbF9wdXJlX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblxcblwiKTtcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9qc19vYmplY3QgKG9iamVjdF9saXRlcmFsKVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfb2JqZWN0IChhKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gYVtpXTtcbiAgICBvW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHBbMV0pXSA9IHBbMl07XG4gIH1cbiAgcmV0dXJuIG87XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEZvcm1hdFxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2Zvcm1hdFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2Zvcm1hdCAoZm10KSB7XG4gIGZtdCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KTtcbiAgdmFyIGxlbiA9IGZtdC5sZW5ndGg7XG4gIGlmIChsZW4gPiAzMSkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZm9ybWF0X2ludDogZm9ybWF0IHRvbyBsb25nXCIpO1xuICB2YXIgZiA9XG4gICAgICB7IGp1c3RpZnk6JysnLCBzaWduc3R5bGU6Jy0nLCBmaWxsZXI6JyAnLCBhbHRlcm5hdGU6ZmFsc2UsXG4gICAgICAgIGJhc2U6MCwgc2lnbmVkY29udjpmYWxzZSwgd2lkdGg6MCwgdXBwZXJjYXNlOmZhbHNlLFxuICAgICAgICBzaWduOjEsIHByZWM6LTEsIGNvbnY6J2YnIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IGZtdC5jaGFyQXQoaSk7XG4gICAgc3dpdGNoIChjKSB7XG4gICAgY2FzZSAnLSc6XG4gICAgICBmLmp1c3RpZnkgPSAnLSc7IGJyZWFrO1xuICAgIGNhc2UgJysnOiBjYXNlICcgJzpcbiAgICAgIGYuc2lnbnN0eWxlID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnMCc6XG4gICAgICBmLmZpbGxlciA9ICcwJzsgYnJlYWs7XG4gICAgY2FzZSAnIyc6XG4gICAgICBmLmFsdGVybmF0ZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOiBjYXNlICc1JzpcbiAgICBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgIGYud2lkdGggPSAwO1xuICAgICAgd2hpbGUgKGM9Zm10LmNoYXJDb2RlQXQoaSkgLSA0OCwgYyA+PSAwICYmIGMgPD0gOSkge1xuICAgICAgICBmLndpZHRoID0gZi53aWR0aCAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgICBicmVhaztcbiAgICBjYXNlICcuJzpcbiAgICAgIGYucHJlYyA9IDA7XG4gICAgICBpKys7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYucHJlYyA9IGYucHJlYyAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgY2FzZSAnZCc6IGNhc2UgJ2knOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlICd1JzpcbiAgICAgIGYuYmFzZSA9IDEwOyBicmVhaztcbiAgICBjYXNlICd4JzpcbiAgICAgIGYuYmFzZSA9IDE2OyBicmVhaztcbiAgICBjYXNlICdYJzpcbiAgICAgIGYuYmFzZSA9IDE2OyBmLnVwcGVyY2FzZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJ28nOlxuICAgICAgZi5iYXNlID0gODsgYnJlYWs7XG4gICAgY2FzZSAnZSc6IGNhc2UgJ2YnOiBjYXNlICdnJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYuY29udiA9IGM7IGJyZWFrO1xuICAgIGNhc2UgJ0UnOiBjYXNlICdGJzogY2FzZSAnRyc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyBmLnVwcGVyY2FzZSA9IHRydWU7XG4gICAgICBmLmNvbnYgPSBjLnRvTG93ZXJDYXNlICgpOyBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcmF3YnVmZmVyKSB7XG4gIGlmIChmLnVwcGVyY2FzZSkgcmF3YnVmZmVyID0gcmF3YnVmZmVyLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBsZW4gPSByYXdidWZmZXIubGVuZ3RoO1xuICAvKiBBZGp1c3QgbGVuIHRvIHJlZmxlY3QgYWRkaXRpb25hbCBjaGFycyAoc2lnbiwgZXRjKSAqL1xuICBpZiAoZi5zaWduZWRjb252ICYmIChmLnNpZ24gPCAwIHx8IGYuc2lnbnN0eWxlICE9ICctJykpIGxlbisrO1xuICBpZiAoZi5hbHRlcm5hdGUpIHtcbiAgICBpZiAoZi5iYXNlID09IDgpIGxlbiArPSAxO1xuICAgIGlmIChmLmJhc2UgPT0gMTYpIGxlbiArPSAyO1xuICB9XG4gIC8qIERvIHRoZSBmb3JtYXR0aW5nICovXG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICBpZiAoZi5qdXN0aWZ5ID09ICcrJyAmJiBmLmZpbGxlciA9PSAnICcpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcgJztcbiAgaWYgKGYuc2lnbmVkY29udikge1xuICAgIGlmIChmLnNpZ24gPCAwKSBidWZmZXIgKz0gJy0nO1xuICAgIGVsc2UgaWYgKGYuc2lnbnN0eWxlICE9ICctJykgYnVmZmVyICs9IGYuc2lnbnN0eWxlO1xuICB9XG4gIGlmIChmLmFsdGVybmF0ZSAmJiBmLmJhc2UgPT0gOCkgYnVmZmVyICs9ICcwJztcbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSAxNikgYnVmZmVyICs9IGYudXBwZXJjYXNlP1wiMFhcIjpcIjB4XCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcwJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJzAnO1xuICBidWZmZXIgKz0gcmF3YnVmZmVyO1xuICBpZiAoZi5qdXN0aWZ5ID09ICctJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhidWZmZXIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGpzb29fZmxvb3JfbG9nMlxudmFyIGxvZzJfb2sgPSBNYXRoLmxvZzIgJiYgTWF0aC5sb2cyKDEuMTIzNTU4MjA5Mjg4OTQ3NEUrMzA3KSA9PSAxMDIwXG5mdW5jdGlvbiBqc29vX2Zsb29yX2xvZzIoeCkge1xuICBpZihsb2cyX29rKSByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmxvZzIoeCkpXG4gIHZhciBpID0gMDtcbiAgaWYgKHggPT0gMCkgcmV0dXJuIC1JbmZpbml0eTtcbiAgaWYoeD49MSkge3doaWxlICh4Pj0yKSB7eC89MjsgaSsrfSB9XG4gIGVsc2Uge3doaWxlICh4IDwgMSkge3gqPTI7IGktLX0gfTtcbiAgcmV0dXJuIGk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyLCBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaVxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIGlmICghaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoaXNOYU4oeCkpXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMSwgMCwgMHg3ZmYwKTtcbiAgICBpZiAoeCA+IDApXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMCwgMCwgMHg3ZmYwKVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweGZmZjApXG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8weDgwMDA6KHg+PTApPzA6MHg4MDAwO1xuICBpZiAoc2lnbikgeCA9IC14O1xuICAvLyBJbnQ2NC5iaXRzX29mX2Zsb2F0IDEuMTIzNTU4MjA5Mjg4OTQ3NEUrMzA3ID0gMHg3ZmIwMDAwMDAwMDAwMDAwTFxuICAvLyB1c2luZyBNYXRoLkxPRzJFKk1hdGgubG9nKHgpIGluIHBsYWNlIG9mIE1hdGgubG9nMiByZXN1bHQgaW4gcHJlY2lzaW9uIGxvc3RcbiAgdmFyIGV4cCA9IGpzb29fZmxvb3JfbG9nMih4KSArIDEwMjM7XG4gIGlmIChleHAgPD0gMCkge1xuICAgIGV4cCA9IDA7XG4gICAgeCAvPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgfSBlbHNlIHtcbiAgICB4IC89IE1hdGgucG93KDIsZXhwLTEwMjcpO1xuICAgIGlmICh4IDwgMTYpIHtcbiAgICAgIHggKj0gMjsgZXhwIC09MTsgfVxuICAgIGlmIChleHAgPT0gMCkge1xuICAgICAgeCAvPSAyOyB9XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLDI0KTtcbiAgdmFyIHIzID0geHwwO1xuICB4ID0gKHggLSByMykgKiBrO1xuICB2YXIgcjIgPSB4fDA7XG4gIHggPSAoeCAtIHIyKSAqIGs7XG4gIHZhciByMSA9IHh8MDtcbiAgcjMgPSAocjMgJjB4ZikgfCBzaWduIHwgZXhwIDw8IDQ7XG4gIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShyMSwgcjIsIHIzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdCAoeCkge1xuICB2YXIgZmxvYXQzMmEgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xuICBmbG9hdDMyYVswXSA9IHg7XG4gIHZhciBpbnQzMmEgPSBuZXcgSW50MzJBcnJheShmbG9hdDMyYS5idWZmZXIpO1xuICByZXR1cm4gaW50MzJhWzBdIHwgMDtcbn1cblxuLy9GUCBsaXRlcmFscyBjYW4gYmUgd3JpdHRlbiB1c2luZyB0aGUgaGV4YWRlY2ltYWxcbi8vbm90YXRpb24gMHg8bWFudGlzc2EgaW4gaGV4PnA8ZXhwb25lbnQ+IGZyb20gSVNPIEM5OS5cbi8vaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWhleGZsb2F0L2Jsb2IvbWFzdGVyL2hleGZsb2F0LmpzXG4vL1Byb3ZpZGVzOiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcsIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQgKHgsIHByZWMsIHN0eWxlKSB7XG4gIGlmICghaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoaXNOYU4oeCkpIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhcIm5hblwiKTtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKCh4ID4gMCk/XCJpbmZpbml0eVwiOlwiLWluZmluaXR5XCIpO1xuICB9XG4gIHZhciBzaWduID0gKHg9PTAgJiYgMS94ID09IC1JbmZpbml0eSk/MTooeD49MCk/MDoxO1xuICBpZihzaWduKSB4ID0gLXg7XG4gIHZhciBleHAgPSAwO1xuICBpZiAoeCA9PSAwKSB7IH1cbiAgZWxzZSBpZiAoeCA8IDEpIHtcbiAgICB3aGlsZSAoeCA8IDEgJiYgZXhwID4gLTEwMjIpICB7IHggKj0gMjsgZXhwLS0gfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlICh4ID49IDIpIHsgeCAvPSAyOyBleHArKyB9XG4gIH1cbiAgdmFyIGV4cF9zaWduID0gZXhwIDwgMCA/ICcnIDogJysnO1xuICB2YXIgc2lnbl9zdHIgPSAnJztcbiAgaWYgKHNpZ24pIHNpZ25fc3RyID0gJy0nXG4gIGVsc2Uge1xuICAgIHN3aXRjaChzdHlsZSl7XG4gICAgY2FzZSA0MyAvKiAnKycgKi86IHNpZ25fc3RyID0gJysnOyBicmVhaztcbiAgICBjYXNlIDMyIC8qICcgJyAqLzogc2lnbl9zdHIgPSAnICc7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAocHJlYyA+PSAwICYmIHByZWMgPCAxMykge1xuICAgIC8qIElmIGEgcHJlY2lzaW9uIGlzIGdpdmVuLCBhbmQgaXMgc21hbGwsIHJvdW5kIG1hbnRpc3NhIGFjY29yZGluZ2x5ICovXG4gICAgdmFyIGNzdCA9IE1hdGgucG93KDIscHJlYyAqIDQpO1xuICAgIHggPSBNYXRoLnJvdW5kKHggKiBjc3QpIC8gY3N0O1xuICB9XG4gIHZhciB4X3N0ciA9IHgudG9TdHJpbmcoMTYpO1xuICBpZihwcmVjID49IDApe1xuICAgIHZhciBpZHggPSB4X3N0ci5pbmRleE9mKCcuJyk7XG4gICAgaWYoaWR4PDApIHtcbiAgICAgIHhfc3RyICs9ICcuJyArIGNhbWxfc3RyX3JlcGVhdChwcmVjLCAnMCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzaXplID0gaWR4KzErcHJlYztcbiAgICAgIGlmKHhfc3RyLmxlbmd0aCA8IHNpemUpXG4gICAgICAgIHhfc3RyICs9IGNhbWxfc3RyX3JlcGVhdChzaXplIC0geF9zdHIubGVuZ3RoLCAnMCcpO1xuICAgICAgZWxzZVxuICAgICAgICB4X3N0ciA9IHhfc3RyLnN1YnN0cigwLHNpemUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHNpZ25fc3RyICsgJzB4JyArIHhfc3RyICsgJ3AnICsgZXhwX3NpZ24gKyBleHAudG9TdHJpbmcoMTApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGxvID0geC5sbztcbiAgdmFyIG1pID0geC5taTtcbiAgdmFyIGhpID0geC5oaTtcbiAgdmFyIGV4cCA9IChoaSAmIDB4N2ZmZikgPj4gNDtcbiAgaWYgKGV4cCA9PSAyMDQ3KSB7XG4gICAgaWYgKChsb3xtaXwoaGkmMHhmKSkgPT0gMClcbiAgICAgIHJldHVybiAoaGkgJiAweDgwMDApPygtSW5maW5pdHkpOkluZmluaXR5O1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBOYU47XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLC0yNCk7XG4gIHZhciByZXMgPSAobG8qayttaSkqaysoaGkmMHhmKTtcbiAgaWYgKGV4cCA+IDApIHtcbiAgICByZXMgKz0gMTY7XG4gICAgcmVzICo9IE1hdGgucG93KDIsZXhwLTEwMjcpO1xuICB9IGVsc2VcbiAgICByZXMgKj0gTWF0aC5wb3coMiwtMTAyNik7XG4gIGlmIChoaSAmIDB4ODAwMCkgcmVzID0gLSByZXM7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV4dGFmdGVyX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfc3ViLGNhbWxfaW50NjRfb2ZfaW50MzJcbmZ1bmN0aW9uIGNhbWxfbmV4dGFmdGVyX2Zsb2F0ICh4LHkpIHtcbiAgaWYoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybiBOYU47XG4gIGlmKHg9PXkpIHJldHVybiB5O1xuICBpZih4PT0wKXtcbiAgICBpZih5IDwgMClcbiAgICAgIHJldHVybiAtTWF0aC5wb3coMiwgLTEwNzQpXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE1hdGgucG93KDIsIC0xMDc0KVxuICB9XG4gIHZhciBiaXRzID0gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHgpO1xuICB2YXIgb25lID0gY2FtbF9pbnQ2NF9vZl9pbnQzMigxKTtcbiAgaWYgKCh4PHkpID09ICh4PjApKVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X2FkZChiaXRzLCBvbmUpXG4gIGVsc2VcbiAgICBiaXRzID0gY2FtbF9pbnQ2NF9zdWIoYml0cywgb25lKVxuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGJpdHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RydW5jX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX3RydW5jX2Zsb2F0KHgpe1xuICByZXR1cm4gTWF0aC50cnVuYyh4KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGludDMyYSA9IG5ldyBJbnQzMkFycmF5KDEpO1xuICBpbnQzMmFbMF0gPSB4O1xuICB2YXIgZmxvYXQzMmEgPSBuZXcgRmxvYXQzMkFycmF5KGludDMyYS5idWZmZXIpO1xuICByZXR1cm4gZmxvYXQzMmFbMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2xhc3NpZnlfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY2xhc3NpZnlfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIGlmIChNYXRoLmFicyh4KSA+PSAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOCkgcmV0dXJuIDA7XG4gICAgaWYgKHggIT0gMCkgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDI7XG4gIH1cbiAgcmV0dXJuIGlzTmFOKHgpPzQ6Mztcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbW9kZl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tb2RmX2Zsb2F0ICh4KSB7XG4gIGlmIChpc0Zpbml0ZSAoeCkpIHtcbiAgICB2YXIgbmVnID0gKDEveCkgPCAwO1xuICAgIHggPSBNYXRoLmFicyh4KTtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IgKHgpO1xuICAgIHZhciBmID0geCAtIGk7XG4gICAgaWYgKG5lZykgeyBpID0gLWk7IGYgPSAtZjsgfVxuICAgIHJldHVybiBbMCwgZiwgaV07XG4gIH1cbiAgaWYgKGlzTmFOICh4KSkgcmV0dXJuIFswLCBOYU4sIE5hTl07XG4gIHJldHVybiBbMCwgMS94LCB4XTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbGRleHBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbGRleHBfZmxvYXQgKHgsZXhwKSB7XG4gIGV4cCB8PSAwO1xuICBpZiAoZXhwID4gMTAyMykge1xuICAgIGV4cCAtPSAxMDIzO1xuICAgIHggKj0gTWF0aC5wb3coMiwgMTAyMyk7XG4gICAgaWYgKGV4cCA+IDEwMjMpIHsgIC8vIGluIGNhc2UgeCBpcyBzdWJub3JtYWxcbiAgICAgIGV4cCAtPSAxMDIzO1xuICAgICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICB9XG4gIH1cbiAgaWYgKGV4cCA8IC0xMDIzKSB7XG4gICAgZXhwICs9IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAtMTAyMyk7XG4gIH1cbiAgeCAqPSBNYXRoLnBvdygyLCBleHApO1xuICByZXR1cm4geDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZnJleHBfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9mcmV4cF9mbG9hdCAoeCkge1xuICBpZiAoKHggPT0gMCkgfHwgIWlzRmluaXRlKHgpKSByZXR1cm4gWzAsIHgsIDBdO1xuICB2YXIgbmVnID0geCA8IDA7XG4gIGlmIChuZWcpIHggPSAtIHg7XG4gIHZhciBleHAgPSBNYXRoLm1heCgtMTAyMywganNvb19mbG9vcl9sb2cyKHgpICsgMSk7XG4gIHggKj0gTWF0aC5wb3coMiwtZXhwKTtcbiAgd2hpbGUgKHggPCAwLjUpIHtcbiAgICB4ICo9IDI7XG4gICAgZXhwLS07XG4gIH1cbiAgd2hpbGUgKHggPj0gMSkge1xuICAgIHggKj0gMC41O1xuICAgIGV4cCsrO1xuICB9XG4gIGlmIChuZWcpIHggPSAtIHg7XG4gIHJldHVybiBbMCwgeCwgZXhwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9jb21wYXJlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Zsb2F0X2NvbXBhcmUgKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHJldHVybiAwO1xuICBpZiAoeCA8IHkpIHJldHVybiAtMTtcbiAgaWYgKHggPiB5KSByZXR1cm4gMTtcbiAgaWYgKHggPT09IHgpIHJldHVybiAxO1xuICBpZiAoeSA9PT0geSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb3B5c2lnbl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3B5c2lnbl9mbG9hdCAoeCwgeSkge1xuICBpZiAoeSA9PSAwKSB5ID0gMSAvIHk7XG4gIHggPSBNYXRoLmFicyh4KTtcbiAgcmV0dXJuICh5IDwgMCk/KC14KTp4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NpZ25iaXRfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc2lnbmJpdF9mbG9hdCh4KSB7XG4gIGlmICh4ID09IDApIHggPSAxIC8geDtcbiAgcmV0dXJuICh4IDwgMCk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4cG0xX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2V4cG0xX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmV4cG0xKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2V4cDJfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXhwMl9mbG9hdCh4KSB7IHJldHVybiBNYXRoLnBvdygyLCB4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9sb2cxcF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cxcF9mbG9hdCh4KSB7IHJldHVybiBNYXRoLmxvZzFwKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzJfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMl9mbG9hdCh4KSB7IHJldHVybiBNYXRoLmxvZzIoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaHlwb3RfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaHlwb3RfZmxvYXQgKHgsIHkpIHsgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMTBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMTBfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGgubG9nMTAoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29zaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3NoX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmNvc2goeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfYWNvc2hfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYWNvc2hfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguYWNvc2goeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc2luaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaW5oX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLnNpbmgoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfYXNpbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYXNpbmhfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguYXNpbmgoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfdGFuaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF90YW5oX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLnRhbmgoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfYXRhbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYXRhbmhfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguYXRhbmgoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfcm91bmRfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfcm91bmRfZmxvYXQgKHgpIHtcbiAgaWYgKHggPj0gMCkge1xuICAgIHZhciB5ID0gTWF0aC5mbG9vcih4KTtcbiAgICByZXR1cm4gKHggLSB5ID49IDAuNSk/KHkgKyAxKTp5XG4gIH0gZWxzZSB7XG4gICAgdmFyIHkgPSBNYXRoLmNlaWwoeCk7XG4gICAgcmV0dXJuICh5IC0geCA+PSAwLjUpPyh5IC0gMSk6eVxuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2NicnRfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY2JydF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5jYnJ0KHgpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXJmX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2VyZl9mbG9hdCh4KSB7XG4gIHZhciBhMSA9IDAuMjU0ODI5NTkyO1xuICB2YXIgYTIgPSAtMC4yODQ0OTY3MzY7XG4gIHZhciBhMyA9IDEuNDIxNDEzNzQxO1xuICB2YXIgYTQgPSAtMS40NTMxNTIwMjc7XG4gIHZhciBhNSA9IDEuMDYxNDA1NDI5O1xuICB2YXIgcCA9IDAuMzI3NTkxMTtcblxuICB2YXIgc2lnbiA9IDE7XG4gIGlmICh4IDwgMCkge1xuICAgIHNpZ24gPSAtMTtcbiAgfVxuICB4ID0gTWF0aC5hYnMoeCk7XG4gIHZhciB0ID0gMS4wIC8gKDEuMCArIHAgKiB4KTtcbiAgdmFyIHkgPSAxLjAgLSAoKCgoYTUgKiB0ICsgYTQpICogdCArIGEzKSAqIHQgKyBhMikgKiB0ICsgYTEpICogdCAqIE1hdGguZXhwKC14ICogeCk7XG5cbiAgcmV0dXJuIHNpZ24gKiB5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VyZmNfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfZXJmX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2VyZmNfZmxvYXQoeCkge1xuICByZXR1cm4gMSAtIGNhbWxfZXJmX2Zsb2F0KHgpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZm1hX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZtYV9mbG9hdCh4LCB5LCB6KSB7XG4gIHZhciBTUExJVCA9IE1hdGgucG93KDIsIDI3KSArIDE7XG4gIHZhciBNSU5fVkFMVUUgPSBNYXRoLnBvdygyLCAtMTAyMik7XG4gIHZhciBFUFNJTE9OID0gTWF0aC5wb3coMiwgLTUyKTtcbiAgdmFyIEMgPSA0MTY7XG4gIHZhciBBID0gTWF0aC5wb3coMiwgK0MpO1xuICB2YXIgQiA9IE1hdGgucG93KDIsIC1DKTtcblxuICBmdW5jdGlvbiBtdWx0aXBseSAoYSwgYikge1xuICAgIHZhciBhdCA9IFNQTElUICogYTtcbiAgICB2YXIgYWhpID0gYXQgLSAoYXQgLSBhKTtcbiAgICB2YXIgYWxvID0gYSAtIGFoaTtcbiAgICB2YXIgYnQgPSBTUExJVCAqIGI7XG4gICAgdmFyIGJoaSA9IGJ0IC0gKGJ0IC0gYik7XG4gICAgdmFyIGJsbyA9IGIgLSBiaGk7XG4gICAgdmFyIHAgPSBhICogYjtcbiAgICB2YXIgZSA9ICgoYWhpICogYmhpIC0gcCkgKyBhaGkgKiBibG8gKyBhbG8gKiBiaGkpICsgYWxvICogYmxvO1xuICAgIHJldHVybiB7XG4gICAgICBwOiBwLFxuICAgICAgZTogZVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gYWRkIChhLCBiKSB7XG4gICAgdmFyIHMgPSBhICsgYjtcbiAgICB2YXIgdiA9IHMgLSBhO1xuICAgIHZhciBlID0gKGEgLSAocyAtIHYpKSArIChiIC0gdik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHM6IHMsXG4gICAgICBlOiBlXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBhZGp1c3QgKHgsIHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCAmJiB5ICE9PSAwICYmIFNQTElUICogeCAtIChTUExJVCAqIHggLSB4KSA9PT0geCA/IHggKiAoMSArICh4IDwgMCA/IC0xIDogKzEpICogKHkgPCAwID8gLTEgOiArMSkgKiBFUFNJTE9OKSA6IHg7XG4gIH07XG5cbiAgaWYgKHggPT09IDAgfHwgeCAhPT0geCB8fCB4ID09PSArMSAvIDAgfHwgeCA9PT0gLTEgLyAwIHx8XG4gICAgICB5ID09PSAwIHx8IHkgIT09IHkgfHwgeSA9PT0gKzEgLyAwIHx8IHkgPT09IC0xIC8gMCkge1xuICAgIHJldHVybiB4ICogeSArIHo7XG4gIH1cbiAgaWYgKHogPT09IDApIHtcbiAgICByZXR1cm4geCAqIHk7XG4gIH1cbiAgaWYgKHogIT09IHogfHwgeiA9PT0gKzEgLyAwIHx8IHogPT09IC0xIC8gMCkge1xuICAgIHJldHVybiB6O1xuICB9XG5cbiAgdmFyIHNjYWxlID0gMTtcbiAgd2hpbGUgKE1hdGguYWJzKHgpID4gQSkge1xuICAgIHNjYWxlICo9IEE7XG4gICAgeCAqPSBCO1xuICB9XG4gIHdoaWxlIChNYXRoLmFicyh5KSA+IEEpIHtcbiAgICBzY2FsZSAqPSBBO1xuICAgIHkgKj0gQjtcbiAgfVxuICBpZiAoc2NhbGUgPT09IDEgLyAwKSB7XG4gICAgcmV0dXJuIHggKiB5ICogc2NhbGU7XG4gIH1cbiAgd2hpbGUgKE1hdGguYWJzKHgpIDwgQikge1xuICAgIHNjYWxlICo9IEI7XG4gICAgeCAqPSBBO1xuICB9XG4gIHdoaWxlIChNYXRoLmFicyh5KSA8IEIpIHtcbiAgICBzY2FsZSAqPSBCO1xuICAgIHkgKj0gQTtcbiAgfVxuICBpZiAoc2NhbGUgPT09IDApIHtcbiAgICByZXR1cm4gejtcbiAgfVxuXG4gIHZhciB4cyA9IHg7XG4gIHZhciB5cyA9IHk7XG4gIHZhciB6cyA9IHogLyBzY2FsZTtcblxuICBpZiAoTWF0aC5hYnMoenMpID4gTWF0aC5hYnMoeHMgKiB5cykgKiA0IC8gRVBTSUxPTikge1xuICAgIHJldHVybiB6O1xuICB9XG4gIGlmIChNYXRoLmFicyh6cykgPCBNYXRoLmFicyh4cyAqIHlzKSAqIEVQU0lMT04gLyA0ICogRVBTSUxPTiAvIDQpIHtcbiAgICB6cyA9ICh6IDwgMCA/IC0xIDogKzEpICogTUlOX1ZBTFVFO1xuICB9XG5cbiAgdmFyIHh5ID0gbXVsdGlwbHkoeHMsIHlzKTtcbiAgdmFyIHMgPSBhZGQoeHkucCwgenMpO1xuICB2YXIgdSA9IGFkZCh4eS5lLCBzLmUpO1xuICB2YXIgaSA9IGFkZChzLnMsIHUucyk7XG5cbiAgdmFyIGYgPSBpLnMgKyBhZGp1c3QoaS5lLCB1LmUpO1xuICBpZiAoZiA9PT0gMCkge1xuICAgIHJldHVybiBmO1xuICB9XG5cbiAgdmFyIGZzID0gZiAqIHNjYWxlO1xuICBpZiAoTWF0aC5hYnMoZnMpID4gTUlOX1ZBTFVFKSB7XG4gICAgcmV0dXJuIGZzO1xuICB9XG5cbiAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCB0aGVyZSB3YXMgZXh0cmEgcm91bmRpbmcgZm9yIGEgZGVub3JtYWxpemVkIHZhbHVlLlxuICByZXR1cm4gZnMgKyBhZGp1c3QoZiAtIGZzIC8gc2NhbGUsIGkuZSkgKiBzY2FsZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9mbG9hdCAoZm10LCB4KSB7XG4gIGZ1bmN0aW9uIHRvRml4ZWQoeCxkcCkge1xuICAgIGlmIChNYXRoLmFicyh4KSA8IDEuMCkge1xuICAgICAgcmV0dXJuIHgudG9GaXhlZChkcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlID0gcGFyc2VJbnQoeC50b1N0cmluZygpLnNwbGl0KCcrJylbMV0pO1xuICAgICAgaWYgKGUgPiAyMCkge1xuICAgICAgICBlIC09IDIwO1xuICAgICAgICB4IC89IE1hdGgucG93KDEwLGUpO1xuICAgICAgICB4ICs9IChuZXcgQXJyYXkoZSsxKSkuam9pbignMCcpO1xuICAgICAgICBpZihkcCA+IDApIHtcbiAgICAgICAgICB4ID0geCArICcuJyArIChuZXcgQXJyYXkoZHArMSkpLmpvaW4oJzAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICAgIGVsc2UgcmV0dXJuIHgudG9GaXhlZChkcClcbiAgICB9XG4gIH1cbiAgdmFyIHMsIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICB2YXIgcHJlYyA9IChmLnByZWMgPCAwKT82OmYucHJlYztcbiAgaWYgKHggPCAwIHx8ICh4ID09IDAgJiYgMS94ID09IC1JbmZpbml0eSkpIHsgZi5zaWduID0gLTE7IHggPSAteDsgfVxuICBpZiAoaXNOYU4oeCkpIHsgcyA9IFwibmFuXCI7IGYuZmlsbGVyID0gJyAnOyB9XG4gIGVsc2UgaWYgKCFpc0Zpbml0ZSh4KSkgeyBzID0gXCJpbmZcIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZVxuICAgIHN3aXRjaCAoZi5jb252KSB7XG4gICAgY2FzZSAnZSc6XG4gICAgICB2YXIgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjKTtcbiAgICAgIC8vIGV4cG9uZW50IHNob3VsZCBiZSBhdCBsZWFzdCB0d28gZGlnaXRzXG4gICAgICB2YXIgaSA9IHMubGVuZ3RoO1xuICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgIHMgPSBzLnNsaWNlICgwLCBpIC0gMSkgKyAnMCcgKyBzLnNsaWNlIChpIC0gMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmJzpcbiAgICAgIHMgPSB0b0ZpeGVkKHgsIHByZWMpOyBicmVhaztcbiAgICBjYXNlICdnJzpcbiAgICAgIHByZWMgPSBwcmVjP3ByZWM6MTtcbiAgICAgIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyAtIDEpO1xuICAgICAgdmFyIGogPSBzLmluZGV4T2YoJ2UnKTtcbiAgICAgIHZhciBleHAgPSArcy5zbGljZShqICsgMSk7XG4gICAgICBpZiAoZXhwIDwgLTQgfHwgeCA+PSAxZTIxIHx8IHgudG9GaXhlZCgwKS5sZW5ndGggPiBwcmVjKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgdmFyIGkgPSBqIC0gMTsgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykgaS0tO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKSArIHMuc2xpY2Uoaik7XG4gICAgICAgIGkgPSBzLmxlbmd0aDtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcCA9IHByZWM7XG4gICAgICAgIGlmIChleHAgPCAwKSB7IHAgLT0gZXhwICsgMTsgcyA9IHgudG9GaXhlZChwKTsgfVxuICAgICAgICBlbHNlIHdoaWxlIChzID0geC50b0ZpeGVkKHApLCBzLmxlbmd0aCA+IHByZWMgKyAxKSBwLS07XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICAgIHZhciBpID0gcy5sZW5ndGggLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgICAgaWYgKHMuY2hhckF0KGkpID09ICcuJykgaS0tO1xuICAgICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9zdHJpbmcocykge1xuICB2YXIgcmVzO1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKVxuICByZXMgPSArcztcbiAgaWYgKChzLmxlbmd0aCA+IDApICYmIChyZXMgPT09IHJlcykpIHJldHVybiByZXM7XG4gIHMgPSBzLnJlcGxhY2UoL18vZyxcIlwiKTtcbiAgcmVzID0gK3M7XG4gIGlmICgoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgfHwgL15bKy1dP25hbiQvaS50ZXN0KHMpKSByZXR1cm4gcmVzO1xuICB2YXIgbSA9IC9eICooWystXT8pMHgoWzAtOWEtZl0rKVxcLj8oWzAtOWEtZl0qKShwKFsrLV0/WzAtOV0rKSk/L2kuZXhlYyhzKTtcbiAgLy8gICAgICAgICAgMSAgICAgICAgMiAgICAgICAgICAgICAzICAgICAgICAgICA1XG4gIGlmKG0pe1xuICAgIHZhciBtMyA9IG1bM10ucmVwbGFjZSgvMCskLywnJyk7XG4gICAgdmFyIG1hbnRpc3NhID0gcGFyc2VJbnQobVsxXSArIG1bMl0gKyBtMywgMTYpO1xuICAgIHZhciBleHBvbmVudCA9IChtWzVdfDApIC0gNCptMy5sZW5ndGg7XG4gICAgcmVzID0gbWFudGlzc2EgKiBNYXRoLnBvdygyLCBleHBvbmVudCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZigvXlxcKz9pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gSW5maW5pdHk7XG4gIGlmKC9eLWluZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiAtSW5maW5pdHk7XG4gIGNhbWxfZmFpbHdpdGgoXCJmbG9hdF9vZl9zdHJpbmdcIik7XG59XG4iLCIvKlxuVG8gZGVhbCB3aXRoIGVmZmVjdHMsIHRoZSBleGVjdXRpb24gY29udGV4dCBpcyBpbnR1aXRpdmVseSBjb21wb3NlZCBvZlxuYSBzdGFjayBvZiBmaWJlcnMuIEVhY2ggZmliZXIgaGFzIGEgY3VycmVudCBsb3ctbGV2ZWwgY29udGludWF0aW9uXG4ob25lLWFyZ3VtZW50IEphdmFTY3JpcHQgZnVuY3Rpb24pLCBhIHN0YWNrIG9mIGV4Y2VwdGlvbiBoYW5kbGVycyBhbmRcbmEgdHJpcGxlIG9mIGhhbmRsZXJzLCB3aGljaCBhcmUgaW52b2tlZCB3aGVuIHRoZSBmaWJlciB0ZXJtaW5hdGVzXG4oZWl0aGVyIHdpdGggYSB2YWx1ZSBvciBhbiBleGNlcHRpb24pIG9yIHdoZW4gYW4gZWZmZWN0IGlzIHBlcmZvcm1lZC5cblRoZSBsb3ctbGV2ZWwgY29udGludWF0aW9uIG9mIHRoZSB0b3Btb3N0IGZpYmVyICh3aGljaCBpcyBjdXJyZW50bHlcbmV4ZWN1dGluZykgaXMgcGFzc2VkIGZyb20gZnVuY3Rpb24gdG8gZnVuY3Rpb24gYXMgYW4gYWRkaXRpb25hbFxuYXJndW1lbnQuIEl0cyBzdGFjayBvZiBleGNlcHRpb24gaGFuZGxlcnMgaXMgc3RvcmVkIGluXG5bY2FtbF9leG5fc3RhY2tdLiBFeGNlcHRpb24gaGFuZGxlcnMgYXJlIHB1c2hlZCBpbnRvIHRoaXMgc3RhY2sgd2hlblxuZW50ZXJpbmcgYSBbdHJ5IC4uLiB3aXRoIC4uLl0gYW5kIHBvcHBlZCBvbiBleGl0LiBUaGVuLCBoYW5kbGVycyBhbmRcbnRoZSByZW1haW5pbmcgZmliZXJzIGFyZSBzdG9yZWQgaW4gW2NhbWxfZmliZXJfc3RhY2tdLiBUbyBpbnN0YWxsIGFuXG5lZmZlY3QgaGFuZGxlciwgd2UgcHVzaCBhIG5ldyBmaWJlciBpbnRvIHRoZSBleGVjdXRpb24gY29udGV4dC5cblxuV2UgaGF2ZSBiYXNpY2FsbHkgdGhlIGZvbGxvd2luZyB0eXBlIGZvciByZWlmaWVkIGNvbnRpbnVhdGlvbnMgKHR5cGVcbltjb250aW51YXRpb25dIGluIG1vZHVsZSBbRWZmZWN0XSBvZiB0aGUgc3RhbmRhcmQgbGlicmFyeSk6XG5cbiAgdHlwZSAoJ2EsICdiKSBjb250aW51YXRpb24gPSAoJ2EsICdiKSBzdGFjayByZWZcblxuICBhbmQgKF8sIF8pIHN0YWNrID1cbiAgICAgIENvbnMgOiAoJ2IgLT4gdW5pdCkgKiAgICAgICAgICAgICAoKiBsb3ctbGV2ZWwgY29udGludWF0aW9uICopXG4gICAgICAgICAgICAgKGV4biAtPiB1bml0KSBsaXN0ICogICAgICAgKCogZXhjZXB0aW9uIGhhbmRsZXJzICopXG4gICAgICAgICAgICAgKCdiLCAnYykgaGFuZGxlciAqXG4gICAgICAgICAgICAgKCdhLCAnYikgc3RhY2tcbiAgICAgICAgICAgICAtPiAoJ2EsICdjKSBzdGFja1xuICAgIHwgRW1wdHkgOiAoJ2EsICdhKSBzdGFja1xuXG4gIGFuZCAoJ2EsJ2IpIGhhbmRsZXIgPSAgICgqIEFzIGluIG1vZHVsZSBFZmZlY3QgZnJvbSB0aGUgc3RhbmRhcmQgbGlicmFyeSAqKVxuICAgIHsgcmV0YzogJ2EgLT4gJ2I7XG4gICAgICBleG5jOiBleG4gLT4gJ2I7XG4gICAgICBlZmZjOiAnYy4nYyBFZmZlY3QudCAtPiAoKCdjLCdiKSBjb250aW51YXRpb24gLT4gJ2IpIG9wdGlvbiB9XG5cbkNvbnRpbnVhdGlvbnMgYXJlIG9uZS1zaG90LiBBIGNvbnRpbnVhdGlvbiBbcmVmIEVtcHR5XSBoYXMgYWxyZWFkeVxuYmVlbiByZXN1bWVkLlxuXG5BIGNvbnRpbnVhdGlvbiBpcyBiYXNpY2FsbHkgY29tcG9zZWQgb2YgYSBsaXN0IG9mIGZpYmVycywgd2hpY2ggZWFjaFxuaGFzIGl0cyBsb3ctbGV2ZWwgY29udGludWF0aW9uLCBpdHMgc3RhY2sgb2YgZXhjZXB0aW9uIGhhbmRsZXJzIGFuZCBhXG50cmlwbGUgb2YgaGFuZGxlcnMgdG8gZGVhbCB3aXRoIHdoZW4gdGhlIGZpYmVyIHRlcm1pbmF0ZXMgb3IgYW5cbmVmZmVjdCBpcyBwZXJmb3JtZWQuIFdoZW4gcmVzdW1pbmcgYSBjb250aW51YXRpb24sIHRoZSBpbm5lcm1vc3QgZmliZXJcbmlzIHJlc3VtZWQgZmlyc3QuXG5cblRoZSBoYW5kbGVycyBhcmUgQ1BTLXRyYW5zZm9ybWVkIGZ1bmN0aW9uczogdGhleSBhY3R1YWxseSB0YWtlIGFuXG5hZGRpdGlvbmFsIHBhcmFtZXRlciB3aGljaCBpcyB0aGUgY3VycmVudCBsb3ctbGV2ZWwgY29udGludWF0aW9uLlxuKi9cblxuLy9Qcm92aWRlczogY2FtbF9leG5fc3RhY2tcbi8vSWY6IGVmZmVjdHNcbi8vIFRoaXMgaXMgYW4gT0NhbWwgbGlzdCBvZiBleGNlcHRpb24gaGFuZGxlcnNcbnZhciBjYW1sX2V4bl9zdGFjayA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfcHVzaF90cmFwXG4vL1JlcXVpcmVzOiBjYW1sX2V4bl9zdGFja1xuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9wdXNoX3RyYXAoaGFuZGxlcikge1xuICBjYW1sX2V4bl9zdGFjaz1bMCxoYW5kbGVyLGNhbWxfZXhuX3N0YWNrXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wb3BfdHJhcFxuLy9SZXF1aXJlczogY2FtbF9leG5fc3RhY2tcbi8vSWY6IGVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfcG9wX3RyYXAoKSB7XG4gIGlmICghY2FtbF9leG5fc3RhY2spIHJldHVybiBmdW5jdGlvbih4KXt0aHJvdyB4O31cbiAgdmFyIGggPSBjYW1sX2V4bl9zdGFja1sxXTtcbiAgY2FtbF9leG5fc3RhY2s9Y2FtbF9leG5fc3RhY2tbMl07XG4gIHJldHVybiBoXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmliZXJfc3RhY2tcbi8vSWY6IGVmZmVjdHNcbi8vIFRoaXMgaGFzIHRoZSBzaGFwZSB7aCwgcjp7aywgeCwgZX19IHdoZXJlIGggaXMgYSB0cmlwbGUgb2YgaGFuZGxlcnNcbi8vIChzZWUgZWZmZWN0LmpzKSBhbmQgaywgeCBhbmQgZSBhcmUgdGhlIHNhdmVkIGNvbnRpbnVhdGlvbixcbi8vIGV4Y2VwdGlvbiBzdGFjayBhbmQgZmliZXIgc3RhY2sgb2YgdGhlIHBhcmVudCBmaWJlci5cbnZhciBjYW1sX2ZpYmVyX3N0YWNrO1xuXG4vL1Byb3ZpZGVzOmNhbWxfcmVzdW1lX3N0YWNrXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2V4bl9zdGFjaywgY2FtbF9maWJlcl9zdGFja1xuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9yZXN1bWVfc3RhY2soc3RhY2ssIGspIHtcbiAgaWYgKCFzdGFjaykgY2FtbF9yYWlzZV9jb25zdGFudFxuICAgICAgICAgICAgICAgICAoY2FtbF9uYW1lZF92YWx1ZShcIkVmZmVjdC5Db250aW51YXRpb25fYWxyZWFkeV9yZXN1bWVkXCIpKTtcbiAgLy8gVXBkYXRlIHRoZSBleGVjdXRpb24gY29udGV4dCB3aXRoIHRoZSBzdGFjayBvZiBmaWJlcnMgaW4gW3N0YWNrXSBpblxuICAvLyBvcmRlciB0byByZXN1bWUgdGhlIGNvbnRpbnVhdGlvblxuICBkbyB7XG4gICAgY2FtbF9maWJlcl9zdGFjayA9XG4gICAgICB7aDpzdGFja1szXSwgcjp7azprLCB4OmNhbWxfZXhuX3N0YWNrLCBlOmNhbWxfZmliZXJfc3RhY2t9fTtcbiAgICBrID0gc3RhY2tbMV07XG4gICAgY2FtbF9leG5fc3RhY2sgPSBzdGFja1syXTtcbiAgICBzdGFjayA9IHN0YWNrWzRdO1xuICB9IHdoaWxlIChzdGFjaylcbiAgcmV0dXJuIGs7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcG9wX2ZpYmVyXG4vL1JlcXVpcmVzOiBjYW1sX2V4bl9zdGFjaywgY2FtbF9maWJlcl9zdGFja1xuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9wb3BfZmliZXIoKSB7XG4gIC8vIE1vdmUgdG8gdGhlIHBhcmVudCBmaWJlciwgcmV0dXJuaW5nIHRoZSBwYXJlbnQncyBsb3ctbGV2ZWwgY29udGludWF0aW9uXG4gIHZhciByZW0gPSBjYW1sX2ZpYmVyX3N0YWNrLnI7XG4gIGNhbWxfZXhuX3N0YWNrID0gcmVtLng7XG4gIGNhbWxfZmliZXJfc3RhY2sgPSByZW0uZTtcbiAgcmV0dXJuIHJlbS5rO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BlcmZvcm1fZWZmZWN0XG4vL1JlcXVpcmVzOiBjYW1sX3BvcF9maWJlciwgY2FtbF9zdGFja19jaGVja19kZXB0aCwgY2FtbF90cmFtcG9saW5lX3JldHVybiwgY2FtbF9leG5fc3RhY2ssIGNhbWxfZmliZXJfc3RhY2tcbi8vSWY6IGVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfcGVyZm9ybV9lZmZlY3QoZWZmLCBjb250LCBrMCkge1xuICAvLyBBbGxvY2F0ZSBhIGNvbnRpbnVhdGlvbiBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICghY29udCkgY29udCA9IFsyNDUgLypjb250aW51YXRpb24qLywgMF07XG4gIC8vIEdldCBjdXJyZW50IGVmZmVjdCBoYW5kbGVyXG4gIHZhciBoYW5kbGVyID0gY2FtbF9maWJlcl9zdGFjay5oWzNdO1xuICAvLyBDb25zIHRoZSBjdXJyZW50IGZpYmVyIG9udG8gdGhlIGNvbnRpbnVhdGlvbjpcbiAgLy8gICBjb250IDo9IENvbnMgKGssIGV4bl9zdGFjaywgaGFuZGxlcnMsICFjb250KVxuICBjb250WzFdID0gWzAsazAsY2FtbF9leG5fc3RhY2ssY2FtbF9maWJlcl9zdGFjay5oLGNvbnRbMV1dO1xuICAvLyBNb3ZlIHRvIHBhcmVudCBmaWJlciBhbmQgZXhlY3V0ZSB0aGUgZWZmZWN0IGhhbmRsZXIgdGhlcmVcbiAgLy8gVGhlIGhhbmRsZXIgaXMgZGVmaW5lZCBpbiBTdGRsaWIuRWZmZWN0LCBzbyB3ZSBrbm93IHRoYXQgdGhlIGFyaXR5IG1hdGNoZXNcbiAgdmFyIGsxID0gY2FtbF9wb3BfZmliZXIoKTtcbiAgcmV0dXJuIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgoKT9oYW5kbGVyKGVmZixjb250LGsxLGsxKVxuICAgICAgICAgOmNhbWxfdHJhbXBvbGluZV9yZXR1cm4oaGFuZGxlcixbZWZmLGNvbnQsazEsazFdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hbGxvY19zdGFja1xuLy9SZXF1aXJlczogY2FtbF9wb3BfZmliZXIsIGNhbWxfZmliZXJfc3RhY2ssIGNhbWxfY2FsbF9nZW4sIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgsIGNhbWxfdHJhbXBvbGluZV9yZXR1cm5cbi8vSWY6IGVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfYWxsb2Nfc3RhY2soaHYsIGh4LCBoZikge1xuICBmdW5jdGlvbiBjYWxsKGksIHgpIHtcbiAgICB2YXIgZj1jYW1sX2ZpYmVyX3N0YWNrLmhbaV07XG4gICAgdmFyIGFyZ3MgPSBbeCwgY2FtbF9wb3BfZmliZXIoKV07XG4gICAgcmV0dXJuIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgoKT9jYW1sX2NhbGxfZ2VuKGYsYXJncylcbiAgICAgICAgICAgOmNhbWxfdHJhbXBvbGluZV9yZXR1cm4oZixhcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBodmFsKHgpIHtcbiAgICAvLyBDYWxsIFtodl0gaW4gdGhlIHBhcmVudCBmaWJlclxuICAgIHJldHVybiBjYWxsKDEsIHgpO1xuICB9XG4gIGZ1bmN0aW9uIGhleG4oZSkge1xuICAgIC8vIENhbGwgW2h4XSBpbiB0aGUgcGFyZW50IGZpYmVyXG4gICAgcmV0dXJuIGNhbGwoMiwgZSk7XG4gIH1cbiAgcmV0dXJuIFswLCBodmFsLCBbMCwgaGV4biwgMF0sIFswLCBodiwgaHgsIGhmXSwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYWxsb2Nfc3RhY2tcbi8vSWY6ICFlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX2FsbG9jX3N0YWNrKGh2LCBoeCwgaGYpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4Y1xuZnVuY3Rpb24gY2FtbF9jb250aW51YXRpb25fdXNlX25vZXhjKGNvbnQpIHtcbiAgdmFyIHN0YWNrPWNvbnRbMV07XG4gIGNvbnRbMV09MDtcbiAgcmV0dXJuIHN0YWNrO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnRpbnVhdGlvbl91c2VfYW5kX3VwZGF0ZV9oYW5kbGVyX25vZXhjXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnRpbnVhdGlvbl91c2Vfbm9leGNcbmZ1bmN0aW9uIGNhbWxfY29udGludWF0aW9uX3VzZV9hbmRfdXBkYXRlX2hhbmRsZXJfbm9leGMoY29udCwgaHZhbCwgaGV4biwgaGVmZikge1xuICB2YXIgc3RhY2sgPSBjYW1sX2NvbnRpbnVhdGlvbl91c2Vfbm9leGMoY29udCk7XG4gIHN0YWNrWzNdID0gWzAsIGh2YWwsIGhleG4sIGhlZmZdO1xuICByZXR1cm4gc3RhY2s7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2NvbnRpbnVhdGlvbl9jYWxsc3RhY2tcbmZ1bmN0aW9uIGNhbWxfZ2V0X2NvbnRpbnVhdGlvbl9jYWxsc3RhY2sgKCkgeyByZXR1cm4gWzBdOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY29uZGl0aW9uX25ld1xuZnVuY3Rpb24gY2FtbF9tbF9jb25kaXRpb25fbmV3KHVuaXQpe1xuICAgIHJldHVybiB7Y29uZGl0aW9uOjF9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NvbmRpdGlvbl93YWl0XG5mdW5jdGlvbiBjYW1sX21sX2NvbmRpdGlvbl93YWl0KHQsbXV0ZXh0KXtcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jb25kaXRpb25fYnJvYWRjYXN0XG5mdW5jdGlvbiBjYW1sX21sX2NvbmRpdGlvbl9icm9hZGNhc3QodCl7XG4gICAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY29uZGl0aW9uX3NpZ25hbFxuZnVuY3Rpb24gY2FtbF9tbF9jb25kaXRpb25fc2lnbmFsKHQpe1xuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2VmZmVjdF9ub3Rfc3VwcG9ydGVkXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vLyFJZjogZWZmZWN0c1xuZnVuY3Rpb24ganNvb19lZmZlY3Rfbm90X3N1cHBvcnRlZCgpe1xuICBjYW1sX2ZhaWx3aXRoKFwiRWZmZWN0IGhhbmRsZXJzIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIGZzX25vZGVfc3VwcG9ydGVkICgpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGdsb2JhbFRoaXMucHJvY2Vzcy52ZXJzaW9ucyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIHR5cGVvZiBnbG9iYWxUaGlzLnByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gJ3VuZGVmaW5lZCcpXG59XG4vL1Byb3ZpZGVzOiBmc19ub2RlX3N1cHBvcnRlZFxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gZnNfbm9kZV9zdXBwb3J0ZWQgKCkge1xuICByZXR1cm4gZmFsc2Vcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sTm9kZUZkLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV93aXRoX2FyZ3Ncbi8vUmVxdWlyZXM6IG1ha2VfdW5peF9lcnJfYXJncywgY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIE1sTm9kZURldmljZShyb290KSB7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLnJvb3QgPSByb290O1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5pc0ZpbGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSkuaXNGaWxlKCk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUubWtkaXIgPSBmdW5jdGlvbihuYW1lLCBtb2RlLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5ta2RpclN5bmModGhpcy5ubShuYW1lKSx7bW9kZTptb2RlfSk7XG4gICAgcmV0dXJuIDBcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ybWRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJtZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgICByZXR1cm4gMFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlYWRkaXIgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMucmVhZGRpclN5bmModGhpcy5ubShuYW1lKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLnN0YXRTeW5jKHRoaXMubm0obmFtZSkpLmlzRGlyZWN0b3J5KCk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBiID0gdGhpcy5mcy5leGlzdHNTeW5jKHRoaXMubm0obmFtZSkpPzE6MDtcbiAgICB0aGlzLmZzLnVubGlua1N5bmModGhpcy5ubShuYW1lKSk7XG4gICAgcmV0dXJuIGI7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIGNvbnN0cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpO1xuICB2YXIgcmVzID0gMDtcbiAgZm9yKHZhciBrZXkgaW4gZil7XG4gICAgc3dpdGNoKGtleSl7XG4gICAgY2FzZSBcInJkb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19SRE9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJ3cm9ubHlcIiAgOiByZXMgfD0gY29uc3RzLk9fV1JPTkxZOyBicmVhaztcbiAgICBjYXNlIFwiYXBwZW5kXCIgIDpcbiAgICAgIHJlcyB8PSBjb25zdHMuT19XUk9OTFkgfCBjb25zdHMuT19BUFBFTkQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY3JlYXRlXCIgICA6IHJlcyB8PSBjb25zdHMuT19DUkVBVDsgICAgYnJlYWs7XG4gICAgY2FzZSBcInRydW5jYXRlXCIgOiByZXMgfD0gY29uc3RzLk9fVFJVTkM7ICAgIGJyZWFrO1xuICAgIGNhc2UgXCJleGNsXCIgICAgIDogcmVzIHw9IGNvbnN0cy5PX0VYQ0w7ICAgICBicmVhaztcbiAgICBjYXNlIFwiYmluYXJ5XCIgICA6IHJlcyB8PSBjb25zdHMuT19CSU5BUlk7ICAgYnJlYWs7XG4gICAgY2FzZSBcInRleHRcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fVEVYVDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJub25ibG9ja1wiIDogcmVzIHw9IGNvbnN0cy5PX05PTkJMT0NLOyBicmVhaztcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgZmQgPSB0aGlzLmZzLm9wZW5TeW5jKHRoaXMubm0obmFtZSksIHJlcyk7XG4gICAgdmFyIGlzQ2hhcmFjdGVyRGV2aWNlID0gdGhpcy5mcy5sc3RhdFN5bmModGhpcy5ubShuYW1lKSkuaXNDaGFyYWN0ZXJEZXZpY2UoKTtcbiAgICBmLmlzQ2hhcmFjdGVyRGV2aWNlID0gaXNDaGFyYWN0ZXJEZXZpY2U7XG4gICAgcmV0dXJuIG5ldyBNbE5vZGVGZChmZCwgZik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cblxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbihvLCBuLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5yZW5hbWVTeW5jKHRoaXMubm0obyksIHRoaXMubm0obikpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnN0YXQgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGpzX3N0YXRzID0gdGhpcy5mcy5zdGF0U3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgICByZXR1cm4gdGhpcy5zdGF0c19mcm9tX2pzKGpzX3N0YXRzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5sc3RhdCA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB2YXIganNfc3RhdHMgPSB0aGlzLmZzLmxzdGF0U3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgICByZXR1cm4gdGhpcy5zdGF0c19mcm9tX2pzKGpzX3N0YXRzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5zeW1saW5rID0gZnVuY3Rpb24odG9fZGlyLCB0YXJnZXQsIHBhdGgsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnN5bWxpbmtTeW5jKHRoaXMubm0odGFyZ2V0KSwgdGhpcy5ubShwYXRoKSwgdG9fZGlyID8gJ2RpcicgOiAnZmlsZScpO1xuICAgIHJldHVybiAwO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlYWRsaW5rID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBsaW5rID0gdGhpcy5mcy5yZWFkbGlua1N5bmModGhpcy5ubShuYW1lKSwgJ3V0ZjgnKTtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcobGluayk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUub3BlbmRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5vcGVuZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yYWlzZV9ub2RlanNfZXJyb3IgPSBmdW5jdGlvbihlcnIsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSBjYW1sX25hbWVkX3ZhbHVlKFwiVW5peC5Vbml4X2Vycm9yXCIpO1xuICBpZiAocmFpc2VfdW5peCAmJiB1bml4X2Vycm9yKSB7XG4gICAgdmFyIGFyZ3MgPSBtYWtlX3VuaXhfZXJyX2FyZ3MoZXJyLmNvZGUsIGVyci5zeXNjYWxsLCBlcnIucGF0aCwgZXJyLmVycm5vKTtcbiAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuc3RhdHNfZnJvbV9qcyA9IGZ1bmN0aW9uKGpzX3N0YXRzKSB7XG4gIC8qID09PVVuaXguZmlsZV9raW5kPT09XG4gICAqIHR5cGUgZmlsZV9raW5kID1cbiAgICogICAgIFNfUkVHICAgICAgICAgICAgICAgICAgICAgICAoKiogUmVndWxhciBmaWxlICopXG4gICAqICAgfCBTX0RJUiAgICAgICAgICAgICAgICAgICAgICAgKCoqIERpcmVjdG9yeSAqKVxuICAgKiAgIHwgU19DSFIgICAgICAgICAgICAgICAgICAgICAgICgqKiBDaGFyYWN0ZXIgZGV2aWNlICopXG4gICAqICAgfCBTX0JMSyAgICAgICAgICAgICAgICAgICAgICAgKCoqIEJsb2NrIGRldmljZSAqKVxuICAgKiAgIHwgU19MTksgICAgICAgICAgICAgICAgICAgICAgICgqKiBTeW1ib2xpYyBsaW5rICopXG4gICAqICAgfCBTX0ZJRk8gICAgICAgICAgICAgICAgICAgICAgKCoqIE5hbWVkIHBpcGUgKilcbiAgICogICB8IFNfU09DSyAgICAgICAgICAgICAgICAgICAgICAoKiogU29ja2V0ICopXG4gICAqL1xuICB2YXIgZmlsZV9raW5kO1xuICBpZiAoanNfc3RhdHMuaXNGaWxlKCkpIHtcbiAgICBmaWxlX2tpbmQgPSAwO1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICBmaWxlX2tpbmQgPSAxO1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzQ2hhcmFjdGVyRGV2aWNlKCkpIHtcbiAgICBmaWxlX2tpbmQgPSAyO1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzQmxvY2tEZXZpY2UoKSkge1xuICAgIGZpbGVfa2luZCA9IDM7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgIGZpbGVfa2luZCA9IDQ7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNGSUZPKCkpIHtcbiAgICBmaWxlX2tpbmQgPSA1O1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzU29ja2V0KCkpIHtcbiAgICBmaWxlX2tpbmQgPSA2O1xuICB9XG4gIC8qID09PVVuaXguc3RhdHM9PT1cbiAgICogdHlwZSBzdGF0cyA9XG4gICAqICB7IHN0X2RldiA6IGludDsgICAgICAgICAgICAgICAoKiogRGV2aWNlIG51bWJlciAqKVxuICAgKiAgICBzdF9pbm8gOiBpbnQ7ICAgICAgICAgICAgICAgKCoqIElub2RlIG51bWJlciAqKVxuICAgKiAgICBzdF9raW5kIDogZmlsZV9raW5kOyAgICAgICAgKCoqIEtpbmQgb2YgdGhlIGZpbGUgKilcbiAgICogICAgc3RfcGVybSA6IGZpbGVfcGVybTsgICAgICAgICgqKiBBY2Nlc3MgcmlnaHRzICopXG4gICAqICAgIHN0X25saW5rIDogaW50OyAgICAgICAgICAgICAoKiogTnVtYmVyIG9mIGxpbmtzICopXG4gICAqICAgIHN0X3VpZCA6IGludDsgICAgICAgICAgICAgICAoKiogVXNlciBpZCBvZiB0aGUgb3duZXIgKilcbiAgICogICAgc3RfZ2lkIDogaW50OyAgICAgICAgICAgICAgICgqKiBHcm91cCBJRCBvZiB0aGUgZmlsZSdzIGdyb3VwICopXG4gICAqICAgIHN0X3JkZXYgOiBpbnQ7ICAgICAgICAgICAgICAoKiogRGV2aWNlIElEIChpZiBzcGVjaWFsIGZpbGUpICopXG4gICAqICAgIHN0X3NpemUgOiBpbnQ7ICAgICAgICAgICAgICAoKiogU2l6ZSBpbiBieXRlcyAqKVxuICAgKiAgICBzdF9hdGltZSA6IGZsb2F0OyAgICAgICAgICAgKCoqIExhc3QgYWNjZXNzIHRpbWUgKilcbiAgICogICAgc3RfbXRpbWUgOiBmbG9hdDsgICAgICAgICAgICgqKiBMYXN0IG1vZGlmaWNhdGlvbiB0aW1lICopXG4gICAqICAgIHN0X2N0aW1lIDogZmxvYXQ7ICAgICAgICAgICAoKiogTGFzdCBzdGF0dXMgY2hhbmdlIHRpbWUgKilcbiAgICogIH1cbiAgICovXG4gIHJldHVybiBCTE9DSyhcbiAgICAwLFxuICAgIGpzX3N0YXRzLmRldixcbiAgICBqc19zdGF0cy5pbm8sXG4gICAgZmlsZV9raW5kLFxuICAgIGpzX3N0YXRzLm1vZGUsXG4gICAganNfc3RhdHMubmxpbmssXG4gICAganNfc3RhdHMudWlkLFxuICAgIGpzX3N0YXRzLmdpZCxcbiAgICBqc19zdGF0cy5yZGV2LFxuICAgIGpzX3N0YXRzLnNpemUsXG4gICAganNfc3RhdHMuYXRpbWVNcyxcbiAgICBqc19zdGF0cy5tdGltZU1zLFxuICAgIGpzX3N0YXRzLmN0aW1lTXNcbiAgKTtcbn1cblxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZURldmljZVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVEZXZpY2Vcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIE1sTm9kZURldmljZSgpIHtcbn1cblxuLy9Qcm92aWRlczogTWxOb2RlRmRcbi8vUmVxdWlyZXM6IE1sRmlsZSwgY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcsIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMsIGNhbWxfYnl0ZXNfc2V0LCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gTWxOb2RlRmQoZmQsIGZsYWdzKXtcbiAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHRoaXMuZmQgPSBmZDtcbiAgdGhpcy5mbGFncyA9IGZsYWdzO1xufVxuTWxOb2RlRmQucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcbk1sTm9kZUZkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZUZkO1xuXG5NbE5vZGVGZC5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB0cnkge1xuICAgIHRoaXMuZnMuZnRydW5jYXRlU3luYyh0aGlzLmZkLGxlbnwwKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVGZC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLmZzdGF0U3luYyh0aGlzLmZkKS5zaXplO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZUZkLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYsYnVmX29mZnNldCxsZW4pe1xuICB0cnkge1xuICAgIGlmKHRoaXMuZmxhZ3MuaXNDaGFyYWN0ZXJEZXZpY2UpXG4gICAgICB0aGlzLmZzLndyaXRlU3luYyh0aGlzLmZkLCBidWYsIGJ1Zl9vZmZzZXQsIGxlbik7XG4gICAgZWxzZVxuICAgICAgdGhpcy5mcy53cml0ZVN5bmModGhpcy5mZCwgYnVmLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbk1sTm9kZUZkLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24ob2Zmc2V0LGEsYnVmX29mZnNldCxsZW4pe1xuICB0cnkge1xuICAgIGlmKHRoaXMuZmxhZ3MuaXNDaGFyYWN0ZXJEZXZpY2UpXG4gICAgICB2YXIgcmVhZCA9IHRoaXMuZnMucmVhZFN5bmModGhpcy5mZCwgYSwgYnVmX29mZnNldCwgbGVuKTtcbiAgICBlbHNlXG4gICAgICB2YXIgcmVhZCA9IHRoaXMuZnMucmVhZFN5bmModGhpcy5mZCwgYSwgYnVmX29mZnNldCwgbGVuLCBvZmZzZXQpO1xuICAgIHJldHVybiByZWFkO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZUZkLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5jbG9zZVN5bmModGhpcy5mZCk7XG4gICAgcmV0dXJuIDBcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5cblxuLy9Qcm92aWRlczogTWxOb2RlRmRcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIE1sTm9kZUZkKCl7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZVxuLy9SZXF1aXJlczogTWxOb2RlRmRcbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW5fZm9yX25vZGUoZmQsIGZsYWdzKXtcbiAgaWYoZmxhZ3MubmFtZSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgZnMgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgICB2YXIgZmQyID0gZnMub3BlblN5bmMoZmxhZ3MubmFtZSwgXCJyc1wiKTtcbiAgICAgIHJldHVybiBuZXcgTWxOb2RlRmQoZmQyLCBmbGFncyk7XG4gICAgfSBjYXRjaChlKSB7ICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBNbE5vZGVGZChmZCwgZmxhZ3MpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlKGZkLCBmbGFncyl7XG4gIHJldHVybiBudWxsO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBEdW1teSBmaWxlc3lzdGVtXG5cbi8vUHJvdmlkZXM6IGNhbWxfdHJhaWxpbmdfc2xhc2hcbmZ1bmN0aW9uIGNhbWxfdHJhaWxpbmdfc2xhc2gobmFtZSl7XG4gIHJldHVybiAobmFtZS5zbGljZSgtMSkgIT09IFwiL1wiKSA/IChuYW1lICsgXCIvXCIpIDogbmFtZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jdXJyZW50X2RpclxuLy9SZXF1aXJlczogY2FtbF90cmFpbGluZ19zbGFzaCwgZnNfbm9kZV9zdXBwb3J0ZWRcbmlmKGZzX25vZGVfc3VwcG9ydGVkICgpICYmIGdsb2JhbFRoaXMucHJvY2VzcyAmJiBnbG9iYWxUaGlzLnByb2Nlc3MuY3dkKVxuICB2YXIgY2FtbF9jdXJyZW50X2RpciA9IGdsb2JhbFRoaXMucHJvY2Vzcy5jd2QoKS5yZXBsYWNlKC9cXFxcL2csJy8nKTtcbmVsc2VcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSAgXCIvc3RhdGljXCI7XG5jYW1sX2N1cnJlbnRfZGlyID0gY2FtbF90cmFpbGluZ19zbGFzaChjYW1sX2N1cnJlbnRfZGlyKTtcblxuLy9Qcm92aWRlczogY2FtbF9nZXRfcm9vdFxuLy9SZXF1aXJlczogcGF0aF9pc19hYnNvbHV0ZVxuZnVuY3Rpb24gY2FtbF9nZXRfcm9vdChwYXRoKXtcbiAgdmFyIHggPSBwYXRoX2lzX2Fic29sdXRlKHBhdGgpO1xuICBpZiAoIXgpIHJldHVybjtcbiAgcmV0dXJuIHhbMF0gKyBcIi9cIn1cblxuLy9Qcm92aWRlczogY2FtbF9yb290XG4vL1JlcXVpcmVzOiBjYW1sX2dldF9yb290LCBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX2ZhaWx3aXRoXG52YXIgY2FtbF9yb290ID0gY2FtbF9nZXRfcm9vdChjYW1sX2N1cnJlbnRfZGlyKSB8fCBjYW1sX2ZhaWx3aXRoKFwidW5hYmxlIHRvIGNvbXB1dGUgY2FtbF9yb290XCIpO1xuXG5cbi8vUHJvdmlkZXM6IE1sRmlsZVxuZnVuY3Rpb24gTWxGaWxlKCl7ICB9XG5cbi8vUHJvdmlkZXM6IHBhdGhfaXNfYWJzb2x1dGVcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiBtYWtlX3BhdGhfaXNfYWJzb2x1dGUoKSB7XG4gIGZ1bmN0aW9uIHBvc2l4KHBhdGgpIHtcbiAgICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykgcmV0dXJuIFtcIlwiLCBwYXRoLnN1YnN0cmluZygxKV07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gd2luMzIocGF0aCkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2IzZmNjMjQ1ZmIyNTUzOTkwOWVmMWQ1ZWFhMDFkYmY5MmUxNjg2MzMvbGliL3BhdGguanMjTDU2XG4gICAgdmFyIHNwbGl0RGV2aWNlUmUgPSAvXihbYS16QS1aXTp8W1xcXFwvXXsyfVteXFxcXC9dK1tcXFxcL10rW15cXFxcL10rKT8oW1xcXFwvXSk/KFtcXHNcXFNdKj8pJC87XG4gICAgdmFyIHJlc3VsdCA9IHNwbGl0RGV2aWNlUmUuZXhlYyhwYXRoKTtcbiAgICB2YXIgZGV2aWNlID0gcmVzdWx0WzFdIHx8ICcnO1xuICAgIHZhciBpc1VuYyA9IEJvb2xlYW4oZGV2aWNlICYmIGRldmljZS5jaGFyQXQoMSkgIT09ICc6Jyk7XG5cbiAgICAvLyBVTkMgcGF0aHMgYXJlIGFsd2F5cyBhYnNvbHV0ZVxuICAgIGlmIChCb29sZWFuKHJlc3VsdFsyXSB8fCBpc1VuYykpIHtcbiAgICAgIHZhciByb290ID0gKHJlc3VsdFsxXSB8fCAnJyk7XG4gICAgICB2YXIgc2VwID0gKHJlc3VsdFsyXSB8fCAnJyk7XG4gICAgICByZXR1cm4gW3Jvb3QsIHBhdGguc3Vic3RyaW5nKHJvb3QubGVuZ3RoICsgc2VwLmxlbmd0aCldXG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZihmc19ub2RlX3N1cHBvcnRlZCAoKSAmJiBnbG9iYWxUaGlzLnByb2Nlc3MgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMucHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHdpbjMyIDogcG9zaXg7XG4gIH1cbiAgZWxzZSByZXR1cm4gcG9zaXhcbn1cbnZhciBwYXRoX2lzX2Fic29sdXRlID0gbWFrZV9wYXRoX2lzX2Fic29sdXRlKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9wYXRoXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZywgcGF0aF9pc19hYnNvbHV0ZVxuZnVuY3Rpb24gY2FtbF9tYWtlX3BhdGggKG5hbWUpIHtcbiAgbmFtZT1jYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYoICFwYXRoX2lzX2Fic29sdXRlKG5hbWUpIClcbiAgICBuYW1lID0gY2FtbF9jdXJyZW50X2RpciArIG5hbWU7XG4gIHZhciBjb21wMCA9IHBhdGhfaXNfYWJzb2x1dGUobmFtZSk7XG4gIHZhciBjb21wID0gY29tcDBbMV0uc3BsaXQoXCIvXCIpO1xuICB2YXIgbmNvbXAgPSBbXVxuICBmb3IodmFyIGkgPSAwOyBpPGNvbXAubGVuZ3RoOyBpKyspe1xuICAgIHN3aXRjaChjb21wW2ldKXtcbiAgICBjYXNlIFwiLi5cIjogaWYobmNvbXAubGVuZ3RoPjEpIG5jb21wLnBvcCgpOyBicmVhaztcbiAgICBjYXNlIFwiLlwiOiBicmVhaztcbiAgICBjYXNlIFwiXCI6IGJyZWFrO1xuICAgIGRlZmF1bHQ6IG5jb21wLnB1c2goY29tcFtpXSk7YnJlYWtcbiAgICB9XG4gIH1cbiAgbmNvbXAudW5zaGlmdChjb21wMFswXSk7XG4gIG5jb21wLm9yaWcgPSBuYW1lO1xuICByZXR1cm4gbmNvbXA7XG59XG5cbi8vUHJvdmlkZXM6anNvb19tb3VudF9wb2ludFxuLy9SZXF1aXJlczogTWxGYWtlRGV2aWNlLCBNbE5vZGVEZXZpY2UsIGNhbWxfcm9vdCwgZnNfbm9kZV9zdXBwb3J0ZWRcbnZhciBqc29vX21vdW50X3BvaW50ID0gW11cbmlmIChmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QsZGV2aWNlOm5ldyBNbE5vZGVEZXZpY2UoY2FtbF9yb290KX0pO1xufSBlbHNlIHtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCxkZXZpY2U6bmV3IE1sRmFrZURldmljZShjYW1sX3Jvb3QpfSk7XG59XG5qc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6XCIvc3RhdGljL1wiLCBkZXZpY2U6bmV3IE1sRmFrZURldmljZShcIi9zdGF0aWMvXCIpfSk7XG5cbi8vUHJvdmlkZXM6Y2FtbF9saXN0X21vdW50X3BvaW50XG4vL1JlcXVpcmVzOiBqc29vX21vdW50X3BvaW50LCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xpc3RfbW91bnRfcG9pbnQoKXtcbiAgdmFyIHByZXYgPSAwXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKXtcbiAgICB2YXIgb2xkID0gcHJldjtcbiAgICBwcmV2ID0gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoanNvb19tb3VudF9wb2ludFtpXS5wYXRoKSwgb2xkXVxuICB9XG4gIHJldHVybiBwcmV2O1xufVxuXG4vL1Byb3ZpZGVzOiByZXNvbHZlX2ZzX2RldmljZVxuLy9SZXF1aXJlczogY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX2dldF9yb290LCBNbE5vZGVEZXZpY2UsIGNhbWxfdHJhaWxpbmdfc2xhc2gsIGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiByZXNvbHZlX2ZzX2RldmljZShuYW1lKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBwYXRoLmpvaW4oXCIvXCIpO1xuICB2YXIgbmFtZV9zbGFzaCA9IGNhbWxfdHJhaWxpbmdfc2xhc2gobmFtZSk7XG4gIHZhciByZXM7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG0gPSBqc29vX21vdW50X3BvaW50W2ldO1xuICAgIGlmKG5hbWVfc2xhc2guc2VhcmNoKG0ucGF0aCkgPT0gMFxuICAgICAgICYmICghcmVzIHx8IHJlcy5wYXRoLmxlbmd0aCA8IG0ucGF0aC5sZW5ndGgpKVxuICAgICAgcmVzID0ge3BhdGg6bS5wYXRoLGRldmljZTptLmRldmljZSxyZXN0Om5hbWUuc3Vic3RyaW5nKG0ucGF0aC5sZW5ndGgsbmFtZS5sZW5ndGgpfTtcbiAgfVxuICBpZiggIXJlcyAmJiBmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgdmFyIHJvb3QgPSBjYW1sX2dldF9yb290KG5hbWUpO1xuICAgIGlmIChyb290ICYmIHJvb3QubWF0Y2goL15bYS16QS1aXTpcXC8kLykpe1xuICAgICAgdmFyIG0gPSB7cGF0aDpyb290LGRldmljZTpuZXcgTWxOb2RlRGV2aWNlKHJvb3QpfTtcbiAgICAgIGpzb29fbW91bnRfcG9pbnQucHVzaChtKTtcbiAgICAgIHJlcyA9IHtwYXRoOm0ucGF0aCxkZXZpY2U6bS5kZXZpY2UscmVzdDpuYW1lLnN1YnN0cmluZyhtLnBhdGgubGVuZ3RoLG5hbWUubGVuZ3RoKX07XG4gICAgfVxuICB9XG4gIGlmKCByZXMgKSByZXR1cm4gcmVzO1xuICBjYW1sX3JhaXNlX3N5c19lcnJvcihcIm5vIGRldmljZSBmb3VuZCBmb3IgXCIgKyBuYW1lX3NsYXNoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tb3VudF9hdXRvbG9hZFxuLy9SZXF1aXJlczogTWxGYWtlRGV2aWNlLCBjYW1sX21ha2VfcGF0aCwganNvb19tb3VudF9wb2ludCwgY2FtbF90cmFpbGluZ19zbGFzaFxuZnVuY3Rpb24gY2FtbF9tb3VudF9hdXRvbG9hZChuYW1lLGYpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IGNhbWxfdHJhaWxpbmdfc2xhc2gocGF0aC5qb2luKFwiL1wiKSk7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpuYW1lLGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKG5hbWUsZil9KVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bm1vdW50XG4vL1JlcXVpcmVzOiBqc29vX21vdW50X3BvaW50LCBjYW1sX21ha2VfcGF0aCwgY2FtbF90cmFpbGluZ19zbGFzaFxuZnVuY3Rpb24gY2FtbF91bm1vdW50KG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IGNhbWxfdHJhaWxpbmdfc2xhc2gocGF0aC5qb2luKFwiL1wiKSk7XG4gIHZhciBpZHggPSAtMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspXG4gICAgaWYoanNvb19tb3VudF9wb2ludFtpXS5wYXRoID09IG5hbWUpIGlkeCA9IGk7XG4gIGlmKGlkeCA+IC0xKSBqc29vX21vdW50X3BvaW50LnNwbGljZShpZHgsMSk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldGN3ZFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0Y3dkKCkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjYW1sX2N1cnJlbnRfZGlyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY2hkaXJcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXIsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF90cmFpbGluZ19zbGFzaCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfY2hkaXIoZGlyKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UoZGlyKTtcbiAgaWYocm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCkpIHtcbiAgICBpZihyb290LnJlc3QpIGNhbWxfY3VycmVudF9kaXIgPSBjYW1sX3RyYWlsaW5nX3NsYXNoKHJvb3QucGF0aCArIHJvb3QucmVzdCk7XG4gICAgZWxzZSBjYW1sX2N1cnJlbnRfZGlyID0gcm9vdC5wYXRoO1xuICAgIHJldHVybiAwO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKGNhbWxfanNieXRlc19vZl9zdHJpbmcoZGlyKSk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKXtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG5hbWUgKyBcIjogTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub3RfYV9kaXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vdF9hX2RpcihuYW1lKXtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19maWxlX2V4aXN0c1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2ZpbGVfZXhpc3RzIChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJldHVybiByb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVhZF9kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2FfZGlyLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnkobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBhID0gcm9vdC5kZXZpY2UucmVhZGRpcihyb290LnJlc3QpO1xuICB2YXIgbCA9IG5ldyBBcnJheShhLmxlbmd0aCArIDEpO1xuICBsWzBdID0gMDtcbiAgZm9yKHZhciBpPTA7aTxhLmxlbmd0aDtpKyspXG4gICAgbFtpKzFdID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhhW2ldKTtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbW92ZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19yZW1vdmUobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBvayA9IHJvb3QuZGV2aWNlLnVubGluayhyb290LnJlc3QpO1xuICBpZihvayA9PSAwKSBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5pc19kaXIocm9vdC5yZXN0KTtcbiAgcmV0dXJuIGE/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW5hbWVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZW5hbWUobyxuKXtcbiAgdmFyIG9fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG8pO1xuICB2YXIgbl9yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobik7XG4gIGlmKG9fcm9vdC5kZXZpY2UgIT0gbl9yb290LmRldmljZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBjYW5ub3QgbW92ZSBmaWxlIGJldHdlZW4gdHdvIGZpbGVzeXN0ZW1cIik7XG4gIGlmKCFvX3Jvb3QuZGV2aWNlLnJlbmFtZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBubyBpbXBsZW1lbnRlZFwiKTtcbiAgb19yb290LmRldmljZS5yZW5hbWUob19yb290LnJlc3QsIG5fcm9vdC5yZXN0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfbWtkaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9zeXNfbWtkaXIobmFtZSwgcGVybSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJvb3QuZGV2aWNlLm1rZGlyKHJvb3QucmVzdCxwZXJtKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JtZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfcmFpc2Vfbm90X2FfZGlyXG5mdW5jdGlvbiBjYW1sX3N5c19ybWRpcihuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcm9vdC5kZXZpY2Uucm1kaXIocm9vdC5yZXN0KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbWFwX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfYmFfbWFwX2ZpbGUodmZkLCBraW5kLCBsYXlvdXQsIHNoYXJlZCwgZGltcywgcG9zKSB7XG4gIC8vIHZhciBkYXRhID0gY2FtbF9zeXNfZmRzW3ZmZF07XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2JhX21hcF9maWxlIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZVxuLy9SZXF1aXJlczogY2FtbF9iYV9tYXBfZmlsZVxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZShhcmd2LGFyZ24pe1xuICByZXR1cm4gY2FtbF9iYV9tYXBfZmlsZShhcmd2WzBdLGFyZ3ZbMV0sYXJndlsyXSxhcmd2WzNdLGFyZ3ZbNF0sYXJndls1XSk7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29fY3JlYXRlX2ZpbGVfZXh0ZXJuXG5mdW5jdGlvbiBqc29vX2NyZWF0ZV9maWxlX2V4dGVybihuYW1lLGNvbnRlbnQpe1xuICBpZihnbG9iYWxUaGlzLmpzb29fY3JlYXRlX2ZpbGUpXG4gICAgZ2xvYmFsVGhpcy5qc29vX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCk7XG4gIGVsc2Uge1xuICAgIGlmKCFnbG9iYWxUaGlzLmNhbWxfZnNfdG1wKSBnbG9iYWxUaGlzLmNhbWxfZnNfdG1wID0gW107XG4gICAgZ2xvYmFsVGhpcy5jYW1sX2ZzX3RtcC5wdXNoKHtuYW1lOm5hbWUsY29udGVudDpjb250ZW50fSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZnNfaW5pdFxuLy9SZXF1aXJlczoganNvb19jcmVhdGVfZmlsZVxuZnVuY3Rpb24gY2FtbF9mc19pbml0ICgpe1xuICB2YXIgdG1wPWdsb2JhbFRoaXMuY2FtbF9mc190bXBcbiAgaWYodG1wKXtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgaSsrKXtcbiAgICAgIGpzb29fY3JlYXRlX2ZpbGUodG1wW2ldLm5hbWUsdG1wW2ldLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxuICBnbG9iYWxUaGlzLmpzb29fY3JlYXRlX2ZpbGUgPSBqc29vX2NyZWF0ZV9maWxlO1xuICBnbG9iYWxUaGlzLmNhbWxfZnNfdG1wID0gW107XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYoISByb290LmRldmljZS5yZWdpc3RlcikgY2FtbF9mYWlsd2l0aChcImNhbm5vdCByZWdpc3RlciBmaWxlXCIpO1xuICByb290LmRldmljZS5yZWdpc3Rlcihyb290LnJlc3QsY29udGVudCk7XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGpzb29fY3JlYXRlX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2ZpbGUsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGpzb29fY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KSB7XG4gIHZhciBuYW1lID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKTtcbiAgdmFyIGNvbnRlbnQgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNvbnRlbnQpO1xuICByZXR1cm4gY2FtbF9jcmVhdGVfZmlsZShuYW1lLCBjb250ZW50KTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlYWRfZmlsZV9jb250ZW50XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JlYWRfZmlsZV9jb250ZW50IChuYW1lKSB7XG4gIHZhciBuYW1lID0gKHR5cGVvZiBuYW1lID09IFwic3RyaW5nXCIpP2NhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSk6bmFtZTtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYocm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCkpIHtcbiAgICB2YXIgZmlsZSA9IHJvb3QuZGV2aWNlLm9wZW4ocm9vdC5yZXN0LHtyZG9ubHk6MX0pO1xuICAgIHZhciBsZW4gID0gZmlsZS5sZW5ndGgoKTtcbiAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBmaWxlLnJlYWQoMCxidWYsMCxsZW4pO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheShidWYpXG4gIH1cbiAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSk7XG59XG4iLCIvL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZ2V0dGltZW9mZGF5XG4vL0FsaWFzOiB1bml4X2dldHRpbWVvZmRheVxuZnVuY3Rpb24gY2FtbF91bml4X2dldHRpbWVvZmRheSAoKSB7XG4gIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC8gMTAwMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3RpbWVcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9nZXR0aW1lb2ZkYXlcbi8vQWxpYXM6IHVuaXhfdGltZVxuZnVuY3Rpb24gY2FtbF91bml4X3RpbWUgKCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihjYW1sX3VuaXhfZ2V0dGltZW9mZGF5ICgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2dtdGltZVxuLy9BbGlhczogdW5peF9nbXRpbWVcbmZ1bmN0aW9uIGNhbWxfdW5peF9nbXRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgZF9udW0gPSBkLmdldFRpbWUoKTtcbiAgdmFyIGphbnVhcnlmaXJzdCA9IChuZXcgRGF0ZShEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEpKSkuZ2V0VGltZSgpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZF9udW0gLSBqYW51YXJ5Zmlyc3QpIC8gODY0MDAwMDApO1xuICByZXR1cm4gQkxPQ0soMCwgZC5nZXRVVENTZWNvbmRzKCksIGQuZ2V0VVRDTWludXRlcygpLCBkLmdldFVUQ0hvdXJzKCksXG4gICAgICAgICAgICAgICBkLmdldFVUQ0RhdGUoKSwgZC5nZXRVVENNb250aCgpLCBkLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwLFxuICAgICAgICAgICAgICAgZC5nZXRVVENEYXkoKSwgZG95LFxuICAgICAgICAgICAgICAgZmFsc2UgfCAwIC8qIGZvciBVVEMgZGF5bGlnaHQgc2F2aW5ncyB0aW1lIGlzIGZhbHNlICovKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfbG9jYWx0aW1lXG4vL0FsaWFzOiB1bml4X2xvY2FsdGltZVxuZnVuY3Rpb24gY2FtbF91bml4X2xvY2FsdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSkpLmdldFRpbWUoKTtcbiAgdmFyIGRveSA9IE1hdGguZmxvb3IoKGRfbnVtIC0gamFudWFyeWZpcnN0KSAvIDg2NDAwMDAwKTtcbiAgdmFyIGphbiA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gIHZhciBqdWwgPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDYsIDEpO1xuICB2YXIgc3RkVGltZXpvbmVPZmZzZXQgPSBNYXRoLm1heChqYW4uZ2V0VGltZXpvbmVPZmZzZXQoKSwganVsLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICByZXR1cm4gQkxPQ0soMCwgZC5nZXRTZWNvbmRzKCksIGQuZ2V0TWludXRlcygpLCBkLmdldEhvdXJzKCksXG4gICAgICAgICAgICAgICBkLmdldERhdGUoKSwgZC5nZXRNb250aCgpLCBkLmdldEZ1bGxZZWFyKCkgLSAxOTAwLFxuICAgICAgICAgICAgICAgZC5nZXREYXkoKSwgZG95LFxuICAgICAgICAgICAgICAgKGQuZ2V0VGltZXpvbmVPZmZzZXQoKSA8IHN0ZFRpbWV6b25lT2Zmc2V0KSB8IDAgLyogZGF5bGlnaHQgc2F2aW5ncyB0aW1lICBmaWVsZC4gKi8pXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9ta3RpbWVcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9sb2NhbHRpbWVcbi8vQWxpYXM6IHVuaXhfbWt0aW1lXG5mdW5jdGlvbiBjYW1sX3VuaXhfbWt0aW1lKHRtKXtcbiAgdmFyIGQgPSAobmV3IERhdGUodG1bNl0rMTkwMCx0bVs1XSx0bVs0XSx0bVszXSx0bVsyXSx0bVsxXSkpLmdldFRpbWUoKTtcbiAgdmFyIHQgPSBNYXRoLmZsb29yKGQgLyAxMDAwKTtcbiAgdmFyIHRtMiA9IGNhbWxfdW5peF9sb2NhbHRpbWUodCk7XG4gIHJldHVybiBCTE9DSygwLHQsdG0yKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9zdGFydHVwIGNvbnN0XG4vL0FsaWFzOiB3aW5fc3RhcnR1cFxuZnVuY3Rpb24gY2FtbF91bml4X3N0YXJ0dXAoKSB7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfY2xlYW51cCBjb25zdFxuLy9BbGlhczogd2luX2NsZWFudXBcbmZ1bmN0aW9uIGNhbWxfdW5peF9jbGVhbnVwKCkge31cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2ZpbGVkZXNjcl9vZl9mZCBjb25zdFxuLy9BbGlhczogd2luX2hhbmRsZV9mZFxuZnVuY3Rpb24gY2FtbF91bml4X2ZpbGVkZXNjcl9vZl9mZCh4KSB7cmV0dXJuIHg7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfaXNhdHR5XG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuLy9BbGlhczogdW5peF9pc2F0dHlcbmZ1bmN0aW9uIGNhbWxfdW5peF9pc2F0dHkoZmlsZURlc2NyaXB0b3IpIHtcbiAgaWYoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICAgIHZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcbiAgICByZXR1cm4gdHR5LmlzYXR0eShmaWxlRGVzY3JpcHRvcik/MTowO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2lzYXR0eVxuLy9BbGlhczogdW5peF9pc2F0dHlcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9pc2F0dHkoZmlsZURlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG1ha2VfdW5peF9lcnJfYXJnc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbnZhciB1bml4X2Vycm9yID0gW1xuICAvKiA9PT1Vbml4LmVycm9yPT09XG4gICAqXG4gICAqIFRoaXMgYXJyYXkgaXMgaW4gb3JkZXIgb2YgdGhlIHZhcmlhbnQgaW4gT0NhbWxcbiAgICovXG4gIFwiRTJCSUdcIiwgXCJFQUNDRVNcIiwgXCJFQUdBSU5cIiwgXCJFQkFERlwiLCBcIkVCVVNZXCIsIFwiRUNISUxEXCIsIFwiRURFQURMS1wiLCBcIkVET01cIixcbiAgXCJFRVhJU1RcIiwgXCJFRkFVTFRcIiwgXCJFRkJJR1wiLCBcIkVJTlRSXCIsIFwiRUlOVkFMXCIsIFwiRUlPXCIsIFwiRUlTRElSXCIsIFwiRU1GSUxFXCIsXG4gIFwiRU1MSU5LXCIsIFwiRU5BTUVUT09MT05HXCIsIFwiRU5GSUxFXCIsIFwiRU5PREVWXCIsIFwiRU5PRU5UXCIsIFwiRU5PRVhFQ1wiLCBcIkVOT0xDS1wiLFxuICBcIkVOT01FTVwiLCBcIkVOT1NQQ1wiLCBcIkVOT1NZU1wiLCBcIkVOT1RESVJcIiwgXCJFTk9URU1QVFlcIiwgXCJFTk9UVFlcIiwgXCJFTlhJT1wiLFxuICBcIkVQRVJNXCIsIFwiRVBJUEVcIiwgXCJFUkFOR0VcIiwgXCJFUk9GU1wiLCBcIkVTUElQRVwiLCBcIkVTUkNIXCIsIFwiRVhERVZcIiwgXCJFV09VTERCTE9DS1wiLFxuICBcIkVJTlBST0dSRVNTXCIsIFwiRUFMUkVBRFlcIiwgXCJFTk9UU09DS1wiLCBcIkVERVNUQUREUlJFUVwiLCBcIkVNU0dTSVpFXCIsXG4gIFwiRVBST1RPVFlQRVwiLCBcIkVOT1BST1RPT1BUXCIsIFwiRVBST1RPTk9TVVBQT1JUXCIsIFwiRVNPQ0tUTk9TVVBQT1JUXCIsXG4gIFwiRU9QTk9UU1VQUFwiLCBcIkVQRk5PU1VQUE9SVFwiLCBcIkVBRk5PU1VQUE9SVFwiLCBcIkVBRERSSU5VU0VcIiwgXCJFQUREUk5PVEFWQUlMXCIsXG4gIFwiRU5FVERPV05cIiwgXCJFTkVUVU5SRUFDSFwiLCBcIkVORVRSRVNFVFwiLCBcIkVDT05OQUJPUlRFRFwiLCBcIkVDT05OUkVTRVRcIiwgXCJFTk9CVUZTXCIsXG4gIFwiRUlTQ09OTlwiLCBcIkVOT1RDT05OXCIsIFwiRVNIVVRET1dOXCIsIFwiRVRPT01BTllSRUZTXCIsIFwiRVRJTUVET1VUXCIsIFwiRUNPTk5SRUZVU0VEXCIsXG4gIFwiRUhPU1RET1dOXCIsIFwiRUhPU1RVTlJFQUNIXCIsIFwiRUxPT1BcIiwgXCJFT1ZFUkZMT1dcIlxuXTtcbmZ1bmN0aW9uIG1ha2VfdW5peF9lcnJfYXJncyhjb2RlLCBzeXNjYWxsLCBwYXRoLCBlcnJubykge1xuICB2YXIgdmFyaWFudCA9IHVuaXhfZXJyb3IuaW5kZXhPZihjb2RlKTtcbiAgaWYgKHZhcmlhbnQgPCAwKSB7XG4gICAgLy8gRGVmYXVsdCBpZiB1bmRlZmluZWRcbiAgICBpZiAoZXJybm8gPT0gbnVsbCkge1xuICAgICAgZXJybm8gPSAtOTk5OVxuICAgIH1cbiAgICAvLyBJZiBub25lIG9mIHRoZSBhYm92ZSB2YXJpYW50cywgZmFsbGJhY2sgdG8gRVVOS05PV05FUlIoaW50KVxuICAgIHZhcmlhbnQgPSBCTE9DSygwLCBlcnJubyk7XG4gIH1cbiAgdmFyIGFyZ3MgPSBbXG4gICAgdmFyaWFudCxcbiAgICBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhzeXNjYWxsIHx8IFwiXCIpLFxuICAgIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHBhdGggfHwgXCJcIilcbiAgXTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9zdGF0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9zdGF0XG5mdW5jdGlvbiBjYW1sX3VuaXhfc3RhdChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2Uuc3RhdCkge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfc3RhdDogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5zdGF0KHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3N0YXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9zdGF0LCBjYW1sX2ludDY0X29mX2ludDMyXG4vL0FsaWFzOiB1bml4X3N0YXRfNjRcbmZ1bmN0aW9uIGNhbWxfdW5peF9zdGF0XzY0KG5hbWUpIHtcbiAgdmFyIHIgPSBjYW1sX3VuaXhfc3RhdChuYW1lKTtcbiAgcls5XSA9IGNhbWxfaW50NjRfb2ZfaW50MzIocls5XSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9sc3RhdFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfbHN0YXRcbmZ1bmN0aW9uIGNhbWxfdW5peF9sc3RhdChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UubHN0YXQpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X2xzdGF0OiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLmxzdGF0KHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2xzdGF0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfbHN0YXQsIGNhbWxfaW50NjRfb2ZfaW50MzJcbi8vQWxpYXM6IHVuaXhfbHN0YXRfNjRcbmZ1bmN0aW9uIGNhbWxfdW5peF9sc3RhdF82NChuYW1lKSB7XG4gIHZhciByID0gY2FtbF91bml4X2xzdGF0KG5hbWUpO1xuICByWzldID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihyWzldKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X21rZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9ta2RpclxuZnVuY3Rpb24gY2FtbF91bml4X21rZGlyKG5hbWUsIHBlcm0pIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5ta2Rpcikge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfbWtkaXI6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UubWtkaXIocm9vdC5yZXN0LCBwZXJtLCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfcm1kaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3JtZGlyXG5mdW5jdGlvbiBjYW1sX3VuaXhfcm1kaXIobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnJtZGlyKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9ybWRpcjogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5ybWRpcihyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9zeW1saW5rXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9zeW1saW5rXG5mdW5jdGlvbiBjYW1sX3VuaXhfc3ltbGluayh0b19kaXIsIHNyYywgZHN0KSB7XG4gIHZhciBzcmNfcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKHNyYyk7XG4gIHZhciBkc3Rfcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKGRzdCk7XG4gIGlmKHNyY19yb290LmRldmljZSAhPSBkc3Rfcm9vdC5kZXZpY2UpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9zeW1saW5rOiBjYW5ub3Qgc3ltbGluayBiZXR3ZWVuIHR3byBmaWxlc3lzdGVtc1wiKTtcbiAgaWYgKCFzcmNfcm9vdC5kZXZpY2Uuc3ltbGluaykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfc3ltbGluazogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiBzcmNfcm9vdC5kZXZpY2Uuc3ltbGluayh0b19kaXIsIHNyY19yb290LnJlc3QsIGRzdF9yb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9yZWFkbGlua1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfcmVhZGxpbmtcbmZ1bmN0aW9uIGNhbWxfdW5peF9yZWFkbGluayhuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UucmVhZGxpbmspIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3JlYWRsaW5rOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLnJlYWRsaW5rKHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3VubGlua1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfdW5saW5rXG5mdW5jdGlvbiBjYW1sX3VuaXhfdW5saW5rKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS51bmxpbmspIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3VubGluazogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS51bmxpbmsocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZ2V0dWlkXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9BbGlhczogdW5peF9nZXR1aWRcbmZ1bmN0aW9uIGNhbWxfdW5peF9nZXR1aWQodW5pdCkge1xuICBpZihnbG9iYWxUaGlzLnByb2Nlc3MgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzLmdldHVpZCl7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMucHJvY2Vzcy5nZXR1aWQoKTtcbiAgfVxuICBjYW1sX3JhaXNlX25vdF9mb3VuZCgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZ2V0cHd1aWRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL0FsaWFzOiB1bml4X2dldHB3dWlkXG5mdW5jdGlvbiBjYW1sX3VuaXhfZ2V0cHd1aWQodW5pdCkge1xuICBjYW1sX3JhaXNlX25vdF9mb3VuZCgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfaGFzX3N5bWxpbmtcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG4vL0FsaWFzOiB1bml4X2hhc19zeW1saW5rXG5mdW5jdGlvbiBjYW1sX3VuaXhfaGFzX3N5bWxpbmsodW5pdCkge1xuICByZXR1cm4gZnNfbm9kZV9zdXBwb3J0ZWQoKT8xOjBcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X29wZW5kaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X29wZW5kaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9vcGVuZGlyKHBhdGgpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShwYXRoKTtcbiAgaWYgKCFyb290LmRldmljZS5vcGVuZGlyKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9vcGVuZGlyOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgdmFyIGRpcl9oYW5kbGUgPSByb290LmRldmljZS5vcGVuZGlyKHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbiAgcmV0dXJuIHsgcG9pbnRlciA6IGRpcl9oYW5kbGUsIHBhdGg6IHBhdGggfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfcmVhZGRpclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IG1ha2VfdW5peF9lcnJfYXJncywgY2FtbF9yYWlzZV93aXRoX2FyZ3MsIGNhbWxfbmFtZWRfdmFsdWVcbi8vQWxpYXM6IHVuaXhfcmVhZGRpclxuZnVuY3Rpb24gY2FtbF91bml4X3JlYWRkaXIoZGlyX2hhbmRsZSkge1xuICB2YXIgZW50cnk7XG4gIHRyeSB7XG4gICAgICBlbnRyeSA9IGRpcl9oYW5kbGUucG9pbnRlci5yZWFkU3luYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgICB2YXIgdW5peF9lcnJvciA9IGNhbWxfbmFtZWRfdmFsdWUoJ1VuaXguVW5peF9lcnJvcicpO1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRUJBREZcIiwgXCJyZWFkZGlyXCIsIGRpcl9oYW5kbGUucGF0aCkpO1xuICB9XG4gIGlmIChlbnRyeSA9PT0gbnVsbCkge1xuICAgICAgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGVudHJ5Lm5hbWUpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9jbG9zZWRpclxuLy9SZXF1aXJlczogbWFrZV91bml4X2Vycl9hcmdzLCBjYW1sX3JhaXNlX3dpdGhfYXJncywgY2FtbF9uYW1lZF92YWx1ZVxuLy9BbGlhczogdW5peF9jbG9zZWRpclxuZnVuY3Rpb24gY2FtbF91bml4X2Nsb3NlZGlyKGRpcl9oYW5kbGUpIHtcbiAgdHJ5IHtcbiAgICAgIGRpcl9oYW5kbGUucG9pbnRlci5jbG9zZVN5bmMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgICAgdmFyIHVuaXhfZXJyb3IgPSBjYW1sX25hbWVkX3ZhbHVlKCdVbml4LlVuaXhfZXJyb3InKTtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVCQURGXCIsIFwiY2xvc2VkaXJcIiwgZGlyX2hhbmRsZS5wYXRoKSk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3Jld2luZGRpclxuLy9SZXF1aXJlczogY2FtbF91bml4X2Nsb3NlZGlyLCBjYW1sX3VuaXhfb3BlbmRpclxuLy9BbGlhczogdW5peF9yZXdpbmRkaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9yZXdpbmRkaXIoZGlyX2hhbmRsZSkge1xuICBjYW1sX3VuaXhfY2xvc2VkaXIoZGlyX2hhbmRsZSk7XG4gIHZhciBuZXdfZGlyX2hhbmRsZSA9IGNhbWxfdW5peF9vcGVuZGlyKGRpcl9oYW5kbGUucGF0aCk7XG4gIGRpcl9oYW5kbGUucG9pbnRlciA9IG5ld19kaXJfaGFuZGxlLnBvaW50ZXI7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZmluZGZpcnN0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9vcGVuZGlyLCBjYW1sX3VuaXhfcmVhZGRpclxuLy9BbGlhczogd2luX2ZpbmRmaXJzdFxuZnVuY3Rpb24gY2FtbF91bml4X2ZpbmRmaXJzdChwYXRoKSB7XG4gIC8vIFRoZSBXaW5kb3dzIGNvZGUgYWRkcyB0aGlzIGdsb2IgdG8gdGhlIHBhdGgsIHNvIHdlIG5lZWQgdG8gcmVtb3ZlIGl0XG4gIHZhciBwYXRoX2pzID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocGF0aCk7XG4gIHBhdGhfanMgPSBwYXRoX2pzLnJlcGxhY2UoLyhefFtcXFxcXFwvXSlcXCpcXC5cXCokLywgXCJcIik7XG4gIHBhdGggPSBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhwYXRoX2pzKTtcbiAgLy8gKi4qIGlzIG5vdyBzdHJpcHBlZFxuICB2YXIgZGlyX2hhbmRsZSA9IGNhbWxfdW5peF9vcGVuZGlyKHBhdGgpO1xuICB2YXIgZmlyc3RfZW50cnkgPSBjYW1sX3VuaXhfcmVhZGRpcihkaXJfaGFuZGxlKTtcbiAgLy8gVGhlIFdpbmRvd3MgYmluZGluZ3MgdHlwZSBkaXJfaGFuZGxlIGFzIGFuIGBpbnRgIGJ1dCBpdCdzIG5vdCBpbiBKU1xuICByZXR1cm4gWzAsIGZpcnN0X2VudHJ5LCBkaXJfaGFuZGxlXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2ZpbmRuZXh0XG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfcmVhZGRpclxuLy9BbGlhczogd2luX2ZpbmRuZXh0XG5mdW5jdGlvbiBjYW1sX3VuaXhfZmluZG5leHQoZGlyX2hhbmRsZSkge1xuICByZXR1cm4gY2FtbF91bml4X3JlYWRkaXIoZGlyX2hhbmRsZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9maW5kY2xvc2Vcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9jbG9zZWRpclxuLy9BbGlhczogd2luX2ZpbmRjbG9zZVxuZnVuY3Rpb24gY2FtbF91bml4X2ZpbmRjbG9zZShkaXJfaGFuZGxlKSB7XG4gIHJldHVybiBjYW1sX3VuaXhfY2xvc2VkaXIoZGlyX2hhbmRsZSk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2luZXRfYWRkcl9vZl9zdHJpbmcgY29uc3Rcbi8vQWxpYXM6IHVuaXhfaW5ldF9hZGRyX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF91bml4X2luZXRfYWRkcl9vZl9zdHJpbmcgKCkge3JldHVybiAwO31cblxuXG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBNbEZha2VEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sRmFrZUZpbGUsIE1sRmFrZUZkLCBjYW1sX2NyZWF0ZV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9hcnJheSwgY2FtbF9ieXRlc19vZl9zdHJpbmcsIGNhbWxfYnl0ZXNfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfcmFpc2Vfd2l0aF9hcmdzLCBjYW1sX25hbWVkX3ZhbHVlc1xuLy9SZXF1aXJlczogbWFrZV91bml4X2Vycl9hcmdzXG5mdW5jdGlvbiBNbEZha2VEZXZpY2UgKHJvb3QsIGYpIHtcbiAgdGhpcy5jb250ZW50PXt9O1xuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLmxvb2t1cEZ1biA9IGY7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5jcmVhdGVfZGlyX2lmX25lZWRlZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGNvbXAgPSBuYW1lLnNwbGl0KFwiL1wiKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBjb21wLmxlbmd0aCAtIDE7IGkrKyl7XG4gICAgcmVzICs9IGNvbXBbaV0gKyBcIi9cIjtcbiAgICBpZih0aGlzLmNvbnRlbnRbcmVzXSkgY29udGludWU7XG4gICAgdGhpcy5jb250ZW50W3Jlc10gPSBTeW1ib2woXCJkaXJlY3RvcnlcIik7XG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuc2xhc2ggPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIC9cXC8kLy50ZXN0KG5hbWUpP25hbWU6KG5hbWUgKyBcIi9cIik7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYoIXRoaXMuY29udGVudFtuYW1lXSAmJiB0aGlzLmxvb2t1cEZ1bikge1xuICAgIHZhciByZXMgPSB0aGlzLmxvb2t1cEZ1bihjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHRoaXMucm9vdCksIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSkpO1xuICAgIGlmKHJlcyAhPT0gMCkge1xuICAgICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICAgIHRoaXMuY29udGVudFtuYW1lXT1uZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhyZXNbMV0pKTtcbiAgICB9XG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICAvLyBUaGUgcm9vdCBvZiB0aGUgZGV2aWNlIGV4aXN0c1xuICBpZihuYW1lID09IFwiXCIpIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGRpcmVjdG9yeSBleGlzdHNcbiAgdmFyIG5hbWVfc2xhc2ggPSB0aGlzLnNsYXNoKG5hbWUpO1xuICBpZih0aGlzLmNvbnRlbnRbbmFtZV9zbGFzaF0pIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGZpbGUgZXhpc3RzXG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdPzE6MDtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuaXNGaWxlID0gZnVuY3Rpb24obmFtZSkge1xuICBpZih0aGlzLmV4aXN0cyhuYW1lKSAmJiAhdGhpcy5pc19kaXIobmFtZSkpIHtcbiAgICByZXR1cm4gMVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiAwXG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubWtkaXIgPSBmdW5jdGlvbihuYW1lLG1vZGUsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSByYWlzZV91bml4ICYmIGNhbWxfbmFtZWRfdmFsdWUoJ1VuaXguVW5peF9lcnJvcicpO1xuICBpZih0aGlzLmV4aXN0cyhuYW1lKSkge1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFRVhJU1RcIiwgXCJta2RpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBGaWxlIGV4aXN0c1wiKTtcbiAgICB9XG4gIH1cbiAgdmFyIHBhcmVudCA9IC9eKC4qKVxcL1teL10rLy5leGVjKG5hbWUpO1xuICBwYXJlbnQgPSAocGFyZW50ICYmIHBhcmVudFsxXSkgfHwgJyc7XG4gIGlmKCF0aGlzLmV4aXN0cyhwYXJlbnQpKXtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PRU5UXCIsIFwibWtkaXJcIiwgdGhpcy5ubShwYXJlbnQpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IocGFyZW50ICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIGlmKCF0aGlzLmlzX2RpcihwYXJlbnQpKXtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PVERJUlwiLCBcIm1rZGlyXCIsIHRoaXMubm0ocGFyZW50KSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHBhcmVudCArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQodGhpcy5zbGFzaChuYW1lKSk7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJtZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB2YXIgdW5peF9lcnJvciA9IHJhaXNlX3VuaXggJiYgY2FtbF9uYW1lZF92YWx1ZSgnVW5peC5Vbml4X2Vycm9yJyk7XG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgPT0gXCJcIik/XCJcIjoodGhpcy5zbGFzaChuYW1lKSk7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKylcIik7XG4gIGlmKCF0aGlzLmV4aXN0cyhuYW1lKSkge1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFTk9FTlRcIiwgXCJybWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfVxuICBpZighdGhpcy5pc19kaXIobmFtZSkpIHtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PVERJUlwiLCBcInJtZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIGlmKG4ubWF0Y2gocikpIHtcbiAgICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT1RFTVBUWVwiLCBcInJtZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIjogRGlyZWN0b3J5IG5vdCBlbXB0eVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGVsZXRlIHRoaXMuY29udGVudFtuYW1lX3NsYXNoXTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOih0aGlzLnNsYXNoKG5hbWUpKTtcbiAgaWYoIXRoaXMuZXhpc3RzKG5hbWUpKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICB9XG4gIGlmKCF0aGlzLmlzX2RpcihuYW1lKSkge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xuICB9XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKylcIik7XG4gIHZhciBzZWVuID0ge31cbiAgdmFyIGEgPSBbXTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIHZhciBtID0gbi5tYXRjaChyKTtcbiAgICBpZihtICYmICFzZWVuW21bMV1dKSB7c2VlblttWzFdXSA9IHRydWU7IGEucHVzaChtWzFdKX1cbiAgfVxuICByZXR1cm4gYTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUub3BlbmRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSByYWlzZV91bml4ICYmIGNhbWxfbmFtZWRfdmFsdWUoJ1VuaXguVW5peF9lcnJvcicpO1xuXG4gIHZhciBhID0gdGhpcy5yZWFkZGlyKG5hbWUpO1xuICB2YXIgYyA9IGZhbHNlO1xuICB2YXIgaSA9IDA7XG4gIHJldHVybiB7IHJlYWRTeW5jIDogKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYykge1xuICAgICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRUJBREZcIiwgXCJjbG9zZWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBjbG9zZWRpciBmYWlsZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKGkgPT0gYS5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgIHZhciBlbnRyeSA9IGFbaV07XG4gICAgaSsrO1xuICAgIHJldHVybiB7IG5hbWU6IGVudHJ5IH1cbiAgfSlcbiAgICAsIGNsb3NlU3luYzogKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjKSB7XG4gICAgICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRUJBREZcIiwgXCJjbG9zZWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBjbG9zZWRpciBmYWlsZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGMgPSB0cnVlO1xuICAgICAgYSA9IFtdO1xuICAgIH0pXG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICBpZihuYW1lID09IFwiXCIpICByZXR1cm4gdHJ1ZTtcbiAgdmFyIG5hbWVfc2xhc2ggPSB0aGlzLnNsYXNoKG5hbWUpO1xuICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVfc2xhc2hdPzE6MDtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgb2sgPSB0aGlzLmNvbnRlbnRbbmFtZV0/dHJ1ZTpmYWxzZTtcbiAgZGVsZXRlIHRoaXMuY29udGVudFtuYW1lXTtcbiAgcmV0dXJuIG9rO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZikge1xuICB2YXIgZmlsZTtcbiAgaWYoZi5yZG9ubHkgJiYgZi53cm9ubHkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl9yZG9ubHkgYW5kIE9wZW5fd3Jvbmx5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgaWYoZi50ZXh0ICYmIGYuYmluYXJ5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fdGV4dCBhbmQgT3Blbl9iaW5hcnkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgaWYgKHRoaXMuY29udGVudFtuYW1lXSkge1xuICAgIGlmICh0aGlzLmlzX2RpcihuYW1lKSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogaXMgYSBkaXJlY3RvcnlcIik7XG4gICAgaWYgKGYuY3JlYXRlICYmIGYuZXhjbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmlsZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICAgIGlmKGYudHJ1bmNhdGUpIGZpbGUudHJ1bmNhdGUoKTtcbiAgfSBlbHNlIGlmIChmLmNyZWF0ZSkge1xuICAgIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQobmFtZSk7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpO1xuICAgIGZpbGUgPSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUgKHRoaXMubm0obmFtZSkpO1xuICB9XG4gIHJldHVybiBuZXcgTWxGYWtlRmQodGhpcy5ubShuYW1lKSwgZmlsZSwgZik7XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYpIHtcbiAgdmFyIGZpbGU7XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIGlmICh0aGlzLmNvbnRlbnRbbmFtZV0pIHtcbiAgICBpZiAodGhpcy5pc19kaXIobmFtZSkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGlzIGEgZGlyZWN0b3J5XCIpO1xuICAgIGlmIChmLmNyZWF0ZSAmJiBmLmV4Y2wpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgZmlsZSA9IHRoaXMuY29udGVudFtuYW1lXTtcbiAgICBpZihmLnRydW5jYXRlKSBmaWxlLnRydW5jYXRlKCk7XG4gIH0gZWxzZSBpZiAoZi5jcmVhdGUpIHtcbiAgICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKG5hbWUpO1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKTtcbiAgICBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlICh0aGlzLm5tKG5hbWUpKTtcbiAgfVxuICByZXR1cm4gbmV3IE1sRmFrZUZkKHRoaXMubm0obmFtZSksIGZpbGUsIGYpO1xufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJlZ2lzdGVyPSBmdW5jdGlvbiAobmFtZSxjb250ZW50KXtcbiAgdmFyIGZpbGU7XG4gIGlmKHRoaXMuY29udGVudFtuYW1lXSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmlsZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgaWYoY2FtbF9pc19tbF9ieXRlcyhjb250ZW50KSlcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY29udGVudCk7XG4gIGlmKGNhbWxfaXNfbWxfc3RyaW5nKGNvbnRlbnQpKVxuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhjb250ZW50KSk7XG4gIGVsc2UgaWYoY29udGVudCBpbnN0YW5jZW9mIEFycmF5KVxuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX2FycmF5KGNvbnRlbnQpKTtcbiAgZWxzZSBpZih0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIilcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9qc2J5dGVzKGNvbnRlbnQpKTtcbiAgZWxzZSBpZihjb250ZW50LnRvU3RyaW5nKSB7XG4gICAgdmFyIGJ5dGVzID0gY2FtbF9ieXRlc19vZl9zdHJpbmcoY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoY29udGVudC50b1N0cmluZygpKSk7XG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGJ5dGVzKTtcbiAgfVxuICBpZihmaWxlKXtcbiAgICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKG5hbWUpO1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IGZpbGU7XG4gIH1cbiAgZWxzZSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiByZWdpc3RlcmluZyBmaWxlIHdpdGggaW52YWxpZCBjb250ZW50IHR5cGVcIik7XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbEZha2VEZXZpY2VcblxuLy9Qcm92aWRlczogTWxGYWtlRmlsZVxuLy9SZXF1aXJlczogTWxGaWxlXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfYmxpdF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcywgY2FtbF9ieXRlc19vZl9hcnJheVxuZnVuY3Rpb24gTWxGYWtlRmlsZShjb250ZW50KXtcbiAgdGhpcy5kYXRhID0gY29udGVudDtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcbk1sRmFrZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRmlsZVxuTWxGYWtlRmlsZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB2YXIgb2xkID0gdGhpcy5kYXRhO1xuICB0aGlzLmRhdGEgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW58MCk7XG4gIGNhbWxfYmxpdF9ieXRlcyhvbGQsIDAsIHRoaXMuZGF0YSwgMCwgbGVuKTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHRoaXMuZGF0YSk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgaWYob2Zmc2V0ICsgbGVuID49IGNsZW4pIHtcbiAgICB2YXIgbmV3X3N0ciA9IGNhbWxfY3JlYXRlX2J5dGVzKG9mZnNldCArIGxlbik7XG4gICAgdmFyIG9sZF9kYXRhID0gdGhpcy5kYXRhO1xuICAgIHRoaXMuZGF0YSA9IG5ld19zdHI7XG4gICAgY2FtbF9ibGl0X2J5dGVzKG9sZF9kYXRhLCAwLCB0aGlzLmRhdGEsIDAsIGNsZW4pO1xuICB9XG4gIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX2FycmF5KGJ1ZiksIHBvcywgdGhpcy5kYXRhLCBvZmZzZXQsIGxlbik7XG4gIHJldHVybiAwXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24ob2Zmc2V0LGJ1Zixwb3MsbGVuKXtcbiAgdmFyIGNsZW4gPSB0aGlzLmxlbmd0aCgpO1xuICBpZihvZmZzZXQgKyBsZW4gPj0gY2xlbikge1xuICAgIGxlbiA9IGNsZW4gLSBvZmZzZXQ7XG4gIH1cbiAgaWYobGVuKSB7XG4gICAgdmFyIGRhdGEgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW58MCk7XG4gICAgY2FtbF9ibGl0X2J5dGVzKHRoaXMuZGF0YSwgb2Zmc2V0LCBkYXRhLCAwLCBsZW4pO1xuICAgIGJ1Zi5zZXQoY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhkYXRhKSwgcG9zKTtcbiAgfVxuICByZXR1cm4gbGVuXG59XG5cblxuLy9Qcm92aWRlczogTWxGYWtlRmRfb3V0XG4vL1JlcXVpcmVzOiBNbEZha2VGaWxlLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gTWxGYWtlRmRfb3V0KGZkLGZsYWdzKSB7XG4gIE1sRmFrZUZpbGUuY2FsbCh0aGlzLCBjYW1sX2NyZWF0ZV9ieXRlcygwKSk7XG4gIHRoaXMubG9nID0gKGZ1bmN0aW9uIChzKSB7IHJldHVybiAwIH0pO1xuICBpZihmZCA9PSAxICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhpcy5sb2cgPSBjb25zb2xlLmxvZztcbiAgZWxzZSBpZihmZCA9PSAyICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09IFwiZnVuY3Rpb25cIilcbiAgICB0aGlzLmxvZyA9IGNvbnNvbGUuZXJyb3I7XG4gIGVsc2UgaWYodHlwZW9mIGNvbnNvbGUubG9nID09IFwiZnVuY3Rpb25cIilcbiAgICB0aGlzLmxvZyA9IGNvbnNvbGUubG9nXG4gIHRoaXMuZmxhZ3MgPSBmbGFncztcbn1cbk1sRmFrZUZkX291dC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7IHJldHVybiAwIH1cbk1sRmFrZUZkX291dC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAob2Zmc2V0LGJ1Zixwb3MsbGVuKSB7XG4gIGlmKHRoaXMubG9nKSB7XG4gICAgaWYobGVuID4gMFxuICAgICAgICYmIHBvcyA+PSAwXG4gICAgICAgJiYgcG9zK2xlbiA8PSBidWYubGVuZ3RoXG4gICAgICAgJiYgYnVmW3BvcytsZW4tMV0gPT0gMTApXG4gICAgICBsZW4gLS07XG4gICAgLy8gRG8gbm90IG91dHB1dCB0aGUgbGFzdCBcXG4gaWYgcHJlc2VudFxuICAgIC8vIGFzIGNvbnNvbGUgbG9nZ2luZyBkaXNwbGF5IGEgbmV3bGluZSBhdCB0aGUgZW5kXG4gICAgdmFyIHNyYyA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoYnVmKSwgcG9zLCBzcmMsIDAsIGxlbik7XG4gICAgdGhpcy5sb2coc3JjLnRvVXRmMTYoKSk7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5mZCAgKyBcIjogZmlsZSBkZXNjcmlwdG9yIGFscmVhZHkgY2xvc2VkXCIpO1xufVxuTWxGYWtlRmRfb3V0LnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG9mZnNldCwgYnVmLCBwb3MsIGxlbikge1xuICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLmZkICArIFwiOiBmaWxlIGRlc2NyaXB0b3IgaXMgd3JpdGUgb25seVwiKTtcbn1cbk1sRmFrZUZkX291dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubG9nID0gdW5kZWZpbmVkO1xufVxuXG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZkXG4vL1JlcXVpcmVzOiBNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gTWxGYWtlRmQobmFtZSwgZmlsZSxmbGFncykge1xuICB0aGlzLmZpbGUgPSBmaWxlO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG59XG5cbk1sRmFrZUZkLnByb3RvdHlwZS5lcnJfY2xvc2VkID0gZnVuY3Rpb24gKCkge1xuICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5hbWUgICsgXCI6IGZpbGUgZGVzY3JpcHRvciBhbHJlYWR5IGNsb3NlZFwiKTtcbn1cbk1sRmFrZUZkLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5maWxlKSByZXR1cm4gdGhpcy5maWxlLmxlbmd0aCAoKVxuICB0aGlzLmVycl9jbG9zZWQoKTtcbn1cbk1sRmFrZUZkLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChvZmZzZXQsYnVmLHBvcyxsZW4pIHtcbiAgaWYodGhpcy5maWxlKSByZXR1cm4gdGhpcy5maWxlLndyaXRlKG9mZnNldCxidWYscG9zLGxlbilcbiAgdGhpcy5lcnJfY2xvc2VkKCk7XG59XG5NbEZha2VGZC5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ1ZiwgcG9zLCBsZW4pIHtcbiAgaWYodGhpcy5maWxlKSByZXR1cm4gdGhpcy5maWxlLnJlYWQob2Zmc2V0LCBidWYsIHBvcywgbGVuKVxuICB0aGlzLmVycl9jbG9zZWQoKTtcbn1cbk1sRmFrZUZkLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5maWxlID0gdW5kZWZpbmVkO1xufVxuIiwiLy9Qcm92aWRlczogaW5pdGlhbGl6ZV9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogc2VyaWFsaXplX25hdCwgZGVzZXJpYWxpemVfbmF0LCBjYW1sX2hhc2hfbmF0XG5mdW5jdGlvbiBpbml0aWFsaXplX25hdCgpIHtcbiAgY2FtbF9jdXN0b21fb3BzW1wiX25hdFwiXSA9XG4gICAgeyBkZXNlcmlhbGl6ZSA6IGRlc2VyaWFsaXplX25hdCxcbiAgICAgIHNlcmlhbGl6ZSA6IHNlcmlhbGl6ZV9uYXQsXG4gICAgICBoYXNoIDogY2FtbF9oYXNoX25hdFxuICAgIH1cbn1cblxuLy9Qcm92aWRlczogTWxOYXRcbmZ1bmN0aW9uIE1sTmF0KHgpe1xuICB0aGlzLmRhdGEgPSBuZXcgSW50MzJBcnJheSh4KTtcbiAgLy8gbGVuZ3RoX25hdCBpc24ndCBleHRlcm5hbCwgc28gd2UgaGF2ZSB0byBtYWtlIHRoZSBPYmouc2l6ZVxuICAvLyB3b3JrIG91dCByaWdodC4gVGhlICsyIHRvIGFycmF5IGxlbmd0aCBzZWVtcyB0byB3b3JrLlxuICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggKyAyXG59XG5cbk1sTmF0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX25hdFwiO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbmF0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9uYXQoeCkge1xuICB2YXIgbGVuID0gbnVtX2RpZ2l0c19uYXQoeCwgMCwgeC5kYXRhLmxlbmd0aCk7XG4gIHZhciBoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB4LmRhdGFbaV0pO1xuICB9XG4gIHJldHVybiBoO1xufVxuXG5cbi8vUHJvdmlkZXM6IG5hdF9vZl9hcnJheVxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIG5hdF9vZl9hcnJheShsKXtcbiAgcmV0dXJuIG5ldyBNbE5hdChsKTtcbn1cblxuLy9Qcm92aWRlczogY3JlYXRlX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGNyZWF0ZV9uYXQoc2l6ZSkge1xuICB2YXIgYXJyID0gbmV3IE1sTmF0KHNpemUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgYXJyLmRhdGFbaV0gPSAtMTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfdG9femVyb19uYXRcbmZ1bmN0aW9uIHNldF90b196ZXJvX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJsaXRfbmF0XG5mdW5jdGlvbiBibGl0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBuYXQyLmRhdGFbb2ZzMitpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdFxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdChuYXQsIG9mcywgZGlnaXQpIHtcbiAgbmF0LmRhdGFbb2ZzXSA9IGRpZ2l0O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbnRoX2RpZ2l0X25hdFxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdChuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdF9uYXRpdmVcbmZ1bmN0aW9uIHNldF9kaWdpdF9uYXRfbmF0aXZlKG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMpIHtcbiAgcmV0dXJuIG5hdC5kYXRhW29mc107XG59XG5cbi8vUHJvdmlkZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBudW1fZGlnaXRzX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYobmF0LmRhdGFbb2ZzK2ldICE9IDApIHJldHVybiBpKzE7XG4gIH1cbiAgcmV0dXJuIDE7IC8vIDAgY291bnRzIGFzIDEgZGlnaXRcbn1cblxuLy9Qcm92aWRlczogbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0XG5mdW5jdGlvbiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0LCBvZnMpIHtcbiAgdmFyIGEgPSBuYXQuZGF0YVtvZnNdO1xuICB2YXIgYiA9IDA7XG4gIGlmKGEgJiAweEZGRkYwMDAwKSB7IGIgKz0xNjsgYSA+Pj49MTY7IH1cbiAgaWYoYSAmIDB4RkYwMCkgICAgIHsgYiArPSA4OyBhID4+Pj0gODsgfVxuICBpZihhICYgMHhGMCkgICAgICAgeyBiICs9IDQ7IGEgPj4+PSA0OyB9XG4gIGlmKGEgJiAxMikgICAgICAgICB7IGIgKz0gMjsgYSA+Pj49IDI7IH1cbiAgaWYoYSAmIDIpICAgICAgICAgIHsgYiArPSAxOyBhID4+Pj0gMTsgfVxuICBpZihhICYgMSkgICAgICAgICAgeyBiICs9IDE7IH1cbiAgcmV0dXJuIDMyIC0gYjtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfaW50XG5mdW5jdGlvbiBpc19kaWdpdF9pbnQobmF0LCBvZnMpIHtcbiAgaWYgKG5hdC5kYXRhW29mc10gPj0gMCkgcmV0dXJuIDFcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X3plcm9cbmZ1bmN0aW9uIGlzX2RpZ2l0X3plcm8obmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSA9PSAwKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X29kZFxuZnVuY3Rpb24gaXNfZGlnaXRfb2RkKG5hdCwgb2ZzKSB7XG4gIGlmKG5hdC5kYXRhW29mc10gJiAxKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBpbmNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICh4IHwgMCk7XG4gICAgaWYoeCA9PSAoeCA+Pj4gMCkpIHtcbiAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBhZGRfbmF0XG4vL1JlcXVpcmVzOiBpbmNyX25hdFxuZnVuY3Rpb24gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4ID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKyBjYXJyeTtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHhcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmNyX25hdChuYXQxLCBvZnMxK2xlbjIsIGxlbjEtbGVuMiwgY2FycnkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wbGVtZW50X25hdFxuZnVuY3Rpb24gY29tcGxlbWVudF9uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQuZGF0YVtvZnMraV0gPSAoLTEgPj4+IDApIC0gKG5hdC5kYXRhW29mcytpXSA+Pj4gMCk7XG4gIH1cbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vUHJvdmlkZXM6IGRlY3JfbmF0XG5mdW5jdGlvbiBkZWNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB4ID0gKG5hdC5kYXRhW29mcytpXSA+Pj4wKSAtIGJvcnJvdztcbiAgICBuYXQuZGF0YVtvZnMraV0gPSB4O1xuICAgIGlmICh4ID49IDApIHtcbiAgICAgIGJvcnJvdyA9IDA7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChib3Jyb3cgPT0gMSkgPyAwIDogMTtcbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogc3ViX25hdFxuLy9SZXF1aXJlczogZGVjcl9uYXRcbmZ1bmN0aW9uIHN1Yl9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgY2FycnlfaW4pIHtcbiAgdmFyIGJvcnJvdyA9IChjYXJyeV9pbiA9PSAxKSA/IDAgOiAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIC0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAtIGJvcnJvdztcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCAoYm9ycm93PT0xKT8wOjEpO1xufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzW29mczNdXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IG11bHRfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBhZGRfbmF0LCBuYXRfb2ZfYXJyYXlcbmZ1bmN0aW9uIG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGEgPSAobmF0My5kYXRhW29mczNdID4+PiAwKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4MSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgKyAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApICogKGEgJiAweDAwMDBGRkZGKSArIGNhcnJ5O1xuICAgIHZhciB4MiA9IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSA+Pj4gMTYpO1xuICAgIGNhcnJ5ID0gTWF0aC5mbG9vcih4Mi82NTUzNik7XG4gICAgdmFyIHgzID0geDEgKyAoeDIgJSA2NTUzNikgKiA2NTUzNjtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHgzO1xuICAgIGNhcnJ5ICs9IE1hdGguZmxvb3IoeDMvNDI5NDk2NzI5Nik7XG4gIH1cblxuICBpZihsZW4yIDwgbGVuMSAmJiBjYXJyeSkge1xuICAgIHJldHVybiBhZGRfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBuYXRfb2ZfYXJyYXkoW2NhcnJ5XSksIDAsIDEsIDApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjYXJyeTtcbiAgfVxufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzXG4vLyBsZW4xID49IGxlbjIgKyBsZW4zLlxuLy9Qcm92aWRlczogbXVsdF9uYXRcbi8vUmVxdWlyZXM6IG11bHRfZGlnaXRfbmF0XG5mdW5jdGlvbiBtdWx0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzLCBsZW4zKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4zOyBpKyspIHtcbiAgICBjYXJyeSArPSBtdWx0X2RpZ2l0X25hdChuYXQxLCBvZnMxK2ksIGxlbjEtaSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMytpKTtcbiAgfVxuICByZXR1cm4gY2Fycnk7XG59XG5cbi8vIG5hdDEgPSAyICogbmF0MSArIG5hdDIgKiBuYXQyXG4vLyBsZW4xID49IDIgKiBsZW4yXG4vL1Byb3ZpZGVzOiBzcXVhcmVfbmF0XG4vL1JlcXVpcmVzOiBtdWx0X25hdCwgYWRkX25hdFxuZnVuY3Rpb24gc3F1YXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGNhcnJ5ICs9IGFkZF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0MSwgb2ZzMSwgbGVuMSwgMCk7XG4gIGNhcnJ5ICs9IG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpO1xuICByZXR1cm4gY2Fycnk7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9sZWZ0X25hdFxuZnVuY3Rpb24gc2hpZnRfbGVmdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbmJpdHMpIHtcbiAgaWYobmJpdHMgPT0gMCkge1xuICAgIG5hdDIuZGF0YVtvZnMyXSA9IDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHdyYXAgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMTsgaSsrKSB7XG4gICAgdmFyIGEgPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPDwgbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA+Pj4gKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vLyBBc3N1bWluZyBjID4gYSwgcmV0dXJucyBbcXVvdGllbnQsIHJlbWFpbmRlcl0gb2YgKGE8PDMyICsgYikvY1xuLy9Qcm92aWRlczogZGl2X2hlbHBlclxuZnVuY3Rpb24gZGl2X2hlbHBlcihhLCBiLCBjKSB7XG4gIHZhciB4ID0gYSAqIDY1NTM2ICsgKGI+Pj4xNik7XG4gIHZhciB5ID0gTWF0aC5mbG9vcih4L2MpICogNjU1MzY7XG4gIHZhciB6ID0gKHggJSBjKSAqIDY1NTM2O1xuICB2YXIgdyA9IHogKyAoYiAmIDB4MDAwMEZGRkYpO1xuICByZXR1cm4gW3kgKyBNYXRoLmZsb29yKHcvYyksIHcgJSBjXTtcbn1cblxuLy8gbmF0MVtvZnMxK2xlbl0gPCBuYXQyW29mczJdXG4vL1Byb3ZpZGVzOiBkaXZfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfZGlnaXRfbmF0KG5hdHEsIG9mc3EsIG5hdHIsIG9mc3IsIG5hdDEsIG9mczEsIGxlbiwgbmF0Miwgb2ZzMikge1xuICB2YXIgcmVtID0gKG5hdDEuZGF0YVtvZnMxK2xlbi0xXSA+Pj4wKTtcbiAgLy8gbmF0cVtvZnNxK2xlbi0xXSBpcyBndWFyYW50ZWVkIHRvIGJlIHplcm8gKGR1ZSB0byB0aGUgTVNEIHJlcXVpcmVtZW50KSxcbiAgLy8gYW5kIHNob3VsZCBub3QgYmUgd3JpdHRlbiB0by5cbiAgZm9yKHZhciBpID0gbGVuLTI7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHggPSBkaXZfaGVscGVyKHJlbSwgKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDIuZGF0YVtvZnMyXSA+Pj4gMCkpO1xuICAgIG5hdHEuZGF0YVtvZnNxK2ldID0geFswXTtcbiAgICByZW0gPSB4WzFdO1xuICB9XG4gIG5hdHIuZGF0YVtvZnNyXSA9IHJlbTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIG5hdDFbbmF0MjpdIDo9IG5hdDEgLyBuYXQyXG4vLyBuYXQxWzpuYXQyXSA6PSBuYXQxICUgbmF0MlxuLy8gbGVuMSA+IGxlbjIsIG5hdDJbb2ZzMitsZW4yLTFdID4gbmF0MVtvZnMxK2xlbjEtMV1cbi8vUHJvdmlkZXM6IGRpdl9uYXRcbi8vUmVxdWlyZXM6IGRpdl9kaWdpdF9uYXQsIGRpdl9oZWxwZXIsIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdCwgc2hpZnRfbGVmdF9uYXQsIHNoaWZ0X3JpZ2h0X25hdCwgY3JlYXRlX25hdCwgc2V0X3RvX3plcm9fbmF0LCBtdWx0X2RpZ2l0X25hdCwgc3ViX25hdCwgY29tcGFyZV9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gZGl2X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIGlmKGxlbjIgPT0gMSkge1xuICAgIGRpdl9kaWdpdF9uYXQobmF0MSwgb2ZzMSsxLCBuYXQxLCBvZnMxLCBuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyKTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBzID0gbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0KG5hdDIsIG9mczIrbGVuMi0xKTtcbiAgc2hpZnRfbGVmdF9uYXQobmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG5cbiAgdmFyIGQgPSAobmF0Mi5kYXRhW29mczIrbGVuMi0xXSA+Pj4gMCkgKyAxO1xuICB2YXIgYSA9IGNyZWF0ZV9uYXQobGVuMisxKTtcbiAgZm9yICh2YXIgaSA9IGxlbjEgLSAxOyBpID49IGxlbjI7IGktLSkge1xuICAgIC8vIERlY2VudCBsb3dlciBib3VuZCBvbiBxdW9cbiAgICB2YXIgcXVvID0gZCA9PSA0Mjk0OTY3Mjk2ID8gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA6IGRpdl9oZWxwZXIoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDEuZGF0YVtvZnMxK2ktMV0gPj4+MCksIGQpWzBdO1xuICAgIHNldF90b196ZXJvX25hdChhLCAwLCBsZW4yKzEpO1xuICAgIG11bHRfZGlnaXRfbmF0KGEsIDAsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFtxdW9dKSwgMCk7XG4gICAgc3ViX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMisxLCBhLCAwLCBsZW4yKzEsIDEpO1xuXG4gICAgd2hpbGUgKG5hdDEuZGF0YVtvZnMxK2ldICE9IDAgfHwgY29tcGFyZV9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpID49IDApIHtcbiAgICAgIHF1byA9IHF1byArIDE7XG4gICAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIG5hdDIsIG9mczIsIGxlbjIsIDEpO1xuICAgIH1cblxuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gcXVvO1xuICB9XG5cbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gc2hpZnQgcmVtYWluZGVyXG4gIHNoaWZ0X3JpZ2h0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7IC8vIHJlc3RvcmVcbiAgcmV0dXJuIDA7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9yaWdodF9uYXRcbmZ1bmN0aW9uIHNoaWZ0X3JpZ2h0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IGxlbjEtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgYSA9IG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPj4+IG5iaXRzKSB8IHdyYXA7XG4gICAgd3JhcCA9IGEgPDwgKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfZGlnaXRzX25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA+IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIDE7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA8IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRcbi8vUmVxdWlyZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjb21wYXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBhID0gbnVtX2RpZ2l0c19uYXQobmF0MSwgb2ZzMSwgbGVuMSk7XG4gIHZhciBiID0gbnVtX2RpZ2l0c19uYXQobmF0Miwgb2ZzMiwgbGVuMik7XG4gIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgaWYoYSA8IGIpIHJldHVybiAtMTtcbiAgZm9yKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgPiAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApKSByZXR1cm4gMTtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA8IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRfcmVhbFxuLy9SZXF1aXJlczogY29tcGFyZV9uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0X3JlYWwobmF0MSxuYXQyKXtcbiAgcmV0dXJuIGNvbXBhcmVfbmF0KG5hdDEsMCxuYXQxLmRhdGEubGVuZ3RoLG5hdDIsMCxuYXQyLmRhdGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogbGFuZF9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxhbmRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdICY9IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGxvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gfD0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbHhvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGx4b3JfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdIF49IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogc2VyaWFsaXplX25hdFxuZnVuY3Rpb24gc2VyaWFsaXplX25hdCh3cml0ZXIsIG5hdCwgc3ope1xuICB2YXIgbGVuID0gbmF0LmRhdGEubGVuZ3RoO1xuICB3cml0ZXIud3JpdGUoMzIsIGxlbik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgd3JpdGVyLndyaXRlKDMyLCBuYXQuZGF0YVtpXSk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICBzelsxXSA9IGxlbiAqIDg7XG59XG5cbi8vUHJvdmlkZXM6IGRlc2VyaWFsaXplX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGRlc2VyaWFsaXplX25hdChyZWFkZXIsIHN6KXtcbiAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBuYXQgPSBuZXcgTWxOYXQobGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBuYXQuZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICByZXR1cm4gbmF0O1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IEh1Z28gSGV1emFyZFxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZVxudmFyIGNhbWxfZ3Jfc3RhdGU7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfZ2V0KCkge1xuICBpZihjYW1sX2dyX3N0YXRlKSB7XG4gICAgcmV0dXJuIGNhbWxfZ3Jfc3RhdGU7XG4gIH1cbiAgdGhyb3cgY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlKFswLGNhbWxfbmFtZWRfdmFsdWUoXCJHcmFwaGljcy5HcmFwaGljX2ZhaWx1cmVcIiksIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJOb3QgaW5pdGlhbGl6ZWRcIildKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlLGNhbWxfZ3Jfc3RhdGVfaW5pdFxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9zZXQoY3R4KSB7XG4gIGNhbWxfZ3Jfc3RhdGU9Y3R4O1xuICBjYW1sX2dyX3N0YXRlX2luaXQoKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9vcGVuX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX29wZW5fZ3JhcGgoaW5mbyl7XG4gIHZhciBpbmZvID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoaW5mbyk7XG4gIGZ1bmN0aW9uIGdldChuYW1lKXtcbiAgICB2YXIgcmVzID0gaW5mby5tYXRjaChcIihefCwpICpcIituYW1lK1wiICo9ICooW2EtekEtWjAtOV9dKykgKigsfCQpXCIpO1xuICAgIGlmKHJlcykgcmV0dXJuIHJlc1syXTtcbiAgfVxuICB2YXIgc3BlY3MgPSBbXTtcbiAgaWYoIShpbmZvPT1cIlwiKSkgc3BlY3MucHVzaChpbmZvKTtcbiAgdmFyIHRhcmdldCA9IGdldChcInRhcmdldFwiKTtcbiAgaWYoIXRhcmdldCkgdGFyZ2V0PVwiXCI7XG4gIHZhciBzdGF0dXMgPSBnZXQoXCJzdGF0dXNcIik7XG4gIGlmKCFzdGF0dXMpIHNwZWNzLnB1c2goXCJzdGF0dXM9MVwiKVxuXG4gIHZhciB3ID0gZ2V0KFwid2lkdGhcIik7XG4gIHcgPSB3P3BhcnNlSW50KHcpOjIwMDtcbiAgc3BlY3MucHVzaChcIndpZHRoPVwiK3cpO1xuXG4gIHZhciBoID0gZ2V0KFwiaGVpZ2h0XCIpO1xuICBoID0gaD9wYXJzZUludChoKToyMDA7XG4gIHNwZWNzLnB1c2goXCJoZWlnaHQ9XCIraCk7XG5cbiAgdmFyIHdpbiA9IGdsb2JhbFRoaXMub3BlbihcImFib3V0OmJsYW5rXCIsdGFyZ2V0LHNwZWNzLmpvaW4oXCIsXCIpKTtcbiAgaWYoIXdpbikge2NhbWxfZmFpbHdpdGgoXCJHcmFwaGljcy5vcGVuX2dyYXBoOiBjYW5ub3Qgb3BlbiB0aGUgd2luZG93XCIpfVxuICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuICB2YXIgY2FudmFzID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNhbnZhcy53aWR0aCA9IHc7XG4gIGNhbnZhcy5oZWlnaHQgPSBoO1xuICB2YXIgY3R4ID0gY2FtbF9ncl9zdGF0ZV9jcmVhdGUoY2FudmFzLHcsaCk7XG4gIGN0eC5zZXRfdGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICBkb2MudGl0bGUgPSB0aXRsZTtcbiAgfTtcbiAgY2FtbF9ncl9zdGF0ZV9zZXQoY3R4KTtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgYm9keS5zdHlsZS5tYXJnaW4gPSBcIjBweFwiO1xuICBib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2luaXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X2NvbG9yLGNhbWxfZ3JfbW92ZXRvLGNhbWxfZ3JfcmVzaXplX3dpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfbGluZV93aWR0aCxjYW1sX2dyX3NldF90ZXh0X3NpemUsY2FtbF9ncl9zZXRfZm9udFxuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2luaXQoKXtcbiAgY2FtbF9ncl9tb3ZldG8oY2FtbF9ncl9zdGF0ZS54LGNhbWxfZ3Jfc3RhdGUueSk7XG4gIGNhbWxfZ3JfcmVzaXplX3dpbmRvdyhjYW1sX2dyX3N0YXRlLndpZHRoLGNhbWxfZ3Jfc3RhdGUuaGVpZ2h0KTtcbiAgY2FtbF9ncl9zZXRfbGluZV93aWR0aChjYW1sX2dyX3N0YXRlLmxpbmVfd2lkdGgpO1xuICBjYW1sX2dyX3NldF90ZXh0X3NpemUoY2FtbF9ncl9zdGF0ZS50ZXh0X3NpemUpO1xuICBjYW1sX2dyX3NldF9mb250KGNhbWxfZ3Jfc3RhdGUuZm9udCk7XG4gIGNhbWxfZ3Jfc2V0X2NvbG9yKGNhbWxfZ3Jfc3RhdGUuY29sb3IpO1xuICBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUoY2FtbF9ncl9zdGF0ZS50aXRsZSk7XG4gIC8vY2FtbF9ncl9yZXNpemVfd2luZG93IG1pZ2h0IHJlc2V0IHNvbWUgY2FudmFzJyBwcm9wZXJ0aWVzXG4gIGNhbWxfZ3Jfc3RhdGUuY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfY3JlYXRlKGNhbnZhcyx3LGgpe1xuICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIHJldHVybiB7XG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBjYW52YXMgOiBjYW52YXMsXG4gICAgeCA6IDAsXG4gICAgeSA6IDAsXG4gICAgd2lkdGggOiB3LFxuICAgIGhlaWdodCA6IGgsXG4gICAgbGluZV93aWR0aCA6IDEsXG4gICAgZm9udCA6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJmaXhlZFwiKSxcbiAgICB0ZXh0X3NpemUgOiAyNixcbiAgICBjb2xvciA6IDB4MDAwMDAwLFxuICAgIHRpdGxlIDogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKVxuICB9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RvY19vZl9zdGF0ZVxuZnVuY3Rpb24gY2FtbF9ncl9kb2Nfb2Zfc3RhdGUoc3RhdGUpIHtcbiAgaWYoc3RhdGUuY2FudmFzLm93bmVyRG9jdW1lbnQpXG4gICAgcmV0dXJuIHN0YXRlLmNhbnZhcy5vd25lckRvY3VtZW50O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Nsb3NlX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jbG9zZV9ncmFwaCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY2FudmFzLndpZHRoID0gMDtcbiAgcy5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUobmFtZSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy50aXRsZSA9IG5hbWU7XG4gIHZhciBqc25hbWUgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYocy5zZXRfdGl0bGUpIHMuc2V0X3RpdGxlKGpzbmFtZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3codyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpXG4gIHMud2lkdGggPSB3O1xuICBzLmhlaWdodCA9IGg7XG4gIHMuY2FudmFzLndpZHRoID0gdztcbiAgcy5jYW52YXMuaGVpZ2h0ID0gaDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xlYXJfZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NsZWFyX2dyYXBoKCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jYW52YXMud2lkdGggPSBzLndpZHRoO1xuICBzLmNhbnZhcy5oZWlnaHQgPSBzLmhlaWdodDtcbiAgLy8gIHMuY29udGV4dC5zdHJva2VSZWN0ICgwLiwgMC4sIHMud2lkdGgsIHMuaGVpZ2h0KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2l6ZV94XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zaXplX3goKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy53aWR0aDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2l6ZV95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zaXplX3koKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy5oZWlnaHQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfY29sb3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NldF9jb2xvcihjb2xvcil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgZnVuY3Rpb24gY29udmVydChudW1iZXIpIHtcbiAgICB2YXIgc3RyID0gJycgKyBudW1iZXIudG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgMikgc3RyID0gJzAnICsgc3RyO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgdmFyXG4gIHIgPSAoY29sb3IgPj4gMTYpICYgMHhmZixcbiAgZyA9IChjb2xvciA+PiA4KSAgJiAweGZmLFxuICBiID0gKGNvbG9yID4+IDApICAmIDB4ZmY7XG4gIHMuY29sb3I9Y29sb3I7XG4gIHZhciBjX3N0ciA9ICcjJyArIGNvbnZlcnQocikgKyBjb252ZXJ0KGcpICsgY29udmVydChiKTtcbiAgcy5jb250ZXh0LmZpbGxTdHlsZSA9ICAgY19zdHI7XG4gIHMuY29udGV4dC5zdHJva2VTdHlsZSA9IGNfc3RyO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcGxvdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcGxvdCh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbT1zLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKDEsMSk7XG4gIHZhciBkID0gaW0uZGF0YTtcbiAgdmFyIGNvbG9yID0gcy5jb2xvcjtcbiAgZFswXSA9IChjb2xvciA+PiAxNikgJiAweGZmOyAvL3JcbiAgZFsxXSA9IChjb2xvciA+PiA4KSAgJiAweGZmLCAvL2dcbiAgZFsyXSA9IChjb2xvciA+PiAwKSAgJiAweGZmOyAvL2JcbiAgZFszXSA9IDB4RkY7IC8vYVxuICBzLng9eDtcbiAgcy55PXk7XG4gIHMuY29udGV4dC5wdXRJbWFnZURhdGEoaW0seCxzLmhlaWdodCAtIHkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9wb2ludF9jb2xvclxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcG9pbnRfY29sb3IoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW09cy5jb250ZXh0LmdldEltYWdlRGF0YSh4LHMuaGVpZ2h0IC0geSwxLDEpO1xuICB2YXIgZCA9IGltLmRhdGE7XG4gIHJldHVybiAoZFswXSA8PCAxNikgKyAoZFsxXSA8PCA4KSArIGRbMl07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21vdmV0b1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbW92ZXRvKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy54PXg7XG4gIHMueT15O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jdXJyZW50X3hcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2N1cnJlbnRfeCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLnhcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3VycmVudF95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jdXJyZW50X3koKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy55XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2xpbmV0b1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbGluZXRvKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBzLmNvbnRleHQubW92ZVRvKHMueCxzLmhlaWdodCAtIHMueSk7XG4gIHMuY29udGV4dC5saW5lVG8oeCxzLmhlaWdodCAtIHkpO1xuICBzLmNvbnRleHQuc3Ryb2tlKCk7XG4gIHMueD14O1xuICBzLnk9eTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfcmVjdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19yZWN0KHgseSx3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5zdHJva2VSZWN0KHgscy5oZWlnaHQgLSB5LHcsLWgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2FyY19hdXgoY3R4LGN4LGN5LHJ5LHJ4LGExLGEyKXtcbiAgd2hpbGUoYTE+YTIpIGEyKz0zNjA7XG4gIGExIC89IDE4MDtcbiAgYTIgLz0gMTgwO1xuICB2YXIgcm90ID0gMCx4UG9zLHlQb3MseFBvc19wcmV2LHlQb3NfcHJldjtcbiAgdmFyIHNwYWNlID0gMjtcbiAgdmFyIG51bSA9ICgoKGEyIC0gYTEpICogTWF0aC5QSSAqICgocngrcnkpLzIpKSAvIHNwYWNlKSB8IDA7XG4gIHZhciBkZWx0YSA9IChhMiAtIGExKSAqIE1hdGguUEkgLyBudW07XG4gIHZhciBpID0gYTEgKiBNYXRoLlBJO1xuICBmb3IgKHZhciBqPTA7ajw9bnVtO2orKyl7XG4gICAgeFBvcyA9IGN4IC0gKHJ4ICogTWF0aC5zaW4oaSkpICogTWF0aC5zaW4ocm90ICogTWF0aC5QSSkgKyAocnkgKiBNYXRoLmNvcyhpKSkgKiBNYXRoLmNvcyhyb3QgKiBNYXRoLlBJKTtcbiAgICB4UG9zID0geFBvcy50b0ZpeGVkKDIpO1xuICAgIHlQb3MgPSBjeSArIChyeSAqIE1hdGguY29zKGkpKSAqIE1hdGguc2luKHJvdCAqIE1hdGguUEkpICsgKHJ4ICogTWF0aC5zaW4oaSkpICogTWF0aC5jb3Mocm90ICogTWF0aC5QSSk7XG4gICAgeVBvcyA9IHlQb3MudG9GaXhlZCgyKTtcbiAgICBpZiAoaj09MCkge1xuICAgICAgY3R4Lm1vdmVUbyh4UG9zLCB5UG9zKTtcbiAgICB9IGVsc2UgaWYgKHhQb3NfcHJldiE9eFBvcyB8fCB5UG9zX3ByZXYhPXlQb3Mpe1xuICAgICAgY3R4LmxpbmVUbyh4UG9zLCB5UG9zKTtcbiAgICB9XG4gICAgeFBvc19wcmV2PXhQb3M7XG4gICAgeVBvc19wcmV2PXlQb3M7XG4gICAgaS09IGRlbHRhOy8vY2N3XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2FyY1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXQsIGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2FyYyh4LHkscngscnksYTEsYTIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY2FtbF9ncl9hcmNfYXV4KHMuY29udGV4dCx4LHMuaGVpZ2h0IC0geSxyeCxyeSxhMSxhMik7XG4gIHMuY29udGV4dC5zdHJva2UoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NldF9saW5lX3dpZHRoKHcpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMubGluZV93aWR0aCA9IHc7XG4gIHMuY29udGV4dC5saW5lV2lkdGggPSB3XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfcmVjdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9yZWN0KHgseSx3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5maWxsUmVjdCh4LHMuaGVpZ2h0IC0geSx3LC1oKTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfcG9seVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9wb2x5KGFyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHMuY29udGV4dC5tb3ZlVG8oYXJbMV1bMV0scy5oZWlnaHQgLSBhclsxXVsyXSk7XG4gIGZvcih2YXIgaSA9IDI7IGkgPCBhci5sZW5ndGg7IGkrKylcbiAgICBzLmNvbnRleHQubGluZVRvKGFyW2ldWzFdLHMuaGVpZ2h0IC0gYXJbaV1bMl0pO1xuICBzLmNvbnRleHQubGluZVRvKGFyWzFdWzFdLHMuaGVpZ2h0IC0gYXJbMV1bMl0pO1xuICBzLmNvbnRleHQuZmlsbCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX2FyY1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXQsIGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX2FyYyh4LHkscngscnksYTEsYTIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY2FtbF9ncl9hcmNfYXV4KHMuY29udGV4dCx4LHMuaGVpZ2h0IC0geSxyeCxyeSxhMSxhMik7XG4gIHMuY29udGV4dC5maWxsKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3N0cihzdHIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBtID0gcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHN0cik7XG4gIHZhciBkeCA9IG0ud2lkdGg7XG4gIHMuY29udGV4dC5maWxsVGV4dChzdHIscy54LHMuaGVpZ2h0IC0gcy55KTtcbiAgcy54ICs9IGR4IHwgMDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX2dyX2RyYXdfc3RyXG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfY2hhcihjKXtcbiAgY2FtbF9ncl9kcmF3X3N0cihTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfZ3JfZHJhd19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfc3RyaW5nKHN0cil7XG4gIGNhbWxfZ3JfZHJhd19zdHIoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoc3RyKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9mb250XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2ZvbnQoZil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5mb250ID0gZjtcbiAgcy5jb250ZXh0LmZvbnQgPSBzLnRleHRfc2l6ZSArIFwicHggXCIgKyBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzLmZvbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfdGV4dF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZShzaXplKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLnRleHRfc2l6ZSA9IHNpemU7XG4gIHMuY29udGV4dC5mb250ID0gcy50ZXh0X3NpemUgKyBcInB4IFwiICsgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocy5mb250KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfdGV4dF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3JfdGV4dF9zaXplKHR4dCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIHcgPSBzLmNvbnRleHQubWVhc3VyZVRleHQoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcodHh0KSkud2lkdGg7XG4gIHJldHVybiBbMCx3LHMudGV4dF9zaXplXTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21ha2VfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX21ha2VfaW1hZ2UoYXJyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaCA9IGFyci5sZW5ndGggLSAxIDtcbiAgdmFyIHcgPSBhcnJbMV0ubGVuZ3RoIC0gMTtcbiAgdmFyIGltID0gcy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3LGgpO1xuICBmb3IodmFyIGk9MDtpPGg7aSsrKXtcbiAgICBmb3IodmFyIGo9MDtqPHc7aisrKXtcbiAgICAgIHZhciBjID0gYXJyW2krMV1baisxXTtcbiAgICAgIHZhciBvID0gaSoodyo0KSArIChqICogNCk7XG4gICAgICBpZihjID09IC0xKSB7XG4gICAgICAgIGltLmRhdGFbbyArIDBdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgMV0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAyXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDNdID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltLmRhdGFbbyArIDBdID0gYyA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDFdID0gYyA+PiAgOCAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDJdID0gYyA+PiAgMCAmIDBYZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDNdID0gMHhmZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGltXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2R1bXBfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2R1bXBfaW1hZ2UoaW0pe1xuICB2YXIgZGF0YSA9IFswXVxuICBmb3IodmFyIGk9MDsgaTxpbS5oZWlnaHQ7aSsrKXtcbiAgICBkYXRhW2krMV0gPSBbMF1cbiAgICBmb3IodmFyIGo9MDsgajxpbS53aWR0aDtqKyspe1xuICAgICAgdmFyIG8gPSBpKihpbS53aWR0aCo0KSArIChqICogNCksXG4gICAgICAgICAgciA9IGltLmRhdGFbbyswXSxcbiAgICAgICAgICBnID0gaW0uZGF0YVtvKzFdLFxuICAgICAgICAgIGIgPSBpbS5kYXRhW28rMl07XG4gICAgICBkYXRhW2krMV1baisxXSA9IChyIDw8IDE2KSArIChnIDw8IDgpICsgYlxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2ltYWdlKGltLHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgaWYoIWltLmltYWdlKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gcy53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gcy5oZWlnaHQ7XG4gICAgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5wdXRJbWFnZURhdGEoaW0sMCwwKTtcbiAgICB2YXIgaW1hZ2UgPSBuZXcgZ2xvYmFsVGhpcy5JbWFnZSgpO1xuICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHMuY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UseCxzLmhlaWdodCAtIGltLmhlaWdodCAtIHkpO1xuICAgICAgaW0uaW1hZ2UgPSBpbWFnZTtcbiAgICB9XG4gICAgaW1hZ2Uuc3JjID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgfSBlbHNlIHtcbiAgICBzLmNvbnRleHQuZHJhd0ltYWdlKGltLmltYWdlLHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3JlYXRlX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jcmVhdGVfaW1hZ2UoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh4LHkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9ibGl0X2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9ibGl0X2ltYWdlKGltLHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltMiA9IHMuY29udGV4dC5nZXRJbWFnZURhdGEoeCxzLmhlaWdodCAtIGltLmhlaWdodCAtIHksaW0ud2lkdGgsaW0uaGVpZ2h0KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbTIuZGF0YS5sZW5ndGg7IGkrPTQpe1xuICAgIGltLmRhdGFbaV0gPSBpbTIuZGF0YVtpXTtcbiAgICBpbS5kYXRhW2krMV0gPSBpbTIuZGF0YVtpKzFdO1xuICAgIGltLmRhdGFbaSsyXSA9IGltMi5kYXRhW2krMl07XG4gICAgaW0uZGF0YVtpKzNdID0gaW0yLmRhdGFbaSszXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2lnaW9faGFuZGxlclxuZnVuY3Rpb24gY2FtbF9ncl9zaWdpb19oYW5kbGVyKCl7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpZ2lvX3NpZ25hbFxuZnVuY3Rpb24gY2FtbF9ncl9zaWdpb19zaWduYWwoKXtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfd2FpdF9ldmVudFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl93YWl0X2V2ZW50KF9ldmwpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl93YWl0X2V2ZW50IG5vdCBJbXBsZW1lbnRlZDogdXNlIEdyYXBoaWNzX2pzIGluc3RlYWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3luY2hyb25pemVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3luY2hyb25pemUgKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9zeW5jaHJvbml6ZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3JlbWVtYmVyX21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3JfcmVtZW1iZXJfbW9kZSAoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3JlbWVtYmVyX21vZGUgbm90IEltcGxlbWVudGVkXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kaXNwbGF5X21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3JfZGlzcGxheV9tb2RlKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9kaXNwbGF5X21vZGUgbm90IEltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3dpbmRvd19pZFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl93aW5kb3dfaWQoYSkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl93aW5kb3dfaWQgbm90IEltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX29wZW5fc3Vid2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX29wZW5fc3Vid2luZG93KGEsYixjLGQpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3cgbm90IEltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Nsb3NlX3N1YndpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3coYSkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3cgbm90IEltcGxlbWVudGVkXCIpO1xufVxuIiwiXG4vL1Byb3ZpZGVzOiBjYW1sX2N1c3RvbV9ldmVudF9pbmRleFxudmFyIGNhbWxfY3VzdG9tX2V2ZW50X2luZGV4ID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3JlZ2lzdGVyXG4vL1JlcXVpcmVzOiBjYW1sX2N1c3RvbV9ldmVudF9pbmRleFxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3JlZ2lzdGVyKGV2ZW50X25hbWUsIGV2ZW50X3RhZywgZXZlbnRfdHlwZSkge1xuICBjYW1sX2N1c3RvbV9ldmVudF9pbmRleCArPSAxO1xuICByZXR1cm4gWzAsIGNhbWxfY3VzdG9tX2V2ZW50X2luZGV4LCBldmVudF9uYW1lLCBldmVudF90eXBlLCBldmVudF90YWddO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfd3JpdGVcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfdXNlcl93cml0ZShldmVudCwgZXZlbnRfY29udGVudCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3Jlc29sdmVcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfdXNlcl9yZXNvbHZlKCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX2V2ZW50c19zdGFydFxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c19zdGFydCgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9ldmVudHNfcGF1c2VcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfcGF1c2UoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3Jlc3VtZVxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c19yZXN1bWUoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX2NyZWF0ZV9jdXJzb3JcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfY3JlYXRlX2N1cnNvcih0YXJnZXQpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX2ZyZWVfY3Vyc29yXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfZXZlbnRzX2ZyZWVfY3Vyc29yKGN1cnNvcikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX2V2ZW50c19yZWFkX3BvbGxcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfcmVhZF9wb2xsKGN1cnNvciwgY2FsbGJhY2tzLCBudW0pIHtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2NvbnN0YW50c1xudmFyIGNhbWxfbWFyc2hhbF9jb25zdGFudHMgPSB7XG4gIFBSRUZJWF9TTUFMTF9CTE9DSzogICAgICAgICAweDgwLFxuICBQUkVGSVhfU01BTExfSU5UOiAgICAgICAgICAgMHg0MCxcbiAgUFJFRklYX1NNQUxMX1NUUklORzogICAgICAgIDB4MjAsXG4gIENPREVfSU5UODogICAgICAgICAgICAgICAgICAweDAwLFxuICBDT0RFX0lOVDE2OiAgICAgICAgICAgICAgICAgMHgwMSxcbiAgQ09ERV9JTlQzMjogICAgICAgICAgICAgICAgIDB4MDIsXG4gIENPREVfSU5UNjQ6ICAgICAgICAgICAgICAgICAweDAzLFxuICBDT0RFX1NIQVJFRDg6ICAgICAgICAgICAgICAgMHgwNCxcbiAgQ09ERV9TSEFSRUQxNjogICAgICAgICAgICAgIDB4MDUsXG4gIENPREVfU0hBUkVEMzI6ICAgICAgICAgICAgICAweDA2LFxuICBDT0RFX0JMT0NLMzI6ICAgICAgICAgICAgICAgMHgwOCxcbiAgQ09ERV9CTE9DSzY0OiAgICAgICAgICAgICAgIDB4MTMsXG4gIENPREVfU1RSSU5HODogICAgICAgICAgICAgICAweDA5LFxuICBDT0RFX1NUUklORzMyOiAgICAgICAgICAgICAgMHgwQSxcbiAgQ09ERV9ET1VCTEVfQklHOiAgICAgICAgICAgIDB4MEIsXG4gIENPREVfRE9VQkxFX0xJVFRMRTogICAgICAgICAweDBDLFxuICBDT0RFX0RPVUJMRV9BUlJBWThfQklHOiAgICAgMHgwRCxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTogIDB4MEUsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfQklHOiAgICAweDBGLFxuICBDT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTogMHgwNyxcbiAgQ09ERV9DT0RFUE9JTlRFUjogICAgICAgICAgIDB4MTAsXG4gIENPREVfSU5GSVhQT0lOVEVSOiAgICAgICAgICAweDExLFxuICBDT0RFX0NVU1RPTTogICAgICAgICAgICAgICAgMHgxMixcbiAgQ09ERV9DVVNUT01fTEVOOiAgICAgICAgICAgIDB4MTgsXG4gIENPREVfQ1VTVE9NX0ZJWEVEOiAgICAgICAgICAweDE5XG59XG5cblxuLy9Qcm92aWRlczogVUludDhBcnJheVJlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXksIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIFVJbnQ4QXJyYXlSZWFkZXIgKHMsIGkpIHsgdGhpcy5zID0gczsgdGhpcy5pID0gaTsgfVxuVUludDhBcnJheVJlYWRlci5wcm90b3R5cGUgPSB7XG4gIHJlYWQ4dTpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnNbdGhpcy5pKytdOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zW3RoaXMuaSsrXSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzW2ldIDw8IDgpIHwgc1tpICsgMV1cbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzW2ldIDw8IDI0ID4+IDE2KSB8IHNbaSArIDFdO1xuICB9LFxuICByZWFkMzJ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKChzW2ldIDw8IDI0KSB8IChzW2krMV0gPDwgMTYpIHxcbiAgICAgICAgICAgIChzW2krMl0gPDwgOCkgfCBzW2krM10pID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKHNbaV0gPDwgMjQpIHwgKHNbaSsxXSA8PCAxNikgfFxuICAgICAgKHNbaSsyXSA8PCA4KSB8IHNbaSszXTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkodGhpcy5zLnN1YmFycmF5KGksIGkgKyBsZW4pKTtcbiAgfSxcbiAgcmVhZHVpbnQ4YXJyYXk6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIHRoaXMucy5zdWJhcnJheShpLCBpICsgbGVuKTtcbiAgfVxufVxuXG5cbi8vUHJvdmlkZXM6IE1sU3RyaW5nUmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBNbFN0cmluZ1JlYWRlciAocywgaSkgeyB0aGlzLnMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpOyB0aGlzLmkgPSBpOyB9XG5NbFN0cmluZ1JlYWRlci5wcm90b3R5cGUgPSB7XG4gIHJlYWQ4dTpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnMuY2hhckNvZGVBdCh0aGlzLmkrKyk7IH0sXG4gIHJlYWQ4czpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnMuY2hhckNvZGVBdCh0aGlzLmkrKykgPDwgMjQgPj4gMjQ7IH0sXG4gIHJlYWQxNnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkgKyAxKVxuICB9LFxuICByZWFkMTZzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCAyNCA+PiAxNikgfCBzLmNoYXJDb2RlQXQoaSArIDEpO1xuICB9LFxuICByZWFkMzJ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKChzLmNoYXJDb2RlQXQoaSkgPDwgMjQpIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDE2KSB8XG4gICAgICAgICAgICAocy5jaGFyQ29kZUF0KGkrMikgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSszKSkgPj4+IDA7XG4gIH0sXG4gIHJlYWQzMnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCAxNikgfFxuICAgICAgKHMuY2hhckNvZGVBdChpKzIpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkrMyk7XG4gIH0sXG4gIHJlYWRzdHI6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXModGhpcy5zLnN1YnN0cmluZyhpLCBpICsgbGVuKSk7XG4gIH0sXG4gIHJlYWR1aW50OGFycmF5OmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgdmFyIHMgPSB0aGlzLnM7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBiW2pdID0gcy5jaGFyQ29kZUF0KGkgKyBqKTtcbiAgICB9XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gYjtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBCaWdTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBCaWdTdHJpbmdSZWFkZXIgKGJzLCBpKSB7IHRoaXMucyA9IGJzOyB0aGlzLmkgPSBpOyB9XG5CaWdTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCA4KSB8IGNhbWxfYmFfZ2V0XzEocyxpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgPDwgMjQgPj4gMTYpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAgICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMykgICAgICAgICApID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSAgIDw8IDI0KSB8IChjYW1sX2JhX2dldF8xKHMsaSsxKSA8PCAxNikgfFxuICAgICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB2YXIgYXJyID0gbmV3IEFycmF5KGxlbilcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspe1xuICAgICAgYXJyW2pdID0gY2FtbF9iYV9nZXRfMSh0aGlzLnMsIGkraik7XG4gICAgfVxuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIH0sXG4gIHJlYWR1aW50OGFycmF5OmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoaSk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gdGhpcy5zLmRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICB9XG59XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKGEpIHtcbiAgcmV0dXJuIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoY2FtbF9pbnQ2NF9vZl9ieXRlcyAoYSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sU3RyaW5nUmVhZGVyLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nKHMsb2ZzKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgTWxTdHJpbmdSZWFkZXIgKHMsIHR5cGVvZiBvZnM9PVwibnVtYmVyXCI/b2ZzOm9mc1swXSk7XG4gIHJldHVybiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxTdHJpbmdSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIsIGNhbWxfc3RyaW5nX29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbFN0cmluZ1JlYWRlciAoY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocyksIHR5cGVvZiBvZnM9PVwibnVtYmVyXCI/b2ZzOm9mc1swXSk7XG4gIHJldHVybiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF91bm1hcnNoYWwocmVhZGVyLCBzaXplKXtcbiAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gIHNpemVbMF0gPSA4O1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyAodCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tYXJzaGFsKHdyaXRlciwgdiwgc2l6ZXMpIHtcbiAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzICh2KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHdyaXRlci53cml0ZSAoOCwgYltpXSk7XG4gIHNpemVzWzBdID0gODsgc2l6ZXNbMV0gPSA4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX3VubWFyc2hhbFxuZnVuY3Rpb24gY2FtbF9pbnQzMl91bm1hcnNoYWwocmVhZGVyLCBzaXplKXtcbiAgc2l6ZVswXSA9IDQ7XG4gIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWwocmVhZGVyLCBzaXplKXtcbiAgc3dpdGNoIChyZWFkZXIucmVhZDh1ICgpKSB7XG4gIGNhc2UgMTpcbiAgICBzaXplWzBdID0gNDtcbiAgICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG4gIGNhc2UgMjpcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IG5hdGl2ZSBpbnRlZ2VyIHZhbHVlIHRvbyBsYXJnZVwiKTtcbiAgZGVmYXVsdDogY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG5hdGl2ZSBpbnRlZ2VyXCIpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF91bm1hcnNoYWwsIGNhbWxfaW50NjRfbWFyc2hhbCwgY2FtbF9pbnQ2NF9jb21wYXJlLCBjYW1sX2ludDY0X2hhc2hcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfdW5tYXJzaGFsLCBjYW1sX25hdGl2ZWludF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfYmFfc2VyaWFsaXplLCBjYW1sX2JhX2Rlc2VyaWFsaXplLCBjYW1sX2JhX2NvbXBhcmUsIGNhbWxfYmFfaGFzaFxudmFyIGNhbWxfY3VzdG9tX29wcyA9XG4gICAge1wiX2pcIjoge1xuICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX2ludDY0X3VubWFyc2hhbCxcbiAgICAgIHNlcmlhbGl6ZSAgOiBjYW1sX2ludDY0X21hcnNoYWwsXG4gICAgICBmaXhlZF9sZW5ndGggOiA4LFxuICAgICAgY29tcGFyZSA6IGNhbWxfaW50NjRfY29tcGFyZSxcbiAgICAgIGhhc2ggOiBjYW1sX2ludDY0X2hhc2hcbiAgICB9LFxuICAgICBcIl9pXCI6IHtcbiAgICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfaW50MzJfdW5tYXJzaGFsLFxuICAgICAgIGZpeGVkX2xlbmd0aCA6IDQsXG4gICAgIH0sXG4gICAgIFwiX25cIjoge1xuICAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsLFxuICAgICAgIGZpeGVkX2xlbmd0aCA6IDQsXG4gICAgIH0sXG4gICAgIFwiX2JpZ2FycmF5XCI6e1xuICAgICAgIGRlc2VyaWFsaXplIDogKGZ1bmN0aW9uIChyZWFkZXIsIHN6KSB7cmV0dXJuIGNhbWxfYmFfZGVzZXJpYWxpemUgKHJlYWRlcixzeixcIl9iaWdhcnJheVwiKX0pLFxuICAgICAgIHNlcmlhbGl6ZSA6IGNhbWxfYmFfc2VyaWFsaXplLFxuICAgICAgIGNvbXBhcmUgOiBjYW1sX2JhX2NvbXBhcmUsXG4gICAgICAgaGFzaDogY2FtbF9iYV9oYXNoLFxuICAgICB9LFxuICAgICBcIl9iaWdhcnIwMlwiOntcbiAgICAgICBkZXNlcmlhbGl6ZSA6IChmdW5jdGlvbiAocmVhZGVyLCBzeikge3JldHVybiBjYW1sX2JhX2Rlc2VyaWFsaXplIChyZWFkZXIsc3osXCJfYmlnYXJyMDJcIil9KSxcbiAgICAgICBzZXJpYWxpemUgOiBjYW1sX2JhX3NlcmlhbGl6ZSxcbiAgICAgICBjb21wYXJlIDogY2FtbF9iYV9jb21wYXJlLFxuICAgICAgIGhhc2g6IGNhbWxfYmFfaGFzaCxcbiAgICAgfVxuICAgIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2Zsb2F0X29mX2J5dGVzLCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IHpzdGRfZGVjb21wcmVzc1xuLy9SZXF1aXJlczogVUludDhBcnJheVJlYWRlclxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcykge1xuICBmdW5jdGlvbiByZWFkdmxxKG92ZXJmbG93KSB7XG4gICAgdmFyIGMgPSByZWFkZXIucmVhZDh1KCk7XG4gICAgdmFyIG4gPSBjICYgMHg3RjtcbiAgICB3aGlsZSAoKGMgJiAweDgwKSAhPSAwKSB7XG4gICAgICBjID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIG43ID0gbiA8PCA3O1xuICAgICAgaWYgKG4gIT0gbjcgPj4gNykgb3ZlcmZsb3dbMF0gPSB0cnVlO1xuICAgICAgbiA9IG43IHwgKGMgJiAweDdGKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgdmFyIG1hZ2ljID0gcmVhZGVyLnJlYWQzMnUgKClcbiAgc3dpdGNoKG1hZ2ljKXtcbiAgY2FzZSAweDg0OTVBNkJFOiAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX3NtYWxsICovXG4gICAgdmFyIGhlYWRlcl9sZW4gPSAyMDtcbiAgICB2YXIgY29tcHJlc3NlZCA9IDA7XG4gICAgdmFyIGRhdGFfbGVuID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgdmFyIHVuY29tcHJlc3NlZF9kYXRhX2xlbiA9IGRhdGFfbGVuO1xuICAgIHZhciBudW1fb2JqZWN0cyA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgIHZhciBfc2l6ZV8zMiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgIHZhciBfc2l6ZV82NCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgIGJyZWFrXG4gIGNhc2UgMHg4NDk1QTZCRDogLyogSW50ZXh0X21hZ2ljX251bWJlcl9jb21wcmVzc2VkICovXG4gICAgdmFyIGhlYWRlcl9sZW4gPSByZWFkZXIucmVhZDh1KCkgJiAweDNGO1xuICAgIHZhciBjb21wcmVzc2VkID0gMTtcbiAgICB2YXIgb3ZlcmZsb3cgPSBbZmFsc2VdO1xuICAgIHZhciBkYXRhX2xlbiA9IHJlYWR2bHEob3ZlcmZsb3cpO1xuICAgIHZhciB1bmNvbXByZXNzZWRfZGF0YV9sZW4gPSByZWFkdmxxKG92ZXJmbG93KTtcbiAgICB2YXIgbnVtX29iamVjdHMgPSByZWFkdmxxKG92ZXJmbG93KTtcbiAgICB2YXIgX3NpemVfMzIgPSByZWFkdmxxIChvdmVyZmxvdyk7XG4gICAgdmFyIF9zaXplXzY0ID0gcmVhZHZscSAob3ZlcmZsb3cpO1xuICAgIGlmKG92ZXJmbG93WzBdKXtcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXI6IG9iamVjdCB0b28gbGFyZ2UgdG8gYmUgcmVhZCBiYWNrIG9uIHRoaXMgcGxhdGZvcm1cIik7XG4gICAgfVxuICAgIGJyZWFrXG4gIGNhc2UgMHg4NDk1QTZCRjogLyogSW50ZXh0X21hZ2ljX251bWJlcl9iaWcgKi9cbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcjogb2JqZWN0IHRvbyBsYXJnZSB0byBiZSByZWFkIGJhY2sgb24gYSAzMi1iaXQgcGxhdGZvcm1cIik7XG4gICAgYnJlYWtcbiAgZGVmYXVsdDpcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcjogYmFkIG9iamVjdFwiKTtcbiAgICBicmVhaztcbiAgfVxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGludGVybl9vYmpfdGFibGUgPSAobnVtX29iamVjdHMgPiAwKT9bXTpudWxsO1xuICB2YXIgb2JqX2NvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBpbnRlcm5fcmVjIChyZWFkZXIpIHtcbiAgICB2YXIgY29kZSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgaWYgKGNvZGUgPj0gMHg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8pIHtcbiAgICAgIGlmIChjb2RlID49IDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8pIHtcbiAgICAgICAgdmFyIHRhZyA9IGNvZGUgJiAweEY7XG4gICAgICAgIHZhciBzaXplID0gKGNvZGUgPj4gNCkgJiAweDc7XG4gICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiAoY29kZSAmIDB4M0YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29kZSA+PSAweDIwLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyAqLykge1xuICAgICAgICB2YXIgbGVuID0gY29kZSAmIDB4MUY7XG4gICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2goY29kZSkge1xuICAgICAgICBjYXNlIDB4MDA6IC8vY3N0LkNPREVfSU5UODpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQ4cyAoKTtcbiAgICAgICAgY2FzZSAweDAxOiAvL2NzdC5DT0RFX0lOVDE2OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDE2cyAoKTtcbiAgICAgICAgY2FzZSAweDAyOiAvL2NzdC5DT0RFX0lOVDMyOlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgICAgICAgY2FzZSAweDAzOiAvL2NzdC5DT0RFX0lOVDY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaW50ZWdlciB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwNDogLy9jc3QuQ09ERV9TSEFSRUQ4OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIGlmKGNvbXByZXNzZWQgPT0gMCkgb2Zmc2V0ID0gb2JqX2NvdW50ZXIgLSBvZmZzZXQ7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA1OiAvL2NzdC5DT0RFX1NIQVJFRDE2OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDE2dSAoKTtcbiAgICAgICAgICBpZihjb21wcmVzc2VkID09IDApIG9mZnNldCA9IG9ial9jb3VudGVyIC0gb2Zmc2V0O1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNjogLy9jc3QuQ09ERV9TSEFSRUQzMjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgaWYoY29tcHJlc3NlZCA9PSAwKSBvZmZzZXQgPSBvYmpfY291bnRlciAtIG9mZnNldDtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDg6IC8vY3N0LkNPREVfQkxPQ0szMjpcbiAgICAgICAgICB2YXIgaGVhZGVyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgdmFyIHRhZyA9IGhlYWRlciAmIDB4RkY7XG4gICAgICAgICAgdmFyIHNpemUgPSBoZWFkZXIgPj4gMTA7XG4gICAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEzOiAvL2NzdC5DT0RFX0JMT0NLNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogZGF0YSBibG9jayB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwOTogLy9jc3QuQ09ERV9TVFJJTkc4OlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQTogLy9jc3QuQ09ERV9TVFJJTkczMjpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBDOiAvL2NzdC5DT0RFX0RPVUJMRV9MSVRUTEU6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFs3IC0gaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEI6IC8vY3N0LkNPREVfRE9VQkxFX0JJRzpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0W2ldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBFOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEQ6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwNzogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEY6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTA6IC8vY3N0LkNPREVfQ09ERVBPSU5URVI6XG4gICAgICAgIGNhc2UgMHgxMTogLy9jc3QuQ09ERV9JTkZJWFBPSU5URVI6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogY29kZSBwb2ludGVyXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTI6IC8vY3N0LkNPREVfQ1VTVE9NOlxuICAgICAgICBjYXNlIDB4MTg6IC8vY3N0LkNPREVfQ1VTVE9NX0xFTjpcbiAgICAgICAgY2FzZSAweDE5OiAvL2NzdC5DT0RFX0NVU1RPTV9GSVhFRDpcbiAgICAgICAgICB2YXIgYywgcyA9IFwiXCI7XG4gICAgICAgICAgd2hpbGUgKChjID0gcmVhZGVyLnJlYWQ4dSAoKSkgIT0gMCkgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW3NdO1xuICAgICAgICAgIHZhciBleHBlY3RlZF9zaXplO1xuICAgICAgICAgIGlmKCFvcHMpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHVua25vd24gY3VzdG9tIGJsb2NrIGlkZW50aWZpZXJcIik7XG4gICAgICAgICAgc3dpdGNoKGNvZGUpe1xuICAgICAgICAgIGNhc2UgMHgxMjogLy8gY3N0LkNPREVfQ1VTVE9NIChkZXByZWNhdGVkKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE5OiAvLyBjc3QuQ09ERV9DVVNUT01fRklYRURcbiAgICAgICAgICAgIGlmKCFvcHMuZml4ZWRfbGVuZ3RoKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGV4cGVjdGVkIGEgZml4ZWQtc2l6ZSBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gb3BzLmZpeGVkX2xlbmd0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHgxODogLy8gY3N0LkNPREVfQ1VTVE9NX0xFTlxuICAgICAgICAgICAgZXhwZWN0ZWRfc2l6ZSA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgICAgLy8gU2tpcCBzaXplNjRcbiAgICAgICAgICAgIHJlYWRlci5yZWFkMzJzKCk7IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9sZF9wb3MgPSByZWFkZXIuaTtcbiAgICAgICAgICB2YXIgc2l6ZSA9IFswXTtcbiAgICAgICAgICB2YXIgdiA9IG9wcy5kZXNlcmlhbGl6ZShyZWFkZXIsIHNpemUpO1xuICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gc2l6ZVswXSlcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbmNvcnJlY3QgbGVuZ3RoIG9mIHNlcmlhbGl6ZWQgY3VzdG9tIGJsb2NrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBtZXNzYWdlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmKGNvbXByZXNzZWQpIHtcbiAgICB2YXIgZGF0YSA9IHJlYWRlci5yZWFkdWludDhhcnJheShkYXRhX2xlbik7XG4gICAgdmFyIHJlcyA9IG5ldyBVaW50OEFycmF5KHVuY29tcHJlc3NlZF9kYXRhX2xlbik7XG4gICAgdmFyIHJlcyA9IHpzdGRfZGVjb21wcmVzcyhkYXRhLCByZXMpO1xuICAgIHZhciByZWFkZXIgPSBuZXcgVUludDhBcnJheVJlYWRlcihyZXMsIDApO1xuICB9XG4gIHZhciByZXMgPSBpbnRlcm5fcmVjIChyZWFkZXIpO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIHZhciBzaXplID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZCA9IHYubGVuZ3RoO1xuICAgIGlmIChkIDwgc2l6ZSkgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICB2W2RdID0gaW50ZXJuX3JlYyAocmVhZGVyKTtcbiAgfVxuICBpZiAodHlwZW9mIG9mcyE9XCJudW1iZXJcIikgb2ZzWzBdID0gcmVhZGVyLmk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZVxuLy9WZXJzaW9uOiA8IDUuMS4wXG52YXIgY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplID0gMjBcblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplXG4vL1ZlcnNpb246ID49IDUuMS4wXG52YXIgY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplID0gMTZcblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBVSW50OEFycmF5UmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemVcbmZ1bmN0aW9uIGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKHMsIG9mcykge1xuICB2YXIgciA9IG5ldyBVSW50OEFycmF5UmVhZGVyKGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMocyksIG9mcyk7XG4gIGZ1bmN0aW9uIHJlYWR2bHEob3ZlcmZsb3cpIHtcbiAgICB2YXIgYyA9IHIucmVhZDh1KCk7XG4gICAgdmFyIG4gPSBjICYgMHg3RjtcbiAgICB3aGlsZSAoKGMgJiAweDgwKSAhPSAwKSB7XG4gICAgICBjID0gci5yZWFkOHUoKTtcbiAgICAgIHZhciBuNyA9IG4gPDwgNztcbiAgICAgIGlmIChuICE9IG43ID4+IDcpIG92ZXJmbG93WzBdID0gdHJ1ZTtcbiAgICAgIG4gPSBuNyB8IChjICYgMHg3Rik7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG5cbiAgc3dpdGNoKHIucmVhZDMydSgpKXtcbiAgY2FzZSAweDg0OTVBNkJFOiAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX3NtYWxsICovXG4gICAgdmFyIGhlYWRlcl9sZW4gPSAyMDtcbiAgICB2YXIgZGF0YV9sZW4gPSByLnJlYWQzMnUoKTtcbiAgICBicmVhaztcbiAgY2FzZSAweDg0OTVBNkJEOiAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX2NvbXByZXNzZWQgKi9cbiAgICB2YXIgaGVhZGVyX2xlbiA9IHIucmVhZDh1KCkgJiAweDNGO1xuICAgIHZhciBvdmVyZmxvdyA9IFtmYWxzZV07XG4gICAgdmFyIGRhdGFfbGVuID0gcmVhZHZscShvdmVyZmxvdyk7XG4gICAgaWYob3ZlcmZsb3dbMF0pe1xuICAgICAgY2FtbF9mYWlsd2l0aChcIk1hcnNoYWwuZGF0YV9zaXplOiBvYmplY3QgdG9vIGxhcmdlIHRvIGJlIHJlYWQgYmFjayBvbiB0aGlzIHBsYXRmb3JtXCIpO1xuICAgIH1cbiAgICBicmVha1xuICBjYXNlIDB4ODQ5NUE2QkY6IC8qIEludGV4dF9tYWdpY19udW1iZXJfYmlnICovXG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9mYWlsd2l0aChcIk1hcnNoYWwuZGF0YV9zaXplOiBiYWQgb2JqZWN0XCIpO1xuICAgIGJyZWFrXG4gIH1cbiAgcmV0dXJuIGhlYWRlcl9sZW4gLSBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUgKyBkYXRhX2xlbjtcbn1cblxuLy9Qcm92aWRlczogTWxPYmplY3RUYWJsZVxudmFyIE1sT2JqZWN0VGFibGU7XG5pZiAodHlwZW9mIGdsb2JhbFRoaXMuTWFwID09PSAndW5kZWZpbmVkJykge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgLyogcG9seWZpbGwgKHVzaW5nIGxpbmVhciBzZWFyY2gpICovXG4gICAgZnVuY3Rpb24gTmFpdmVMb29rdXAob2JqcykgeyB0aGlzLm9ianMgPSBvYmpzOyB9XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLm9ianNbaV0gPT09IHYpIHJldHVybiBpO1xuICAgICAgfVxuICAgIH07XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRG8gbm90aGluZyBoZXJlLiBbTWxPYmplY3RUYWJsZS5zdG9yZV0gd2lsbCBwdXNoIHRvIFt0aGlzLm9ianNdIGRpcmVjdGx5LlxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBOYWl2ZUxvb2t1cCh0aGlzLm9ianMpO1xuICAgIH07XG4gIH0oKTtcbn1cbmVsc2Uge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICB0aGlzLm9ianMgPSBbXTsgdGhpcy5sb29rdXAgPSBuZXcgZ2xvYmFsVGhpcy5NYXAoKTtcbiAgfTtcbn1cblxuTWxPYmplY3RUYWJsZS5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMubG9va3VwLnNldCh2LCB0aGlzLm9ianMubGVuZ3RoKTtcbiAgdGhpcy5vYmpzLnB1c2godik7XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnJlY2FsbCA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIGkgPSB0aGlzLmxvb2t1cC5nZXQodik7XG4gIHJldHVybiAoaSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkIDogdGhpcy5vYmpzLmxlbmd0aCAtIGk7ICAgLyogaW5kZXggaXMgcmVsYXRpdmUgKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IE1sT2JqZWN0VGFibGUsIGNhbWxfbGlzdF90b19qc19hcnJheSwgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9pc19jb250aW51YXRpb25fdGFnXG52YXIgY2FtbF9vdXRwdXRfdmFsID0gZnVuY3Rpb24gKCl7XG4gIGZ1bmN0aW9uIFdyaXRlciAoKSB7IHRoaXMuY2h1bmsgPSBbXTsgfVxuICBXcml0ZXIucHJvdG90eXBlID0ge1xuICAgIGNodW5rX2lkeDoyMCwgYmxvY2tfbGVuOjAsIG9ial9jb3VudGVyOjAsIHNpemVfMzI6MCwgc2l6ZV82NDowLFxuICAgIHdyaXRlOmZ1bmN0aW9uIChzaXplLCB2YWx1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfYXQ6ZnVuY3Rpb24gKHBvcywgc2l6ZSwgdmFsdWUpIHtcbiAgICAgIHZhciBwb3MgPSBwb3M7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1twb3MrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfY29kZTpmdW5jdGlvbiAoc2l6ZSwgY29kZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSBjb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfc2hhcmVkOmZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgIGlmIChvZmZzZXQgPCAoMSA8PCA4KSkgdGhpcy53cml0ZV9jb2RlKDgsIDB4MDQgLypjc3QuQ09ERV9TSEFSRUQ4Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIGlmIChvZmZzZXQgPCAoMSA8PCAxNikpIHRoaXMud3JpdGVfY29kZSgxNiwgMHgwNSAvKmNzdC5DT0RFX1NIQVJFRDE2Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIHRoaXMud3JpdGVfY29kZSgzMiwgMHgwNiAvKmNzdC5DT0RFX1NIQVJFRDMyKi8sIG9mZnNldCk7XG4gICAgfSxcbiAgICBwb3M6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jaHVua19pZHggfSxcbiAgICBmaW5hbGl6ZTpmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJsb2NrX2xlbiA9IHRoaXMuY2h1bmtfaWR4IC0gMjA7XG4gICAgICB0aGlzLmNodW5rX2lkeCA9IDA7XG4gICAgICB0aGlzLndyaXRlICgzMiwgMHg4NDk1QTZCRSk7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5ibG9ja19sZW4pO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMub2JqX2NvdW50ZXIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV8zMik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5zaXplXzY0KTtcbiAgICAgIHJldHVybiB0aGlzLmNodW5rO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKHYsIGZsYWdzKSB7XG4gICAgZmxhZ3MgPSBjYW1sX2xpc3RfdG9fanNfYXJyYXkoZmxhZ3MpO1xuXG4gICAgdmFyIG5vX3NoYXJpbmcgPSAoZmxhZ3MuaW5kZXhPZigwIC8qTWFyc2hhbC5Ob19zaGFyaW5nKi8pICE9PSAtMSksXG4gICAgICAgIGNsb3N1cmVzID0gIChmbGFncy5pbmRleE9mKDEgLypNYXJzaGFsLkNsb3N1cmVzKi8pICE9PSAtMSk7XG4gICAgLyogTWFyc2hhbC5Db21wYXRfMzIgaXMgcmVkdW5kYW50IHNpbmNlIGludGVnZXJzIGFyZSAzMi1iaXQgYW55d2F5ICovXG5cbiAgICBpZiAoY2xvc3VyZXMpXG4gICAgICBjb25zb2xlLndhcm4oXCJpbiBjYW1sX291dHB1dF92YWw6IGZsYWcgTWFyc2hhbC5DbG9zdXJlcyBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcblxuICAgIHZhciB3cml0ZXIgPSBuZXcgV3JpdGVyICgpO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBpbnRlcm5fb2JqX3RhYmxlID0gbm9fc2hhcmluZyA/IG51bGwgOiBuZXcgTWxPYmplY3RUYWJsZSgpO1xuXG4gICAgZnVuY3Rpb24gbWVtbyh2KSB7XG4gICAgICBpZiAobm9fc2hhcmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGV4aXN0aW5nX29mZnNldCA9IGludGVybl9vYmpfdGFibGUucmVjYWxsKHYpO1xuICAgICAgaWYgKGV4aXN0aW5nX29mZnNldCkgeyB3cml0ZXIud3JpdGVfc2hhcmVkKGV4aXN0aW5nX29mZnNldCk7IHJldHVybiB0cnVlOyB9XG4gICAgICBlbHNlIHsgaW50ZXJuX29ial90YWJsZS5zdG9yZSh2KTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZXJuX3JlYyAodikge1xuICAgICAgaWYgKHYuY2FtbF9jdXN0b20pIHtcbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIG5hbWUgPSB2LmNhbWxfY3VzdG9tO1xuICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW25hbWVdO1xuICAgICAgICB2YXIgc3pfMzJfNjQgPSBbMCwwXTtcbiAgICAgICAgaWYoIW9wcy5zZXJpYWxpemUpXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQ3VzdG9tKVwiKTtcbiAgICAgICAgaWYob3BzLmZpeGVkX2xlbmd0aCA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOCAvKmNzdC5DT0RFX0NVU1RPTV9MRU4qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgaGVhZGVyX3BvcyA9IHdyaXRlci5wb3MgKCk7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3BzLnNlcmlhbGl6ZSh3cml0ZXIsIHYsIHN6XzMyXzY0KTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcywgMzIsIHN6XzMyXzY0WzBdKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcyArIDQsIDMyLCAwKTsgLy8gemVyb1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgOCwgMzIsIHN6XzMyXzY0WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTkgLypjc3QuQ09ERV9DVVNUT01fRklYRUQqLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHdyaXRlci5wb3MoKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIGlmIChvcHMuZml4ZWRfbGVuZ3RoICE9IHdyaXRlci5wb3MoKSAtIG9sZF9wb3MpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBpbmNvcnJlY3QgZml4ZWQgc2l6ZXMgc3BlY2lmaWVkIGJ5IFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMiArICgoc3pfMzJfNjRbMF0gKyAzKSA+PiAyKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMiArICgoc3pfMzJfNjRbMV0gKyA3KSA+PiAzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2WzBdID09PSAodlswXXwwKSkge1xuICAgICAgICBpZiAodlswXSA9PSAyNTEpIHtcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQWJzdHJhY3QpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWcodlswXSkpXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwib3V0cHV0X3ZhbHVlOiBjb250aW51YXRpb24gdmFsdWVcIik7XG4gICAgICAgIGlmICh2Lmxlbmd0aCA+IDEgJiYgbWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICBpZiAodlswXSA8IDE2ICYmIHYubGVuZ3RoIC0gMSA8IDgpXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDgwIC8qY3N0LlBSRUZJWF9TTUFMTF9CTE9DSyovICsgdlswXSArICgodi5sZW5ndGggLSAxKTw8NCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDggLypjc3QuQ09ERV9CTE9DSzMyKi8sICgodi5sZW5ndGgtMSkgPDwgMTApIHwgdlswXSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IHYubGVuZ3RoO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSB2Lmxlbmd0aDtcbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSkgc3RhY2sucHVzaCAodiwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXModikpIHtcbiAgICAgICAgaWYoIShjYW1sX2lzX21sX2J5dGVzKGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIikpKSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IFtCeXRlcy50XSBjYW5ub3Qgc2FmZWx5IGJlIG1hcnNoYWxlZCB3aXRoIFstLWVuYWJsZSB1c2UtanMtc3RyaW5nXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9ieXRlc19sZW5ndGgodik7XG4gICAgICAgIGlmIChsZW4gPCAweDIwKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgyMCAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HKi8gKyBsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPCAweDEwMClcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoOCwgMHgwOS8qY3N0LkNPREVfU1RSSU5HOCovLCBsZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDMyLCAweDBBIC8qY3N0LkNPREVfU1RSSU5HMzIqLywgbGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IGxlbjtpKyspXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcodikpIHtcbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICE9ICh2fDApKXtcbiAgICAgICAgICB2YXIgdHlwZV9vZl92ID0gdHlwZW9mIHY7XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBJZiBhIGZsb2F0IGhhcHBlbnMgdG8gYmUgYW4gaW50ZWdlciBpdCBpcyBzZXJpYWxpemVkIGFzIGFuIGludGVnZXJcbiAgICAgICAgICAvLyAoSnNfb2Zfb2NhbWwgY2Fubm90IHRlbGwgd2hldGhlciB0aGUgdHlwZSBvZiBhbiBpbnRlZ2VyIG51bWJlciBpc1xuICAgICAgICAgIC8vIGZsb2F0IG9yIGludGVnZXIuKSBUaGlzIGNhbiByZXN1bHQgaW4gdW5leHBlY3RlZCBjcmFzaGVzIHdoZW5cbiAgICAgICAgICAvLyB1bm1hcnNoYWxsaW5nIHVzaW5nIHRoZSBzdGFuZGFyZCBydW50aW1lLiBJdCBzZWVtcyBiZXR0ZXIgdG9cbiAgICAgICAgICAvLyBzeXN0ZW1hdGljYWxseSBmYWlsIG9uIG1hcnNoYWxsaW5nLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICAgICAgICAgaWYodHlwZV9vZl92ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKFwiK3R5cGVfb2ZfditcIilcIik7XG4gICAgICAgICAgLy8gICAgICAgICAgdmFyIHQgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh2KSk7XG4gICAgICAgICAgLy8gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDBCIC8qY3N0LkNPREVfRE9VQkxFX0JJRyovKTtcbiAgICAgICAgICAvLyAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpPDg7IGkrKyl7d3JpdGVyLndyaXRlKDgsdFtpXSl9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiA+PSAwICYmIHYgPCAweDQwKSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAwWDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLyArIHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2ID49IC0oMSA8PCA3KSAmJiB2IDwgKDEgPDwgNykpXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSg4LCAweDAwIC8qY3N0LkNPREVfSU5UOCovLCB2KTtcbiAgICAgICAgICBlbHNlIGlmICh2ID49IC0oMSA8PCAxNSkgJiYgdiA8ICgxIDw8IDE1KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDE2LCAweDAxIC8qY3N0LkNPREVfSU5UMTYqLywgdik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDIgLypjc3QuQ09ERV9JTlQzMiovLCB2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBleHRlcm5fcmVjICh2KTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGkgPSBzdGFjay5wb3AgKCk7XG4gICAgICB2YXIgdiA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIGlmIChpICsgMSA8IHYubGVuZ3RoKSBzdGFjay5wdXNoICh2LCBpICsgMSk7XG4gICAgICBleHRlcm5fcmVjICh2W2ldKTtcbiAgICB9XG4gICAgaWYgKGludGVybl9vYmpfdGFibGUpIHdyaXRlci5vYmpfY291bnRlciA9IGludGVybl9vYmpfdGFibGUub2Jqcy5sZW5ndGg7XG4gICAgd3JpdGVyLmZpbmFsaXplKCk7XG4gICAgcmV0dXJuIHdyaXRlci5jaHVuaztcbiAgfVxufSAoKTtcblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9ieXRlc19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgKHYsIGZsYWdzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX2JsaXRfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciAocywgb2ZzLCBsZW4sIHYsIGZsYWdzKSB7XG4gIHZhciB0ID0gY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncyk7XG4gIGlmICh0Lmxlbmd0aCA+IGxlbikgY2FtbF9mYWlsd2l0aCAoXCJNYXJzaGFsLnRvX2J1ZmZlcjogYnVmZmVyIG92ZXJmbG93XCIpO1xuICBjYW1sX2JsaXRfYnl0ZXModCwgMCwgcywgb2ZzLCB0Lmxlbmd0aCk7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBJb1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19mZHNcbnZhciBjYW1sX3N5c19mZHMgPSBuZXcgQXJyYXkoMyk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2Nsb3NlXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19mZHNcbmZ1bmN0aW9uIGNhbWxfc3lzX2Nsb3NlKGZkKSB7XG4gIHZhciBmaWxlID0gY2FtbF9zeXNfZmRzW2ZkXTtcbiAgaWYoZmlsZSkgZmlsZS5jbG9zZSgpO1xuICBkZWxldGUgY2FtbF9zeXNfZmRzW2ZkXTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfb3BlblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IE1sRmFrZUZkX291dFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19mZHNcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX29wZW5fZm9yX25vZGVcbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW5faW50ZXJuYWwoZmlsZSxpZHgpIHtcbiAgaWYoaWR4ID09IHVuZGVmaW5lZCl7XG4gICAgaWR4ID0gY2FtbF9zeXNfZmRzLmxlbmd0aDtcbiAgfVxuICBjYW1sX3N5c19mZHNbaWR4XSA9IGZpbGU7XG4gIHJldHVybiBpZHggfCAwO1xufVxuZnVuY3Rpb24gY2FtbF9zeXNfb3BlbiAobmFtZSwgZmxhZ3MsIF9wZXJtcykge1xuICB2YXIgZiA9IHt9O1xuICB3aGlsZShmbGFncyl7XG4gICAgc3dpdGNoKGZsYWdzWzFdKXtcbiAgICBjYXNlIDA6IGYucmRvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDE6IGYud3Jvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDI6IGYuYXBwZW5kID0gMTticmVhaztcbiAgICBjYXNlIDM6IGYuY3JlYXRlID0gMTticmVhaztcbiAgICBjYXNlIDQ6IGYudHJ1bmNhdGUgPSAxO2JyZWFrO1xuICAgIGNhc2UgNTogZi5leGNsID0gMTsgYnJlYWs7XG4gICAgY2FzZSA2OiBmLmJpbmFyeSA9IDE7YnJlYWs7XG4gICAgY2FzZSA3OiBmLnRleHQgPSAxO2JyZWFrO1xuICAgIGNhc2UgODogZi5ub25ibG9jayA9IDE7YnJlYWs7XG4gICAgfVxuICAgIGZsYWdzPWZsYWdzWzJdO1xuICB9XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCxmKTtcbiAgcmV0dXJuIGNhbWxfc3lzX29wZW5faW50ZXJuYWwgKGZpbGUsIHVuZGVmaW5lZCk7XG59XG4oZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBmaWxlKGZkLCBmbGFncykge1xuICAgIGlmKGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAgICAgIHJldHVybiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlKGZkLCBmbGFncyk7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBuZXcgTWxGYWtlRmRfb3V0KGZkLCBmbGFncylcbiAgfVxuICBjYW1sX3N5c19vcGVuX2ludGVybmFsKGZpbGUoMCx7cmRvbmx5OjEsYWx0bmFtZTpcIi9kZXYvc3RkaW5cIixpc0NoYXJhY3RlckRldmljZTp0cnVlfSksIDApO1xuICBjYW1sX3N5c19vcGVuX2ludGVybmFsKGZpbGUoMSx7YnVmZmVyZWQ6Mix3cm9ubHk6MSxpc0NoYXJhY3RlckRldmljZTp0cnVlfSksIDEpO1xuICBjYW1sX3N5c19vcGVuX2ludGVybmFsKGZpbGUoMix7YnVmZmVyZWQ6Mix3cm9ubHk6MSxpc0NoYXJhY3RlckRldmljZTp0cnVlfSksIDIpO1xufSkoKVxuXG5cbi8vIG9jYW1sIENoYW5uZWxzXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lKGNoYW5pZCwgbmFtZSkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2hhbi5uYW1lID0gbmFtZTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbHNcbnZhciBjYW1sX21sX2NoYW5uZWxzID0gbmV3IEFycmF5KCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3QgKCkge1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgYyA9IDA7IGMgPCBjYW1sX21sX2NoYW5uZWxzLmxlbmd0aDsgYysrKXtcbiAgICBpZihjYW1sX21sX2NoYW5uZWxzW2NdICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3BlbmVkICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3V0KVxuICAgICAgbD1bMCxjYW1sX21sX2NoYW5uZWxzW2NdLmZkLGxdO1xuICB9XG4gIHJldHVybiBsO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9zeXNfZmRzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuLy9SZXF1aXJlczogY2FtbF9zeXNfb3BlblxuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0IChmZCkge1xuICB2YXIgZmlsZSA9IGNhbWxfc3lzX2Zkc1tmZF07XG4gIGlmKGZpbGUuZmxhZ3MucmRvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHJlYWRvbmx5XCIpO1xuICB2YXIgYnVmZmVyZWQgPSAoZmlsZS5mbGFncy5idWZmZXJlZCAhPT0gdW5kZWZpbmVkKSA/IGZpbGUuZmxhZ3MuYnVmZmVyZWQgOiAxO1xuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmZpbGUsXG4gICAgb2Zmc2V0OmZpbGUuZmxhZ3MuYXBwZW5kP2ZpbGUubGVuZ3RoKCk6MCxcbiAgICBmZDpmZCxcbiAgICBvcGVuZWQ6dHJ1ZSxcbiAgICBvdXQ6dHJ1ZSxcbiAgICBidWZmZXJfY3VycjowLFxuICAgIGJ1ZmZlcjpuZXcgVWludDhBcnJheSg2NTUzNiksXG4gICAgYnVmZmVyZWQ6YnVmZmVyZWRcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfc3lzX2Zkc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX29wZW5cbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luIChmZCkgIHtcbiAgdmFyIGZpbGUgPSBjYW1sX3N5c19mZHNbZmRdO1xuICBpZihmaWxlLmZsYWdzLndyb25seSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJmZCBcIisgZmQgKyBcIiBpcyB3cml0ZW9ubHlcIik7XG4gIHZhciByZWZpbGwgPSBudWxsO1xuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmZpbGUsXG4gICAgb2Zmc2V0OmZpbGUuZmxhZ3MuYXBwZW5kP2ZpbGUubGVuZ3RoKCk6MCxcbiAgICBmZDpmZCxcbiAgICBvcGVuZWQ6dHJ1ZSxcbiAgICBvdXQ6IGZhbHNlLFxuICAgIGJ1ZmZlcl9jdXJyOjAsXG4gICAgYnVmZmVyX21heDowLFxuICAgIGJ1ZmZlcjpuZXcgVWludDhBcnJheSg2NTUzNiksXG4gICAgcmVmaWxsOnJlZmlsbFxuICB9O1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5uZWwuZmRdPWNoYW5uZWw7XG4gIHJldHVybiBjaGFubmVsLmZkO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luX3dpdGhfZmxhZ3Ncbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXG4vL1ZlcnNpb246ID49IDUuMVxuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5fd2l0aF9mbGFncyhmZCwgZmxhZ3Mpe1xuICByZXR1cm4gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4oZmQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRfd2l0aF9mbGFnc1xuLy9SZXF1aXJlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0XG4vL1ZlcnNpb246ID49IDUuMVxuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0X3dpdGhfZmxhZ3MoZmQsIGZsYWdzKXtcbiAgcmV0dXJuIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dChmZCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG4vL0FsaWFzOiB3aW5fZmlsZWRlc2NyX29mX2NoYW5uZWxcbmZ1bmN0aW9uIGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yKGNoYW5pZCl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5mZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlKGNoYW5pZCxtb2RlKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNoYW4uZmlsZS5mbGFncy50ZXh0ID0gIW1vZGVcbiAgY2hhbi5maWxlLmZsYWdzLmJpbmFyeSA9IG1vZGVcbiAgcmV0dXJuIDA7XG59XG5cbi8vSW5wdXQgZnJvbSBpbl9jaGFubmVsXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2xvc2VfY2hhbm5lbFxuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCwgY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogY2FtbF9zeXNfY2xvc2VcbmZ1bmN0aW9uIGNhbWxfbWxfY2xvc2VfY2hhbm5lbCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjaGFuLm9wZW5lZCA9IGZhbHNlO1xuICBjYW1sX3N5c19jbG9zZShjaGFuLmZkKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNoYW4uZmlsZS5sZW5ndGgoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3NpemVfNjQoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjaGFuLmZpbGUubGVuZ3RoICgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0KGNoYW5pZCxmKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjaGFuLm91dHB1dCA9IChmdW5jdGlvbiAocykge2Yocyl9KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbChjaGFuaWQsZikge1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ucmVmaWxsID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVmaWxsXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JlZmlsbCAoY2hhbikge1xuICBpZihjaGFuLnJlZmlsbCAhPSBudWxsKXtcbiAgICB2YXIgc3RyID0gY2hhbi5yZWZpbGwoKTtcbiAgICB2YXIgc3RyX2EgPSBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZyhzdHIpO1xuICAgIGlmIChzdHJfYS5sZW5ndGggPT0gMCkge1xuICAgICAgY2hhbi5yZWZpbGwgPSBudWxsXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYoY2hhbi5idWZmZXIubGVuZ3RoIDwgY2hhbi5idWZmZXJfbWF4ICsgc3RyX2EubGVuZ3RoKXtcbiAgICAgICAgdmFyIGIgPSBuZXcgVWludDhBcnJheShjaGFuLmJ1ZmZlcl9tYXggKyBzdHJfYS5sZW5ndGgpO1xuICAgICAgICBiLnNldChjaGFuLmJ1ZmZlcik7XG4gICAgICAgIGNoYW4uYnVmZmVyID0gYjtcbiAgICAgIH1cbiAgICAgIGNoYW4uYnVmZmVyLnNldChzdHJfYSxjaGFuLmJ1ZmZlcl9tYXgpO1xuICAgICAgY2hhbi5vZmZzZXQgKz0gc3RyX2EubGVuZ3RoO1xuICAgICAgY2hhbi5idWZmZXJfbWF4ICs9IHN0cl9hLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5yZWFkID0gY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsIGNoYW4uYnVmZmVyLCBjaGFuLmJ1ZmZlcl9tYXgsIGNoYW4uYnVmZmVyLmxlbmd0aCAtIGNoYW4uYnVmZmVyX21heCk7XG4gICAgY2hhbi5vZmZzZXQgKz0gbnJlYWQ7XG4gICAgY2hhbi5idWZmZXJfbWF4ICs9IG5yZWFkO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfaW5wdXRfYmxvY2tcbi8vUmVxdWlyZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXQgKGNoYW5pZCwgYiwgaSwgbCkge1xuICB2YXIgYmEgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKGIpO1xuICByZXR1cm4gY2FtbF9tbF9pbnB1dF9ibG9jayhjaGFuaWQsIGJhLCBpLCBsKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2Jsb2NrXG4vL1JlcXVpcmVzOiBjYW1sX3JlZmlsbCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9ibG9jayAoY2hhbmlkLCBiYSwgaSwgbCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIG4gPSBsO1xuICB2YXIgYXZhaWwgPSBjaGFuLmJ1ZmZlcl9tYXggLSBjaGFuLmJ1ZmZlcl9jdXJyO1xuICBpZihsIDw9IGF2YWlsKSB7XG4gICAgYmEuc2V0KGNoYW4uYnVmZmVyLnN1YmFycmF5KGNoYW4uYnVmZmVyX2N1cnIsY2hhbi5idWZmZXJfY3VyciArIGwpLCBpKTtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGw7XG4gIH1cbiAgZWxzZSBpZihhdmFpbCA+IDApIHtcbiAgICBiYS5zZXQoY2hhbi5idWZmZXIuc3ViYXJyYXkoY2hhbi5idWZmZXJfY3VycixjaGFuLmJ1ZmZlcl9jdXJyICsgYXZhaWwpLCBpKTtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGF2YWlsO1xuICAgIG4gPSBhdmFpbDtcbiAgfSBlbHNlIHtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyID0gMDtcbiAgICBjaGFuLmJ1ZmZlcl9tYXggPSAwO1xuICAgIGNhbWxfcmVmaWxsKGNoYW4pO1xuICAgIHZhciBhdmFpbCA9IGNoYW4uYnVmZmVyX21heCAtIGNoYW4uYnVmZmVyX2N1cnI7XG4gICAgaWYobiA+IGF2YWlsKSBuID0gYXZhaWw7XG4gICAgYmEuc2V0KGNoYW4uYnVmZmVyLnN1YmFycmF5KGNoYW4uYnVmZmVyX2N1cnIsY2hhbi5idWZmZXJfY3VyciArIG4pLCBpKTtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IG47XG4gIH1cbiAgcmV0dXJuIG4gfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX21hcnNoYWxfZGF0YV9zaXplLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3JlZmlsbCwgY2FtbF9mYWlsd2l0aCwgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBoZWFkZXIgPSBuZXcgVWludDhBcnJheShjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUpO1xuICBmdW5jdGlvbiBibG9jayhidWZmZXIsIG9mZnNldCwgbikge1xuICAgIHZhciByID0gMDtcbiAgICB3aGlsZShyIDwgbil7XG4gICAgICBpZihjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyX21heCl7XG4gICAgICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgICAgICBjaGFuLmJ1ZmZlcl9tYXggPSAwO1xuICAgICAgICBjYW1sX3JlZmlsbChjaGFuKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyX21heClcbiAgICAgICAgYnJlYWs7XG4gICAgICBidWZmZXJbb2Zmc2V0K3JdID0gY2hhbi5idWZmZXJbY2hhbi5idWZmZXJfY3Vycl07XG4gICAgICBjaGFuLmJ1ZmZlcl9jdXJyKys7XG4gICAgICByKys7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHZhciByID0gYmxvY2soaGVhZGVyLCAwLCBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUpO1xuICBpZihyID09IDApXG4gICAgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICBlbHNlIGlmIChyIDwgY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogdHJ1bmNhdGVkIG9iamVjdFwiKTtcbiAgdmFyIGxlbiA9IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoaGVhZGVyKSwgMCk7XG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW4gKyBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUpO1xuICBidWYuc2V0KGhlYWRlciwwKTtcbiAgdmFyIHIgPSBibG9jayhidWYsIGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSwgbGVuKVxuICBpZihyIDwgbGVuKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogdHJ1bmNhdGVkIG9iamVjdCBcIiArIHIgKyBcIiAgXCIgKyBsZW4pO1xuICB2YXIgb2Zmc2V0ID0gWzBdO1xuICB2YXIgcmVzID0gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoYnVmKSwgb2Zmc2V0KTtcbiAgY2hhbi5vZmZzZXQgPSBjaGFuLm9mZnNldCArIG9mZnNldFswXTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV90b19vdXRzaWRlX2hlYXBcbi8vUmVxdWlyZXM6IGNhbWxfaW5wdXRfdmFsdWVcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfdG9fb3V0c2lkZV9oZWFwKGMpIHtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWUoYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfY2hhclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9yZWZpbGxcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfY2hhciAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZihjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyX21heCl7XG4gICAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gICAgY2hhbi5idWZmZXJfbWF4ID0gMDtcbiAgICBjYW1sX3JlZmlsbChjaGFuKTtcbiAgfVxuICBpZiAoY2hhbi5idWZmZXJfY3VyciA+PSBjaGFuLmJ1ZmZlcl9tYXgpXG4gICAgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB2YXIgcmVzID0gY2hhbi5idWZmZXJbY2hhbi5idWZmZXJfY3Vycl07XG4gIGNoYW4uYnVmZmVyX2N1cnIrKztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfaW5wdXRfY2hhciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9pbnQgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA0OyBpKyspe1xuICAgIHJlcyA9IChyZXMgPDwgOCkgKyBjYW1sX21sX2lucHV0X2NoYXIoY2hhbmlkKSB8IDA7XG4gIH1cbiAgcmV0dXJuIHJlcyB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2Vla19pblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfc2Vla19pbihjaGFuaWQsIHBvcykge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsICE9IG51bGwpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiSWxsZWdhbCBzZWVrXCIpO1xuICBpZihwb3MgPj0gY2hhbi5vZmZzZXQgLSBjaGFuLmJ1ZmZlcl9tYXhcbiAgICAgJiYgcG9zIDw9IGNoYW4ub2Zmc2V0XG4gICAgICYmIGNoYW4uZmlsZS5mbGFncy5iaW5hcnkpIHtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyID0gY2hhbi5idWZmZXJfbWF4IC0gKGNoYW4ub2Zmc2V0IC0gcG9zKTtcbiAgfSBlbHNlIHtcbiAgICBjaGFuLm9mZnNldCA9IHBvcztcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyID0gMDtcbiAgICBjaGFuLmJ1ZmZlcl9tYXggPSAwO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfaW5cbi8vUmVxdWlyZXM6IGNhbWxfc2Vla19pblxuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX2luKGNoYW5pZCxwb3Mpe1xuICByZXR1cm4gY2FtbF9zZWVrX2luKGNoYW5pZCxwb3MpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfc2Vla19pblxuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX2luXzY0KGNoYW5pZCxwb3Mpe1xuICB2YXIgcG9zID0gY2FtbF9pbnQ2NF90b19mbG9hdChwb3MpO1xuICByZXR1cm4gY2FtbF9zZWVrX2luKGNoYW5pZCwgcG9zKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wb3NfaW5cbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfcG9zX2luKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNoYW4ub2Zmc2V0IC0gKGNoYW4uYnVmZmVyX21heCAtIGNoYW4uYnVmZmVyX2N1cnIpIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3NfaW5cbi8vUmVxdWlyZXM6IGNhbWxfcG9zX2luXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbihjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfcG9zX2luKGNoYW5pZCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX3Bvc19pblxuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW5fNjQoY2hhbmlkKSB7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNhbWxfcG9zX2luKGNoYW5pZCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X3NjYW5fbGluZVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9yZWZpbGxcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lKGNoYW5pZCl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgcCA9IGNoYW4uYnVmZmVyX2N1cnI7XG4gIGRvIHtcbiAgICBpZihwID49IGNoYW4uYnVmZmVyX21heCkge1xuICAgICAgaWYoY2hhbi5idWZmZXJfY3VyciA+IDApIHtcbiAgICAgICAgY2hhbi5idWZmZXIuc2V0KGNoYW4uYnVmZmVyLnN1YmFycmF5KGNoYW4uYnVmZmVyX2N1cnIpLDApO1xuICAgICAgICBwIC09IGNoYW4uYnVmZmVyX2N1cnI7XG4gICAgICAgIGNoYW4uYnVmZmVyX21heCAtPSBjaGFuLmJ1ZmZlcl9jdXJyO1xuICAgICAgICBjaGFuLmJ1ZmZlcl9jdXJyID0gMDtcbiAgICAgIH1cbiAgICAgIGlmKGNoYW4uYnVmZmVyX21heCA+PSBjaGFuLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0oY2hhbi5idWZmZXJfbWF4KSB8IDA7XG4gICAgICB9XG4gICAgICB2YXIgcHJldl9tYXggPSBjaGFuLmJ1ZmZlcl9tYXg7XG4gICAgICBjYW1sX3JlZmlsbCAoY2hhbik7XG4gICAgICBpZihwcmV2X21heCA9PSBjaGFuLmJ1ZmZlcl9tYXgpIHtcbiAgICAgICAgcmV0dXJuIC0oY2hhbi5idWZmZXJfbWF4KSB8IDA7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlIChjaGFuLmJ1ZmZlcltwKytdICE9IDEwKTtcbiAgcmV0dXJuIChwIC0gY2hhbi5idWZmZXJfY3VycikgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2ZsdXNoXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX2ZsdXNoIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmKCEgY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IGZsdXNoIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIGlmKCFjaGFuLmJ1ZmZlciB8fCBjaGFuLmJ1ZmZlcl9jdXJyID09IDApIHJldHVybiAwO1xuICBpZihjaGFuLm91dHB1dCkge1xuICAgIGNoYW4ub3V0cHV0KGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhjaGFuLmJ1ZmZlciwgMCwgY2hhbi5idWZmZXJfY3VycikpO1xuICB9IGVsc2Uge1xuICAgIGNoYW4uZmlsZS53cml0ZShjaGFuLm9mZnNldCwgY2hhbi5idWZmZXIsIDAsIGNoYW4uYnVmZmVyX2N1cnIpO1xuICB9XG4gIGNoYW4ub2Zmc2V0ICs9IGNoYW4uYnVmZmVyX2N1cnI7XG4gIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICByZXR1cm4gMDtcbn1cblxuLy9vdXRwdXQgdG8gb3V0X2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBvdXRwdXQgdG8gYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgdmFyIGJ1ZmZlciA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMoYnVmZmVyKTtcbiAgYnVmZmVyID0gYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgaWYoY2hhbi5idWZmZXJfY3VyciArIGJ1ZmZlci5sZW5ndGggPiBjaGFuLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KGNoYW4uYnVmZmVyX2N1cnIgKyBidWZmZXIubGVuZ3RoKTtcbiAgICBiLnNldChjaGFuLmJ1ZmZlcik7XG4gICAgY2hhbi5idWZmZXIgPSBiXG4gIH1cbiAgc3dpdGNoKGNoYW4uYnVmZmVyZWQpe1xuICBjYXNlIDA6IC8vIFVuYnVmZmVyZWRcbiAgICBjaGFuLmJ1ZmZlci5zZXQoYnVmZmVyLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgY2FtbF9tbF9mbHVzaCAoY2hhbmlkKTtcbiAgICBicmVha1xuICBjYXNlIDE6IC8vIEJ1ZmZlcmVkICh0aGUgZGVmYXVsdClcbiAgICBjaGFuLmJ1ZmZlci5zZXQoYnVmZmVyLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgaWYoY2hhbi5idWZmZXJfY3VyciA+PSBjaGFuLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBjYW1sX21sX2ZsdXNoIChjaGFuaWQpO1xuICAgIGJyZWFrO1xuICBjYXNlIDI6IC8vIEJ1ZmZlcmVkIChvbmx5IGZvciBzdGRvdXQgYW5kIHN0ZGVycilcbiAgICB2YXIgaWQgPSBidWZmZXIubGFzdEluZGV4T2YoMTApXG4gICAgaWYoaWQgPCAwKSB7XG4gICAgICBjaGFuLmJ1ZmZlci5zZXQoYnVmZmVyLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgIGlmKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXIubGVuZ3RoKVxuICAgICAgICBjYW1sX21sX2ZsdXNoIChjaGFuaWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNoYW4uYnVmZmVyLnNldChidWZmZXIuc3ViYXJyYXkoMCwgaWQgKyAxKSwgY2hhbi5idWZmZXJfY3Vycik7XG4gICAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGlkICsgMTtcbiAgICAgIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCk7XG4gICAgICBjaGFuLmJ1ZmZlci5zZXQoYnVmZmVyLnN1YmFycmF5KGlkICsgMSksIGNoYW4uYnVmZmVyX2N1cnIpO1xuICAgICAgY2hhbi5idWZmZXJfY3VyciArPSBidWZmZXIubGVuZ3RoIC0gaWQgLSAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXQoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKXtcbiAgcmV0dXJuIGNhbWxfbWxfb3V0cHV0X2J5dGVzKGNoYW5pZCxjYW1sX2J5dGVzX29mX3N0cmluZyhidWZmZXIpLG9mZnNldCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfY2hhciAoY2hhbmlkLGMpIHtcbiAgdmFyIHMgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLDEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZywgY2FtbF9tbF9vdXRwdXQsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZSAoY2hhbmlkLHYsZmxhZ3MpIHtcbiAgdmFyIHMgPSBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcodiwgZmxhZ3MpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSk7XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfc2Vla19vdXQoY2hhbmlkLCBwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjaGFuLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfc2Vla19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXQoY2hhbmlkLHBvcyl7XG4gIHJldHVybiBjYW1sX3NlZWtfb3V0KGNoYW5pZCwgcG9zKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfc2Vla19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXRfNjQoY2hhbmlkLHBvcyl7XG4gIHZhciBwb3MgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiBjYW1sX3NlZWtfb3V0KGNoYW5pZCwgcG9zKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wb3Nfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX3Bvc19vdXQoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5vZmZzZXQgKyBjaGFuLmJ1ZmZlcl9jdXJyXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dFxuLy9SZXF1aXJlczogY2FtbF9wb3Nfb3V0XG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXQoY2hhbmlkKSB7XG4gIHJldHVybiBjYW1sX3Bvc19vdXQoY2hhbmlkKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3Nfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX3Bvc19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dF82NChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQgKGNhbWxfcG9zX291dChjaGFuaWQpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2ludCAoY2hhbmlkLGkpIHtcbiAgdmFyIGFyciA9IFsoaT4+MjQpICYgMHhGRiwoaT4+MTYpICYgMHhGRiwoaT4+OCkgJiAweEZGLGkgJiAweEZGIF07XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCw0KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pc19idWZmZXJlZFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pc19idWZmZXJlZChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5idWZmZXJlZCA/IDEgOiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2J1ZmZlcmVkXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NldF9idWZmZXJlZChjaGFuaWQsdikge1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0uYnVmZmVyZWQgPSB2O1xuICBpZighdikgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gMFxufVxuIiwiXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWlub3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWlub3IodW5pdCl7XG4gIC8vYXZhaWxhYmxlIHdpdGggW25vZGUgLS1leHBvc2UtZ2NdXG4gIGlmKHR5cGVvZiBnbG9iYWxUaGlzLmdjID09ICdmdW5jdGlvbicpIGdsb2JhbFRoaXMuZ2ModHJ1ZSk7XG4gIHJldHVybiAwXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX21ham9yXG5mdW5jdGlvbiBjYW1sX2djX21ham9yKHVuaXQpe1xuICAvL2F2YWlsYWJsZSB3aXRoIFtub2RlIC0tZXhwb3NlLWdjXVxuICBpZih0eXBlb2YgZ2xvYmFsVGhpcy5nYyA9PSAnZnVuY3Rpb24nKSBnbG9iYWxUaGlzLmdjKCk7XG4gIHJldHVybiAwXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2Z1bGxfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfZnVsbF9tYWpvcih1bml0KXtcbiAgLy9hdmFpbGFibGUgd2l0aCBbbm9kZSAtLWV4cG9zZS1nY11cbiAgaWYodHlwZW9mIGdsb2JhbFRoaXMuZ2MgPT0gJ2Z1bmN0aW9uJykgZ2xvYmFsVGhpcy5nYygpO1xuICByZXR1cm4gMFxufVxuLy9Qcm92aWRlczogY2FtbF9nY19jb21wYWN0aW9uXG5mdW5jdGlvbiBjYW1sX2djX2NvbXBhY3Rpb24oKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvdW50ZXJzXG5mdW5jdGlvbiBjYW1sX2djX2NvdW50ZXJzKCkgeyByZXR1cm4gWzI1NCwwLDAsMF0gfVxuLy9Qcm92aWRlczogY2FtbF9nY19xdWlja19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3F1aWNrX3N0YXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19zdGF0KCkge1xuICAvLyBBIGZpZWxkIHdhcyBhZGRlZCBpbiBPQ2FtbCA0LjEyLiBJdCBpcyB1bmxpa2VseSB0byBiZSBhbiBpc3N1ZSB0b1xuICAvLyByZXR1cm4gdG9vIG1hbnkgZmllbGRzIGluIHByZXZpb3VzIHZlcnNpb25zIG9mIE9DYW1sLlxuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX3NldFxuZnVuY3Rpb24gY2FtbF9nY19zZXQoX2NvbnRyb2wpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZ2V0XG5mdW5jdGlvbiBjYW1sX2djX2dldCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc2V0XG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZVxudmFyIGFsbF9maW5hbGl6ZXJzID0gbmV3IGdsb2JhbFRoaXMuU2V0KClcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUgKGNiLCBhKSB7XG4gIGlmKGdsb2JhbFRoaXMuRmluYWxpemF0aW9uUmVnaXN0cnkgJiYgYSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIHZhciB4ID0gbmV3IGdsb2JhbFRoaXMuRmluYWxpemF0aW9uUmVnaXN0cnkoZnVuY3Rpb24gKHgpe2FsbF9maW5hbGl6ZXJzLmRlbGV0ZSh4KTsgY2IoMCk7IHJldHVybjt9KTtcbiAgICB4LnJlZ2lzdGVyKGEseCk7XG4gICAgYWxsX2ZpbmFsaXplcnMuYWRkKHgpO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlbGVhc2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVsZWFzZSAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zdGFydFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3N0YXJ0KHJhdGUsc3RhY2tfc2l6ZSx0cmFja2VyKXtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zdG9wXG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc3RvcCh1bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V2ZW50bG9nX3Jlc3VtZVxuZnVuY3Rpb24gY2FtbF9ldmVudGxvZ19yZXN1bWUodW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V2ZW50bG9nX3BhdXNlXG5mdW5jdGlvbiBjYW1sX2V2ZW50bG9nX3BhdXNlKHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50XG5mdW5jdGlvbiBjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnQodW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX21ham9yX3NsaWNlXG5mdW5jdGlvbiBjYW1sX2djX21ham9yX3NsaWNlKHdvcmspIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nY19taW5vcl93b3Jkc1xuZnVuY3Rpb24gY2FtbF9nY19taW5vcl93b3Jkcyh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X21pbm9yX2ZyZWVcbmZ1bmN0aW9uIGNhbWxfZ2V0X21pbm9yX2ZyZWUodW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9tYWpvcl9idWNrZXRcbmZ1bmN0aW9uIGNhbWxfZ2V0X21ham9yX2J1Y2tldChuKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X21ham9yX2NyZWRpdFxuZnVuY3Rpb24gY2FtbF9nZXRfbWFqb3JfY3JlZGl0KG4pIHsgcmV0dXJuIDA7IH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkLCBBbmR5IFJheVxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuLy9cbi8vIEJpZ2FycmF5LlxuLy9cbi8vIC0gYWxsIGJpZ2FycmF5IHR5cGVzIGluY2x1ZGluZyBJbnQ2NCBhbmQgQ29tcGxleC5cbi8vIC0gZm9ydHJhbiArIGMgbGF5b3V0c1xuLy8gLSBzdWIvc2xpY2UvcmVzaGFwZVxuLy8gLSByZXRhaW4gZmFzdCBwYXRoIGZvciAxZCBhcnJheSBhY2Nlc3NcblxuLy9Qcm92aWRlczogY2FtbF9iYV9pbml0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2JhX2luaXQoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X3NpemUoZGltcykge1xuICB2YXIgbl9kaW1zID0gZGltcy5sZW5ndGg7XG4gIHZhciBzaXplID0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX2RpbXM7IGkrKykge1xuICAgIGlmIChkaW1zW2ldIDwgMClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmNyZWF0ZTogbmVnYXRpdmUgZGltZW5zaW9uXCIpO1xuICAgIHNpemUgPSBzaXplICogZGltc1tpXTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKXtcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDc6IGNhc2UgMTA6IGNhc2UgMTE6IHJldHVybiAyO1xuICBkZWZhdWx0OiByZXR1cm4gMTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIHNpemUpe1xuICB2YXIgdmlldztcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDA6ICB2aWV3ID0gRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxOiAgdmlldyA9IEZsb2F0NjRBcnJheTsgYnJlYWs7XG4gIGNhc2UgMjogIHZpZXcgPSBJbnQ4QXJyYXk7IGJyZWFrO1xuICBjYXNlIDM6ICB2aWV3ID0gVWludDhBcnJheTsgYnJlYWs7XG4gIGNhc2UgNDogIHZpZXcgPSBJbnQxNkFycmF5OyBicmVhaztcbiAgY2FzZSA1OiAgdmlldyA9IFVpbnQxNkFycmF5OyBicmVhaztcbiAgY2FzZSA2OiAgdmlldyA9IEludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDc6ICB2aWV3ID0gSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgODogIHZpZXcgPSBJbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA5OiAgdmlldyA9IEludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDEwOiB2aWV3ID0gRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMTogdmlldyA9IEZsb2F0NjRBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTI6IHZpZXcgPSBVaW50OEFycmF5OyBicmVhaztcbiAgfVxuICBpZiAoIXZpZXcpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmNyZWF0ZTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgdmFyIGRhdGEgPSBuZXcgdmlldyhzaXplICogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1ZlcnNpb246IDwgNC4xMVxudmFyIGNhbWxfYmFfY3VzdG9tX25hbWUgPSBcIl9iaWdhcnJheVwiXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vVmVyc2lvbjogPj0gNC4xMVxudmFyIGNhbWxfYmFfY3VzdG9tX25hbWUgPSBcIl9iaWdhcnIwMlwiXG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpLCBjYW1sX2ludDY0X2hpMzIsIGNhbWxfaW50NjRfbG8zMlxuZnVuY3Rpb24gTWxfQmlnYXJyYXkgKGtpbmQsIGxheW91dCwgZGltcywgYnVmZmVyKSB7XG5cbiAgdGhpcy5raW5kICAgPSBraW5kIDtcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuZGltcyAgID0gZGltcztcbiAgdGhpcy5kYXRhID0gYnVmZmVyO1xufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBjYW1sX2JhX2N1c3RvbV9uYW1lO1xuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKGFyZykge1xuICB2YXIgb2ZzID0gMDtcbiAgaWYodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIikgYXJnID0gW2FyZ107XG4gIGlmICghIChhcmcgaW5zdGFuY2VvZiBBcnJheSkpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImJpZ2FycmF5LmpzOiBpbnZhbGlkIG9mZnNldFwiKTtcbiAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT0gYXJnLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5nZXQvc2V0OiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gIGlmKHRoaXMubGF5b3V0ID09IDAgLyogY19sYXlvdXQgKi8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFyZ1tpXSA8IDAgfHwgYXJnW2ldID49IHRoaXMuZGltc1tpXSlcbiAgICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgb2ZzID0gKG9mcyAqIHRoaXMuZGltc1tpXSkgKyBhcmdbaV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmRpbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChhcmdbaV0gPCAxIHx8IGFyZ1tpXSA+IHRoaXMuZGltc1tpXSl7XG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIG9mcyA9IChvZnMgKiB0aGlzLmRpbXNbaV0pICsgKGFyZ1tpXSAtIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2ZzO1xufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mcykge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdmFyIGwgPSB0aGlzLmRhdGFbb2ZzICogMiArIDBdO1xuICAgIHZhciBoID0gdGhpcy5kYXRhW29mcyAqIDIgKyAxXTtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobCxoKTtcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHZhciByID0gdGhpcy5kYXRhW29mcyAqIDIgKyAwXTtcbiAgICB2YXIgaSA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgcmV0dXJuIFsyNTQsIHIsIGldO1xuICBkZWZhdWx0OlxuICAgIHJldHVybiB0aGlzLmRhdGFbb2ZzXVxuICB9XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2ZzLHYpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSBjYW1sX2ludDY0X2xvMzIodik7XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAxXSA9IGNhbWxfaW50NjRfaGkzMih2KTtcbiAgICBicmVhaztcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSB2WzFdO1xuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMV0gPSB2WzJdO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMFxufVxuXG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHZhciBhID0gY2FtbF9pbnQ2NF9sbzMyKHYpO1xuICAgIHZhciBiID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgIGlmKGEgPT0gYil7XG4gICAgICB0aGlzLmRhdGEuZmlsbChhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpPHRoaXMuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IChpJTIgPT0gMCkgPyBhIDogYjtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB2YXIgaW0gPSB2WzFdO1xuICAgIHZhciByZSA9IHZbMl07XG4gICAgaWYoaW0gPT0gcmUpe1xuICAgICAgdGhpcy5kYXRhLmZpbGwoaW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGk8dGhpcy5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gKGklMiA9PSAwKSA/IGltIDogcmU7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRoaXMuZGF0YS5maWxsKHYpO1xuICAgIGJyZWFrO1xuICB9XG59XG5cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYiwgdG90YWwpIHtcbiAgaWYgKHRoaXMubGF5b3V0ICE9IGIubGF5b3V0IHx8IHRoaXMua2luZCAhPSBiLmtpbmQpIHtcbiAgICB2YXIgazEgPSB0aGlzLmtpbmQgfCAodGhpcy5sYXlvdXQgPDwgOCk7XG4gICAgdmFyIGsyID0gICAgYi5raW5kIHwgKGIubGF5b3V0IDw8IDgpO1xuICAgIHJldHVybiBrMiAtIGsxO1xuICB9XG4gIGlmICh0aGlzLmRpbXMubGVuZ3RoICE9IGIuZGltcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYi5kaW1zLmxlbmd0aCAtIHRoaXMuZGltcy5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKHRoaXMuZGltc1tpXSAhPSBiLmRpbXNbaV0pXG4gICAgICByZXR1cm4gKHRoaXMuZGltc1tpXSA8IGIuZGltc1tpXSkgPyAtMSA6IDE7XG4gIHN3aXRjaCAodGhpcy5raW5kKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICBjYXNlIDEwOlxuICBjYXNlIDExOlxuICAgIC8vIEZsb2F0c1xuICAgIHZhciB4LCB5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB4ID0gdGhpcy5kYXRhW2ldO1xuICAgICAgeSA9IGIuZGF0YVtpXTtcbiAgICAgIGlmICh4IDwgeSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHggPiB5KVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICh4ICE9IHkpIHtcbiAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgaWYgKHggPT0geCkgcmV0dXJuIDE7XG4gICAgICAgIGlmICh5ID09IHkpIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSs9Mikge1xuICAgICAgLy8gQ2hlY2sgaGlnaGVzdCBiaXRzIGZpcnN0XG4gICAgICBpZiAodGhpcy5kYXRhW2krMV0gPCBiLmRhdGFbaSsxXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMuZGF0YVtpKzFdID4gYi5kYXRhW2krMV0pXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKCh0aGlzLmRhdGFbaV0gPj4+IDApIDwgKGIuZGF0YVtpXSA+Pj4gMCkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICgodGhpcy5kYXRhW2ldID4+PiAwKSA+IChiLmRhdGFbaV0gPj4+IDApKVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMjpcbiAgY2FzZSAzOlxuICBjYXNlIDQ6XG4gIGNhc2UgNTpcbiAgY2FzZSA2OlxuICBjYXNlIDg6XG4gIGNhc2UgOTpcbiAgY2FzZSAxMjpcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuZGF0YVtpXSA8IGIuZGF0YVtpXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMuZGF0YVtpXSA+IGIuZGF0YVtpXSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBNbF9CaWdhcnJheV9jXzFfMVxuLy9SZXF1aXJlczogTWxfQmlnYXJyYXksIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gTWxfQmlnYXJyYXlfY18xXzEoa2luZCwgbGF5b3V0LCBkaW1zLCBidWZmZXIpIHtcbiAgdGhpcy5raW5kICAgPSBraW5kIDtcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuZGltcyAgID0gZGltcztcbiAgdGhpcy5kYXRhICAgPSBidWZmZXI7XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZSA9IG5ldyBNbF9CaWdhcnJheSgpXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKGFyZykge1xuICBpZih0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKXtcbiAgICBpZigoYXJnIGluc3RhbmNlb2YgQXJyYXkpICYmIGFyZy5sZW5ndGggPT0gMSlcbiAgICAgIGFyZyA9IGFyZ1swXTtcbiAgICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIk1sX0JpZ2FycmF5X2NfMV8xLm9mZnNldFwiKTtcbiAgfVxuICBpZiAoYXJnIDwgMCB8fCBhcmcgPj0gdGhpcy5kaW1zWzBdKVxuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFyZztcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YVtvZnNdO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9mcyx2KSB7XG4gIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgcmV0dXJuIDBcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodikge1xuICB0aGlzLmRhdGEuZmlsbCh2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jb21wYXJlXG5mdW5jdGlvbiBjYW1sX2JhX2NvbXBhcmUoYSxiLHRvdGFsKXtcbiAgcmV0dXJuIGEuY29tcGFyZShiLHRvdGFsKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbi8vUmVxdWlyZXM6IE1sX0JpZ2FycmF5LCBNbF9CaWdhcnJheV9jXzFfMSwgY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKXtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpO1xuICBpZihjYW1sX2JhX2dldF9zaXplKGRpbXMpICogc2l6ZV9wZXJfZWxlbWVudCAhPSBkYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImxlbmd0aCBkb2Vzbid0IG1hdGNoIGRpbXNcIik7XG4gIH1cbiAgaWYobGF5b3V0ID09IDAgJiYgLy8gY19sYXlvdXRcbiAgICAgZGltcy5sZW5ndGggPT0gMSAmJiAvLyBBcnJheTFcbiAgICAgc2l6ZV9wZXJfZWxlbWVudCA9PSAxKSAvLyAxLXRvLTEgbWFwcGluZ1xuICAgIHJldHVybiBuZXcgTWxfQmlnYXJyYXlfY18xXzEoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbiAgcmV0dXJuIG5ldyBNbF9CaWdhcnJheShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuXG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlKGtpbmQsIGxheW91dCwgZGltc19tbCkge1xuICB2YXIgZGltcyA9IGNhbWxfanNfZnJvbV9hcnJheShkaW1zX21sKTtcbiAgdmFyIGRhdGEgPSBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGNhbWxfYmFfY2hhbmdlX2xheW91dChiYSwgbGF5b3V0KSB7XG4gIGlmKGJhLmxheW91dCA9PSBsYXlvdXQpIHJldHVybiBiYTtcbiAgdmFyIG5ld19kaW1zID0gW11cbiAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIG5ld19kaW1zW2ldID0gYmEuZGltc1tiYS5kaW1zLmxlbmd0aCAtIGkgLSAxXTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBsYXlvdXQsIG5ld19kaW1zLCBiYS5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9raW5kXG5mdW5jdGlvbiBjYW1sX2JhX2tpbmQoYmEpIHtcbiAgcmV0dXJuIGJhLmtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbGF5b3V0XG5mdW5jdGlvbiBjYW1sX2JhX2xheW91dChiYSkge1xuICByZXR1cm4gYmEubGF5b3V0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX251bV9kaW1zXG5mdW5jdGlvbiBjYW1sX2JhX251bV9kaW1zKGJhKSB7XG4gIHJldHVybiBiYS5kaW1zLmxlbmd0aDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1cbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9kaW0oYmEsIGkpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gYmEuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZGltXCIpO1xuICByZXR1cm4gYmEuZGltc1tpXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMVxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzEoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMlxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzIoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fM1xuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzMoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfZ2VuZXJpY1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9nZW5lcmljKGJhLCBpKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoY2FtbF9qc19mcm9tX2FycmF5KGkpKTtcbiAgcmV0dXJuIGJhLmdldChvZnMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDE2KGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcyArIDEpO1xuICByZXR1cm4gKGIxIHwgKGIyIDw8IDgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQzMihiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyswKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcysxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcysyKTtcbiAgdmFyIGI0ID0gYmEuZ2V0KG9mcyszKTtcbiAgcmV0dXJuICggKGIxIDw8IDApICB8XG4gICAgICAgICAgIChiMiA8PCA4KSAgfFxuICAgICAgICAgICAoYjMgPDwgMTYpIHxcbiAgICAgICAgICAgKGI0IDw8IDI0KSApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDY0KGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgNyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKzApO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzKzEpO1xuICB2YXIgYjMgPSBiYS5nZXQob2ZzKzIpO1xuICB2YXIgYjQgPSBiYS5nZXQob2ZzKzMpO1xuICB2YXIgYjUgPSBiYS5nZXQob2ZzKzQpO1xuICB2YXIgYjYgPSBiYS5nZXQob2ZzKzUpO1xuICB2YXIgYjcgPSBiYS5nZXQob2ZzKzYpO1xuICB2YXIgYjggPSBiYS5nZXQob2ZzKzcpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbYjgsYjcsYjYsYjUsYjQsYjMsYjIsYjFdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMShiYSwgaTApIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoaTApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMihiYSwgaTAsIGkxKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KFtpMCxpMV0pKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMyhiYSwgaTAsIGkxLCBpMikge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsaTEsaTJdKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfZ2VuZXJpYyhiYSwgaSwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KGNhbWxfanNfZnJvbV9hcnJheShpKSksIHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDE2KGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBiYS5zZXQob2ZzKzAsICB2ICAgICAgICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzEsICh2ID4+PiA4KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQzMihiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyswLCAgdiAgICAgICAgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMSwgKHYgPj4+IDgpICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzIsICh2ID4+PiAxNikgJiAweGZmKTtcbiAgYmEuc2V0KG9mcyszLCAodiA+Pj4gMjQpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDY0KGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgNyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgdiA9IGNhbWxfaW50NjRfdG9fYnl0ZXModik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA4OyBpKyspIGJhLnNldChvZnMraSwgdls3LWldKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMShiYSwgaTAsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChpMCksIHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8yXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8yKGJhLCBpMCwgaTEsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChbaTAsaTFdKSwgdik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8zXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8zKGJhLCBpMCwgaTEsIGkyLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoW2kwLGkxLGkyXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9maWxsXG5mdW5jdGlvbiBjYW1sX2JhX2ZpbGwoYmEsIHYpIHtcbiAgYmEuZmlsbCh2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2JsaXQoc3JjLCBkc3QpIHtcbiAgaWYgKGRzdC5kaW1zLmxlbmd0aCAhPSBzcmMuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRzdC5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIGlmIChkc3QuZGltc1tpXSAhPSBzcmMuZGltc1tpXSlcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZHN0LmRhdGEuc2V0KHNyYy5kYXRhKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc3ViXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9zdWIoYmEsIG9mcywgbGVuKSB7XG4gIHZhciBjaGFuZ2VkX2RpbTtcbiAgdmFyIG11bCA9IDE7XG4gIGlmIChiYS5sYXlvdXQgPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICAgIG11bCA9IG11bCAqIGJhLmRpbXNbaV07XG4gICAgY2hhbmdlZF9kaW0gPSAwO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKGJhLmRpbXMubGVuZ3RoIC0gMSk7IGkrKylcbiAgICAgIG11bCA9IG11bCAqIGJhLmRpbXNbaV07XG4gICAgY2hhbmdlZF9kaW0gPSBiYS5kaW1zLmxlbmd0aCAtIDE7XG4gICAgb2ZzID0gb2ZzIC0gMTtcbiAgfVxuICBpZiAob2ZzIDwgMCB8fCBsZW4gPCAwIHx8IChvZnMgKyBsZW4pID4gYmEuZGltc1tjaGFuZ2VkX2RpbV0pe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnN1YjogYmFkIHN1Yi1hcnJheVwiKTtcbiAgfVxuICB2YXIgbmV3X2RpbXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIG5ld19kaW1zW2ldID0gYmEuZGltc1tpXTtcbiAgbmV3X2RpbXNbY2hhbmdlZF9kaW1dID0gbGVuO1xuICBtdWwgKj0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChiYS5raW5kKTtcbiAgdmFyIG5ld19kYXRhID0gYmEuZGF0YS5zdWJhcnJheShvZnMgKiBtdWwsIChvZnMgKyBsZW4pICogbXVsKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW1zLCBuZXdfZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2xpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfc2xpY2UoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG51bV9pbmRzID0gdmluZC5sZW5ndGg7XG4gIHZhciBpbmRleCA9IFtdO1xuICB2YXIgc3ViX2RpbXMgPSBbXTtcbiAgdmFyIG9mcztcblxuICBpZiAobnVtX2luZHMgPiBiYS5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zbGljZTogdG9vIG1hbnkgaW5kaWNlc1wiKTtcblxuICAvLyBDb21wdXRlIG9mZnNldCBhbmQgY2hlY2sgYm91bmRzXG4gIGlmIChiYS5sYXlvdXQgPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2ldID0gdmluZFtpXTtcbiAgICBmb3IgKDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgICBpbmRleFtpXSA9IDA7XG4gICAgc3ViX2RpbXMgPSBiYS5kaW1zLnNsaWNlKG51bV9pbmRzKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzICsgaV0gPSB2aW5kW2ldO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGggLSBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSAxO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZSgwLCBiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzKTtcbiAgfVxuICBvZnMgPSBiYS5vZmZzZXQoaW5kZXgpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoc3ViX2RpbXMpO1xuICB2YXIgc2l6ZV9wZXJfZWxlbWVudCA9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkob2ZzICogc2l6ZV9wZXJfZWxlbWVudCwgKG9mcyArIHNpemUpICogc2l6ZV9wZXJfZWxlbWVudCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBzdWJfZGltcywgbmV3X2RhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3Jlc2hhcGVcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfYmFfZ2V0X3NpemVcbmZ1bmN0aW9uIGNhbWxfYmFfcmVzaGFwZShiYSwgdmluZCkge1xuICB2aW5kID0gY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpO1xuICB2YXIgbmV3X2RpbSA9IFtdO1xuICB2YXIgbnVtX2RpbXMgPSB2aW5kLmxlbmd0aDtcblxuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgfVxuICB2YXIgbnVtX2VsdHMgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIHtcbiAgICBuZXdfZGltW2ldID0gdmluZFtpXTtcbiAgICBpZiAobmV3X2RpbVtpXSA8IDApXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgbnVtX2VsdHMgPSBudW1fZWx0cyAqIG5ld19kaW1baV07XG4gIH1cblxuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoYmEuZGltcyk7XG4gIC8vIENoZWNrIHRoYXQgc2l6ZXMgYWdyZWVcbiAgaWYgKG51bV9lbHRzICE9IHNpemUpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogc2l6ZSBtaXNtYXRjaFwiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW0sIGJhLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfYmFfc2VyaWFsaXplKHdyaXRlciwgYmEsIHN6KSB7XG4gIHdyaXRlci53cml0ZSgzMiwgYmEuZGltcy5sZW5ndGgpO1xuICB3cml0ZXIud3JpdGUoMzIsIChiYS5raW5kIHwgKGJhLmxheW91dCA8PCA4KSkpO1xuICBpZihiYS5jYW1sX2N1c3RvbSA9PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZihiYS5kaW1zW2ldIDwgMHhmZmZmKVxuICAgICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRpbXNbaV0pO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHdyaXRlci53cml0ZSgxNiwgMHhmZmZmKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCAwKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kaW1zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIGVsc2VcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgd3JpdGVyLndyaXRlKDMyLGJhLmRpbXNbaV0pXG4gIHN3aXRjaChiYS5raW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSg4LCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIHdyaXRlci53cml0ZSg4LDApO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGJhLmdldChpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGIpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBqID0gYmEuZ2V0KGkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsxXSkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsyXSkpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBjb21wbGV4ID0gYmEuZ2V0KGkpO1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChjb21wbGV4WzFdKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsyXSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHN6WzBdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA0O1xuICBzelsxXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kZXNlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzLCBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2Rlc2VyaWFsaXplKHJlYWRlciwgc3osIG5hbWUpe1xuICB2YXIgbnVtX2RpbXMgPSByZWFkZXIucmVhZDMycygpO1xuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB3cm9uZyBudW1iZXIgb2YgYmlnYXJyYXkgZGltZW5zaW9uc1wiKTtcbiAgdmFyIHRhZyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBraW5kID0gdGFnICYgMHhmZlxuICB2YXIgbGF5b3V0ID0gKHRhZyA+PiA4KSAmIDE7XG4gIHZhciBkaW1zID0gW11cbiAgaWYobmFtZSA9PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgICAgdmFyIHNpemVfZGltID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICAgIGlmKHNpemVfZGltID09IDB4ZmZmZil7XG4gICAgICAgIHZhciBzaXplX2RpbV9oaSA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgIHZhciBzaXplX2RpbV9sbyA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgIGlmKHNpemVfZGltX2hpICE9IDApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBiaWdhcnJheSBkaW1lbnNpb24gb3ZlcmZsb3cgaW4gMzJiaXRcIik7XG4gICAgICAgIHNpemVfZGltID0gc2l6ZV9kaW1fbG87XG4gICAgICB9XG4gICAgICBkaW1zLnB1c2goc2l6ZV9kaW0pO1xuICAgIH1cbiAgZWxzZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykgZGltcy5wdXNoKHJlYWRlci5yZWFkMzJ1KCkpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoZGltcyk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIHNpemUpO1xuICB2YXIgYmEgPSBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkOHMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICB2YXIgc2l4dHkgPSByZWFkZXIucmVhZDh1KCk7XG4gICAgaWYoc2l4dHkpIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogY2Fubm90IHJlYWQgYmlnYXJyYXkgd2l0aCA2NC1iaXQgT0NhbWwgaW50c1wiKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OiAvLyAoaW50NjQpXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGludDY0ID0gY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KTtcbiAgICAgIGJhLnNldChpLGludDY0KTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBmID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgYmEuc2V0KGksZik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIHZhciBmID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgYmEuc2V0KGksZik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIHZhciByZSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIHZhciBpbSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIGJhLnNldChpLFsyNTQscmUsaW1dKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciByZSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBpbSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGJhLnNldChpLFsyNTQscmUsaW1dKTtcbiAgICB9XG4gICAgYnJlYWtcbiAgfVxuICBzelswXSA9ICg0ICsgbnVtX2RpbXMpICogNDtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xufVxuXG4vL0RlcHJlY2F0ZWRcbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2Zyb21cbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9mcm9tKGRhdGExLCBkYXRhMiwganN0eXAsIGtpbmQsIGxheW91dCwgZGltcyl7XG4gIGlmKGRhdGEyIHx8IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkgPT0gMil7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iYV9jcmVhdGVfZnJvbTogdXNlIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcIik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGExKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9oYXNoIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9mbG9hdFxuZnVuY3Rpb24gY2FtbF9iYV9oYXNoKGJhKXtcbiAgdmFyIG51bV9lbHRzID0gY2FtbF9iYV9nZXRfc2l6ZShiYS5kaW1zKTtcbiAgdmFyIGggPSAwO1xuICBzd2l0Y2goYmEua2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBpZihudW1fZWx0cyA+IDI1NikgbnVtX2VsdHMgPSAyNTY7XG4gICAgdmFyIHcgPSAwLCBpID0wO1xuICAgIGZvcihpID0gMDsgaSArIDQgPD0gYmEuZGF0YS5sZW5ndGg7IGkrPTQpe1xuICAgICAgdyA9IGJhLmRhdGFbaSswXSB8IChiYS5kYXRhW2krMV0gPDwgOCkgfCAoYmEuZGF0YVtpKzJdIDw8IDE2KSB8IChiYS5kYXRhW2krM10gPDwgMjQpO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsdyk7XG4gICAgfVxuICAgIHcgPSAwO1xuICAgIHN3aXRjaCAobnVtX2VsdHMgJiAzKSB7XG4gICAgY2FzZSAzOiB3ICA9IGJhLmRhdGFbaSsyXSA8PCAxNjsgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlIDI6IHcgfD0gYmEuZGF0YVtpKzFdIDw8IDg7ICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgMTogdyB8PSBiYS5kYXRhW2krMF07XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgaWYobnVtX2VsdHMgPiAxMjgpIG51bV9lbHRzID0gMTI4O1xuICAgIHZhciB3ID0gMCwgaSA9MDtcbiAgICBmb3IoaSA9IDA7IGkgKyAyIDw9IGJhLmRhdGEubGVuZ3RoOyBpKz0yKXtcbiAgICAgIHcgPSBiYS5kYXRhW2krMF0gfCAoYmEuZGF0YVtpKzFdIDw8IDE2KTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLHcpO1xuICAgIH1cbiAgICBpZiAoKG51bV9lbHRzICYgMSkgIT0gMClcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBpZiAobnVtX2VsdHMgPiAzMikgbnVtX2VsdHMgPSAzMjtcbiAgICBudW1fZWx0cyAqPSAyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBudW1fZWx0cyAqPTI7IC8qIGZhbGx0aHJvdWdoICovXG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIG51bV9lbHRzICo9MjsgLyogZmFsbHRocm91Z2ggKi9cbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgaWYgKG51bV9lbHRzID4gMzIpIG51bV9lbHRzID0gMzI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV90b190eXBlZF9hcnJheSBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGJhKXtcbiAgcmV0dXJuIGJhLmRhdGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSh0YSl7XG4gIHZhciBraW5kO1xuICBpZiAgICAgICh0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkga2luZCA9IDA7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSBraW5kID0gMTtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpIGtpbmQgPSAyO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIGtpbmQgPSAzO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSBraW5kID0gMztcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBJbnQxNkFycmF5KSBraW5kID0gNDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkga2luZCA9IDU7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgSW50MzJBcnJheSkga2luZCA9IDY7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgVWludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgcmV0dXJuIGtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGtpbmQgPSBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpO1xuICB2YXIgdGEgPVxuICAgICAgLyogTmVlZGVkIHRvIGF2b2lkIHVuc2lnbmVkIHNldHRlcnMgb3ZlcmZsb3dpbmdcbiAgICAgICAgIHRoZSByYW5nZSBvZiBPQ2FtbCBbaW50MzJdIHZhbHVlcy4gKi9cbiAgICAgIHRhIGluc3RhbmNlb2YgVWludDMyQXJyYXkgP1xuICAgICAgbmV3IEludDMyQXJyYXkodGEuYnVmZmVyICx0YS5ieXRlT2Zmc2V0LCB0YS5sZW5ndGgpIDogdGE7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBwYXJzaW5nLmMgODk4MyAyMDA4LTA4LTA2IDA5OjM4OjI1WiB4bGVyb3kgJCAqL1xuXG4vKiBUaGUgUERBIGF1dG9tYXRvbiBmb3IgcGFyc2VycyBnZW5lcmF0ZWQgYnkgY2FtbHlhY2MgKi9cblxuLyogVGhlIHB1c2hkb3duIGF1dG9tYXRhICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VyX3RyYWNlXG52YXIgY2FtbF9wYXJzZXJfdHJhY2UgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9sZXhfYXJyYXksIGNhbWxfcGFyc2VyX3RyYWNlLGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX3BhcnNlX2VuZ2luZSh0YWJsZXMsIGVudiwgY21kLCBhcmcpXG57XG4gIHZhciBFUlJDT0RFID0gMjU2O1xuXG4gIC8vdmFyIFNUQVJUID0gMDtcbiAgLy92YXIgVE9LRU5fUkVBRCA9IDE7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8xID0gMjtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzIgPSAzO1xuICAvL3ZhciBTRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQgPSA0O1xuICAvL3ZhciBFUlJPUl9ERVRFQ1RFRCA9IDU7XG4gIHZhciBsb29wID0gNjtcbiAgdmFyIHRlc3RzaGlmdCA9IDc7XG4gIHZhciBzaGlmdCA9IDg7XG4gIHZhciBzaGlmdF9yZWNvdmVyID0gOTtcbiAgdmFyIHJlZHVjZSA9IDEwO1xuXG4gIHZhciBSRUFEX1RPS0VOID0gMDtcbiAgdmFyIFJBSVNFX1BBUlNFX0VSUk9SID0gMTtcbiAgdmFyIEdST1dfU1RBQ0tTXzEgPSAyO1xuICB2YXIgR1JPV19TVEFDS1NfMiA9IDM7XG4gIHZhciBDT01QVVRFX1NFTUFOVElDX0FDVElPTiA9IDQ7XG4gIHZhciBDQUxMX0VSUk9SX0ZVTkNUSU9OID0gNTtcblxuICB2YXIgZW52X3Nfc3RhY2sgPSAxO1xuICB2YXIgZW52X3Zfc3RhY2sgPSAyO1xuICB2YXIgZW52X3N5bWJfc3RhcnRfc3RhY2sgPSAzO1xuICB2YXIgZW52X3N5bWJfZW5kX3N0YWNrID0gNDtcbiAgdmFyIGVudl9zdGFja3NpemUgPSA1O1xuICB2YXIgZW52X3N0YWNrYmFzZSA9IDY7XG4gIHZhciBlbnZfY3Vycl9jaGFyID0gNztcbiAgdmFyIGVudl9sdmFsID0gODtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0ID0gOTtcbiAgdmFyIGVudl9zeW1iX2VuZCA9IDEwO1xuICB2YXIgZW52X2FzcCA9IDExO1xuICB2YXIgZW52X3J1bGVfbGVuID0gMTI7XG4gIHZhciBlbnZfcnVsZV9udW1iZXIgPSAxMztcbiAgdmFyIGVudl9zcCA9IDE0O1xuICB2YXIgZW52X3N0YXRlID0gMTU7XG4gIHZhciBlbnZfZXJyZmxhZyA9IDE2O1xuXG4gIC8vIHZhciBfdGJsX2FjdGlvbnMgPSAxO1xuICB2YXIgdGJsX3RyYW5zbF9jb25zdCA9IDI7XG4gIHZhciB0YmxfdHJhbnNsX2Jsb2NrID0gMztcbiAgdmFyIHRibF9saHMgPSA0O1xuICB2YXIgdGJsX2xlbiA9IDU7XG4gIHZhciB0YmxfZGVmcmVkID0gNjtcbiAgdmFyIHRibF9kZ290byA9IDc7XG4gIHZhciB0Ymxfc2luZGV4ID0gODtcbiAgdmFyIHRibF9yaW5kZXggPSA5O1xuICB2YXIgdGJsX2dpbmRleCA9IDEwO1xuICB2YXIgdGJsX3RhYmxlc2l6ZSA9IDExO1xuICB2YXIgdGJsX3RhYmxlID0gMTI7XG4gIHZhciB0YmxfY2hlY2sgPSAxMztcbiAgLy8gdmFyIF90YmxfZXJyb3JfZnVuY3Rpb24gPSAxNDtcbiAgdmFyIHRibF9uYW1lc19jb25zdCA9IDE1O1xuICB2YXIgdGJsX25hbWVzX2Jsb2NrID0gMTY7XG5cblxuICBmdW5jdGlvbiBsb2coeCkge1xuICAgIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh4ICsgXCJcXG5cIik7XG4gICAgY2FtbF9tbF9vdXRwdXQoMiwgcywgMCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuX25hbWUobmFtZXMsIG51bWJlcilcbiAge1xuICAgIHZhciBzdHIgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lcyk7XG4gICAgaWYgKHN0clswXSA9PSAnXFx4MDAnKVxuICAgICAgcmV0dXJuIFwiPHVua25vd24gdG9rZW4+XCI7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnXFx4MDAnKVtudW1iZXJdO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRfdG9rZW4oc3RhdGUsIHRvaylcbiAge1xuICAgIHZhciB0b2tlbiwga2luZDtcbiAgICBpZiAodG9rIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRva2VuID0gdG9rZW5fbmFtZSh0YWJsZXNbdGJsX25hbWVzX2Jsb2NrXSwgdG9rWzBdKTtcbiAgICAgIGlmICh0eXBlb2YgdG9rWzFdID09IFwibnVtYmVyXCIpXG4gICAgICAgIGtpbmQgPSBcIlwiICsgdG9rWzFdO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIHRva1sxXSA9PSBcInN0cmluZ1wiKVxuICAgICAgICBraW5kID0gdG9rWzFdXG4gICAgICBlbHNlIGlmICh0b2tbMV0gaW5zdGFuY2VvZiBNbEJ5dGVzKVxuICAgICAgICBraW5kID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh0b2tbMV0pXG4gICAgICBlbHNlXG4gICAgICAgIGtpbmQgPSBcIl9cIlxuICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiByZWFkIHRva2VuIFwiICsgdG9rZW4gKyBcIihcIiArIGtpbmQgKyBcIilcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuID0gdG9rZW5fbmFtZSh0YWJsZXNbdGJsX25hbWVzX2NvbnN0XSwgdG9rKTtcbiAgICAgIGxvZyhcIlN0YXRlIFwiICsgc3RhdGUgKyBcIjogcmVhZCB0b2tlbiBcIiArIHRva2VuKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRhYmxlcy5kZ290bykge1xuICAgIHRhYmxlcy5kZWZyZWQgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZWZyZWRdKTtcbiAgICB0YWJsZXMuc2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0Ymxfc2luZGV4XSk7XG4gICAgdGFibGVzLmNoZWNrICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2NoZWNrXSk7XG4gICAgdGFibGVzLnJpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3JpbmRleF0pO1xuICAgIHRhYmxlcy50YWJsZSAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF90YWJsZV0pO1xuICAgIHRhYmxlcy5sZW4gICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9sZW5dKTtcbiAgICB0YWJsZXMubGhzICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGhzXSk7XG4gICAgdGFibGVzLmdpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2dpbmRleF0pO1xuICAgIHRhYmxlcy5kZ290byAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZ290b10pO1xuICB9XG5cbiAgdmFyIHJlcyA9IDAsIG4sIG4xLCBuMiwgc3RhdGUxO1xuXG4gIC8vIFJFU1RPUkVcbiAgdmFyIHNwID0gZW52W2Vudl9zcF07XG4gIHZhciBzdGF0ZSA9IGVudltlbnZfc3RhdGVdO1xuICB2YXIgZXJyZmxhZyA9IGVudltlbnZfZXJyZmxhZ107XG5cbiAgZXhpdDpmb3IgKDs7KSB7XG4gICAgbmV4dDpzd2l0Y2goY21kKSB7XG4gICAgY2FzZSAwOi8vU1RBUlQ6XG4gICAgICBzdGF0ZSA9IDA7XG4gICAgICBlcnJmbGFnID0gMDtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSA2Oi8vbG9vcDpcbiAgICAgIG4gPSB0YWJsZXMuZGVmcmVkW3N0YXRlXTtcbiAgICAgIGlmIChuICE9IDApIHsgY21kID0gcmVkdWNlOyBicmVhazsgfVxuICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA+PSAwKSB7IGNtZCA9IHRlc3RzaGlmdDsgYnJlYWs7IH1cbiAgICAgIHJlcyA9IFJFQURfVE9LRU47XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIGxleGVyIGFuZCB1cGRhdGVzICovXG4gICAgICAvKiBzeW1iX3N0YXJ0IGFuZCBzeW1iX2VuZCAqL1xuICAgIGNhc2UgMTovL1RPS0VOX1JFQUQ6XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfYmxvY2tdW2FyZ1swXSArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gYXJnWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfY29uc3RdW2FyZyArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSkgcHJpbnRfdG9rZW4gKHN0YXRlLCBhcmcpO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIDc6Ly90ZXN0c2hpZnQ6XG4gICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgY21kID0gc2hpZnQ7IGJyZWFrO1xuICAgICAgfVxuICAgICAgbjEgPSB0YWJsZXMucmluZGV4W3N0YXRlXTtcbiAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gZW52W2Vudl9jdXJyX2NoYXJdKSB7XG4gICAgICAgIG4gPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgICBjbWQgPSByZWR1Y2U7IGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGVycmZsYWcgPD0gMCkge1xuICAgICAgICByZXMgPSBDQUxMX0VSUk9SX0ZVTkNUSU9OO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgZXJyb3IgZnVuY3Rpb24gKi9cbiAgICBjYXNlIDU6Ly9FUlJPUl9ERVRFQ1RFRDpcbiAgICAgIGlmIChlcnJmbGFnIDwgMykge1xuICAgICAgICBlcnJmbGFnID0gMztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3AgKyAxXTtcbiAgICAgICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGUxXTtcbiAgICAgICAgICBuMiA9IG4xICsgRVJSQ09ERTtcbiAgICAgICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IEVSUkNPREUpIHtcbiAgICAgICAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgICAgICAgbG9nKFwiUmVjb3ZlcmluZyBpbiBzdGF0ZSBcIiArIHN0YXRlMSk7XG4gICAgICAgICAgICBjbWQgPSBzaGlmdF9yZWNvdmVyOyBicmVhayBuZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgICAgICAgIGxvZyhcIkRpc2NhcmRpbmcgc3RhdGUgXCIgKyBzdGF0ZTEpO1xuICAgICAgICAgICAgaWYgKHNwIDw9IGVudltlbnZfc3RhY2tiYXNlXSkge1xuICAgICAgICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgICAgICAgICAgbG9nKFwiTm8gbW9yZSBzdGF0ZXMgdG8gZGlzY2FyZFwiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgICAgICBzcC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA9PSAwKVxuICAgICAgICAgIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjsgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgICBsb2coXCJEaXNjYXJkaW5nIGxhc3QgdG9rZW4gcmVhZFwiKTtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA4Oi8vc2hpZnQ6XG4gICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgIGlmIChlcnJmbGFnID4gMCkgZXJyZmxhZy0tO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA5Oi8vc2hpZnRfcmVjb3ZlcjpcbiAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiBzaGlmdCB0byBzdGF0ZSBcIiArIHRhYmxlcy50YWJsZVtuMl0pO1xuICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgc3ArKztcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMTtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgY2FzZSAyOi8vU1RBQ0tTX0dST1dOXzE6XG4gICAgICBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV0gPSBzdGF0ZTtcbiAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfbHZhbF07XG4gICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfc3RhcnRdO1xuICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRdO1xuICAgICAgY21kID0gbG9vcDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxMDovL3JlZHVjZTpcbiAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiByZWR1Y2UgYnkgcnVsZSBcIiArIG4pO1xuICAgICAgdmFyIG0gPSB0YWJsZXMubGVuW25dO1xuICAgICAgZW52W2Vudl9hc3BdID0gc3A7XG4gICAgICBlbnZbZW52X3J1bGVfbnVtYmVyXSA9IG47XG4gICAgICBlbnZbZW52X3J1bGVfbGVuXSA9IG07XG4gICAgICBzcCA9IHNwIC0gbSArIDE7XG4gICAgICBtID0gdGFibGVzLmxoc1tuXTtcbiAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3BdO1xuICAgICAgbjEgPSB0YWJsZXMuZ2luZGV4W21dO1xuICAgICAgbjIgPSBuMSArIHN0YXRlMTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBzdGF0ZTEpXG4gICAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMuZGdvdG9bbV07XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzI7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMzovL1NUQUNLU19HUk9XTl8yOlxuICAgICAgcmVzID0gQ09NUFVURV9TRU1BTlRJQ19BQ1RJT047XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIHNlbWFudGljIGFjdGlvbiAqL1xuICAgIGNhc2UgNDovL1NFTUFOVElDX0FDVElPTl9DT01QVVRFRDpcbiAgICAgIGVudltlbnZfc19zdGFja11bc3AgKyAxXSA9IHN0YXRlO1xuICAgICAgZW52W2Vudl92X3N0YWNrXVtzcCArIDFdID0gYXJnO1xuICAgICAgdmFyIGFzcCA9IGVudltlbnZfYXNwXTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIGlmIChzcCA+IGFzcCkge1xuICAgICAgICAvKiBUaGlzIGlzIGFuIGVwc2lsb24gcHJvZHVjdGlvbi4gVGFrZSBzeW1iX3N0YXJ0IGVxdWFsIHRvIHN5bWJfZW5kLiAqL1xuICAgICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIH1cbiAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgLyogU2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvLyBTQVZFXG4gIGVudltlbnZfc3BdID0gc3A7XG4gIGVudltlbnZfc3RhdGVdID0gc3RhdGU7XG4gIGVudltlbnZfZXJyZmxhZ10gPSBlcnJmbGFnO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9wYXJzZXJfdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VyX3RyYWNlXG5mdW5jdGlvbiBjYW1sX3NldF9wYXJzZXJfdHJhY2UoYm9vbCkge1xuICB2YXIgb2xkZmxhZyA9IGNhbWxfcGFyc2VyX3RyYWNlO1xuICBjYW1sX3BhcnNlcl90cmFjZSA9IGJvb2w7XG4gIHJldHVybiBvbGRmbGFnO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfaW50IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZywgY2FtbF9zdHJfcmVwZWF0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9pbnQoZm10LCBpKSB7XG4gIGlmIChjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCkgPT0gXCIlZFwiKSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiK2kpO1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChpIDwgMCkgeyBpZiAoZi5zaWduZWRjb252KSB7IGYuc2lnbiA9IC0xOyBpID0gLWk7IH0gZWxzZSBpID4+Pj0gMDsgfVxuICB2YXIgcyA9IGkudG9TdHJpbmcoZi5iYXNlKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSAnICc7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBzLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIHMgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBzO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2Vcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKSB7XG4gIHZhciBpID0gMCwgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpLCBiYXNlID0gMTAsIHNpZ24gPSAxO1xuICBpZiAobGVuID4gMCkge1xuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpKSB7XG4gICAgY2FzZSA0NTogaSsrOyBzaWduID0gLTE7IGJyZWFrO1xuICAgIGNhc2UgNDM6IGkrKzsgc2lnbiA9IDE7IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoaSArIDEgPCBsZW4gJiYgY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSA9PSA0OClcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSArIDEpKSB7XG4gICAgY2FzZSAxMjA6IGNhc2UgODg6IGJhc2UgPSAxNjsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlIDExMTogY2FzZSA3OTogYmFzZSA9ICA4OyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgIDk4OiBjYXNlIDY2OiBiYXNlID0gIDI7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTc6IGNhc2UgODU6IGkgKz0gMjsgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gW2ksIHNpZ24sIGJhc2VdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2RpZ2l0XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2RpZ2l0KGMpIHtcbiAgaWYgKGMgPj0gNDggJiYgYyA8PSA1NykgIHJldHVybiBjIC0gNDg7XG4gIGlmIChjID49IDY1ICYmIGMgPD0gOTApICByZXR1cm4gYyAtIDU1O1xuICBpZiAoYyA+PSA5NyAmJiBjIDw9IDEyMikgcmV0dXJuIGMgLSA4NztcbiAgcmV0dXJuIC0xO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfcGFyc2VfZGlnaXQsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfaW50X29mX3N0cmluZyAocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgdGhyZXNob2xkID0gLTEgPj4+IDA7XG4gIHZhciBjID0gKGkgPCBsZW4pP2NhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk6MDtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGQ7XG4gIGZvciAoaSsrO2k8bGVuO2krKykge1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICByZXMgPSBiYXNlICogcmVzICsgZDtcbiAgICBpZiAocmVzID4gdGhyZXNob2xkKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBsZW4pIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAvLyBGb3IgYmFzZSBkaWZmZXJlbnQgZnJvbSAxMCwgd2UgZXhwZWN0IGFuIHVuc2lnbmVkIHJlcHJlc2VudGF0aW9uLFxuICAvLyBoZW5jZSBhbnkgdmFsdWUgb2YgJ3JlcycgKGxlc3MgdGhhbiAndGhyZXNob2xkJykgaXMgYWNjZXB0YWJsZS5cbiAgLy8gQnV0IHdlIGhhdmUgdG8gY29udmVydCB0aGUgcmVzdWx0IGJhY2sgdG8gYSBzaWduZWQgaW50ZWdlci5cbiAgcmVzID0gc2lnbiAqIHJlcztcbiAgaWYgKChiYXNlID09IDEwKSAmJiAoKHJlcyB8IDApICE9IHJlcykpXG4gICAgLyogU2lnbmVkIHJlcHJlc2VudGF0aW9uIGV4cGVjdGVkLCBhbGxvdyAtMl4obmJpdHMtMSkgdG8gMl4obmJpdHMtMSkgLSAxICovXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHJldHVybiByZXMgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX211bCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tdWwoYSxiKXtcbiAgcmV0dXJuIE1hdGguaW11bChhLGIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RpdlxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9kaXYoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiAoeC95KXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9tb2QoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiB4JXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnN3YXAxNlxuZnVuY3Rpb24gY2FtbF9ic3dhcDE2KHgpIHtcbiAgcmV0dXJuICgoKCh4ICYgMHgwMEZGKSA8PCA4KSB8XG4gICAgICAgICAgICgoeCAmIDB4RkYwMCkgPj4gOCkpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfYnN3YXBcbmZ1bmN0aW9uIGNhbWxfaW50MzJfYnN3YXAoeCkge1xuICByZXR1cm4gKCgoeCAmIDB4MDAwMDAwRkYpIDw8IDI0KSB8XG4gICAgICAgICAgKCh4ICYgMHgwMDAwRkYwMCkgPDwgOCkgfFxuICAgICAgICAgICgoeCAmIDB4MDBGRjAwMDApID4+PiA4KSB8XG4gICAgICAgICAgKCh4ICYgMHhGRjAwMDAwMCkgPj4+IDI0KSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Jzd2FwXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X2Jzd2FwKHgpIHtcbiAgdmFyIHkgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHgpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbeVs3XSwgeVs2XSwgeVs1XSwgeVs0XSwgeVszXSwgeVsyXSwgeVsxXSwgeVswXV0pO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBIYXNodGJsXG5cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX3VuaXZfcGFyYW0gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG4vL1ZlcnNpb246IDwgNC4xMlxuZnVuY3Rpb24gY2FtbF9oYXNoX3VuaXZfcGFyYW0gKGNvdW50LCBsaW1pdCwgb2JqKSB7XG4gIHZhciBoYXNoX2FjY3UgPSAwO1xuICBmdW5jdGlvbiBoYXNoX2F1eCAob2JqKSB7XG4gICAgbGltaXQgLS07XG4gICAgaWYgKGNvdW50IDwgMCB8fCBsaW1pdCA8IDApIHJldHVybjtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkgJiYgb2JqWzBdID09PSAob2JqWzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKG9ialswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqWzJdKSB8IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTA6XG4gICAgICAgIC8vIEZvcndhcmRcbiAgICAgICAgbGltaXQrKzsgaGFzaF9hdXgob2JqKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgb2JqWzBdKSB8IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBvYmoubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkgaGFzaF9hdXggKG9ialtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKG9iaikpIHtcbiAgICAgIGNvdW50IC0tO1xuICAgICAgdmFyIGNvbnRlbnQgPSBjYW1sX21sX2J5dGVzX2NvbnRlbnQob2JqKTtcbiAgICAgIGlmKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGZvciAodmFyIGIgPSBjb250ZW50LCBsID0gYi5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgICAgfSBlbHNlIHsgLyogQVJSQVkgKi9cbiAgICAgICAgZm9yICh2YXIgYSA9IGNvbnRlbnQsIGwgPSBhLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYVtpXSkgfCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcob2JqKSkge1xuICAgICAgdmFyIGpzYnl0ZXMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9iaik7XG4gICAgICBmb3IgKHZhciBiID0ganNieXRlcywgbCA9IGpzYnl0ZXMubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmb3IgKHZhciBiID0gb2JqLCBsID0gb2JqLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSAob2JqfDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBjb3VudCAtLTtcbiAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9iaikgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSArb2JqKSB7XG4gICAgICAvLyBGbG9hdFxuICAgICAgY291bnQtLTtcbiAgICAgIHZhciBwID0gY2FtbF9pbnQ2NF90b19ieXRlcyAoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IChvYmopKTtcbiAgICAgIGZvciAodmFyIGkgPSA3OyBpID49IDA7IGktLSkgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgcFtpXSkgfCAwO1xuICAgIH0gZWxzZSBpZihvYmogJiYgb2JqLmNhbWxfY3VzdG9tKSB7XG4gICAgICBpZihjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXS5oYXNoKSB7XG4gICAgICAgIHZhciBoID0gY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaChvYmopIHwgMDtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgaCkgfCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYXNoX2F1eCAob2JqKTtcbiAgcmV0dXJuIGhhc2hfYWNjdSAmIDB4M0ZGRkZGRkY7XG59XG5cbi8vZnVuY3Rpb24gUk9UTDMyKHgsbikgeyByZXR1cm4gKCh4IDw8IG4pIHwgKHggPj4+ICgzMi1uKSkpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ludFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfaW50KGgsZCkge1xuICBkID0gY2FtbF9tdWwoZCwgMHhjYzllMmQ1MXwwKTtcbiAgZCA9ICgoZCA8PCAxNSkgfCAoZCA+Pj4gKDMyLTE1KSkpOyAvLyBST1RMMzIoZCwgMTUpO1xuICBkID0gY2FtbF9tdWwoZCwgMHgxYjg3MzU5Myk7XG4gIGggXj0gZDtcbiAgaCA9ICgoaCA8PCAxMykgfCAoaCA+Pj4gKDMyLTEzKSkpOyAgIC8vUk9UTDMyKGgsIDEzKTtcbiAgcmV0dXJuICgoKGggKyAoaCA8PCAyKSl8MCkgKyAoMHhlNjU0NmI2NHwwKSl8MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmluYWwoaCkge1xuICBoIF49IGggPj4+IDE2O1xuICBoID0gY2FtbF9tdWwgKGgsIDB4ODVlYmNhNmJ8MCk7XG4gIGggXj0gaCA+Pj4gMTM7XG4gIGggPSBjYW1sX211bCAoaCwgMHhjMmIyYWUzNXwwKTtcbiAgaCBePSBoID4+PiAxNjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9oYXNoX21peF9pbnQ2NFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9mbG9hdCAoaCwgdjApIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfaW50NjQoaCwgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0ICh2MCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbG8zMiwgY2FtbF9pbnQ2NF9oaTMyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludDY0IChoLCB2KSB7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBjYW1sX2ludDY0X2xvMzIodikpO1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgY2FtbF9pbnQ2NF9oaTMyKHYpKTtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aCwgaSwgdztcbiAgZm9yIChpID0gMDsgaSArIDQgPD0gbGVuOyBpICs9IDQpIHtcbiAgICB3ID0gcy5jaGFyQ29kZUF0KGkpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCA4KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMikgPDwgMTYpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSszKSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHMuY2hhckNvZGVBdChpKzIpIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gcy5jaGFyQ29kZUF0KGkrMSkgPDwgODtcbiAgY2FzZSAxOlxuICAgIHcgfD0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHNbaV1cbiAgICAgIHwgKHNbaSsxXSA8PCA4KVxuICAgICAgfCAoc1tpKzJdIDw8IDE2KVxuICAgICAgfCAoc1tpKzNdIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICBjYXNlIDM6IHcgID0gc1tpKzJdIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gc1tpKzFdIDw8IDg7XG4gIGNhc2UgMTogdyB8PSBzW2ldO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlcyhoLCB2KSB7XG4gIHZhciBjb250ZW50ID0gY2FtbF9tbF9ieXRlc19jb250ZW50KHYpO1xuICBpZih0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIGNvbnRlbnQpXG4gIGVsc2UgLyogQVJSQVkgKi9cbiAgICByZXR1cm4gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCwgY29udGVudCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsIHYpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHYpKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2ggbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBjYW1sX2hhc2hfbWl4X2ZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0LCBjYW1sX2hhc2hfbWl4X3N0cmluZywgY2FtbF9oYXNoX21peF9ieXRlcywgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaXNfY29udGludWF0aW9uX3RhZ1xuZnVuY3Rpb24gY2FtbF9oYXNoIChjb3VudCwgbGltaXQsIHNlZWQsIG9iaikge1xuICB2YXIgcXVldWUsIHJkLCB3ciwgc3osIG51bSwgaCwgdiwgaSwgbGVuO1xuICBzeiA9IGxpbWl0O1xuICBpZiAoc3ogPCAwIHx8IHN6ID4gMjU2KSBzeiA9IDI1NjtcbiAgbnVtID0gY291bnQ7XG4gIGggPSBzZWVkO1xuICBxdWV1ZSA9IFtvYmpdOyByZCA9IDA7IHdyID0gMTtcbiAgd2hpbGUgKHJkIDwgd3IgJiYgbnVtID4gMCkge1xuICAgIHYgPSBxdWV1ZVtyZCsrXTtcbiAgICBpZiAodiAmJiB2LmNhbWxfY3VzdG9tKXtcbiAgICAgIGlmKGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaGggPSBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCh2KTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50IChoLCBoaCk7XG4gICAgICAgIG51bSAtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKHZbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHZbMl0pO1xuICAgICAgICBudW0tLTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBxdWV1ZVstLXJkXSA9IHZbMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYoY2FtbF9pc19jb250aW51YXRpb25fdGFnKHZbMF0pKSB7XG4gICAgICAgICAgLyogQWxsIGNvbnRpbnVhdGlvbnMgaGFzaCB0byB0aGUgc2FtZSB2YWx1ZSxcbiAgICAgICAgICAgICBzaW5jZSB3ZSBoYXZlIG5vIGlkZWEgaG93IHRvIGRpc3Rpbmd1aXNoIHRoZW0uICovXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhZyA9ICgodi5sZW5ndGggLSAxKSA8PCAxMCkgfCB2WzBdO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdGFnKTtcbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICh3ciA+PSBzeikgYnJlYWs7XG4gICAgICAgICAgcXVldWVbd3IrK10gPSB2W2ldO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSAodnwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHYrdisxKTtcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLHYpO1xuICAgICAgbnVtLS07XG4gICAgfVxuICB9XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpO1xuICByZXR1cm4gaCAmIDB4M0ZGRkZGRkY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2hhc2hcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmluYWwsIGNhbWxfaGFzaF9taXhfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19oYXNoKGgsIHYpe1xuICB2YXIgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsdik7XG4gIHZhciBoID0gY2FtbF9oYXNoX21peF9maW5hbChoKTtcbiAgcmV0dXJuIGggJiAweDNGRkZGRkZGO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF91cGRhdGVfZHVtbXlcbmZ1bmN0aW9uIGNhbWxfdXBkYXRlX2R1bW15ICh4LCB5KSB7XG4gIGlmKCB5LmZ1biApIHsgeC5mdW4gPSB5LmZ1bjsgcmV0dXJuIDA7IH1cbiAgaWYoIHR5cGVvZiB5PT09XCJmdW5jdGlvblwiICkgeyB4LmZ1biA9IHk7IHJldHVybiAwOyB9XG4gIHZhciBpID0geS5sZW5ndGg7IHdoaWxlIChpLS0pIHhbaV0gPSB5W2ldOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hbGxvY19kdW1teV9pbmZpeFxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9hbGxvY19kdW1teV9pbmZpeCAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmICh4KSB7IHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuZnVuLCBbeF0pIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfaXNfYmxvY2sgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfaXNfYmxvY2sgKHgpIHsgcmV0dXJuICsoeCBpbnN0YW5jZW9mIEFycmF5KTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9pc19tbF9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfb2JqX3RhZyAoeCkge1xuICBpZiAoKHggaW5zdGFuY2VvZiBBcnJheSkgJiYgeFswXSA9PSAoeFswXSA+Pj4gMCkpXG4gICAgcmV0dXJuIHhbMF1cbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh4KSlcbiAgICByZXR1cm4gMjUyXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHgpKVxuICAgIHJldHVybiAyNTJcbiAgZWxzZSBpZiAoKHggaW5zdGFuY2VvZiBGdW5jdGlvbikgfHwgdHlwZW9mIHggPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiAyNDdcbiAgZWxzZSBpZiAoeCAmJiB4LmNhbWxfY3VzdG9tKVxuICAgIHJldHVybiAyNTVcbiAgZWxzZVxuICAgIHJldHVybiAxMDAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3NldF90YWcgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfc2V0X3RhZyAoeCwgdGFnKSB7IHhbMF0gPSB0YWc7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX29ial9ibG9jayBjb25zdCAoY29uc3QsY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9ibG9jayAodGFnLCBzaXplKSB7XG4gIHZhciBvID0gbmV3IEFycmF5KHNpemUrMSk7XG4gIG9bMF09dGFnO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSBzaXplOyBpKyspIG9baV0gPSAwO1xuICByZXR1cm4gbztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfd2l0aF90YWdcbmZ1bmN0aW9uIGNhbWxfb2JqX3dpdGhfdGFnKHRhZyx4KSB7XG4gIHZhciBsID0geC5sZW5ndGg7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gdGFnO1xuICBmb3IodmFyIGkgPSAxOyBpIDwgbDsgaSsrICkgYVtpXSA9IHhbaV07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9kdXAgbXV0YWJsZSAobXV0YWJsZSlcbmZ1bmN0aW9uIGNhbWxfb2JqX2R1cCAoeCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdHJ1bmNhdGUgKG11dGFibGUsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX29ial90cnVuY2F0ZSAoeCwgcykge1xuICBpZiAoczw9MCB8fCBzICsgMSA+IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJPYmoudHJ1bmNhdGVcIik7XG4gIGlmICh4Lmxlbmd0aCAhPSBzICsgMSkgeC5sZW5ndGggPSBzICsgMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX21ha2VfZm9yd2FyZFxuZnVuY3Rpb24gY2FtbF9vYmpfbWFrZV9mb3J3YXJkIChiLHYpIHtcbiAgYlswXT0yNTA7XG4gIGJbMV09djtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfY29tcGFyZV9hbmRfc3dhcFxuZnVuY3Rpb24gY2FtbF9vYmpfY29tcGFyZV9hbmRfc3dhcCh4LGksb2xkLG4pe1xuICBpZih4W2krMV0gPT0gb2xkKSB7XG4gICAgeFtpKzFdID0gbjtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9pc19zaGFyZWRcbmZ1bmN0aW9uIGNhbWxfb2JqX2lzX3NoYXJlZCh4KXtcbiAgcmV0dXJuIDFcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X21ha2VfZm9yd2FyZCBjb25zdCAobXV0YWJsZSlcbmZ1bmN0aW9uIGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgKHYpIHsgcmV0dXJuIFsyNTAsIHZdOyB9XG5cbi8vLy8vLy8vLy8vLy8gQ2FtbGludGVybmFsT09cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgY29uc3RcbnZhciBjYW1sX21ldGhvZF9jYWNoZSA9IFtdO1xuZnVuY3Rpb24gY2FtbF9nZXRfcHVibGljX21ldGhvZCAob2JqLCB0YWcsIGNhY2hlaWQpIHtcbiAgdmFyIG1ldGhzID0gb2JqWzFdO1xuICB2YXIgb2ZzID0gY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF07XG4gIGlmIChvZnMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyYXkgaXMgbm90IHNwYXJzZVxuICAgIGZvciAodmFyIGkgPSBjYW1sX21ldGhvZF9jYWNoZS5sZW5ndGg7IGkgPCBjYWNoZWlkOyBpKyspXG4gICAgICBjYW1sX21ldGhvZF9jYWNoZVtpXSA9IDA7XG4gIH0gZWxzZSBpZiAobWV0aHNbb2ZzXSA9PT0gdGFnKSB7XG4gICAgcmV0dXJuIG1ldGhzW29mcyAtIDFdO1xuICB9XG4gIHZhciBsaSA9IDMsIGhpID0gbWV0aHNbMV0gKiAyICsgMSwgbWk7XG4gIHdoaWxlIChsaSA8IGhpKSB7XG4gICAgbWkgPSAoKGxpK2hpKSA+PiAxKSB8IDE7XG4gICAgaWYgKHRhZyA8IG1ldGhzW21pKzFdKSBoaSA9IG1pLTI7XG4gICAgZWxzZSBsaSA9IG1pO1xuICB9XG4gIGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdID0gbGkgKyAxO1xuICAvKiByZXR1cm4gMCBpZiB0YWcgaXMgbm90IHRoZXJlICovXG4gIHJldHVybiAodGFnID09IG1ldGhzW2xpKzFdID8gbWV0aHNbbGldIDogMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb29fbGFzdF9pZFxudmFyIGNhbWxfb29fbGFzdF9pZCA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X29vX2lkXG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfc2V0X29vX2lkIChiKSB7XG4gIGJbMl09Y2FtbF9vb19sYXN0X2lkKys7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXNoX29vX2lkIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfZnJlc2hfb29faWQoKSB7XG4gIHJldHVybiBjYW1sX29vX2xhc3RfaWQrKztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfcmF3X2ZpZWxkXG5mdW5jdGlvbiBjYW1sX29ial9yYXdfZmllbGQobyxpKSB7IHJldHVybiBvW2krMV0gfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9zZXRfcmF3X2ZpZWxkXG5mdW5jdGlvbiBjYW1sX29ial9zZXRfcmF3X2ZpZWxkKG8saSx2KSB7IHJldHVybiBvW2krMV0gPSB2IH1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzXG5mdW5jdGlvbiBjYW1sX29ial9yZWFjaGFibGVfd29yZHMobykgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9hZGRfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX29ial9hZGRfb2Zmc2V0KHYsb2Zmc2V0KSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJPYmouYWRkX29mZnNldCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial91cGRhdGVfdGFnXG5mdW5jdGlvbiBjYW1sX29ial91cGRhdGVfdGFnKGIsbyxuKSB7XG4gICAgaWYoYlswXT09bykgeyBiWzBdID0gbjsgcmV0dXJuIDEgfVxuICAgIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV91cGRhdGVfdG9fZm9yY2luZ1xuLy9SZXF1aXJlczogY2FtbF9vYmpfdXBkYXRlX3RhZ1xuZnVuY3Rpb24gY2FtbF9sYXp5X3VwZGF0ZV90b19mb3JjaW5nKG8pIHtcbiAgaWYgKChvIGluc3RhbmNlb2YgQXJyYXkpICYmIG9bMF0gPT0gKG9bMF0gPj4+IDApICYmXG4gICAgICBjYW1sX29ial91cGRhdGVfdGFnKG8sIDI0NiwgMjQ0KSkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV91cGRhdGVfdG9fZm9yd2FyZFxuLy9SZXF1aXJlczogY2FtbF9vYmpfdXBkYXRlX3RhZ1xuICBmdW5jdGlvbiBjYW1sX2xhenlfdXBkYXRlX3RvX2ZvcndhcmQobykge1xuICBjYW1sX29ial91cGRhdGVfdGFnKG8sMjQ0LDI1MCk7XG4gIHJldHVybiAwOyAvLyB1bml0XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X3Jlc2V0X3RvX2xhenlcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX3VwZGF0ZV90YWdcbmZ1bmN0aW9uIGNhbWxfbGF6eV9yZXNldF90b19sYXp5KG8pIHtcbiAgY2FtbF9vYmpfdXBkYXRlX3RhZyhvLDI0NCwyNDYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X3JlYWRfcmVzdWx0XG4vL1JlcXVpcmVzOiBjYW1sX29ial90YWdcbmZ1bmN0aW9uIGNhbWxfbGF6eV9yZWFkX3Jlc3VsdChvKSB7XG4gIHJldHVybiAoY2FtbF9vYmpfdGFnKG8pID09IDI1MCk/b1sxXTpvO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfY29udGludWF0aW9uX3RhZ1xuLy9WZXJzaW9uOiA8IDVcbmZ1bmN0aW9uIGNhbWxfaXNfY29udGludWF0aW9uX3RhZyh0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWdcbi8vVmVyc2lvbjogPj0gNVxuZnVuY3Rpb24gY2FtbF9pc19jb250aW51YXRpb25fdGFnKHQpIHtcbiAgcmV0dXJuICh0ID09IDI0NSkgPyAxIDogMDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSl7XG4gIGlmICh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIikgcmV0dXJuIDEwMDA7IC8vIGludF90YWcgKHdlIHVzZSBpdCBmb3IgYWxsIG51bWJlcnMpXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoYSkpIHJldHVybiAyNTI7IC8vIHN0cmluZ190YWdcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcoYSkpIHJldHVybiAxMjUyOyAvLyBvY2FtbCBzdHJpbmcgKGlmIGRpZmZlcmVudCBmcm9tIGJ5dGVzKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgQXJyYXkgJiYgYVswXSA9PT0gKGFbMF0+Pj4wKSAmJiBhWzBdIDw9IDI1NSkge1xuICAgIC8vIExvb2sgbGlrZSBhbiBvY2FtbCBibG9ja1xuICAgIHZhciB0YWcgPSBhWzBdIHwgMDtcbiAgICAvLyBpZ25vcmUgZG91YmxlX2FycmF5X3RhZyBiZWNhdXNlIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IHNldFxuICAgIC8vIHRoaXMgdGFnIHdoZW4gd2UgY3JlYXRlIGFuIGFycmF5IG9mIGZsb2F0LlxuICAgIHJldHVybiAodGFnID09IDI1NCk/MDp0YWdcbiAgfVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgU3RyaW5nKSByZXR1cm4gMTI1MjA7IC8vIGphdmFzY3JpcHQgc3RyaW5nLCBsaWtlIHN0cmluZ190YWcgKDI1MilcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBOdW1iZXIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChhICYmIGEuY2FtbF9jdXN0b20pIHJldHVybiAxMjU1OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAoYSAmJiBhLmNvbXBhcmUpIHJldHVybiAxMjU2OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gMTI0NzsgLy8gbGlrZSBjbG9zdXJlX3RhZyAoMjQ3KVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PSBcInN5bWJvbFwiKSByZXR1cm4gMTI1MTtcbiAgcmV0dXJuIDEwMDE7IC8vb3V0X29mX2hlYXBfdGFnXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSl7XG4gIHJldHVybiBjYW1sX2N1c3RvbV9vcHNbYS5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dLmNvbXBhcmU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20obnVtLCBjdXN0b20sIHN3YXAsIHRvdGFsKSB7XG4gIHZhciBjb21wID0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGN1c3RvbSk7XG4gIGlmKGNvbXApIHtcbiAgICB2YXIgeCA9IChzd2FwID4gMCk/Y29tcChjdXN0b20sbnVtLHRvdGFsKTpjb21wKG51bSxjdXN0b20sdG90YWwpO1xuICAgIGlmKHRvdGFsICYmIHggIT0geCkgcmV0dXJuIHN3YXA7IC8vIHRvdGFsICYmIG5hblxuICAgIGlmKCt4ICE9ICt4KSByZXR1cm4gK3g7IC8vIG5hblxuICAgIGlmKCh4IHwgMCkgIT0gMCkgcmV0dXJuICh4IHwgMCk7IC8vICFuYW5cbiAgfVxuICByZXR1cm4gc3dhcFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsIChjb25zdCwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnRfY29tcGFyZSwgY2FtbF9zdHJpbmdfY29tcGFyZSwgY2FtbF9ieXRlc19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSwgY2FtbF9jb21wYXJlX3ZhbF90YWdcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9pc19jb250aW51YXRpb25fdGFnXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsIChhLCBiLCB0b3RhbCkge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgZm9yKDs7KSB7XG4gICAgaWYgKCEodG90YWwgJiYgYSA9PT0gYikpIHtcbiAgICAgIHZhciB0YWdfYSA9IGNhbWxfY29tcGFyZV92YWxfdGFnKGEpO1xuICAgICAgLy8gZm9yd2FyZF90YWcgP1xuICAgICAgaWYodGFnX2EgPT0gMjUwKSB7IGEgPSBhWzFdOyBjb250aW51ZSB9XG5cbiAgICAgIHZhciB0YWdfYiA9IGNhbWxfY29tcGFyZV92YWxfdGFnKGIpO1xuICAgICAgLy8gZm9yd2FyZF90YWcgP1xuICAgICAgaWYodGFnX2IgPT0gMjUwKSB7IGIgPSBiWzFdOyBjb250aW51ZSB9XG5cbiAgICAgIC8vIHRhZ3MgYXJlIGRpZmZlcmVudFxuICAgICAgaWYodGFnX2EgIT09IHRhZ19iKSB7XG4gICAgICAgIGlmKHRhZ19hID09IDEwMDApIHtcbiAgICAgICAgICBpZih0YWdfYiA9PSAxMjU1KSB7IC8vaW1tZWRpYXRlIGNhbiBjb21wYXJlIGFnYWluc3QgY3VzdG9tXG4gICAgICAgICAgICByZXR1cm4gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKGEsIGIsIC0xLCB0b3RhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGlmKHRhZ19iID09IDEwMDApIHtcbiAgICAgICAgICBpZih0YWdfYSA9PSAxMjU1KSB7IC8vaW1tZWRpYXRlIGNhbiBjb21wYXJlIGFnYWluc3QgY3VzdG9tXG4gICAgICAgICAgICByZXR1cm4gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKGIsIGEsIDEsIHRvdGFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRhZ19hIDwgdGFnX2IpPy0xOjE7XG4gICAgICB9XG4gICAgICBzd2l0Y2godGFnX2Epe1xuICAgICAgICAvLyAyNDY6IExhenlfdGFnIGhhbmRsZWQgYmVsbG93XG4gICAgICBjYXNlIDI0NzogLy8gQ2xvc3VyZV90YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNDg6IC8vIE9iamVjdFxuICAgICAgICB2YXIgeCA9IGNhbWxfaW50X2NvbXBhcmUoYVsyXSwgYlsyXSk7XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjQ5OiAvLyBJbmZpeFxuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI1MDogLy8gRm9yd2FyZCB0YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlbiwgaGFuZGxlZCBhYm92ZVxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IEZvcndhcmRfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MTogLy9BYnN0cmFjdFxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogYWJzdHJhY3QgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTI6IC8vIE9DYW1sIGJ5dGVzXG4gICAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgICAgdmFyIHggPSBjYW1sX2J5dGVzX2NvbXBhcmUoYSwgYik7XG4gICAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTM6IC8vIERvdWJsZV90YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IERvdWJsZV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjU0OiAvLyBEb3VibGVfYXJyYXlfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW4sIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBEb3VibGVfYXJyYXlfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjU1OiAvLyBDdXN0b21fdGFnXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgQ3VzdG9tX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjQ3OiAvLyBGdW5jdGlvblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1NTogLy8gQ3VzdG9tXG4gICAgICAgIHZhciBjb21wID0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGEpO1xuICAgICAgICBpZihjb21wICE9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShiKSl7XG4gICAgICAgICAgcmV0dXJuIChhLmNhbWxfY3VzdG9tPGIuY2FtbF9jdXN0b20pPy0xOjE7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIWNvbXApXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogYWJzdHJhY3QgdmFsdWVcIik7XG4gICAgICAgIHZhciB4ID0gY29tcChhLGIsdG90YWwpO1xuICAgICAgICBpZih4ICE9IHgpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCBVTk9SREVSRURcbiAgICAgICAgICByZXR1cm4gdG90YWw/LTE6eDtcbiAgICAgICAgfVxuICAgICAgICBpZih4ICE9PSAoeHwwKSl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIHJldHVybiB2YWx1ZVxuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1NjogLy8gY29tcGFyZSBmdW5jdGlvblxuICAgICAgICB2YXIgeCA9IGEuY29tcGFyZShiLHRvdGFsKTtcbiAgICAgICAgaWYoeCAhPSB4KSB7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIFVOT1JERVJFRFxuICAgICAgICAgIHJldHVybiB0b3RhbD8tMTp4O1xuICAgICAgICB9XG4gICAgICAgIGlmKHggIT09ICh4fDApKXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDAwOiAvLyBOdW1iZXJcbiAgICAgICAgYSA9ICthO1xuICAgICAgICBiID0gK2I7XG4gICAgICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICBpZiAoYSAhPSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICBpZiAoYSA9PSBhKSByZXR1cm4gMTtcbiAgICAgICAgICBpZiAoYiA9PSBiKSByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwMDE6IC8vIFRoZSByZXN0XG4gICAgICAgIC8vIEhlcmUgd2UgY2FuIGJlIGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgICAgIC8vIDEuIEphdmFTY3JpcHQgcHJpbWl0aXZlIHR5cGVzXG4gICAgICAgIC8vIDIuIEphdmFTY3JpcHQgb2JqZWN0IHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gcHJpbWl0aXZlIHR5cGVzXG4gICAgICAgIC8vIDMuIEphdmFTY3JpcHQgb2JqZWN0IHRoYW4gY2Fubm90IGJlIGNvZXJjZWQgdG8gcHJpbWl0aXZlIHR5cGVzXG4gICAgICAgIC8vXG4gICAgICAgIC8vICgzKSB3aWxsIHJhaXNlIGEgW1R5cGVFcnJvcl1cbiAgICAgICAgLy8gKDIpIHdpbGwgY29lcmNlIHRvIHByaW1pdGl2ZSB0eXBlcyB1c2luZyBbdmFsdWVPZl0gb3IgW3RvU3RyaW5nXVxuICAgICAgICAvLyAoMikgYW5kICgzKSwgYWZ0ZXIgZXZlbnR1YWwgY29lcmNpb25cbiAgICAgICAgLy8gLSBpZiBhIGFuZCBiIGFyZSBzdHJpbmdzLCBhcHBseSBsZXhpY29ncmFwaGljIGNvbXBhcmlzb25cbiAgICAgICAgLy8gLSBpZiBhIG9yIGIgYXJlIG5vdCBzdHJpbmdzLCBjb252ZXJ0IGEgYW5kIGIgdG8gbnVtYmVyXG4gICAgICAgIC8vICAgYW5kIGFwcGx5IHN0YW5kYXJkIGNvbXBhcmlzb25cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRXhjZXB0aW9uOiBgIT1gIHdpbGwgbm90IGNvZXJjZS9jb252ZXJ0IGlmIGJvdGggYSBhbmQgYiBhcmUgb2JqZWN0c1xuICAgICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgIT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgaWYgKGEgPT0gYSkgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKGIgPT0gYikgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjUxOiAvLyBKYXZhU2NyaXB0IFN5bWJvbCwgbm8gb3JkZXJpbmcuXG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjUyOiAvLyBvY2FtbCBzdHJpbmdzXG4gICAgICAgIHZhciBhID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhhKTtcbiAgICAgICAgdmFyIGIgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGIpO1xuICAgICAgICBpZihhICE9PSBiKSB7XG4gICAgICAgICAgaWYoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgICBpZihhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTIwOiAvLyBqYXZhc2NyaXB0IHN0cmluZ3NcbiAgICAgICAgdmFyIGEgPSBhLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBiID0gYi50b1N0cmluZygpO1xuICAgICAgICBpZihhICE9PSBiKSB7XG4gICAgICAgICAgaWYoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgICBpZihhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI0NjogLy8gTGF6eV90YWdcbiAgICAgIGNhc2UgMjU0OiAvLyBEb3VibGVfYXJyYXlcbiAgICAgIGRlZmF1bHQ6IC8vIEJsb2NrIHdpdGggb3RoZXIgdGFnXG4gICAgICAgIGlmKGNhbWxfaXNfY29udGludWF0aW9uX3RhZyh0YWdfYSkpIHtcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBjb250aW51YXRpb24gdmFsdWVcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gKGEubGVuZ3RoIDwgYi5sZW5ndGgpPy0xOjE7XG4gICAgICAgIGlmIChhLmxlbmd0aCA+IDEpIHN0YWNrLnB1c2goYSwgYiwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhY2subGVuZ3RoID09IDApIHJldHVybiAwO1xuICAgIHZhciBpID0gc3RhY2sucG9wKCk7XG4gICAgYiA9IHN0YWNrLnBvcCgpO1xuICAgIGEgPSBzdGFjay5wb3AoKTtcbiAgICBpZiAoaSArIDEgPCBhLmxlbmd0aCkgc3RhY2sucHVzaChhLCBiLCBpICsgMSk7XG4gICAgYSA9IGFbaV07XG4gICAgYiA9IGJbaV07XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9jb21wYXJlIChhLCBiKSB7IHJldHVybiBjYW1sX2NvbXBhcmVfdmFsIChhLCBiLCB0cnVlKTsgfVxuLy9Qcm92aWRlczogY2FtbF9pbnRfY29tcGFyZSBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2ludF9jb21wYXJlIChhLCBiKSB7XG4gIGlmIChhIDwgYikgcmV0dXJuICgtMSk7IGlmIChhID09IGIpIHJldHVybiAwOyByZXR1cm4gMTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9lcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ub3RlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgIT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JlYXRlcmVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcmVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVydGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJ0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3NlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3NlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPD0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc3RoYW4gbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9sZXNzdGhhbiAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPCAwKTsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgbGlicmFyeVxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEpzbGliOiBjb2RlIHNwZWNpZmljIHRvIEpzX29mX29jYW1sXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfb25faWUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfb25faWUgKCkge1xuICB2YXIgdWEgPVxuICAgICAgZ2xvYmFsVGhpcy5uYXZpZ2F0b3I/Z2xvYmFsVGhpcy5uYXZpZ2F0b3IudXNlckFnZW50OlwiXCI7XG4gIHJldHVybiB1YS5pbmRleE9mKFwiTVNJRVwiKSAhPSAtMSAmJiB1YS5pbmRleE9mKFwiT3BlcmFcIikgIT0gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19odG1sX2VzY2FwZSBjb25zdCAoY29uc3QpXG52YXIgY2FtbF9qc19yZWdleHBzID0geyBhbXA6LyYvZywgbHQ6LzwvZywgcXVvdDovXFxcIi9nLCBhbGw6L1smPFxcXCJdLyB9O1xuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VzY2FwZSAocykge1xuICBpZiAoIWNhbWxfanNfcmVnZXhwcy5hbGwudGVzdChzKSkgcmV0dXJuIHM7XG4gIHJldHVybiBzLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmFtcCwgXCImYW1wO1wiKVxuICAgIC5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5sdCwgXCImbHQ7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLnF1b3QsIFwiJnF1b3Q7XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZW50aXRpZXNcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfanNfaHRtbF9lbnRpdGllcyhzKSB7XG4gIHZhciBlbnRpdHkgPSAvXiYjP1swLTlhLXpBLVpdKzskL1xuICBpZihzLm1hdGNoKGVudGl0eSkpXG4gIHtcbiAgICB2YXIgc3RyLCB0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgIHRlbXAuaW5uZXJIVE1MPSBzO1xuICAgIHN0cj0gdGVtcC50ZXh0Q29udGVudCB8fCB0ZW1wLmlubmVyVGV4dDtcbiAgICB0ZW1wPW51bGw7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiSW52YWxpZCBlbnRpdHkgXCIgKyBzKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2dldF9jb25zb2xlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX2dldF9jb25zb2xlICgpIHtcbiAgdmFyIGMgPSBjb25zb2xlO1xuICB2YXIgbSA9IFtcImxvZ1wiLCBcImRlYnVnXCIsIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiLCBcImFzc2VydFwiLCBcImRpclwiLCBcImRpcnhtbFwiLFxuICAgICAgICAgICBcInRyYWNlXCIsIFwiZ3JvdXBcIiwgXCJncm91cENvbGxhcHNlZFwiLCBcImdyb3VwRW5kXCIsIFwidGltZVwiLCBcInRpbWVFbmRcIl07XG4gIGZ1bmN0aW9uIGYgKCkge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSBpZiAoIWNbbVtpXV0pIGNbbVtpXV09ZjtcbiAgcmV0dXJuIGM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1dlYWtkZWZcbmZ1bmN0aW9uIGNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlKHVuaXQpe1xuICBpZih0eXBlb2YgZ2xvYmFsVGhpcy5YTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGdsb2JhbFRoaXMuWE1MSHR0cFJlcXVlc3QgfSBjYXRjaCAoZSkgeyB9O1xuICB9XG4gIGlmKHR5cGVvZiBnbG9iYWxUaGlzLmFjdGl2ZVhPYmplY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLmFjdGl2ZVhPYmplY3QoXCJNc3htbDIuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICAgIHRyeSB7IHJldHVybiBuZXcgZ2xvYmFsVGhpcy5hY3RpdmVYT2JqZWN0KFwiTXN4bWwzLlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGdsb2JhbFRoaXMuYWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gIH1cbiAgY2FtbF9mYWlsd2l0aChcIkNhbm5vdCBjcmVhdGUgYSBYTUxIdHRwUmVxdWVzdFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uKGV4bikge1xuICBpZihleG4uanNfZXJyb3IpIHsgcmV0dXJuIGV4bi5qc19lcnJvcjsgfVxuICByZXR1cm4gbnVsbDtcbn1cbiIsIi8vLy8vLy8vLyBCSUdTVFJJTkdcblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZyhoLCBicykge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCxicy5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciBtdXRhYmxlXG5mdW5jdGlvbiBiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyKGJzKSB7XG4gIHJldHVybiBicy5kYXRhLmJ1ZmZlclxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5KGJzKSB7XG4gIHJldHVybiBicy5kYXRhXG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyKGFiKSB7XG4gIHZhciB0YSA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5KGJhKSB7XG4gIHZhciB0YSA9IG5ldyBVaW50OEFycmF5KGJhLmJ1ZmZlciwgYmEuYnl0ZU9mZnNldCwgYmEubGVuZ3RoICogYmEuQllURVNfUEVSX0VMRU1FTlQpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKDEyLCAwLCBbdGEubGVuZ3RoXSwgdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19tZW1jbXBcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX21lbWNtcChzMSwgcG9zMSwgczIsIHBvczIsIGxlbil7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYSA9IGNhbWxfYmFfZ2V0XzEoczEscG9zMSArIGkpO1xuICAgIHZhciBiID0gY2FtbF9iYV9nZXRfMShzMixwb3MyICsgaSk7XG4gICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhKGJhMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTEua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMxID0gYmExLm9mZnNldChwb3MxKTtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZihvZnMxICsgbGVuID4gYmExLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGJhMS5kYXRhLnN1YmFycmF5KG9mczEsb2ZzMStsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2UscG9zMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhKHN0cjEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZihwb3MxICsgbGVuID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cjEpKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcoc3RyMSkuc2xpY2UocG9zMSxwb3MxICsgbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLG9mczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhKHN0cjEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZihwb3MxICsgbGVuID4gY2FtbF9tbF9ieXRlc19sZW5ndGgoc3RyMSkpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKHN0cjEpLnNsaWNlKHBvczEscG9zMSArIGxlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxvZnMyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzKGJhMSwgcG9zMSwgYnl0ZXMyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTEua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMSA9IGJhMS5vZmZzZXQocG9zMSk7XG4gIGlmKG9mczEgKyBsZW4gPiBiYTEuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihwb3MyICsgbGVuID4gY2FtbF9tbF9ieXRlc19sZW5ndGgoYnl0ZXMyKSl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGJhMS5kYXRhLnNsaWNlKG9mczEsIG9mczErbGVuKTtcbiAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoc2xpY2UpLCAwLCBieXRlczIsIHBvczIsIGxlbik7XG4gIHJldHVybiAwXG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfY2hhblxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfbWxfaW5wdXRfYmxvY2tcbi8vUmVxdWlyZXM6IGNhbWxfTUQ1SW5pdCwgY2FtbF9NRDVVcGRhdGUsIGNhbWxfTUQ1RmluYWxcbmZ1bmN0aW9uIGNhbWxfbWQ1X2NoYW4oY2hhbmlkLHRvcmVhZCl7XG4gIHZhciBjdHggPSBjYW1sX01ENUluaXQoKTtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDQwOTYpO1xuICBpZih0b3JlYWQgPCAwKXtcbiAgICB3aGlsZSh0cnVlKXtcbiAgICAgIHZhciByZWFkID0gY2FtbF9tbF9pbnB1dF9ibG9jayhjaGFuaWQsYnVmZmVyLDAsYnVmZmVyLmxlbmd0aCk7XG4gICAgICBpZihyZWFkID09IDApIGJyZWFrO1xuICAgICAgY2FtbF9NRDVVcGRhdGUoY3R4LGJ1ZmZlci5zdWJhcnJheSgwLCByZWFkKSwgcmVhZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlKHRvcmVhZCA+IDApIHtcbiAgICAgIHZhciByZWFkID0gY2FtbF9tbF9pbnB1dF9ibG9jayhjaGFuaWQsYnVmZmVyLDAsICh0b3JlYWQgPiBidWZmZXIubGVuZ3RoID8gYnVmZmVyLmxlbmd0aCA6IHRvcmVhZCkpO1xuICAgICAgaWYocmVhZCA9PSAwKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gICAgICBjYW1sX01ENVVwZGF0ZShjdHgsYnVmZmVyLnN1YmFycmF5KDAsIHJlYWQpLCByZWFkKTtcbiAgICAgIHRvcmVhZCAtPSByZWFkXG4gICAgfVxuICB9XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheShjYW1sX01ENUZpbmFsKGN0eCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX21kNV9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tZDVfc3RyaW5nKHMsIG9mcywgbGVuKSB7XG4gIHJldHVybiBjYW1sX21kNV9ieXRlcyhjYW1sX2J5dGVzX29mX3N0cmluZyhzKSxvZnMsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9NRDVUcmFuc2Zvcm1cbnZhciBjYW1sX01ENVRyYW5zZm9ybSA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGFkZCAoeCwgeSkgeyByZXR1cm4gKHggKyB5KSB8IDA7IH1cbiAgZnVuY3Rpb24geHgocSxhLGIseCxzLHQpIHtcbiAgICBhID0gYWRkKGFkZChhLCBxKSwgYWRkKHgsIHQpKTtcbiAgICByZXR1cm4gYWRkKChhIDw8IHMpIHwgKGEgPj4+ICgzMiAtIHMpKSwgYik7XG4gIH1cbiAgZnVuY3Rpb24gZmYoYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2coYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gaGgoYSxiLGMsZCx4LHMsdCkgeyByZXR1cm4geHgoYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTsgfVxuICBmdW5jdGlvbiBpaShhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7IH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHcsIGJ1ZmZlcikge1xuICAgIHZhciBhID0gd1swXSwgYiA9IHdbMV0sIGMgPSB3WzJdLCBkID0gd1szXTtcblxuICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbIDBdLCA3LCAweEQ3NkFBNDc4KTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyWyAxXSwgMTIsIDB4RThDN0I3NTYpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbIDJdLCAxNywgMHgyNDIwNzBEQik7XG4gICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlclsgM10sIDIyLCAweEMxQkRDRUVFKTtcbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyWyA0XSwgNywgMHhGNTdDMEZBRik7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlclsgNV0sIDEyLCAweDQ3ODdDNjJBKTtcbiAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyWyA2XSwgMTcsIDB4QTgzMDQ2MTMpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbIDddLCAyMiwgMHhGRDQ2OTUwMSk7XG4gICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlclsgOF0sIDcsIDB4Njk4MDk4RDgpO1xuICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbIDldLCAxMiwgMHg4QjQ0RjdBRik7XG4gICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlclsxMF0sIDE3LCAweEZGRkY1QkIxKTtcbiAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyWzExXSwgMjIsIDB4ODk1Q0Q3QkUpO1xuICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbMTJdLCA3LCAweDZCOTAxMTIyKTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyWzEzXSwgMTIsIDB4RkQ5ODcxOTMpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbMTRdLCAxNywgMHhBNjc5NDM4RSk7XG4gICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlclsxNV0sIDIyLCAweDQ5QjQwODIxKTtcblxuICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbIDFdLCA1LCAweEY2MUUyNTYyKTtcbiAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyWyA2XSwgOSwgMHhDMDQwQjM0MCk7XG4gICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlclsxMV0sIDE0LCAweDI2NUU1QTUxKTtcbiAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyWyAwXSwgMjAsIDB4RTlCNkM3QUEpO1xuICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbIDVdLCA1LCAweEQ2MkYxMDVEKTtcbiAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyWzEwXSwgOSwgMHgwMjQ0MTQ1Myk7XG4gICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlclsxNV0sIDE0LCAweEQ4QTFFNjgxKTtcbiAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyWyA0XSwgMjAsIDB4RTdEM0ZCQzgpO1xuICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbIDldLCA1LCAweDIxRTFDREU2KTtcbiAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyWzE0XSwgOSwgMHhDMzM3MDdENik7XG4gICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlclsgM10sIDE0LCAweEY0RDUwRDg3KTtcbiAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyWyA4XSwgMjAsIDB4NDU1QTE0RUQpO1xuICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbMTNdLCA1LCAweEE5RTNFOTA1KTtcbiAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyWyAyXSwgOSwgMHhGQ0VGQTNGOCk7XG4gICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlclsgN10sIDE0LCAweDY3NkYwMkQ5KTtcbiAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyWzEyXSwgMjAsIDB4OEQyQTRDOEEpO1xuXG4gICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlclsgNV0sIDQsIDB4RkZGQTM5NDIpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbIDhdLCAxMSwgMHg4NzcxRjY4MSk7XG4gICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlclsxMV0sIDE2LCAweDZEOUQ2MTIyKTtcbiAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyWzE0XSwgMjMsIDB4RkRFNTM4MEMpO1xuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbIDFdLCA0LCAweEE0QkVFQTQ0KTtcbiAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyWyA0XSwgMTEsIDB4NEJERUNGQTkpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbIDddLCAxNiwgMHhGNkJCNEI2MCk7XG4gICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlclsxMF0sIDIzLCAweEJFQkZCQzcwKTtcbiAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyWzEzXSwgNCwgMHgyODlCN0VDNik7XG4gICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlclsgMF0sIDExLCAweEVBQTEyN0ZBKTtcbiAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyWyAzXSwgMTYsIDB4RDRFRjMwODUpO1xuICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbIDZdLCAyMywgMHgwNDg4MUQwNSk7XG4gICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlclsgOV0sIDQsIDB4RDlENEQwMzkpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbMTJdLCAxMSwgMHhFNkRCOTlFNSk7XG4gICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlclsxNV0sIDE2LCAweDFGQTI3Q0Y4KTtcbiAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyWyAyXSwgMjMsIDB4QzRBQzU2NjUpO1xuXG4gICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlclsgMF0sIDYsIDB4RjQyOTIyNDQpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbIDddLCAxMCwgMHg0MzJBRkY5Nyk7XG4gICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlclsxNF0sIDE1LCAweEFCOTQyM0E3KTtcbiAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyWyA1XSwgMjEsIDB4RkM5M0EwMzkpO1xuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbMTJdLCA2LCAweDY1NUI1OUMzKTtcbiAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyWyAzXSwgMTAsIDB4OEYwQ0NDOTIpO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbMTBdLCAxNSwgMHhGRkVGRjQ3RCk7XG4gICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlclsgMV0sIDIxLCAweDg1ODQ1REQxKTtcbiAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyWyA4XSwgNiwgMHg2RkE4N0U0Rik7XG4gICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlclsxNV0sIDEwLCAweEZFMkNFNkUwKTtcbiAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyWyA2XSwgMTUsIDB4QTMwMTQzMTQpO1xuICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbMTNdLCAyMSwgMHg0RTA4MTFBMSk7XG4gICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlclsgNF0sIDYsIDB4Rjc1MzdFODIpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbMTFdLCAxMCwgMHhCRDNBRjIzNSk7XG4gICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlclsgMl0sIDE1LCAweDJBRDdEMkJCKTtcbiAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyWyA5XSwgMjEsIDB4RUI4NkQzOTEpO1xuXG4gICAgd1swXSA9IGFkZChhLCB3WzBdKTtcbiAgICB3WzFdID0gYWRkKGIsIHdbMV0pO1xuICAgIHdbMl0gPSBhZGQoYywgd1syXSk7XG4gICAgd1szXSA9IGFkZChkLCB3WzNdKTtcbiAgfX0pKClcblxuLy9Qcm92aWRlczogY2FtbF9NRDVJbml0XG5mdW5jdGlvbiBjYW1sX01ENUluaXQoKSB7XG4gIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoNjQpO1xuICB2YXIgYjMyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gIHZhciBiOCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gIHJldHVybiB7bGVuOjAsXG4gICAgICAgICAgdzpuZXcgVWludDMyQXJyYXkoWzB4Njc0NTIzMDEsIDB4RUZDREFCODksIDB4OThCQURDRkUsIDB4MTAzMjU0NzZdKSxcbiAgICAgICAgICBiMzI6YjMyLFxuICAgICAgICAgIGI4OmI4fVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX01ENVVwZGF0ZVxuLy9SZXF1aXJlczogY2FtbF9NRDVUcmFuc2Zvcm1cbmZ1bmN0aW9uIGNhbWxfTUQ1VXBkYXRlKGN0eCwgaW5wdXQsIGlucHV0X2xlbil7XG4gIHZhciBpbl9idWYgPSBjdHgubGVuICYgMHgzZjtcbiAgdmFyIGlucHV0X3BvcyA9IDA7XG4gIGN0eC5sZW4gKz0gaW5wdXRfbGVuO1xuICBpZihpbl9idWYpe1xuICAgIHZhciBtaXNzaW5nID0gNjQgLSBpbl9idWY7XG4gICAgaWYoaW5wdXRfbGVuIDwgbWlzc2luZykge1xuICAgICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheSgwLGlucHV0X2xlbiksaW5fYnVmKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjdHguYjguc2V0KGlucHV0LnN1YmFycmF5KDAsbWlzc2luZyksaW5fYnVmKTtcbiAgICBjYW1sX01ENVRyYW5zZm9ybShjdHgudywgY3R4LmIzMik7XG4gICAgaW5wdXRfbGVuIC09IG1pc3Npbmc7XG4gICAgaW5wdXRfcG9zICs9IG1pc3Npbmc7XG4gIH1cbiAgd2hpbGUoaW5wdXRfbGVuID49IDY0KXtcbiAgICBjdHguYjguc2V0KGlucHV0LnN1YmFycmF5KGlucHV0X3BvcyxpbnB1dF9wb3MgKyA2NCksIDApO1xuICAgIGNhbWxfTUQ1VHJhbnNmb3JtKGN0eC53LCBjdHguYjMyKTtcbiAgICBpbnB1dF9sZW4gLT0gNjQ7XG4gICAgaW5wdXRfcG9zICs9IDY0O1xuICB9XG4gIGlmKGlucHV0X2xlbilcbiAgICBjdHguYjguc2V0KGlucHV0LnN1YmFycmF5KGlucHV0X3BvcyxpbnB1dF9wb3MgKyBpbnB1dF9sZW4pLCAwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9NRDVGaW5hbFxuLy9SZXF1aXJlczogY2FtbF9NRDVUcmFuc2Zvcm1cbmZ1bmN0aW9uIGNhbWxfTUQ1RmluYWwoY3R4KXtcbiAgdmFyIGluX2J1ZiA9IGN0eC5sZW4gJiAweDNmO1xuICBjdHguYjhbaW5fYnVmXSA9IDB4ODA7XG4gIGluX2J1ZiArKztcbiAgaWYoaW5fYnVmID4gNTYpIHtcbiAgICBmb3IodmFyIGogPSBpbl9idWY7IGogPCA2NDsgaisrKXtcbiAgICAgIGN0eC5iOFtqXSA9IDA7XG4gICAgfVxuICAgIGNhbWxfTUQ1VHJhbnNmb3JtKGN0eC53LCBjdHguYjMyKTtcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgNTY7IGorKyl7XG4gICAgICBjdHguYjhbal0gPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IodmFyIGogPSBpbl9idWY7IGogPCA1NjsgaisrKXtcbiAgICAgIGN0eC5iOFtqXSA9IDA7XG4gICAgfVxuICB9XG4gIGN0eC5iMzJbMTRdID0gY3R4LmxlbiA8PCAzO1xuICBjdHguYjMyWzE1XSA9IChjdHgubGVuID4+IDI5KSAmIDB4MUZGRkZGRkY7XG4gIGNhbWxfTUQ1VHJhbnNmb3JtKGN0eC53LCBjdHguYjMyKTtcbiAgdmFyIHQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgaisrKVxuICAgICAgdFtpICogNCArIGpdID0gKGN0eC53W2ldID4+ICg4ICogaikpICYgMHhGRjtcbiAgcmV0dXJuIHQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX01ENUluaXQsIGNhbWxfTUQ1VXBkYXRlLCBjYW1sX01ENUZpbmFsXG5mdW5jdGlvbiBjYW1sX21kNV9ieXRlcyhzLCBvZnMsIGxlbikge1xuICB2YXIgY3R4ID0gY2FtbF9NRDVJbml0KCk7XG4gIHZhciBhID0gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhzKTtcbiAgY2FtbF9NRDVVcGRhdGUoY3R4LGEuc3ViYXJyYXkob2ZzLCBvZnMgKyBsZW4pLCBsZW4pO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoY2FtbF9NRDVGaW5hbChjdHgpKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAyMCAtIEh1Z28gSGV1emFyZFxuLy8gQ29weXJpZ2h0IChDKSAyMDIwIC0gU2hhY2hhciBJdHpoYWt5XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vb2NhbWwvb2NhbWwvYmxvYi80LjA3L290aGVybGlicy9zdHIvc3Ryc3R1YnMuY1xuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pzY29xL2pzY29xL2Jsb2IvdjguMTEvY29xLWpzL2pzX3N0dWIvc3RyLmpzXG5cbi8vUHJvdmlkZXM6IHJlX21hdGNoXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19nZXRcblxudmFyIHJlX21hdGNoID0gZnVuY3Rpb24oKXtcbiAgdmFyIHJlX3dvcmRfbGV0dGVycyA9IFtcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweDAwLTB4MUY6IG5vbmUgKi9cbiAgICAweDAwLCAweDAwLCAweEZGLCAweDAzLCAgICAgICAvKiAweDIwLTB4M0Y6IGRpZ2l0cyAwLTkgKi9cbiAgICAweEZFLCAweEZGLCAweEZGLCAweDg3LCAgICAgICAvKiAweDQwLTB4NUY6IEEgdG8gWiwgXyAqL1xuICAgIDB4RkUsIDB4RkYsIDB4RkYsIDB4MDcsICAgICAgIC8qIDB4NjAtMHg3RjogYSB0byB6ICovXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHg4MC0weDlGOiBub25lICovXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHhBMC0weEJGOiBub25lICovXG4gICAgMHhGRiwgMHhGRiwgMHg3RiwgMHhGRiwgICAgICAgLyogMHhDMC0weERGOiBMYXRpbi0xIGFjY2VudGVkIHVwcGVyY2FzZSAqL1xuICAgIDB4RkYsIDB4RkYsIDB4N0YsIDB4RkYgICAgICAgIC8qIDB4RTAtMHhGRjogTGF0aW4tMSBhY2NlbnRlZCBsb3dlcmNhc2UgKi9cbiAgXTtcblxuICB2YXIgb3Bjb2RlcyA9IHtcbiAgICBDSEFSOiAwLCBDSEFSTk9STTogMSwgU1RSSU5HOiAyLCBTVFJJTkdOT1JNOiAzLCBDSEFSQ0xBU1M6IDQsXG4gICAgQk9MOiA1LCBFT0w6IDYsIFdPUkRCT1VOREFSWTogNyxcbiAgICBCRUdHUk9VUDogOCwgRU5ER1JPVVA6IDksIFJFRkdST1VQOiAxMCxcbiAgICBBQ0NFUFQ6IDExLFxuICAgIFNJTVBMRU9QVDogMTIsIFNJTVBMRVNUQVI6IDEzLCBTSU1QTEVQTFVTOiAxNCxcbiAgICBHT1RPOiAxNSwgUFVTSEJBQ0s6IDE2LCBTRVRNQVJLOiAxNyxcbiAgICBDSEVDS1BST0dSRVNTOiAxOFxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzX3dvcmRfbGV0dGVyKGMpIHtcbiAgICByZXR1cm4gKHJlX3dvcmRfbGV0dGVyc1sgIChjID4+IDMpXSA+PiAoYyAmIDcpKSAmIDE7XG4gIH1cblxuICBmdW5jdGlvbiBpbl9iaXRzZXQocyxpKSB7XG4gICAgcmV0dXJuIChjYW1sX3N0cmluZ19nZXQocywoaSA+PiAzKSkgPj4gKGkgJiA3KSkgJiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVfbWF0Y2hfaW1wbChyZSwgcywgcG9zLCBwYXJ0aWFsKSB7XG5cbiAgICB2YXIgcHJvZyAgICAgICAgICA9IGNhbWxfanNfZnJvbV9hcnJheShyZVsxXSksXG4gICAgICAgIGNwb29sICAgICAgICAgPSBjYW1sX2pzX2Zyb21fYXJyYXkocmVbMl0pLFxuICAgICAgICBub3JtdGFibGUgICAgID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZVszXSksXG4gICAgICAgIG51bWdyb3VwcyAgICAgPSByZVs0XSB8IDAsXG4gICAgICAgIG51bXJlZ2lzdGVycyAgPSByZVs1XSB8IDAsXG4gICAgICAgIHN0YXJ0Y2hhcnMgICAgPSByZVs2XSB8IDA7XG5cbiAgICB2YXIgcyA9IGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nKHMpO1xuXG4gICAgdmFyIHBjID0gMCxcbiAgICAgICAgcXVpdCA9IGZhbHNlLFxuICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICBncm91cHMgPSBuZXcgQXJyYXkobnVtZ3JvdXBzKSxcbiAgICAgICAgcmVfcmVnaXN0ZXIgPSBuZXcgQXJyYXkobnVtcmVnaXN0ZXJzKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspe1xuICAgICAgZ3JvdXBzW2ldID0ge3N0YXJ0OiAtMSwgZW5kOi0xfVxuICAgIH1cbiAgICBncm91cHNbMF0uc3RhcnQgPSBwb3M7XG5cbiAgICB2YXIgYmFja3RyYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgaXRlbSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoaXRlbS51bmRvKSB7XG4gICAgICAgICAgaXRlbS51bmRvLm9ialtpdGVtLnVuZG8ucHJvcF0gPSBpdGVtLnVuZG8udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihpdGVtLnBvcykge1xuICAgICAgICAgIHBjID0gaXRlbS5wb3MucGM7XG4gICAgICAgICAgcG9zID0gaXRlbS5wb3MudHh0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcXVpdCA9IHRydWU7XG4gICAgfTtcblxuICAgIHZhciBwdXNoID0gZnVuY3Rpb24oaXRlbSkgeyBzdGFjay5wdXNoKGl0ZW0pOyB9O1xuXG4gICAgdmFyIGFjY2VwdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGdyb3Vwc1swXS5lbmQgPSBwb3M7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KDEgKyBncm91cHMubGVuZ3RoKjIpO1xuICAgICAgcmVzdWx0WzBdID0gMDsgLy8gdGFnXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGcgPSBncm91cHNbaV07XG4gICAgICAgIGlmKGcuc3RhcnQgPCAwIHx8IGcuZW5kIDwgMCkge1xuICAgICAgICAgIGcuc3RhcnQgPSBnLmVuZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFsyKmkgKyAxIF0gPSBnLnN0YXJ0O1xuICAgICAgICByZXN1bHRbMippICsgMSArIDEgXSA9IGcuZW5kO1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgdmFyIHByZWZpeF9tYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmKHBhcnRpYWwpIHJldHVybiBhY2NlcHQgKCk7XG4gICAgICBlbHNlIGJhY2t0cmFjayAoKTtcbiAgICB9XG5cbiAgICAvKiBNYWluIERGQSBpbnRlcnByZXRlciBsb29wICovXG4gICAgd2hpbGUgKCFxdWl0KSB7XG4gICAgICB2YXIgb3AgPSBwcm9nW3BjXSAmIDB4ZmYsXG4gICAgICAgICAgc2FyZyA9IHByb2dbcGNdID4+IDgsXG4gICAgICAgICAgdWFyZyA9IHNhcmcgJiAweGZmLFxuICAgICAgICAgIGMgPSBzW3Bvc10sXG4gICAgICAgICAgZ3JvdXA7XG5cbiAgICAgIHBjKys7XG5cbiAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChjID09PSB1YXJnKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUk5PUk06XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSB1YXJnKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU1RSSU5HOlxuICAgICAgICBmb3IgKHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYgKGMgPT09IGFyZy5jaGFyQ29kZUF0KGkpKVxuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIGVsc2UgeyBiYWNrdHJhY2soKTsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TVFJJTkdOT1JNOlxuICAgICAgICBmb3IgKHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSBhcmcuY2hhckNvZGVBdChpKSlcbiAgICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICBlbHNlIHsgYmFja3RyYWNrKCk7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUkNMQVNTOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQk9MOlxuICAgICAgICBpZihwb3MgPiAwICYmIHNbcG9zIC0gMV0gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkVPTDpcbiAgICAgICAgaWYocG9zIDwgcy5sZW5ndGggJiYgc1twb3NdICE9IDEwIC8qIFxcbiAqLykge2JhY2t0cmFjaygpfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5XT1JEQk9VTkRBUlk6XG4gICAgICAgIGlmKHBvcyA9PSAwKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbMF0pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3MgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1twb3MgLSAxXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSAhPSBpc193b3JkX2xldHRlcihzW3Bvc10pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2sgKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQkVHR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOmdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdyb3VwLnN0YXJ0fX0pO1xuICAgICAgICBncm91cC5zdGFydCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU5ER1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOiBncm91cCxcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6J2VuZCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuZW5kfX0pO1xuICAgICAgICBncm91cC5lbmQgPSBwb3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlJFRkdST1VQOlxuICAgICAgICBncm91cCA9IGdyb3Vwc1t1YXJnXTtcbiAgICAgICAgaWYoZ3JvdXAuc3RhcnQgPCAwIHx8IGdyb3VwLmVuZCA8IDApIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICBmb3IgKHZhciBpID0gZ3JvdXAuc3RhcnQ7IGkgPCBncm91cC5lbmQ7IGkrKyl7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmKHNbaV0gIT0gc1twb3NdKSB7YmFja3RyYWNrICgpOyBicmVha31cbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVPUFQ6XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0lNUExFU1RBUjpcbiAgICAgICAgd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpXG4gICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVQTFVTOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIH0gd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkFDQ0VQVDpcbiAgICAgICAgcmV0dXJuIGFjY2VwdCgpO1xuICAgICAgY2FzZSBvcGNvZGVzLkdPVE86XG4gICAgICAgIHBjID0gcGMgKyBzYXJnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5QVVNIQkFDSzpcbiAgICAgICAgcHVzaCh7cG9zOiB7cGM6IHBjICsgc2FyZywgdHh0OiBwb3N9fSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNFVE1BUks6XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6cmVfcmVnaXN0ZXIsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOiB1YXJnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlX3JlZ2lzdGVyW3VhcmddfX0pO1xuICAgICAgICByZV9yZWdpc3Rlclt1YXJnXSA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hFQ0tQUk9HUkVTUzpcbiAgICAgICAgaWYgKHJlX3JlZ2lzdGVyW3VhcmddID09PSBwb3MpIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnl0ZWNvZGVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHJlX21hdGNoX2ltcGw7XG59KCk7XG5cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2ZvcndhcmRcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc2VhcmNoX2ZvcndhcmQocmUsIHMsIHBvcykge1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2ZvcndhcmRcIilcbiAgd2hpbGUgKHBvcyA8PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIHtcbiAgICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gICAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgICBwb3MrKztcbiAgfVxuXG4gIHJldHVybiBbMF07ICAvKiBbfHxdIDogaW50IGFycmF5ICovXG59XG5cbi8vUHJvdmlkZXM6IHJlX3NlYXJjaF9iYWNrd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfYmFja3dhcmQocmUsIHMsIHBvcykge1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2JhY2t3YXJkXCIpXG4gIHdoaWxlIChwb3MgPj0gMCkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcy0tO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuXG4vL1Byb3ZpZGVzOiByZV9zdHJpbmdfbWF0Y2hcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc3RyaW5nX21hdGNoKHJlLHMscG9zKXtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnN0cmluZ19tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcGFydGlhbF9tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9wYXJ0aWFsX21hdGNoKHJlLHMscG9zKXtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnBhcnRpYWxfbWF0Y2hcIilcbiAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDEpO1xuICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICBlbHNlIHJldHVybiBbMF07XG59XG5cbi8vUHJvdmlkZXM6IHJlX3JlcGxhY2VtZW50X3RleHRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vLyBleHRlcm5hbCByZV9yZXBsYWNlbWVudF90ZXh0OiBzdHJpbmcgLT4gaW50IGFycmF5IC0+IHN0cmluZyAtPiBzdHJpbmdcbmZ1bmN0aW9uIHJlX3JlcGxhY2VtZW50X3RleHQocmVwbCxncm91cHMsb3JpZykge1xuICB2YXIgcmVwbCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocmVwbCk7XG4gIHZhciBsZW4gPSByZXBsLmxlbmd0aDtcbiAgdmFyIG9yaWcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9yaWcpO1xuICB2YXIgcmVzID0gXCJcIjsgLy9yZXN1bHRcbiAgdmFyIG4gPSAwOyAvLyBjdXJyZW50IHBvc2l0aW9uXG4gIHZhciBjdXI7IC8vY3VycmVudCBjaGFyXG4gIHZhciBzdGFydCwgZW5kLCBjO1xuICB3aGlsZShuIDwgbGVuKXtcbiAgICBjdXIgPSByZXBsLmNoYXJBdChuKyspO1xuICAgIGlmKGN1ciAhPSAnXFxcXCcpe1xuICAgICAgcmVzICs9IGN1cjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZihuID09IGxlbikgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiBpbGxlZ2FsIGJhY2tzbGFzaCBzZXF1ZW5jZVwiKTtcbiAgICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgICBzd2l0Y2goY3VyKXtcbiAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICByZXMgKz0gY3VyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzAnOiBjYXNlICcxJzogY2FzZSAnMic6IGNhc2UgJzMnOiBjYXNlICc0JzpcbiAgICAgIGNhc2UgJzUnOiBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgICAgYyA9ICtjdXI7XG4gICAgICAgIGlmIChjKjIgPj0gZ3JvdXBzLmxlbmd0aCAtIDEgKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogcmVmZXJlbmNlIHRvIHVubWF0Y2hlZCBncm91cFwiICk7XG4gICAgICAgIHN0YXJ0ID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLGMqMik7XG4gICAgICAgIGVuZCA9IGNhbWxfYXJyYXlfZ2V0KGdyb3VwcywgYyoyICsxKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09IC0xKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogcmVmZXJlbmNlIHRvIHVubWF0Y2hlZCBncm91cFwiKTtcbiAgICAgICAgcmVzKz1vcmlnLnNsaWNlKHN0YXJ0LGVuZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzICs9ICgnXFxcXCcgICsgY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocmVzKTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyX2luaXRpYWxpemVcbmZ1bmN0aW9uIGNhbWxfc3RyX2luaXRpYWxpemUodW5pdCkge1xuICByZXR1cm4gMDtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBsZXhpbmcuYyA2MDQ1IDIwMDQtMDEtMDEgMTY6NDI6NDNaIGRvbGlnZXogJCAqL1xuXG4vKiBUaGUgdGFibGUtZHJpdmVuIGF1dG9tYXRvbiBmb3IgbGV4ZXJzIGdlbmVyYXRlZCBieSBjYW1sbGV4LiAqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9sZXhfYXJyYXkocykge1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTtcbiAgdmFyIGwgPSBzLmxlbmd0aCAvIDI7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKylcbiAgICBhW2ldID0gKHMuY2hhckNvZGVBdCgyICogaSkgfCAocy5jaGFyQ29kZUF0KDIgKiBpICsgMSkgPDwgOCkpIDw8IDE2ID4+IDE2O1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheSwgY2FtbF91aW50OF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9sZXhfZW5naW5lKHRibCwgc3RhcnRfc3RhdGUsIGxleGJ1Zikge1xuICB2YXIgbGV4X2J1ZmZlciA9IDI7XG4gIHZhciBsZXhfYnVmZmVyX2xlbiA9IDM7XG4gIHZhciBsZXhfc3RhcnRfcG9zID0gNTtcbiAgdmFyIGxleF9jdXJyX3BvcyA9IDY7XG4gIHZhciBsZXhfbGFzdF9wb3MgPSA3O1xuICB2YXIgbGV4X2xhc3RfYWN0aW9uID0gODtcbiAgdmFyIGxleF9lb2ZfcmVhY2hlZCA9IDk7XG4gIHZhciBsZXhfYmFzZSA9IDE7XG4gIHZhciBsZXhfYmFja3RyayA9IDI7XG4gIHZhciBsZXhfZGVmYXVsdCA9IDM7XG4gIHZhciBsZXhfdHJhbnMgPSA0O1xuICB2YXIgbGV4X2NoZWNrID0gNTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrXSk7XG4gICAgdGJsLmxleF9jaGVjayA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tdKTtcbiAgICB0YmwubGV4X3RyYW5zID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc10pO1xuICAgIHRibC5sZXhfZGVmYXVsdCA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuXG4gIHZhciBjLCBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKGxleGJ1ZltsZXhfYnVmZmVyXSk7XG5cbiAgaWYgKHN0YXRlID49IDApIHtcbiAgICAvKiBGaXJzdCBlbnRyeSAqL1xuICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9zdGFydF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICAvKiBSZWVudHJ5IGFmdGVyIHJlZmlsbCAqL1xuICAgIHN0YXRlID0gLXN0YXRlIC0gMTtcbiAgfVxuICBmb3IoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSByZXR1cm4gLWJhc2UtMTtcbiAgICAvKiBTZWUgaWYgaXQncyBhIGJhY2t0cmFjayBwb2ludCAqL1xuICAgIHZhciBiYWNrdHJrID0gdGJsLmxleF9iYWNrdHJrW3N0YXRlXTtcbiAgICBpZiAoYmFja3RyayA+PSAwKSB7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIGlmICh0YmwubGV4X2NoZWNrW2Jhc2UgKyBjXSA9PSBzdGF0ZSlcbiAgICAgIHN0YXRlID0gdGJsLmxleF90cmFuc1tiYXNlICsgY107XG4gICAgZWxzZVxuICAgICAgc3RhdGUgPSB0YmwubGV4X2RlZmF1bHRbc3RhdGVdO1xuICAgIC8qIElmIG5vIHRyYW5zaXRpb24gb24gdGhpcyBjaGFyLCByZXR1cm4gdG8gbGFzdCBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICBpZiAoc3RhdGUgPCAwKSB7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSA9IGxleGJ1ZltsZXhfbGFzdF9wb3NdO1xuICAgICAgaWYgKGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID09IC0xKVxuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwibGV4aW5nOiBlbXB0eSB0b2tlblwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dO1xuICAgIH1lbHNle1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAqL1xuICAgICAgaWYgKGMgPT0gMjU2KSBsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9IDA7XG4gICAgfVxuICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIE5ldyBsZXhlciBlbmdpbmUsIHdpdGggbWVtb3J5IG9mIHBvc2l0aW9ucyAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy9Qcm92aWRlczogY2FtbF9uZXdfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl9tZW0ocywgaSwgbWVtLCBjdXJyX3Bvcykge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChkc3QgPT0gMHhmZikgcmV0dXJuO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoc3JjID09IDB4ZmYpXG4gICAgICBtZW0gW2RzdCArIDFdID0gY3Vycl9wb3M7XG4gICAgZWxzZVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IG1lbSBbc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9sZXhfcnVuX3RhZyhzLCBpLCBtZW0pIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoZHN0ID09IDB4ZmYpIHJldHVybiA7XG4gICAgdmFyIHNyYyA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChzcmMgPT0gMHhmZilcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSAtMTtcbiAgICBlbHNlXG4gICAgICBtZW0gW2RzdCArIDFdID0gbWVtIFtzcmMgKyAxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1sX25ld19sZXhfZW5naW5lKHRibCwgc3RhcnRfc3RhdGUsIGxleGJ1Zikge1xuICB2YXIgbGV4X2J1ZmZlciA9IDI7XG4gIHZhciBsZXhfYnVmZmVyX2xlbiA9IDM7XG4gIHZhciBsZXhfc3RhcnRfcG9zID0gNTtcbiAgdmFyIGxleF9jdXJyX3BvcyA9IDY7XG4gIHZhciBsZXhfbGFzdF9wb3MgPSA3O1xuICB2YXIgbGV4X2xhc3RfYWN0aW9uID0gODtcbiAgdmFyIGxleF9lb2ZfcmVhY2hlZCA9IDk7XG4gIHZhciBsZXhfbWVtID0gMTA7XG4gIHZhciBsZXhfYmFzZSA9IDE7XG4gIHZhciBsZXhfYmFja3RyayA9IDI7XG4gIHZhciBsZXhfZGVmYXVsdCA9IDM7XG4gIHZhciBsZXhfdHJhbnMgPSA0O1xuICB2YXIgbGV4X2NoZWNrID0gNTtcbiAgdmFyIGxleF9iYXNlX2NvZGUgPSA2O1xuICB2YXIgbGV4X2JhY2t0cmtfY29kZSA9IDc7XG4gIHZhciBsZXhfZGVmYXVsdF9jb2RlID0gODtcbiAgdmFyIGxleF90cmFuc19jb2RlID0gOTtcbiAgdmFyIGxleF9jaGVja19jb2RlID0gMTA7XG4gIHZhciBsZXhfY29kZSA9IDExO1xuXG4gIGlmICghdGJsLmxleF9kZWZhdWx0KSB7XG4gICAgdGJsLmxleF9iYXNlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF0pO1xuICB9XG4gIGlmICghdGJsLmxleF9kZWZhdWx0X2NvZGUpIHtcbiAgICB0YmwubGV4X2Jhc2VfY29kZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VfY29kZV0pO1xuICAgIHRibC5sZXhfYmFja3Rya19jb2RlID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya19jb2RlXSk7XG4gICAgdGJsLmxleF9jaGVja19jb2RlID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja19jb2RlXSk7XG4gICAgdGJsLmxleF90cmFuc19jb2RlID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc19jb2RlXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0X2NvZGUgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0X2NvZGVdKTtcbiAgfVxuICBpZiAodGJsLmxleF9jb2RlID09IG51bGwpIHRibC5sZXhfY29kZSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcodGJsW2xleF9jb2RlXSk7XG5cbiAgdmFyIGMsIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMobGV4YnVmW2xleF9idWZmZXJdKTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvcig7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHtcbiAgICAgIHZhciBwY19vZmYgPSB0YmwubGV4X2Jhc2VfY29kZVtzdGF0ZV07XG4gICAgICBjYW1sX2xleF9ydW5fdGFnKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0pO1xuICAgICAgcmV0dXJuIC1iYXNlLTE7XG4gICAgfVxuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIHZhciBwY19vZmYgPSB0YmwubGV4X2JhY2t0cmtfY29kZVtzdGF0ZV07XG4gICAgICBjYW1sX2xleF9ydW5fdGFnKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0pO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gYmFja3RyaztcbiAgICB9XG4gICAgLyogU2VlIGlmIHdlIG5lZWQgYSByZWZpbGwgKi9cbiAgICBpZiAobGV4YnVmW2xleF9jdXJyX3Bvc10gPj0gbGV4YnVmW2xleF9idWZmZXJfbGVuXSl7XG4gICAgICBpZiAobGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPT0gMClcbiAgICAgICAgcmV0dXJuIC1zdGF0ZSAtIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGMgPSAyNTY7XG4gICAgfWVsc2V7XG4gICAgICAvKiBSZWFkIG5leHQgaW5wdXQgY2hhciAqL1xuICAgICAgYyA9IGJ1ZmZlcltsZXhidWZbbGV4X2N1cnJfcG9zXV07XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSArKztcbiAgICB9XG4gICAgLyogRGV0ZXJtaW5lIG5leHQgc3RhdGUgKi9cbiAgICB2YXIgcHN0YXRlID0gc3RhdGUgO1xuICAgIGlmICh0YmwubGV4X2NoZWNrW2Jhc2UgKyBjXSA9PSBzdGF0ZSlcbiAgICAgIHN0YXRlID0gdGJsLmxleF90cmFuc1tiYXNlICsgY107XG4gICAgZWxzZVxuICAgICAgc3RhdGUgPSB0YmwubGV4X2RlZmF1bHRbc3RhdGVdO1xuICAgIC8qIElmIG5vIHRyYW5zaXRpb24gb24gdGhpcyBjaGFyLCByZXR1cm4gdG8gbGFzdCBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICBpZiAoc3RhdGUgPCAwKSB7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSA9IGxleGJ1ZltsZXhfbGFzdF9wb3NdO1xuICAgICAgaWYgKGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID09IC0xKVxuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwibGV4aW5nOiBlbXB0eSB0b2tlblwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dO1xuICAgIH1lbHNle1xuICAgICAgLyogSWYgc29tZSB0cmFuc2l0aW9uLCBnZXQgYW5kIHBlcmZvcm0gbWVtb3J5IG1vdmVzICovXG4gICAgICB2YXIgYmFzZV9jb2RlID0gdGJsLmxleF9iYXNlX2NvZGVbcHN0YXRlXSwgcGNfb2ZmO1xuICAgICAgaWYgKHRibC5sZXhfY2hlY2tfY29kZVtiYXNlX2NvZGUgKyBjXSA9PSBwc3RhdGUpXG4gICAgICAgIHBjX29mZiA9IHRibC5sZXhfdHJhbnNfY29kZVtiYXNlX2NvZGUgKyBjXTtcbiAgICAgIGVsc2VcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF9kZWZhdWx0X2NvZGVbcHN0YXRlXTtcbiAgICAgIGlmIChwY19vZmYgPiAwKVxuICAgICAgICBjYW1sX2xleF9ydW5fbWVtXG4gICAgICAodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSwgbGV4YnVmW2xleF9jdXJyX3Bvc10pO1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAqL1xuICAgICAgaWYgKGMgPT0gMjU2KSBsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9IDA7XG4gICAgfVxuICB9XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEFycmF5XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfc3ViIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfc3ViIChhLCBpLCBsZW4pIHtcbiAgdmFyIGEyID0gbmV3IEFycmF5KGxlbisxKTtcbiAgYTJbMF09MDtcbiAgZm9yKHZhciBpMiA9IDEsIGkxPSBpKzE7IGkyIDw9IGxlbjsgaTIrKyxpMSsrICl7XG4gICAgYTJbaTJdPWFbaTFdO1xuICB9XG4gIHJldHVybiBhMjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9hcHBlbmQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9hcHBlbmQoYTEsIGEyKSB7XG4gIHZhciBsMSA9IGExLmxlbmd0aCwgbDIgPSBhMi5sZW5ndGg7XG4gIHZhciBsID0gbDErbDItMVxuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IDA7XG4gIHZhciBpID0gMSxqID0gMTtcbiAgZm9yKDtpPGwxO2krKykgYVtpXT1hMVtpXTtcbiAgZm9yKDtpPGw7aSsrLGorKykgYVtpXT1hMltqXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfY29uY2F0IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfY29uY2F0KGwpIHtcbiAgdmFyIGEgPSBbMF07XG4gIHdoaWxlIChsICE9PSAwKSB7XG4gICAgdmFyIGIgPSBsWzFdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYi5sZW5ndGg7IGkrKykgYS5wdXNoKGJbaV0pO1xuICAgIGwgPSBsWzJdO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JsaXRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKSB7XG4gIGlmIChpMiA8PSBpMSkge1xuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IGxlbjsgaisrKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBqID0gbGVuOyBqID49IDE7IGotLSkgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfYmxpdFxuZnVuY3Rpb24gY2FtbF9mbG9hdGFycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICBpZiAoaTIgPD0gaTEpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBsZW47IGorKykgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAxOyBqLS0pIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9O1xuICByZXR1cm4gMDtcbn1cblxuLy8vLy8vLy8vLy8vLyBQZXJ2YXNpdmVcbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfc2V0IChtdXRhYmxlLCBjb25zdCwgbXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfc2V0IChhcnJheSwgaW5kZXgsIG5ld3ZhbCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGFycmF5W2luZGV4KzFdPW5ld3ZhbDsgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfZ2V0IG11dGFibGUgKG11dGFibGUsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9nZXQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheVtpbmRleCsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9maWxsXG5mdW5jdGlvbiBjYW1sX2FycmF5X2ZpbGwoYXJyYXksIG9mcywgbGVuLCB2KXtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBhcnJheVtvZnMraSsxXSA9IHY7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hlY2tfYm91bmQgKG11dGFibGUsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9jaGVja19ib3VuZCAoYXJyYXksIGluZGV4KSB7XG4gIGlmIChpbmRleCA+Pj4gMCA+PSBhcnJheS5sZW5ndGggLSAxKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3ZlY3QgY29uc3QgKGNvbnN0LCBtdXRhYmxlKVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9tYWtlX3ZlY3QgKGxlbiwgaW5pdCkge1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IGluaXQ7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfZmxvYXRfdmVjdCBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21ha2VfZmxvYXRfdmVjdChsZW4pe1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MjU0O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gMDtcbiAgcmV0dXJuIGJcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRhcnJheV9jcmVhdGUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9mbG9hdGFycmF5X2NyZWF0ZShsZW4pe1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MjU0O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gMDtcbiAgcmV0dXJuIGJcbn1cbiIsIi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX2Rsc1xudmFyIGNhbWxfZG9tYWluX2RscyA9IFswXTtcblxuLy9Qcm92aWRlczogY2FtbF9kb21haW5fZGxzX3NldFxuLy9SZXF1aXJlczogY2FtbF9kb21haW5fZGxzXG5mdW5jdGlvbiBjYW1sX2RvbWFpbl9kbHNfc2V0KGEpIHtcbiAgY2FtbF9kb21haW5fZGxzID0gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9kb21haW5fZGxzX2dldFxuLy9SZXF1aXJlczogY2FtbF9kb21haW5fZGxzXG5mdW5jdGlvbiBjYW1sX2RvbWFpbl9kbHNfZ2V0KHVuaXQpIHtcbiAgcmV0dXJuIGNhbWxfZG9tYWluX2Rscztcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2F0b21pY19sb2FkXG5mdW5jdGlvbiBjYW1sX2F0b21pY19sb2FkKHJlZil7XG4gIHJldHVybiByZWZbMV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXRvbWljX2Nhc1xuZnVuY3Rpb24gY2FtbF9hdG9taWNfY2FzKHJlZixvLG4pIHtcbiAgaWYocmVmWzFdID09PSBvKXtcbiAgICByZWZbMV0gPSBuO1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2F0b21pY19mZXRjaF9hZGRcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX2ZldGNoX2FkZChyZWYsIGkpIHtcbiAgdmFyIG9sZCA9IHJlZlsxXTtcbiAgcmVmWzFdICs9IGk7XG4gIHJldHVybiBvbGQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXRvbWljX2V4Y2hhbmdlXG5mdW5jdGlvbiBjYW1sX2F0b21pY19leGNoYW5nZShyZWYsIHYpIHtcbiAgdmFyIHIgPSByZWZbMV07XG4gIHJlZlsxXSA9IHY7XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RvbWFpbl91bmlxdWVfdG9rZW5cbnZhciBjYW1sX21sX2RvbWFpbl91bmlxdWVfdG9rZW5fID0gWzBdXG5mdW5jdGlvbiBjYW1sX21sX2RvbWFpbl91bmlxdWVfdG9rZW4odW5pdCkge1xuICByZXR1cm4gY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuX1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZG9tYWluX3NldF9uYW1lXG5mdW5jdGlvbiBjYW1sX21sX2RvbWFpbl9zZXRfbmFtZShfbmFtZSkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWNvbW1lbmRlZF9kb21haW5fY291bnRcbmZ1bmN0aW9uIGNhbWxfcmVjb21tZW5kZWRfZG9tYWluX2NvdW50KHVuaXQpIHsgcmV0dXJuIDEgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX2lkXG52YXIgY2FtbF9kb21haW5faWQgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9zcGF3blxuLy9SZXF1aXJlczogY2FtbF9tbF9tdXRleF91bmxvY2tcbi8vUmVxdWlyZXM6IGNhbWxfZG9tYWluX2lkXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG52YXIgY2FtbF9kb21haW5fbGF0ZXN0X2lkeCA9IDFcbmZ1bmN0aW9uIGNhbWxfZG9tYWluX3NwYXduKGYsbXV0ZXgpe1xuICAgIHZhciBpZCA9IGNhbWxfZG9tYWluX2xhdGVzdF9pZHgrKztcbiAgICB2YXIgb2xkID0gY2FtbF9kb21haW5faWQ7XG4gICAgY2FtbF9kb21haW5faWQgPSBpZDtcbiAgICBjYW1sX2NhbGxiYWNrKGYsWzBdKTtcbiAgICBjYW1sX2RvbWFpbl9pZCA9IG9sZDtcbiAgICBjYW1sX21sX211dGV4X3VubG9jayhtdXRleCk7XG4gICAgcmV0dXJuIGlkO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZG9tYWluX2lkXG4vL1JlcXVpcmVzOiBjYW1sX2RvbWFpbl9pZFxuZnVuY3Rpb24gY2FtbF9tbF9kb21haW5faWQodW5pdCl7XG4gICAgcmV0dXJuIGNhbWxfZG9tYWluX2lkO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZG9tYWluX2NwdV9yZWxheFxuZnVuY3Rpb24gY2FtbF9tbF9kb21haW5fY3B1X3JlbGF4KHVuaXQpe1xuICAgIHJldHVybiAwO1xufVxuIiwiXG4vL1Byb3ZpZGVzOiBNbE11dGV4XG5mdW5jdGlvbiBNbE11dGV4KCkge1xuICB0aGlzLmxvY2tlZCA9IGZhbHNlXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbXV0ZXhfbmV3XG4vL1JlcXVpcmVzOiBNbE11dGV4XG5mdW5jdGlvbiBjYW1sX21sX211dGV4X25ldyh1bml0KSB7XG4gIHJldHVybiBuZXcgTWxNdXRleCgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX211dGV4X2xvY2tcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfbWxfbXV0ZXhfbG9jayh0KSB7XG4gIGlmKHQubG9ja2VkKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJNdXRleC5sb2NrOiBtdXRleCBhbHJlYWR5IGxvY2tlZC4gQ2Fubm90IHdhaXQuXCIpO1xuICBlbHNlIHQubG9ja2VkID0gdHJ1ZTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbXV0ZXhfdHJ5X2xvY2tcbmZ1bmN0aW9uIGNhbWxfbWxfbXV0ZXhfdHJ5X2xvY2sodCkge1xuICBpZighdC5sb2NrZWQpIHtcbiAgICB0LmxvY2tlZCA9IHRydWU7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbXV0ZXhfdW5sb2NrXG5mdW5jdGlvbiBjYW1sX21sX211dGV4X3VubG9jayh0KSB7XG4gIHQubG9ja2VkID0gZmFsc2U7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIFdlYWsgQVBJXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG52YXIgY2FtbF9lcGhlX2tleV9vZmZzZXQgPSAzXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxudmFyIGNhbWxfZXBoZV9kYXRhX29mZnNldCA9IDJcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfa2V5KHgsIGksIHYpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLnNldFwiKTtcbiAgaWYgKHYgaW5zdGFuY2VvZiBPYmplY3QgJiYgZ2xvYmFsVGhpcy5XZWFrUmVmKSB7XG4gICAgaWYoeFsxXS5yZWdpc3RlcikgeFsxXS5yZWdpc3Rlcih2LCB1bmRlZmluZWQsIHYpO1xuICAgIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IG5ldyBnbG9iYWxUaGlzLldlYWtSZWYodik7XG4gIH1cbiAgZWxzZSB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSB2O1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfa2V5KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLnNldFwiKTtcbiAgaWYoZ2xvYmFsVGhpcy5XZWFrUmVmICYmIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZiAmJiB4WzFdLnVucmVnaXN0ZXIpIHtcbiAgICB2YXIgb2xkID0geFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldLmRlcmVmKCk7XG4gICAgaWYob2xkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjb3VudCA9IDBcbiAgICAgIGZvcih2YXIgaiA9IGNhbWxfZXBoZV9rZXlfb2Zmc2V0OyBqIDwgeC5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBrZXkgPSB4W2pdO1xuICAgICAgICBpZihrZXkgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLldlYWtSZWYpe1xuICAgICAgICAgIGtleSA9IGtleS5kZXJlZigpXG4gICAgICAgICAgaWYoa2V5ID09PSBvbGQpIGNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKGNvdW50ID09IDEpIHhbMV0udW5yZWdpc3RlcihvbGQpO1xuICAgIH1cbiAgfVxuICB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSB1bmRlZmluZWQ7XG4gIHJldHVybiAwXG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NyZWF0ZSwgY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfY3JlYXRlIChuKSB7XG4gIHZhciB4ID0gY2FtbF93ZWFrX2NyZWF0ZShuKTtcbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnQsY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX3dlYWtfY3JlYXRlIChuKSB7XG4gIGlmIChuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuY3JlYXRlXCIpO1xuICB2YXIgeCA9IFsyNTEsXCJjYW1sX2VwaGVfbGlzdF9oZWFkXCJdO1xuICB4Lmxlbmd0aCA9IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgbjtcbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX3NldF9rZXksIGNhbWxfZXBoZV91bnNldF9rZXlcbmZ1bmN0aW9uIGNhbWxfd2Vha19zZXQoeCwgaSwgdikge1xuICBpZih2ID09IDApIGNhbWxfZXBoZV91bnNldF9rZXkoeCxpKVxuICBlbHNlIGNhbWxfZXBoZV9zZXRfa2V5KHgsaSx2WzFdKVxuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0FsaWFzOiBjYW1sX3dlYWtfZ2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2tleSh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfa2V5XCIpO1xuICB2YXIgd2VhayA9IHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpIF07XG4gIGlmKGdsb2JhbFRoaXMuV2Vha1JlZiAmJiB3ZWFrIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWFrUmVmKSB3ZWFrID0gd2Vhay5kZXJlZigpO1xuICByZXR1cm4gKHdlYWs9PT11bmRlZmluZWQpPzA6WzAsIHdlYWtdO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlfY29weVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2dldF9rZXksY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0FsaWFzOiBjYW1sX3dlYWtfZ2V0X2NvcHlcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfa2V5X2NvcHkoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuZ2V0X2NvcHlcIik7XG4gIHZhciB5ID0gY2FtbF9lcGhlX2dldF9rZXkoeCwgaSk7XG4gIGlmICh5ID09PSAwKSByZXR1cm4geTtcbiAgdmFyIHogPSB5WzFdO1xuICBpZiAoeiBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh6KV07XG4gIHJldHVybiB5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfa2V5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL0FsaWFzOiBjYW1sX3dlYWtfY2hlY2tcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jaGVja19rZXkoeCwgaSkge1xuICB2YXIgd2VhayA9IHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXTtcbiAgaWYoZ2xvYmFsVGhpcy5XZWFrUmVmICYmIHdlYWsgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLldlYWtSZWYpIHdlYWsgPSB3ZWFrLmRlcmVmKCk7XG4gIGlmKHdlYWs9PT11bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL0FsaWFzOiBjYW1sX3dlYWtfYmxpdFxuZnVuY3Rpb24gY2FtbF9lcGhlX2JsaXRfa2V5KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgLy8gbWludXMgb25lIGJlY2F1c2UgY2FtbF9hcnJheV9ibGl0IHdvcmtzIG9uIG9jYW1sIGFycmF5XG4gIGNhbWxfYXJyYXlfYmxpdChhMSwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMSAtIDEsXG4gICAgICAgICAgICAgICAgICBhMiwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMiAtIDEsXG4gICAgICAgICAgICAgICAgICBsZW4pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0LCBjYW1sX2VwaGVfc2V0X2RhdGEsIGNhbWxfZXBoZV91bnNldF9kYXRhXG5mdW5jdGlvbiBjYW1sX2VwaGVfYmxpdF9kYXRhKHNyYywgZHN0KXtcbiAgdmFyIG4gPSBzcmNbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XTtcbiAgaWYobiA9PT0gdW5kZWZpbmVkKSBjYW1sX2VwaGVfdW5zZXRfZGF0YShkc3QpO1xuICBlbHNlIGNhbWxfZXBoZV9zZXRfZGF0YShkc3QsIG4pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cFxuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdKV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0LCBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfZGF0YSh4LCBkYXRhKXtcbiAgaWYoZ2xvYmFsVGhpcy5GaW5hbGl6YXRpb25SZWdpc3RyeSAmJiBnbG9iYWxUaGlzLldlYWtSZWYpIHtcbiAgICBpZighICh4WzFdIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5GaW5hbGl6YXRpb25SZWdpc3RyeSkpIHtcbiAgICAgIHhbMV0gPSBuZXcgZ2xvYmFsVGhpcy5GaW5hbGl6YXRpb25SZWdpc3RyeShmdW5jdGlvbiAoKSB7IGNhbWxfZXBoZV91bnNldF9kYXRhKHgpIH0pO1xuICAgICAgLy9yZWdpc3RlciBhbGwga2V5c1xuICAgICAgZm9yKHZhciBqID0gY2FtbF9lcGhlX2tleV9vZmZzZXQ7IGogPCB4Lmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIGtleSA9IHhbal07XG4gICAgICAgIGlmKGtleSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgICAgICAgIGtleSA9IGtleS5kZXJlZigpO1xuICAgICAgICAgIGlmKGtleSkgeFsxXS5yZWdpc3RlcihrZXksIHVuZGVmaW5lZCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBkYXRhO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldCwgY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9kYXRhKHgpe1xuICBpZihnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5ICYmIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgIGlmKHhbMV0gaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5KXtcbiAgICAgIC8vdW5yZWdpc3RlciBhbGwga2V5c1xuICAgICAgZm9yKHZhciBqID0gY2FtbF9lcGhlX2tleV9vZmZzZXQ7IGogPCB4Lmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIGtleSA9IHhbal07XG4gICAgICAgIGlmKGtleSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgICAgICAgIGtleSA9IGtleS5kZXJlZigpO1xuICAgICAgICAgIGlmKGtleSkgeFsxXS51bnJlZ2lzdGVyKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gdW5kZWZpbmVkO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NoZWNrX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX2NoZWNrX2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIDE7XG59XG4iLCJcbi8vUHJvdmlkZXM6IGNhbWxfbHhtX25leHRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfc2hpZnRfbGVmdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF94b3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYWRkXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X211bFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuLy9SZXF1aXJlczogY2FtbF9iYV9zZXRfMVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9seG1fbmV4dCh2KSB7XG4gIGZ1bmN0aW9uIHNoaWZ0X2woeCwgayl7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfc2hpZnRfbGVmdCh4LGspO1xuICB9XG4gIGZ1bmN0aW9uIHNoaWZ0X3IoeCwgayl7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCxrKTtcbiAgfVxuICBmdW5jdGlvbiBvcihhLCBiKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9vcihhLGIpO1xuICB9XG4gIGZ1bmN0aW9uIHhvcihhLCBiKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF94b3IoYSxiKTtcbiAgfVxuICBmdW5jdGlvbiBhZGQoYSwgYil7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfYWRkKGEsYik7XG4gIH1cbiAgZnVuY3Rpb24gbXVsKGEsIGIpe1xuICAgIHJldHVybiBjYW1sX2ludDY0X211bChhLGIpO1xuICB9XG4gIGZ1bmN0aW9uIHJvdGwoeCwgaykge1xuICAgIHJldHVybiBvcihzaGlmdF9sKHgsayksc2hpZnRfciAoeCwgNjQgLSBrKSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0KGEsIGkpIHtcbiAgICByZXR1cm4gY2FtbF9iYV9nZXRfMShhLCBpKTtcbiAgfVxuICBmdW5jdGlvbiBzZXQoYSwgaSwgeCkge1xuICAgIHJldHVybiBjYW1sX2JhX3NldF8xKGEsIGksIHgpO1xuICB9XG4gIHZhciBNID0gY2FtbF9pbnQ2NF9vZl9zdHJpbmcoY2FtbF9uZXdfc3RyaW5nKFwiMHhkMTM0MjU0M2RlODJlZjk1XCIpKTtcbiAgdmFyIGRhYmEgPSBjYW1sX2ludDY0X29mX3N0cmluZyhjYW1sX25ld19zdHJpbmcoXCIweGRhYmEwYjZlYjA5MzIyZTNcIikpO1xuICB2YXIgeiwgcTAsIHExO1xuICB2YXIgc3QgPSB2O1xuICB2YXIgYSA9IGdldChzdCwwKTtcbiAgdmFyIHMgPSBnZXQoc3QsMSk7XG4gIHZhciB4MCA9IGdldChzdCwyKTtcbiAgdmFyIHgxID0gZ2V0KHN0LDMpO1xuICAvKiBDb21iaW5pbmcgb3BlcmF0aW9uICovXG4gIHogPSBhZGQocywgeDApO1xuICAvKiBNaXhpbmcgZnVuY3Rpb24gKi9cbiAgeiA9IG11bCh4b3IoeixzaGlmdF9yKHosMzIpKSwgZGFiYSk7XG4gIHogPSBtdWwoeG9yKHosc2hpZnRfcih6LDMyKSksIGRhYmEpO1xuICB6ID0geG9yKHosc2hpZnRfcih6LDMyKSk7XG4gIC8qIExDRyB1cGRhdGUgKi9cbiAgc2V0KHN0LCAxLCBhZGQgKG11bChzLE0pLCBhKSk7XG4gIC8qIFhCRyB1cGRhdGUgKi9cbiAgdmFyIHEwID0geDBcbiAgdmFyIHExID0geDFcbiAgcTEgPSB4b3IocTEscTApO1xuICBxMCA9IHJvdGwocTAsIDI0KTtcbiAgcTAgPSB4b3IoeG9yKHEwLCBxMSksIChzaGlmdF9sKHExLDE2KSkpO1xuICBxMSA9IHJvdGwocTEsIDM3KTtcbiAgc2V0KHN0LCAyLCBxMCk7XG4gIHNldChzdCwgMywgcTEpO1xuICAvKiBSZXR1cm4gcmVzdWx0ICovXG4gIHJldHVybiB6O1xufVxuIiwiXG4vL1Byb3ZpZGVzOiB6c3RkX2RlY29tcHJlc3NcbnZhciB6c3RkX2RlY29tcHJlc3MgPSAoZnVuY3Rpb24gKCkge1xuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBhbGlhc2VzIGZvciBzaG9ydGVyIGNvbXByZXNzZWQgY29kZSAobW9zdCBtaW5pZmVycyBkb24ndCBkbyB0aGlzKVxudmFyIGFiID0gQXJyYXlCdWZmZXIsIHU4ID0gVWludDhBcnJheSwgdTE2ID0gVWludDE2QXJyYXksIGkxNiA9IEludDE2QXJyYXksIHUzMiA9IFVpbnQzMkFycmF5LCBpMzIgPSBJbnQzMkFycmF5O1xudmFyIHNsYyA9IGZ1bmN0aW9uICh2LCBzLCBlKSB7XG4gICAgaWYgKHU4LnByb3RvdHlwZS5zbGljZSlcbiAgICAgICAgcmV0dXJuIHU4LnByb3RvdHlwZS5zbGljZS5jYWxsKHYsIHMsIGUpO1xuICAgIGlmIChzID09IG51bGwgfHwgcyA8IDApXG4gICAgICAgIHMgPSAwO1xuICAgIGlmIChlID09IG51bGwgfHwgZSA+IHYubGVuZ3RoKVxuICAgICAgICBlID0gdi5sZW5ndGg7XG4gICAgdmFyIG4gPSBuZXcgdTgoZSAtIHMpO1xuICAgIG4uc2V0KHYuc3ViYXJyYXkocywgZSkpO1xuICAgIHJldHVybiBuO1xufTtcbnZhciBmaWxsID0gZnVuY3Rpb24gKHYsIG4sIHMsIGUpIHtcbiAgICBpZiAodTgucHJvdG90eXBlLmZpbGwpXG4gICAgICAgIHJldHVybiB1OC5wcm90b3R5cGUuZmlsbC5jYWxsKHYsIG4sIHMsIGUpO1xuICAgIGlmIChzID09IG51bGwgfHwgcyA8IDApXG4gICAgICAgIHMgPSAwO1xuICAgIGlmIChlID09IG51bGwgfHwgZSA+IHYubGVuZ3RoKVxuICAgICAgICBlID0gdi5sZW5ndGg7XG4gICAgZm9yICg7IHMgPCBlOyArK3MpXG4gICAgICAgIHZbc10gPSBuO1xuICAgIHJldHVybiB2O1xufTtcbnZhciBjcHcgPSBmdW5jdGlvbiAodiwgdCwgcywgZSkge1xuICAgIGlmICh1OC5wcm90b3R5cGUuY29weVdpdGhpbilcbiAgICAgICAgcmV0dXJuIHU4LnByb3RvdHlwZS5jb3B5V2l0aGluLmNhbGwodiwgdCwgcywgZSk7XG4gICAgaWYgKHMgPT0gbnVsbCB8fCBzIDwgMClcbiAgICAgICAgcyA9IDA7XG4gICAgaWYgKGUgPT0gbnVsbCB8fCBlID4gdi5sZW5ndGgpXG4gICAgICAgIGUgPSB2Lmxlbmd0aDtcbiAgICB3aGlsZSAocyA8IGUpIHtcbiAgICAgICAgdlt0KytdID0gdltzKytdO1xuICAgIH1cbn07XG4vKipcbiAqIENvZGVzIGZvciBlcnJvcnMgZ2VuZXJhdGVkIHdpdGhpbiB0aGlzIGxpYnJhcnlcbiAqL1xuLy8gZXJyb3IgY29kZXNcbnZhciBlYyA9IFtcbiAgICAnaW52YWxpZCB6c3RkIGRhdGEnLFxuICAgICd3aW5kb3cgc2l6ZSB0b28gbGFyZ2UgKD4yMDQ2TUIpJyxcbiAgICAnaW52YWxpZCBibG9jayB0eXBlJyxcbiAgICAnRlNFIGFjY3VyYWN5IHRvbyBoaWdoJyxcbiAgICAnbWF0Y2ggZGlzdGFuY2UgdG9vIGZhciBiYWNrJyxcbiAgICAndW5leHBlY3RlZCBFT0YnXG5dO1xuO1xudmFyIGVyciA9IGZ1bmN0aW9uIChpbmQsIG1zZywgbnQpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtc2cgfHwgZWNbaW5kXSk7XG4gICAgZS5jb2RlID0gaW5kO1xuICAgIGlmICghbnQpXG4gICAgICAgIHRocm93IGU7XG4gICAgcmV0dXJuIGU7XG59O1xudmFyIHJiID0gZnVuY3Rpb24gKGQsIGIsIG4pIHtcbiAgICB2YXIgaSA9IDAsIG8gPSAwO1xuICAgIGZvciAoOyBpIDwgbjsgKytpKVxuICAgICAgICBvIHw9IGRbYisrXSA8PCAoaSA8PCAzKTtcbiAgICByZXR1cm4gbztcbn07XG52YXIgYjQgPSBmdW5jdGlvbiAoZCwgYikgeyByZXR1cm4gKGRbYl0gfCAoZFtiICsgMV0gPDwgOCkgfCAoZFtiICsgMl0gPDwgMTYpIHwgKGRbYiArIDNdIDw8IDI0KSkgPj4+IDA7IH07XG4vLyByZWFkIFpzdGFuZGFyZCBmcmFtZSBoZWFkZXJcbnZhciByemZoID0gZnVuY3Rpb24gKGRhdCwgdykge1xuICAgIHZhciBuMyA9IGRhdFswXSB8IChkYXRbMV0gPDwgOCkgfCAoZGF0WzJdIDw8IDE2KTtcbiAgICBpZiAobjMgPT0gMHgyRkI1MjggJiYgZGF0WzNdID09IDI1Mykge1xuICAgICAgICAvLyBac3RhbmRhcmRcbiAgICAgICAgdmFyIGZsZyA9IGRhdFs0XTtcbiAgICAgICAgLy8gICAgc2luZ2xlIHNlZ21lbnQgICAgICAgY2hlY2tzdW0gICAgICAgICAgICAgZGljdCBmbGFnICAgICBmcmFtZSBjb250ZW50IGZsYWdcbiAgICAgICAgdmFyIHNzID0gKGZsZyA+PiA1KSAmIDEsIGNjID0gKGZsZyA+PiAyKSAmIDEsIGRmID0gZmxnICYgMywgZmNmID0gZmxnID4+IDY7XG4gICAgICAgIGlmIChmbGcgJiA4KVxuICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAvLyBieXRlXG4gICAgICAgIHZhciBidCA9IDYgLSBzcztcbiAgICAgICAgLy8gZGljdCBieXRlc1xuICAgICAgICB2YXIgZGIgPSBkZiA9PSAzID8gNCA6IGRmO1xuICAgICAgICAvLyBkaWN0aW9uYXJ5IGlkXG4gICAgICAgIHZhciBkaSA9IHJiKGRhdCwgYnQsIGRiKTtcbiAgICAgICAgYnQgKz0gZGI7XG4gICAgICAgIC8vIGZyYW1lIHNpemUgYnl0ZXNcbiAgICAgICAgdmFyIGZzYiA9IGZjZiA/ICgxIDw8IGZjZikgOiBzcztcbiAgICAgICAgLy8gZnJhbWUgc291cmNlIHNpemVcbiAgICAgICAgdmFyIGZzcyA9IHJiKGRhdCwgYnQsIGZzYikgKyAoKGZjZiA9PSAxKSAmJiAyNTYpO1xuICAgICAgICAvLyB3aW5kb3cgc2l6ZVxuICAgICAgICB2YXIgd3MgPSBmc3M7XG4gICAgICAgIGlmICghc3MpIHtcbiAgICAgICAgICAgIC8vIHdpbmRvdyBkZXNjcmlwdG9yXG4gICAgICAgICAgICB2YXIgd2IgPSAxIDw8ICgxMCArIChkYXRbNV0gPj4gMykpO1xuICAgICAgICAgICAgd3MgPSB3YiArICh3YiA+PiAzKSAqIChkYXRbNV0gJiA3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3MgPiAyMTQ1Mzg2NDk2KVxuICAgICAgICAgICAgZXJyKDEpO1xuICAgICAgICB2YXIgYnVmID0gbmV3IHU4KCh3ID09IDEgPyAoZnNzIHx8IHdzKSA6IHcgPyAwIDogd3MpICsgMTIpO1xuICAgICAgICBidWZbMF0gPSAxLCBidWZbNF0gPSA0LCBidWZbOF0gPSA4O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYjogYnQgKyBmc2IsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgbDogMCxcbiAgICAgICAgICAgIGQ6IGRpLFxuICAgICAgICAgICAgdzogKHcgJiYgdyAhPSAxKSA/IHcgOiBidWYuc3ViYXJyYXkoMTIpLFxuICAgICAgICAgICAgZTogd3MsXG4gICAgICAgICAgICBvOiBuZXcgaTMyKGJ1Zi5idWZmZXIsIDAsIDMpLFxuICAgICAgICAgICAgdTogZnNzLFxuICAgICAgICAgICAgYzogY2MsXG4gICAgICAgICAgICBtOiBNYXRoLm1pbigxMzEwNzIsIHdzKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgoKG4zID4+IDQpIHwgKGRhdFszXSA8PCAyMCkpID09IDB4MTg0RDJBNSkge1xuICAgICAgICAvLyBza2lwcGFibGVcbiAgICAgICAgcmV0dXJuIGI0KGRhdCwgNCkgKyA4O1xuICAgIH1cbiAgICBlcnIoMCk7XG59O1xuLy8gbW9zdCBzaWduaWZpY2FudCBiaXQgZm9yIG5vbnplcm9cbnZhciBtc2IgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIGJpdHMgPSAwO1xuICAgIGZvciAoOyAoMSA8PCBiaXRzKSA8PSB2YWw7ICsrYml0cylcbiAgICAgICAgO1xuICAgIHJldHVybiBiaXRzIC0gMTtcbn07XG4vLyByZWFkIGZpbml0ZSBzdGF0ZSBlbnRyb3B5XG52YXIgcmZzZSA9IGZ1bmN0aW9uIChkYXQsIGJ0LCBtYWwpIHtcbiAgICAvLyB0YWJsZSBwb3NcbiAgICB2YXIgdHBvcyA9IChidCA8PCAzKSArIDQ7XG4gICAgLy8gYWNjdXJhY3kgbG9nXG4gICAgdmFyIGFsID0gKGRhdFtidF0gJiAxNSkgKyA1O1xuICAgIGlmIChhbCA+IG1hbClcbiAgICAgICAgZXJyKDMpO1xuICAgIC8vIHNpemVcbiAgICB2YXIgc3ogPSAxIDw8IGFsO1xuICAgIC8vIHByb2JhYmlsaXRpZXMgc3ltYm9scyAgcmVwZWF0ICAgaW5kZXggICBoaWdoIHRocmVzaG9sZFxuICAgIHZhciBwcm9icyA9IHN6LCBzeW0gPSAtMSwgcmUgPSAtMSwgaSA9IC0xLCBodCA9IHN6O1xuICAgIC8vIG9wdGltaXphdGlvbjogc2luZ2xlIGFsbG9jYXRpb24gaXMgbXVjaCBmYXN0ZXJcbiAgICB2YXIgYnVmID0gbmV3IGFiKDUxMiArIChzeiA8PCAyKSk7XG4gICAgdmFyIGZyZXEgPSBuZXcgaTE2KGJ1ZiwgMCwgMjU2KTtcbiAgICAvLyBzYW1lIHZpZXcgYXMgZnJlcVxuICAgIHZhciBkc3RhdGUgPSBuZXcgdTE2KGJ1ZiwgMCwgMjU2KTtcbiAgICB2YXIgbnN0YXRlID0gbmV3IHUxNihidWYsIDUxMiwgc3opO1xuICAgIHZhciBiYjEgPSA1MTIgKyAoc3ogPDwgMSk7XG4gICAgdmFyIHN5bXMgPSBuZXcgdTgoYnVmLCBiYjEsIHN6KTtcbiAgICB2YXIgbmJpdHMgPSBuZXcgdTgoYnVmLCBiYjEgKyBzeik7XG4gICAgd2hpbGUgKHN5bSA8IDI1NSAmJiBwcm9icyA+IDApIHtcbiAgICAgICAgdmFyIGJpdHMgPSBtc2IocHJvYnMgKyAxKTtcbiAgICAgICAgdmFyIGNidCA9IHRwb3MgPj4gMztcbiAgICAgICAgLy8gbWFza1xuICAgICAgICB2YXIgbXNrID0gKDEgPDwgKGJpdHMgKyAxKSkgLSAxO1xuICAgICAgICB2YXIgdmFsID0gKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkgfCAoZGF0W2NidCArIDJdIDw8IDE2KSkgPj4gKHRwb3MgJiA3KSkgJiBtc2s7XG4gICAgICAgIC8vIG1hc2sgKDEgZmV3ZXIgYml0KVxuICAgICAgICB2YXIgbXNrMWZiID0gKDEgPDwgYml0cykgLSAxO1xuICAgICAgICAvLyBtYXggc21hbGwgdmFsdWVcbiAgICAgICAgdmFyIG1zdiA9IG1zayAtIHByb2JzIC0gMTtcbiAgICAgICAgLy8gc21hbGwgdmFsdWVcbiAgICAgICAgdmFyIHN2YWwgPSB2YWwgJiBtc2sxZmI7XG4gICAgICAgIGlmIChzdmFsIDwgbXN2KVxuICAgICAgICAgICAgdHBvcyArPSBiaXRzLCB2YWwgPSBzdmFsO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRwb3MgKz0gYml0cyArIDE7XG4gICAgICAgICAgICBpZiAodmFsID4gbXNrMWZiKVxuICAgICAgICAgICAgICAgIHZhbCAtPSBtc3Y7XG4gICAgICAgIH1cbiAgICAgICAgZnJlcVsrK3N5bV0gPSAtLXZhbDtcbiAgICAgICAgaWYgKHZhbCA9PSAtMSkge1xuICAgICAgICAgICAgcHJvYnMgKz0gdmFsO1xuICAgICAgICAgICAgc3ltc1stLWh0XSA9IHN5bTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwcm9icyAtPSB2YWw7XG4gICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgLy8gcmVwZWF0IGJ5dGVcbiAgICAgICAgICAgICAgICB2YXIgcmJ0ID0gdHBvcyA+PiAzO1xuICAgICAgICAgICAgICAgIHJlID0gKChkYXRbcmJ0XSB8IChkYXRbcmJ0ICsgMV0gPDwgOCkpID4+ICh0cG9zICYgNykpICYgMztcbiAgICAgICAgICAgICAgICB0cG9zICs9IDI7XG4gICAgICAgICAgICAgICAgc3ltICs9IHJlO1xuICAgICAgICAgICAgfSB3aGlsZSAocmUgPT0gMyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN5bSA+IDI1NSB8fCBwcm9icylcbiAgICAgICAgZXJyKDApO1xuICAgIHZhciBzeW1wb3MgPSAwO1xuICAgIC8vIHN5bSBzdGVwIChjb3ByaW1lIHdpdGggc3ogLSBmb3JtdWxhIGZyb20genN0ZCBzb3VyY2UpXG4gICAgdmFyIHNzdGVwID0gKHN6ID4+IDEpICsgKHN6ID4+IDMpICsgMztcbiAgICAvLyBzeW0gbWFza1xuICAgIHZhciBzbWFzayA9IHN6IC0gMTtcbiAgICBmb3IgKHZhciBzID0gMDsgcyA8PSBzeW07ICsrcykge1xuICAgICAgICB2YXIgc2YgPSBmcmVxW3NdO1xuICAgICAgICBpZiAoc2YgPCAxKSB7XG4gICAgICAgICAgICBkc3RhdGVbc10gPSAtc2Y7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIHNwbGl0IGludG8gdHdvIGxvb3BzIGluIHpzdGQgdG8gYXZvaWQgYnJhbmNoaW5nLCBidXQgYXMgSlMgaXMgaGlnaGVyLWxldmVsIHRoYXQgaXMgdW5uZWNlc3NhcnlcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNmOyArK2kpIHtcbiAgICAgICAgICAgIHN5bXNbc3ltcG9zXSA9IHM7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgc3ltcG9zID0gKHN5bXBvcyArIHNzdGVwKSAmIHNtYXNrO1xuICAgICAgICAgICAgfSB3aGlsZSAoc3ltcG9zID49IGh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZnRlciBzcHJlYWRpbmcgc3ltYm9scywgc2hvdWxkIGJlIHplcm8gYWdhaW5cbiAgICBpZiAoc3ltcG9zKVxuICAgICAgICBlcnIoMCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHN6OyArK2kpIHtcbiAgICAgICAgLy8gbmV4dCBzdGF0ZVxuICAgICAgICB2YXIgbnMgPSBkc3RhdGVbc3ltc1tpXV0rKztcbiAgICAgICAgLy8gbnVtIGJpdHNcbiAgICAgICAgdmFyIG5iID0gbmJpdHNbaV0gPSBhbCAtIG1zYihucyk7XG4gICAgICAgIG5zdGF0ZVtpXSA9IChucyA8PCBuYikgLSBzejtcbiAgICB9XG4gICAgcmV0dXJuIFsodHBvcyArIDcpID4+IDMsIHtcbiAgICAgICAgICAgIGI6IGFsLFxuICAgICAgICAgICAgczogc3ltcyxcbiAgICAgICAgICAgIG46IG5iaXRzLFxuICAgICAgICAgICAgdDogbnN0YXRlXG4gICAgICAgIH1dO1xufTtcbi8vIHJlYWQgaHVmZm1hblxudmFyIHJodSA9IGZ1bmN0aW9uIChkYXQsIGJ0KSB7XG4gICAgLy8gIGluZGV4ICB3ZWlnaHQgY291bnRcbiAgICB2YXIgaSA9IDAsIHdjID0gLTE7XG4gICAgLy8gICAgYnVmZmVyICAgICAgICAgICAgIGhlYWRlciBieXRlXG4gICAgdmFyIGJ1ZiA9IG5ldyB1OCgyOTIpLCBoYiA9IGRhdFtidF07XG4gICAgLy8gaHVmZm1hbiB3ZWlnaHRzXG4gICAgdmFyIGh3ID0gYnVmLnN1YmFycmF5KDAsIDI1Nik7XG4gICAgLy8gcmFuayBjb3VudFxuICAgIHZhciByYyA9IGJ1Zi5zdWJhcnJheSgyNTYsIDI2OCk7XG4gICAgLy8gcmFuayBpbmRleFxuICAgIHZhciByaSA9IG5ldyB1MTYoYnVmLmJ1ZmZlciwgMjY4KTtcbiAgICAvLyBOT1RFOiBhdCB0aGlzIHBvaW50IGJ0IGlzIDEgbGVzcyB0aGFuIGV4cGVjdGVkXG4gICAgaWYgKGhiIDwgMTI4KSB7XG4gICAgICAgIC8vIGVuZCBieXRlLCBmc2UgZGVjb2RlIHRhYmxlXG4gICAgICAgIHZhciBfYSA9IHJmc2UoZGF0LCBidCArIDEsIDYpLCBlYnQgPSBfYVswXSwgZmR0ID0gX2FbMV07XG4gICAgICAgIGJ0ICs9IGhiO1xuICAgICAgICB2YXIgZXBvcyA9IGVidCA8PCAzO1xuICAgICAgICAvLyBsYXN0IGJ5dGVcbiAgICAgICAgdmFyIGxiID0gZGF0W2J0XTtcbiAgICAgICAgaWYgKCFsYilcbiAgICAgICAgICAgIGVycigwKTtcbiAgICAgICAgLy8gIHN0YXRlMSAgIHN0YXRlMiAgIHN0YXRlMSBiaXRzICAgc3RhdGUyIGJpdHNcbiAgICAgICAgdmFyIHN0MSA9IDAsIHN0MiA9IDAsIGJ0cjEgPSBmZHQuYiwgYnRyMiA9IGJ0cjE7XG4gICAgICAgIC8vIGZzZSBwb3NcbiAgICAgICAgLy8gcHJlLWluY3JlbWVudCB0byBhY2NvdW50IGZvciBvcmlnaW5hbCBkZWZpY2l0IG9mIDFcbiAgICAgICAgdmFyIGZwb3MgPSAoKytidCA8PCAzKSAtIDggKyBtc2IobGIpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBmcG9zIC09IGJ0cjE7XG4gICAgICAgICAgICBpZiAoZnBvcyA8IGVwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgY2J0ID0gZnBvcyA+PiAzO1xuICAgICAgICAgICAgc3QxICs9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoZnBvcyAmIDcpKSAmICgoMSA8PCBidHIxKSAtIDEpO1xuICAgICAgICAgICAgaHdbKyt3Y10gPSBmZHQuc1tzdDFdO1xuICAgICAgICAgICAgZnBvcyAtPSBidHIyO1xuICAgICAgICAgICAgaWYgKGZwb3MgPCBlcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2J0ID0gZnBvcyA+PiAzO1xuICAgICAgICAgICAgc3QyICs9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoZnBvcyAmIDcpKSAmICgoMSA8PCBidHIyKSAtIDEpO1xuICAgICAgICAgICAgaHdbKyt3Y10gPSBmZHQuc1tzdDJdO1xuICAgICAgICAgICAgYnRyMSA9IGZkdC5uW3N0MV07XG4gICAgICAgICAgICBzdDEgPSBmZHQudFtzdDFdO1xuICAgICAgICAgICAgYnRyMiA9IGZkdC5uW3N0Ml07XG4gICAgICAgICAgICBzdDIgPSBmZHQudFtzdDJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICgrK3djID4gMjU1KVxuICAgICAgICAgICAgZXJyKDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2MgPSBoYiAtIDEyNztcbiAgICAgICAgZm9yICg7IGkgPCB3YzsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZSA9IGRhdFsrK2J0XTtcbiAgICAgICAgICAgIGh3W2ldID0gYnl0ZSA+PiA0O1xuICAgICAgICAgICAgaHdbaSArIDFdID0gYnl0ZSAmIDE1O1xuICAgICAgICB9XG4gICAgICAgICsrYnQ7XG4gICAgfVxuICAgIC8vIHdlaWdodCBleHBvbmVudGlhbCBzdW1cbiAgICB2YXIgd2VzID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgd2M7ICsraSkge1xuICAgICAgICB2YXIgd3QgPSBod1tpXTtcbiAgICAgICAgLy8gYml0cyBtdXN0IGJlIGF0IG1vc3QgMTEsIHNhbWUgYXMgd2VpZ2h0XG4gICAgICAgIGlmICh3dCA+IDExKVxuICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICB3ZXMgKz0gd3QgJiYgKDEgPDwgKHd0IC0gMSkpO1xuICAgIH1cbiAgICAvLyBtYXggYml0c1xuICAgIHZhciBtYiA9IG1zYih3ZXMpICsgMTtcbiAgICAvLyB0YWJsZSBzaXplXG4gICAgdmFyIHRzID0gMSA8PCBtYjtcbiAgICAvLyByZW1haW5pbmcgc3VtXG4gICAgdmFyIHJlbSA9IHRzIC0gd2VzO1xuICAgIC8vIG11c3QgYmUgcG93ZXIgb2YgMlxuICAgIGlmIChyZW0gJiAocmVtIC0gMSkpXG4gICAgICAgIGVycigwKTtcbiAgICBod1t3YysrXSA9IG1zYihyZW0pICsgMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgd2M7ICsraSkge1xuICAgICAgICB2YXIgd3QgPSBod1tpXTtcbiAgICAgICAgKytyY1tod1tpXSA9IHd0ICYmIChtYiArIDEgLSB3dCldO1xuICAgIH1cbiAgICAvLyBodWYgYnVmXG4gICAgdmFyIGhidWYgPSBuZXcgdTgodHMgPDwgMSk7XG4gICAgLy8gICAgc3ltYm9scyAgICAgICAgICAgICAgICAgICAgICBudW0gYml0c1xuICAgIHZhciBzeW1zID0gaGJ1Zi5zdWJhcnJheSgwLCB0cyksIG5iID0gaGJ1Zi5zdWJhcnJheSh0cyk7XG4gICAgcmlbbWJdID0gMDtcbiAgICBmb3IgKGkgPSBtYjsgaSA+IDA7IC0taSkge1xuICAgICAgICB2YXIgcHYgPSByaVtpXTtcbiAgICAgICAgZmlsbChuYiwgaSwgcHYsIHJpW2kgLSAxXSA9IHB2ICsgcmNbaV0gKiAoMSA8PCAobWIgLSBpKSkpO1xuICAgIH1cbiAgICBpZiAocmlbMF0gIT0gdHMpXG4gICAgICAgIGVycigwKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgd2M7ICsraSkge1xuICAgICAgICB2YXIgYml0cyA9IGh3W2ldO1xuICAgICAgICBpZiAoYml0cykge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByaVtiaXRzXTtcbiAgICAgICAgICAgIGZpbGwoc3ltcywgaSwgY29kZSwgcmlbYml0c10gPSBjb2RlICsgKDEgPDwgKG1iIC0gYml0cykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2J0LCB7XG4gICAgICAgICAgICBuOiBuYixcbiAgICAgICAgICAgIGI6IG1iLFxuICAgICAgICAgICAgczogc3ltc1xuICAgICAgICB9XTtcbn07XG4vLyBUYWJsZXMgZ2VuZXJhdGVkIHVzaW5nIHRoaXM6XG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMDFhcnJvd3ovYTk3OTQ1MmQ0MzU1OTkyY2JmOGYyNTdjYmZmYzllZGRcbi8vIGRlZmF1bHQgbGl0ZXJhbCBsZW5ndGggdGFibGVcbnZhciBkbGx0ID0gLyojX19QVVJFX18qLyByZnNlKC8qI19fUFVSRV9fKi8gbmV3IHU4KFtcbiAgICA4MSwgMTYsIDk5LCAxNDAsIDQ5LCAxOTgsIDI0LCA5OSwgMTIsIDMzLCAxOTYsIDI0LCA5OSwgMTAyLCAxMDIsIDEzNCwgNzAsIDE0NiwgNFxuXSksIDAsIDYpWzFdO1xuLy8gZGVmYXVsdCBtYXRjaCBsZW5ndGggdGFibGVcbnZhciBkbWx0ID0gLyojX19QVVJFX18qLyByZnNlKC8qI19fUFVSRV9fKi8gbmV3IHU4KFtcbiAgICAzMywgMjAsIDE5NiwgMjQsIDk5LCAxNDAsIDMzLCAxMzIsIDE2LCA2NiwgOCwgMzMsIDEzMiwgMTYsIDY2LCA4LCAzMywgNjgsIDY4LCA2OCwgNjgsIDY4LCA2OCwgNjgsIDY4LCAzNiwgOVxuXSksIDAsIDYpWzFdO1xuLy8gZGVmYXVsdCBvZmZzZXQgY29kZSB0YWJsZVxudmFyIGRvY3QgPSAvKiNfX1BVUkVfXyAqLyByZnNlKC8qI19fUFVSRV9fKi8gbmV3IHU4KFtcbiAgICAzMiwgMTMyLCAxNiwgNjYsIDEwMiwgNzAsIDY4LCA2OCwgNjgsIDY4LCAzNiwgNzMsIDJcbl0pLCAwLCA1KVsxXTtcbi8vIGJpdHMgdG8gYmFzZWxpbmVcbnZhciBiMmJsID0gZnVuY3Rpb24gKGIsIHMpIHtcbiAgICB2YXIgbGVuID0gYi5sZW5ndGgsIGJsID0gbmV3IGkzMihsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgYmxbaV0gPSBzO1xuICAgICAgICBzICs9IDEgPDwgYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGJsO1xufTtcbi8vIGxpdGVyYWwgbGVuZ3RoIGJpdHNcbnZhciBsbGIgPSAvKiNfX1BVUkVfXyAqLyBuZXcgdTgoKCAvKiNfX1BVUkVfXyAqL25ldyBpMzIoW1xuICAgIDAsIDAsIDAsIDAsIDE2ODQzMDA5LCA1MDUyODc3MCwgMTM0Njc4MDIwLCAyMDIwNTAwNTcsIDI2OTQyMjA5M1xuXSkpLmJ1ZmZlciwgMCwgMzYpO1xuLy8gbGl0ZXJhbCBsZW5ndGggYmFzZWxpbmVcbnZhciBsbGJsID0gLyojX19QVVJFX18gKi8gYjJibChsbGIsIDApO1xuLy8gbWF0Y2ggbGVuZ3RoIGJpdHNcbnZhciBtbGIgPSAvKiNfX1BVUkVfXyAqLyBuZXcgdTgoKCAvKiNfX1BVUkVfXyAqL25ldyBpMzIoW1xuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDE2ODQzMDA5LCA1MDUyODc3MCwgMTE3NzY5MjIwLCAxODUyMDcwNDgsIDI1MjU3OTA4NCwgMTZcbl0pKS5idWZmZXIsIDAsIDUzKTtcbi8vIG1hdGNoIGxlbmd0aCBiYXNlbGluZVxudmFyIG1sYmwgPSAvKiNfX1BVUkVfXyAqLyBiMmJsKG1sYiwgMyk7XG4vLyBkZWNvZGUgaHVmZm1hbiBzdHJlYW1cbnZhciBkaHUgPSBmdW5jdGlvbiAoZGF0LCBvdXQsIGh1KSB7XG4gICAgdmFyIGxlbiA9IGRhdC5sZW5ndGgsIHNzID0gb3V0Lmxlbmd0aCwgbGIgPSBkYXRbbGVuIC0gMV0sIG1zayA9ICgxIDw8IGh1LmIpIC0gMSwgZWIgPSAtaHUuYjtcbiAgICBpZiAoIWxiKVxuICAgICAgICBlcnIoMCk7XG4gICAgdmFyIHN0ID0gMCwgYnRyID0gaHUuYiwgcG9zID0gKGxlbiA8PCAzKSAtIDggKyBtc2IobGIpIC0gYnRyLCBpID0gLTE7XG4gICAgZm9yICg7IHBvcyA+IGViICYmIGkgPCBzczspIHtcbiAgICAgICAgdmFyIGNidCA9IHBvcyA+PiAzO1xuICAgICAgICB2YXIgdmFsID0gKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSB8IChkYXRbY2J0ICsgMl0gPDwgMTYpKSA+PiAocG9zICYgNyk7XG4gICAgICAgIHN0ID0gKChzdCA8PCBidHIpIHwgdmFsKSAmIG1zaztcbiAgICAgICAgb3V0WysraV0gPSBodS5zW3N0XTtcbiAgICAgICAgcG9zIC09IChidHIgPSBodS5uW3N0XSk7XG4gICAgfVxuICAgIGlmIChwb3MgIT0gZWIgfHwgaSArIDEgIT0gc3MpXG4gICAgICAgIGVycigwKTtcbn07XG4vLyBkZWNvZGUgaHVmZm1hbiBzdHJlYW0gNHhcbi8vIFRPRE86IHVzZSB3b3JrZXJzIHRvIHBhcmFsbGVsaXplXG52YXIgZGh1NCA9IGZ1bmN0aW9uIChkYXQsIG91dCwgaHUpIHtcbiAgICB2YXIgYnQgPSA2O1xuICAgIHZhciBzcyA9IG91dC5sZW5ndGgsIHN6MSA9IChzcyArIDMpID4+IDIsIHN6MiA9IHN6MSA8PCAxLCBzejMgPSBzejEgKyBzejI7XG4gICAgZGh1KGRhdC5zdWJhcnJheShidCwgYnQgKz0gZGF0WzBdIHwgKGRhdFsxXSA8PCA4KSksIG91dC5zdWJhcnJheSgwLCBzejEpLCBodSk7XG4gICAgZGh1KGRhdC5zdWJhcnJheShidCwgYnQgKz0gZGF0WzJdIHwgKGRhdFszXSA8PCA4KSksIG91dC5zdWJhcnJheShzejEsIHN6MiksIGh1KTtcbiAgICBkaHUoZGF0LnN1YmFycmF5KGJ0LCBidCArPSBkYXRbNF0gfCAoZGF0WzVdIDw8IDgpKSwgb3V0LnN1YmFycmF5KHN6Miwgc3ozKSwgaHUpO1xuICAgIGRodShkYXQuc3ViYXJyYXkoYnQpLCBvdXQuc3ViYXJyYXkoc3ozKSwgaHUpO1xufTtcbi8vIHJlYWQgWnN0YW5kYXJkIGJsb2NrXG52YXIgcnpiID0gZnVuY3Rpb24gKGRhdCwgc3QsIG91dCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgYnQgPSBzdC5iO1xuICAgIC8vICAgIGJ5dGUgMCAgICAgICAgYmxvY2sgdHlwZVxuICAgIHZhciBiMCA9IGRhdFtidF0sIGJ0eXBlID0gKGIwID4+IDEpICYgMztcbiAgICBzdC5sID0gYjAgJiAxO1xuICAgIHZhciBzeiA9IChiMCA+PiAzKSB8IChkYXRbYnQgKyAxXSA8PCA1KSB8IChkYXRbYnQgKyAyXSA8PCAxMyk7XG4gICAgLy8gZW5kIGJ5dGUgZm9yIGJsb2NrXG4gICAgdmFyIGVidCA9IChidCArPSAzKSArIHN6O1xuICAgIGlmIChidHlwZSA9PSAxKSB7XG4gICAgICAgIGlmIChidCA+PSBkYXQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdC5iID0gYnQgKyAxO1xuICAgICAgICBpZiAob3V0KSB7XG4gICAgICAgICAgICBmaWxsKG91dCwgZGF0W2J0XSwgc3QueSwgc3QueSArPSBzeik7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxsKG5ldyB1OChzeiksIGRhdFtidF0pO1xuICAgIH1cbiAgICBpZiAoZWJ0ID4gZGF0Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChidHlwZSA9PSAwKSB7XG4gICAgICAgIHN0LmIgPSBlYnQ7XG4gICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgIG91dC5zZXQoZGF0LnN1YmFycmF5KGJ0LCBlYnQpLCBzdC55KTtcbiAgICAgICAgICAgIHN0LnkgKz0gc3o7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzbGMoZGF0LCBidCwgZWJ0KTtcbiAgICB9XG4gICAgaWYgKGJ0eXBlID09IDIpIHtcbiAgICAgICAgLy8gICAgYnl0ZSAzICAgICAgICBsaXQgYnR5cGUgICAgIHNpemUgZm9ybWF0XG4gICAgICAgIHZhciBiMyA9IGRhdFtidF0sIGxidCA9IGIzICYgMywgc2YgPSAoYjMgPj4gMikgJiAzO1xuICAgICAgICAvLyBsaXQgc3JjIHNpemUgIGxpdCBjbXAgc3ogNCBzdHJlYW1zXG4gICAgICAgIHZhciBsc3MgPSBiMyA+PiA0LCBsY3MgPSAwLCBzNCA9IDA7XG4gICAgICAgIGlmIChsYnQgPCAyKSB7XG4gICAgICAgICAgICBpZiAoc2YgJiAxKVxuICAgICAgICAgICAgICAgIGxzcyB8PSAoZGF0WysrYnRdIDw8IDQpIHwgKChzZiAmIDIpICYmIChkYXRbKytidF0gPDwgMTIpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsc3MgPSBiMyA+PiAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgczQgPSBzZjtcbiAgICAgICAgICAgIGlmIChzZiA8IDIpXG4gICAgICAgICAgICAgICAgbHNzIHw9ICgoZGF0WysrYnRdICYgNjMpIDw8IDQpLCBsY3MgPSAoZGF0W2J0XSA+PiA2KSB8IChkYXRbKytidF0gPDwgMik7XG4gICAgICAgICAgICBlbHNlIGlmIChzZiA9PSAyKVxuICAgICAgICAgICAgICAgIGxzcyB8PSAoZGF0WysrYnRdIDw8IDQpIHwgKChkYXRbKytidF0gJiAzKSA8PCAxMiksIGxjcyA9IChkYXRbYnRdID4+IDIpIHwgKGRhdFsrK2J0XSA8PCA2KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsc3MgfD0gKGRhdFsrK2J0XSA8PCA0KSB8ICgoZGF0WysrYnRdICYgNjMpIDw8IDEyKSwgbGNzID0gKGRhdFtidF0gPj4gNikgfCAoZGF0WysrYnRdIDw8IDIpIHwgKGRhdFsrK2J0XSA8PCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgKytidDtcbiAgICAgICAgLy8gYWRkIGxpdGVyYWxzIHRvIGVuZCAtIGNhbiBuZXZlciBvdmVybGFwIHdpdGggYmFja3JlZmVyZW5jZXMgYmVjYXVzZSB1bnVzZWQgbGl0ZXJhbHMgYWx3YXlzIGFwcGVuZGVkXG4gICAgICAgIHZhciBidWYgPSBvdXQgPyBvdXQuc3ViYXJyYXkoc3QueSwgc3QueSArIHN0Lm0pIDogbmV3IHU4KHN0Lm0pO1xuICAgICAgICAvLyBzdGFydGluZyBwb2ludCBmb3IgbGl0ZXJhbHNcbiAgICAgICAgdmFyIHNwbCA9IGJ1Zi5sZW5ndGggLSBsc3M7XG4gICAgICAgIGlmIChsYnQgPT0gMClcbiAgICAgICAgICAgIGJ1Zi5zZXQoZGF0LnN1YmFycmF5KGJ0LCBidCArPSBsc3MpLCBzcGwpO1xuICAgICAgICBlbHNlIGlmIChsYnQgPT0gMSlcbiAgICAgICAgICAgIGZpbGwoYnVmLCBkYXRbYnQrK10sIHNwbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaHVmZm1hbiB0YWJsZVxuICAgICAgICAgICAgdmFyIGh1ID0gc3QuaDtcbiAgICAgICAgICAgIGlmIChsYnQgPT0gMikge1xuICAgICAgICAgICAgICAgIHZhciBodWQgPSByaHUoZGF0LCBidCk7XG4gICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgZGVzY3JpcHRpb24gbGVuZ3RoXG4gICAgICAgICAgICAgICAgbGNzICs9IGJ0IC0gKGJ0ID0gaHVkWzBdKTtcbiAgICAgICAgICAgICAgICBzdC5oID0gaHUgPSBodWRbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaHUpXG4gICAgICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAgICAgKHM0ID8gZGh1NCA6IGRodSkoZGF0LnN1YmFycmF5KGJ0LCBidCArPSBsY3MpLCBidWYuc3ViYXJyYXkoc3BsKSwgaHUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG51bSBzZXF1ZW5jZXNcbiAgICAgICAgdmFyIG5zID0gZGF0W2J0KytdO1xuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgIGlmIChucyA9PSAyNTUpXG4gICAgICAgICAgICAgICAgbnMgPSAoZGF0W2J0KytdIHwgKGRhdFtidCsrXSA8PCA4KSkgKyAweDdGMDA7XG4gICAgICAgICAgICBlbHNlIGlmIChucyA+IDEyNylcbiAgICAgICAgICAgICAgICBucyA9ICgobnMgLSAxMjgpIDw8IDgpIHwgZGF0W2J0KytdO1xuICAgICAgICAgICAgLy8gc3ltYm9sIGNvbXByZXNzaW9uIG1vZGVzXG4gICAgICAgICAgICB2YXIgc2NtID0gZGF0W2J0KytdO1xuICAgICAgICAgICAgaWYgKHNjbSAmIDMpXG4gICAgICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAgICAgdmFyIGR0cyA9IFtkbWx0LCBkb2N0LCBkbGx0XTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAyOyBpID4gLTE7IC0taSkge1xuICAgICAgICAgICAgICAgIHZhciBtZCA9IChzY20gPj4gKChpIDw8IDEpICsgMikpICYgMztcbiAgICAgICAgICAgICAgICBpZiAobWQgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBybGUgYnVmXG4gICAgICAgICAgICAgICAgICAgIHZhciByYnVmID0gbmV3IHU4KFswLCAwLCBkYXRbYnQrK11dKTtcbiAgICAgICAgICAgICAgICAgICAgZHRzW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgczogcmJ1Zi5zdWJhcnJheSgyLCAzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG46IHJidWYuc3ViYXJyYXkoMCwgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0OiBuZXcgdTE2KHJidWYuYnVmZmVyLCAwLCAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGI6IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWQgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhY2N1cmFjeSBsb2cgOCBmb3Igb2Zmc2V0cywgOSBmb3Igb3RoZXJzXG4gICAgICAgICAgICAgICAgICAgIF9hID0gcmZzZShkYXQsIGJ0LCA5IC0gKGkgJiAxKSksIGJ0ID0gX2FbMF0sIGR0c1tpXSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3QudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycigwKTtcbiAgICAgICAgICAgICAgICAgICAgZHRzW2ldID0gc3QudFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBzdC50ID0gZHRzLCBtbHQgPSBfYlswXSwgb2N0ID0gX2JbMV0sIGxsdCA9IF9iWzJdO1xuICAgICAgICAgICAgdmFyIGxiID0gZGF0W2VidCAtIDFdO1xuICAgICAgICAgICAgaWYgKCFsYilcbiAgICAgICAgICAgICAgICBlcnIoMCk7XG4gICAgICAgICAgICB2YXIgc3BvcyA9IChlYnQgPDwgMykgLSA4ICsgbXNiKGxiKSAtIGxsdC5iLCBjYnQgPSBzcG9zID4+IDMsIG91YnQgPSAwO1xuICAgICAgICAgICAgdmFyIGxzdCA9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBsbHQuYikgLSAxKTtcbiAgICAgICAgICAgIGNidCA9IChzcG9zIC09IG9jdC5iKSA+PiAzO1xuICAgICAgICAgICAgdmFyIG9zdCA9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBvY3QuYikgLSAxKTtcbiAgICAgICAgICAgIGNidCA9IChzcG9zIC09IG1sdC5iKSA+PiAzO1xuICAgICAgICAgICAgdmFyIG1zdCA9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBtbHQuYikgLSAxKTtcbiAgICAgICAgICAgIGZvciAoKytuczsgLS1uczspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGxjID0gbGx0LnNbbHN0XTtcbiAgICAgICAgICAgICAgICB2YXIgbGJ0ciA9IGxsdC5uW2xzdF07XG4gICAgICAgICAgICAgICAgdmFyIG1sYyA9IG1sdC5zW21zdF07XG4gICAgICAgICAgICAgICAgdmFyIG1idHIgPSBtbHQublttc3RdO1xuICAgICAgICAgICAgICAgIHZhciBvZmMgPSBvY3Quc1tvc3RdO1xuICAgICAgICAgICAgICAgIHZhciBvYnRyID0gb2N0Lm5bb3N0XTtcbiAgICAgICAgICAgICAgICBjYnQgPSAoc3BvcyAtPSBvZmMpID4+IDM7XG4gICAgICAgICAgICAgICAgdmFyIG9mcCA9IDEgPDwgb2ZjO1xuICAgICAgICAgICAgICAgIHZhciBvZmYgPSBvZnAgKyAoKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkgfCAoZGF0W2NidCArIDJdIDw8IDE2KSB8IChkYXRbY2J0ICsgM10gPDwgMjQpKSA+Pj4gKHNwb3MgJiA3KSkgJiAob2ZwIC0gMSkpO1xuICAgICAgICAgICAgICAgIGNidCA9IChzcG9zIC09IG1sYlttbGNdKSA+PiAzO1xuICAgICAgICAgICAgICAgIHZhciBtbCA9IG1sYmxbbWxjXSArICgoKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSB8IChkYXRbY2J0ICsgMl0gPDwgMTYpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBtbGJbbWxjXSkgLSAxKSk7XG4gICAgICAgICAgICAgICAgY2J0ID0gKHNwb3MgLT0gbGxiW2xsY10pID4+IDM7XG4gICAgICAgICAgICAgICAgdmFyIGxsID0gbGxibFtsbGNdICsgKCgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpIHwgKGRhdFtjYnQgKyAyXSA8PCAxNikpID4+IChzcG9zICYgNykpICYgKCgxIDw8IGxsYltsbGNdKSAtIDEpKTtcbiAgICAgICAgICAgICAgICBjYnQgPSAoc3BvcyAtPSBsYnRyKSA+PiAzO1xuICAgICAgICAgICAgICAgIGxzdCA9IGxsdC50W2xzdF0gKyAoKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkpID4+IChzcG9zICYgNykpICYgKCgxIDw8IGxidHIpIC0gMSkpO1xuICAgICAgICAgICAgICAgIGNidCA9IChzcG9zIC09IG1idHIpID4+IDM7XG4gICAgICAgICAgICAgICAgbXN0ID0gbWx0LnRbbXN0XSArICgoKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSkgPj4gKHNwb3MgJiA3KSkgJiAoKDEgPDwgbWJ0cikgLSAxKSk7XG4gICAgICAgICAgICAgICAgY2J0ID0gKHNwb3MgLT0gb2J0cikgPj4gMztcbiAgICAgICAgICAgICAgICBvc3QgPSBvY3QudFtvc3RdICsgKCgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBvYnRyKSAtIDEpKTtcbiAgICAgICAgICAgICAgICBpZiAob2ZmID4gMykge1xuICAgICAgICAgICAgICAgICAgICBzdC5vWzJdID0gc3Qub1sxXTtcbiAgICAgICAgICAgICAgICAgICAgc3Qub1sxXSA9IHN0Lm9bMF07XG4gICAgICAgICAgICAgICAgICAgIHN0Lm9bMF0gPSBvZmYgLT0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBvZmYgLSAobGwgIT0gMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZiA9IGlkeCA9PSAzID8gc3Qub1swXSAtIDEgOiBzdC5vW2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID4gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdC5vWzJdID0gc3Qub1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0Lm9bMV0gPSBzdC5vWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Qub1swXSA9IG9mZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmYgPSBzdC5vWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW291YnQgKyBpXSA9IGJ1ZltzcGwgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3VidCArPSBsbCwgc3BsICs9IGxsO1xuICAgICAgICAgICAgICAgIHZhciBzdGluID0gb3VidCAtIG9mZjtcbiAgICAgICAgICAgICAgICBpZiAoc3RpbiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IC1zdGluO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnMgPSBzdC5lICsgc3RpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiA+IG1sKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gbWw7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltvdWJ0ICsgaV0gPSBzdC53W2JzICsgaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3VidCArPSBsZW4sIG1sIC09IGxlbiwgc3RpbiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBidWZbb3VidCArIGldID0gYnVmW3N0aW4gKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3VidCArPSBtbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdWJ0ICE9IHNwbCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChzcGwgPCBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltvdWJ0KytdID0gYnVmW3NwbCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb3VidCA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgICAgICBpZiAob3V0KVxuICAgICAgICAgICAgICAgIHN0LnkgKz0gb3VidDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBidWYgPSBzbGMoYnVmLCAwLCBvdWJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgICAgICBzdC55ICs9IGxzcztcbiAgICAgICAgICAgICAgICBpZiAoc3BsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbHNzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltpXSA9IGJ1ZltzcGwgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNwbClcbiAgICAgICAgICAgICAgICBidWYgPSBzbGMoYnVmLCBzcGwpO1xuICAgICAgICB9XG4gICAgICAgIHN0LmIgPSBlYnQ7XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIGVycigyKTtcbn07XG4vLyBjb25jYXRcbnZhciBjY3QgPSBmdW5jdGlvbiAoYnVmcywgb2wpIHtcbiAgICBpZiAoYnVmcy5sZW5ndGggPT0gMSlcbiAgICAgICAgcmV0dXJuIGJ1ZnNbMF07XG4gICAgdmFyIGJ1ZiA9IG5ldyB1OChvbCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGIgPSAwOyBpIDwgYnVmcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY2hrID0gYnVmc1tpXTtcbiAgICAgICAgYnVmLnNldChjaGssIGIpO1xuICAgICAgICBiICs9IGNoay5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59O1xuLyoqXG4gKiBEZWNvbXByZXNzZXMgWnN0YW5kYXJkIGRhdGFcbiAqIEBwYXJhbSBkYXQgVGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSBidWYgVGhlIG91dHB1dCBidWZmZXIuIElmIHVuc3BlY2lmaWVkLCB0aGUgZnVuY3Rpb24gd2lsbCBhbGxvY2F0ZVxuICogICAgICAgICAgICBleGFjdGx5IGVub3VnaCBtZW1vcnkgdG8gZml0IHRoZSBkZWNvbXByZXNzZWQgZGF0YS4gSWYgeW91clxuICogICAgICAgICAgICBkYXRhIGhhcyBtdWx0aXBsZSBmcmFtZXMgYW5kIHlvdSBrbm93IHRoZSBvdXRwdXQgc2l6ZSwgc3BlY2lmeWluZ1xuICogICAgICAgICAgICBpdCB3aWxsIHlpZWxkIGJldHRlciBwZXJmb3JtYW5jZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgZGF0YVxuICovXG5yZXR1cm4gZnVuY3Rpb24gZGVjb21wcmVzcyhkYXQsIGJ1Zikge1xuICAgIHZhciBidCA9IDAsIGJ1ZnMgPSBbXSwgbmIgPSArIWJ1Ziwgb2wgPSAwO1xuICAgIGZvciAoOyBkYXQubGVuZ3RoOykge1xuICAgICAgICB2YXIgc3QgPSByemZoKGRhdCwgbmIgfHwgYnVmKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdCA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKG5iKSB7XG4gICAgICAgICAgICAgICAgYnVmID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc3Qudy5sZW5ndGggPT0gc3QudSkge1xuICAgICAgICAgICAgICAgICAgICBidWZzLnB1c2goYnVmID0gc3Qudyk7XG4gICAgICAgICAgICAgICAgICAgIG9sICs9IHN0LnU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmcy5wdXNoKGJ1Zik7XG4gICAgICAgICAgICAgICAgc3QuZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDsgIXN0Lmw7KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJsayA9IHJ6YihkYXQsIHN0LCBidWYpO1xuICAgICAgICAgICAgICAgIGlmICghYmxrKVxuICAgICAgICAgICAgICAgICAgICBlcnIoNSk7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZilcbiAgICAgICAgICAgICAgICAgICAgc3QuZSA9IHN0Lnk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZnMucHVzaChibGspO1xuICAgICAgICAgICAgICAgICAgICBvbCArPSBibGsubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjcHcoc3QudywgMCwgYmxrLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHN0Lncuc2V0KGJsaywgc3Qudy5sZW5ndGggLSBibGsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidCA9IHN0LmIgKyAoc3QuYyAqIDQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJ0ID0gc3Q7XG4gICAgICAgIGRhdCA9IGRhdC5zdWJhcnJheShidCk7XG4gICAgfVxuICAgIHJldHVybiBjY3QoYnVmcywgb2wpO1xufVxufSkgKClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICBCZW5vaXQgVmF1Z29uLCBFTlNUQSAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUGFkZGluZyBwb3NpdGlvbi4gKilcbnR5cGUgcGFkdHkgPVxuICB8IExlZnQgICAoKiBUZXh0IGlzIGxlZnQganVzdGlmaWVkICgnLScgb3B0aW9uKS4gICAgICAgICAgICAgICAqKVxuICB8IFJpZ2h0ICAoKiBUZXh0IGlzIHJpZ2h0IGp1c3RpZmllZCAobm8gJy0nIG9wdGlvbikuICAgICAgICAgICAqKVxuICB8IFplcm9zICAoKiBUZXh0IGlzIHJpZ2h0IGp1c3RpZmllZCBieSB6ZXJvcyAoc2VlICcwJyBvcHRpb24pLiAqKVxuXG4oKioqKVxuXG4oKiBJbnRlZ2VyIGNvbnZlcnNpb24uICopXG50eXBlIGludF9jb252ID1cbiAgfCBJbnRfZCB8IEludF9wZCB8IEludF9zZCAgICAgICAgKCogICVkIHwgJStkIHwgJSBkICAqKVxuICB8IEludF9pIHwgSW50X3BpIHwgSW50X3NpICAgICAgICAoKiAgJWkgfCAlK2kgfCAlIGkgICopXG4gIHwgSW50X3ggfCBJbnRfQ3ggICAgICAgICAgICAgICAgICgqICAleCB8ICUjeCAgICAgICAgKilcbiAgfCBJbnRfWCB8IEludF9DWCAgICAgICAgICAgICAgICAgKCogICVYIHwgJSNYICAgICAgICAqKVxuICB8IEludF9vIHwgSW50X0NvICAgICAgICAgICAgICAgICAoKiAgJW8gfCAlI28gICAgICAgICopXG4gIHwgSW50X3UgICAgICAgICAgICAgICAgICAgICAgICAgICgqICAldSAgICAgICAgICAgICAgKilcbiAgfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgICAgICAgKCogICUjZCB8ICUjaSB8ICUjdSAqKVxuXG4oKiBGbG9hdCBjb252ZXJzaW9uLiAqKVxudHlwZSBmbG9hdF9mbGFnX2NvbnYgPVxuICB8IEZsb2F0X2ZsYWdfICAgICAgICAgICAgICAgICAgICAoKiAlW2ZlRWdHRmhIXSAqKVxuICB8IEZsb2F0X2ZsYWdfcCAgICAgICAgICAgICAgICAgICAoKiAlK1tmZUVnR0ZoSF0gKilcbiAgfCBGbG9hdF9mbGFnX3MgICAgICAgICAgICAgICAgICAgKCogJSBbZmVFZ0dGaEhdICopXG50eXBlIGZsb2F0X2tpbmRfY29udiA9XG4gIHwgRmxvYXRfZiAgICAgICAgICAgICAgICAgICAgICAgICgqICAlZiB8ICUrZiB8ICUgZiAgKilcbiAgfCBGbG9hdF9lICAgICAgICAgICAgICAgICAgICAgICAgKCogICVlIHwgJStlIHwgJSBlICAqKVxuICB8IEZsb2F0X0UgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUUgfCAlK0UgfCAlIEUgICopXG4gIHwgRmxvYXRfZyAgICAgICAgICAgICAgICAgICAgICAgICgqICAlZyB8ICUrZyB8ICUgZyAgKilcbiAgfCBGbG9hdF9HICAgICAgICAgICAgICAgICAgICAgICAgKCogICVHIHwgJStHIHwgJSBHICAqKVxuICB8IEZsb2F0X0YgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUYgfCAlK0YgfCAlIEYgICopXG4gIHwgRmxvYXRfaCAgICAgICAgICAgICAgICAgICAgICAgICgqICAlaCB8ICUraCB8ICUgaCAgKilcbiAgfCBGbG9hdF9IICAgICAgICAgICAgICAgICAgICAgICAgKCogICVIIHwgJStIIHwgJSBIICAqKVxuICB8IEZsb2F0X0NGICAgICAgICAgICAgICAgICAgICAgICAoKiAgJSNGfCAlKyNGfCAlICNGICopXG50eXBlIGZsb2F0X2NvbnYgPSBmbG9hdF9mbGFnX2NvbnYgKiBmbG9hdF9raW5kX2NvbnZcblxuKCoqKilcblxuKCogQ2hhciBzZXRzIChzZWUgJVsuLi5dKSBhcmUgYml0bWFwcyBpbXBsZW1lbnRlZCBhcyAzMi1jaGFyIHN0cmluZ3MuICopXG50eXBlIGNoYXJfc2V0ID0gc3RyaW5nXG5cbigqKiopXG5cbigqIENvdW50ZXIgdXNlZCBpbiBTY2FuZi4gKilcbnR5cGUgY291bnRlciA9XG4gIHwgTGluZV9jb3VudGVyICAgICAoKiAgJWwgICAgICAqKVxuICB8IENoYXJfY291bnRlciAgICAgKCogICVuICAgICAgKilcbiAgfCBUb2tlbl9jb3VudGVyICAgICgqICAlTiwgJUwgICopXG5cbigqKiopXG5cbigqIFBhZGRpbmcgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycy4gKilcbnR5cGUgKCdhLCAnYikgcGFkZGluZyA9XG4gICgqIE5vIHBhZGRpbmcgKGV4OiBcIiVkXCIpICopXG4gIHwgTm9fcGFkZGluZyAgOiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIExpdGVyYWwgcGFkZGluZyAoZXg6IFwiJThkXCIpICopXG4gIHwgTGl0X3BhZGRpbmcgOiBwYWR0eSAqIGludCAtPiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIFBhZGRpbmcgYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqZFwiKSAqKVxuICB8IEFyZ19wYWRkaW5nIDogcGFkdHkgLT4gKGludCAtPiAnYSwgJ2EpIHBhZGRpbmdcblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZCxcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwYWRkaW5nIG9wdGlvbiAobm8gZXh0cmEgYXJndW1lbnQpICopXG50eXBlIHBhZF9vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIFByZWNpc2lvbiBvZiBmbG9hdHMgYW5kICcwJy1wYWRkaW5nIG9mIGludGVnZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwcmVjaXNpb24gPVxuICAoKiBObyBwcmVjaXNpb24gKGV4OiBcIiVmXCIpICopXG4gIHwgTm9fcHJlY2lzaW9uIDogKCdhLCAnYSkgcHJlY2lzaW9uXG4gICgqIExpdGVyYWwgcHJlY2lzaW9uIChleDogXCIlLjNmXCIpICopXG4gIHwgTGl0X3ByZWNpc2lvbiA6IGludCAtPiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogUHJlY2lzaW9uIGFzIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpICopXG4gIHwgQXJnX3ByZWNpc2lvbiA6IChpbnQgLT4gJ2EsICdhKSBwcmVjaXNpb25cblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZixcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwcmVjaXNpb24gb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcHJlY19vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIHNlZSB0aGUgQ3VzdG9tIGZvcm1hdCBjb21iaW5hdG9yICopXG50eXBlICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgPVxuICB8IEN1c3RvbV96ZXJvIDogKCdhLCBzdHJpbmcsICdhKSBjdXN0b21fYXJpdHlcbiAgfCBDdXN0b21fc3VjYyA6ICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgLT5cbiAgICAoJ2EsICd4IC0+ICdiLCAneCAtPiAnYykgY3VzdG9tX2FyaXR5XG5cbigqKiopXG5cbigqICAgICAgICBSZWxhdGlvbmFsIGZvcm1hdCB0eXBlc1xuXG5JbiB0aGUgZmlyc3QgZm9ybWF0K2dhZHRzIGltcGxlbWVudGF0aW9uLCB0aGUgdHlwZSBmb3IgJSguLiUpIGluIHRoZVxuZm10IEdBRFQgd2FzIGFzIGZvbGxvd3M6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKiAoJ2QxLCAncTEsICdkMiwgJ3EyKSByZWFkZXJfbmJfdW5pZmllciAqXG4gICAgKCd4LCAnYiwgJ2MsICdkMSwgJ3ExLCAndSkgZm10dHkgKlxuICAgICgndSwgJ2IsICdjLCAncTEsICdlMSwgJ2YpIGZtdCAtPlxuICAgICAgKCgneCwgJ2IsICdjLCAnZDIsICdxMiwgJ3UpIGZvcm1hdDYgLT4gJ3gsICdiLCAnYywgJ2QxLCAnZTEsICdmKSBmbXRcblxuTm90aWNlIHRoYXQgdGhlICd1IHBhcmFtZXRlciBpbiAnZiBwb3NpdGlvbiBpbiB0aGUgZm9ybWF0IGFyZ3VtZW50XG4oKCd4LCAuLiwgJ3UpIGZvcm1hdDYgLT4gLi4pIGlzIGVxdWFsIHRvIHRoZSAndSBwYXJhbWV0ZXIgaW4gJ2FcbnBvc2l0aW9uIGluIHRoZSBmb3JtYXQgdGFpbCAoKCd1LCAuLiwgJ2YpIGZtdCkuIFRoaXMgbWVhbnMgdGhhdCB0aGVcbnR5cGUgb2YgdGhlIGV4cGVjdGVkIGZvcm1hdCBwYXJhbWV0ZXIgZGVwZW5kcyBvZiB3aGVyZSB0aGUgJSguLi4lKVxuYXJlIGluIHRoZSBmb3JtYXQgc3RyaW5nOlxuXG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSlcIlxuICAtIDogKHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgdW5pdClcbiAgICAgIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2IC0+IHVuaXRcbiAgPSA8ZnVuPlxuICAjIFByaW50Zi5wcmludGYgXCIlKCUpJWRcIlxuICAtIDogKGludCAtPiB1bml0LCBvdXRfY2hhbm5lbCwgdW5pdCwgJ19hLCAnX2EsIGludCAtPiB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gaW50IC0+IHVuaXRcbiAgPSA8ZnVuPlxuXG5PbiB0aGUgY29udHJhcnksIHRoZSBsZWdhY3kgdHlwZXIgZ2l2ZXMgYSBjbGV2ZXIgdHlwZSB0aGF0IGRvZXMgbm90XG5kZXBlbmQgb24gdGhlIHBvc2l0aW9uIG9mICUoLi4lKSBpbiB0aGUgZm9ybWF0IHN0cmluZy4gRm9yIGV4YW1wbGUsXG4lKCUpIHdpbGwgaGF2ZSB0aGUgcG9seW1vcnBoaWMgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSk6IGl0IGNhblxuYmUgY29uY2F0ZW5hdGVkIHRvIGFueSBmb3JtYXQgdHlwZSwgYW5kIG9ubHkgZW5mb3JjZXMgdGhlIGNvbnN0cmFpbnRcbnRoYXQgaXRzICdhIGFuZCAnZiBwYXJhbWV0ZXJzIGFyZSBlcXVhbCAobm8gZm9ybWF0IGFyZ3VtZW50cykgYW5kICdkXG5hbmQgJ2UgYXJlIGVxdWFsIChubyByZWFkZXIgYXJndW1lbnQpLlxuXG5UaGUgd2Vha2VuaW5nIG9mIHRoaXMgcGFyYW1ldGVyIHR5cGUgaW4gdGhlIEdBRFQgdmVyc2lvbiBicm9rZSB1c2VyXG5jb2RlIChpbiBmYWN0IGl0IGVzc2VudGlhbGx5IG1hZGUgJSguLi4lKSB1bnVzYWJsZSBleGNlcHQgYXQgdGhlIGxhc3RcbnBvc2l0aW9uIG9mIGEgZm9ybWF0KS4gSW4gcGFydGljdWxhciwgdGhlIGZvbGxvd2luZyB3b3VsZCBub3Qgd29ya1xuYW55bW9yZTpcblxuICBmdW4gc2VwIC0+XG4gICAgRm9ybWF0LnByaW50ZiBcImZvbyUoJSliYXIlKCUpYmF6XCIgc2VwIHNlcFxuXG5BcyB0aGUgdHlwZS1jaGVja2VyIHdvdWxkIHJlcXVpcmUgdHdvICppbmNvbXBhdGlibGUqIHR5cGVzIGZvciB0aGUgJSglKVxuaW4gZGlmZmVyZW50IHBvc2l0aW9ucy5cblxuVGhlIHNvbHV0aW9uIHRvIHJlZ2FpbiBhIGdlbmVyYWwgdHlwZSBmb3IgJSguLiUpIGlzIHRvIGdlbmVyYWxpemUgdGhpc1xudGVjaG5pcXVlLCBub3Qgb25seSBvbiB0aGUgJ2QsICdlIHBhcmFtZXRlcnMsIGJ1dCBvbiBhbGwgc2l4XG5wYXJhbWV0ZXJzIG9mIGEgZm9ybWF0OiB3ZSBpbnRyb2R1Y2UgYSBcInJlbGF0aW9uYWxcIiB0eXBlXG4gICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG53aG9zZSB2YWx1ZXMgYXJlIHByb29mcyB0aGF0ICgnYTEsIC4uLCAnZjEpIGFuZCAoJ2EyLCAuLiwgJ2YyKSBtb3JhbGx5XG5jb3JyZXNwb25kIHRvIHRoZSBzYW1lIGZvcm1hdCB0eXBlOiAnYTEgaXMgb2J0YWluZWQgZnJvbSAnZjEsJ2IxLCdjMVxuaW4gdGhlIGV4YWN0IHNhbWUgd2F5IHRoYXQgJ2EyIGlzIG9idGFpbmVkIGZyb20gJ2YyLCdiMiwnYzIsIGV0Yy5cblxuRm9yIGV4YW1wbGUsIHRoZSByZWxhdGlvbiBiZXR3ZWVuIHR3byBmb3JtYXQgdHlwZXMgYmVnaW5uaW5nIHdpdGggYSBDaGFyXG5wYXJhbWV0ZXIgaXMgYXMgZm9sbG93czpcblxufCBDaGFyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWMgICopXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgIChjaGFyIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbkluIHRoZSBnZW5lcmFsIGNhc2UsIHRoZSB0ZXJtIHN0cnVjdHVyZSBvZiBmbXR0eV9yZWwgaXMgKGFsbW9zdFsxXSlcbmlzb21vcnBoaWMgdG8gdGhlIGZtdHR5IG9mIHRoZSBwcmV2aW91cyBpbXBsZW1lbnRhdGlvbjogZXZlcnlcbmNvbnN0cnVjdG9yIGlzIHJlLXJlYWQgd2l0aCBhIGJpbmFyeSwgcmVsYXRpb25hbCB0eXBlLCBpbnN0ZWFkIG9mIHRoZVxucHJldmlvdXMgdW5hcnkgdHlwaW5nLiBmbXR0eSBjYW4gdGhlbiBiZSByZS1kZWZpbmVkIGFzIHRoZSBkaWFnb25hbCBvZlxuZm10dHlfcmVsOlxuXG4gIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5ID1cbiAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5cbk9uY2Ugd2UgaGF2ZSB0aGlzIGZtdHR5X3JlbCB0eXBlIGluIHBsYWNlLCB3ZSBjYW4gZ2l2ZSB0aGUgbW9yZVxuZ2VuZXJhbCB0eXBlIHRvICUoLi4uJSk6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKlxuICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiLCAnYywgJ2oyLCAnZSwgJ2YpIGZtdFxuXG5XZSBhY2NlcHQgYW55IGZvcm1hdCAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYpICh0aGlzIGlzXG5jb21wbGV0ZWx5IHVucmVsYXRlZCB0byB0aGUgdHlwZSBvZiB0aGUgY3VycmVudCBmb3JtYXQpLCBidXQgYWxzb1xucmVxdWlyZSBhIHByb29mIHRoYXQgdGhpcyBmb3JtYXQgaXMgaW4gcmVsYXRpb24gdG8gYW5vdGhlciBmb3JtYXQgdGhhdFxuaXMgY29uY2F0ZW5hYmxlIHRvIHRoZSBmb3JtYXQgdGFpbC4gV2hlbiBleGVjdXRpbmcgYSAlKC4uLiUpIGZvcm1hdFxuKGluIGNhbWxpbnRlcm5hbEZvcm1hdC5tbDptYWtlX3ByaW50ZiBvciBzY2FuZi5tbDptYWtlX3NjYW5mKSwgd2VcbnRyYW5zdHlwZSB0aGUgZm9ybWF0IGFsb25nIHRoaXMgcmVsYXRpb24gdXNpbmcgdGhlICdyZWNhc3QnIGZ1bmN0aW9uXG50byB0cmFuc3Bvc2UgYmV0d2VlbiByZWxhdGVkIGZvcm1hdCB0eXBlcy5cblxuICB2YWwgcmVjYXN0IDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEpIGZtdFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10XG5cbk5PVEUgWzFdOiB0aGUgdHlwaW5nIG9mIEZvcm1hdF9zdWJzdF90eSByZXF1aXJlcyBub3Qgb25lIGZvcm1hdCB0eXBlLCBidXRcbnR3bywgb25lIHRvIGVzdGFibGlzaCB0aGUgbGluayBiZXR3ZWVuIHRoZSBmb3JtYXQgYXJndW1lbnQgYW5kIHRoZVxuZmlyc3Qgc2l4IHBhcmFtZXRlcnMsIGFuZCB0aGUgb3RoZXIgZm9yIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdFxuYXJndW1lbnQgYW5kIHRoZSBsYXN0IHNpeCBwYXJhbWV0ZXJzLlxuXG58IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2QyLCAnYTIpIGZtdHR5X3JlbCAqXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzEsICdiMSwgJ2MxLCAnajEsICdlMSwgJ2YxLFxuICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuV2hlbiB3ZSBnZW5lcmF0ZSBhIGZvcm1hdCBBU1QsIHdlIGdlbmVyYXRlIGV4YWN0bHkgdGhlIHNhbWUgd2l0bmVzc1xuZm9yIGJvdGggcmVsYXRpb25zLCBhbmQgdGhlIHdpdG5lc3MtY29udmVyc2lvbiBmdW5jdGlvbnMgaW5cbmNhbWxpbnRlcm5hbEZvcm1hdCBkbyByZWx5IG9uIHRoaXMgaW52YXJpYW50LiBGb3IgZXhhbXBsZSwgdGhlXG5mdW5jdGlvbiB0aGF0IHByb3ZlcyB0aGF0IHRoZSByZWxhdGlvbiBpcyB0cmFuc2l0aXZlXG5cbiAgdmFsIHRyYW5zIDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgLT4gKCdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcbiAgLT4gKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcblxuZG9lcyBhc3N1bWUgdGhhdCB0aGUgdHdvIGlucHV0cyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgdGVybSBzdHJ1Y3R1cmVcbihhbmQgaXMgb25seSBldmVyeSB1c2VkIGZvciBhcmd1bWVudCB3aXRuZXNzZXMgb2YgdGhlXG5Gb3JtYXRfc3Vic3RfdHkgY29uc3RydWN0b3IpLlxuKilcblxuKCogVHlwZSBvZiBhIGJsb2NrIHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCAgICgqIEhvcml6b250YWwgYmxvY2sgbm8gbGluZSBicmVha2luZyAqKVxuICB8IFBwX3Zib3ggICAoKiBWZXJ0aWNhbCBibG9jayBlYWNoIGJyZWFrIGxlYWRzIHRvIGEgbmV3IGxpbmUgKilcbiAgfCBQcF9odmJveCAgKCogSG9yaXpvbnRhbC12ZXJ0aWNhbCBibG9jazogc2FtZSBhcyB2Ym94LCBleGNlcHQgaWYgdGhpcyBibG9ja1xuICAgICAgICAgICAgICAgICBpcyBzbWFsbCBlbm91Z2ggdG8gZml0IG9uIGEgc2luZ2xlIGxpbmUgKilcbiAgfCBQcF9ob3Zib3ggKCogSG9yaXpvbnRhbCBvciBWZXJ0aWNhbCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2sgKilcbiAgfCBQcF9ib3ggICAgKCogSG9yaXpvbnRhbCBvciBJbmRlbnQgYmxvY2s6IGJyZWFrcyBsZWFkIHRvIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgIG9ubHkgd2hlbiBuZWNlc3NhcnkgdG8gcHJpbnQgdGhlIGNvbnRlbnQgb2YgdGhlIGJsb2NrLCBvclxuICAgICAgICAgICAgICAgICB3aGVuIGl0IGxlYWRzIHRvIGEgbmV3IGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50IGxpbmUgKilcbiAgfCBQcF9maXRzICAgKCogSW50ZXJuYWwgdXNhZ2U6IHdoZW4gYSBibG9jayBmaXRzIG9uIGEgc2luZ2xlIGxpbmUgKilcblxuKCogRm9ybWF0dGluZyBlbGVtZW50IHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgZm9ybWF0dGluZ19saXQgPVxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXSAgICopXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEB9ICAgKilcbiAgfCBCcmVhayBvZiBzdHJpbmcgKiBpbnQgKiBpbnQgICAgICAgICAgKCogQCwgfCBAICB8IEA7IHwgQDs8PiAqKVxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPyAgICopXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBcXG4gICopXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAuICAgKilcbiAgfCBNYWdpY19zaXplIG9mIHN0cmluZyAqIGludCAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQDxuPiAqKVxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAQCAgICopXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAlJSAgKilcbiAgfCBTY2FuX2luZGljIG9mIGNoYXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFggICAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW4gPVxuICB8IE9wZW5fdGFnIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gICAgICAoKiBAeyAgICopXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdHRpbmdfZ2VuXG4gIHwgT3Blbl9ib3ggOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEBbICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cblxuKCoqKilcblxuKCogTGlzdCBvZiBmb3JtYXQgdHlwZSBlbGVtZW50cy4gKilcbigqIEluIHBhcnRpY3VsYXIgdXNlZCB0byByZXByZXNlbnQgJSguLi4lKSBhbmQgJXsuLi4lfSBjb250ZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X3JlbFxuYW5kICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgPVxuICB8IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBjaGFyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFN0cmluZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKHN0cmluZyAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIHN0cmluZyAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50MzJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVsZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50MzIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQzMiAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBOYXRpdmVpbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5kICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChuYXRpdmVpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBuYXRpdmVpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50NjRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVMZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50NjQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQ2NCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBGbG9hdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWYgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChmbG9hdCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGZsb2F0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEJvb2xfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGJvb2wgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBib29sIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRm9ybWF0X2FyZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAqXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpXG4gICAgICAgICAgIGZtdHR5X3JlbFxuICB8IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzEsICdiMSwgJ2MxLCAnajEsICdkMSwgJ2ExKSBmbXR0eV9yZWwgKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzLiAqKVxuICB8IEFscGhhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ3ggLT4gJ2MxKSAtPiAneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ3ggLT4gJ2MyKSAtPiAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBUaGV0YV90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2IxIC0+ICdjMSkgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAoJ2IyIC0+ICdjMikgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQW55X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBVc2VkIGZvciBjdXN0b20gZm9ybWF0cyAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoJ3ggLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBSZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXIgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3IgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRW5kX29mX2ZtdHR5IDpcbiAgICAgICgnZjEsICdiMSwgJ2MxLCAnZDEsICdkMSwgJ2YxLFxuICAgICAgICdmMiwgJ2IyLCAnYzIsICdkMiwgJ2QyLCAnZjIpIGZtdHR5X3JlbFxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCBlbGVtZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10ID1cbiAgfCBDaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlUyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQzMiAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IE5hdGl2ZWludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVuW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgbmF0aXZlaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQ2NCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZsb2F0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGaEhdICopXG4gICAgICBmbG9hdF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgZmxvYXQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBCb29sIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2JCXSAqKVxuICAgICAgKCd4LCBib29sIC0+ICdhKSBwYWRkaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRmx1c2ggOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSEgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogYWJjICopXG4gICAgICBzdHJpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDaGFyX2xpdGVyYWwgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiB4ICopXG4gICAgICBjaGFyICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgfCBGb3JtYXRfYXJnIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAley4uLiV9ICopXG4gICAgICBwYWRfb3B0aW9uICogKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5ICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAgIHBhZF9vcHRpb24gKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYiwgJ2MsICdqMiwgJ2QsICdhKSBmbXR0eV9yZWwgKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IsICdjLCAnajIsICdlLCAnZikgZm10XG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3IuICopXG4gIHwgQWxwaGEgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWEgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnYiAtPiAneCAtPiAnYykgLT4gJ3ggLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgVGhldGEgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnYiAtPiAnYykgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yOiAqKVxuICB8IEZvcm1hdHRpbmdfbGl0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBfICopXG4gICAgICBmb3JtYXR0aW5nX2xpdCAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZvcm1hdHRpbmdfZ2VuIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXyAqKVxuICAgICAgKCdhMSwgJ2IsICdjLCAnZDEsICdlMSwgJ2YxKSBmb3JtYXR0aW5nX2dlbiAqXG4gICAgICAoJ2YxLCAnYiwgJ2MsICdlMSwgJ2UyLCAnZjIpIGZtdCAtPiAoJ2ExLCAnYiwgJ2MsICdkMSwgJ2UyLCAnZjIpIGZtdFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBSZWFkZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlciAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3ggLT4gJ2EsICdiLCAnYywgKCdiIC0+ICd4KSAtPiAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX2NoYXJfc2V0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlWy4uLl0gKilcbiAgICAgIHBhZF9vcHRpb24gKiBjaGFyX3NldCAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKHN0cmluZyAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX2dldF9jb3VudGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW25sTkxdICopXG4gICAgICBjb3VudGVyICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoaW50IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fbmV4dF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUwYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKGNoYXIgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSWdub3JlZF9wYXJhbSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8gKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBpZ25vcmVkICogKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogQ3VzdG9tIHByaW50aW5nIGZvcm1hdCAoUFIjNjQ1MiwgR1BSIzE0MClcblxuICAgICBXZSBpbmNsdWRlIGEgdHlwZSBDdXN0b20gb2YgXCJjdXN0b20gY29udmVydGVyc1wiLCB3aGVyZSBhblxuICAgICBhcmJpdHJhcnkgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gY29udmVydCBvbmUgb3IgbW9yZVxuICAgICBhcmd1bWVudHMuIFRoZXJlIGlzIG5vIHN5bnRheCBmb3IgY3VzdG9tIGNvbnZlcnRlcnMsIGl0IGlzIG9ubHlcbiAgICAgaW50ZW5kZWQgZm9yIGN1c3RvbSBwcm9jZXNzb3JzIHRoYXQgd2lzaCB0byByZWx5IG9uIHRoZVxuICAgICBzdGRsaWItZGVmaW5lZCBmb3JtYXQgR0FEVHMuXG5cbiAgICAgRm9yIGluc3RhbmNlIGEgcHJlLXByb2Nlc3NvciBjb3VsZCBjaG9vc2UgdG8gaW50ZXJwcmV0IHN0cmluZ3NcbiAgICAgcHJlZml4ZWQgd2l0aCBbXCIhXCJdIGFzIGZvcm1hdCBzdHJpbmdzIHdoZXJlIFsle3sgLi4uIH19XSBpc1xuICAgICBhIHNwZWNpYWwgZm9ybSB0byBwYXNzIGEgdG9fc3RyaW5nIGZ1bmN0aW9uLCBzbyB0aGF0IG9uZSBjb3VsZFxuICAgICB3cml0ZTpcblxuICAgICB7W1xuICAgICAgIHR5cGUgdCA9IHsgeCA6IGludDsgeSA6IGludCB9XG5cbiAgICAgICBsZXQgc3RyaW5nX29mX3QgdCA9IFByaW50Zi5zcHJpbnRmIFwieyB4ID0gJWQ7IHkgPSAlZCB9XCIgdC54IHQueVxuXG4gICAgICAgUHJpbnRmLnByaW50ZiAhXCJ0ID0gJXt7c3RyaW5nX29mX3R9fVwiIHsgeCA9IDQyOyB5ID0gNDIgfVxuICAgICBdfVxuICAqKVxuICB8IEN1c3RvbSA6XG4gICAgICAoJ2EsICd4LCAneSkgY3VzdG9tX2FyaXR5ICogKHVuaXQgLT4gJ3gpICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKCd5LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIGVuZCBvZiBhIGZvcm1hdCBzcGVjaWZpY2F0aW9uICopXG4gIHwgRW5kX29mX2Zvcm1hdCA6XG4gICAgICAgICgnZiwgJ2IsICdjLCAnZSwgJ2UsICdmKSBmbXRcblxuKCoqKilcblxuKCogVHlwZSBmb3IgaWdub3JlZCBwYXJhbWV0ZXJzIChzZWUgXCIlX1wiKS4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgaWdub3JlZCA9XG4gIHwgSWdub3JlZF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9jICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfY2FtbF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3MgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1MgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2QgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfbGQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfbmF0aXZlaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfbmQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfTGQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZmxvYXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfZiAqKVxuICAgICAgcGFkX29wdGlvbiAqIHByZWNfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9ib29sIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9CICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV97Li4uJX0gKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXyguLi4lKSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgaWdub3JlZFxuICB8IElnbm9yZWRfcmVhZGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfciAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICgnYiAtPiAneCkgLT4gJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfWy4uLl0gKilcbiAgICAgIHBhZF9vcHRpb24gKiBjaGFyX3NldCAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfW25sTkxdICopXG4gICAgICBjb3VudGVyIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8wYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcblxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgRm9ybWF0IG9mICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgKiBzdHJpbmdcblxubGV0IHJlYyBlcmFzZV9yZWwgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCBpIGogayBsIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYsXG4gICBnLCBoLCBpLCBqLCBrLCBsKSBmbXR0eV9yZWwgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5XG49IGZ1bmN0aW9uXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgQ2hhcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBTdHJpbmdfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludF90eSByZXN0IC0+XG4gICAgSW50X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgSW50MzJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBJbnQ2NF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBOYXRpdmVpbnRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBGbG9hdF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgQm9vbF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGVyYXNlX3JlbCByZXN0KVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCBfdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTEsIGVyYXNlX3JlbCByZXN0KVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBBbHBoYV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIFRoZXRhX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIEFueV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBSZWFkZXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCB0eXBlIGNvbmNhdGVuYXRpb24gKilcblxuKCogQ29uY2F0ZW5hdGUgdHdvIGZvcm1hdCB0eXBlcy4gKilcbigqIFVzZWQgYnk6XG4gICAqIHJlYWRlcl9uYl91bmlmaWVyX29mX2ZtdHR5IHRvIGNvdW50IHJlYWRlcnMgaW4gYW4gZm10dHksXG4gICAqIFNjYW5mLnRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgdG8gZXh0cmFjdCByZWFkZXJzIGluc2lkZSAlKC4uLiUpLFxuICAgKiBDYW1saW50ZXJuYWxGb3JtYXQuZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgdG8gZXh0cmFjdCBmb3JtYXQgdHlwZS4gKilcblxuKCpcbmxldCByZWMgY29uY2F0X2ZtdHR5IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChmLCBiLCBjLCBlLCBnLCBoKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBnLCBoKSBmbXR0eSA9XG4qKVxubGV0IHJlYyBjb25jYXRfZm10dHkgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgICAgICBnMSBqMSBnMiBqMlxuICAuXG4gICAgKGcxLCBiMSwgYzEsIGoxLCBkMSwgYTEsXG4gICAgIGcyLCBiMiwgYzIsIGoyLCBkMiwgYTIpIGZtdHR5X3JlbCAtPlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWwgLT5cbiAgICAoZzEsIGIxLCBjMSwgajEsIGUxLCBmMSxcbiAgICAgZzIsIGIyLCBjMiwgajIsIGUyLCBmMikgZm10dHlfcmVsID1cbmZ1biBmbXR0eTEgZm10dHkyIC0+IG1hdGNoIGZtdHR5MSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgQ2hhcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgU3RyaW5nX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBJbnRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgSW50MzJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIE5hdGl2ZWludF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBJbnQ2NF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBGbG9hdF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIEJvb2xfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgQWxwaGFfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgVGhldGFfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIEFueV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgUmVhZGVyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBFbmRfb2ZfZm10dHkgLT4gZm10dHkyXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgY29uY2F0ZW5hdGlvbiAqKVxuXG4oKiBDb25jYXRlbmF0ZSB0d28gZm9ybWF0cy4gKilcbmxldCByZWMgY29uY2F0X2ZtdCA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIC5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKGYsIGIsIGMsIGUsIGcsIGgpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBnLCBoKSBmbXQgPVxuZnVuIGZtdDEgZm10MiAtPiBtYXRjaCBmbXQxIHdpdGhcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBTdHJpbmcgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBDYW1sX3N0cmluZyAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludDMyIChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgQ2hhciAocmVzdCkgLT5cbiAgICBDaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIENhbWxfY2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIEJvb2wgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQWxwaGEgcmVzdCAtPlxuICAgIEFscGhhIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBUaGV0YSByZXN0IC0+XG4gICAgVGhldGEgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEN1c3RvbSAoYXJpdHksIGYsIHJlc3QpIC0+XG4gICAgQ3VzdG9tIChhcml0eSwgZiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgUmVhZGVyIHJlc3QgLT5cbiAgICBSZWFkZXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBGbHVzaCAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIFN0cmluZ19saXRlcmFsIChzdHIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIENoYXJfbGl0ZXJhbCAgIChjaHIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRm9ybWF0X2FyZyAocGFkLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnICAgKHBhZCwgZm10dHksIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3QgKHBhZCwgZm10dHksIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgIFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFNjYW5fbmV4dF9jaGFyIChyZXN0KSAtPlxuICAgIFNjYW5fbmV4dF9jaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgSWdub3JlZF9wYXJhbSAoaWduLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgIEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgLT5cbiAgICBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgZm10MlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFeGNlcHRpb25zICopXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+ICdhIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0ICgpID1cbiAgKCogZm9yIHJ1bnRpbWUvZmFpbF9uYXQuYyAqKVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlBlcnZhc2l2ZXMuYXJyYXlfYm91bmRfZXJyb3JcIlxuICAgIChJbnZhbGlkX2FyZ3VtZW50IFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKVxuXG5leHRlcm5hbCByYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlXCJcbmV4dGVybmFsIHJhaXNlX25vdHJhY2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZV9ub3RyYWNlXCJcblxubGV0IGZhaWx3aXRoIHMgPSByYWlzZShGYWlsdXJlIHMpXG5sZXQgaW52YWxpZF9hcmcgcyA9IHJhaXNlKEludmFsaWRfYXJndW1lbnQgcylcblxuZXhjZXB0aW9uIEV4aXRcbmV4Y2VwdGlvbiBNYXRjaF9mYWlsdXJlID0gTWF0Y2hfZmFpbHVyZVxuZXhjZXB0aW9uIEFzc2VydF9mYWlsdXJlID0gQXNzZXJ0X2ZhaWx1cmVcbmV4Y2VwdGlvbiBJbnZhbGlkX2FyZ3VtZW50ID0gSW52YWxpZF9hcmd1bWVudFxuZXhjZXB0aW9uIEZhaWx1cmUgPSBGYWlsdXJlXG5leGNlcHRpb24gTm90X2ZvdW5kID0gTm90X2ZvdW5kXG5leGNlcHRpb24gT3V0X29mX21lbW9yeSA9IE91dF9vZl9tZW1vcnlcbmV4Y2VwdGlvbiBTdGFja19vdmVyZmxvdyA9IFN0YWNrX292ZXJmbG93XG5leGNlcHRpb24gU3lzX2Vycm9yID0gU3lzX2Vycm9yXG5leGNlcHRpb24gRW5kX29mX2ZpbGUgPSBFbmRfb2ZfZmlsZVxuZXhjZXB0aW9uIERpdmlzaW9uX2J5X3plcm8gPSBEaXZpc2lvbl9ieV96ZXJvXG5leGNlcHRpb24gU3lzX2Jsb2NrZWRfaW8gPSBTeXNfYmxvY2tlZF9pb1xuZXhjZXB0aW9uIFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlID0gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGVcblxuKCogQ29tcG9zaXRpb24gb3BlcmF0b3JzICopXG5cbmV4dGVybmFsICggfD4gKSA6ICdhIC0+ICgnYSAtPiAnYikgLT4gJ2IgPSBcIiVyZXZhcHBseVwiXG5leHRlcm5hbCAoIEBAICkgOiAoJ2EgLT4gJ2IpIC0+ICdhIC0+ICdiID0gXCIlYXBwbHlcIlxuXG4oKiBEZWJ1Z2dpbmcgKilcblxuZXh0ZXJuYWwgX19MT0NfXyA6IHN0cmluZyA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19GSUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfRklMRVwiXG5leHRlcm5hbCBfX0xJTkVfXyA6IGludCA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fTU9EVUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfTU9EVUxFXCJcbmV4dGVybmFsIF9fUE9TX18gOiBzdHJpbmcgKiBpbnQgKiBpbnQgKiBpbnQgPSBcIiVsb2NfUE9TXCJcbmV4dGVybmFsIF9fRlVOQ1RJT05fXyA6IHN0cmluZyA9IFwiJWxvY19GVU5DVElPTlwiXG5cbmV4dGVybmFsIF9fTE9DX09GX18gOiAnYSAtPiBzdHJpbmcgKiAnYSA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19MSU5FX09GX18gOiAnYSAtPiBpbnQgKiAnYSA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fUE9TX09GX18gOiAnYSAtPiAoc3RyaW5nICogaW50ICogaW50ICogaW50KSAqICdhID0gXCIlbG9jX1BPU1wiXG5cbigqIENvbXBhcmlzb25zICopXG5cbmV4dGVybmFsICggPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbmV4dGVybmFsICggPD4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG5leHRlcm5hbCAoIDwgKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG5leHRlcm5hbCAoID4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG5leHRlcm5hbCAoIDw9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcbmV4dGVybmFsICggPj0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZXh0ZXJuYWwgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludCA9IFwiJWNvbXBhcmVcIlxuXG5sZXQgbWluIHggeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbmV4dGVybmFsICggPT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcVwiXG5leHRlcm5hbCAoICE9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXFcIlxuXG4oKiBCb29sZWFuIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgbm90IDogYm9vbCAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuXG4oKiBJbnRlZ2VyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LSApIDogaW50IC0+IGludCA9IFwiJW5lZ2ludFwiXG5leHRlcm5hbCAoIH4rICkgOiBpbnQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgc3VjYyA6IGludCAtPiBpbnQgPSBcIiVzdWNjaW50XCJcbmV4dGVybmFsIHByZWQgOiBpbnQgLT4gaW50ID0gXCIlcHJlZGludFwiXG5leHRlcm5hbCAoICsgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsICggLSApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuZXh0ZXJuYWwgKCAqICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW11bGludFwiXG5leHRlcm5hbCAoIC8gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbmV4dGVybmFsICggbW9kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW1vZGludFwiXG5cbmxldCBhYnMgeCA9IGlmIHggPj0gMCB0aGVuIHggZWxzZSAteFxuXG5leHRlcm5hbCAoIGxhbmQgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsICggbG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsICggbHhvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxuXG5sZXQgbG5vdCB4ID0geCBseG9yICgtMSlcblxuZXh0ZXJuYWwgKCBsc2wgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNsaW50XCJcbmV4dGVybmFsICggbHNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG5leHRlcm5hbCAoIGFzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhc3JpbnRcIlxuXG5sZXQgbWF4X2ludCA9ICgtMSkgbHNyIDFcbmxldCBtaW5faW50ID0gbWF4X2ludCArIDFcblxuKCogRmxvYXRpbmctcG9pbnQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCAoIH4tLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVuZWdmbG9hdFwiXG5leHRlcm5hbCAoIH4rLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCAoICsuICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFkZGZsb2F0XCJcbmV4dGVybmFsICggLS4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlc3ViZmxvYXRcIlxuZXh0ZXJuYWwgKCAqLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVtdWxmbG9hdFwiXG5leHRlcm5hbCAoIC8uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWRpdmZsb2F0XCJcbmV4dGVybmFsICggKiogKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc19mbG9hdFwiIFwiYWNvc1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbl9mbG9hdFwiIFwiYXNpblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbl9mbG9hdFwiIFwiYXRhblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuMiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW4yX2Zsb2F0XCIgXCJhdGFuMlwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBoeXBvdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NfZmxvYXRcIiBcImNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NoX2Zsb2F0XCIgXCJjYW1sX2Fjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzEwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMTBfZmxvYXRcIiBcImxvZzEwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luaF9mbG9hdFwiIFwiY2FtbF9hc2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5fZmxvYXRcIiBcInRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuaF9mbG9hdFwiIFwidGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5oX2Zsb2F0XCIgXCJjYW1sX2F0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNlaWwgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jZWlsX2Zsb2F0XCIgXCJjZWlsXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb29yIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZmxvb3JfZmxvYXRcIiBcImZsb29yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFic19mbG9hdCA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuZXh0ZXJuYWwgY29weXNpZ24gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgICAgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgICAgICAgICAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZF9mbG9hdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Ztb2RfZmxvYXRcIiBcImZtb2RcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5leHRlcm5hbCBsZGV4cCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiAoaW50IFtAdW50YWdnZWRdKSAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfbGRleHBfZmxvYXRcIiBcImNhbWxfbGRleHBfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RmIDogZmxvYXQgLT4gZmxvYXQgKiBmbG9hdCA9IFwiY2FtbF9tb2RmX2Zsb2F0XCJcbmV4dGVybmFsIGZsb2F0IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCBmbG9hdF9vZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRydW5jYXRlIDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBpbnRfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5sZXQgaW5maW5pdHkgPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgbmVnX2luZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweEZGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5hbiA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9GMF8wMF8wMF8wMF8wMF8wMF8wMUxcbmxldCBtYXhfZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRUZfRkZfRkZfRkZfRkZfRkZfRkZMXG5sZXQgbWluX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDAwXzEwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IGVwc2lsb25fZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4M0NfQjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5cbnR5cGUgZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuXG4oKiBTdHJpbmcgYW5kIGJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZXMgU3RyaW5nIGFuZCBCeXRlcyAqKVxuXG5leHRlcm5hbCBzdHJpbmdfbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgYnl0ZXNfbGVuZ3RoIDogYnl0ZXMgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgc3RyaW5nX2JsaXQgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYnl0ZXNfYmxpdCA6IGJ5dGVzIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmxldCAoIF4gKSBzMSBzMiA9XG4gIGxldCBsMSA9IHN0cmluZ19sZW5ndGggczEgYW5kIGwyID0gc3RyaW5nX2xlbmd0aCBzMiBpblxuICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSAobDEgKyBsMikgaW5cbiAgc3RyaW5nX2JsaXQgczEgMCBzIDAgbDE7XG4gIHN0cmluZ19ibGl0IHMyIDAgcyBsMSBsMjtcbiAgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyBzXG5cbigqIENoYXJhY3RlciBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlIENoYXIgKilcblxuZXh0ZXJuYWwgaW50X29mX2NoYXIgOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaGFyX29mX2ludCA6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxubGV0IGNoYXJfb2ZfaW50IG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJjaGFyX29mX2ludFwiIGVsc2UgdW5zYWZlX2NoYXJfb2ZfaW50IG5cblxuKCogVW5pdCBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGlnbm9yZSA6ICdhIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4oKiBQYWlyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgZnN0IDogJ2EgKiAnYiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCBzbmQgOiAnYSAqICdiIC0+ICdiID0gXCIlZmllbGQxXCJcblxuKCogUmVmZXJlbmNlcyAqKVxuXG50eXBlICdhIHJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cbmV4dGVybmFsIHJlZiA6ICdhIC0+ICdhIHJlZiA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsICggISApIDogJ2EgcmVmIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsICggOj0gKSA6ICdhIHJlZiAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcbmV4dGVybmFsIGluY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVpbmNyXCJcbmV4dGVybmFsIGRlY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVkZWNyXCJcblxuKCogUmVzdWx0IHR5cGUgKilcblxudHlwZSAoJ2EsJ2IpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2JcblxuKCogU3RyaW5nIGNvbnZlcnNpb24gZnVuY3Rpb25zICopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmV4dGVybmFsIGZvcm1hdF9mbG9hdCA6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcblxubGV0IHN0cmluZ19vZl9ib29sIGIgPVxuICBpZiBiIHRoZW4gXCJ0cnVlXCIgZWxzZSBcImZhbHNlXCJcbmxldCBib29sX29mX3N0cmluZyA9IGZ1bmN0aW9uXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IF8gLT4gaW52YWxpZF9hcmcgXCJib29sX29mX3N0cmluZ1wiXG5cbmxldCBib29sX29mX3N0cmluZ19vcHQgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IFNvbWUgdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBTb21lIGZhbHNlXG4gIHwgXyAtPiBOb25lXG5cbmxldCBzdHJpbmdfb2ZfaW50IG4gPVxuICBmb3JtYXRfaW50IFwiJWRcIiBuXG5cbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxuXG5sZXQgaW50X29mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IHByb3ZpZGUgdGhpcyBkaXJlY3RseSBhcyBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZS4gKilcbiAgdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5leHRlcm5hbCBzdHJpbmdfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcblxubGV0IHZhbGlkX2Zsb2F0X2xleGVtIHMgPVxuICBsZXQgbCA9IHN0cmluZ19sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA+PSBsIHRoZW4gcyBeIFwiLlwiIGVsc2VcbiAgICBtYXRjaCBzdHJpbmdfZ2V0IHMgaSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IGxvb3AgKGkgKyAxKVxuICAgIHwgXyAtPiBzXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgc3RyaW5nX29mX2Zsb2F0IGYgPSB2YWxpZF9mbG9hdF9sZXhlbSAoZm9ybWF0X2Zsb2F0IFwiJS4xMmdcIiBmKVxuXG5leHRlcm5hbCBmbG9hdF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRfb2Zfc3RyaW5nXCJcblxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IHByb3ZpZGUgdGhpcyBkaXJlY3RseSBhcyBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZS4gKilcbiAgdHJ5IFNvbWUgKGZsb2F0X29mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbigqIExpc3Qgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBMaXN0ICopXG5cbmxldCByZWMgKCBAICkgbDEgbDIgPVxuICBtYXRjaCBsMSB3aXRoXG4gICAgW10gLT4gbDJcbiAgfCBoZCA6OiB0bCAtPiBoZCA6OiAodGwgQCBsMilcblxuKCogSS9PIG9wZXJhdGlvbnMgKilcblxudHlwZSBpbl9jaGFubmVsXG50eXBlIG91dF9jaGFubmVsXG5cbmV4dGVybmFsIG9wZW5fZGVzY3JpcHRvcl9vdXQgOiBpbnQgLT4gb3V0X2NoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFwiXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3JfaW4gOiBpbnQgLT4gaW5fY2hhbm5lbCA9IFwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cIlxuXG5sZXQgc3RkaW4gPSBvcGVuX2Rlc2NyaXB0b3JfaW4gMFxubGV0IHN0ZG91dCA9IG9wZW5fZGVzY3JpcHRvcl9vdXQgMVxubGV0IHN0ZGVyciA9IG9wZW5fZGVzY3JpcHRvcl9vdXQgMlxuXG4oKiBHZW5lcmFsIG91dHB1dCBmdW5jdGlvbnMgKilcblxudHlwZSBvcGVuX2ZsYWcgPVxuICAgIE9wZW5fcmRvbmx5IHwgT3Blbl93cm9ubHkgfCBPcGVuX2FwcGVuZFxuICB8IE9wZW5fY3JlYXQgfCBPcGVuX3RydW5jIHwgT3Blbl9leGNsXG4gIHwgT3Blbl9iaW5hcnkgfCBPcGVuX3RleHQgfCBPcGVuX25vbmJsb2NrXG5cbmV4dGVybmFsIG9wZW5fZGVzYyA6IHN0cmluZyAtPiBvcGVuX2ZsYWcgbGlzdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX3N5c19vcGVuXCJcblxuZXh0ZXJuYWwgc2V0X291dF9jaGFubmVsX25hbWU6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiB1bml0ID1cbiAgXCJjYW1sX21sX3NldF9jaGFubmVsX25hbWVcIlxuXG5sZXQgb3Blbl9vdXRfZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0KG9wZW5fZGVzYyBuYW1lIG1vZGUgcGVybSkgaW5cbiAgc2V0X291dF9jaGFubmVsX25hbWUgYyBuYW1lO1xuICBjXG5cbmxldCBvcGVuX291dCBuYW1lID1cbiAgb3Blbl9vdXRfZ2VuIFtPcGVuX3dyb25seTsgT3Blbl9jcmVhdDsgT3Blbl90cnVuYzsgT3Blbl90ZXh0XSAwbzY2NiBuYW1lXG5cbmxldCBvcGVuX291dF9iaW4gbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fYmluYXJ5XSAwbzY2NiBuYW1lXG5cbmV4dGVybmFsIGZsdXNoIDogb3V0X2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9mbHVzaFwiXG5cbmV4dGVybmFsIG91dF9jaGFubmVsc19saXN0IDogdW5pdCAtPiBvdXRfY2hhbm5lbCBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdFwiXG5cbmxldCBmbHVzaF9hbGwgKCkgPVxuICBsZXQgcmVjIGl0ZXIgPSBmdW5jdGlvblxuICAgICAgW10gLT4gKClcbiAgICB8IGE6OmwgLT5cbiAgICAgICAgYmVnaW4gdHJ5XG4gICAgICAgICAgICBmbHVzaCBhXG4gICAgICAgIHdpdGggU3lzX2Vycm9yIF8gLT5cbiAgICAgICAgICAoKSAoKiBpZ25vcmUgY2hhbm5lbHMgY2xvc2VkIGR1cmluZyBhIHByZWNlZGluZyBmbHVzaC4gKilcbiAgICAgICAgZW5kO1xuICAgICAgICBpdGVyIGxcbiAgaW4gaXRlciAob3V0X2NoYW5uZWxzX2xpc3QgKCkpXG5cbmV4dGVybmFsIHVuc2FmZV9vdXRwdXQgOiBvdXRfY2hhbm5lbCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0cHV0X2J5dGVzXCJcbmV4dGVybmFsIHVuc2FmZV9vdXRwdXRfc3RyaW5nIDogb3V0X2NoYW5uZWwgLT4gc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0cHV0XCJcblxuZXh0ZXJuYWwgb3V0cHV0X2NoYXIgOiBvdXRfY2hhbm5lbCAtPiBjaGFyIC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2NoYXJcIlxuXG5sZXQgb3V0cHV0X2J5dGVzIG9jIHMgPVxuICB1bnNhZmVfb3V0cHV0IG9jIHMgMCAoYnl0ZXNfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXRfc3RyaW5nIG9jIHMgPVxuICB1bnNhZmVfb3V0cHV0X3N0cmluZyBvYyBzIDAgKHN0cmluZ19sZW5ndGggcylcblxubGV0IG91dHB1dCBvYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dFwiXG4gIGVsc2UgdW5zYWZlX291dHB1dCBvYyBzIG9mcyBsZW5cblxubGV0IG91dHB1dF9zdWJzdHJpbmcgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IHN0cmluZ19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwib3V0cHV0X3N1YnN0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyBvZnMgbGVuXG5cbmV4dGVybmFsIG91dHB1dF9ieXRlIDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2NoYXJcIlxuZXh0ZXJuYWwgb3V0cHV0X2JpbmFyeV9pbnQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfaW50XCJcblxuZXh0ZXJuYWwgbWFyc2hhbF90b19jaGFubmVsIDogb3V0X2NoYW5uZWwgLT4gJ2EgLT4gdW5pdCBsaXN0IC0+IHVuaXRcbiAgICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlXCJcbmxldCBvdXRwdXRfdmFsdWUgY2hhbiB2ID0gbWFyc2hhbF90b19jaGFubmVsIGNoYW4gdiBbXVxuXG5leHRlcm5hbCBzZWVrX291dCA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfb3V0XCJcbmV4dGVybmFsIHBvc19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfcG9zX291dFwiXG5leHRlcm5hbCBvdXRfY2hhbm5lbF9sZW5ndGggOiBvdXRfY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXCJcbmV4dGVybmFsIGNsb3NlX291dF9jaGFubmVsIDogb3V0X2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9vdXQgb2MgPSBmbHVzaCBvYzsgY2xvc2Vfb3V0X2NoYW5uZWwgb2NcbmxldCBjbG9zZV9vdXRfbm9lcnIgb2MgPVxuICAodHJ5IGZsdXNoIG9jIHdpdGggXyAtPiAoKSk7XG4gICh0cnkgY2xvc2Vfb3V0X2NoYW5uZWwgb2Mgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX291dCA6IG91dF9jaGFubmVsIC0+IGJvb2wgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBHZW5lcmFsIGlucHV0IGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBzZXRfaW5fY2hhbm5lbF9uYW1lOiBpbl9jaGFubmVsIC0+IHN0cmluZyAtPiB1bml0ID1cbiAgXCJjYW1sX21sX3NldF9jaGFubmVsX25hbWVcIlxuXG5sZXQgb3Blbl9pbl9nZW4gbW9kZSBwZXJtIG5hbWUgPVxuICBsZXQgYyA9IG9wZW5fZGVzY3JpcHRvcl9pbihvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9pbl9jaGFubmVsX25hbWUgYyBuYW1lO1xuICBjXG5cbmxldCBvcGVuX2luIG5hbWUgPVxuICBvcGVuX2luX2dlbiBbT3Blbl9yZG9ubHk7IE9wZW5fdGV4dF0gMCBuYW1lXG5cbmxldCBvcGVuX2luX2JpbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX2JpbmFyeV0gMCBuYW1lXG5cbmV4dGVybmFsIGlucHV0X2NoYXIgOiBpbl9jaGFubmVsIC0+IGNoYXIgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5cbmV4dGVybmFsIHVuc2FmZV9pbnB1dCA6IGluX2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9pbnB1dFwiXG5cbmxldCBpbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcImlucHV0XCJcbiAgZWxzZSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuXG5cbmxldCByZWMgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBsZW4gPD0gMCB0aGVuICgpIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IHVuc2FmZV9pbnB1dCBpYyBzIG9mcyBsZW4gaW5cbiAgICBpZiByID0gMFxuICAgIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICBlbHNlIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyAob2ZzICsgcikgKGxlbiAtIHIpXG4gIGVuZFxuXG5sZXQgcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwicmVhbGx5X2lucHV0XCJcbiAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVhbGx5X2lucHV0X3N0cmluZyBpYyBsZW4gPVxuICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSBsZW4gaW5cbiAgcmVhbGx5X2lucHV0IGljIHMgMCBsZW47XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG5leHRlcm5hbCBpbnB1dF9zY2FuX2xpbmUgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmVcIlxuXG5sZXQgaW5wdXRfbGluZSBjaGFuID1cbiAgbGV0IHJlYyBidWlsZF9yZXN1bHQgYnVmIHBvcyA9IGZ1bmN0aW9uXG4gICAgW10gLT4gYnVmXG4gIHwgaGQgOjogdGwgLT5cbiAgICAgIGxldCBsZW4gPSBieXRlc19sZW5ndGggaGQgaW5cbiAgICAgIGJ5dGVzX2JsaXQgaGQgMCBidWYgKHBvcyAtIGxlbikgbGVuO1xuICAgICAgYnVpbGRfcmVzdWx0IGJ1ZiAocG9zIC0gbGVuKSB0bCBpblxuICBsZXQgcmVjIHNjYW4gYWNjdSBsZW4gPVxuICAgIGxldCBuID0gaW5wdXRfc2Nhbl9saW5lIGNoYW4gaW5cbiAgICBpZiBuID0gMCB0aGVuIGJlZ2luICAgICAgICAgICAgICAgICAgICgqIG4gPSAwOiB3ZSBhcmUgYXQgRU9GICopXG4gICAgICBtYXRjaCBhY2N1IHdpdGhcbiAgICAgICAgW10gLT4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICAgIHwgXyAgLT4gYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gYWNjdVxuICAgIGVuZCBlbHNlIGlmIG4gPiAwIHRoZW4gYmVnaW4gICAgICAgICAgKCogbiA+IDA6IG5ld2xpbmUgZm91bmQgaW4gYnVmZmVyICopXG4gICAgICBsZXQgcmVzID0gYnl0ZXNfY3JlYXRlIChuIC0gMSkgaW5cbiAgICAgIGlnbm9yZSAodW5zYWZlX2lucHV0IGNoYW4gcmVzIDAgKG4gLSAxKSk7XG4gICAgICBpZ25vcmUgKGlucHV0X2NoYXIgY2hhbik7ICAgICAgICAgICAoKiBza2lwIHRoZSBuZXdsaW5lICopXG4gICAgICBtYXRjaCBhY2N1IHdpdGhcbiAgICAgICAgW10gLT4gcmVzXG4gICAgICB8ICBfIC0+IGxldCBsZW4gPSBsZW4gKyBuIC0gMSBpblxuICAgICAgICAgICAgICBidWlsZF9yZXN1bHQgKGJ5dGVzX2NyZWF0ZSBsZW4pIGxlbiAocmVzIDo6IGFjY3UpXG4gICAgZW5kIGVsc2UgYmVnaW4gICAgICAgICAgICAgICAgICAgICAgICAoKiBuIDwgMDogbmV3bGluZSBub3QgZm91bmQgKilcbiAgICAgIGxldCBiZWcgPSBieXRlc19jcmVhdGUgKC1uKSBpblxuICAgICAgaWdub3JlKHVuc2FmZV9pbnB1dCBjaGFuIGJlZyAwICgtbikpO1xuICAgICAgc2NhbiAoYmVnIDo6IGFjY3UpIChsZW4gLSBuKVxuICAgIGVuZFxuICBpbiBieXRlc191bnNhZmVfdG9fc3RyaW5nIChzY2FuIFtdIDApXG5cbmV4dGVybmFsIGlucHV0X2J5dGUgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9jaGFyXCJcbmV4dGVybmFsIGlucHV0X2JpbmFyeV9pbnQgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9pbnRcIlxuZXh0ZXJuYWwgaW5wdXRfdmFsdWUgOiBpbl9jaGFubmVsIC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlXCJcbmV4dGVybmFsIHNlZWtfaW4gOiBpbl9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfaW5cIlxuZXh0ZXJuYWwgcG9zX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfcG9zX2luXCJcbmV4dGVybmFsIGluX2NoYW5uZWxfbGVuZ3RoIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXCJcbmV4dGVybmFsIGNsb3NlX2luIDogaW5fY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2Nsb3NlX2NoYW5uZWxcIlxubGV0IGNsb3NlX2luX25vZXJyIGljID0gKHRyeSBjbG9zZV9pbiBpYyB3aXRoIF8gLT4gKCkpXG5leHRlcm5hbCBzZXRfYmluYXJ5X21vZGVfaW4gOiBpbl9jaGFubmVsIC0+IGJvb2wgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZVwiXG5cbigqIE91dHB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgb3V0cHV0ICopXG5cbmxldCBwcmludF9jaGFyIGMgPSBvdXRwdXRfY2hhciBzdGRvdXQgY1xubGV0IHByaW50X3N0cmluZyBzID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgc1xubGV0IHByaW50X2J5dGVzIHMgPSBvdXRwdXRfYnl0ZXMgc3Rkb3V0IHNcbmxldCBwcmludF9pbnQgaSA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IChzdHJpbmdfb2ZfaW50IGkpXG5sZXQgcHJpbnRfZmxvYXQgZiA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IChzdHJpbmdfb2ZfZmxvYXQgZilcbmxldCBwcmludF9lbmRsaW5lIHMgPVxuICBvdXRwdXRfc3RyaW5nIHN0ZG91dCBzOyBvdXRwdXRfY2hhciBzdGRvdXQgJ1xcbic7IGZsdXNoIHN0ZG91dFxubGV0IHByaW50X25ld2xpbmUgKCkgPSBvdXRwdXRfY2hhciBzdGRvdXQgJ1xcbic7IGZsdXNoIHN0ZG91dFxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGVycm9yICopXG5cbmxldCBwcmVycl9jaGFyIGMgPSBvdXRwdXRfY2hhciBzdGRlcnIgY1xubGV0IHByZXJyX3N0cmluZyBzID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgc1xubGV0IHByZXJyX2J5dGVzIHMgPSBvdXRwdXRfYnl0ZXMgc3RkZXJyIHNcbmxldCBwcmVycl9pbnQgaSA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIChzdHJpbmdfb2ZfaW50IGkpXG5sZXQgcHJlcnJfZmxvYXQgZiA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIChzdHJpbmdfb2ZfZmxvYXQgZilcbmxldCBwcmVycl9lbmRsaW5lIHMgPVxuICBvdXRwdXRfc3RyaW5nIHN0ZGVyciBzOyBvdXRwdXRfY2hhciBzdGRlcnIgJ1xcbic7IGZsdXNoIHN0ZGVyclxubGV0IHByZXJyX25ld2xpbmUgKCkgPSBvdXRwdXRfY2hhciBzdGRlcnIgJ1xcbic7IGZsdXNoIHN0ZGVyclxuXG4oKiBJbnB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgaW5wdXQgKilcblxubGV0IHJlYWRfbGluZSAoKSA9IGZsdXNoIHN0ZG91dDsgaW5wdXRfbGluZSBzdGRpblxubGV0IHJlYWRfaW50ICgpID0gaW50X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2ludF9vcHQgKCkgPSBpbnRfb2Zfc3RyaW5nX29wdChyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0ICgpID0gZmxvYXRfb2Zfc3RyaW5nKHJlYWRfbGluZSgpKVxubGV0IHJlYWRfZmxvYXRfb3B0ICgpID0gZmxvYXRfb2Zfc3RyaW5nX29wdChyZWFkX2xpbmUoKSlcblxuKCogT3BlcmF0aW9ucyBvbiBsYXJnZSBmaWxlcyAqKVxuXG5tb2R1bGUgTGFyZ2VGaWxlID1cbiAgc3RydWN0XG4gICAgZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfb3V0XzY0XCJcbiAgICBleHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfcG9zX291dF82NFwiXG4gICAgZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50NjRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XCJcbiAgICBleHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfaW5fNjRcIlxuICAgIGV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfcG9zX2luXzY0XCJcbiAgICBleHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XCJcbiAgZW5kXG5cbigqIEZvcm1hdHMgKilcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuICAgPSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcbiAgID0gRm9ybWF0IG9mICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm10XG4gICAgICAgICAgICAgICAqIHN0cmluZ1xuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA9ICgnYSwgJ2IsICdjLCAnYywgJ2MsICdkKSBmb3JtYXQ2XG5cbnR5cGUgKCdhLCAnYiwgJ2MpIGZvcm1hdCA9ICgnYSwgJ2IsICdjLCAnYykgZm9ybWF0NFxuXG5sZXQgc3RyaW5nX29mX2Zvcm1hdCAoRm9ybWF0IChfZm10LCBzdHIpKSA9IHN0clxuXG5leHRlcm5hbCBmb3JtYXRfb2Zfc3RyaW5nIDpcbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgKCBeXiApIChGb3JtYXQgKGZtdDEsIHN0cjEpKSAoRm9ybWF0IChmbXQyLCBzdHIyKSkgPVxuICBGb3JtYXQgKENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5jb25jYXRfZm10IGZtdDEgZm10MixcbiAgICAgICAgICBzdHIxIF4gXCIlLFwiIF4gc3RyMilcblxuKCogTWlzY2VsbGFuZW91cyAqKVxuXG5leHRlcm5hbCBzeXNfZXhpdCA6IGludCAtPiAnYSA9IFwiY2FtbF9zeXNfZXhpdFwiXG5cbigqIGZvciBhdF9leGl0ICopXG50eXBlICdhIGF0b21pY190XG5leHRlcm5hbCBhdG9taWNfbWFrZSA6ICdhIC0+ICdhIGF0b21pY190ID0gXCIlbWFrZW11dGFibGVcIlxuZXh0ZXJuYWwgYXRvbWljX2dldCA6ICdhIGF0b21pY190IC0+ICdhID0gXCIlYXRvbWljX2xvYWRcIlxuZXh0ZXJuYWwgYXRvbWljX2NvbXBhcmVfYW5kX3NldCA6ICdhIGF0b21pY190IC0+ICdhIC0+ICdhIC0+IGJvb2xcbiAgPSBcIiVhdG9taWNfY2FzXCJcblxubGV0IGV4aXRfZnVuY3Rpb24gPSBhdG9taWNfbWFrZSBmbHVzaF9hbGxcblxubGV0IHJlYyBhdF9leGl0IGYgPVxuICAoKiBNUFIjNzI1MywgTVBSIzc3OTY6IG1ha2Ugc3VyZSBcImZcIiBpcyBleGVjdXRlZCBvbmx5IG9uY2UgKilcbiAgbGV0IGZfeWV0X3RvX3J1biA9IGF0b21pY19tYWtlIHRydWUgaW5cbiAgbGV0IG9sZF9leGl0ID0gYXRvbWljX2dldCBleGl0X2Z1bmN0aW9uIGluXG4gIGxldCBuZXdfZXhpdCAoKSA9XG4gICAgaWYgYXRvbWljX2NvbXBhcmVfYW5kX3NldCBmX3lldF90b19ydW4gdHJ1ZSBmYWxzZSB0aGVuIGYgKCkgO1xuICAgIG9sZF9leGl0ICgpXG4gIGluXG4gIGxldCBzdWNjZXNzID0gYXRvbWljX2NvbXBhcmVfYW5kX3NldCBleGl0X2Z1bmN0aW9uIG9sZF9leGl0IG5ld19leGl0IGluXG4gIGlmIG5vdCBzdWNjZXNzIHRoZW4gYXRfZXhpdCBmXG5cbmxldCBkb19kb21haW5fbG9jYWxfYXRfZXhpdCA9IHJlZiAoZnVuICgpIC0+ICgpKVxuXG5sZXQgZG9fYXRfZXhpdCAoKSA9XG4gICghZG9fZG9tYWluX2xvY2FsX2F0X2V4aXQpICgpO1xuICAoYXRvbWljX2dldCBleGl0X2Z1bmN0aW9uKSAoKVxuXG5sZXQgZXhpdCByZXRjb2RlID1cbiAgZG9fYXRfZXhpdCAoKTtcbiAgc3lzX2V4aXQgcmV0Y29kZVxuXG5sZXQgXyA9IHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIgZG9fYXRfZXhpdFxuXG4oKk1PRFVMRV9BTElBU0VTKilcbm1vZHVsZSBBcmcgICAgICAgICAgICA9IEFyZ1xubW9kdWxlIEFycmF5ICAgICAgICAgID0gQXJyYXlcbm1vZHVsZSBBcnJheUxhYmVscyAgICA9IEFycmF5TGFiZWxzXG5tb2R1bGUgQXRvbWljICAgICAgICAgPSBBdG9taWNcbm1vZHVsZSBCaWdhcnJheSAgICAgICA9IEJpZ2FycmF5XG5tb2R1bGUgQm9vbCAgICAgICAgICAgPSBCb29sXG5tb2R1bGUgQnVmZmVyICAgICAgICAgPSBCdWZmZXJcbm1vZHVsZSBCeXRlcyAgICAgICAgICA9IEJ5dGVzXG5tb2R1bGUgQnl0ZXNMYWJlbHMgICAgPSBCeXRlc0xhYmVsc1xubW9kdWxlIENhbGxiYWNrICAgICAgID0gQ2FsbGJhY2tcbm1vZHVsZSBDaGFyICAgICAgICAgICA9IENoYXJcbm1vZHVsZSBDb21wbGV4ICAgICAgICA9IENvbXBsZXhcbm1vZHVsZSBDb25kaXRpb24gICAgICA9IENvbmRpdGlvblxubW9kdWxlIERpZ2VzdCAgICAgICAgID0gRGlnZXN0XG5tb2R1bGUgRG9tYWluICAgICAgICAgPSBEb21haW5cbm1vZHVsZSBFZmZlY3QgICAgICAgICA9IEVmZmVjdFxubW9kdWxlIEVpdGhlciAgICAgICAgID0gRWl0aGVyXG5tb2R1bGUgRXBoZW1lcm9uICAgICAgPSBFcGhlbWVyb25cbm1vZHVsZSBGaWxlbmFtZSAgICAgICA9IEZpbGVuYW1lXG5tb2R1bGUgRmxvYXQgICAgICAgICAgPSBGbG9hdFxubW9kdWxlIEZvcm1hdCAgICAgICAgID0gRm9ybWF0XG5tb2R1bGUgRnVuICAgICAgICAgICAgPSBGdW5cbm1vZHVsZSBHYyAgICAgICAgICAgICA9IEdjXG5tb2R1bGUgSGFzaHRibCAgICAgICAgPSBIYXNodGJsXG5tb2R1bGUgSW5fY2hhbm5lbCAgICAgPSBJbl9jaGFubmVsXG5tb2R1bGUgSW50ICAgICAgICAgICAgPSBJbnRcbm1vZHVsZSBJbnQzMiAgICAgICAgICA9IEludDMyXG5tb2R1bGUgSW50NjQgICAgICAgICAgPSBJbnQ2NFxubW9kdWxlIExhenkgICAgICAgICAgID0gTGF6eVxubW9kdWxlIExleGluZyAgICAgICAgID0gTGV4aW5nXG5tb2R1bGUgTGlzdCAgICAgICAgICAgPSBMaXN0XG5tb2R1bGUgTGlzdExhYmVscyAgICAgPSBMaXN0TGFiZWxzXG5tb2R1bGUgTWFwICAgICAgICAgICAgPSBNYXBcbm1vZHVsZSBNYXJzaGFsICAgICAgICA9IE1hcnNoYWxcbm1vZHVsZSBNb3JlTGFiZWxzICAgICA9IE1vcmVMYWJlbHNcbm1vZHVsZSBNdXRleCAgICAgICAgICA9IE11dGV4XG5tb2R1bGUgTmF0aXZlaW50ICAgICAgPSBOYXRpdmVpbnRcbm1vZHVsZSBPYmogICAgICAgICAgICA9IE9ialxubW9kdWxlIE9vICAgICAgICAgICAgID0gT29cbm1vZHVsZSBPcHRpb24gICAgICAgICA9IE9wdGlvblxubW9kdWxlIE91dF9jaGFubmVsICAgID0gT3V0X2NoYW5uZWxcbm1vZHVsZSBQYXJzaW5nICAgICAgICA9IFBhcnNpbmdcbm1vZHVsZSBQcmludGV4YyAgICAgICA9IFByaW50ZXhjXG5tb2R1bGUgUHJpbnRmICAgICAgICAgPSBQcmludGZcbm1vZHVsZSBRdWV1ZSAgICAgICAgICA9IFF1ZXVlXG5tb2R1bGUgUmFuZG9tICAgICAgICAgPSBSYW5kb21cbm1vZHVsZSBSZXN1bHQgICAgICAgICA9IFJlc3VsdFxubW9kdWxlIFNjYW5mICAgICAgICAgID0gU2NhbmZcbm1vZHVsZSBTZW1hcGhvcmUgICAgICA9IFNlbWFwaG9yZVxubW9kdWxlIFNlcSAgICAgICAgICAgID0gU2VxXG5tb2R1bGUgU2V0ICAgICAgICAgICAgPSBTZXRcbm1vZHVsZSBTdGFjayAgICAgICAgICA9IFN0YWNrXG5tb2R1bGUgU3RkTGFiZWxzICAgICAgPSBTdGRMYWJlbHNcbm1vZHVsZSBTdHJpbmcgICAgICAgICA9IFN0cmluZ1xubW9kdWxlIFN0cmluZ0xhYmVscyAgID0gU3RyaW5nTGFiZWxzXG5tb2R1bGUgU3lzICAgICAgICAgICAgPSBTeXNcbm1vZHVsZSBVY2hhciAgICAgICAgICA9IFVjaGFyXG5tb2R1bGUgVW5pdCAgICAgICAgICAgPSBVbml0XG5tb2R1bGUgV2VhayAgICAgICAgICAgPSBXZWFrXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEdhYnJpZWwgU2NoZXJlciwgcHJvamV0IFBhcnNpZmFsLCBJTlJJQSBTYWNsYXkgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE5IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgKCdhLCAnYikgdCA9IExlZnQgb2YgJ2EgfCBSaWdodCBvZiAnYlxuXG5sZXQgbGVmdCB2ID0gTGVmdCB2XG5sZXQgcmlnaHQgdiA9IFJpZ2h0IHZcblxubGV0IGlzX2xlZnQgPSBmdW5jdGlvblxufCBMZWZ0IF8gLT4gdHJ1ZVxufCBSaWdodCBfIC0+IGZhbHNlXG5cbmxldCBpc19yaWdodCA9IGZ1bmN0aW9uXG58IExlZnQgXyAtPiBmYWxzZVxufCBSaWdodCBfIC0+IHRydWVcblxubGV0IGZpbmRfbGVmdCA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBTb21lIHZcbnwgUmlnaHQgXyAtPiBOb25lXG5cbmxldCBmaW5kX3JpZ2h0ID0gZnVuY3Rpb25cbnwgTGVmdCBfIC0+IE5vbmVcbnwgUmlnaHQgdiAtPiBTb21lIHZcblxubGV0IG1hcF9sZWZ0IGYgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gTGVmdCAoZiB2KVxufCBSaWdodCBfIGFzIGUgLT4gZVxuXG5sZXQgbWFwX3JpZ2h0IGYgPSBmdW5jdGlvblxufCBMZWZ0IF8gYXMgZSAtPiBlXG58IFJpZ2h0IHYgLT4gUmlnaHQgKGYgdilcblxubGV0IG1hcCB+bGVmdCB+cmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gTGVmdCAobGVmdCB2KVxufCBSaWdodCB2IC0+IFJpZ2h0IChyaWdodCB2KVxuXG5sZXQgZm9sZCB+bGVmdCB+cmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gbGVmdCB2XG58IFJpZ2h0IHYgLT4gcmlnaHQgdlxuXG5sZXQgaXRlciA9IGZvbGRcblxubGV0IGZvcl9hbGwgPSBmb2xkXG5cbmxldCBlcXVhbCB+bGVmdCB+cmlnaHQgZTEgZTIgPSBtYXRjaCBlMSwgZTIgd2l0aFxufCBMZWZ0IHYxLCBMZWZ0IHYyIC0+IGxlZnQgdjEgdjJcbnwgUmlnaHQgdjEsIFJpZ2h0IHYyIC0+IHJpZ2h0IHYxIHYyXG58IExlZnQgXywgUmlnaHQgXyB8IFJpZ2h0IF8sIExlZnQgXyAtPiBmYWxzZVxuXG5sZXQgY29tcGFyZSB+bGVmdCB+cmlnaHQgZTEgZTIgPSBtYXRjaCBlMSwgZTIgd2l0aFxufCBMZWZ0IHYxLCBMZWZ0IHYyIC0+IGxlZnQgdjEgdjJcbnwgUmlnaHQgdjEsIFJpZ2h0IHYyIC0+IHJpZ2h0IHYxIHYyXG58IExlZnQgXywgUmlnaHQgXyAtPiAoLTEpXG58IFJpZ2h0IF8sIExlZnQgXyAtPiAxXG4iLCIoKiBAY29uZmlndXJlX2lucHV0QCAqKVxuIzMgXCJzeXMubWwuaW5cIlxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIGJhY2tlbmRfdHlwZSA9XG4gIHwgTmF0aXZlXG4gIHwgQnl0ZWNvZGVcbiAgfCBPdGhlciBvZiBzdHJpbmdcbigqIFN5c3RlbSBpbnRlcmZhY2UgKilcblxuZXh0ZXJuYWwgZ2V0X2NvbmZpZzogdW5pdCAtPiBzdHJpbmcgKiBpbnQgKiBib29sID0gXCJjYW1sX3N5c19nZXRfY29uZmlnXCJcbmV4dGVybmFsIGdldF9leGVjdXRhYmxlX25hbWUgOiB1bml0IC0+IHN0cmluZyA9IFwiY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lXCJcbmV4dGVybmFsIGFyZ3YgOiBzdHJpbmcgYXJyYXkgPSBcIiVzeXNfYXJndlwiXG5leHRlcm5hbCBiaWdfZW5kaWFuIDogdW5pdCAtPiBib29sID0gXCIlYmlnX2VuZGlhblwiXG5leHRlcm5hbCB3b3JkX3NpemUgOiB1bml0IC0+IGludCA9IFwiJXdvcmRfc2l6ZVwiXG5leHRlcm5hbCBpbnRfc2l6ZSA6IHVuaXQgLT4gaW50ID0gXCIlaW50X3NpemVcIlxuZXh0ZXJuYWwgbWF4X3dvc2l6ZSA6IHVuaXQgLT4gaW50ID0gXCIlbWF4X3dvc2l6ZVwiXG5leHRlcm5hbCB1bml4IDogdW5pdCAtPiBib29sID0gXCIlb3N0eXBlX3VuaXhcIlxuZXh0ZXJuYWwgd2luMzIgOiB1bml0IC0+IGJvb2wgPSBcIiVvc3R5cGVfd2luMzJcIlxuZXh0ZXJuYWwgY3lnd2luIDogdW5pdCAtPiBib29sID0gXCIlb3N0eXBlX2N5Z3dpblwiXG5leHRlcm5hbCBnZXRfYmFja2VuZF90eXBlIDogdW5pdCAtPiBiYWNrZW5kX3R5cGUgPSBcIiViYWNrZW5kX3R5cGVcIlxuXG5sZXQgZXhlY3V0YWJsZV9uYW1lID0gZ2V0X2V4ZWN1dGFibGVfbmFtZSgpXG5sZXQgKG9zX3R5cGUsIF8sIF8pID0gZ2V0X2NvbmZpZygpXG5sZXQgYmFja2VuZF90eXBlID0gZ2V0X2JhY2tlbmRfdHlwZSAoKVxubGV0IGJpZ19lbmRpYW4gPSBiaWdfZW5kaWFuICgpXG5sZXQgd29yZF9zaXplID0gd29yZF9zaXplICgpXG5sZXQgaW50X3NpemUgPSBpbnRfc2l6ZSAoKVxubGV0IHVuaXggPSB1bml4ICgpXG5sZXQgd2luMzIgPSB3aW4zMiAoKVxubGV0IGN5Z3dpbiA9IGN5Z3dpbiAoKVxubGV0IG1heF9hcnJheV9sZW5ndGggPSBtYXhfd29zaXplICgpXG5sZXQgbWF4X2Zsb2F0YXJyYXlfbGVuZ3RoID0gbWF4X2FycmF5X2xlbmd0aCAvICg2NCAvIHdvcmRfc2l6ZSlcbmxldCBtYXhfc3RyaW5nX2xlbmd0aCA9IHdvcmRfc2l6ZSAvIDggKiBtYXhfYXJyYXlfbGVuZ3RoIC0gMVxuZXh0ZXJuYWwgcnVudGltZV92YXJpYW50IDogdW5pdCAtPiBzdHJpbmcgPSBcImNhbWxfcnVudGltZV92YXJpYW50XCJcbmV4dGVybmFsIHJ1bnRpbWVfcGFyYW1ldGVycyA6IHVuaXQgLT4gc3RyaW5nID0gXCJjYW1sX3J1bnRpbWVfcGFyYW1ldGVyc1wiXG5cbmV4dGVybmFsIGZpbGVfZXhpc3RzOiBzdHJpbmcgLT4gYm9vbCA9IFwiY2FtbF9zeXNfZmlsZV9leGlzdHNcIlxuZXh0ZXJuYWwgaXNfZGlyZWN0b3J5IDogc3RyaW5nIC0+IGJvb2wgPSBcImNhbWxfc3lzX2lzX2RpcmVjdG9yeVwiXG5leHRlcm5hbCByZW1vdmU6IHN0cmluZyAtPiB1bml0ID0gXCJjYW1sX3N5c19yZW1vdmVcIlxuZXh0ZXJuYWwgcmVuYW1lIDogc3RyaW5nIC0+IHN0cmluZyAtPiB1bml0ID0gXCJjYW1sX3N5c19yZW5hbWVcIlxuZXh0ZXJuYWwgZ2V0ZW52OiBzdHJpbmcgLT4gc3RyaW5nID0gXCJjYW1sX3N5c19nZXRlbnZcIlxuXG5sZXQgZ2V0ZW52X29wdCBzID1cbiAgKCogVE9ETzogZXhwb3NlIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlIGRpcmVjdGx5LiAqKVxuICB0cnkgU29tZSAoZ2V0ZW52IHMpXG4gIHdpdGggTm90X2ZvdW5kIC0+IE5vbmVcblxuZXh0ZXJuYWwgY29tbWFuZDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmRcIlxuZXh0ZXJuYWwgdGltZTogdW5pdCAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfc3lzX3RpbWVcIiBcImNhbWxfc3lzX3RpbWVfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjaGRpcjogc3RyaW5nIC0+IHVuaXQgPSBcImNhbWxfc3lzX2NoZGlyXCJcbmV4dGVybmFsIG1rZGlyOiBzdHJpbmcgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfc3lzX21rZGlyXCJcbmV4dGVybmFsIHJtZGlyOiBzdHJpbmcgLT4gdW5pdCA9IFwiY2FtbF9zeXNfcm1kaXJcIlxuZXh0ZXJuYWwgZ2V0Y3dkOiB1bml0IC0+IHN0cmluZyA9IFwiY2FtbF9zeXNfZ2V0Y3dkXCJcbmV4dGVybmFsIHJlYWRkaXIgOiBzdHJpbmcgLT4gc3RyaW5nIGFycmF5ID0gXCJjYW1sX3N5c19yZWFkX2RpcmVjdG9yeVwiXG5cbmxldCBpbnRlcmFjdGl2ZSA9IHJlZiBmYWxzZVxuXG50eXBlIHNpZ25hbF9iZWhhdmlvciA9XG4gICAgU2lnbmFsX2RlZmF1bHRcbiAgfCBTaWduYWxfaWdub3JlXG4gIHwgU2lnbmFsX2hhbmRsZSBvZiAoaW50IC0+IHVuaXQpXG5cbmV4dGVybmFsIHNpZ25hbCA6IGludCAtPiBzaWduYWxfYmVoYXZpb3IgLT4gc2lnbmFsX2JlaGF2aW9yXG4gICAgICAgICAgICAgICAgPSBcImNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlclwiXG5cbmxldCBzZXRfc2lnbmFsIHNpZ19udW0gc2lnX2JlaCA9IGlnbm9yZShzaWduYWwgc2lnX251bSBzaWdfYmVoKVxuXG5sZXQgc2lnYWJydCA9IC0xXG5sZXQgc2lnYWxybSA9IC0yXG5sZXQgc2lnZnBlID0gLTNcbmxldCBzaWdodXAgPSAtNFxubGV0IHNpZ2lsbCA9IC01XG5sZXQgc2lnaW50ID0gLTZcbmxldCBzaWdraWxsID0gLTdcbmxldCBzaWdwaXBlID0gLThcbmxldCBzaWdxdWl0ID0gLTlcbmxldCBzaWdzZWd2ID0gLTEwXG5sZXQgc2lndGVybSA9IC0xMVxubGV0IHNpZ3VzcjEgPSAtMTJcbmxldCBzaWd1c3IyID0gLTEzXG5sZXQgc2lnY2hsZCA9IC0xNFxubGV0IHNpZ2NvbnQgPSAtMTVcbmxldCBzaWdzdG9wID0gLTE2XG5sZXQgc2lndHN0cCA9IC0xN1xubGV0IHNpZ3R0aW4gPSAtMThcbmxldCBzaWd0dG91ID0gLTE5XG5sZXQgc2lndnRhbHJtID0gLTIwXG5sZXQgc2lncHJvZiA9IC0yMVxubGV0IHNpZ2J1cyA9IC0yMlxubGV0IHNpZ3BvbGwgPSAtMjNcbmxldCBzaWdzeXMgPSAtMjRcbmxldCBzaWd0cmFwID0gLTI1XG5sZXQgc2lndXJnID0gLTI2XG5sZXQgc2lneGNwdSA9IC0yN1xubGV0IHNpZ3hmc3ogPSAtMjhcblxuZXhjZXB0aW9uIEJyZWFrXG5cbmxldCBjYXRjaF9icmVhayBvbiA9XG4gIGlmIG9uIHRoZW5cbiAgICBzZXRfc2lnbmFsIHNpZ2ludCAoU2lnbmFsX2hhbmRsZShmdW4gXyAtPiByYWlzZSBCcmVhaykpXG4gIGVsc2VcbiAgICBzZXRfc2lnbmFsIHNpZ2ludCBTaWduYWxfZGVmYXVsdFxuXG5cbmV4dGVybmFsIGVuYWJsZV9ydW50aW1lX3dhcm5pbmdzOiBib29sIC0+IHVuaXQgPVxuICBcImNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3NcIlxuZXh0ZXJuYWwgcnVudGltZV93YXJuaW5nc19lbmFibGVkOiB1bml0IC0+IGJvb2wgPVxuICBcImNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkXCJcblxuKCogVGhlIHZlcnNpb24gc3RyaW5nIGlzIGZvdW5kIGluIGZpbGUgLi4vVkVSU0lPTiAqKVxuXG5sZXQgb2NhbWxfdmVyc2lvbiA9IFwiQFZFUlNJT05AXCJcblxubGV0IGRldmVsb3BtZW50X3ZlcnNpb24gPSBAT0NBTUxfREVWRUxPUE1FTlRfVkVSU0lPTkBcblxudHlwZSBleHRyYV9wcmVmaXggPSBQbHVzIHwgVGlsZGVcblxudHlwZSBleHRyYV9pbmZvID0gZXh0cmFfcHJlZml4ICogc3RyaW5nXG5cbnR5cGUgb2NhbWxfcmVsZWFzZV9pbmZvID0ge1xuICBtYWpvciA6IGludDtcbiAgbWlub3IgOiBpbnQ7XG4gIHBhdGNobGV2ZWwgOiBpbnQ7XG4gIGV4dHJhIDogZXh0cmFfaW5mbyBvcHRpb25cbn1cblxubGV0IG9jYW1sX3JlbGVhc2UgPSB7XG4gIG1ham9yID0gQE9DQU1MX1ZFUlNJT05fTUFKT1JAO1xuICBtaW5vciA9IEBPQ0FNTF9WRVJTSU9OX01JTk9SQDtcbiAgcGF0Y2hsZXZlbCA9IEBPQ0FNTF9WRVJTSU9OX1BBVENITEVWRUxAO1xuICBleHRyYSA9IEBPQ0FNTF9SRUxFQVNFX0VYVFJBQFxufVxuXG4oKiBPcHRpbWl6YXRpb24gKilcblxuZXh0ZXJuYWwgb3BhcXVlX2lkZW50aXR5IDogJ2EgLT4gJ2EgPSBcIiVvcGFxdWVcIlxuXG5tb2R1bGUgSW1tZWRpYXRlNjQgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgTm9uX2ltbWVkaWF0ZSA9IHNpZ1xuICAgIHR5cGUgdFxuICBlbmRcbiAgbW9kdWxlIHR5cGUgSW1tZWRpYXRlID0gc2lnXG4gICAgdHlwZSB0IFtAQGltbWVkaWF0ZV1cbiAgZW5kXG5cbiAgbW9kdWxlIE1ha2UoSW1tZWRpYXRlIDogSW1tZWRpYXRlKShOb25faW1tZWRpYXRlIDogTm9uX2ltbWVkaWF0ZSkgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgW0BAaW1tZWRpYXRlNjRdXG4gICAgdHlwZSAnYSByZXByID1cbiAgICAgIHwgSW1tZWRpYXRlIDogSW1tZWRpYXRlLnQgcmVwclxuICAgICAgfCBOb25faW1tZWRpYXRlIDogTm9uX2ltbWVkaWF0ZS50IHJlcHJcbiAgICBleHRlcm5hbCBtYWdpYyA6IF8gcmVwciAtPiB0IHJlcHIgPSBcIiVpZGVudGl0eVwiXG4gICAgbGV0IHJlcHIgPVxuICAgICAgaWYgd29yZF9zaXplID0gNjQgdGhlblxuICAgICAgICBtYWdpYyBJbW1lZGlhdGVcbiAgICAgIGVsc2VcbiAgICAgICAgbWFnaWMgTm9uX2ltbWVkaWF0ZVxuICBlbmRcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBPcGVyYXRpb25zIG9uIGludGVybmFsIHJlcHJlc2VudGF0aW9ucyBvZiB2YWx1ZXMgKilcblxudHlwZSB0XG5cbnR5cGUgcmF3X2RhdGEgPSBuYXRpdmVpbnRcblxuZXh0ZXJuYWwgcmVwciA6ICdhIC0+IHQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBvYmogOiB0IC0+ICdhID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgbWFnaWMgOiAnYSAtPiAnYiA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGlzX2ludCA6IHQgLT4gYm9vbCA9IFwiJW9ial9pc19pbnRcIlxubGV0IFtAaW5saW5lIGFsd2F5c10gaXNfYmxvY2sgYSA9IG5vdCAoaXNfaW50IGEpXG5leHRlcm5hbCB0YWcgOiB0IC0+IGludCA9IFwiY2FtbF9vYmpfdGFnXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpemUgOiB0IC0+IGludCA9IFwiJW9ial9zaXplXCJcbmV4dGVybmFsIHJlYWNoYWJsZV93b3JkcyA6IHQgLT4gaW50ID0gXCJjYW1sX29ial9yZWFjaGFibGVfd29yZHNcIlxuZXh0ZXJuYWwgZmllbGQgOiB0IC0+IGludCAtPiB0ID0gXCIlb2JqX2ZpZWxkXCJcbmV4dGVybmFsIHNldF9maWVsZCA6IHQgLT4gaW50IC0+IHQgLT4gdW5pdCA9IFwiJW9ial9zZXRfZmllbGRcIlxuZXh0ZXJuYWwgY29tcGFyZV9hbmRfc3dhcF9maWVsZCA6IHQgLT4gaW50IC0+IHQgLT4gdCAtPiBib29sXG4gID0gXCJjYW1sX29ial9jb21wYXJlX2FuZF9zd2FwXCJcbmV4dGVybmFsIGlzX3NoYXJlZCA6IHQgLT4gYm9vbCA9IFwiY2FtbF9vYmpfaXNfc2hhcmVkXCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRhcnJheV9nZXRcIlxuZXh0ZXJuYWwgZmxvYXRhcnJheV9zZXQgOlxuICAgIGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcImNhbWxfZmxvYXRhcnJheV9zZXRcIlxubGV0IFtAaW5saW5lIGFsd2F5c10gZG91YmxlX2ZpZWxkIHggaSA9IGZsb2F0YXJyYXlfZ2V0IChvYmogeCA6IGZsb2F0YXJyYXkpIGlcbmxldCBbQGlubGluZSBhbHdheXNdIHNldF9kb3VibGVfZmllbGQgeCBpIHYgPVxuICBmbG9hdGFycmF5X3NldCAob2JqIHggOiBmbG9hdGFycmF5KSBpIHZcbmV4dGVybmFsIHJhd19maWVsZCA6IHQgLT4gaW50IC0+IHJhd19kYXRhID0gXCJjYW1sX29ial9yYXdfZmllbGRcIlxuZXh0ZXJuYWwgc2V0X3Jhd19maWVsZCA6IHQgLT4gaW50IC0+IHJhd19kYXRhIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX29ial9zZXRfcmF3X2ZpZWxkXCJcblxuZXh0ZXJuYWwgbmV3X2Jsb2NrIDogaW50IC0+IGludCAtPiB0ID0gXCJjYW1sX29ial9ibG9ja1wiXG5leHRlcm5hbCBkdXAgOiB0IC0+IHQgPSBcImNhbWxfb2JqX2R1cFwiXG5leHRlcm5hbCBhZGRfb2Zmc2V0IDogdCAtPiBJbnQzMi50IC0+IHQgPSBcImNhbWxfb2JqX2FkZF9vZmZzZXRcIlxuZXh0ZXJuYWwgd2l0aF90YWcgOiBpbnQgLT4gdCAtPiB0ID0gXCJjYW1sX29ial93aXRoX3RhZ1wiXG5cbmxldCBmaXJzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMFxubGV0IGxhc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yX3RhZyA9IDI0M1xuXG5sZXQgZm9yY2luZ190YWcgPSAyNDRcbmxldCBjb250X3RhZyA9IDI0NVxubGV0IGxhenlfdGFnID0gMjQ2XG5sZXQgY2xvc3VyZV90YWcgPSAyNDdcbmxldCBvYmplY3RfdGFnID0gMjQ4XG5sZXQgaW5maXhfdGFnID0gMjQ5XG5sZXQgZm9yd2FyZF90YWcgPSAyNTBcblxubGV0IG5vX3NjYW5fdGFnID0gMjUxXG5cbmxldCBhYnN0cmFjdF90YWcgPSAyNTFcbmxldCBzdHJpbmdfdGFnID0gMjUyXG5sZXQgZG91YmxlX3RhZyA9IDI1M1xubGV0IGRvdWJsZV9hcnJheV90YWcgPSAyNTRcbmxldCBjdXN0b21fdGFnID0gMjU1XG5cblxubGV0IGludF90YWcgPSAxMDAwXG5sZXQgb3V0X29mX2hlYXBfdGFnID0gMTAwMVxubGV0IHVuYWxpZ25lZF90YWcgPSAxMDAyXG5cbm1vZHVsZSBDbG9zdXJlID0gc3RydWN0XG4gIHR5cGUgaW5mbyA9IHtcbiAgICBhcml0eTogaW50O1xuICAgIHN0YXJ0X2VudjogaW50O1xuICB9XG5cbiAgbGV0IGluZm9fb2ZfcmF3IChpbmZvIDogbmF0aXZlaW50KSA9XG4gICAgbGV0IG9wZW4gTmF0aXZlaW50IGluXG4gICAgbGV0IGFyaXR5ID1cbiAgICAgICgqIHNpZ25lZDogbmVnYXRpdmUgZm9yIHR1cGxlZCBmdW5jdGlvbnMgKilcbiAgICAgIGlmIFN5cy53b3JkX3NpemUgPSA2NCB0aGVuXG4gICAgICAgIHRvX2ludCAoc2hpZnRfcmlnaHQgaW5mbyA1NilcbiAgICAgIGVsc2VcbiAgICAgICAgdG9faW50IChzaGlmdF9yaWdodCBpbmZvIDI0KVxuICAgIGluXG4gICAgbGV0IHN0YXJ0X2VudiA9XG4gICAgICAoKiBzdGFydF9lbnYgaXMgdW5zaWduZWQsIGJ1dCB3ZSBrbm93IGl0IGNhbiBhbHdheXMgZml0IGFuIE9DYW1sXG4gICAgICAgICBpbnRlZ2VyIHNvIHdlIHVzZSBbdG9faW50XSBpbnN0ZWFkIG9mIFt1bnNpZ25lZF90b19pbnRdLiAqKVxuICAgICAgdG9faW50IChzaGlmdF9yaWdodF9sb2dpY2FsIChzaGlmdF9sZWZ0IGluZm8gOCkgOSkgaW5cbiAgICB7IGFyaXR5OyBzdGFydF9lbnYgfVxuXG4gICgqIG5vdGU6IHdlIGV4cGVjdCBhIGNsb3N1cmUsIG5vdCBhbiBpbmZpeCBwb2ludGVyICopXG4gIGxldCBpbmZvIChvYmogOiB0KSA9XG4gICAgYXNzZXJ0ICh0YWcgb2JqID0gY2xvc3VyZV90YWcpO1xuICAgIGluZm9fb2ZfcmF3IChyYXdfZmllbGQgb2JqIDEpXG5lbmRcblxubW9kdWxlIEV4dGVuc2lvbl9jb25zdHJ1Y3RvciA9XG5zdHJ1Y3RcbiAgdHlwZSB0ID0gZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXG4gIGxldCBvZl92YWwgeCA9XG4gICAgbGV0IHggPSByZXByIHggaW5cbiAgICBsZXQgc2xvdCA9XG4gICAgICBpZiAoaXNfYmxvY2sgeCkgJiYgKHRhZyB4KSA8PiBvYmplY3RfdGFnICYmIChzaXplIHgpID49IDEgdGhlbiBmaWVsZCB4IDBcbiAgICAgIGVsc2UgeFxuICAgIGluXG4gICAgbGV0IG5hbWUgPVxuICAgICAgaWYgKGlzX2Jsb2NrIHNsb3QpICYmICh0YWcgc2xvdCkgPSBvYmplY3RfdGFnIHRoZW4gZmllbGQgc2xvdCAwXG4gICAgICBlbHNlIGludmFsaWRfYXJnIFwiT2JqLmV4dGVuc2lvbl9jb25zdHJ1Y3RvclwiXG4gICAgaW5cbiAgICAgIGlmICh0YWcgbmFtZSkgPSBzdHJpbmdfdGFnIHRoZW4gKG9iaiBzbG90IDogdClcbiAgICAgIGVsc2UgaW52YWxpZF9hcmcgXCJPYmouZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXCJcblxuICBsZXQgW0BpbmxpbmUgYWx3YXlzXSBuYW1lIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDApIDogc3RyaW5nKVxuXG4gIGxldCBbQGlubGluZSBhbHdheXNdIGlkIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDEpIDogaW50KVxuZW5kXG5cbm1vZHVsZSBFcGhlbWVyb24gPSBzdHJ1Y3RcbiAgdHlwZSBvYmpfdCA9IHRcblxuICB0eXBlIHQgKCoqIGVwaGVtZXJvbiAqKVxuXG4gICAoKiogVG8gY2hhbmdlIGluIHN5bmMgd2l0aCB3ZWFrLmggKilcbiAgbGV0IGFkZGl0aW9uYWxfdmFsdWVzID0gMlxuICBsZXQgbWF4X2VwaGVfbGVuZ3RoID0gU3lzLm1heF9hcnJheV9sZW5ndGggLSBhZGRpdGlvbmFsX3ZhbHVlc1xuXG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiB0ID0gXCJjYW1sX2VwaGVfY3JlYXRlXCJcbiAgbGV0IGNyZWF0ZSBsID1cbiAgICBpZiBub3QgKDAgPD0gbCAmJiBsIDw9IG1heF9lcGhlX2xlbmd0aCkgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJPYmouRXBoZW1lcm9uLmNyZWF0ZVwiO1xuICAgIGNyZWF0ZSBsXG5cbiAgbGV0IGxlbmd0aCB4ID0gc2l6ZShyZXByIHgpIC0gYWRkaXRpb25hbF92YWx1ZXNcblxuICBsZXQgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIG1zZyA9XG4gICAgaWYgbm90ICgwIDw9IG8gJiYgbyA8IGxlbmd0aCBlKSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBtc2dcblxuICBleHRlcm5hbCBnZXRfa2V5OiB0IC0+IGludCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfa2V5XCJcbiAgbGV0IGdldF9rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmdldF9rZXlcIjtcbiAgICBnZXRfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGdldF9rZXlfY29weTogdCAtPiBpbnQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XCJcbiAgbGV0IGdldF9rZXlfY29weSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uZ2V0X2tleV9jb3B5XCI7XG4gICAgZ2V0X2tleV9jb3B5IGUgb1xuXG4gIGV4dGVybmFsIHNldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfa2V5XCJcbiAgbGV0IHNldF9rZXkgZSBvIHggPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uc2V0X2tleVwiO1xuICAgIHNldF9rZXkgZSBvIHhcblxuICBleHRlcm5hbCB1bnNldF9rZXk6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9rZXlcIlxuICBsZXQgdW5zZXRfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi51bnNldF9rZXlcIjtcbiAgICB1bnNldF9rZXkgZSBvXG5cbiAgZXh0ZXJuYWwgY2hlY2tfa2V5OiB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfa2V5XCJcbiAgbGV0IGNoZWNrX2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uY2hlY2tfa2V5XCI7XG4gICAgY2hlY2tfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGJsaXRfa2V5IDogdCAtPiBpbnQgLT4gdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICA9IFwiY2FtbF9lcGhlX2JsaXRfa2V5XCJcblxuICBsZXQgYmxpdF9rZXkgZTEgbzEgZTIgbzIgbCA9XG4gICAgaWYgbCA8IDAgfHwgbzEgPCAwIHx8IG8xID4gbGVuZ3RoIGUxIC0gbFxuICAgICAgIHx8IG8yIDwgMCB8fCBvMiA+IGxlbmd0aCBlMiAtIGxcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiT2JqLkVwaGVtZXJvbi5ibGl0X2tleVwiXG4gICAgZWxzZSBpZiBsIDw+IDAgdGhlbiBibGl0X2tleSBlMSBvMSBlMiBvMiBsXG5cbiAgZXh0ZXJuYWwgZ2V0X2RhdGE6IHQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2RhdGFcIlxuICBleHRlcm5hbCBnZXRfZGF0YV9jb3B5OiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcIlxuICBleHRlcm5hbCBzZXRfZGF0YTogdCAtPiBvYmpfdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2RhdGFcIlxuICBleHRlcm5hbCB1bnNldF9kYXRhOiB0IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9kYXRhXCJcbiAgZXh0ZXJuYWwgY2hlY2tfZGF0YTogdCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfZGF0YVwiXG4gIGV4dGVybmFsIGJsaXRfZGF0YSA6IHQgLT4gdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfYmxpdF9kYXRhXCJcblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgU3RlcGhlbiBEb2xhbiwgVW5pdmVyc2l0eSBvZiBDYW1icmlkZ2UgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE3LTIwMTggVW5pdmVyc2l0eSBvZiBDYW1icmlkZ2UuICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgISdhIHRcblxuZXh0ZXJuYWwgbWFrZSA6ICdhIC0+ICdhIHQgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCBnZXQgOiAnYSB0IC0+ICdhID0gXCIlYXRvbWljX2xvYWRcIlxuZXh0ZXJuYWwgZXhjaGFuZ2UgOiAnYSB0IC0+ICdhIC0+ICdhID0gXCIlYXRvbWljX2V4Y2hhbmdlXCJcbmV4dGVybmFsIGNvbXBhcmVfYW5kX3NldCA6ICdhIHQgLT4gJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWF0b21pY19jYXNcIlxuZXh0ZXJuYWwgZmV0Y2hfYW5kX2FkZCA6IGludCB0IC0+IGludCAtPiBpbnQgPSBcIiVhdG9taWNfZmV0Y2hfYWRkXCJcbmV4dGVybmFsIGlnbm9yZSA6ICdhIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG5sZXQgc2V0IHIgeCA9IGlnbm9yZSAoZXhjaGFuZ2UgciB4KVxubGV0IGluY3IgciA9IGlnbm9yZSAoZmV0Y2hfYW5kX2FkZCByIDEpXG5sZXQgZGVjciByID0gaWdub3JlIChmZXRjaF9hbmRfYWRkIHIgKC0xKSlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogSW50ZXJuYWxzIG9mIGZvcmNpbmcgbGF6eSB2YWx1ZXMuICopXG5cbnR5cGUgJ2EgdCA9ICdhIGxhenlfdFxuXG5leGNlcHRpb24gVW5kZWZpbmVkXG5cbigqIFt1cGRhdGVfdG9fZm9yY2luZyBibGtdIHRyaWVzIHRvIHVwZGF0ZSBhIFtibGtdIHdpdGggW2xhenlfdGFnXSB0b1xuICAgW2ZvcmNpbmdfdGFnXSB1c2luZyBjb21wYXJlLWFuZC1zd2FwIChDQVMpLCB0YWtpbmcgY2FyZSB0byBoYW5kbGUgY29uY3VycmVudFxuICAgbWFya2luZyBvZiB0aGUgaGVhZGVyIHdvcmQgYnkgYSBjb25jdXJyZW50IEdDIHRocmVhZC4gUmV0dXJucyBbMF0gaWYgdGhlXG4gICBDQVMgaXMgc3VjY2Vzc2Z1bC4gSWYgdGhlIENBUyBmYWlscywgdGhlbiB0aGUgdGFnIHdhcyBvYnNlcnZlZCB0byBiZVxuICAgc29tZXRoaW5nIG90aGVyIHRoYW4gW2xhenlfdGFnXSBkdWUgdG8gYSBjb25jdXJyZW50IG11dGF0b3IuIEluIHRoaXMgY2FzZSxcbiAgIHRoZSBmdW5jdGlvbiByZXR1cm5zIFsxXS4gKilcbmV4dGVybmFsIHVwZGF0ZV90b19mb3JjaW5nIDogT2JqLnQgLT4gaW50ID1cbiAgXCJjYW1sX2xhenlfdXBkYXRlX3RvX2ZvcmNpbmdcIiBbQEBub2FsbG9jXVxuXG4oKiBbcmVzZXRfdG9fbGF6eSBibGtdIGV4cGVjdHMgW2Jsa10gdG8gYmUgYSBsYXp5IG9iamVjdCB3aXRoIFtPYmouZm9yY2luZ190YWddXG4gICBhbmQgdXBkYXRlcyB0aGUgdGFnIHRvIFtPYmoubGF6eV90YWddLCB0YWtpbmcgY2FyZSB0byBoYW5kbGUgY29uY3VycmVudFxuICAgbWFya2luZyBvZiB0aGlzIG9iamVjdCdzIGhlYWRlciBieSBhIGNvbmN1cnJlbnQgR0MgdGhyZWFkLiAqKVxuZXh0ZXJuYWwgcmVzZXRfdG9fbGF6eSA6IE9iai50IC0+IHVuaXQgPSBcImNhbWxfbGF6eV9yZXNldF90b19sYXp5XCIgW0BAbm9hbGxvY11cblxuKCogW3VwZGF0ZV90b19mb3J3YXJkIGJsa10gZXhwZWN0cyBbYmxrXSB0byBiZSBhIGxhenkgb2JqZWN0IHdpdGhcbiAgIFtPYmouZm9yY2luZ190YWddIGFuZCB1cGRhdGVzIHRoZSB0YWcgdG8gW09iai5mb3J3YXJkX3RhZ10sIHRha2luZyBjYXJlIHRvXG4gICBoYW5kbGUgY29uY3VycmVudCBtYXJraW5nIG9mIHRoaXMgb2JqZWN0J3MgaGVhZGVyIGJ5IGEgY29uY3VycmVudCBHQyB0aHJlYWQuXG4gKilcbmV4dGVybmFsIHVwZGF0ZV90b19mb3J3YXJkIDogT2JqLnQgLT4gdW5pdCA9XG4gIFwiY2FtbF9sYXp5X3VwZGF0ZV90b19mb3J3YXJkXCIgW0BAbm9hbGxvY11cblxuKCogQXNzdW1lcyBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGZvcmNpbmcgKilcbmxldCBkb19mb3JjZV9ibG9jayBibGsgPVxuICBsZXQgYiA9IE9iai5yZXByIGJsayBpblxuICBsZXQgY2xvc3VyZSA9IChPYmoub2JqIChPYmouZmllbGQgYiAwKSA6IHVuaXQgLT4gJ2FyZykgaW5cbiAgT2JqLnNldF9maWVsZCBiIDAgKE9iai5yZXByICgpKTsgKCogUmVsZWFzZSB0aGUgY2xvc3VyZSAqKVxuICB0cnlcbiAgICBsZXQgcmVzdWx0ID0gY2xvc3VyZSAoKSBpblxuICAgIE9iai5zZXRfZmllbGQgYiAwIChPYmoucmVwciByZXN1bHQpO1xuICAgIHVwZGF0ZV90b19mb3J3YXJkIGI7XG4gICAgcmVzdWx0XG4gIHdpdGggZSAtPlxuICAgIE9iai5zZXRfZmllbGQgYiAwIChPYmoucmVwciAoZnVuICgpIC0+IHJhaXNlIGUpKTtcbiAgICByZXNldF90b19sYXp5IGI7XG4gICAgcmFpc2UgZVxuXG4oKiBBc3N1bWVzIFtibGtdIGlzIGEgYmxvY2sgd2l0aCB0YWcgZm9yY2luZyAqKVxubGV0IGRvX2ZvcmNlX3ZhbF9ibG9jayBibGsgPVxuICBsZXQgYiA9IE9iai5yZXByIGJsayBpblxuICBsZXQgY2xvc3VyZSA9IChPYmoub2JqIChPYmouZmllbGQgYiAwKSA6IHVuaXQgLT4gJ2FyZykgaW5cbiAgT2JqLnNldF9maWVsZCBiIDAgKE9iai5yZXByICgpKTsgKCogUmVsZWFzZSB0aGUgY2xvc3VyZSAqKVxuICBsZXQgcmVzdWx0ID0gY2xvc3VyZSAoKSBpblxuICBPYmouc2V0X2ZpZWxkIGIgMCAoT2JqLnJlcHIgcmVzdWx0KTtcbiAgdXBkYXRlX3RvX2ZvcndhcmQgYjtcbiAgcmVzdWx0XG5cbigqIENhbGxlZCBieSBbZm9yY2VfZ2VuXSAqKVxubGV0IGZvcmNlX2dlbl9sYXp5X2Jsb2NrIH5vbmx5X3ZhbCAoYmxrIDogJ2FyZyBsYXp5X3QpID1cbiAgKCogV2UgZXhwZWN0IHRoZSB0YWcgdG8gYmUgW2xhenlfdGFnXSwgYnV0IG1heSBiZSBvdGhlciB0YWdzIGR1ZSB0b1xuICAgICBjb25jdXJyZW50IGZvcmNpbmcgb2YgbGF6eSB2YWx1ZXMuICopXG4gIG1hdGNoIHVwZGF0ZV90b19mb3JjaW5nIChPYmoucmVwciBibGspIHdpdGhcbiAgfCAwIHdoZW4gb25seV92YWwgLT4gZG9fZm9yY2VfdmFsX2Jsb2NrIGJsa1xuICB8IDAgLT4gZG9fZm9yY2VfYmxvY2sgYmxrXG4gIHwgXyAtPiByYWlzZSBVbmRlZmluZWRcblxuKCogdXNlZCBpbiB0aGUgJWxhenlfZm9yY2UgcHJpbWl0aXZlICopXG5sZXQgZm9yY2VfbGF6eV9ibG9jayBibGsgPSBmb3JjZV9nZW5fbGF6eV9ibG9jayB+b25seV92YWw6ZmFsc2UgYmxrXG5cbigqIFtmb3JjZV9nZW4gfm9ubHlfdmFsOmZhbHNlXSBpcyBub3QgdXNlZCwgc2luY2UgW0xhenkuZm9yY2VdIGlzXG4gICBkZWNsYXJlZCBhcyBhIHByaW1pdGl2ZSB3aG9zZSBjb2RlIGlubGluZXMgdGhlIHRhZyB0ZXN0cyBvZiBpdHNcbiAgIGFyZ3VtZW50LCBleGNlcHQgd2hlbiBhZmwgaW5zdHJ1bWVudGF0aW9uIGlzIHR1cm5lZCBvbi4gKilcbmxldCBmb3JjZV9nZW4gfm9ubHlfdmFsIChsenYgOiAnYXJnIGxhenlfdCkgPVxuICAoKiBVc2luZyBbU3lzLm9wYXF1ZV9pZGVudGl0eV0gcHJldmVudHMgdHdvIHBvdGVudGlhbCBwcm9ibGVtczpcbiAgICAgLSBJZiB0aGUgdmFsdWUgaXMga25vd24gdG8gaGF2ZSBGb3J3YXJkX3RhZywgdGhlbiBpdCBjb3VsZCBoYXZlIGJlZW5cbiAgICAgICBzaG9ydGN1dCBkdXJpbmcgR0MsIHNvIHRoYXQgaW5mb3JtYXRpb24gbXVzdCBiZSBmb3Jnb3R0ZW4gKHNlZSBHUFIjNzEzXG4gICAgICAgYW5kIGlzc3VlICM3MzAxKS4gVGhpcyBpcyBub3QgYW4gaXNzdWUgaGVyZSBhdCB0aGUgbW9tZW50IHNpbmNlXG4gICAgICAgW09iai50YWddIGlzIG5vdCBzaW1wbGlmaWVkIGJ5IHRoZSBjb21waWxlciwgYW5kIEdQUiM3MTMgYWxzb1xuICAgICAgIGVuc3VyZXMgdGhhdCBubyB2YWx1ZSB3aWxsIGJlIGtub3duIHRvIGhhdmUgRm9yd2FyZF90YWcuXG4gICAgIC0gSWYgdGhlIHZhbHVlIGlzIGtub3duIHRvIGJlIGltbXV0YWJsZSwgdGhlbiBpZiB0aGUgY29tcGlsZXJcbiAgICAgICBjYW5ub3QgcHJvdmUgdGhhdCB0aGUgbGFzdCBicmFuY2ggaXMgbm90IHRha2VuIGl0IHdpbGwgaXNzdWUgYVxuICAgICAgIHdhcm5pbmcgNTkgKG1vZGlmaWNhdGlvbiBvZiBhbiBpbW11dGFibGUgdmFsdWUpICopXG4gIGxldCBsenYgPSBTeXMub3BhcXVlX2lkZW50aXR5IGx6diBpblxuICBsZXQgeCA9IE9iai5yZXByIGx6diBpblxuICAoKiBTVEFSVCBubyBzYWZlIHBvaW50cy4gSWYgYSBHQyBvY2N1cnMgaGVyZSwgdGhlbiB0aGUgb2JqZWN0IFt4XSBtYXkgYmVcbiAgICAgc2hvcnQtY2lyY3VpdGVkLCBhbmQgZ2V0dGluZyB0aGUgZmlyc3QgZmllbGQgb2YgW3hdIHdvdWxkIGdldCB1cyB0aGUgd3JvbmdcbiAgICAgdmFsdWUuIEx1Y2tpbHksIHRoZSBjb21waWxlciBkb2VzIG5vdCBpbnNlcnQgR0Mgc2FmZSBwb2ludHMgYXQgdGhpcyBwbGFjZSxcbiAgICAgc28gaXQgaXMgb2suICopXG4gIGxldCB0ID0gT2JqLnRhZyB4IGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgdGhlblxuICAgIChPYmoub2JqIChPYmouZmllbGQgeCAwKSA6ICdhcmcpXG4gICgqIEVORCBubyBzYWZlIHBvaW50cyAqKVxuICBlbHNlIGlmIHQgPSBPYmouZm9yY2luZ190YWcgdGhlbiByYWlzZSBVbmRlZmluZWRcbiAgZWxzZSBpZiB0IDw+IE9iai5sYXp5X3RhZyB0aGVuIChPYmoub2JqIHggOiAnYXJnKVxuICBlbHNlIGZvcmNlX2dlbl9sYXp5X2Jsb2NrIH5vbmx5X3ZhbCBsenZcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtMYXp5XTogZGVmZXJyZWQgY29tcHV0YXRpb25zICopXG5cblxuKCpcbiAgIFdBUk5JTkc6IHNvbWUgcHVycGxlIG1hZ2ljIGlzIGdvaW5nIG9uIGhlcmUuICBEbyBub3QgdGFrZSB0aGlzIGZpbGVcbiAgIGFzIGFuIGV4YW1wbGUgb2YgaG93IHRvIHByb2dyYW0gaW4gT0NhbWwuXG4qKVxuXG5cbigqIFdlIG1ha2UgdXNlIG9mIHR3byBzcGVjaWFsIHRhZ3MgcHJvdmlkZWQgYnkgdGhlIHJ1bnRpbWU6XG4gICBbbGF6eV90YWddIGFuZCBbZm9yd2FyZF90YWddLlxuXG4gICBBIHZhbHVlIG9mIHR5cGUgWydhIExhenkudF0gY2FuIGJlIG9uZSBvZiB0aHJlZSB0aGluZ3M6XG4gICAxLiBBIGJsb2NrIG9mIHNpemUgMSB3aXRoIHRhZyBbbGF6eV90YWddLiAgSXRzIGZpZWxkIGlzIGEgY2xvc3VyZSBvZlxuICAgICAgdHlwZSBbdW5pdCAtPiAnYV0gdGhhdCBjb21wdXRlcyB0aGUgdmFsdWUuXG4gICAyLiBBIGJsb2NrIG9mIHNpemUgMSB3aXRoIHRhZyBbZm9yd2FyZF90YWddLiAgSXRzIGZpZWxkIGlzIHRoZSB2YWx1ZVxuICAgICAgb2YgdHlwZSBbJ2FdIHRoYXQgd2FzIGNvbXB1dGVkLlxuICAgMy4gQW55dGhpbmcgZWxzZSBleGNlcHQgYSBmbG9hdC4gIFRoaXMgaGFzIHR5cGUgWydhXSBhbmQgaXMgdGhlIHZhbHVlXG4gICAgICB0aGF0IHdhcyBjb21wdXRlZC5cbiAgIEV4Y2VwdGlvbnMgYXJlIHN0b3JlZCBpbiBmb3JtYXQgKDEpLlxuICAgVGhlIEdDIHdpbGwgbWFnaWNhbGx5IGNoYW5nZSB0aGluZ3MgZnJvbSAoMikgdG8gKDMpIGFjY29yZGluZyB0byBpdHNcbiAgIGZhbmN5LlxuXG4gICBJZiBPQ2FtbCB3YXMgY29uZmlndXJlZCB3aXRoIHRoZSAtZmxhdC1mbG9hdC1hcnJheSBvcHRpb24gKHdoaWNoIGlzXG4gICBjdXJyZW50bHkgdGhlIGRlZmF1bHQpLCB0aGUgZm9sbG93aW5nIGlzIGFsc28gdHJ1ZTpcbiAgIFdlIGNhbm5vdCB1c2UgcmVwcmVzZW50YXRpb24gKDMpIGZvciBhIFtmbG9hdCBMYXp5LnRdIGJlY2F1c2VcbiAgIFtjYW1sX21ha2VfYXJyYXldIGFzc3VtZXMgdGhhdCBvbmx5IGEgW2Zsb2F0XSB2YWx1ZSBjYW4gaGF2ZSB0YWdcbiAgIFtEb3VibGVfdGFnXS5cblxuICAgV2UgaGF2ZSB0byB1c2UgdGhlIGJ1aWx0LWluIHR5cGUgY29uc3RydWN0b3IgW2xhenlfdF0gdG9cbiAgIGxldCB0aGUgY29tcGlsZXIgaW1wbGVtZW50IHRoZSBzcGVjaWFsIHR5cGluZyBhbmQgY29tcGlsYXRpb25cbiAgIHJ1bGVzIGZvciB0aGUgW2xhenldIGtleXdvcmQuXG4qKVxuXG50eXBlICdhIHQgPSAnYSBDYW1saW50ZXJuYWxMYXp5LnRcblxuZXhjZXB0aW9uIFVuZGVmaW5lZCA9IENhbWxpbnRlcm5hbExhenkuVW5kZWZpbmVkXG5leHRlcm5hbCBtYWtlX2ZvcndhcmQgOiAnYSAtPiAnYSBsYXp5X3QgPSBcImNhbWxfbGF6eV9tYWtlX2ZvcndhcmRcIlxuZXh0ZXJuYWwgZm9yY2UgOiAnYSB0IC0+ICdhID0gXCIlbGF6eV9mb3JjZVwiXG5cbmxldCBmb3JjZV92YWwgbCA9IENhbWxpbnRlcm5hbExhenkuZm9yY2VfZ2VuIH5vbmx5X3ZhbDp0cnVlIGxcblxubGV0IGZyb21fZnVuIChmIDogdW5pdCAtPiAnYXJnKSA9XG4gIGxldCB4ID0gT2JqLm5ld19ibG9jayBPYmoubGF6eV90YWcgMSBpblxuICBPYmouc2V0X2ZpZWxkIHggMCAoT2JqLnJlcHIgZik7XG4gIChPYmoub2JqIHggOiAnYXJnIHQpXG5cbmxldCBmcm9tX3ZhbCAodiA6ICdhcmcpID1cbiAgbGV0IHQgPSBPYmoudGFnIChPYmoucmVwciB2KSBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHx8IHQgPSBPYmoubGF6eV90YWcgfHxcbiAgICAgdCA9IE9iai5mb3JjaW5nX3RhZyB8fCB0ID0gT2JqLmRvdWJsZV90YWcgdGhlbiBiZWdpblxuICAgIG1ha2VfZm9yd2FyZCB2XG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgKE9iai5tYWdpYyB2IDogJ2FyZyB0KVxuICBlbmRcblxubGV0IGlzX3ZhbCAobCA6ICdhcmcgdCkgPSBPYmoudGFnIChPYmoucmVwciBsKSA8PiBPYmoubGF6eV90YWdcblxubGV0IG1hcCBmIHggPVxuICBsYXp5IChmIChmb3JjZSB4KSlcblxubGV0IG1hcF92YWwgZiB4ID1cbiAgaWYgaXNfdmFsIHhcbiAgdGhlbiBmcm9tX3ZhbCAoZiAoZm9yY2UgeCkpXG4gIGVsc2UgbGF6eSAoZiAoZm9yY2UgeCkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgU2ltb24gQ3J1YW5lcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbU2VxXTogZnVuY3Rpb25hbCBpdGVyYXRvcnMgKilcblxudHlwZSArJ2Egbm9kZSA9XG4gIHwgTmlsXG4gIHwgQ29ucyBvZiAnYSAqICdhIHRcblxuYW5kICdhIHQgPSB1bml0IC0+ICdhIG5vZGVcblxubGV0IGVtcHR5ICgpID0gTmlsXG5cbmxldCByZXR1cm4geCAoKSA9IENvbnMgKHgsIGVtcHR5KVxuXG5sZXQgY29ucyB4IG5leHQgKCkgPSBDb25zICh4LCBuZXh0KVxuXG5sZXQgcmVjIGFwcGVuZCBzZXExIHNlcTIgKCkgPVxuICBtYXRjaCBzZXExKCkgd2l0aFxuICB8IE5pbCAtPiBzZXEyKClcbiAgfCBDb25zICh4LCBuZXh0KSAtPiBDb25zICh4LCBhcHBlbmQgbmV4dCBzZXEyKVxuXG5sZXQgcmVjIG1hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gQ29ucyAoZiB4LCBtYXAgZiBuZXh0KVxuXG5sZXQgcmVjIGZpbHRlcl9tYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgICB8IE5vbmUgLT4gZmlsdGVyX21hcCBmIG5leHQgKClcbiAgICAgICAgfCBTb21lIHkgLT4gQ29ucyAoeSwgZmlsdGVyX21hcCBmIG5leHQpXG5cbmxldCByZWMgZmlsdGVyIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgaWYgZiB4XG4gICAgICB0aGVuIENvbnMgKHgsIGZpbHRlciBmIG5leHQpXG4gICAgICBlbHNlIGZpbHRlciBmIG5leHQgKClcblxubGV0IHJlYyBjb25jYXQgc2VxICgpID0gbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgYXBwZW5kIHggKGNvbmNhdCBuZXh0KSAoKVxuXG5sZXQgcmVjIGZsYXRfbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICBhcHBlbmQgKGYgeCkgKGZsYXRfbWFwIGYgbmV4dCkgKClcblxubGV0IGNvbmNhdF9tYXAgPSBmbGF0X21hcFxuXG5sZXQgcmVjIGZvbGRfbGVmdCBmIGFjYyBzZXEgPVxuICBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgTmlsIC0+IGFjY1xuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0IGFjYyA9IGYgYWNjIHggaW5cbiAgICAgICAgZm9sZF9sZWZ0IGYgYWNjIG5leHRcblxubGV0IHJlYyBpdGVyIGYgc2VxID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IE5pbCAtPiAoKVxuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgZiB4O1xuICAgICAgICBpdGVyIGYgbmV4dFxuXG5sZXQgcmVjIHVuZm9sZCBmIHUgKCkgPVxuICBtYXRjaCBmIHUgd2l0aFxuICB8IE5vbmUgLT4gTmlsXG4gIHwgU29tZSAoeCwgdScpIC0+IENvbnMgKHgsIHVuZm9sZCBmIHUnKVxuXG5sZXQgaXNfZW1wdHkgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zIChfLCBfKSAtPlxuICAgICAgZmFsc2VcblxubGV0IHVuY29ucyB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgU29tZSAoeCwgeHMpXG4gIHwgTmlsIC0+XG4gICAgICBOb25lXG5cblxuXG5sZXQgcmVjIGxlbmd0aF9hdXggYWNjdSB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgYWNjdVxuICB8IENvbnMgKF8sIHhzKSAtPlxuICAgICAgbGVuZ3RoX2F1eCAoYWNjdSArIDEpIHhzXG5cbmxldFtAaW5saW5lXSBsZW5ndGggeHMgPVxuICBsZW5ndGhfYXV4IDAgeHNcblxubGV0IHJlYyBpdGVyaV9hdXggZiBpIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICAoKVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgZiBpIHg7XG4gICAgICBpdGVyaV9hdXggZiAoaSsxKSB4c1xuXG5sZXRbQGlubGluZV0gaXRlcmkgZiB4cyA9XG4gIGl0ZXJpX2F1eCBmIDAgeHNcblxubGV0IHJlYyBmb2xkX2xlZnRpX2F1eCBmIGFjY3UgaSB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgYWNjdVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbGV0IGFjY3UgPSBmIGFjY3UgaSB4IGluXG4gICAgICBmb2xkX2xlZnRpX2F1eCBmIGFjY3UgKGkrMSkgeHNcblxubGV0W0BpbmxpbmVdIGZvbGRfbGVmdGkgZiBhY2N1IHhzID1cbiAgZm9sZF9sZWZ0aV9hdXggZiBhY2N1IDAgeHNcblxubGV0IHJlYyBmb3JfYWxsIHAgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIHAgeCAmJiBmb3JfYWxsIHAgeHNcblxubGV0IHJlYyBleGlzdHMgcCB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIHAgeCB8fCBleGlzdHMgcCB4c1xuXG5sZXQgcmVjIGZpbmQgcCB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTm9uZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgaWYgcCB4IHRoZW4gU29tZSB4IGVsc2UgZmluZCBwIHhzXG5cbmxldCByZWMgZmluZF9tYXAgZiB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTm9uZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGZpbmRfbWFwIGYgeHNcbiAgICAgIHwgU29tZSBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIHJlc3VsdFxuXG4oKiBbaXRlcjJdLCBbZm9sZF9sZWZ0Ml0sIFtmb3JfYWxsMl0sIFtleGlzdHMyXSwgW21hcDJdLCBbemlwXSB3b3JrIGFsc28gaW5cbiAgIHRoZSBjYXNlIHdoZXJlIHRoZSB0d28gc2VxdWVuY2VzIGhhdmUgZGlmZmVyZW50IGxlbmd0aHMuIFRoZXkgc3RvcCBhcyBzb29uXG4gICBhcyBvbmUgc2VxdWVuY2UgaXMgZXhoYXVzdGVkLiBUaGVpciBiZWhhdmlvciBpcyBzbGlnaHRseSBhc3ltbWV0cmljOiB3aGVuXG4gICBbeHNdIGlzIGVtcHR5LCB0aGV5IGRvIG5vdCBmb3JjZSBbeXNdOyBob3dldmVyLCB3aGVuIFt5c10gaXMgZW1wdHksIFt4c10gaXNcbiAgIGZvcmNlZCwgZXZlbiB0aG91Z2ggdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gYXBwbGljYXRpb24gW3hzKCldIHR1cm5zIG91dFxuICAgdG8gYmUgdXNlbGVzcy4gKilcblxubGV0IHJlYyBpdGVyMiBmIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICAoKVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgICgpXG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIGYgeCB5O1xuICAgICAgICAgIGl0ZXIyIGYgeHMgeXNcblxubGV0IHJlYyBmb2xkX2xlZnQyIGYgYWNjdSB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgYWNjdVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIGFjY3VcbiAgICAgIHwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICAgICAgbGV0IGFjY3UgPSBmIGFjY3UgeCB5IGluXG4gICAgICAgICAgZm9sZF9sZWZ0MiBmIGFjY3UgeHMgeXNcblxubGV0IHJlYyBmb3JfYWxsMiBmIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCB5cygpIHdpdGhcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBmIHggeSAmJiBmb3JfYWxsMiBmIHhzIHlzXG5cbmxldCByZWMgZXhpc3RzMiBmIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBmYWxzZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIGYgeCB5IHx8IGV4aXN0czIgZiB4cyB5c1xuXG5sZXQgcmVjIGVxdWFsIGVxIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSwgeXMoKSB3aXRoXG4gIHwgTmlsLCBOaWwgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zICh4LCB4cyksIENvbnMgKHksIHlzKSAtPlxuICAgICAgZXEgeCB5ICYmIGVxdWFsIGVxIHhzIHlzXG4gIHwgTmlsLCBDb25zIChfLCBfKVxuICB8IENvbnMgKF8sIF8pLCBOaWwgLT5cbiAgICAgIGZhbHNlXG5cbmxldCByZWMgY29tcGFyZSBjbXAgeHMgeXMgPVxuICBtYXRjaCB4cygpLCB5cygpIHdpdGhcbiAgfCBOaWwsIE5pbCAtPlxuICAgICAgMFxuICB8IENvbnMgKHgsIHhzKSwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICBsZXQgYyA9IGNtcCB4IHkgaW5cbiAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZSBjb21wYXJlIGNtcCB4cyB5c1xuICB8IE5pbCwgQ29ucyAoXywgXykgLT5cbiAgICAgIC0xXG4gIHwgQ29ucyAoXywgXyksIE5pbCAtPlxuICAgICAgKzFcblxuXG5cbigqIFtpbml0X2F1eCBmIGkgal0gaXMgdGhlIHNlcXVlbmNlIFtmIGksIC4uLiwgZiAoai0xKV0uICopXG5cbmxldCByZWMgaW5pdF9hdXggZiBpIGogKCkgPVxuICBpZiBpIDwgaiB0aGVuIGJlZ2luXG4gICAgQ29ucyAoZiBpLCBpbml0X2F1eCBmIChpICsgMSkgailcbiAgZW5kXG4gIGVsc2VcbiAgICBOaWxcblxubGV0IGluaXQgbiBmID1cbiAgaWYgbiA8IDAgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU2VxLmluaXRcIlxuICBlbHNlXG4gICAgaW5pdF9hdXggZiAwIG5cblxubGV0IHJlYyByZXBlYXQgeCAoKSA9XG4gIENvbnMgKHgsIHJlcGVhdCB4KVxuXG5sZXQgcmVjIGZvcmV2ZXIgZiAoKSA9XG4gIENvbnMgKGYoKSwgZm9yZXZlciBmKVxuXG4oKiBUaGlzIHByZWxpbWluYXJ5IGRlZmluaXRpb24gb2YgW2N5Y2xlXSByZXF1aXJlcyB0aGUgc2VxdWVuY2UgW3hzXVxuICAgdG8gYmUgbm9uZW1wdHkuIEFwcGx5aW5nIGl0IHRvIGFuIGVtcHR5IHNlcXVlbmNlIHdvdWxkIHByb2R1Y2UgYVxuICAgc2VxdWVuY2UgdGhhdCBkaXZlcmdlcyB3aGVuIGl0IGlzIGZvcmNlZC4gKilcblxubGV0IHJlYyBjeWNsZV9ub25lbXB0eSB4cyAoKSA9XG4gIGFwcGVuZCB4cyAoY3ljbGVfbm9uZW1wdHkgeHMpICgpXG5cbigqIFtjeWNsZSB4c10gY2hlY2tzIHdoZXRoZXIgW3hzXSBpcyBlbXB0eSBhbmQsIGlmIHNvLCByZXR1cm5zIGFuIGVtcHR5XG4gICBzZXF1ZW5jZS4gT3RoZXJ3aXNlLCBbY3ljbGUgeHNdIHByb2R1Y2VzIG9uZSBjb3B5IG9mIFt4c10gZm9sbG93ZWRcbiAgIHdpdGggdGhlIGluZmluaXRlIHNlcXVlbmNlIFtjeWNsZV9ub25lbXB0eSB4c10uIFRodXMsIHRoZSBub25lbXB0aW5lc3NcbiAgIGNoZWNrIGlzIHBlcmZvcm1lZCBqdXN0IG9uY2UuICopXG5cbmxldCBjeWNsZSB4cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMnKSAtPlxuICAgICAgQ29ucyAoeCwgYXBwZW5kIHhzJyAoY3ljbGVfbm9uZW1wdHkgeHMpKVxuXG4oKiBbaXRlcmF0ZTEgZiB4XSBpcyB0aGUgc2VxdWVuY2UgW2YgeCwgZiAoZiB4KSwgLi4uXS5cbiAgIEl0IGlzIGVxdWl2YWxlbnQgdG8gW3RhaWwgKGl0ZXJhdGUgZiB4KV0uXG4gICBbaXRlcmF0ZTFdIGlzIHVzZWQgYXMgYSBidWlsZGluZyBibG9jayBpbiB0aGUgZGVmaW5pdGlvbiBvZiBbaXRlcmF0ZV0uICopXG5cbmxldCByZWMgaXRlcmF0ZTEgZiB4ICgpID1cbiAgbGV0IHkgPSBmIHggaW5cbiAgQ29ucyAoeSwgaXRlcmF0ZTEgZiB5KVxuXG4oKiBbaXRlcmF0ZSBmIHhdIGlzIHRoZSBzZXF1ZW5jZSBbeCwgZiB4LCAuLi5dLiAqKVxuXG4oKiBUaGUgcmVhc29uIHdoeSB3ZSBnaXZlIHRoaXMgc2xpZ2h0bHkgaW5kaXJlY3QgZGVmaW5pdGlvbiBvZiBbaXRlcmF0ZV0sXG4gICBhcyBvcHBvc2VkIHRvIHRoZSBtb3JlIG5haXZlIGRlZmluaXRpb24gdGhhdCBtYXkgY29tZSB0byBtaW5kLCBpcyB0aGF0XG4gICB3ZSBhcmUgY2FyZWZ1bCB0byBhdm9pZCBldmFsdWF0aW5nIFtmIHhdIHVudGlsIHRoaXMgZnVuY3Rpb24gY2FsbCBpc1xuICAgYWN0dWFsbHkgbmVjZXNzYXJ5LiBUaGUgbmFpdmUgZGVmaW5pdGlvbiAobm90IHNob3duIGhlcmUpIGNvbXB1dGVzIHRoZVxuICAgc2Vjb25kIGFyZ3VtZW50IG9mIHRoZSBzZXF1ZW5jZSwgW2YgeF0sIHdoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IGlzXG4gICByZXF1ZXN0ZWQgYnkgdGhlIHVzZXIuICopXG5cbmxldCBpdGVyYXRlIGYgeCA9XG4gIGNvbnMgeCAoaXRlcmF0ZTEgZiB4KVxuXG5cblxubGV0IHJlYyBtYXBpX2F1eCBmIGkgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgQ29ucyAoZiBpIHgsIG1hcGlfYXV4IGYgKGkrMSkgeHMpXG5cbmxldFtAaW5saW5lXSBtYXBpIGYgeHMgPVxuICBtYXBpX2F1eCBmIDAgeHNcblxuKCogW3RhaWxfc2NhbiBmIHMgeHNdIGlzIGVxdWl2YWxlbnQgdG8gW3RhaWwgKHNjYW4gZiBzIHhzKV0uXG4gICBbdGFpbF9zY2FuXSBpcyB1c2VkIGFzIGEgYnVpbGRpbmcgYmxvY2sgaW4gdGhlIGRlZmluaXRpb24gb2YgW3NjYW5dLiAqKVxuXG4oKiBUaGlzIHNsaWdodGx5IGluZGlyZWN0IGRlZmluaXRpb24gb2YgW3NjYW5dIGlzIG1lYW50IHRvIGF2b2lkIGNvbXB1dGluZ1xuICAgZWxlbWVudHMgdG9vIGVhcmx5OyBzZWUgdGhlIGFib3ZlIGNvbW1lbnQgYWJvdXQgW2l0ZXJhdGUxXSBhbmQgW2l0ZXJhdGVdLiAqKVxuXG5sZXQgcmVjIHRhaWxfc2NhbiBmIHMgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbGV0IHMgPSBmIHMgeCBpblxuICAgICAgQ29ucyAocywgdGFpbF9zY2FuIGYgcyB4cylcblxubGV0IHNjYW4gZiBzIHhzID1cbiAgY29ucyBzICh0YWlsX3NjYW4gZiBzIHhzKVxuXG4oKiBbdGFrZV0gaXMgZGVmaW5lZCBpbiBzdWNoIGEgd2F5IHRoYXQgW3Rha2UgMCB4c10gcmV0dXJucyBbZW1wdHldXG4gICBpbW1lZGlhdGVseSwgd2l0aG91dCBhbGxvY2F0aW5nIGFueSBtZW1vcnkuICopXG5cbmxldCByZWMgdGFrZV9hdXggbiB4cyA9XG4gIGlmIG4gPSAwIHRoZW5cbiAgICBlbXB0eVxuICBlbHNlXG4gICAgZnVuICgpIC0+XG4gICAgICBtYXRjaCB4cygpIHdpdGhcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgTmlsXG4gICAgICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgICAgIENvbnMgKHgsIHRha2VfYXV4IChuLTEpIHhzKVxuXG5sZXQgdGFrZSBuIHhzID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcS50YWtlXCI7XG4gIHRha2VfYXV4IG4geHNcblxuKCogW2ZvcmNlX2Ryb3AgbiB4c10gaXMgZXF1aXZhbGVudCB0byBbZHJvcCBuIHhzICgpXS5cbiAgIFtmb3JjZV9kcm9wIG4geHNdIHJlcXVpcmVzIFtuID4gMF0uXG4gICBbZm9yY2VfZHJvcF0gaXMgdXNlZCBhcyBhIGJ1aWxkaW5nIGJsb2NrIGluIHRoZSBkZWZpbml0aW9uIG9mIFtkcm9wXS4gKilcblxubGV0IHJlYyBmb3JjZV9kcm9wIG4geHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKF8sIHhzKSAtPlxuICAgICAgbGV0IG4gPSBuIC0gMSBpblxuICAgICAgaWYgbiA9IDAgdGhlblxuICAgICAgICB4cygpXG4gICAgICBlbHNlXG4gICAgICAgIGZvcmNlX2Ryb3AgbiB4c1xuXG4oKiBbZHJvcF0gaXMgZGVmaW5lZCBpbiBzdWNoIGEgd2F5IHRoYXQgW2Ryb3AgMCB4c10gcmV0dXJucyBbeHNdIGltbWVkaWF0ZWx5LFxuICAgd2l0aG91dCBhbGxvY2F0aW5nIGFueSBtZW1vcnkuICopXG5cbmxldCBkcm9wIG4geHMgPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiU2VxLmRyb3BcIlxuICBlbHNlIGlmIG4gPSAwIHRoZW5cbiAgICB4c1xuICBlbHNlXG4gICAgZnVuICgpIC0+XG4gICAgICBmb3JjZV9kcm9wIG4geHNcblxubGV0IHJlYyB0YWtlX3doaWxlIHAgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgaWYgcCB4IHRoZW4gQ29ucyAoeCwgdGFrZV93aGlsZSBwIHhzKSBlbHNlIE5pbFxuXG5sZXQgcmVjIGRyb3Bfd2hpbGUgcCB4cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIGFzIG5vZGUgLT5cbiAgICAgIGlmIHAgeCB0aGVuIGRyb3Bfd2hpbGUgcCB4cyAoKSBlbHNlIG5vZGVcblxubGV0IHJlYyBncm91cCBlcSB4cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBDb25zIChjb25zIHggKHRha2Vfd2hpbGUgKGVxIHgpIHhzKSwgZ3JvdXAgZXEgKGRyb3Bfd2hpbGUgKGVxIHgpIHhzKSlcblxuZXhjZXB0aW9uIEZvcmNlZF90d2ljZVxuXG5tb2R1bGUgU3VzcGVuc2lvbiA9IHN0cnVjdFxuXG4gIHR5cGUgJ2Egc3VzcGVuc2lvbiA9XG4gICAgdW5pdCAtPiAnYVxuXG4gICgqIENvbnZlcnNpb25zLiAqKVxuXG4gIGxldCB0b19sYXp5IDogJ2Egc3VzcGVuc2lvbiAtPiAnYSBMYXp5LnQgPVxuICAgIExhenkuZnJvbV9mdW5cbiAgICAoKiBmdW4gcyAtPiBsYXp5IChzKCkpICopXG5cbiAgbGV0IGZyb21fbGF6eSAocyA6ICdhIExhenkudCkgOiAnYSBzdXNwZW5zaW9uID1cbiAgICBmdW4gKCkgLT4gTGF6eS5mb3JjZSBzXG5cbiAgKCogW21lbW9pemVdIHR1cm5zIGFuIGFyYml0cmFyeSBzdXNwZW5zaW9uIGludG8gYSBwZXJzaXN0ZW50IHN1c3BlbnNpb24uICopXG5cbiAgbGV0IG1lbW9pemUgKHMgOiAnYSBzdXNwZW5zaW9uKSA6ICdhIHN1c3BlbnNpb24gPVxuICAgIGZyb21fbGF6eSAodG9fbGF6eSBzKVxuXG4gICgqIFtmYWlsdXJlXSBpcyBhIHN1c3BlbnNpb24gdGhhdCBmYWlscyB3aGVuIGZvcmNlZC4gKilcblxuICBsZXQgZmFpbHVyZSA6IF8gc3VzcGVuc2lvbiA9XG4gICAgZnVuICgpIC0+XG4gICAgICAoKiBBIHN1c3BlbnNpb24gY3JlYXRlZCBieSBbb25jZV0gaGFzIGJlZW4gZm9yY2VkIHR3aWNlLiAqKVxuICAgICAgcmFpc2UgRm9yY2VkX3R3aWNlXG5cbiAgKCogSWYgW2ZdIGlzIGEgc3VzcGVuc2lvbiwgdGhlbiBbb25jZSBmXSBpcyBhIHN1c3BlbnNpb24gdGhhdCBjYW4gYmUgZm9yY2VkXG4gICAgIGF0IG1vc3Qgb25jZS4gSWYgaXQgaXMgZm9yY2VkIG1vcmUgdGhhbiBvbmNlLCB0aGVuIFtGb3JjZWRfdHdpY2VdIGlzXG4gICAgIHJhaXNlZC4gKilcblxuICBsZXQgb25jZSAoZiA6ICdhIHN1c3BlbnNpb24pIDogJ2Egc3VzcGVuc2lvbiA9XG4gICAgbGV0IGFjdGlvbiA9IEF0b21pYy5tYWtlIGYgaW5cbiAgICBmdW4gKCkgLT5cbiAgICAgICgqIEdldCB0aGUgZnVuY3Rpb24gY3VycmVudGx5IHN0b3JlZCBpbiBbYWN0aW9uXSwgYW5kIHdyaXRlIHRoZVxuICAgICAgICAgZnVuY3Rpb24gW2ZhaWx1cmVdIGluIGl0cyBwbGFjZSwgc28gdGhlIG5leHQgYWNjZXNzIHdpbGwgcmVzdWx0XG4gICAgICAgICBpbiBhIGNhbGwgdG8gW2ZhaWx1cmUoKV0uICopXG4gICAgICBsZXQgZiA9IEF0b21pYy5leGNoYW5nZSBhY3Rpb24gZmFpbHVyZSBpblxuICAgICAgZigpXG5cbmVuZCAoKiBTdXNwZW5zaW9uICopXG5cbmxldCByZWMgbWVtb2l6ZSB4cyA9XG4gIFN1c3BlbnNpb24ubWVtb2l6ZSAoZnVuICgpIC0+XG4gICAgbWF0Y2ggeHMoKSB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgICAgTmlsXG4gICAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgICAgQ29ucyAoeCwgbWVtb2l6ZSB4cylcbiAgKVxuXG5sZXQgcmVjIG9uY2UgeHMgPVxuICBTdXNwZW5zaW9uLm9uY2UgKGZ1biAoKSAtPlxuICAgIG1hdGNoIHhzKCkgd2l0aFxuICAgIHwgTmlsIC0+XG4gICAgICAgIE5pbFxuICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgIENvbnMgKHgsIG9uY2UgeHMpXG4gIClcblxuXG5sZXQgcmVjIHppcCB4cyB5cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCB5cygpIHdpdGhcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgTmlsXG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIENvbnMgKCh4LCB5KSwgemlwIHhzIHlzKVxuXG5sZXQgcmVjIG1hcDIgZiB4cyB5cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCB5cygpIHdpdGhcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgTmlsXG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIENvbnMgKGYgeCB5LCBtYXAyIGYgeHMgeXMpXG5cbmxldCByZWMgaW50ZXJsZWF2ZSB4cyB5cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgeXMoKVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgQ29ucyAoeCwgaW50ZXJsZWF2ZSB5cyB4cylcblxuKCogW3NvcnRlZF9tZXJnZTFsIGNtcCB4IHhzIHlzXSBpcyBlcXVpdmFsZW50IHRvXG4gICAgIFtzb3J0ZWRfbWVyZ2UgY21wIChjb25zIHggeHMpIHlzXS5cblxuICAgW3NvcnRlZF9tZXJnZTFyIGNtcCB4cyB5IHlzXSBpcyBlcXVpdmFsZW50IHRvXG4gICAgIFtzb3J0ZWRfbWVyZ2UgY21wIHhzIChjb25zIHkgeXMpXS5cblxuICAgW3NvcnRlZF9tZXJnZTEgY21wIHggeHMgeSB5c10gaXMgZXF1aXZhbGVudCB0b1xuICAgICBbc29ydGVkX21lcmdlIGNtcCAoY29ucyB4IHhzKSAoY29ucyB5IHlzKV0uXG5cbiAgIFRoZXNlIHRocmVlIGZ1bmN0aW9ucyBhcmUgdXNlZCBhcyBidWlsZGluZyBibG9ja3MgaW4gdGhlIGRlZmluaXRpb25cbiAgIG9mIFtzb3J0ZWRfbWVyZ2VdLiAqKVxuXG5sZXQgcmVjIHNvcnRlZF9tZXJnZTFsIGNtcCB4IHhzIHlzICgpID1cbiAgbWF0Y2ggeXMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBDb25zICh4LCB4cylcbiAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgIHNvcnRlZF9tZXJnZTEgY21wIHggeHMgeSB5c1xuXG5hbmQgc29ydGVkX21lcmdlMXIgY21wIHhzIHkgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIENvbnMgKHksIHlzKVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgc29ydGVkX21lcmdlMSBjbXAgeCB4cyB5IHlzXG5cbmFuZCBzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXMgPVxuICBpZiBjbXAgeCB5IDw9IDAgdGhlblxuICAgIENvbnMgKHgsIHNvcnRlZF9tZXJnZTFyIGNtcCB4cyB5IHlzKVxuICBlbHNlXG4gICAgQ29ucyAoeSwgc29ydGVkX21lcmdlMWwgY21wIHggeHMgeXMpXG5cbmxldCBzb3J0ZWRfbWVyZ2UgY21wIHhzIHlzICgpID1cbiAgbWF0Y2ggeHMoKSwgeXMoKSB3aXRoXG4gICAgfCBOaWwsIE5pbCAtPlxuICAgICAgICBOaWxcbiAgICB8IE5pbCwgY1xuICAgIHwgYywgTmlsIC0+XG4gICAgICAgIGNcbiAgICB8IENvbnMgKHgsIHhzKSwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICAgIHNvcnRlZF9tZXJnZTEgY21wIHggeHMgeSB5c1xuXG5cbmxldCByZWMgbWFwX2ZzdCB4eXMgKCkgPVxuICBtYXRjaCB4eXMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICgoeCwgXyksIHh5cykgLT5cbiAgICAgIENvbnMgKHgsIG1hcF9mc3QgeHlzKVxuXG5sZXQgcmVjIG1hcF9zbmQgeHlzICgpID1cbiAgbWF0Y2ggeHlzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoKF8sIHkpLCB4eXMpIC0+XG4gICAgICBDb25zICh5LCBtYXBfc25kIHh5cylcblxubGV0IHVuemlwIHh5cyA9XG4gIG1hcF9mc3QgeHlzLCBtYXBfc25kIHh5c1xuXG5sZXQgc3BsaXQgPVxuICB1bnppcFxuXG4oKiBbZmlsdGVyX21hcF9maW5kX2xlZnRfbWFwIGYgeHNdIGlzIGVxdWl2YWxlbnQgdG9cbiAgIFtmaWx0ZXJfbWFwIEVpdGhlci5maW5kX2xlZnQgKG1hcCBmIHhzKV0uICopXG5cbmxldCByZWMgZmlsdGVyX21hcF9maW5kX2xlZnRfbWFwIGYgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgIHwgRWl0aGVyLkxlZnQgeSAtPlxuICAgICAgICAgIENvbnMgKHksIGZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzKVxuICAgICAgfCBFaXRoZXIuUmlnaHQgXyAtPlxuICAgICAgICAgIGZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzICgpXG5cbmxldCByZWMgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IEVpdGhlci5MZWZ0IF8gLT5cbiAgICAgICAgICBmaWx0ZXJfbWFwX2ZpbmRfcmlnaHRfbWFwIGYgeHMgKClcbiAgICAgIHwgRWl0aGVyLlJpZ2h0IHogLT5cbiAgICAgICAgICBDb25zICh6LCBmaWx0ZXJfbWFwX2ZpbmRfcmlnaHRfbWFwIGYgeHMpXG5cbmxldCBwYXJ0aXRpb25fbWFwIGYgeHMgPVxuICBmaWx0ZXJfbWFwX2ZpbmRfbGVmdF9tYXAgZiB4cyxcbiAgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzXG5cbmxldCBwYXJ0aXRpb24gcCB4cyA9XG4gIGZpbHRlciBwIHhzLCBmaWx0ZXIgKGZ1biB4IC0+IG5vdCAocCB4KSkgeHNcblxuKCogSWYgW3hzc10gaXMgYSBtYXRyaXggKGEgc2VxdWVuY2Ugb2Ygcm93cyksIHRoZW4gW3BlZWwgeHNzXSBpcyBhIHBhaXIgb2ZcbiAgIHRoZSBmaXJzdCBjb2x1bW4gKGEgc2VxdWVuY2Ugb2YgZWxlbWVudHMpIGFuZCBvZiB0aGUgcmVtYWluZGVyIG9mIHRoZVxuICAgbWF0cml4IChhIHNlcXVlbmNlIG9mIHNob3J0ZXIgcm93cykuIFRoZXNlIHR3byBzZXF1ZW5jZXMgaGF2ZSB0aGUgc2FtZVxuICAgbGVuZ3RoLiBUaGUgcm93cyBvZiB0aGUgbWF0cml4IFt4c3NdIGFyZSBub3QgcmVxdWlyZWQgdG8gaGF2ZSB0aGUgc2FtZVxuICAgbGVuZ3RoLiBBbiBlbXB0eSByb3cgaXMgaWdub3JlZC4gKilcblxuKCogQmVjYXVzZSBbcGVlbF0gdXNlcyBbdW56aXBdLCBpdHMgYXJndW1lbnQgbXVzdCBiZSBwZXJzaXN0ZW50LiBUaGUgc2FtZVxuICAgcmVtYXJrIGFwcGxpZXMgdG8gW3RyYW5zcG9zZV0sIFtkaWFnb25hbHNdLCBbcHJvZHVjdF0sIGV0Yy4gKilcblxubGV0IHBlZWwgeHNzID1cbiAgdW56aXAgKGZpbHRlcl9tYXAgdW5jb25zIHhzcylcblxubGV0IHJlYyB0cmFuc3Bvc2UgeHNzICgpID1cbiAgbGV0IGhlYWRzLCB0YWlscyA9IHBlZWwgeHNzIGluXG4gIGlmIGlzX2VtcHR5IGhlYWRzIHRoZW4gYmVnaW5cbiAgICBhc3NlcnQgKGlzX2VtcHR5IHRhaWxzKTtcbiAgICBOaWxcbiAgZW5kXG4gIGVsc2VcbiAgICBDb25zIChoZWFkcywgdHJhbnNwb3NlIHRhaWxzKVxuXG4oKiBUaGUgaW50ZXJuYWwgZnVuY3Rpb24gW2RpYWdvbmFsc10gdGFrZXMgYW4gZXh0cmEgYXJndW1lbnQsIFtyZW1haW5kZXJzXSxcbiAgIHdoaWNoIGNvbnRhaW5zIHRoZSByZW1haW5kZXJzIG9mIHRoZSByb3dzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW5cbiAgIGRpc2NvdmVyZWQuICopXG5cbmxldCByZWMgZGlhZ29uYWxzIHJlbWFpbmRlcnMgeHNzICgpID1cbiAgbWF0Y2ggeHNzKCkgd2l0aFxuICB8IENvbnMgKHhzLCB4c3MpIC0+XG4gICAgICBiZWdpbiBtYXRjaCB4cygpIHdpdGhcbiAgICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgICAgKCogV2UgZGlzY292ZXIgYSBuZXcgbm9uZW1wdHkgcm93IFt4IDo6IHhzXS4gVGh1cywgdGhlIG5leHQgZGlhZ29uYWxcbiAgICAgICAgICAgICBpcyBbeCA6OiBoZWFkc106IHRoaXMgZGlhZ29uYWwgYmVnaW5zIHdpdGggW3hdIGFuZCBjb250aW51ZXMgd2l0aFxuICAgICAgICAgICAgIHRoZSBmaXJzdCBlbGVtZW50IG9mIGV2ZXJ5IHJvdyBpbiBbcmVtYWluZGVyc10uIEluIHRoZSByZWN1cnNpdmVcbiAgICAgICAgICAgICBjYWxsLCB0aGUgYXJndW1lbnQgW3JlbWFpbmRlcnNdIGlzIGluc3RhbnRpYXRlZCB3aXRoIFt4cyA6OlxuICAgICAgICAgICAgIHRhaWxzXSwgd2hpY2ggbWVhbnMgdGhhdCB3ZSBoYXZlIG9uZSBtb3JlIHJlbWFpbmluZyByb3csIFt4c10sXG4gICAgICAgICAgICAgYW5kIHRoYXQgd2Uga2VlcCB0aGUgdGFpbHMgb2YgdGhlIHByZS1leGlzdGluZyByZW1haW5pbmcgcm93cy4gKilcbiAgICAgICAgICBsZXQgaGVhZHMsIHRhaWxzID0gcGVlbCByZW1haW5kZXJzIGluXG4gICAgICAgICAgQ29ucyAoY29ucyB4IGhlYWRzLCBkaWFnb25hbHMgKGNvbnMgeHMgdGFpbHMpIHhzcylcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgKCogV2UgZGlzY292ZXIgYSBuZXcgZW1wdHkgcm93LiBJbiB0aGlzIGNhc2UsIHRoZSBuZXcgZGlhZ29uYWwgaXNcbiAgICAgICAgICAgICBqdXN0IFtoZWFkc10sIGFuZCBbcmVtYWluZGVyc10gaXMgaW5zdGFudGlhdGVkIHdpdGgganVzdCBbdGFpbHNdLFxuICAgICAgICAgICAgIGFzIHdlIGRvIG5vdCBoYXZlIG9uZSBtb3JlIHJlbWFpbmluZyByb3cuICopXG4gICAgICAgICAgbGV0IGhlYWRzLCB0YWlscyA9IHBlZWwgcmVtYWluZGVycyBpblxuICAgICAgICAgIENvbnMgKGhlYWRzLCBkaWFnb25hbHMgdGFpbHMgeHNzKVxuICAgICAgZW5kXG4gIHwgTmlsIC0+XG4gICAgICAoKiBUaGVyZSBhcmUgbm8gbW9yZSByb3dzIHRvIGJlIGRpc2NvdmVyZWQuIFRoZXJlIHJlbWFpbnMgdG8gZXhoYXVzdFxuICAgICAgICAgdGhlIHJlbWFpbmluZyByb3dzLiAqKVxuICAgICAgdHJhbnNwb3NlIHJlbWFpbmRlcnMgKClcblxuKCogSWYgW3hzc10gaXMgYSBtYXRyaXggKGEgc2VxdWVuY2Ugb2Ygcm93cyksIHRoZW4gW2RpYWdvbmFscyB4c3NdIGlzXG4gICB0aGUgc2VxdWVuY2Ugb2YgaXRzIGRpYWdvbmFscy5cblxuICAgVGhlIGZpcnN0IGRpYWdvbmFsIGNvbnRhaW5zIGp1c3QgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlXG4gICBmaXJzdCByb3cuIFRoZSBzZWNvbmQgZGlhZ29uYWwgY29udGFpbnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlXG4gICBzZWNvbmQgcm93IGFuZCB0aGUgc2Vjb25kIGVsZW1lbnQgb2YgdGhlIGZpcnN0IHJvdzsgYW5kIHNvIG9uLlxuICAgVGhpcyBraW5kIG9mIGRpYWdvbmFsIGlzIGluIGZhY3Qgc29tZXRpbWVzIGtub3duIGFzIGFuIGFudGlkaWFnb25hbC5cblxuICAgLSBFdmVyeSBkaWFnb25hbCBpcyBhIGZpbml0ZSBzZXF1ZW5jZS5cbiAgIC0gVGhlIHJvd3Mgb2YgdGhlIG1hdHJpeCBbeHNzXSBhcmUgbm90IHJlcXVpcmVkIHRvIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLlxuICAgLSBUaGUgbWF0cml4IFt4c3NdIGlzIG5vdCByZXF1aXJlZCB0byBiZSBmaW5pdGUgKGluIGVpdGhlciBkaXJlY3Rpb24pLlxuICAgLSBUaGUgbWF0cml4IFt4c3NdIG11c3QgYmUgcGVyc2lzdGVudC4gKilcblxubGV0IGRpYWdvbmFscyB4c3MgPVxuICBkaWFnb25hbHMgZW1wdHkgeHNzXG5cbmxldCBtYXBfcHJvZHVjdCBmIHhzIHlzID1cbiAgY29uY2F0IChkaWFnb25hbHMgKFxuICAgIG1hcCAoZnVuIHggLT5cbiAgICAgIG1hcCAoZnVuIHkgLT5cbiAgICAgICAgZiB4IHlcbiAgICAgICkgeXNcbiAgICApIHhzXG4gICkpXG5cbmxldCBwcm9kdWN0IHhzIHlzID1cbiAgbWFwX3Byb2R1Y3QgKGZ1biB4IHkgLT4gKHgsIHkpKSB4cyB5c1xuXG5sZXQgb2ZfZGlzcGVuc2VyIGl0ID1cbiAgbGV0IHJlYyBjICgpID1cbiAgICBtYXRjaCBpdCgpIHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgICAgTmlsXG4gICAgfCBTb21lIHggLT5cbiAgICAgICAgQ29ucyAoeCwgYylcbiAgaW5cbiAgY1xuXG5sZXQgdG9fZGlzcGVuc2VyIHhzID1cbiAgbGV0IHMgPSByZWYgeHMgaW5cbiAgZnVuICgpIC0+XG4gICAgbWF0Y2ggKCFzKSgpIHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgICBOb25lXG4gICAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgICAgcyA6PSB4cztcbiAgICAgICAgU29tZSB4XG5cblxuXG5sZXQgcmVjIGludHMgaSAoKSA9XG4gIENvbnMgKGksIGludHMgKGkgKyAxKSlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAnYSB0ID0gJ2Egb3B0aW9uID0gTm9uZSB8IFNvbWUgb2YgJ2FcblxubGV0IG5vbmUgPSBOb25lXG5sZXQgc29tZSB2ID0gU29tZSB2XG5sZXQgdmFsdWUgbyB+ZGVmYXVsdCA9IG1hdGNoIG8gd2l0aCBTb21lIHYgLT4gdiB8IE5vbmUgLT4gZGVmYXVsdFxubGV0IGdldCA9IGZ1bmN0aW9uIFNvbWUgdiAtPiB2IHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIm9wdGlvbiBpcyBOb25lXCJcbmxldCBiaW5kIG8gZiA9IG1hdGNoIG8gd2l0aCBOb25lIC0+IE5vbmUgfCBTb21lIHYgLT4gZiB2XG5sZXQgam9pbiA9IGZ1bmN0aW9uIFNvbWUgbyAtPiBvIHwgTm9uZSAtPiBOb25lXG5sZXQgbWFwIGYgbyA9IG1hdGNoIG8gd2l0aCBOb25lIC0+IE5vbmUgfCBTb21lIHYgLT4gU29tZSAoZiB2KVxubGV0IGZvbGQgfm5vbmUgfnNvbWUgPSBmdW5jdGlvbiBTb21lIHYgLT4gc29tZSB2IHwgTm9uZSAtPiBub25lXG5sZXQgaXRlciBmID0gZnVuY3Rpb24gU29tZSB2IC0+IGYgdiB8IE5vbmUgLT4gKClcbmxldCBpc19ub25lID0gZnVuY3Rpb24gTm9uZSAtPiB0cnVlIHwgU29tZSBfIC0+IGZhbHNlXG5sZXQgaXNfc29tZSA9IGZ1bmN0aW9uIE5vbmUgLT4gZmFsc2UgfCBTb21lIF8gLT4gdHJ1ZVxuXG5sZXQgZXF1YWwgZXEgbzAgbzEgPSBtYXRjaCBvMCwgbzEgd2l0aFxufCBTb21lIHYwLCBTb21lIHYxIC0+IGVxIHYwIHYxXG58IE5vbmUsIE5vbmUgLT4gdHJ1ZVxufCBfIC0+IGZhbHNlXG5cbmxldCBjb21wYXJlIGNtcCBvMCBvMSA9IG1hdGNoIG8wLCBvMSB3aXRoXG58IFNvbWUgdjAsIFNvbWUgdjEgLT4gY21wIHYwIHYxXG58IE5vbmUsIE5vbmUgLT4gMFxufCBOb25lLCBTb21lIF8gLT4gLTFcbnwgU29tZSBfLCBOb25lIC0+IDFcblxubGV0IHRvX3Jlc3VsdCB+bm9uZSA9IGZ1bmN0aW9uIE5vbmUgLT4gRXJyb3Igbm9uZSB8IFNvbWUgdiAtPiBPayB2XG5sZXQgdG9fbGlzdCA9IGZ1bmN0aW9uIE5vbmUgLT4gW10gfCBTb21lIHYgLT4gW3ZdXG5sZXQgdG9fc2VxID0gZnVuY3Rpb24gTm9uZSAtPiBTZXEuZW1wdHkgfCBTb21lIHYgLT4gU2VxLnJldHVybiB2XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2VcblxubGV0IG9rIHYgPSBPayB2XG5sZXQgZXJyb3IgZSA9IEVycm9yIGVcbmxldCB2YWx1ZSByIH5kZWZhdWx0ID0gbWF0Y2ggciB3aXRoIE9rIHYgLT4gdiB8IEVycm9yIF8gLT4gZGVmYXVsdFxubGV0IGdldF9vayA9IGZ1bmN0aW9uIE9rIHYgLT4gdiB8IEVycm9yIF8gLT4gaW52YWxpZF9hcmcgXCJyZXN1bHQgaXMgRXJyb3IgX1wiXG5sZXQgZ2V0X2Vycm9yID0gZnVuY3Rpb24gRXJyb3IgZSAtPiBlIHwgT2sgXyAtPiBpbnZhbGlkX2FyZyBcInJlc3VsdCBpcyBPayBfXCJcbmxldCBiaW5kIHIgZiA9IG1hdGNoIHIgd2l0aCBPayB2IC0+IGYgdiB8IEVycm9yIF8gYXMgZSAtPiBlXG5sZXQgam9pbiA9IGZ1bmN0aW9uIE9rIHIgLT4gciB8IEVycm9yIF8gYXMgZSAtPiBlXG5sZXQgbWFwIGYgPSBmdW5jdGlvbiBPayB2IC0+IE9rIChmIHYpIHwgRXJyb3IgXyBhcyBlIC0+IGVcbmxldCBtYXBfZXJyb3IgZiA9IGZ1bmN0aW9uIEVycm9yIGUgLT4gRXJyb3IgKGYgZSkgfCBPayBfIGFzIHYgLT4gdlxubGV0IGZvbGQgfm9rIH5lcnJvciA9IGZ1bmN0aW9uIE9rIHYgLT4gb2sgdiB8IEVycm9yIGUgLT4gZXJyb3IgZVxubGV0IGl0ZXIgZiA9IGZ1bmN0aW9uIE9rIHYgLT4gZiB2IHwgRXJyb3IgXyAtPiAoKVxubGV0IGl0ZXJfZXJyb3IgZiA9IGZ1bmN0aW9uIEVycm9yIGUgLT4gZiBlIHwgT2sgXyAtPiAoKVxubGV0IGlzX29rID0gZnVuY3Rpb24gT2sgXyAtPiB0cnVlIHwgRXJyb3IgXyAtPiBmYWxzZVxubGV0IGlzX2Vycm9yID0gZnVuY3Rpb24gRXJyb3IgXyAtPiB0cnVlIHwgT2sgXyAtPiBmYWxzZVxuXG5sZXQgZXF1YWwgfm9rIH5lcnJvciByMCByMSA9IG1hdGNoIHIwLCByMSB3aXRoXG58IE9rIHYwLCBPayB2MSAtPiBvayB2MCB2MVxufCBFcnJvciBlMCwgRXJyb3IgZTEgLT4gZXJyb3IgZTAgZTFcbnwgXywgXyAtPiBmYWxzZVxuXG5sZXQgY29tcGFyZSB+b2sgfmVycm9yIHIwIHIxID0gbWF0Y2ggcjAsIHIxIHdpdGhcbnwgT2sgdjAsIE9rIHYxIC0+IG9rIHYwIHYxXG58IEVycm9yIGUwLCBFcnJvciBlMSAtPiBlcnJvciBlMCBlMVxufCBPayBfLCBFcnJvciBfIC0+IC0xXG58IEVycm9yIF8sIE9rIF8gLT4gMVxuXG5sZXQgdG9fb3B0aW9uID0gZnVuY3Rpb24gT2sgdiAtPiBTb21lIHYgfCBFcnJvciBfIC0+IE5vbmVcbmxldCB0b19saXN0ID0gZnVuY3Rpb24gT2sgdiAtPiBbdl0gfCBFcnJvciBfIC0+IFtdXG5sZXQgdG9fc2VxID0gZnVuY3Rpb24gT2sgdiAtPiBTZXEucmV0dXJuIHYgfCBFcnJvciBfIC0+IFNlcS5lbXB0eVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSBib29sID0gZmFsc2UgfCB0cnVlXG5cbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmxldCBlcXVhbCA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gKCA9IClcbmxldCBjb21wYXJlIDogYm9vbCAtPiBib29sIC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5leHRlcm5hbCB0b19pbnQgOiBib29sIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmxldCB0b19mbG9hdCA9IGZ1bmN0aW9uIGZhbHNlIC0+IDAuIHwgdHJ1ZSAtPiAxLlxuXG4oKlxubGV0IG9mX3N0cmluZyA9IGZ1bmN0aW9uXG58IFwiZmFsc2VcIiAtPiBTb21lIGZhbHNlXG58IFwidHJ1ZVwiIC0+IFNvbWUgdHJ1ZVxufCBfIC0+IE5vbmVcbiopXG5cbmxldCB0b19zdHJpbmcgPSBmdW5jdGlvbiBmYWxzZSAtPiBcImZhbHNlXCIgfCB0cnVlIC0+IFwidHJ1ZVwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENoYXJhY3RlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGNvZGU6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdW5zYWZlX2NocjogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBjaHIgbiA9XG4gIGlmIG4gPCAwIHx8IG4gPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyBcIkNoYXIuY2hyXCIgZWxzZSB1bnNhZmVfY2hyIG5cblxuZXh0ZXJuYWwgYnl0ZXNfY3JlYXRlOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmxldCBlc2NhcGVkID0gZnVuY3Rpb25cbiAgfCAnXFwnJyAtPiBcIlxcXFwnXCJcbiAgfCAnXFxcXCcgLT4gXCJcXFxcXFxcXFwiXG4gIHwgJ1xcbicgLT4gXCJcXFxcblwiXG4gIHwgJ1xcdCcgLT4gXCJcXFxcdFwiXG4gIHwgJ1xccicgLT4gXCJcXFxcclwiXG4gIHwgJ1xcYicgLT4gXCJcXFxcYlwiXG4gIHwgJyAnIC4uICd+JyBhcyBjIC0+XG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSAxIGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCBjO1xuICAgICAgdW5zYWZlX3RvX3N0cmluZyBzXG4gIHwgYyAtPlxuICAgICAgbGV0IG4gPSBjb2RlIGMgaW5cbiAgICAgIGxldCBzID0gYnl0ZXNfY3JlYXRlIDQgaW5cbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAwICdcXFxcJztcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAxICh1bnNhZmVfY2hyICg0OCArIG4gLyAxMDApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAyICh1bnNhZmVfY2hyICg0OCArIChuIC8gMTApIG1vZCAxMCkpO1xuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDMgKHVuc2FmZV9jaHIgKDQ4ICsgbiBtb2QgMTApKTtcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuXG5sZXQgbG93ZXJjYXNlX2FzY2lpID0gZnVuY3Rpb25cbiAgfCAnQScgLi4gJ1onIGFzIGMgLT4gdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgfCBjIC0+IGNcblxubGV0IHVwcGVyY2FzZV9hc2NpaSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6JyBhcyBjIC0+IHVuc2FmZV9jaHIoY29kZSBjIC0gMzIpXG4gIHwgYyAtPiBjXG5cbnR5cGUgdCA9IGNoYXJcblxubGV0IGNvbXBhcmUgYzEgYzIgPSBjb2RlIGMxIC0gY29kZSBjMlxubGV0IGVxdWFsIChjMTogdCkgKGMyOiB0KSA9IGNvbXBhcmUgYzEgYzIgPSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgIERhbmllbCBDLiBCdWVuemxpICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcblxubGV0IGVycl9ub19wcmVkID0gXCJVKzAwMDAgaGFzIG5vIHByZWRlY2Vzc29yXCJcbmxldCBlcnJfbm9fc3VjYyA9IFwiVSsxMEZGRkYgaGFzIG5vIHN1Y2Nlc3NvclwiXG5sZXQgZXJyX25vdF9zdiBpID0gZm9ybWF0X2ludCBcIiVYXCIgaSBeIFwiIGlzIG5vdCBhbiBVbmljb2RlIHNjYWxhciB2YWx1ZVwiXG5sZXQgZXJyX25vdF9sYXRpbjEgdSA9IFwiVStcIiBeIGZvcm1hdF9pbnQgXCIlMDRYXCIgdSBeIFwiIGlzIG5vdCBhIGxhdGluMSBjaGFyYWN0ZXJcIlxuXG50eXBlIHQgPSBpbnRcblxubGV0IG1pbiA9IDB4MDAwMFxubGV0IG1heCA9IDB4MTBGRkZGXG5sZXQgbG9fYm91bmQgPSAweEQ3RkZcbmxldCBoaV9ib3VuZCA9IDB4RTAwMFxuXG5sZXQgYm9tID0gMHhGRUZGXG5sZXQgcmVwID0gMHhGRkZEXG5cbmxldCBzdWNjIHUgPVxuICBpZiB1ID0gbG9fYm91bmQgdGhlbiBoaV9ib3VuZCBlbHNlXG4gIGlmIHUgPSBtYXggdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fc3VjYyBlbHNlXG4gIHUgKyAxXG5cbmxldCBwcmVkIHUgPVxuICBpZiB1ID0gaGlfYm91bmQgdGhlbiBsb19ib3VuZCBlbHNlXG4gIGlmIHUgPSBtaW4gdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fcHJlZCBlbHNlXG4gIHUgLSAxXG5cbmxldCBpc192YWxpZCBpID0gKG1pbiA8PSBpICYmIGkgPD0gbG9fYm91bmQpIHx8IChoaV9ib3VuZCA8PSBpICYmIGkgPD0gbWF4KVxubGV0IG9mX2ludCBpID0gaWYgaXNfdmFsaWQgaSB0aGVuIGkgZWxzZSBpbnZhbGlkX2FyZyAoZXJyX25vdF9zdiBpKVxuZXh0ZXJuYWwgdW5zYWZlX29mX2ludCA6IGludCAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdG9faW50IDogdCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19jaGFyIHUgPSB1IDwgMjU2XG5sZXQgb2ZfY2hhciBjID0gQ2hhci5jb2RlIGNcbmxldCB0b19jaGFyIHUgPVxuICBpZiB1ID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgKGVycl9ub3RfbGF0aW4xIHUpIGVsc2VcbiAgQ2hhci51bnNhZmVfY2hyIHVcblxubGV0IHVuc2FmZV90b19jaGFyID0gQ2hhci51bnNhZmVfY2hyXG5cbmxldCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGludCAtPiBpbnQgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmxldCBoYXNoID0gdG9faW50XG5cbigqIFVURiBjb2RlY3MgdG9vbHMgKilcblxudHlwZSB1dGZfZGVjb2RlID0gaW50XG4oKiBUaGlzIGlzIGFuIGludCBbMHhEVVVVVVVVXSBkZWNvbXBvc2VkIGFzIGZvbGxvd3M6XG4gICAtIFtEXSBpcyBmb3VyIGJpdHMgZm9yIGRlY29kZSBpbmZvcm1hdGlvbiwgdGhlIGhpZ2hlc3QgYml0IGlzIHNldCBpZiB0aGVcbiAgICAgZGVjb2RlIGlzIHZhbGlkLiBUaGUgdGhyZWUgbG93ZXIgYml0cyBpbmRpY2F0ZSB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzXG4gICAgIGZyb20gdGhlIHNvdXJjZSB0aGF0IHdlcmUgY29uc3VtZWQgYnkgdGhlIGRlY29kZS5cbiAgIC0gW1VVVVVVVV0gaXMgdGhlIGRlY29kZWQgVW5pY29kZSBjaGFyYWN0ZXIgb3IgdGhlIFVuaWNvZGUgcmVwbGFjZW1lbnRcbiAgICAgY2hhcmFjdGVyIFUrRkZGRCBpZiBmb3IgaW52YWxpZCBkZWNvZGVzLiAqKVxuXG5sZXQgdmFsaWRfYml0ID0gMjdcbmxldCBkZWNvZGVfYml0cyA9IDI0XG5cbmxldFtAaW5saW5lXSB1dGZfZGVjb2RlX2lzX3ZhbGlkIGQgPSAoZCBsc3IgdmFsaWRfYml0KSA9IDFcbmxldFtAaW5saW5lXSB1dGZfZGVjb2RlX2xlbmd0aCBkID0gKGQgbHNyIGRlY29kZV9iaXRzKSBsYW5kIDBiMTExXG5sZXRbQGlubGluZV0gdXRmX2RlY29kZV91Y2hhciBkID0gdW5zYWZlX29mX2ludCAoZCBsYW5kIDB4RkZGRkZGKVxubGV0W0BpbmxpbmVdIHV0Zl9kZWNvZGUgbiB1ID0gKCg4IGxvciBuKSBsc2wgZGVjb2RlX2JpdHMpIGxvciAodG9faW50IHUpXG5sZXRbQGlubGluZV0gdXRmX2RlY29kZV9pbnZhbGlkIG4gPSAobiBsc2wgZGVjb2RlX2JpdHMpIGxvciByZXBcblxubGV0IHV0Zl84X2J5dGVfbGVuZ3RoIHUgPSBtYXRjaCB0b19pbnQgdSB3aXRoXG58IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbnwgdSB3aGVuIHUgPD0gMHgwMDdGIC0+IDFcbnwgdSB3aGVuIHUgPD0gMHgwN0ZGIC0+IDJcbnwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+IDNcbnwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT4gNFxufCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgdXRmXzE2X2J5dGVfbGVuZ3RoIHUgPSBtYXRjaCB0b19pbnQgdSB3aXRoXG58IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbnwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+IDJcbnwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT4gNFxufCBfIC0+IGFzc2VydCBmYWxzZVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgbGlzdHMuICopXG50eXBlICdhIHQgPSAnYSBsaXN0ID0gW10gfCAoOjopIG9mICdhICogJ2EgbGlzdFxuXG4oKiBMaXN0IG9wZXJhdGlvbnMgKilcblxubGV0IHJlYyBsZW5ndGhfYXV4IGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gbGVuXG4gIHwgXzo6bCAtPiBsZW5ndGhfYXV4IChsZW4gKyAxKSBsXG5cbmxldCBsZW5ndGggbCA9IGxlbmd0aF9hdXggMCBsXG5cbmxldCBjb25zIGEgbCA9IGE6OmxcblxubGV0IGhkID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWlsd2l0aCBcImhkXCJcbiAgfCBhOjpfIC0+IGFcblxubGV0IHRsID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWlsd2l0aCBcInRsXCJcbiAgfCBfOjpsIC0+IGxcblxubGV0IG50aCBsIG4gPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5udGhcIiBlbHNlXG4gIGxldCByZWMgbnRoX2F1eCBsIG4gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gZmFpbHdpdGggXCJudGhcIlxuICAgIHwgYTo6bCAtPiBpZiBuID0gMCB0aGVuIGEgZWxzZSBudGhfYXV4IGwgKG4tMSlcbiAgaW4gbnRoX2F1eCBsIG5cblxubGV0IG50aF9vcHQgbCBuID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QubnRoXCIgZWxzZVxuICBsZXQgcmVjIG50aF9hdXggbCBuID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IGE6OmwgLT4gaWYgbiA9IDAgdGhlbiBTb21lIGEgZWxzZSBudGhfYXV4IGwgKG4tMSlcbiAgaW4gbnRoX2F1eCBsIG5cblxubGV0IGFwcGVuZCA9IChAKVxuXG5sZXQgcmVjIHJldl9hcHBlbmQgbDEgbDIgPVxuICBtYXRjaCBsMSB3aXRoXG4gICAgW10gLT4gbDJcbiAgfCBhIDo6IGwgLT4gcmV2X2FwcGVuZCBsIChhIDo6IGwyKVxuXG5sZXQgcmV2IGwgPSByZXZfYXBwZW5kIGwgW11cblxubGV0IHJlYyBpbml0X3RhaWxyZWNfYXV4IGFjYyBpIG4gZiA9XG4gIGlmIGkgPj0gbiB0aGVuIGFjY1xuICBlbHNlIGluaXRfdGFpbHJlY19hdXggKGYgaSA6OiBhY2MpIChpKzEpIG4gZlxuXG5sZXQgcmVjIGluaXRfYXV4IGkgbiBmID1cbiAgaWYgaSA+PSBuIHRoZW4gW11cbiAgZWxzZVxuICAgIGxldCByID0gZiBpIGluXG4gICAgciA6OiBpbml0X2F1eCAoaSsxKSBuIGZcblxubGV0IHJldl9pbml0X3RocmVzaG9sZCA9XG4gIG1hdGNoIFN5cy5iYWNrZW5kX3R5cGUgd2l0aFxuICB8IFN5cy5OYXRpdmUgfCBTeXMuQnl0ZWNvZGUgLT4gMTBfMDAwXG4gICgqIFdlIGRvbid0IGtub3cgdGhlIHNpemUgb2YgdGhlIHN0YWNrLCBiZXR0ZXIgYmUgc2FmZSBhbmQgYXNzdW1lIGl0J3NcbiAgICAgc21hbGwuICopXG4gIHwgU3lzLk90aGVyIF8gLT4gNTBcblxubGV0IGluaXQgbGVuIGYgPVxuICBpZiBsZW4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0LmluaXRcIiBlbHNlXG4gIGlmIGxlbiA+IHJldl9pbml0X3RocmVzaG9sZCB0aGVuIHJldiAoaW5pdF90YWlscmVjX2F1eCBbXSAwIGxlbiBmKVxuICBlbHNlIGluaXRfYXV4IDAgbGVuIGZcblxubGV0IHJlYyBmbGF0dGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGw6OnIgLT4gbCBAIGZsYXR0ZW4gclxuXG5sZXQgY29uY2F0ID0gZmxhdHRlblxuXG5sZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGE6OmwgLT4gbGV0IHIgPSBmIGEgaW4gciA6OiBtYXAgZiBsXG5cbmxldCByZWMgbWFwaSBpIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgYTo6bCAtPiBsZXQgciA9IGYgaSBhIGluIHIgOjogbWFwaSAoaSArIDEpIGYgbFxuXG5sZXQgbWFwaSBmIGwgPSBtYXBpIDAgZiBsXG5cbmxldCByZXZfbWFwIGYgbCA9XG4gIGxldCByZWMgcm1hcF9mIGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjdVxuICAgIHwgYTo6bCAtPiBybWFwX2YgKGYgYSA6OiBhY2N1KSBsXG4gIGluXG4gIHJtYXBfZiBbXSBsXG5cblxubGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+ICgpXG4gIHwgYTo6bCAtPiBmIGE7IGl0ZXIgZiBsXG5cbmxldCByZWMgaXRlcmkgaSBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoKVxuICB8IGE6OmwgLT4gZiBpIGE7IGl0ZXJpIChpICsgMSkgZiBsXG5cbmxldCBpdGVyaSBmIGwgPSBpdGVyaSAwIGYgbFxuXG5sZXQgcmVjIGZvbGRfbGVmdCBmIGFjY3UgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdIC0+IGFjY3VcbiAgfCBhOjpsIC0+IGZvbGRfbGVmdCBmIChmIGFjY3UgYSkgbFxuXG5sZXQgcmVjIGZvbGRfcmlnaHQgZiBsIGFjY3UgPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAtPiBhY2N1XG4gIHwgYTo6bCAtPiBmIGEgKGZvbGRfcmlnaHQgZiBsIGFjY3UpXG5cbmxldCByZWMgbWFwMiBmIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBsZXQgciA9IGYgYTEgYTIgaW4gciA6OiBtYXAyIGYgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0Lm1hcDJcIlxuXG5sZXQgcmV2X21hcDIgZiBsMSBsMiA9XG4gIGxldCByZWMgcm1hcDJfZiBhY2N1IGwxIGwyID1cbiAgICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgfCAoW10sIFtdKSAtPiBhY2N1XG4gICAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHJtYXAyX2YgKGYgYTEgYTIgOjogYWNjdSkgbDEgbDJcbiAgICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QucmV2X21hcDJcIlxuICBpblxuICBybWFwMl9mIFtdIGwxIGwyXG5cblxubGV0IHJlYyBpdGVyMiBmIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+ICgpXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmIGExIGEyOyBpdGVyMiBmIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5pdGVyMlwiXG5cbmxldCByZWMgZm9sZF9sZWZ0MiBmIGFjY3UgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gYWNjdVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZm9sZF9sZWZ0MiBmIChmIGFjY3UgYTEgYTIpIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb2xkX2xlZnQyXCJcblxubGV0IHJlYyBmb2xkX3JpZ2h0MiBmIGwxIGwyIGFjY3UgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gYWNjdVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZiBhMSBhMiAoZm9sZF9yaWdodDIgZiBsMSBsMiBhY2N1KVxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9sZF9yaWdodDJcIlxuXG5sZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gdHJ1ZVxuICB8IGE6OmwgLT4gcCBhICYmIGZvcl9hbGwgcCBsXG5cbmxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBwIGEgfHwgZXhpc3RzIHAgbFxuXG5sZXQgcmVjIGZvcl9hbGwyIHAgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gdHJ1ZVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcCBhMSBhMiAmJiBmb3JfYWxsMiBwIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb3JfYWxsMlwiXG5cbmxldCByZWMgZXhpc3RzMiBwIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGZhbHNlXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBwIGExIGEyIHx8IGV4aXN0czIgcCBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZXhpc3RzMlwiXG5cbmxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBjb21wYXJlIGEgeCA9IDAgfHwgbWVtIHggbFxuXG5sZXQgcmVjIG1lbXEgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IGEgPT0geCB8fCBtZW1xIHggbFxuXG5sZXQgcmVjIGFzc29jIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IChhLGIpOjpsIC0+IGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIGIgZWxzZSBhc3NvYyB4IGxcblxubGV0IHJlYyBhc3NvY19vcHQgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gTm9uZVxuICB8IChhLGIpOjpsIC0+IGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIFNvbWUgYiBlbHNlIGFzc29jX29wdCB4IGxcblxubGV0IHJlYyBhc3NxIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IChhLGIpOjpsIC0+IGlmIGEgPT0geCB0aGVuIGIgZWxzZSBhc3NxIHggbFxuXG5sZXQgcmVjIGFzc3Ffb3B0IHggPSBmdW5jdGlvblxuICAgIFtdIC0+IE5vbmVcbiAgfCAoYSxiKTo6bCAtPiBpZiBhID09IHggdGhlbiBTb21lIGIgZWxzZSBhc3NxX29wdCB4IGxcblxubGV0IHJlYyBtZW1fYXNzb2MgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoYSwgXykgOjogbCAtPiBjb21wYXJlIGEgeCA9IDAgfHwgbWVtX2Fzc29jIHggbFxuXG5sZXQgcmVjIG1lbV9hc3NxIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IGZhbHNlXG4gIHwgKGEsIF8pIDo6IGwgLT4gYSA9PSB4IHx8IG1lbV9hc3NxIHggbFxuXG5sZXQgcmVjIHJlbW92ZV9hc3NvYyB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IChhLCBfIGFzIHBhaXIpIDo6IGwgLT5cbiAgICAgIGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIGwgZWxzZSBwYWlyIDo6IHJlbW92ZV9hc3NvYyB4IGxcblxubGV0IHJlYyByZW1vdmVfYXNzcSB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IChhLCBfIGFzIHBhaXIpIDo6IGwgLT4gaWYgYSA9PSB4IHRoZW4gbCBlbHNlIHBhaXIgOjogcmVtb3ZlX2Fzc3EgeCBsXG5cbmxldCByZWMgZmluZCBwID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4geCBlbHNlIGZpbmQgcCBsXG5cbmxldCByZWMgZmluZF9vcHQgcCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBTb21lIHggZWxzZSBmaW5kX29wdCBwIGxcblxubGV0IHJlYyBmaW5kX21hcCBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBsIC0+XG4gICAgIGJlZ2luIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgcmVzdWx0IC0+IHJlc3VsdFxuICAgICAgIHwgTm9uZSAtPiBmaW5kX21hcCBmIGxcbiAgICAgZW5kXG5cbmxldCBmaW5kX2FsbCBwID1cbiAgbGV0IHJlYyBmaW5kIGFjY3UgPSBmdW5jdGlvblxuICB8IFtdIC0+IHJldiBhY2N1XG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIGZpbmQgKHggOjogYWNjdSkgbCBlbHNlIGZpbmQgYWNjdSBsIGluXG4gIGZpbmQgW11cblxubGV0IGZpbHRlciA9IGZpbmRfYWxsXG5cbmxldCBmaWx0ZXJpIHAgbCA9XG4gIGxldCByZWMgYXV4IGkgYWNjID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByZXYgYWNjXG4gIHwgeDo6bCAtPiBhdXggKGkgKyAxKSAoaWYgcCBpIHggdGhlbiB4OjphY2MgZWxzZSBhY2MpIGxcbiAgaW5cbiAgYXV4IDAgW10gbFxuXG5sZXQgZmlsdGVyX21hcCBmID1cbiAgbGV0IHJlYyBhdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXYgYWNjdVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBhdXggYWNjdSBsXG4gICAgICAgIHwgU29tZSB2IC0+IGF1eCAodiA6OiBhY2N1KSBsXG4gIGluXG4gIGF1eCBbXVxuXG5sZXQgY29uY2F0X21hcCBmIGwgPVxuICBsZXQgcmVjIGF1eCBmIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXYgYWNjXG4gICAgfCB4IDo6IGwgLT5cbiAgICAgICBsZXQgeHMgPSBmIHggaW5cbiAgICAgICBhdXggZiAocmV2X2FwcGVuZCB4cyBhY2MpIGxcbiAgaW4gYXV4IGYgW10gbFxuXG5sZXQgZm9sZF9sZWZ0X21hcCBmIGFjY3UgbCA9XG4gIGxldCByZWMgYXV4IGFjY3UgbF9hY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3UsIHJldiBsX2FjY3VcbiAgICB8IHggOjogbCAtPlxuICAgICAgICBsZXQgYWNjdSwgeCA9IGYgYWNjdSB4IGluXG4gICAgICAgIGF1eCBhY2N1ICh4IDo6IGxfYWNjdSkgbCBpblxuICBhdXggYWNjdSBbXSBsXG5cbmxldCBwYXJ0aXRpb24gcCBsID1cbiAgbGV0IHJlYyBwYXJ0IHllcyBubyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gKHJldiB5ZXMsIHJldiBubylcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gcGFydCAoeCA6OiB5ZXMpIG5vIGwgZWxzZSBwYXJ0IHllcyAoeCA6OiBubykgbCBpblxuICBwYXJ0IFtdIFtdIGxcblxubGV0IHBhcnRpdGlvbl9tYXAgcCBsID1cbiAgbGV0IHJlYyBwYXJ0IGxlZnQgcmlnaHQgPSBmdW5jdGlvblxuICB8IFtdIC0+IChyZXYgbGVmdCwgcmV2IHJpZ2h0KVxuICB8IHggOjogbCAtPlxuICAgICBiZWdpbiBtYXRjaCBwIHggd2l0aFxuICAgICAgIHwgRWl0aGVyLkxlZnQgdiAtPiBwYXJ0ICh2IDo6IGxlZnQpIHJpZ2h0IGxcbiAgICAgICB8IEVpdGhlci5SaWdodCB2IC0+IHBhcnQgbGVmdCAodiA6OiByaWdodCkgbFxuICAgICBlbmRcbiAgaW5cbiAgcGFydCBbXSBbXSBsXG5cbmxldCByZWMgc3BsaXQgPSBmdW5jdGlvblxuICAgIFtdIC0+IChbXSwgW10pXG4gIHwgKHgseSk6OmwgLT5cbiAgICAgIGxldCAocngsIHJ5KSA9IHNwbGl0IGwgaW4gKHg6OnJ4LCB5OjpyeSlcblxubGV0IHJlYyBjb21iaW5lIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiAoYTEsIGEyKSA6OiBjb21iaW5lIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5jb21iaW5lXCJcblxuKCoqIHNvcnRpbmcgKilcblxubGV0IHJlYyBtZXJnZSBjbXAgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBsMiAtPiBsMlxuICB8IGwxLCBbXSAtPiBsMVxuICB8IGgxIDo6IHQxLCBoMiA6OiB0MiAtPlxuICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgIHRoZW4gaDEgOjogbWVyZ2UgY21wIHQxIGwyXG4gICAgICBlbHNlIGgyIDo6IG1lcmdlIGNtcCBsMSB0MlxuXG5cbmxldCBzdGFibGVfc29ydCBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPD0gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPSBpZiBjbXAgeDEgeDIgPD0gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV0gaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGlmIGNtcCB4MSB4MiA8PSAwIHRoZW5cbiAgICAgICAgICAgIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzIDw9IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZV9yZXYgczEgczIgW10sIHRsKVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID0gaWYgY21wIHgxIHgyID4gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV0gaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGlmIGNtcCB4MSB4MiA+IDAgdGhlblxuICAgICAgICAgICAgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzID4gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHNvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlIHMxIHMyIFtdLCB0bClcbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2UgZnN0IChzb3J0IGxlbiBsKVxuXG5cbmxldCBzb3J0ID0gc3RhYmxlX3NvcnRcbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiBOb3RlOiBvbiBhIGxpc3Qgb2YgbGVuZ3RoIGJldHdlZW4gYWJvdXQgMTAwMDAwIChkZXBlbmRpbmcgb24gdGhlIG1pbm9yXG4gICBoZWFwIHNpemUgYW5kIHRoZSB0eXBlIG9mIHRoZSBsaXN0KSBhbmQgU3lzLm1heF9hcnJheV9zaXplLCBpdCBpc1xuICAgYWN0dWFsbHkgZmFzdGVyIHRvIHVzZSB0aGUgZm9sbG93aW5nLCBidXQgaXQgbWlnaHQgYWxzbyB1c2UgbW9yZSBtZW1vcnlcbiAgIGJlY2F1c2UgdGhlIGFyZ3VtZW50IGxpc3QgY2Fubm90IGJlIGRlYWxsb2NhdGVkIGluY3JlbWVudGFsbHkuXG5cbiAgIEFsc28sIHRoZXJlIHNlZW1zIHRvIGJlIGEgYnVnIGluIHRoaXMgY29kZSBvciBpbiB0aGVcbiAgIGltcGxlbWVudGF0aW9uIG9mIG9ial90cnVuY2F0ZS5cblxuZXh0ZXJuYWwgb2JqX3RydW5jYXRlIDogJ2EgYXJyYXkgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3RydW5jYXRlXCJcblxubGV0IGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYSA9XG4gIGxldCBsID0gQXJyYXkubGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGFjY3UgbiBwID1cbiAgICBpZiBwIDw9IDAgdGhlbiBhY2N1IGVsc2UgYmVnaW5cbiAgICAgIGlmIHAgPSBuIHRoZW4gYmVnaW5cbiAgICAgICAgb2JqX3RydW5jYXRlIGEgcDtcbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSAobi0xMDAwKSAocC0xKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSBuIChwLTEpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBbXSAobC0xMDAwKSBsXG5cblxubGV0IHN0YWJsZV9zb3J0IGNtcCBsID1cbiAgbGV0IGEgPSBBcnJheS5vZl9saXN0IGwgaW5cbiAgQXJyYXkuc3RhYmxlX3NvcnQgY21wIGE7XG4gIGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYVxuXG4qKVxuXG5cbigqKiBzb3J0aW5nICsgcmVtb3ZpbmcgZHVwbGljYXRlcyAqKVxuXG5sZXQgc29ydF91bmlxIGNtcCBsID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGxldCBjID0gY21wIGgxIGgyIGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gcmV2X21lcmdlIHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZV9yZXYgdDEgdDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIGlmIGMgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml0gZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSByZXZfc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlX3JldiBzMSBzMiBbXSwgdGwpXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml0gZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSBzb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZSBzMSBzMiBbXSwgdGwpXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIGZzdCAoc29ydCBsZW4gbClcblxuXG5sZXQgcmVjIGNvbXBhcmVfbGVuZ3RocyBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCBfIDo6IGwxLCBfIDo6IGwyIC0+IGNvbXBhcmVfbGVuZ3RocyBsMSBsMlxuXG5sZXQgcmVjIGNvbXBhcmVfbGVuZ3RoX3dpdGggbCBuID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT5cbiAgICBpZiBuID0gMCB0aGVuIDAgZWxzZVxuICAgICAgaWYgbiA+IDAgdGhlbiAtMSBlbHNlIDFcbiAgfCBfIDo6IGwgLT5cbiAgICBpZiBuIDw9IDAgdGhlbiAxIGVsc2VcbiAgICAgIGNvbXBhcmVfbGVuZ3RoX3dpdGggbCAobi0xKVxuXG4oKiogezEgQ29tcGFyaXNvbn0gKilcblxuKCogTm90ZTogd2UgYXJlICpub3QqIHNob3J0Y3V0dGluZyB0aGUgbGlzdCBieSB1c2luZ1xuICAgW0xpc3QuY29tcGFyZV9sZW5ndGhzXSBmaXJzdDsgdGhpcyBtYXkgYmUgc2xvd2VyIG9uIGxvbmcgbGlzdHNcbiAgIGltbWVkaWF0ZWx5IHN0YXJ0IHdpdGggZGlzdGluY3QgZWxlbWVudHMuIEl0IGlzIGFsc28gaW5jb3JyZWN0IGZvclxuICAgW2NvbXBhcmVdIGJlbG93LCBhbmQgaXQgaXMgYmV0dGVyIChwcmluY2lwbGUgb2YgbGVhc3Qgc3VycHJpc2UpIHRvXG4gICB1c2UgdGhlIHNhbWUgYXBwcm9hY2ggZm9yIGJvdGggZnVuY3Rpb25zLiAqKVxubGV0IHJlYyBlcXVhbCBlcSBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IHRydWVcbiAgfCBbXSwgXzo6XyB8IF86Ol8sIFtdIC0+IGZhbHNlXG4gIHwgYTE6OmwxLCBhMjo6bDIgLT4gZXEgYTEgYTIgJiYgZXF1YWwgZXEgbDEgbDJcblxubGV0IHJlYyBjb21wYXJlIGNtcCBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXzo6XyAtPiAtMVxuICB8IF86Ol8sIFtdIC0+IDFcbiAgfCBhMTo6bDEsIGEyOjpsMiAtPlxuICAgIGxldCBjID0gY21wIGExIGEyIGluXG4gICAgaWYgYyA8PiAwIHRoZW4gY1xuICAgIGVsc2UgY29tcGFyZSBjbXAgbDEgbDJcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBsID1cbiAgbGV0IHJlYyBhdXggbCAoKSA9IG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gU2VxLk5pbFxuICAgIHwgeCA6OiB0YWlsIC0+IFNlcS5Db25zICh4LCBhdXggdGFpbClcbiAgaW5cbiAgYXV4IGxcblxubGV0IG9mX3NlcSBzZXEgPVxuICBsZXQgcmVjIGRpcmVjdCBkZXB0aCBzZXEgOiBfIGxpc3QgPVxuICAgIGlmIGRlcHRoPTBcbiAgICB0aGVuXG4gICAgICBTZXEuZm9sZF9sZWZ0IChmdW4gYWNjIHggLT4geDo6YWNjKSBbXSBzZXFcbiAgICAgIHw+IHJldiAoKiB0YWlscmVjICopXG4gICAgZWxzZSBtYXRjaCBzZXEoKSB3aXRoXG4gICAgICB8IFNlcS5OaWwgLT4gW11cbiAgICAgIHwgU2VxLkNvbnMgKHgsIG5leHQpIC0+IHggOjogZGlyZWN0IChkZXB0aC0xKSBuZXh0XG4gIGluXG4gIGRpcmVjdCA1MDAgc2VxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IGludFxuXG5sZXQgemVybyA9IDBcbmxldCBvbmUgPSAxXG5sZXQgbWludXNfb25lID0gLTFcbmV4dGVybmFsIG5lZyA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgYWRkIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgc3ViIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuZXh0ZXJuYWwgbXVsIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgZGl2IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuZXh0ZXJuYWwgcmVtIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxuZXh0ZXJuYWwgc3VjYyA6IGludCAtPiBpbnQgPSBcIiVzdWNjaW50XCJcbmV4dGVybmFsIHByZWQgOiBpbnQgLT4gaW50ID0gXCIlcHJlZGludFwiXG5sZXQgYWJzIHggPSBpZiB4ID49IDAgdGhlbiB4IGVsc2UgLXhcbmxldCBtYXhfaW50ID0gKC0xKSBsc3IgMVxubGV0IG1pbl9pbnQgPSBtYXhfaW50ICsgMVxuZXh0ZXJuYWwgbG9nYW5kIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsIGxvZ3hvciA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcbmxldCBsb2dub3QgeCA9IGxvZ3hvciB4ICgtMSlcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG5sZXQgZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5sZXQgbWluIHggeSA6IHQgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgOiB0ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuXG4oKlxuZXh0ZXJuYWwgaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQgPSBcImNhbWxfaW50X29mX3N0cmluZ1wiXG5sZXQgb2Zfc3RyaW5nIHMgPSB0cnkgU29tZSAoaW50X29mX3N0cmluZyBzKSB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG4qKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5sZXQgdG9fc3RyaW5nIHggPSBmb3JtYXRfaW50IFwiJWRcIiB4XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAqKVxuXG4oKiBXQVJOSU5HOiBTb21lIGZ1bmN0aW9ucyBpbiB0aGlzIGZpbGUgYXJlIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sIGZvclxuICAgZWZmaWNpZW5jeSByZWFzb25zLiBXaGVuIHlvdSBtb2RpZnkgdGhlIG9uZSBpbiB0aGlzIGZpbGUgeW91IG5lZWQgdG9cbiAgIG1vZGlmeSBpdHMgZHVwbGljYXRlIGluIHN0cmluZy5tbC5cbiAgIFRoZXNlIGZ1bmN0aW9ucyBoYXZlIGEgXCJkdXBsaWNhdGVkXCIgY29tbWVudCBhYm92ZSB0aGVpciBkZWZpbml0aW9uLlxuKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogYnl0ZXMgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcbmV4dGVybmFsIHN0cmluZ19sZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBnZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciA9IFwiJWJ5dGVzX3NhZmVfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc19zYWZlX3NldFwiXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIHVuc2FmZV9nZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciA9IFwiJWJ5dGVzX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9maWxsIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiBjaGFyIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2ZpbGxfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5leHRlcm5hbCB1bnNhZmVfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGJ5dGVzID0gXCIlYnl0ZXNfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOiBieXRlcyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV9ibGl0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5cbmxldCBtYWtlIG4gYyA9XG4gIGxldCBzID0gY3JlYXRlIG4gaW5cbiAgdW5zYWZlX2ZpbGwgcyAwIG4gYztcbiAgc1xuXG5sZXQgaW5pdCBuIGYgPVxuICBsZXQgcyA9IGNyZWF0ZSBuIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgcyBpIChmIGkpXG4gIGRvbmU7XG4gIHNcblxubGV0IGVtcHR5ID0gY3JlYXRlIDBcblxubGV0IGNvcHkgcyA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyBpblxuICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgdW5zYWZlX2JsaXQgcyAwIHIgMCBsZW47XG4gIHJcblxubGV0IHRvX3N0cmluZyBiID0gdW5zYWZlX3RvX3N0cmluZyAoY29weSBiKVxubGV0IG9mX3N0cmluZyBzID0gY29weSAodW5zYWZlX29mX3N0cmluZyBzKVxuXG5sZXQgc3ViIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLnN1YiAvIEJ5dGVzLnN1YlwiXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgICB1bnNhZmVfYmxpdCBzIG9mcyByIDAgbGVuO1xuICAgIHJcbiAgZW5kXG5cbmxldCBzdWJfc3RyaW5nIGIgb2ZzIGxlbiA9IHVuc2FmZV90b19zdHJpbmcgKHN1YiBiIG9mcyBsZW4pXG5cbigqIGFkZGl0aW9uIHdpdGggYW4gb3ZlcmZsb3cgY2hlY2sgKilcbmxldCAoKyspIGEgYiA9XG4gIGxldCBjID0gYSArIGIgaW5cbiAgbWF0Y2ggYSA8IDAsIGIgPCAwLCBjIDwgMCB3aXRoXG4gIHwgdHJ1ZSAsIHRydWUgLCBmYWxzZVxuICB8IGZhbHNlLCBmYWxzZSwgdHJ1ZSAgLT4gaW52YWxpZF9hcmcgXCJCeXRlcy5leHRlbmRcIiAoKiBvdmVyZmxvdyAqKVxuICB8IF8gLT4gY1xuXG5sZXQgZXh0ZW5kIHMgbGVmdCByaWdodCA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyArKyBsZWZ0ICsrIHJpZ2h0IGluXG4gIGxldCByID0gY3JlYXRlIGxlbiBpblxuICBsZXQgKHNyY29mZiwgZHN0b2ZmKSA9IGlmIGxlZnQgPCAwIHRoZW4gLWxlZnQsIDAgZWxzZSAwLCBsZWZ0IGluXG4gIGxldCBjcHlsZW4gPSBJbnQubWluIChsZW5ndGggcyAtIHNyY29mZikgKGxlbiAtIGRzdG9mZikgaW5cbiAgaWYgY3B5bGVuID4gMCB0aGVuIHVuc2FmZV9ibGl0IHMgc3Jjb2ZmIHIgZHN0b2ZmIGNweWxlbjtcbiAgclxuXG5sZXQgZmlsbCBzIG9mcyBsZW4gYyA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmZpbGwgLyBCeXRlcy5maWxsXCJcbiAgZWxzZSB1bnNhZmVfZmlsbCBzIG9mcyBsZW4gY1xuXG5sZXQgYmxpdCBzMSBvZnMxIHMyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gbGVuZ3RoIHMxIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBzMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnl0ZXMuYmxpdFwiXG4gIGVsc2UgdW5zYWZlX2JsaXQgczEgb2ZzMSBzMiBvZnMyIGxlblxuXG5sZXQgYmxpdF9zdHJpbmcgczEgb2ZzMSBzMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IHN0cmluZ19sZW5ndGggczEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIHMyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuYmxpdCAvIEJ5dGVzLmJsaXRfc3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfYmxpdF9zdHJpbmcgczEgb2ZzMSBzMiBvZnMyIGxlblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGl0ZXIgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaXRlcmkgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiQnl0ZXMuY29uY2F0XCJcblxubGV0IHJlYyBzdW1fbGVuZ3RocyBhY2Mgc2VwbGVuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2NcbiAgfCBoZCA6OiBbXSAtPiBsZW5ndGggaGQgKyBhY2NcbiAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBzZXBsZW4gKyBhY2MpIGFjYykgc2VwbGVuIHRsXG5cbmxldCByZWMgdW5zYWZlX2JsaXRzIGRzdCBwb3Mgc2VwIHNlcGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZHN0XG4gIHwgaGQgOjogW10gLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7IGRzdFxuICB8IGhkIDo6IHRsIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpO1xuICAgIHVuc2FmZV9ibGl0IHNlcCAwIGRzdCAocG9zICsgbGVuZ3RoIGhkKSBzZXBsZW47XG4gICAgdW5zYWZlX2JsaXRzIGRzdCAocG9zICsgbGVuZ3RoIGhkICsgc2VwbGVuKSBzZXAgc2VwbGVuIHRsXG5cbmxldCBjb25jYXQgc2VwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBlbXB0eVxuICB8IGwgLT4gbGV0IHNlcGxlbiA9IGxlbmd0aCBzZXAgaW5cbiAgICAgICAgICB1bnNhZmVfYmxpdHNcbiAgICAgICAgICAgIChjcmVhdGUgKHN1bV9sZW5ndGhzIDAgc2VwbGVuIGwpKVxuICAgICAgICAgICAgMCBzZXAgc2VwbGVuIGxcblxubGV0IGNhdCBzMSBzMiA9XG4gIGxldCBsMSA9IGxlbmd0aCBzMSBpblxuICBsZXQgbDIgPSBsZW5ndGggczIgaW5cbiAgbGV0IHIgPSBjcmVhdGUgKGwxICsgbDIpIGluXG4gIHVuc2FmZV9ibGl0IHMxIDAgciAwIGwxO1xuICB1bnNhZmVfYmxpdCBzMiAwIHIgbDEgbDI7XG4gIHJcblxuXG5leHRlcm5hbCBjaGFyX2NvZGU6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgY2hhcl9jaHI6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgaXNfc3BhY2UgPSBmdW5jdGlvblxuICB8ICcgJyB8ICdcXDAxMicgfCAnXFxuJyB8ICdcXHInIHwgJ1xcdCcgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IHRyaW0gcyA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbGVuICYmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgIWkpIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gIGxldCBqID0gcmVmIChsZW4gLSAxKSBpblxuICB3aGlsZSAhaiA+PSAhaSAmJiBpc19zcGFjZSAodW5zYWZlX2dldCBzICFqKSBkb1xuICAgIGRlY3IgalxuICBkb25lO1xuICBpZiAhaiA+PSAhaSB0aGVuXG4gICAgc3ViIHMgIWkgKCFqIC0gIWkgKyAxKVxuICBlbHNlXG4gICAgZW1wdHlcblxubGV0IHVuc2FmZV9lc2NhcGUgcyA9XG4gICgqIFdlIHBlcmZvcm0gdHdvIHBhc3NlcyBvbiB0aGUgaW5wdXQgc2VxdWVuY2UsIG9uZSB0byBjb21wdXRlIHRoZVxuICAgICByZXN1bHQgc2l6ZSBhbmQgb25lIHRvIHdyaXRlIHRoZSByZXN1bHQuXG5cbiAgICAgIzExNTA4LCAjMTE1MDk6IFRoaXMgbG9naWMgd291bGQgYmUgaW5jb3JyZWN0IGluIHByZXNlbmNlIG9mXG4gICAgIGNvbmN1cnJlbnQgbW9kaWZpY2F0aW9uIHRvIHRoZSBpbnB1dCwgbWFraW5nIHRoZSB1c2Ugb2ZcbiAgICAgW3Vuc2FmZV9zZXRdIGJlbG93IG1lbW9yeS11bnNhZmUuXG5cbiAgICAgUHJlY29uZGl0aW9uOiBUaGlzIGZ1bmN0aW9uIG1heSBiZSBzYWZlbHkgY2FsbGVkIG9uOlxuICAgICAtIGFuIGltbXV0YWJsZSBieXRlIHNlcXVlbmNlXG4gICAgIC0gYSB1bmlxdWVseS1vd25lZCBieXRlIHNlcXVlbmNlICh0aGUgZnVuY3Rpb24gdGFrZXMgb3duZXJzaGlwKVxuXG4gICAgIEluIGVpdGhlciBjYXNlIHdlIHJldHVybiBhIHVuaXF1ZWx5LW93bmVkIGJ5dGUgc2VxdWVuY2UuXG4gICopXG4gIGxldCBuID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgIG4gOj0gIW4gK1xuICAgICAgKG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXG4nIHwgJ1xcdCcgfCAnXFxyJyB8ICdcXGInIC0+IDJcbiAgICAgICB8ICcgJyAuLiAnficgLT4gMVxuICAgICAgIHwgXyAtPiA0KVxuICBkb25lO1xuICBpZiAhbiA9IGxlbmd0aCBzIHRoZW4gc1xuICBlbHNlIGJlZ2luXG4gICAgbGV0IHMnID0gY3JlYXRlICFuIGluXG4gICAgbiA6PSAwO1xuICAgIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICAgIGJlZ2luIG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgKCdcXFwiJyB8ICdcXFxcJykgYXMgYyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ24nXG4gICAgICB8ICdcXHQnIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAndCdcbiAgICAgIHwgJ1xccicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICdyJ1xuICAgICAgfCAnXFxiJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ2InXG4gICAgICB8ICgnICcgLi4gJ34nKSBhcyBjIC0+IHVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgfCBjIC0+XG4gICAgICAgICAgbGV0IGEgPSBjaGFyX2NvZGUgYyBpblxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyBhIC8gMTAwKSk7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIChhIC8gMTApIG1vZCAxMCkpO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyBhIG1vZCAxMCkpO1xuICAgICAgZW5kO1xuICAgICAgaW5jciBuXG4gICAgZG9uZTtcbiAgICBzJ1xuICBlbmRcblxubGV0IGVzY2FwZWQgYiA9XG4gIGxldCBiID0gY29weSBiIGluXG4gICgqIFdlIGNvcHkgb3VyIGlucHV0IHRvIG9idGFpbiBhIHVuaXF1ZWx5LW93bmVkIGJ5dGUgc2VxdWVuY2UgW2JdXG4gICAgIHRvIHNhdGlzZnkgW3Vuc2FmZV9lc2NhcGVdJ3MgcHJlY29uZGl0aW9uICopXG4gIHVuc2FmZV9lc2NhcGUgYlxuXG5sZXQgbWFwIGYgcyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgbCA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IHMgaSkpIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IG1hcGkgZiBzID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBsID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG8gdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBzIGkpKSBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCBmb2xkX2xlZnQgZiB4IGEgPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lO1xuICAhclxuXG5sZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSBsZW5ndGggYSAtIDEgZG93bnRvIDAgZG9cbiAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICBkb25lO1xuICAhclxuXG5sZXQgZXhpc3RzIHAgcyA9XG4gIGxldCBuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgcyBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBmb3JfYWxsIHAgcyA9XG4gIGxldCBuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBzIGkpIHRoZW4gbG9vcCAoc3VjYyBpKVxuICAgIGVsc2UgZmFsc2UgaW5cbiAgbG9vcCAwXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgcyA9IG1hcCBDaGFyLnVwcGVyY2FzZV9hc2NpaSBzXG5sZXQgbG93ZXJjYXNlX2FzY2lpIHMgPSBtYXAgQ2hhci5sb3dlcmNhc2VfYXNjaWkgc1xuXG5sZXQgYXBwbHkxIGYgcyA9XG4gIGlmIGxlbmd0aCBzID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY29weSBzIGluXG4gICAgdW5zYWZlX3NldCByIDAgKGYodW5zYWZlX2dldCBzIDApKTtcbiAgICByXG4gIGVuZFxuXG5sZXQgY2FwaXRhbGl6ZV9hc2NpaSBzID0gYXBwbHkxIENoYXIudXBwZXJjYXNlX2FzY2lpIHNcbmxldCB1bmNhcGl0YWxpemVfYXNjaWkgcyA9IGFwcGx5MSBDaGFyLmxvd2VyY2FzZV9hc2NpaSBzXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgc3RhcnRzX3dpdGggfnByZWZpeCBzID1cbiAgbGV0IGxlbl9zID0gbGVuZ3RoIHNcbiAgYW5kIGxlbl9wcmUgPSBsZW5ndGggcHJlZml4IGluXG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIGkgPSBsZW5fcHJlIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgdW5zYWZlX2dldCBzIGkgPD4gdW5zYWZlX2dldCBwcmVmaXggaSB0aGVuIGZhbHNlXG4gICAgZWxzZSBhdXggKGkgKyAxKVxuICBpbiBsZW5fcyA+PSBsZW5fcHJlICYmIGF1eCAwXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgZW5kc193aXRoIH5zdWZmaXggcyA9XG4gIGxldCBsZW5fcyA9IGxlbmd0aCBzXG4gIGFuZCBsZW5fc3VmID0gbGVuZ3RoIHN1ZmZpeCBpblxuICBsZXQgZGlmZiA9IGxlbl9zIC0gbGVuX3N1ZiBpblxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID0gbGVuX3N1ZiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHVuc2FmZV9nZXQgcyAoZGlmZiArIGkpIDw+IHVuc2FmZV9nZXQgc3VmZml4IGkgdGhlbiBmYWxzZVxuICAgIGVsc2UgYXV4IChpICsgMSlcbiAgaW4gZGlmZiA+PSAwICYmIGF1eCAwXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIGluZGV4X3JlYyBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSBpbmRleF9yZWMgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXggcyBjID0gaW5kZXhfcmVjIHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgaW5kZXhfcmVjX29wdCBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSBpbmRleF9yZWNfb3B0IHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X29wdCBzIGMgPSBpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb20gLyBCeXRlcy5pbmRleF9mcm9tXCIgZWxzZVxuICBpbmRleF9yZWMgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5pbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICBpbmRleF9yZWNfb3B0IHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgcmluZGV4X3JlYyBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIHJpbmRleF9yZWMgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXggcyBjID0gcmluZGV4X3JlYyBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbSAvIEJ5dGVzLnJpbmRleF9mcm9tXCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWMgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgcmluZGV4X3JlY19vcHQgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSByaW5kZXhfcmVjX29wdCBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9vcHQgcyBjID0gcmluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX29wdCAvIEJ5dGVzLnJpbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjX29wdCBzIGkgY1xuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5jb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKGluZGV4X3JlYyBzIGwgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgY29udGFpbnMgcyBjID0gY29udGFpbnNfZnJvbSBzIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJjb250YWluc19mcm9tIHMgaSBjID1cbiAgaWYgaSA8IDAgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5yY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChyaW5kZXhfcmVjIHMgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5cbnR5cGUgdCA9IGJ5dGVzXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmV4dGVybmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2wgPSBcImNhbWxfYnl0ZXNfZXF1YWxcIiBbQEBub2FsbG9jXVxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHNwbGl0X29uX2NoYXIgc2VwIHMgPVxuICBsZXQgciA9IHJlZiBbXSBpblxuICBsZXQgaiA9IHJlZiAobGVuZ3RoIHMpIGluXG4gIGZvciBpID0gbGVuZ3RoIHMgLSAxIGRvd250byAwIGRvXG4gICAgaWYgdW5zYWZlX2dldCBzIGkgPSBzZXAgdGhlbiBiZWdpblxuICAgICAgciA6PSBzdWIgcyAoaSArIDEpICghaiAtIGkgLSAxKSA6OiAhcjtcbiAgICAgIGogOj0gaVxuICAgIGVuZFxuICBkb25lO1xuICBzdWIgcyAwICFqIDo6ICFyXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPSBsZW5ndGggcyB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IGdldCBzIGkgaW5cbiAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCB0b19zZXFpIHMgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpID0gbGVuZ3RoIHMgdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBnZXQgcyBpIGluXG4gICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IG4gPSByZWYgMCBpblxuICBsZXQgYnVmID0gcmVmIChtYWtlIDI1NiAnXFwwMDAnKSBpblxuICBsZXQgcmVzaXplICgpID1cbiAgICAoKiByZXNpemUgKilcbiAgICBsZXQgbmV3X2xlbiA9IEludC5taW4gKDIgKiBsZW5ndGggIWJ1ZikgU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGluXG4gICAgaWYgbGVuZ3RoICFidWYgPSBuZXdfbGVuIHRoZW4gZmFpbHdpdGggXCJCeXRlcy5vZl9zZXE6IGNhbm5vdCBncm93IGJ5dGVzXCI7XG4gICAgbGV0IG5ld19idWYgPSBtYWtlIG5ld19sZW4gJ1xcMDAwJyBpblxuICAgIGJsaXQgIWJ1ZiAwIG5ld19idWYgMCAhbjtcbiAgICBidWYgOj0gbmV3X2J1ZlxuICBpblxuICBTZXEuaXRlclxuICAgIChmdW4gYyAtPlxuICAgICAgIGlmICFuID0gbGVuZ3RoICFidWYgdGhlbiByZXNpemUoKTtcbiAgICAgICBzZXQgIWJ1ZiAhbiBjO1xuICAgICAgIGluY3IgbilcbiAgICBpO1xuICBzdWIgIWJ1ZiAwICFuXG5cbigqKiB7NiBCaW5hcnkgZW5jb2RpbmcvZGVjb2Rpbmcgb2YgaW50ZWdlcnN9ICopXG5cbigqIFRoZSBnZXRfIGZ1bmN0aW9ucyBhcmUgYWxsIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5cbmV4dGVybmFsIHVuc2FmZV9nZXRfdWludDggOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCIlYnl0ZXNfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfZ2V0X3VpbnQxNl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcIiVjYW1sX2J5dGVzX2dldDE2dVwiXG5leHRlcm5hbCBnZXRfdWludDggOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCIlYnl0ZXNfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgZ2V0X3VpbnQxNl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcIiVjYW1sX2J5dGVzX2dldDE2XCJcbmV4dGVybmFsIGdldF9pbnQzMl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQzMiA9IFwiJWNhbWxfYnl0ZXNfZ2V0MzJcIlxuZXh0ZXJuYWwgZ2V0X2ludDY0X25lIDogYnl0ZXMgLT4gaW50IC0+IGludDY0ID0gXCIlY2FtbF9ieXRlc19nZXQ2NFwiXG5cbmV4dGVybmFsIHVuc2FmZV9zZXRfdWludDggOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfdWludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiJWNhbWxfYnl0ZXNfc2V0MTZ1XCJcbmV4dGVybmFsIHNldF9pbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgc2V0X2ludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQxNlwiXG5leHRlcm5hbCBzZXRfaW50MzJfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MzJcIlxuZXh0ZXJuYWwgc2V0X2ludDY0X25lIDogYnl0ZXMgLT4gaW50IC0+IGludDY0IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDY0XCJcbmV4dGVybmFsIHN3YXAxNiA6IGludCAtPiBpbnQgPSBcIiVic3dhcDE2XCJcbmV4dGVybmFsIHN3YXAzMiA6IGludDMyIC0+IGludDMyID0gXCIlYnN3YXBfaW50MzJcIlxuZXh0ZXJuYWwgc3dhcDY0IDogaW50NjQgLT4gaW50NjQgPSBcIiVic3dhcF9pbnQ2NFwiXG5cbmxldCB1bnNhZmVfZ2V0X3VpbnQxNl9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhblxuICB0aGVuIHN3YXAxNiAodW5zYWZlX2dldF91aW50MTZfbmUgYiBpKVxuICBlbHNlIHVuc2FmZV9nZXRfdWludDE2X25lIGIgaVxuXG5sZXQgdW5zYWZlX2dldF91aW50MTZfYmUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW5cbiAgdGhlbiB1bnNhZmVfZ2V0X3VpbnQxNl9uZSBiIGlcbiAgZWxzZSBzd2FwMTYgKHVuc2FmZV9nZXRfdWludDE2X25lIGIgaSlcblxubGV0IGdldF9pbnQ4IGIgaSA9XG4gICgoZ2V0X3VpbnQ4IGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSA4KSkgYXNyIChTeXMuaW50X3NpemUgLSA4KVxuXG5sZXQgZ2V0X3VpbnQxNl9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiAoZ2V0X3VpbnQxNl9uZSBiIGkpXG4gIGVsc2UgZ2V0X3VpbnQxNl9uZSBiIGlcblxubGV0IGdldF91aW50MTZfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDE2IChnZXRfdWludDE2X25lIGIgaSlcbiAgZWxzZSBnZXRfdWludDE2X25lIGIgaVxuXG5sZXQgZ2V0X2ludDE2X25lIGIgaSA9XG4gICgoZ2V0X3VpbnQxNl9uZSBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gMTYpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDE2KVxuXG5sZXQgZ2V0X2ludDE2X2xlIGIgaSA9XG4gICgoZ2V0X3VpbnQxNl9sZSBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gMTYpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDE2KVxuXG5sZXQgZ2V0X2ludDE2X2JlIGIgaSA9XG4gICgoZ2V0X3VpbnQxNl9iZSBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gMTYpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDE2KVxuXG5sZXQgZ2V0X2ludDMyX2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIChnZXRfaW50MzJfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQzMl9uZSBiIGlcblxubGV0IGdldF9pbnQzMl9iZSBiIGkgPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMzIgKGdldF9pbnQzMl9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDMyX25lIGIgaVxuXG5sZXQgZ2V0X2ludDY0X2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IChnZXRfaW50NjRfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQ2NF9uZSBiIGlcblxubGV0IGdldF9pbnQ2NF9iZSBiIGkgPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwNjQgKGdldF9pbnQ2NF9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDY0X25lIGIgaVxuXG5sZXQgdW5zYWZlX3NldF91aW50MTZfbGUgYiBpIHggPVxuICBpZiBTeXMuYmlnX2VuZGlhblxuICB0aGVuIHVuc2FmZV9zZXRfdWludDE2X25lIGIgaSAoc3dhcDE2IHgpXG4gIGVsc2UgdW5zYWZlX3NldF91aW50MTZfbmUgYiBpIHhcblxubGV0IHVuc2FmZV9zZXRfdWludDE2X2JlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW5cbiAgdGhlbiB1bnNhZmVfc2V0X3VpbnQxNl9uZSBiIGkgeCBlbHNlXG4gIHVuc2FmZV9zZXRfdWludDE2X25lIGIgaSAoc3dhcDE2IHgpXG5cbmxldCBzZXRfaW50MTZfbGUgYiBpIHggPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuICBlbHNlIHNldF9pbnQxNl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDE2X2JlIGIgaSB4ID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDE2X25lIGIgaSAoc3dhcDE2IHgpXG4gIGVsc2Ugc2V0X2ludDE2X25lIGIgaSB4XG5cbmxldCBzZXRfaW50MzJfbGUgYiBpIHggPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQzMl9uZSBiIGkgKHN3YXAzMiB4KVxuICBlbHNlIHNldF9pbnQzMl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDMyX2JlIGIgaSB4ID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDMyX25lIGIgaSAoc3dhcDMyIHgpXG4gIGVsc2Ugc2V0X2ludDMyX25lIGIgaSB4XG5cbmxldCBzZXRfaW50NjRfbGUgYiBpIHggPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQ2NF9uZSBiIGkgKHN3YXA2NCB4KVxuICBlbHNlIHNldF9pbnQ2NF9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDY0X2JlIGIgaSB4ID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDY0X25lIGIgaSAoc3dhcDY0IHgpXG4gIGVsc2Ugc2V0X2ludDY0X25lIGIgaSB4XG5cbmxldCBzZXRfdWludDggPSBzZXRfaW50OFxubGV0IHNldF91aW50MTZfbmUgPSBzZXRfaW50MTZfbmVcbmxldCBzZXRfdWludDE2X2JlID0gc2V0X2ludDE2X2JlXG5sZXQgc2V0X3VpbnQxNl9sZSA9IHNldF9pbnQxNl9sZVxuXG4oKiBVVEYgY29kZWNzIGFuZCB2YWxpZGF0aW9ucyAqKVxuXG5sZXQgZGVjX2ludmFsaWQgPSBVY2hhci51dGZfZGVjb2RlX2ludmFsaWRcbmxldFtAaW5saW5lXSBkZWNfcmV0IG4gdSA9IFVjaGFyLnV0Zl9kZWNvZGUgbiAoVWNoYXIudW5zYWZlX29mX2ludCB1KVxuXG4oKiBJbiBjYXNlIG9mIGRlY29kaW5nIGVycm9yLCBpZiB3ZSBlcnJvciBvbiB0aGUgZmlyc3QgYnl0ZSwgd2VcbiAgIGNvbnN1bWUgdGhlIGJ5dGUsIG90aGVyd2lzZSB3ZSBjb25zdW1lIHRoZSBbbl0gYnl0ZXMgcHJlY2VkaW5nXG4gICB0aGUgZXJyb3JpbmcgYnl0ZS5cblxuICAgVGhpcyBtZWFucyB0aGF0IGlmIGEgY2xpZW50IHVzZXMgZGVjb2RlcyB3aXRob3V0IGNhcmluZyBhYm91dFxuICAgdmFsaWRpdHkgaXQgbmF0dXJhbGx5IHJlcGxhY2UgYm9ndXMgZGF0YSB3aXRoIFVjaGFyLnJlcCBhY2NvcmRpbmdcbiAgIHRvIHRoZSBXSEFUV0cgRW5jb2Rpbmcgc3RhbmRhcmQuIE90aGVyIHNjaGVtZXMgYXJlIHBvc3NpYmxlIGJ5XG4gICBjb25zdWx0aW5nIHRoZSBudW1iZXIgb2YgdXNlZCBieXRlcyBvbiBpbnZhbGlkIGRlY29kZXMuIEZvciBtb3JlXG4gICBkZXRhaWxzIHNlZSBodHRwczovL2hzaXZvbmVuLmZpL2Jyb2tlbi11dGYtOC9cblxuICAgRm9yIHRoaXMgcmVhc29uIGluIFtnZXRfdXRmXzhfdWNoYXJdIHdlIGdyYWR1YWxseSBjaGVjayB0aGUgbmV4dFxuICAgYnl0ZSBpcyBhdmFpbGFibGUgcmF0aGVyIHRoYW4gZG9pbmcgaXQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlXG4gICBmaXJzdCBieXRlLiBDb250cmFzdCB3aXRoIFtpc192YWxpZF91dGZfOF0uICopXG5cbigqIFVURi04ICopXG5cbmxldFtAaW5saW5lXSBub3RfaW5feDgwX3RvX3hCRiBiID0gYiBsc3IgNiA8PiAwYjEwXG5sZXRbQGlubGluZV0gbm90X2luX3hBMF90b194QkYgYiA9IGIgbHNyIDUgPD4gMGIxMDFcbmxldFtAaW5saW5lXSBub3RfaW5feDgwX3RvX3g5RiBiID0gYiBsc3IgNSA8PiAwYjEwMFxubGV0W0BpbmxpbmVdIG5vdF9pbl94OTBfdG9feEJGIGIgPSBiIDwgMHg5MCB8fCAweEJGIDwgYlxubGV0W0BpbmxpbmVdIG5vdF9pbl94ODBfdG9feDhGIGIgPSBiIGxzciA0IDw+IDB4OFxuXG5sZXRbQGlubGluZV0gdXRmXzhfdWNoYXJfMiBiMCBiMSA9XG4gICgoYjAgbGFuZCAweDFGKSBsc2wgNikgbG9yXG4gICgoYjEgbGFuZCAweDNGKSlcblxubGV0W0BpbmxpbmVdIHV0Zl84X3VjaGFyXzMgYjAgYjEgYjIgPVxuICAoKGIwIGxhbmQgMHgwRikgbHNsIDEyKSBsb3JcbiAgKChiMSBsYW5kIDB4M0YpIGxzbCA2KSBsb3JcbiAgKChiMiBsYW5kIDB4M0YpKVxuXG5sZXRbQGlubGluZV0gdXRmXzhfdWNoYXJfNCBiMCBiMSBiMiBiMyA9XG4gICgoYjAgbGFuZCAweDA3KSBsc2wgMTgpIGxvclxuICAoKGIxIGxhbmQgMHgzRikgbHNsIDEyKSBsb3JcbiAgKChiMiBsYW5kIDB4M0YpIGxzbCA2KSBsb3JcbiAgKChiMyBsYW5kIDB4M0YpKVxuXG5sZXQgZ2V0X3V0Zl84X3VjaGFyIGIgaSA9XG4gIGxldCBiMCA9IGdldF91aW50OCBiIGkgaW4gKCogcmFpc2VzIGlmIFtpXSBpcyBub3QgYSB2YWxpZCBpbmRleC4gKilcbiAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDggaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBtYXRjaCBDaGFyLnVuc2FmZV9jaHIgYjAgd2l0aCAoKiBTZWUgVGhlIFVuaWNvZGUgU3RhbmRhcmQsIFRhYmxlIDMuNyAqKVxuICB8ICdcXHgwMCcgLi4gJ1xceDdGJyAtPiBkZWNfcmV0IDEgYjBcbiAgfCAnXFx4QzInIC4uICdcXHhERicgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgZGVjX3JldCAyICh1dGZfOF91Y2hhcl8yIGIwIGIxKVxuICB8ICdcXHhFMCcgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feEEwX3RvX3hCRiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBkZWNfcmV0IDMgKHV0Zl84X3VjaGFyXzMgYjAgYjEgYjIpXG4gIHwgJ1xceEUxJyAuLiAnXFx4RUMnIHwgJ1xceEVFJyAuLiAnXFx4RUYnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgZGVjX3JldCAzICh1dGZfOF91Y2hhcl8zIGIwIGIxIGIyKVxuICB8ICdcXHhFRCcgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3g5RiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBkZWNfcmV0IDMgKHV0Zl84X3VjaGFyXzMgYjAgYjEgYjIpXG4gIHwgJ1xceEYwJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94OTBfdG9feEJGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgbGV0IGIzID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMyB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgZGVjX3JldCA0ICh1dGZfOF91Y2hhcl80IGIwIGIxIGIyIGIzKVxuICB8ICdcXHhGMScgLi4gJ1xceEYzJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgbGV0IGIzID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMyB0aGVuIGRlY19pbnZhbGlkIDMgZWxzZVxuICAgICAgZGVjX3JldCA0ICh1dGZfOF91Y2hhcl80IGIwIGIxIGIyIGIzKVxuICB8ICdcXHhGNCcgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3g4RiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGxldCBiMyA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjMgdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGRlY19yZXQgNCAodXRmXzhfdWNoYXJfNCBiMCBiMSBiMiBiMylcbiAgfCBfIC0+IGRlY19pbnZhbGlkIDFcblxubGV0IHNldF91dGZfOF91Y2hhciBiIGkgdSA9XG4gIGxldCBzZXQgPSB1bnNhZmVfc2V0X3VpbnQ4IGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuICB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiAgfCB1IHdoZW4gdSA8PSAweDAwN0YgLT5cbiAgICAgIHNldF91aW50OCBiIGkgdTtcbiAgICAgIDFcbiAgfCB1IHdoZW4gdSA8PSAweDA3RkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDEgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2VcbiAgICAgIChzZXRfdWludDggYiBpICgweEMwIGxvciAodSBsc3IgNikpO1xuICAgICAgIHNldCBiIGxhc3QgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpO1xuICAgICAgIDIpXG4gIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAyIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlXG4gICAgICAoc2V0X3VpbnQ4IGIgaSAoMHhFMCBsb3IgKHUgbHNyIDEyKSk7XG4gICAgICAgc2V0IGIgKGkgKyAxKSAoMHg4MCBsb3IgKCh1IGxzciA2KSBsYW5kIDB4M0YpKTtcbiAgICAgICBzZXQgYiBsYXN0ICgweDgwIGxvciAodSBsYW5kIDB4M0YpKTtcbiAgICAgICAzKVxuICB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlXG4gICAgICAoc2V0X3VpbnQ4IGIgaSAoMHhGMCBsb3IgKHUgbHNyIDE4KSk7XG4gICAgICAgc2V0IGIgKGkgKyAxKSAoMHg4MCBsb3IgKCh1IGxzciAxMikgbGFuZCAweDNGKSk7XG4gICAgICAgc2V0IGIgKGkgKyAyKSAoMHg4MCBsb3IgKCh1IGxzciA2KSBsYW5kIDB4M0YpKTtcbiAgICAgICBzZXQgYiBsYXN0ICgweDgwIGxvciAodSBsYW5kIDB4M0YpKTtcbiAgICAgICA0KVxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBpc192YWxpZF91dGZfOCBiID1cbiAgbGV0IHJlYyBsb29wIG1heCBiIGkgPVxuICAgIGlmIGkgPiBtYXggdGhlbiB0cnVlIGVsc2VcbiAgICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50OCBpblxuICAgIG1hdGNoIENoYXIudW5zYWZlX2NociAoZ2V0IGIgaSkgd2l0aFxuICAgIHwgJ1xceDAwJyAuLiAnXFx4N0YnIC0+IGxvb3AgbWF4IGIgKGkgKyAxKVxuICAgIHwgJ1xceEMyJyAuLiAnXFx4REYnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDEgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEUwJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAyIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3hBMF90b194QkYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RTEnIC4uICdcXHhFQycgfCAnXFx4RUUnIC4uICdcXHhFRicgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMiBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEVEJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAyIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194OUYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RjAnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDkwX3RvX3hCRiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIChpICsgMikpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RjEnIC4uICdcXHhGMycgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgKGkgKyAyKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhGNCcgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feDhGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgKGkgKyAyKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8IF8gLT4gZmFsc2VcbiAgaW5cbiAgbG9vcCAobGVuZ3RoIGIgLSAxKSBiIDBcblxuKCogVVRGLTE2QkUgKilcblxubGV0IGdldF91dGZfMTZiZV91Y2hhciBiIGkgPVxuICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50MTZfYmUgaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBpZiBpIDwgMCB8fCBpID4gbWF4IHRoZW4gaW52YWxpZF9hcmcgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIgZWxzZVxuICBpZiBpID0gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gIG1hdGNoIGdldCBiIGkgd2l0aFxuICB8IHUgd2hlbiB1IDwgMHhEODAwIHx8IHUgPiAweERGRkYgLT4gZGVjX3JldCAyIHVcbiAgfCB1IHdoZW4gdSA+IDB4REJGRiAtPiBkZWNfaW52YWxpZCAyXG4gIHwgaGkgLT4gKCogY29tYmluZSBbaGldIHdpdGggYSBsb3cgc3Vycm9nYXRlICopXG4gICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgKG1heCAtIGkgKyAxKSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiAoaSArIDIpIHdpdGhcbiAgICAgIHwgdSB3aGVuIHUgPCAweERDMDAgfHwgdSA+IDB4REZGRiAtPiBkZWNfaW52YWxpZCAyICgqIHJldHJ5IGhlcmUgKilcbiAgICAgIHwgbG8gLT5cbiAgICAgICAgICBsZXQgdSA9ICgoKGhpIGxhbmQgMHgzRkYpIGxzbCAxMCkgbG9yIChsbyBsYW5kIDB4M0ZGKSkgKyAweDEwMDAwIGluXG4gICAgICAgICAgZGVjX3JldCA0IHVcblxubGV0IHNldF91dGZfMTZiZV91Y2hhciBiIGkgdSA9XG4gIGxldCBzZXQgPSB1bnNhZmVfc2V0X3VpbnQxNl9iZSBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBtYXggdGhlbiBpbnZhbGlkX2FyZyBcImluZGV4IG91dCBvZiBib3VuZHNcIiBlbHNlXG4gIG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiAgfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAxIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlIChzZXQgYiBpIHU7IDIpXG4gIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2VcbiAgICAgIGxldCB1JyA9IHUgLSAweDEwMDAwIGluXG4gICAgICBsZXQgaGkgPSAoMHhEODAwIGxvciAodScgbHNyIDEwKSkgaW5cbiAgICAgIGxldCBsbyA9ICgweERDMDAgbG9yICh1JyBsYW5kIDB4M0ZGKSkgaW5cbiAgICAgIHNldCBiIGkgaGk7IHNldCBiIChpICsgMikgbG87IDRcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgaXNfdmFsaWRfdXRmXzE2YmUgYiA9XG4gIGxldCByZWMgbG9vcCBtYXggYiBpID1cbiAgICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50MTZfYmUgaW5cbiAgICBpZiBpID4gbWF4IHRoZW4gdHJ1ZSBlbHNlXG4gICAgaWYgaSA9IG1heCB0aGVuIGZhbHNlIGVsc2VcbiAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICB8IHUgd2hlbiB1IDwgMHhEODAwIHx8IHUgPiAweERGRkYgLT4gbG9vcCBtYXggYiAoaSArIDIpXG4gICAgfCB1IHdoZW4gdSA+IDB4REJGRiAtPiBmYWxzZVxuICAgIHwgX2hpIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIGZhbHNlIGVsc2VcbiAgICAgICAgbWF0Y2ggZ2V0IGIgKGkgKyAyKSB3aXRoXG4gICAgICAgIHwgdSB3aGVuIHUgPCAweERDMDAgfHwgdSA+IDB4REZGRiAtPiBmYWxzZVxuICAgICAgICB8IF9sbyAtPiBsb29wIG1heCBiIChpICsgNClcbiAgaW5cbiAgbG9vcCAobGVuZ3RoIGIgLSAxKSBiIDBcblxuKCogVVRGLTE2TEUgKilcblxubGV0IGdldF91dGZfMTZsZV91Y2hhciBiIGkgPVxuICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50MTZfbGUgaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBpZiBpIDwgMCB8fCBpID4gbWF4IHRoZW4gaW52YWxpZF9hcmcgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIgZWxzZVxuICBpZiBpID0gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gIG1hdGNoIGdldCBiIGkgd2l0aFxuICB8IHUgd2hlbiB1IDwgMHhEODAwIHx8IHUgPiAweERGRkYgLT4gZGVjX3JldCAyIHVcbiAgfCB1IHdoZW4gdSA+IDB4REJGRiAtPiBkZWNfaW52YWxpZCAyXG4gIHwgaGkgLT4gKCogY29tYmluZSBbaGldIHdpdGggYSBsb3cgc3Vycm9nYXRlICopXG4gICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgKG1heCAtIGkgKyAxKSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiAoaSArIDIpIHdpdGhcbiAgICAgIHwgdSB3aGVuIHUgPCAweERDMDAgfHwgdSA+IDB4REZGRiAtPiBkZWNfaW52YWxpZCAyICgqIHJldHJ5IGhlcmUgKilcbiAgICAgIHwgbG8gLT5cbiAgICAgICAgICBsZXQgdSA9ICgoKGhpIGxhbmQgMHgzRkYpIGxzbCAxMCkgbG9yIChsbyBsYW5kIDB4M0ZGKSkgKyAweDEwMDAwIGluXG4gICAgICAgICAgZGVjX3JldCA0IHVcblxubGV0IHNldF91dGZfMTZsZV91Y2hhciBiIGkgdSA9XG4gIGxldCBzZXQgPSB1bnNhZmVfc2V0X3VpbnQxNl9sZSBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBtYXggdGhlbiBpbnZhbGlkX2FyZyBcImluZGV4IG91dCBvZiBib3VuZHNcIiBlbHNlXG4gIG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiAgfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAxIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlIChzZXQgYiBpIHU7IDIpXG4gIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiAwIGVsc2VcbiAgICAgIGxldCB1JyA9IHUgLSAweDEwMDAwIGluXG4gICAgICBsZXQgaGkgPSAoMHhEODAwIGxvciAodScgbHNyIDEwKSkgaW5cbiAgICAgIGxldCBsbyA9ICgweERDMDAgbG9yICh1JyBsYW5kIDB4M0ZGKSkgaW5cbiAgICAgIHNldCBiIGkgaGk7IHNldCBiIChpICsgMikgbG87IDRcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgaXNfdmFsaWRfdXRmXzE2bGUgYiA9XG4gIGxldCByZWMgbG9vcCBtYXggYiBpID1cbiAgICBsZXQgZ2V0ID0gdW5zYWZlX2dldF91aW50MTZfbGUgaW5cbiAgICBpZiBpID4gbWF4IHRoZW4gdHJ1ZSBlbHNlXG4gICAgaWYgaSA9IG1heCB0aGVuIGZhbHNlIGVsc2VcbiAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICB8IHUgd2hlbiB1IDwgMHhEODAwIHx8IHUgPiAweERGRkYgLT4gbG9vcCBtYXggYiAoaSArIDIpXG4gICAgfCB1IHdoZW4gdSA+IDB4REJGRiAtPiBmYWxzZVxuICAgIHwgX2hpIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIGZhbHNlIGVsc2VcbiAgICAgICAgbWF0Y2ggZ2V0IGIgKGkgKyAyKSB3aXRoXG4gICAgICAgIHwgdSB3aGVuIHUgPCAweERDMDAgfHwgdSA+IDB4REZGRiAtPiBmYWxzZVxuICAgICAgICB8IF9sbyAtPiBsb29wIG1heCBiIChpICsgNClcbiAgaW5cbiAgbG9vcCAobGVuZ3RoIGIgLSAxKSBiIDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IEdhbGxpdW0sIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU3RyaW5nIG9wZXJhdGlvbnMsIGJhc2VkIG9uIGJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAqKVxuXG4oKiBXQVJOSU5HOiBTb21lIGZ1bmN0aW9ucyBpbiB0aGlzIGZpbGUgYXJlIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgZm9yXG4gICBlZmZpY2llbmN5IHJlYXNvbnMuIFdoZW4geW91IG1vZGlmeSB0aGUgb25lIGluIHRoaXMgZmlsZSB5b3UgbmVlZCB0b1xuICAgbW9kaWZ5IGl0cyBkdXBsaWNhdGUgaW4gYnl0ZXMubWwuXG4gICBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBhIFwiZHVwbGljYXRlZFwiIGNvbW1lbnQgYWJvdmUgdGhlaXIgZGVmaW5pdGlvbi5cbiopXG5cbmV4dGVybmFsIGxlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGdldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOiBzdHJpbmcgLT4gaW50IC0+ICBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cblxubW9kdWxlIEIgPSBCeXRlc1xuXG5sZXQgYnRzID0gQi51bnNhZmVfdG9fc3RyaW5nXG5sZXQgYm9zID0gQi51bnNhZmVfb2Zfc3RyaW5nXG5cbmxldCBtYWtlIG4gYyA9XG4gIEIubWFrZSBuIGMgfD4gYnRzXG5sZXQgaW5pdCBuIGYgPVxuICBCLmluaXQgbiBmIHw+IGJ0c1xubGV0IGVtcHR5ID0gXCJcIlxubGV0IG9mX2J5dGVzID0gQi50b19zdHJpbmdcbmxldCB0b19ieXRlcyA9IEIub2Zfc3RyaW5nXG5sZXQgc3ViIHMgb2ZzIGxlbiA9XG4gIEIuc3ViIChib3Mgcykgb2ZzIGxlbiB8PiBidHNcbmxldCBibGl0ID1cbiAgQi5ibGl0X3N0cmluZ1xuXG5sZXQgZW5zdXJlX2dlICh4OmludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb25jYXRcIlxuXG5sZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyBzZXBsZW4gPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY1xuICB8IGhkIDo6IFtdIC0+IGxlbmd0aCBoZCArIGFjY1xuICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIHNlcGxlbiArIGFjYykgYWNjKSBzZXBsZW4gdGxcblxubGV0IHJlYyB1bnNhZmVfYmxpdHMgZHN0IHBvcyBzZXAgc2VwbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBkc3RcbiAgfCBoZCA6OiBbXSAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTsgZHN0XG4gIHwgaGQgOjogdGwgLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7XG4gICAgdW5zYWZlX2JsaXQgc2VwIDAgZHN0IChwb3MgKyBsZW5ndGggaGQpIHNlcGxlbjtcbiAgICB1bnNhZmVfYmxpdHMgZHN0IChwb3MgKyBsZW5ndGggaGQgKyBzZXBsZW4pIHNlcCBzZXBsZW4gdGxcblxubGV0IGNvbmNhdCBzZXAgPSBmdW5jdGlvblxuICAgIFtdIC0+IFwiXCJcbiAgfCBsIC0+IGxldCBzZXBsZW4gPSBsZW5ndGggc2VwIGluIGJ0cyBAQFxuICAgICAgICAgIHVuc2FmZV9ibGl0c1xuICAgICAgICAgICAgKEIuY3JlYXRlIChzdW1fbGVuZ3RocyAwIHNlcGxlbiBsKSlcbiAgICAgICAgICAgIDAgc2VwIHNlcGxlbiBsXG5cbmxldCBjYXQgPSAoIF4gKVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaXRlciBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgKHVuc2FmZV9nZXQgcyBpKSBkb25lXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyaSBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxubGV0IG1hcCBmIHMgPVxuICBCLm1hcCBmIChib3MgcykgfD4gYnRzXG5sZXQgbWFwaSBmIHMgPVxuICBCLm1hcGkgZiAoYm9zIHMpIHw+IGJ0c1xubGV0IGZvbGRfcmlnaHQgZiB4IGEgPVxuICBCLmZvbGRfcmlnaHQgZiAoYm9zIHgpIGFcbmxldCBmb2xkX2xlZnQgZiBhIHggPVxuICBCLmZvbGRfbGVmdCBmIGEgKGJvcyB4KVxubGV0IGV4aXN0cyBmIHMgPVxuICBCLmV4aXN0cyBmIChib3MgcylcbmxldCBmb3JfYWxsIGYgcyA9XG4gIEIuZm9yX2FsbCBmIChib3MgcylcblxuKCogQmV3YXJlOiB3ZSBjYW5ub3QgdXNlIEIudHJpbSBvciBCLmVzY2FwZSBiZWNhdXNlIHRoZXkgYWx3YXlzIG1ha2UgYVxuICAgY29weSwgYnV0IFN0cmluZy5tbGkgc3BlbGxzIG91dCBzb21lIGNhc2VzIHdoZXJlIHdlIGFyZSBub3QgYWxsb3dlZFxuICAgdG8gbWFrZSBhIGNvcHkuICopXG5cbmxldCBpc19zcGFjZSA9IGZ1bmN0aW9uXG4gIHwgJyAnIHwgJ1xcMDEyJyB8ICdcXG4nIHwgJ1xccicgfCAnXFx0JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgdHJpbSBzID1cbiAgaWYgcyA9IFwiXCIgdGhlbiBzXG4gIGVsc2UgaWYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAwKSB8fCBpc19zcGFjZSAodW5zYWZlX2dldCBzIChsZW5ndGggcyAtIDEpKVxuICAgIHRoZW4gYnRzIChCLnRyaW0gKGJvcyBzKSlcbiAgZWxzZSBzXG5cbmxldCBlc2NhcGVkIHMgPVxuICBsZXQgYiA9IGJvcyBzIGluXG4gICgqIFdlIHNhdGlzZnkgW3Vuc2FmZV9lc2NhcGVdJ3MgcHJlY29uZGl0aW9uIGJ5IHBhc3NpbmcgYW5cbiAgICAgaW1tdXRhYmxlIGJ5dGUgc2VxdWVuY2UgW2JdLiAqKVxuICBidHMgKEIudW5zYWZlX2VzY2FwZSBiKVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIGluZGV4X3JlYyBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSBpbmRleF9yZWMgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleCBzIGMgPSBpbmRleF9yZWMgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIGluZGV4X3JlY19vcHQgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgaW5kZXhfcmVjX29wdCBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X29wdCBzIGMgPSBpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbSAvIEJ5dGVzLmluZGV4X2Zyb21cIiBlbHNlXG4gICAgaW5kZXhfcmVjIHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5pbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICBpbmRleF9yZWNfb3B0IHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjIHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgcmluZGV4X3JlYyBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbSAvIEJ5dGVzLnJpbmRleF9mcm9tXCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWMgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIHJpbmRleF9yZWNfb3B0IHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX29wdCAvIEJ5dGVzLnJpbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjX29wdCBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5jb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKGluZGV4X3JlYyBzIGwgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnMgcyBjID0gY29udGFpbnNfZnJvbSBzIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgMCB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yY29udGFpbnNfZnJvbSAvIEJ5dGVzLnJjb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKHJpbmRleF9yZWMgcyBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgcyA9XG4gIEIudXBwZXJjYXNlX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgbG93ZXJjYXNlX2FzY2lpIHMgPVxuICBCLmxvd2VyY2FzZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IGNhcGl0YWxpemVfYXNjaWkgcyA9XG4gIEIuY2FwaXRhbGl6ZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IHVuY2FwaXRhbGl6ZV9hc2NpaSBzID1cbiAgQi51bmNhcGl0YWxpemVfYXNjaWkgKGJvcyBzKSB8PiBidHNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHN0YXJ0c193aXRoIH5wcmVmaXggcyA9XG4gIGxldCBsZW5fcyA9IGxlbmd0aCBzXG4gIGFuZCBsZW5fcHJlID0gbGVuZ3RoIHByZWZpeCBpblxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID0gbGVuX3ByZSB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHVuc2FmZV9nZXQgcyBpIDw+IHVuc2FmZV9nZXQgcHJlZml4IGkgdGhlbiBmYWxzZVxuICAgIGVsc2UgYXV4IChpICsgMSlcbiAgaW4gbGVuX3MgPj0gbGVuX3ByZSAmJiBhdXggMFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgZW5kc193aXRoIH5zdWZmaXggcyA9XG4gIGxldCBsZW5fcyA9IGxlbmd0aCBzXG4gIGFuZCBsZW5fc3VmID0gbGVuZ3RoIHN1ZmZpeCBpblxuICBsZXQgZGlmZiA9IGxlbl9zIC0gbGVuX3N1ZiBpblxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID0gbGVuX3N1ZiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHVuc2FmZV9nZXQgcyAoZGlmZiArIGkpIDw+IHVuc2FmZV9nZXQgc3VmZml4IGkgdGhlbiBmYWxzZVxuICAgIGVsc2UgYXV4IChpICsgMSlcbiAgaW4gZGlmZiA+PSAwICYmIGF1eCAwXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoIDogaW50IC0+IHN0cmluZyAtPiBpbnQgPSBcImNhbWxfc3RyaW5nX2hhc2hcIiBbQEBub2FsbG9jXVxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoIDAgeFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgc3BsaXRfb25fY2hhciBzZXAgcyA9XG4gIGxldCByID0gcmVmIFtdIGluXG4gIGxldCBqID0gcmVmIChsZW5ndGggcykgaW5cbiAgZm9yIGkgPSBsZW5ndGggcyAtIDEgZG93bnRvIDAgZG9cbiAgICBpZiB1bnNhZmVfZ2V0IHMgaSA9IHNlcCB0aGVuIGJlZ2luXG4gICAgICByIDo9IHN1YiBzIChpICsgMSkgKCFqIC0gaSAtIDEpIDo6ICFyO1xuICAgICAgaiA6PSBpXG4gICAgZW5kXG4gIGRvbmU7XG4gIHN1YiBzIDAgIWogOjogIXJcblxudHlwZSB0ID0gc3RyaW5nXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmV4dGVybmFsIGVxdWFsIDogc3RyaW5nIC0+IHN0cmluZyAtPiBib29sID0gXCJjYW1sX3N0cmluZ19lcXVhbFwiIFtAQG5vYWxsb2NdXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9IGJvcyBzIHw+IEIudG9fc2VxXG5cbmxldCB0b19zZXFpIHMgPSBib3MgcyB8PiBCLnRvX3NlcWlcblxubGV0IG9mX3NlcSBnID0gQi5vZl9zZXEgZyB8PiBidHNcblxuKCogVVRGIGRlY29kZXJzIGFuZCB2YWxpZGF0b3JzICopXG5cbmxldCBnZXRfdXRmXzhfdWNoYXIgcyBpID0gQi5nZXRfdXRmXzhfdWNoYXIgKGJvcyBzKSBpXG5sZXQgaXNfdmFsaWRfdXRmXzggcyA9IEIuaXNfdmFsaWRfdXRmXzggKGJvcyBzKVxuXG5sZXQgZ2V0X3V0Zl8xNmJlX3VjaGFyIHMgaSA9IEIuZ2V0X3V0Zl8xNmJlX3VjaGFyIChib3MgcykgaVxubGV0IGlzX3ZhbGlkX3V0Zl8xNmJlIHMgPSBCLmlzX3ZhbGlkX3V0Zl8xNmJlIChib3MgcylcblxubGV0IGdldF91dGZfMTZsZV91Y2hhciBzIGkgPSBCLmdldF91dGZfMTZsZV91Y2hhciAoYm9zIHMpIGlcbmxldCBpc192YWxpZF91dGZfMTZsZSBzID0gQi5pc192YWxpZF91dGZfMTZsZSAoYm9zIHMpXG5cbigqKiB7NiBCaW5hcnkgZW5jb2RpbmcvZGVjb2Rpbmcgb2YgaW50ZWdlcnN9ICopXG5cbmV4dGVybmFsIGdldF91aW50OCA6IHN0cmluZyAtPiBpbnQgLT4gaW50ID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcbmV4dGVybmFsIGdldF91aW50MTZfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludCA9IFwiJWNhbWxfc3RyaW5nX2dldDE2XCJcbmV4dGVybmFsIGdldF9pbnQzMl9uZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50MzIgPSBcIiVjYW1sX3N0cmluZ19nZXQzMlwiXG5leHRlcm5hbCBnZXRfaW50NjRfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludDY0ID0gXCIlY2FtbF9zdHJpbmdfZ2V0NjRcIlxuXG5sZXQgZ2V0X2ludDggcyBpID0gQi5nZXRfaW50OCAoYm9zIHMpIGlcbmxldCBnZXRfdWludDE2X2xlIHMgaSA9IEIuZ2V0X3VpbnQxNl9sZSAoYm9zIHMpIGlcbmxldCBnZXRfdWludDE2X2JlIHMgaSA9IEIuZ2V0X3VpbnQxNl9iZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MTZfbmUgcyBpID0gQi5nZXRfaW50MTZfbmUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDE2X2xlIHMgaSA9IEIuZ2V0X2ludDE2X2xlIChib3MgcykgaVxubGV0IGdldF9pbnQxNl9iZSBzIGkgPSBCLmdldF9pbnQxNl9iZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MzJfbGUgcyBpID0gQi5nZXRfaW50MzJfbGUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDMyX2JlIHMgaSA9IEIuZ2V0X2ludDMyX2JlIChib3MgcykgaVxubGV0IGdldF9pbnQ2NF9sZSBzIGkgPSBCLmdldF9pbnQ2NF9sZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50NjRfYmUgcyBpID0gQi5nZXRfaW50NjRfYmUgKGJvcyBzKSBpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IHVuaXQgPSAoKVxuXG5sZXQgZXF1YWwgKCkgKCkgPSB0cnVlXG5sZXQgY29tcGFyZSAoKSAoKSA9IDBcbmxldCB0b19zdHJpbmcgKCkgPSBcIigpXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBleHRlcm5fZmxhZ3MgPVxuICAgIE5vX3NoYXJpbmdcbiAgfCBDbG9zdXJlc1xuICB8IENvbXBhdF8zMlxuKCogbm90ZTogdGhpcyB0eXBlIGRlZmluaXRpb24gaXMgdXNlZCBpbiAncnVudGltZS9kZWJ1Z2dlci5jJyAqKVxuXG5leHRlcm5hbCB0b19jaGFubmVsOiBvdXRfY2hhbm5lbCAtPiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiB1bml0XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlXCJcbmV4dGVybmFsIHRvX2J5dGVzOiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBieXRlc1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19ieXRlc1wiXG5leHRlcm5hbCB0b19zdHJpbmc6ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IHN0cmluZ1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmdcIlxuZXh0ZXJuYWwgdG9fYnVmZmVyX3Vuc2FmZTpcbiAgICAgIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gaW50XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclwiXG5cbmxldCB0b19idWZmZXIgYnVmZiBvZnMgbGVuIHYgZmxhZ3MgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwudG9fYnVmZmVyOiBzdWJzdHJpbmcgb3V0IG9mIGJvdW5kc1wiXG4gIGVsc2UgdG9fYnVmZmVyX3Vuc2FmZSBidWZmIG9mcyBsZW4gdiBmbGFnc1xuXG4oKiBUaGUgZnVuY3Rpb25zIGJlbG93IHVzZSBieXRlIHNlcXVlbmNlcyBhcyBpbnB1dCwgbmV2ZXIgdXNpbmcgYW55XG4gICBtdXRhdGlvbi4gSXQgbWFrZXMgc2Vuc2UgdG8gdXNlIG5vbi1tdXRhdGVkIFtieXRlc10gcmF0aGVyIHRoYW5cbiAgIFtzdHJpbmddLCBiZWNhdXNlIHdlIHJlYWxseSB3b3JrIHdpdGggc2VxdWVuY2VzIG9mIGJ5dGVzLCBub3RcbiAgIGEgdGV4dCByZXByZXNlbnRhdGlvbi5cbiopXG5cbmV4dGVybmFsIGZyb21fY2hhbm5lbDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBmcm9tX2J5dGVzX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXNcIlxuZXh0ZXJuYWwgZGF0YV9zaXplX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZVwiXG5cbmxldCBoZWFkZXJfc2l6ZSA9IDIwXG5sZXQgZGF0YV9zaXplIGJ1ZmYgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGhlYWRlcl9zaXplXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmRhdGFfc2l6ZVwiXG4gIGVsc2UgZGF0YV9zaXplX3Vuc2FmZSBidWZmIG9mc1xubGV0IHRvdGFsX3NpemUgYnVmZiBvZnMgPSBoZWFkZXJfc2l6ZSArIGRhdGFfc2l6ZSBidWZmIG9mc1xuXG5sZXQgZnJvbV9ieXRlcyBidWZmIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBoZWFkZXJfc2l6ZVxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5mcm9tX2J5dGVzXCJcbiAgZWxzZSBiZWdpblxuICAgIGxldCBsZW4gPSBkYXRhX3NpemVfdW5zYWZlIGJ1ZmYgb2ZzIGluXG4gICAgaWYgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSAoaGVhZGVyX3NpemUgKyBsZW4pXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZnJvbV9ieXRlc1wiXG4gICAgZWxzZSBmcm9tX2J5dGVzX3Vuc2FmZSBidWZmIG9mc1xuICBlbmRcblxubGV0IGZyb21fc3RyaW5nIGJ1ZmYgb2ZzID1cbiAgKCogQnl0ZXMudW5zYWZlX29mX3N0cmluZyBpcyBzYWZlIGhlcmUsIGFzIHRoZSBwcm9kdWNlZCBieXRlXG4gICAgIHNlcXVlbmNlIGlzIG5ldmVyIG11dGF0ZWQgKilcbiAgZnJvbV9ieXRlcyAoQnl0ZXMudW5zYWZlX29mX3N0cmluZyBidWZmKSBvZnNcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIGFycmF5cy4gKilcbnR5cGUgJ2EgdCA9ICdhIGFycmF5XG5cbigqIEFycmF5IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogJ2EgYXJyYXkgLT4gaW50ID0gXCIlYXJyYXlfbGVuZ3RoXCJcbmV4dGVybmFsIGdldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3NhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9nZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSA9IFwiJWFycmF5X3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVhcnJheV91bnNhZmVfc2V0XCJcbmV4dGVybmFsIG1ha2U6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgY3JlYXRlOiBpbnQgLT4gJ2EgLT4gJ2EgYXJyYXkgPSBcImNhbWxfbWFrZV92ZWN0XCJcbmV4dGVybmFsIHVuc2FmZV9zdWIgOiAnYSBhcnJheSAtPiBpbnQgLT4gaW50IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X3N1YlwiXG5leHRlcm5hbCBhcHBlbmRfcHJpbSA6ICdhIGFycmF5IC0+ICdhIGFycmF5IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X2FwcGVuZFwiXG5leHRlcm5hbCBjb25jYXQgOiAnYSBhcnJheSBsaXN0IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X2NvbmNhdFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6XG4gICdhIGFycmF5IC0+IGludCAtPiAnYSBhcnJheSAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfYXJyYXlfYmxpdFwiXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6XG4gICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9hcnJheV9maWxsXCJcbmV4dGVybmFsIGNyZWF0ZV9mbG9hdDogaW50IC0+IGZsb2F0IGFycmF5ID0gXCJjYW1sX21ha2VfZmxvYXRfdmVjdFwiXG5cbm1vZHVsZSBGbG9hdGFycmF5ID0gc3RydWN0XG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBmbG9hdGFycmF5ID0gXCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgbGVuZ3RoIDogZmxvYXRhcnJheSAtPiBpbnQgPSBcIiVmbG9hdGFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIGdldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXRcbiAgICAgID0gXCIlZmxvYXRhcnJheV91bnNhZmVfc2V0XCJcbmVuZFxuXG5sZXQgaW5pdCBsIGYgPVxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZVxuICBpZiBsIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuaW5pdFwiXG4gICgqIFNlZSAjNjU3NS4gV2UgY291bGQgYWxzbyBjaGVjayBmb3IgbWF4aW11bSBhcnJheSBzaXplLCBidXQgdGhpcyBkZXBlbmRzXG4gICAgIG9uIHdoZXRoZXIgd2UgY3JlYXRlIGEgZmxvYXQgYXJyYXkgb3IgYSByZWd1bGFyIG9uZS4uLiAqKVxuICBlbHNlXG4gICBsZXQgcmVzID0gY3JlYXRlIGwgKGYgMCkgaW5cbiAgIGZvciBpID0gMSB0byBwcmVkIGwgZG9cbiAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgZG9uZTtcbiAgIHJlc1xuXG5sZXQgbWFrZV9tYXRyaXggc3ggc3kgaW5pdCA9XG4gIGxldCByZXMgPSBjcmVhdGUgc3ggW3x8XSBpblxuICBmb3IgeCA9IDAgdG8gcHJlZCBzeCBkb1xuICAgIHVuc2FmZV9zZXQgcmVzIHggKGNyZWF0ZSBzeSBpbml0KVxuICBkb25lO1xuICByZXNcblxubGV0IGNvcHkgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW4gaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgdW5zYWZlX3N1YiBhIDAgbFxuXG5sZXQgYXBwZW5kIGExIGEyID1cbiAgbGV0IGwxID0gbGVuZ3RoIGExIGluXG4gIGlmIGwxID0gMCB0aGVuIGNvcHkgYTJcbiAgZWxzZSBpZiBsZW5ndGggYTIgPSAwIHRoZW4gdW5zYWZlX3N1YiBhMSAwIGwxXG4gIGVsc2UgYXBwZW5kX3ByaW0gYTEgYTJcblxubGV0IHN1YiBhIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LnN1YlwiXG4gIGVsc2UgdW5zYWZlX3N1YiBhIG9mcyBsZW5cblxubGV0IGZpbGwgYSBvZnMgbGVuIHYgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmZpbGxcIlxuICBlbHNlIHVuc2FmZV9maWxsIGEgb2ZzIGxlbiB2XG5cbmxldCBibGl0IGExIG9mczEgYTIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggYTEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIGEyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBhMSBvZnMxIGEyIG9mczIgbGVuXG5cbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgaXRlcjIgZiBhIGIgPVxuICBpZiBsZW5ndGggYSA8PiBsZW5ndGggYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICBlbHNlXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSBkb25lXG5cbmxldCBtYXAgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IG1hcDIgZiBhIGIgPVxuICBsZXQgbGEgPSBsZW5ndGggYSBpblxuICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICBpZiBsYSA8PiBsYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5tYXAyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2UgYmVnaW5cbiAgICBpZiBsYSA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIChmICh1bnNhZmVfZ2V0IGEgMCkgKHVuc2FmZV9nZXQgYiAwKSkgaW5cbiAgICAgIGZvciBpID0gMSB0byBsYSAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpKVxuICAgICAgZG9uZTtcbiAgICAgIHJcbiAgICBlbmRcbiAgZW5kXG5cbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IG1hcGkgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYgMCAodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IHRvX2xpc3QgYSA9XG4gIGxldCByZWMgdG9saXN0IGkgcmVzID1cbiAgICBpZiBpIDwgMCB0aGVuIHJlcyBlbHNlIHRvbGlzdCAoaSAtIDEpICh1bnNhZmVfZ2V0IGEgaSA6OiByZXMpIGluXG4gIHRvbGlzdCAobGVuZ3RoIGEgLSAxKSBbXVxuXG4oKiBDYW5ub3QgdXNlIExpc3QubGVuZ3RoIGhlcmUgYmVjYXVzZSB0aGUgTGlzdCBtb2R1bGUgZGVwZW5kcyBvbiBBcnJheS4gKilcbmxldCByZWMgbGlzdF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjdVxuICB8IF86OnQgLT4gbGlzdF9sZW5ndGggKHN1Y2MgYWNjdSkgdFxuXG5sZXQgb2ZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgYSA9IGNyZWF0ZSAobGlzdF9sZW5ndGggMCBsKSBoZCBpblxuICAgICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgICAgIFtdIC0+IGFcbiAgICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGkrMSkgdGwgaW5cbiAgICAgIGZpbGwgMSB0bFxuXG5sZXQgZm9sZF9sZWZ0IGYgeCBhID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZTtcbiAgIXJcblxubGV0IGZvbGRfbGVmdF9tYXAgZiBhY2MgaW5wdXRfYXJyYXkgPVxuICBsZXQgbGVuID0gbGVuZ3RoIGlucHV0X2FycmF5IGluXG4gIGlmIGxlbiA9IDAgdGhlbiAoYWNjLCBbfHxdKSBlbHNlIGJlZ2luXG4gICAgbGV0IGFjYywgZWx0ID0gZiBhY2MgKHVuc2FmZV9nZXQgaW5wdXRfYXJyYXkgMCkgaW5cbiAgICBsZXQgb3V0cHV0X2FycmF5ID0gY3JlYXRlIGxlbiBlbHQgaW5cbiAgICBsZXQgYWNjID0gcmVmIGFjYyBpblxuICAgIGZvciBpID0gMSB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgYWNjJywgZWx0ID0gZiAhYWNjICh1bnNhZmVfZ2V0IGlucHV0X2FycmF5IGkpIGluXG4gICAgICBhY2MgOj0gYWNjJztcbiAgICAgIHVuc2FmZV9zZXQgb3V0cHV0X2FycmF5IGkgZWx0O1xuICAgIGRvbmU7XG4gICAgIWFjYywgb3V0cHV0X2FycmF5XG4gIGVuZFxuXG5sZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSBsZW5ndGggYSAtIDEgZG93bnRvIDAgZG9cbiAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICBkb25lO1xuICAhclxuXG5sZXQgZXhpc3RzIHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBmb3JfYWxsIHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gbG9vcCAoc3VjYyBpKVxuICAgIGVsc2UgZmFsc2UgaW5cbiAgbG9vcCAwXG5cbmxldCBmb3JfYWxsMiBwIGwxIGwyID1cbiAgbGV0IG4xID0gbGVuZ3RoIGwxXG4gIGFuZCBuMiA9IGxlbmd0aCBsMiBpblxuICBpZiBuMSA8PiBuMiB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuZm9yX2FsbDJcIlxuICBlbHNlIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbjEgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGwxIGkpICh1bnNhZmVfZ2V0IGwyIGkpIHRoZW4gbG9vcCAoc3VjYyBpKVxuICAgIGVsc2UgZmFsc2UgaW5cbiAgbG9vcCAwXG5cbmxldCBleGlzdHMyIHAgbDEgbDIgPVxuICBsZXQgbjEgPSBsZW5ndGggbDFcbiAgYW5kIG4yID0gbGVuZ3RoIGwyIGluXG4gIGlmIG4xIDw+IG4yIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5leGlzdHMyXCJcbiAgZWxzZSBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4xIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgbDEgaSkgKHVuc2FmZV9nZXQgbDIgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgbWVtIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW1xIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHggPT0gKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBmaW5kX29wdCBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIE5vbmVcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICBpZiBwIHggdGhlbiBTb21lIHhcbiAgICAgIGVsc2UgbG9vcCAoc3VjYyBpKVxuICBpblxuICBsb29wIDBcblxubGV0IGZpbmRfbWFwIGYgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gTm9uZVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIGYgKHVuc2FmZV9nZXQgYSBpKSB3aXRoXG4gICAgICB8IE5vbmUgLT4gbG9vcCAoc3VjYyBpKVxuICAgICAgfCBTb21lIF8gYXMgciAtPiByXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgc3BsaXQgeCA9XG4gIGlmIHggPSBbfHxdIHRoZW4gW3x8XSwgW3x8XVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IGEwLCBiMCA9IHVuc2FmZV9nZXQgeCAwIGluXG4gICAgbGV0IG4gPSBsZW5ndGggeCBpblxuICAgIGxldCBhID0gY3JlYXRlIG4gYTAgaW5cbiAgICBsZXQgYiA9IGNyZWF0ZSBuIGIwIGluXG4gICAgZm9yIGkgPSAxIHRvIG4gLSAxIGRvXG4gICAgICBsZXQgYWksIGJpID0gdW5zYWZlX2dldCB4IGkgaW5cbiAgICAgIHVuc2FmZV9zZXQgYSBpIGFpO1xuICAgICAgdW5zYWZlX3NldCBiIGkgYmlcbiAgICBkb25lO1xuICAgIGEsIGJcbiAgZW5kXG5cbmxldCBjb21iaW5lIGEgYiA9XG4gIGxldCBuYSA9IGxlbmd0aCBhIGluXG4gIGxldCBuYiA9IGxlbmd0aCBiIGluXG4gIGlmIG5hIDw+IG5iIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5jb21iaW5lXCI7XG4gIGlmIG5hID0gMCB0aGVuIFt8fF1cbiAgZWxzZSBiZWdpblxuICAgIGxldCB4ID0gY3JlYXRlIG5hICh1bnNhZmVfZ2V0IGEgMCwgdW5zYWZlX2dldCBiIDApIGluXG4gICAgZm9yIGkgPSAxIHRvIG5hIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCB4IGkgKHVuc2FmZV9nZXQgYSBpLCB1bnNhZmVfZ2V0IGIgaSlcbiAgICBkb25lO1xuICAgIHhcbiAgZW5kXG5cbmV4Y2VwdGlvbiBCb3R0b20gb2YgaW50XG5sZXQgc29ydCBjbXAgYSA9XG4gIGxldCBtYXhzb24gbCBpID1cbiAgICBsZXQgaTMxID0gaStpK2krMSBpblxuICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgIGlmIGkzMSsyIDwgbCB0aGVuIGJlZ2luXG4gICAgICBpZiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMCB0aGVuIHggOj0gaTMxKzE7XG4gICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICF4XG4gICAgZW5kIGVsc2VcbiAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgdGhlbiBpMzErMVxuICAgICAgZWxzZSBpZiBpMzEgPCBsIHRoZW4gaTMxIGVsc2UgcmFpc2UgKEJvdHRvbSBpKVxuICBpblxuICBsZXQgcmVjIHRyaWNrbGVkb3duIGwgaSBlID1cbiAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgdHJpY2tsZWRvd24gbCBqIGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHNldCBhIGkgZTtcbiAgICBlbmQ7XG4gIGluXG4gIGxldCB0cmlja2xlIGwgaSBlID0gdHJ5IHRyaWNrbGVkb3duIGwgaSBlIHdpdGggQm90dG9tIGkgLT4gc2V0IGEgaSBlIGluXG4gIGxldCByZWMgYnViYmxlZG93biBsIGkgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgIGJ1YmJsZWRvd24gbCBqXG4gIGluXG4gIGxldCBidWJibGUgbCBpID0gdHJ5IGJ1YmJsZWRvd24gbCBpIHdpdGggQm90dG9tIGkgLT4gaSBpblxuICBsZXQgcmVjIHRyaWNrbGV1cCBpIGUgPVxuICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgIGFzc2VydCAoaSA8PiBmYXRoZXIpO1xuICAgIGlmIGNtcCAoZ2V0IGEgZmF0aGVyKSBlIDwgMCB0aGVuIGJlZ2luXG4gICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgaWYgZmF0aGVyID4gMCB0aGVuIHRyaWNrbGV1cCBmYXRoZXIgZSBlbHNlIHNldCBhIDAgZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBmb3IgaSA9IChsICsgMSkgLyAzIC0gMSBkb3dudG8gMCBkbyB0cmlja2xlIGwgaSAoZ2V0IGEgaSk7IGRvbmU7XG4gIGZvciBpID0gbCAtIDEgZG93bnRvIDIgZG9cbiAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgIHNldCBhIGkgKGdldCBhIDApO1xuICAgIHRyaWNrbGV1cCAoYnViYmxlIGkgMCkgZTtcbiAgZG9uZTtcbiAgaWYgbCA+IDEgdGhlbiAobGV0IGUgPSAoZ2V0IGEgMSkgaW4gc2V0IGEgMSAoZ2V0IGEgMCk7IHNldCBhIDAgZSlcblxuXG5sZXQgY3V0b2ZmID0gNVxubGV0IHN0YWJsZV9zb3J0IGNtcCBhID1cbiAgbGV0IG1lcmdlIHNyYzFvZnMgc3JjMWxlbiBzcmMyIHNyYzJvZnMgc3JjMmxlbiBkc3QgZHN0b2ZzID1cbiAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgIGxldCByZWMgbG9vcCBpMSBzMSBpMiBzMiBkID1cbiAgICAgIGlmIGNtcCBzMSBzMiA8PSAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICBsZXQgaTEgPSBpMSArIDEgaW5cbiAgICAgICAgaWYgaTEgPCBzcmMxciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgc3JjMiBpMiBkc3QgKGQgKyAxKSAoc3JjMnIgLSBpMilcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBkc3QgZCBzMjtcbiAgICAgICAgbGV0IGkyID0gaTIgKyAxIGluXG4gICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgIGxvb3AgaTEgczEgaTIgKGdldCBzcmMyIGkyKSAoZCArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICBlbmRcbiAgICBpbiBsb29wIHNyYzFvZnMgKGdldCBhIHNyYzFvZnMpIHNyYzJvZnMgKGdldCBzcmMyIHNyYzJvZnMpIGRzdG9mcztcbiAgaW5cbiAgbGV0IGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgbGV0IGogPSByZWYgKGRzdG9mcyArIGkgLSAxKSBpblxuICAgICAgd2hpbGUgKCFqID49IGRzdG9mcyAmJiBjbXAgKGdldCBkc3QgIWopIGUgPiAwKSBkb1xuICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgZGVjciBqO1xuICAgICAgZG9uZTtcbiAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICBkb25lO1xuICBpblxuICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGlmIGxlbiA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsZW4gLyAyIGluXG4gICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgc29ydHRvIChzcmNvZnMgKyBsMSkgZHN0IChkc3RvZnMgKyBsMSkgbDI7XG4gICAgICBzb3J0dG8gc3Jjb2ZzIGEgKHNyY29mcyArIGwyKSBsMTtcbiAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICBlbmQ7XG4gIGluXG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIDAgYSAwIGwgZWxzZSBiZWdpblxuICAgIGxldCBsMSA9IGwgLyAyIGluXG4gICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgbGV0IHQgPSBtYWtlIGwyIChnZXQgYSAwKSBpblxuICAgIHNvcnR0byBsMSB0IDAgbDI7XG4gICAgc29ydHRvIDAgYSBsMiBsMTtcbiAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICBlbmRcblxuXG5sZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBhID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgdGhlblxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICBlbHNlIFNlcS5OaWxcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgYSA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPCBsZW5ndGggYVxuICAgIHRoZW5cbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICAgIGVsc2UgU2VxLk5pbFxuICBpblxuICBhdXggMFxuXG5sZXQgb2ZfcmV2X2xpc3QgPSBmdW5jdGlvblxuICAgIFtdIC0+IFt8fF1cbiAgfCBoZDo6dGwgYXMgbCAtPlxuICAgICAgbGV0IGxlbiA9IGxpc3RfbGVuZ3RoIDAgbCBpblxuICAgICAgbGV0IGEgPSBjcmVhdGUgbGVuIGhkIGluXG4gICAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgICAgW10gLT4gYVxuICAgICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaS0xKSB0bFxuICAgICAgaW5cbiAgICAgIGZpbGwgKGxlbi0yKSB0bFxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgbCA9IFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIGkgaW5cbiAgb2ZfcmV2X2xpc3QgbFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICBOaWNvbGFzIE9qZWRhIEJhciwgTGV4aUZpICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBuZWcgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsIGFkZCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgc3ViIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCBtdWwgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsIGRpdiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgcmVtIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbWEgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbWFfZmxvYXRcIiBcImNhbWxfZm1hXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFicyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuXG5sZXQgemVybyA9IDAuXG5sZXQgb25lID0gMS5cbmxldCBtaW51c19vbmUgPSAtMS5cbmxldCBpbmZpbml0eSA9IFN0ZGxpYi5pbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IFN0ZGxpYi5uZWdfaW5maW5pdHlcbmxldCBuYW4gPSBTdGRsaWIubmFuXG5sZXQgaXNfZmluaXRlICh4OiBmbG9hdCkgPSB4IC0uIHggPSAwLlxubGV0IGlzX2luZmluaXRlICh4OiBmbG9hdCkgPSAxLiAvLiB4ID0gMC5cbmxldCBpc19uYW4gKHg6IGZsb2F0KSA9IHggPD4geFxuXG5sZXQgcGkgPSAweDEuOTIxZmI1NDQ0MmQxOHArMVxubGV0IG1heF9mbG9hdCA9IFN0ZGxpYi5tYXhfZmxvYXRcbmxldCBtaW5fZmxvYXQgPSBTdGRsaWIubWluX2Zsb2F0XG5sZXQgZXBzaWxvbiA9IFN0ZGxpYi5lcHNpbG9uX2Zsb2F0XG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5sZXQgb2Zfc3RyaW5nX29wdCA9IFN0ZGxpYi5mbG9hdF9vZl9zdHJpbmdfb3B0XG5sZXQgdG9fc3RyaW5nID0gU3RkbGliLnN0cmluZ19vZl9mbG9hdFxudHlwZSBmcGNsYXNzID0gU3RkbGliLmZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHBvdyA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2JydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NicnRfZmxvYXRcIiBcImNhbWxfY2JydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAyIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwMl9mbG9hdFwiIFwiY2FtbF9leHAyXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzEwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMTBfZmxvYXRcIiBcImxvZzEwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzIgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cyX2Zsb2F0XCIgXCJjYW1sX2xvZzJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc2hfZmxvYXRcIiBcImNhbWxfYWNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luaF9mbG9hdFwiIFwiY2FtbF9hc2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5oX2Zsb2F0XCIgXCJjYW1sX2F0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGVyZiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2VyZl9mbG9hdFwiIFwiY2FtbF9lcmZcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXJmYyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2VyZmNfZmxvYXRcIiBcImNhbWxfZXJmY1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0cnVuYyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RydW5jX2Zsb2F0XCIgXCJjYW1sX3RydW5jXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHJvdW5kIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcm91bmRfZmxvYXRcIiBcImNhbWxfcm91bmRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IGlzX2ludGVnZXIgeCA9IHggPSB0cnVuYyB4ICYmIGlzX2Zpbml0ZSB4XG5cbmV4dGVybmFsIG5leHRfYWZ0ZXIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICA9IFwiY2FtbF9uZXh0YWZ0ZXJfZmxvYXRcIiBcImNhbWxfbmV4dGFmdGVyXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IHN1Y2MgeCA9IG5leHRfYWZ0ZXIgeCBpbmZpbml0eVxubGV0IHByZWQgeCA9IG5leHRfYWZ0ZXIgeCBuZWdfaW5maW5pdHlcblxuZXh0ZXJuYWwgY29weV9zaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaWduX2JpdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBib29sXG4gID0gXCJjYW1sX3NpZ25iaXRfZmxvYXRcIiBcImNhbWxfc2lnbmJpdFwiIFtAQG5vYWxsb2NdXG5cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG50eXBlIHQgPSBmbG9hdFxuZXh0ZXJuYWwgY29tcGFyZSA6IGZsb2F0IC0+IGZsb2F0IC0+IGludCA9IFwiJWNvbXBhcmVcIlxubGV0IGVxdWFsIHggeSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXRbQGlubGluZV0gbWluICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB5IHRoZW4geSBlbHNlIHhcbiAgZWxzZSBpZiBpc19uYW4geCB0aGVuIHggZWxzZSB5XG5cbmxldFtAaW5saW5lXSBtYXggKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4geSBlbHNlIHhcblxubGV0W0BpbmxpbmVdIG1pbl9tYXggKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgaXNfbmFuIHggfHwgaXNfbmFuIHkgdGhlbiAobmFuLCBuYW4pXG4gIGVsc2UgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuICh4LCB5KSBlbHNlICh5LCB4KVxuXG5sZXRbQGlubGluZV0gbWluX251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSB4XG4gIGVsc2UgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgeVxuXG5sZXRbQGlubGluZV0gbWF4X251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geSB0aGVuIHggZWxzZSB5XG4gIGVsc2UgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgeFxuXG5sZXRbQGlubGluZV0gbWluX21heF9udW0gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgaXNfbmFuIHggdGhlbiAoeSx5KVxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4gKHgseClcbiAgZWxzZSBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW4gKHgseSkgZWxzZSAoeSx4KVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6IGludCAtPiBpbnQgLT4gaW50IC0+IGZsb2F0IC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfaGFzaFwiIFtAQG5vYWxsb2NdXG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxuXG5tb2R1bGUgQXJyYXkgPSBzdHJ1Y3RcblxuICB0eXBlIHQgPSBmbG9hdGFycmF5XG5cbiAgZXh0ZXJuYWwgbGVuZ3RoIDogdCAtPiBpbnQgPSBcIiVmbG9hdGFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIGdldCA6IHQgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCA6IHQgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IHQgPSBcImNhbWxfZmxvYXRhcnJheV9jcmVhdGVcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5cbiAgbGV0IHVuc2FmZV9maWxsIGEgb2ZzIGxlbiB2ID1cbiAgICBmb3IgaSA9IG9mcyB0byBvZnMgKyBsZW4gLSAxIGRvIHVuc2FmZV9zZXQgYSBpIHYgZG9uZVxuXG4gIGV4dGVybmFsIHVuc2FmZV9ibGl0OiB0IC0+IGludCAtPiB0IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9XG4gICAgXCJjYW1sX2Zsb2F0YXJyYXlfYmxpdFwiIFtAQG5vYWxsb2NdXG5cbiAgbGV0IGNoZWNrIGEgb2ZzIGxlbiBtc2cgPVxuICAgIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgKyBsZW4gPCAwIHx8IG9mcyArIGxlbiA+IGxlbmd0aCBhIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIG1zZ1xuXG4gIGxldCBtYWtlIG4gdiA9XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBuIGluXG4gICAgdW5zYWZlX2ZpbGwgcmVzdWx0IDAgbiB2O1xuICAgIHJlc3VsdFxuXG4gIGxldCBpbml0IGwgZiA9XG4gICAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5LmluaXRcIlxuICAgIGVsc2VcbiAgICAgIGxldCByZXMgPSBjcmVhdGUgbCBpblxuICAgICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgICAgIGRvbmU7XG4gICAgICByZXNcblxuICBsZXQgYXBwZW5kIGExIGEyID1cbiAgICBsZXQgbDEgPSBsZW5ndGggYTEgaW5cbiAgICBsZXQgbDIgPSBsZW5ndGggYTIgaW5cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChsMSArIGwyKSBpblxuICAgIHVuc2FmZV9ibGl0IGExIDAgcmVzdWx0IDAgbDE7XG4gICAgdW5zYWZlX2JsaXQgYTIgMCByZXN1bHQgbDEgbDI7XG4gICAgcmVzdWx0XG5cbiAgKCogbmV4dCAzIGZ1bmN0aW9uczogbW9kaWZpZWQgY29weSBvZiBjb2RlIGZyb20gc3RyaW5nLm1sICopXG4gIGxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID1cbiAgICBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5jb25jYXRcIlxuXG4gIGxldCByZWMgc3VtX2xlbmd0aHMgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgYWNjKSBhY2MpIHRsXG5cbiAgbGV0IGNvbmNhdCBsID1cbiAgICBsZXQgbGVuID0gc3VtX2xlbmd0aHMgMCBsIGluXG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIGxvb3AgbCBpID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgKGkgPSBsZW4pXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIGxldCBobGVuID0gbGVuZ3RoIGhkIGluXG4gICAgICAgIHVuc2FmZV9ibGl0IGhkIDAgcmVzdWx0IGkgaGxlbjtcbiAgICAgICAgbG9vcCB0bCAoaSArIGhsZW4pXG4gICAgaW5cbiAgICBsb29wIGwgMDtcbiAgICByZXN1bHRcblxuICBsZXQgc3ViIGEgb2ZzIGxlbiA9XG4gICAgY2hlY2sgYSBvZnMgbGVuIFwiRmxvYXQuQXJyYXkuc3ViXCI7XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICB1bnNhZmVfYmxpdCBhIG9mcyByZXN1bHQgMCBsZW47XG4gICAgcmVzdWx0XG5cbiAgbGV0IGNvcHkgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbCBpblxuICAgIHVuc2FmZV9ibGl0IGEgMCByZXN1bHQgMCBsO1xuICAgIHJlc3VsdFxuXG4gIGxldCBmaWxsIGEgb2ZzIGxlbiB2ID1cbiAgICBjaGVjayBhIG9mcyBsZW4gXCJGbG9hdC5BcnJheS5maWxsXCI7XG4gICAgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHZcblxuICBsZXQgYmxpdCBzcmMgc29mcyBkc3QgZG9mcyBsZW4gPVxuICAgIGNoZWNrIHNyYyBzb2ZzIGxlbiBcIkZsb2F0LmFycmF5LmJsaXRcIjtcbiAgICBjaGVjayBkc3QgZG9mcyBsZW4gXCJGbG9hdC5hcnJheS5ibGl0XCI7XG4gICAgdW5zYWZlX2JsaXQgc3JjIHNvZnMgZHN0IGRvZnMgbGVuXG5cbiAgbGV0IHRvX2xpc3QgYSA9XG4gICAgTGlzdC5pbml0IChsZW5ndGggYSkgKHVuc2FmZV9nZXQgYSlcblxuICBsZXQgb2ZfbGlzdCBsID1cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChMaXN0Lmxlbmd0aCBsKSBpblxuICAgIGxldCByZWMgZmlsbCBpIGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IHJlc3VsdFxuICAgICAgfCBoIDo6IHQgLT4gdW5zYWZlX3NldCByZXN1bHQgaSBoOyBmaWxsIChpICsgMSkgdFxuICAgIGluXG4gICAgZmlsbCAwIGxcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGl0ZXIgZiBhID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyMiBmIGEgYiA9XG4gICAgaWYgbGVuZ3RoIGEgPD4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICAgIGVsc2VcbiAgICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkgZG9uZVxuXG4gIGxldCBtYXAgZiBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuICBsZXQgbWFwMiBmIGEgYiA9XG4gICAgbGV0IGxhID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICAgIGlmIGxhIDw+IGxiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkubWFwMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbGEgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyaSBmIGEgPVxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4gIGxldCBtYXBpIGYgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gICAgZG9uZTtcbiAgICAhclxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICAgIGRvbmU7XG4gICAgIXJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGV4aXN0cyBwIGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmb3JfYWxsIHAgYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBsb29wIChpICsgMSlcbiAgICAgIGVsc2UgZmFsc2UgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IG1lbSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sLCBidXQgc2xpZ2h0bHkgZGlmZmVyZW50ICopXG4gIGxldCBtZW1faWVlZSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHggPSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBleGNlcHRpb24gQm90dG9tIG9mIGludFxuICBsZXQgc29ydCBjbXAgYSA9XG4gICAgbGV0IG1heHNvbiBsIGkgPVxuICAgICAgbGV0IGkzMSA9IGkraStpKzEgaW5cbiAgICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgICAgaWYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDAgdGhlbiB4IDo9IGkzMSsxO1xuICAgICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICAgIXhcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgICB0aGVuIGkzMSsxXG4gICAgICAgIGVsc2UgaWYgaTMxIDwgbCB0aGVuIGkzMSBlbHNlIHJhaXNlIChCb3R0b20gaSlcbiAgICBpblxuICAgIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICAgIHRyaWNrbGVkb3duIGwgaiBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgICBsZXQgcmVjIGJ1YmJsZWRvd24gbCBpID1cbiAgICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICBidWJibGVkb3duIGwgalxuICAgIGluXG4gICAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gICAgbGV0IHJlYyB0cmlja2xldXAgaSBlID1cbiAgICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgICBpZiBjbXAgKGdldCBhIGZhdGhlcikgZSA8IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgICBmb3IgaSA9IGwgLSAxIGRvd250byAyIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgICB0cmlja2xldXAgKGJ1YmJsZSBpIDApIGU7XG4gICAgZG9uZTtcbiAgICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCwgZXhjZXB0IGZvciB0aGUgY2FsbCB0byBbY3JlYXRlXSAqKVxuICBsZXQgY3V0b2ZmID0gNVxuICBsZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICAgIGxldCBtZXJnZSBzcmMxb2ZzIHNyYzFsZW4gc3JjMiBzcmMyb2ZzIHNyYzJsZW4gZHN0IGRzdG9mcyA9XG4gICAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgICBpZiBjbXAgczEgczIgPD0gMCB0aGVuIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICAgIGlmIGkxIDwgc3JjMXIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IHNyYzIgaTIgZHN0IChkICsgMSkgKHNyYzJyIC0gaTIpXG4gICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICAgIGxldCBpMiA9IGkyICsgMSBpblxuICAgICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICAgIGVuZFxuICAgICAgaW4gbG9vcCBzcmMxb2ZzIChnZXQgYSBzcmMxb2ZzKSBzcmMyb2ZzIChnZXQgc3JjMiBzcmMyb2ZzKSBkc3RvZnM7XG4gICAgaW5cbiAgICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICAgIHdoaWxlICghaiA+PSBkc3RvZnMgJiYgY21wIChnZXQgZHN0ICFqKSBlID4gMCkgZG9cbiAgICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgICBkZWNyIGo7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICAgIGRvbmU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGwxID0gbGVuIC8gMiBpblxuICAgICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgICAgc29ydHRvIHNyY29mcyBhIChzcmNvZnMgKyBsMikgbDE7XG4gICAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsIC8gMiBpblxuICAgICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgICBsZXQgdCA9IGNyZWF0ZSBsMiBpblxuICAgICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICAgIHNvcnR0byAwIGEgbDIgbDE7XG4gICAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICAgIGVuZFxuXG4gIGxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgdG9fc2VxIGEgPVxuICAgIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgICB0aGVuXG4gICAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IHRvX3NlcWkgYSA9XG4gICAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICAgIHRoZW5cbiAgICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9yZXZfbGlzdCBsID1cbiAgICBsZXQgbGVuID0gTGlzdC5sZW5ndGggbCBpblxuICAgIGxldCBhID0gY3JlYXRlIGxlbiBpblxuICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgW10gLT4gYVxuICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGktMSkgdGxcbiAgICBpblxuICAgIGZpbGwgKGxlbi0xKSBsXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9zZXEgaSA9XG4gICAgbGV0IGwgPSBTZXEuZm9sZF9sZWZ0IChmdW4gYWNjIHggLT4geDo6YWNjKSBbXSBpIGluXG4gICAgb2ZfcmV2X2xpc3QgbFxuXG5cbiAgbGV0IG1hcF90b19hcnJheSBmIGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsID0gMCB0aGVuIFt8IHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gQXJyYXkubWFrZSBsIChmICh1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgICAgQXJyYXkudW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG5cbiAgbGV0IG1hcF9mcm9tX2FycmF5IGYgYSA9XG4gICAgbGV0IGwgPSBBcnJheS5sZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIChBcnJheS51bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbmVuZFxuXG5tb2R1bGUgQXJyYXlMYWJlbHMgPSBBcnJheVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0ludDMyXTogMzItYml0IGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZyA6IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbmVnXCJcbmV4dGVybmFsIGFkZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYWRkXCJcbmV4dGVybmFsIHN1YiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfc3ViXCJcbmV4dGVybmFsIG11bCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbXVsXCJcbmV4dGVybmFsIGRpdiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfZGl2XCJcbmV4dGVybmFsIHJlbSA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYW5kXCJcbmV4dGVybmFsIGxvZ29yIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9vclwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDMyID0gXCIlaW50MzJfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGludDMyIC0+IGludCA9IFwiJWludDMyX3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQzMiAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQzMl90b19mbG9hdFwiIFwiY2FtbF9pbnQzMl90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50MzIgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgemVybyA9IDBsXG5sZXQgb25lID0gMWxcbmxldCBtaW51c19vbmUgPSAtMWxcbmxldCBzdWNjIG4gPSBhZGQgbiAxbFxubGV0IHByZWQgbiA9IHN1YiBuIDFsXG5sZXQgYWJzIG4gPSBpZiBuID49IDBsIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgbWluX2ludCA9IDB4ODAwMDAwMDBsXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZsXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFsKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbWF0Y2ggU3lzLndvcmRfc2l6ZSB3aXRoXG4gIHwgMzIgLT5cbiAgICAgIGxldCBtYXhfaW50ID0gb2ZfaW50IFN0ZGxpYi5tYXhfaW50IGluXG4gICAgICBmdW4gbiAtPlxuICAgICAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgICAgIFNvbWUgKHRvX2ludCBuKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgTm9uZVxuICB8IDY0IC0+XG4gICAgICAoKiBTbyB0aGF0IGl0IGNvbXBpbGVzIGluIDMyLWJpdCAqKVxuICAgICAgbGV0IG1hc2sgPSAweEZGRkYgbHNsIDE2IGxvciAweEZGRkYgaW5cbiAgICAgIGZ1biBuIC0+IFNvbWUgKHRvX2ludCBuIGxhbmQgbWFzaylcbiAgfCBfIC0+XG4gICAgICBhc3NlcnQgZmFsc2VcblxuZXh0ZXJuYWwgZm9ybWF0IDogc3RyaW5nIC0+IGludDMyIC0+IHN0cmluZyA9IFwiY2FtbF9pbnQzMl9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQzMiA9IFwiY2FtbF9pbnQzMl9vZl9zdHJpbmdcIlxuXG5sZXQgb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogZXhwb3NlIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlIGRpcmVjdGx5LiAqKVxuICB0cnkgU29tZSAob2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxudHlwZSB0ID0gaW50MzJcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbmxldCBtaW4geCB5IDogdCA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA6IHQgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG4oKiBVbnNpZ25lZCBkaXZpc2lvbiBmcm9tIHNpZ25lZCBkaXZpc2lvbiBvZiB0aGUgc2FtZVxuICAgYml0bmVzcy4gU2VlIFdhcnJlbiBKci4sIEhlbnJ5IFMuICgyMDEzKS4gSGFja2VyJ3MgRGVsaWdodCAoMiBlZC4pLCBTZWMgOS0zLlxuKilcbmxldCB1bnNpZ25lZF9kaXYgbiBkID1cbiAgaWYgZCA8IHplcm8gdGhlblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgbiBkIDwgMCB0aGVuIHplcm8gZWxzZSBvbmVcbiAgZWxzZVxuICAgIGxldCBxID0gc2hpZnRfbGVmdCAoZGl2IChzaGlmdF9yaWdodF9sb2dpY2FsIG4gMSkgZCkgMSBpblxuICAgIGxldCByID0gc3ViIG4gKG11bCBxIGQpIGluXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSByIGQgPj0gMCB0aGVuIHN1Y2MgcSBlbHNlIHFcblxubGV0IHVuc2lnbmVkX3JlbSBuIGQgPVxuICBzdWIgbiAobXVsICh1bnNpZ25lZF9kaXYgbiBkKSBkKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0ludDY0XTogNjQtYml0IGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZyA6IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbmVnXCJcbmV4dGVybmFsIGFkZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYWRkXCJcbmV4dGVybmFsIHN1YiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfc3ViXCJcbmV4dGVybmFsIG11bCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbXVsXCJcbmV4dGVybmFsIGRpdiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfZGl2XCJcbmV4dGVybmFsIHJlbSA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYW5kXCJcbmV4dGVybmFsIGxvZ29yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vclwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGludDY0IC0+IGludCA9IFwiJWludDY0X3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF90b19mbG9hdFwiIFwiY2FtbF9pbnQ2NF90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG9mX2ludDMyIDogaW50MzIgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnQzMlwiXG5leHRlcm5hbCB0b19pbnQzMiA6IGludDY0IC0+IGludDMyID0gXCIlaW50NjRfdG9faW50MzJcIlxuZXh0ZXJuYWwgb2ZfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfbmF0aXZlaW50XCJcbmV4dGVybmFsIHRvX25hdGl2ZWludCA6IGludDY0IC0+IG5hdGl2ZWludCA9IFwiJWludDY0X3RvX25hdGl2ZWludFwiXG5cbmxldCB6ZXJvID0gMExcbmxldCBvbmUgPSAxTFxubGV0IG1pbnVzX29uZSA9IC0xTFxubGV0IHN1Y2MgbiA9IGFkZCBuIDFMXG5sZXQgcHJlZCBuID0gc3ViIG4gMUxcbmxldCBhYnMgbiA9IGlmIG4gPj0gMEwgdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBtaW5faW50ID0gMHg4MDAwMDAwMDAwMDAwMDAwTFxubGV0IG1heF9pbnQgPSAweDdGRkZGRkZGRkZGRkZGRkZMXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFMKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgZnVuIG4gLT5cbiAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgU29tZSAodG9faW50IG4pXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDY0ID0gXCJjYW1sX2ludDY0X29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5cblxuZXh0ZXJuYWwgYml0c19vZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbnR5cGUgdCA9IGludDY0XG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG5cbmxldCB1bnNpZ25lZF9jb21wYXJlIG4gbSA9XG4gIGNvbXBhcmUgKHN1YiBuIG1pbl9pbnQpIChzdWIgbSBtaW5faW50KVxuXG5sZXQgbWluIHggeSA6IHQgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgOiB0ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcblxuKCogVW5zaWduZWQgZGl2aXNpb24gZnJvbSBzaWduZWQgZGl2aXNpb24gb2YgdGhlIHNhbWVcbiAgIGJpdG5lc3MuIFNlZSBXYXJyZW4gSnIuLCBIZW5yeSBTLiAoMjAxMykuIEhhY2tlcidzIERlbGlnaHQgKDIgZWQuKSwgU2VjIDktMy5cbiopXG5sZXQgdW5zaWduZWRfZGl2IG4gZCA9XG4gIGlmIGQgPCB6ZXJvIHRoZW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIG4gZCA8IDAgdGhlbiB6ZXJvIGVsc2Ugb25lXG4gIGVsc2VcbiAgICBsZXQgcSA9IHNoaWZ0X2xlZnQgKGRpdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBuIDEpIGQpIDEgaW5cbiAgICBsZXQgciA9IHN1YiBuIChtdWwgcSBkKSBpblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgciBkID49IDAgdGhlbiBzdWNjIHEgZWxzZSBxXG5cbmxldCB1bnNpZ25lZF9yZW0gbiBkID1cbiAgc3ViIG4gKG11bCAodW5zaWduZWRfZGl2IG4gZCkgZClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtOYXRpdmVpbnRdOiBwcm9jZXNzb3ItbmF0aXZlIGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZzogbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9uZWdcIlxuZXh0ZXJuYWwgYWRkOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hZGRcIlxuZXh0ZXJuYWwgc3ViOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9zdWJcIlxuZXh0ZXJuYWwgbXVsOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tdWxcIlxuZXh0ZXJuYWwgZGl2OiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9kaXZcIlxuZXh0ZXJuYWwgcmVtOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3I6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29yXCJcbmV4dGVybmFsIGxvZ3hvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQ6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWw6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzclwiXG5leHRlcm5hbCBvZl9pbnQ6IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludDogbmF0aXZlaW50IC0+IGludCA9IFwiJW5hdGl2ZWludF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogbmF0aXZlaW50IC0+IGZsb2F0XG4gID0gXCJjYW1sX25hdGl2ZWludF90b19mbG9hdFwiIFwiY2FtbF9uYXRpdmVpbnRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBvZl9pbnQzMjogaW50MzIgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyOiBuYXRpdmVpbnQgLT4gaW50MzIgPSBcIiVuYXRpdmVpbnRfdG9faW50MzJcIlxuXG5sZXQgemVybyA9IDBuXG5sZXQgb25lID0gMW5cbmxldCBtaW51c19vbmUgPSAtMW5cbmxldCBzdWNjIG4gPSBhZGQgbiAxblxubGV0IHByZWQgbiA9IHN1YiBuIDFuXG5sZXQgYWJzIG4gPSBpZiBuID49IDBuIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgc2l6ZSA9IFN5cy53b3JkX3NpemVcbmxldCBtaW5faW50ID0gc2hpZnRfbGVmdCAxbiAoc2l6ZSAtIDEpXG5sZXQgbWF4X2ludCA9IHN1YiBtaW5faW50IDFuXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFuKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgZnVuIG4gLT5cbiAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgU29tZSAodG9faW50IG4pXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZyA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmc6IHN0cmluZyAtPiBuYXRpdmVpbnQgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBuYXRpdmVpbnRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbmxldCBtaW4geCB5IDogdCA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA6IHQgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG4oKiBVbnNpZ25lZCBkaXZpc2lvbiBmcm9tIHNpZ25lZCBkaXZpc2lvbiBvZiB0aGUgc2FtZVxuICAgYml0bmVzcy4gU2VlIFdhcnJlbiBKci4sIEhlbnJ5IFMuICgyMDEzKS4gSGFja2VyJ3MgRGVsaWdodCAoMiBlZC4pLCBTZWMgOS0zLlxuKilcbmxldCB1bnNpZ25lZF9kaXYgbiBkID1cbiAgaWYgZCA8IHplcm8gdGhlblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgbiBkIDwgMCB0aGVuIHplcm8gZWxzZSBvbmVcbiAgZWxzZVxuICAgIGxldCBxID0gc2hpZnRfbGVmdCAoZGl2IChzaGlmdF9yaWdodF9sb2dpY2FsIG4gMSkgZCkgMSBpblxuICAgIGxldCByID0gc3ViIG4gKG11bCBxIGQpIGluXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSByIGQgPj0gMCB0aGVuIHN1Y2MgcSBlbHNlIHFcblxubGV0IHVuc2lnbmVkX3JlbSBuIGQgPVxuICBzdWIgbiAobXVsICh1bnNpZ25lZF9kaXYgbiBkKSBkKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3IgbGV4ZXJzIGdlbmVyYXRlZCBieSBjYW1sbGV4ICopXG5cbnR5cGUgcG9zaXRpb24gPSB7XG4gIHBvc19mbmFtZSA6IHN0cmluZztcbiAgcG9zX2xudW0gOiBpbnQ7XG4gIHBvc19ib2wgOiBpbnQ7XG4gIHBvc19jbnVtIDogaW50O1xufVxuXG5sZXQgZHVtbXlfcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDA7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IC0xO1xufVxuXG50eXBlIGxleGJ1ZiA9XG4gIHsgcmVmaWxsX2J1ZmYgOiBsZXhidWYgLT4gdW5pdDtcbiAgICBtdXRhYmxlIGxleF9idWZmZXIgOiBieXRlcztcbiAgICBtdXRhYmxlIGxleF9idWZmZXJfbGVuIDogaW50O1xuICAgIG11dGFibGUgbGV4X2Fic19wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfc3RhcnRfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2N1cnJfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2xhc3RfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2xhc3RfYWN0aW9uIDogaW50O1xuICAgIG11dGFibGUgbGV4X2VvZl9yZWFjaGVkIDogYm9vbDtcbiAgICBtdXRhYmxlIGxleF9tZW0gOiBpbnQgYXJyYXk7XG4gICAgbXV0YWJsZSBsZXhfc3RhcnRfcCA6IHBvc2l0aW9uO1xuICAgIG11dGFibGUgbGV4X2N1cnJfcCA6IHBvc2l0aW9uO1xuICB9XG5cbnR5cGUgbGV4X3RhYmxlcyA9XG4gIHsgbGV4X2Jhc2U6IHN0cmluZztcbiAgICBsZXhfYmFja3Ryazogc3RyaW5nO1xuICAgIGxleF9kZWZhdWx0OiBzdHJpbmc7XG4gICAgbGV4X3RyYW5zOiBzdHJpbmc7XG4gICAgbGV4X2NoZWNrOiBzdHJpbmc7XG4gICAgbGV4X2Jhc2VfY29kZSA6IHN0cmluZztcbiAgICBsZXhfYmFja3Rya19jb2RlIDogc3RyaW5nO1xuICAgIGxleF9kZWZhdWx0X2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X3RyYW5zX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2NoZWNrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2NvZGU6IHN0cmluZzt9XG5cbmV4dGVybmFsIGNfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludCA9IFwiY2FtbF9sZXhfZW5naW5lXCJcbmV4dGVybmFsIGNfbmV3X2VuZ2luZSA6IGxleF90YWJsZXMgLT4gaW50IC0+IGxleGJ1ZiAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9uZXdfbGV4X2VuZ2luZVwiXG5cbmxldCBlbmdpbmUgdGJsIHN0YXRlIGJ1ZiA9XG4gIGxldCByZXN1bHQgPSBjX2VuZ2luZSB0Ymwgc3RhdGUgYnVmIGluXG4gIGlmIHJlc3VsdCA+PSAwICYmIGJ1Zi5sZXhfY3Vycl9wICE9IGR1bW15X3BvcyB0aGVuIGJlZ2luXG4gICAgYnVmLmxleF9zdGFydF9wIDwtIGJ1Zi5sZXhfY3Vycl9wO1xuICAgIGJ1Zi5sZXhfY3Vycl9wIDwtIHtidWYubGV4X2N1cnJfcFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBvc19jbnVtID0gYnVmLmxleF9hYnNfcG9zICsgYnVmLmxleF9jdXJyX3Bvc307XG4gIGVuZDtcbiAgcmVzdWx0XG5cblxubGV0IG5ld19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiA9XG4gIGxldCByZXN1bHQgPSBjX25ld19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiBpblxuICBpZiByZXN1bHQgPj0gMCAmJiBidWYubGV4X2N1cnJfcCAhPSBkdW1teV9wb3MgdGhlbiBiZWdpblxuICAgIGJ1Zi5sZXhfc3RhcnRfcCA8LSBidWYubGV4X2N1cnJfcDtcbiAgICBidWYubGV4X2N1cnJfcCA8LSB7YnVmLmxleF9jdXJyX3BcbiAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBwb3NfY251bSA9IGJ1Zi5sZXhfYWJzX3BvcyArIGJ1Zi5sZXhfY3Vycl9wb3N9O1xuICBlbmQ7XG4gIHJlc3VsdFxuXG5sZXQgbGV4X3JlZmlsbCByZWFkX2Z1biBhdXhfYnVmZmVyIGxleGJ1ZiA9XG4gIGxldCByZWFkID1cbiAgICByZWFkX2Z1biBhdXhfYnVmZmVyIChCeXRlcy5sZW5ndGggYXV4X2J1ZmZlcikgaW5cbiAgbGV0IG4gPVxuICAgIGlmIHJlYWQgPiAwXG4gICAgdGhlbiByZWFkXG4gICAgZWxzZSAobGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlOyAwKSBpblxuICAoKiBDdXJyZW50IHN0YXRlIG9mIHRoZSBidWZmZXI6XG4gICAgICAgIDwtLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLT5cbiAgICAgICAgfCAganVuayB8ICAgICAgdmFsaWQgZGF0YSAgICAgfCAgIGp1bmsgICAgfFxuICAgICAgICBeICAgICAgIF4gICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICBeXG4gICAgICAgIDAgICAgc3RhcnRfcG9zICAgICAgICAgICAgIGJ1ZmZlcl9lbmQgICAgQnl0ZXMubGVuZ3RoIGJ1ZmZlclxuICAqKVxuICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gKyBuID4gQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyIHRoZW4gYmVnaW5cbiAgICAoKiBUaGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgblxuICAgICAgIDw9IEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlclxuICAgIHRoZW4gYmVnaW5cbiAgICAgICgqIEJ1dCB0aGVyZSBpcyBlbm91Z2ggc3BhY2UgaWYgd2UgcmVjbGFpbSB0aGUganVuayBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICBvZiB0aGUgYnVmZmVyICopXG4gICAgICBCeXRlcy5ibGl0IGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zXG4gICAgICAgICAgICAgICAgICBsZXhidWYubGV4X2J1ZmZlciAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpXG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICgqIFdlIG11c3QgZ3JvdyB0aGUgYnVmZmVyLiAgRG91YmxpbmcgaXRzIHNpemUgd2lsbCBwcm92aWRlIGVub3VnaFxuICAgICAgICAgc3BhY2Ugc2luY2UgbiA8PSBTdHJpbmcubGVuZ3RoIGF1eF9idWZmZXIgPD0gU3RyaW5nLmxlbmd0aCBidWZmZXIuXG4gICAgICAgICBXYXRjaCBvdXQgZm9yIHN0cmluZyBsZW5ndGggb3ZlcmZsb3csIHRob3VnaC4gKilcbiAgICAgIGxldCBuZXdsZW4gPVxuICAgICAgICBJbnQubWluICgyICogQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgbiA+IG5ld2xlblxuICAgICAgdGhlbiBmYWlsd2l0aCBcIkxleGluZy5sZXhfcmVmaWxsOiBjYW5ub3QgZ3JvdyBidWZmZXJcIjtcbiAgICAgIGxldCBuZXdidWYgPSBCeXRlcy5jcmVhdGUgbmV3bGVuIGluXG4gICAgICAoKiBDb3B5IHRoZSB2YWxpZCBkYXRhIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIG5ld2J1ZiAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpO1xuICAgICAgbGV4YnVmLmxleF9idWZmZXIgPC0gbmV3YnVmXG4gICAgZW5kO1xuICAgICgqIFJlYWxsb2NhdGlvbiBvciBub3QsIHdlIGhhdmUgc2hpZnRlZCB0aGUgZGF0YSBsZWZ0IGJ5XG4gICAgICAgc3RhcnRfcG9zIGNoYXJhY3RlcnM7IHVwZGF0ZSB0aGUgcG9zaXRpb25zICopXG4gICAgbGV0IHMgPSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICAgIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBsZXhidWYubGV4X2Fic19wb3MgKyBzO1xuICAgIGxleGJ1Zi5sZXhfY3Vycl9wb3MgPC0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIHM7XG4gICAgbGV4YnVmLmxleF9zdGFydF9wb3MgPC0gMDtcbiAgICBsZXhidWYubGV4X2xhc3RfcG9zIDwtIGxleGJ1Zi5sZXhfbGFzdF9wb3MgLSBzO1xuICAgIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiA8LSBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBzIDtcbiAgICBsZXQgdCA9IGxleGJ1Zi5sZXhfbWVtIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LTEgZG9cbiAgICAgIGxldCB2ID0gdC4oaSkgaW5cbiAgICAgIGlmIHYgPj0gMCB0aGVuXG4gICAgICAgIHQuKGkpIDwtIHYtc1xuICAgIGRvbmVcbiAgZW5kO1xuICAoKiBUaGVyZSBpcyBub3cgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICBCeXRlcy5ibGl0IGF1eF9idWZmZXIgMCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X2J1ZmZlcl9sZW4gbjtcbiAgbGV4YnVmLmxleF9idWZmZXJfbGVuIDwtIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG5cblxubGV0IHplcm9fcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDE7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IDA7XG59XG5cbmxldCBmcm9tX2Z1bmN0aW9uID8od2l0aF9wb3NpdGlvbnMgPSB0cnVlKSBmID1cbiAgeyByZWZpbGxfYnVmZiA9IGxleF9yZWZpbGwgZiAoQnl0ZXMuY3JlYXRlIDUxMik7XG4gICAgbGV4X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAxMDI0O1xuICAgIGxleF9idWZmZXJfbGVuID0gMDtcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gZmFsc2U7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBmcm9tX2NoYW5uZWwgP3dpdGhfcG9zaXRpb25zIGljID1cbiAgZnJvbV9mdW5jdGlvbiA/d2l0aF9wb3NpdGlvbnMgKGZ1biBidWYgbiAtPiBpbnB1dCBpYyBidWYgMCBuKVxuXG5sZXQgZnJvbV9zdHJpbmcgPyh3aXRoX3Bvc2l0aW9ucyA9IHRydWUpIHMgPVxuICB7IHJlZmlsbF9idWZmID0gKGZ1biBsZXhidWYgLT4gbGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlKTtcbiAgICBsZXhfYnVmZmVyID0gQnl0ZXMub2Zfc3RyaW5nIHM7ICgqIGhhdmUgdG8gbWFrZSBhIGNvcHkgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdW5zYWZlLXN0cmluZyBtb2RlICopXG4gICAgbGV4X2J1ZmZlcl9sZW4gPSBTdHJpbmcubGVuZ3RoIHM7XG4gICAgbGV4X2Fic19wb3MgPSAwO1xuICAgIGxleF9zdGFydF9wb3MgPSAwO1xuICAgIGxleF9jdXJyX3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9hY3Rpb24gPSAwO1xuICAgIGxleF9tZW0gPSBbfHxdO1xuICAgIGxleF9lb2ZfcmVhY2hlZCA9IHRydWU7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBzZXRfcG9zaXRpb24gbGV4YnVmIHBvc2l0aW9uID1cbiAgbGV4YnVmLmxleF9jdXJyX3AgIDwtIHtwb3NpdGlvbiB3aXRoIHBvc19mbmFtZSA9IGxleGJ1Zi5sZXhfY3Vycl9wLnBvc19mbmFtZX07XG4gIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBwb3NpdGlvbi5wb3NfY251bVxuXG5sZXQgc2V0X2ZpbGVuYW1lIGxleGJ1ZiBmbmFtZSA9XG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtIHtsZXhidWYubGV4X2N1cnJfcCB3aXRoIHBvc19mbmFtZSA9IGZuYW1lfVxuXG5sZXQgd2l0aF9wb3NpdGlvbnMgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zXG5cbmxldCBsZXhlbWUgbGV4YnVmID1cbiAgbGV0IGxlbiA9IGxleGJ1Zi5sZXhfY3Vycl9wb3MgLSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICBCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGxlblxuXG5sZXQgc3ViX2xleGVtZSBsZXhidWYgaTEgaTIgPVxuICBsZXQgbGVuID0gaTItaTEgaW5cbiAgQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBpMSBsZW5cblxubGV0IHN1Yl9sZXhlbWVfb3B0IGxleGJ1ZiBpMSBpMiA9XG4gIGlmIGkxID49IDAgdGhlbiBiZWdpblxuICAgIGxldCBsZW4gPSBpMi1pMSBpblxuICAgIFNvbWUgKEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgaTEgbGVuKVxuICBlbmQgZWxzZSBiZWdpblxuICAgIE5vbmVcbiAgZW5kXG5cbmxldCBzdWJfbGV4ZW1lX2NoYXIgbGV4YnVmIGkgPSBCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgaVxuXG5sZXQgc3ViX2xleGVtZV9jaGFyX29wdCBsZXhidWYgaSA9XG4gIGlmIGkgPj0gMCB0aGVuXG4gICAgU29tZSAoQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIGkpXG4gIGVsc2VcbiAgICBOb25lXG5cblxubGV0IGxleGVtZV9jaGFyIGxleGJ1ZiBpID1cbiAgQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIChsZXhidWYubGV4X3N0YXJ0X3BvcyArIGkpXG5cbmxldCBsZXhlbWVfc3RhcnQgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wLnBvc19jbnVtXG5sZXQgbGV4ZW1lX2VuZCBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcC5wb3NfY251bVxuXG5sZXQgbGV4ZW1lX3N0YXJ0X3AgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wXG5sZXQgbGV4ZW1lX2VuZF9wIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wXG5cbmxldCBuZXdfbGluZSBsZXhidWYgPVxuICBsZXQgbGNwID0gbGV4YnVmLmxleF9jdXJyX3AgaW5cbiAgaWYgbGNwICE9IGR1bW15X3BvcyB0aGVuXG4gICAgbGV4YnVmLmxleF9jdXJyX3AgPC1cbiAgICAgIHsgbGNwIHdpdGhcbiAgICAgICAgcG9zX2xudW0gPSBsY3AucG9zX2xudW0gKyAxO1xuICAgICAgICBwb3NfYm9sID0gbGNwLnBvc19jbnVtO1xuICAgICAgfVxuXG5cblxuKCogRGlzY2FyZCBkYXRhIGxlZnQgaW4gbGV4ZXIgYnVmZmVyLiAqKVxuXG5sZXQgZmx1c2hfaW5wdXQgbGIgPVxuICBsYi5sZXhfY3Vycl9wb3MgPC0gMDtcbiAgbGIubGV4X2Fic19wb3MgPC0gMDtcbiAgbGV0IGxjcCA9IGxiLmxleF9jdXJyX3AgaW5cbiAgaWYgbGNwICE9IGR1bW15X3BvcyB0aGVuXG4gICAgbGIubGV4X2N1cnJfcCA8LSB7emVyb19wb3Mgd2l0aCBwb3NfZm5hbWUgPSBsY3AucG9zX2ZuYW1lfTtcbiAgbGIubGV4X2J1ZmZlcl9sZW4gPC0gMDtcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVGhlIHBhcnNpbmcgZW5naW5lICopXG5cbm9wZW4gTGV4aW5nXG5cbigqIEludGVybmFsIGludGVyZmFjZSB0byB0aGUgcGFyc2luZyBlbmdpbmUgKilcblxudHlwZSBwYXJzZXJfZW52ID1cbiAgeyBtdXRhYmxlIHNfc3RhY2sgOiBpbnQgYXJyYXk7ICAgICAgICAoKiBTdGF0ZXMgKilcbiAgICBtdXRhYmxlIHZfc3RhY2sgOiBPYmoudCBhcnJheTsgICAgICAoKiBTZW1hbnRpYyBhdHRyaWJ1dGVzICopXG4gICAgbXV0YWJsZSBzeW1iX3N0YXJ0X3N0YWNrIDogcG9zaXRpb24gYXJyYXk7ICgqIFN0YXJ0IHBvc2l0aW9ucyAqKVxuICAgIG11dGFibGUgc3ltYl9lbmRfc3RhY2sgOiBwb3NpdGlvbiBhcnJheTsgICAoKiBFbmQgcG9zaXRpb25zICopXG4gICAgbXV0YWJsZSBzdGFja3NpemUgOiBpbnQ7ICAgICAgICAgICAgKCogU2l6ZSBvZiB0aGUgc3RhY2tzICopXG4gICAgbXV0YWJsZSBzdGFja2Jhc2UgOiBpbnQ7ICAgICAgICAgICAgKCogQmFzZSBzcCBmb3IgY3VycmVudCBwYXJzZSAqKVxuICAgIG11dGFibGUgY3Vycl9jaGFyIDogaW50OyAgICAgICAgICAgICgqIExhc3QgdG9rZW4gcmVhZCAqKVxuICAgIG11dGFibGUgbHZhbCA6IE9iai50OyAgICAgICAgICAgICAgICgqIEl0cyBzZW1hbnRpYyBhdHRyaWJ1dGUgKilcbiAgICBtdXRhYmxlIHN5bWJfc3RhcnQgOiBwb3NpdGlvbjsgICAgICAoKiBTdGFydCBwb3MuIG9mIHRoZSBjdXJyZW50IHN5bWJvbCopXG4gICAgbXV0YWJsZSBzeW1iX2VuZCA6IHBvc2l0aW9uOyAgICAgICAgKCogRW5kIHBvcy4gb2YgdGhlIGN1cnJlbnQgc3ltYm9sICopXG4gICAgbXV0YWJsZSBhc3AgOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogVGhlIHN0YWNrIHBvaW50ZXIgZm9yIGF0dHJpYnV0ZXMgKilcbiAgICBtdXRhYmxlIHJ1bGVfbGVuIDogaW50OyAgICAgICAgICAgICAoKiBOdW1iZXIgb2YgcmhzIGl0ZW1zIGluIHRoZSBydWxlICopXG4gICAgbXV0YWJsZSBydWxlX251bWJlciA6IGludDsgICAgICAgICAgKCogUnVsZSBudW1iZXIgdG8gcmVkdWNlIGJ5ICopXG4gICAgbXV0YWJsZSBzcCA6IGludDsgICAgICAgICAgICAgICAgICAgKCogU2F2ZWQgc3AgZm9yIHBhcnNlX2VuZ2luZSAqKVxuICAgIG11dGFibGUgc3RhdGUgOiBpbnQ7ICAgICAgICAgICAgICAgICgqIFNhdmVkIHN0YXRlIGZvciBwYXJzZV9lbmdpbmUgKilcbiAgICBtdXRhYmxlIGVycmZsYWcgOiBpbnQgfSAgICAgICAgICAgICAoKiBTYXZlZCBlcnJvciBmbGFnIGZvciBwYXJzZV9lbmdpbmUgKilcbltAQHdhcm5pbmcgXCItdW51c2VkLWZpZWxkXCJdXG5cbnR5cGUgcGFyc2VfdGFibGVzID1cbiAgeyBhY3Rpb25zIDogKHBhcnNlcl9lbnYgLT4gT2JqLnQpIGFycmF5O1xuICAgIHRyYW5zbF9jb25zdCA6IGludCBhcnJheTtcbiAgICB0cmFuc2xfYmxvY2sgOiBpbnQgYXJyYXk7XG4gICAgbGhzIDogc3RyaW5nO1xuICAgIGxlbiA6IHN0cmluZztcbiAgICBkZWZyZWQgOiBzdHJpbmc7XG4gICAgZGdvdG8gOiBzdHJpbmc7XG4gICAgc2luZGV4IDogc3RyaW5nO1xuICAgIHJpbmRleCA6IHN0cmluZztcbiAgICBnaW5kZXggOiBzdHJpbmc7XG4gICAgdGFibGVzaXplIDogaW50O1xuICAgIHRhYmxlIDogc3RyaW5nO1xuICAgIGNoZWNrIDogc3RyaW5nO1xuICAgIGVycm9yX2Z1bmN0aW9uIDogc3RyaW5nIC0+IHVuaXQ7XG4gICAgbmFtZXNfY29uc3QgOiBzdHJpbmc7XG4gICAgbmFtZXNfYmxvY2sgOiBzdHJpbmcgfVxuXG5leGNlcHRpb24gWVlleGl0IG9mIE9iai50XG5leGNlcHRpb24gUGFyc2VfZXJyb3JcblxudHlwZSBwYXJzZXJfaW5wdXQgPVxuICAgIFN0YXJ0XG4gIHwgVG9rZW5fcmVhZFxuICB8IFN0YWNrc19ncm93bl8xXG4gIHwgU3RhY2tzX2dyb3duXzJcbiAgfCBTZW1hbnRpY19hY3Rpb25fY29tcHV0ZWRcbiAgfCBFcnJvcl9kZXRlY3RlZFxuXG50eXBlIHBhcnNlcl9vdXRwdXQgPVxuICAgIFJlYWRfdG9rZW5cbiAgfCBSYWlzZV9wYXJzZV9lcnJvclxuICB8IEdyb3dfc3RhY2tzXzFcbiAgfCBHcm93X3N0YWNrc18yXG4gIHwgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb25cbiAgfCBDYWxsX2Vycm9yX2Z1bmN0aW9uXG5cbigqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5sZXQgXyA9IFtSZWFkX3Rva2VuOyBSYWlzZV9wYXJzZV9lcnJvcjsgR3Jvd19zdGFja3NfMTsgR3Jvd19zdGFja3NfMjtcbiAgICAgICAgIENvbXB1dGVfc2VtYW50aWNfYWN0aW9uOyBDYWxsX2Vycm9yX2Z1bmN0aW9uXVxuXG5leHRlcm5hbCBwYXJzZV9lbmdpbmUgOlxuICAgIHBhcnNlX3RhYmxlcyAtPiBwYXJzZXJfZW52IC0+IHBhcnNlcl9pbnB1dCAtPiBPYmoudCAtPiBwYXJzZXJfb3V0cHV0XG4gICAgPSBcImNhbWxfcGFyc2VfZW5naW5lXCJcblxuZXh0ZXJuYWwgc2V0X3RyYWNlOiBib29sIC0+IGJvb2xcbiAgICA9IFwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlXCJcblxubGV0IGVudiA9XG4gIHsgc19zdGFjayA9IEFycmF5Lm1ha2UgMTAwIDA7XG4gICAgdl9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIChPYmoucmVwciAoKSk7XG4gICAgc3ltYl9zdGFydF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzeW1iX2VuZF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzdGFja3NpemUgPSAxMDA7XG4gICAgc3RhY2tiYXNlID0gMDtcbiAgICBjdXJyX2NoYXIgPSAwO1xuICAgIGx2YWwgPSBPYmoucmVwciAoKTtcbiAgICBzeW1iX3N0YXJ0ID0gZHVtbXlfcG9zO1xuICAgIHN5bWJfZW5kID0gZHVtbXlfcG9zO1xuICAgIGFzcCA9IDA7XG4gICAgcnVsZV9sZW4gPSAwO1xuICAgIHJ1bGVfbnVtYmVyID0gMDtcbiAgICBzcCA9IDA7XG4gICAgc3RhdGUgPSAwO1xuICAgIGVycmZsYWcgPSAwIH1cblxubGV0IGdyb3dfc3RhY2tzKCkgPVxuICBsZXQgb2xkc2l6ZSA9IGVudi5zdGFja3NpemUgaW5cbiAgbGV0IG5ld3NpemUgPSBvbGRzaXplICogMiBpblxuICBsZXQgbmV3X3MgPSBBcnJheS5tYWtlIG5ld3NpemUgMFxuICBhbmQgbmV3X3YgPSBBcnJheS5tYWtlIG5ld3NpemUgKE9iai5yZXByICgpKVxuICBhbmQgbmV3X3N0YXJ0ID0gQXJyYXkubWFrZSBuZXdzaXplIGR1bW15X3Bvc1xuICBhbmQgbmV3X2VuZCA9IEFycmF5Lm1ha2UgbmV3c2l6ZSBkdW1teV9wb3MgaW5cbiAgICBBcnJheS5ibGl0IGVudi5zX3N0YWNrIDAgbmV3X3MgMCBvbGRzaXplO1xuICAgIGVudi5zX3N0YWNrIDwtIG5ld19zO1xuICAgIEFycmF5LmJsaXQgZW52LnZfc3RhY2sgMCBuZXdfdiAwIG9sZHNpemU7XG4gICAgZW52LnZfc3RhY2sgPC0gbmV3X3Y7XG4gICAgQXJyYXkuYmxpdCBlbnYuc3ltYl9zdGFydF9zdGFjayAwIG5ld19zdGFydCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfc3RhcnRfc3RhY2sgPC0gbmV3X3N0YXJ0O1xuICAgIEFycmF5LmJsaXQgZW52LnN5bWJfZW5kX3N0YWNrIDAgbmV3X2VuZCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfZW5kX3N0YWNrIDwtIG5ld19lbmQ7XG4gICAgZW52LnN0YWNrc2l6ZSA8LSBuZXdzaXplXG5cbmxldCBjbGVhcl9wYXJzZXIoKSA9XG4gIEFycmF5LmZpbGwgZW52LnZfc3RhY2sgMCBlbnYuc3RhY2tzaXplIChPYmoucmVwciAoKSk7XG4gIGVudi5sdmFsIDwtIE9iai5yZXByICgpXG5cbmxldCBjdXJyZW50X2xvb2thaGVhZF9mdW4gPSByZWYgKGZ1biAoXyA6IE9iai50KSAtPiBmYWxzZSlcblxubGV0IHl5cGFyc2UgdGFibGVzIHN0YXJ0IGxleGVyIGxleGJ1ZiA9XG4gIGxldCByZWMgbG9vcCBjbWQgYXJnID1cbiAgICBtYXRjaCBwYXJzZV9lbmdpbmUgdGFibGVzIGVudiBjbWQgYXJnIHdpdGhcbiAgICAgIFJlYWRfdG9rZW4gLT5cbiAgICAgICAgbGV0IHQgPSBPYmoucmVwcihsZXhlciBsZXhidWYpIGluXG4gICAgICAgIGVudi5zeW1iX3N0YXJ0IDwtIGxleGJ1Zi5sZXhfc3RhcnRfcDtcbiAgICAgICAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICAgICAgICBsb29wIFRva2VuX3JlYWQgdFxuICAgIHwgUmFpc2VfcGFyc2VfZXJyb3IgLT5cbiAgICAgICAgcmFpc2UgUGFyc2VfZXJyb3JcbiAgICB8IENvbXB1dGVfc2VtYW50aWNfYWN0aW9uIC0+XG4gICAgICAgIGxldCAoYWN0aW9uLCB2YWx1ZSkgPVxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgKFNlbWFudGljX2FjdGlvbl9jb21wdXRlZCwgdGFibGVzLmFjdGlvbnMuKGVudi5ydWxlX251bWJlcikgZW52KVxuICAgICAgICAgIHdpdGggUGFyc2VfZXJyb3IgLT5cbiAgICAgICAgICAgIChFcnJvcl9kZXRlY3RlZCwgT2JqLnJlcHIgKCkpIGluXG4gICAgICAgIGxvb3AgYWN0aW9uIHZhbHVlXG4gICAgfCBHcm93X3N0YWNrc18xIC0+XG4gICAgICAgIGdyb3dfc3RhY2tzKCk7IGxvb3AgU3RhY2tzX2dyb3duXzEgKE9iai5yZXByICgpKVxuICAgIHwgR3Jvd19zdGFja3NfMiAtPlxuICAgICAgICBncm93X3N0YWNrcygpOyBsb29wIFN0YWNrc19ncm93bl8yIChPYmoucmVwciAoKSlcbiAgICB8IENhbGxfZXJyb3JfZnVuY3Rpb24gLT5cbiAgICAgICAgdGFibGVzLmVycm9yX2Z1bmN0aW9uIFwic3ludGF4IGVycm9yXCI7XG4gICAgICAgIGxvb3AgRXJyb3JfZGV0ZWN0ZWQgKE9iai5yZXByICgpKSBpblxuICBsZXQgaW5pdF9hc3AgPSBlbnYuYXNwXG4gIGFuZCBpbml0X3NwID0gZW52LnNwXG4gIGFuZCBpbml0X3N0YWNrYmFzZSA9IGVudi5zdGFja2Jhc2VcbiAgYW5kIGluaXRfc3RhdGUgPSBlbnYuc3RhdGVcbiAgYW5kIGluaXRfY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhclxuICBhbmQgaW5pdF9sdmFsID0gZW52Lmx2YWxcbiAgYW5kIGluaXRfZXJyZmxhZyA9IGVudi5lcnJmbGFnIGluXG4gIGVudi5zdGFja2Jhc2UgPC0gZW52LnNwICsgMTtcbiAgZW52LmN1cnJfY2hhciA8LSBzdGFydDtcbiAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICB0cnlcbiAgICBsb29wIFN0YXJ0IChPYmoucmVwciAoKSlcbiAgd2l0aCBleG4gLT5cbiAgICBsZXQgY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhciBpblxuICAgIGVudi5hc3AgPC0gaW5pdF9hc3A7XG4gICAgZW52LnNwIDwtIGluaXRfc3A7XG4gICAgZW52LnN0YWNrYmFzZSA8LSBpbml0X3N0YWNrYmFzZTtcbiAgICBlbnYuc3RhdGUgPC0gaW5pdF9zdGF0ZTtcbiAgICBlbnYuY3Vycl9jaGFyIDwtIGluaXRfY3Vycl9jaGFyO1xuICAgIGVudi5sdmFsIDwtIGluaXRfbHZhbDtcbiAgICBlbnYuZXJyZmxhZyA8LSBpbml0X2VycmZsYWc7XG4gICAgbWF0Y2ggZXhuIHdpdGhcbiAgICAgIFlZZXhpdCB2IC0+XG4gICAgICAgIE9iai5tYWdpYyB2XG4gICAgfCBfIC0+XG4gICAgICAgIGN1cnJlbnRfbG9va2FoZWFkX2Z1biA6PVxuICAgICAgICAgIChmdW4gdG9rIC0+XG4gICAgICAgICAgICBpZiBPYmouaXNfYmxvY2sgdG9rXG4gICAgICAgICAgICB0aGVuIHRhYmxlcy50cmFuc2xfYmxvY2suKE9iai50YWcgdG9rKSA9IGN1cnJfY2hhclxuICAgICAgICAgICAgZWxzZSB0YWJsZXMudHJhbnNsX2NvbnN0LihPYmoubWFnaWMgdG9rKSA9IGN1cnJfY2hhcik7XG4gICAgICAgIHJhaXNlIGV4blxuXG5sZXQgcGVla192YWwgZW52IG4gPVxuICBPYmoubWFnaWMgZW52LnZfc3RhY2suKGVudi5hc3AgLSBuKVxuXG5sZXQgc3ltYm9sX3N0YXJ0X3BvcyAoKSA9XG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpIDw9IDAgdGhlbiBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHN0ID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSBpICsgMSkgaW5cbiAgICAgIGxldCBlbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIGkgKyAxKSBpblxuICAgICAgaWYgc3QgPD4gZW4gdGhlbiBzdCBlbHNlIGxvb3AgKGkgLSAxKVxuICAgIGVuZFxuICBpblxuICBsb29wIGVudi5ydWxlX2xlblxuXG5sZXQgc3ltYm9sX2VuZF9wb3MgKCkgPSBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG5sZXQgcmhzX3N0YXJ0X3BvcyBuID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSAoZW52LnJ1bGVfbGVuIC0gbikpXG5sZXQgcmhzX2VuZF9wb3MgbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIChlbnYucnVsZV9sZW4gLSBuKSlcblxubGV0IHN5bWJvbF9zdGFydCAoKSA9IChzeW1ib2xfc3RhcnRfcG9zICgpKS5wb3NfY251bVxubGV0IHN5bWJvbF9lbmQgKCkgPSAoc3ltYm9sX2VuZF9wb3MgKCkpLnBvc19jbnVtXG5sZXQgcmhzX3N0YXJ0IG4gPSAocmhzX3N0YXJ0X3BvcyBuKS5wb3NfY251bVxubGV0IHJoc19lbmQgbiA9IChyaHNfZW5kX3BvcyBuKS5wb3NfY251bVxuXG5sZXQgaXNfY3VycmVudF9sb29rYWhlYWQgdG9rID1cbiAgKCFjdXJyZW50X2xvb2thaGVhZF9mdW4pKE9iai5yZXByIHRvaylcblxubGV0IHBhcnNlX2Vycm9yIChfIDogc3RyaW5nKSA9ICgpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFNldHMgb3ZlciBvcmRlcmVkIHR5cGVzICopXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGVsdFxuICAgIHR5cGUgdFxuICAgIHZhbCBlbXB0eTogdFxuICAgIHZhbCBpc19lbXB0eTogdCAtPiBib29sXG4gICAgdmFsIG1lbTogZWx0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBhZGQ6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgc2luZ2xldG9uOiBlbHQgLT4gdFxuICAgIHZhbCByZW1vdmU6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgdW5pb246IHQgLT4gdCAtPiB0XG4gICAgdmFsIGludGVyOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBkaXNqb2ludDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZGlmZjogdCAtPiB0IC0+IHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgc3Vic2V0OiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoZWx0IC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICAgIHZhbCBtYXA6IChlbHQgLT4gZWx0KSAtPiB0IC0+IHRcbiAgICB2YWwgZm9sZDogKGVsdCAtPiAnYSAtPiAnYSkgLT4gdCAtPiAnYSAtPiAnYVxuICAgIHZhbCBmb3JfYWxsOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGVsdCAtPiBib29sKSAtPiB0IC0+IHRcbiAgICB2YWwgZmlsdGVyX21hcDogKGVsdCAtPiBlbHQgb3B0aW9uKSAtPiB0IC0+IHRcbiAgICB2YWwgcGFydGl0aW9uOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gdCAqIHRcbiAgICB2YWwgY2FyZGluYWw6IHQgLT4gaW50XG4gICAgdmFsIGVsZW1lbnRzOiB0IC0+IGVsdCBsaXN0XG4gICAgdmFsIG1pbl9lbHQ6IHQgLT4gZWx0XG4gICAgdmFsIG1pbl9lbHRfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgbWF4X2VsdDogdCAtPiBlbHRcbiAgICB2YWwgbWF4X2VsdF9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBjaG9vc2U6IHQgLT4gZWx0XG4gICAgdmFsIGNob29zZV9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBzcGxpdDogZWx0IC0+IHQgLT4gdCAqIGJvb2wgKiB0XG4gICAgdmFsIGZpbmQ6IGVsdCAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX29wdDogZWx0IC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgb2ZfbGlzdDogZWx0IGxpc3QgLT4gdFxuICAgIHZhbCB0b19zZXFfZnJvbSA6IGVsdCAtPiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCB0b19zZXEgOiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCB0b19yZXZfc2VxIDogdCAtPiBlbHQgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6IGVsdCBTZXEudCAtPiB0IC0+IHRcbiAgICB2YWwgb2Zfc2VxIDogZWx0IFNlcS50IC0+IHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID1cbiAgc3RydWN0XG4gICAgdHlwZSBlbHQgPSBPcmQudFxuICAgIHR5cGUgdCA9IEVtcHR5IHwgTm9kZSBvZiB7bDp0OyB2OmVsdDsgcjp0OyBoOmludH1cblxuICAgICgqIFNldHMgYXJlIHJlcHJlc2VudGVkIGJ5IGJhbGFuY2VkIGJpbmFyeSB0cmVlcyAodGhlIGhlaWdodHMgb2YgdGhlXG4gICAgICAgY2hpbGRyZW4gZGlmZmVyIGJ5IGF0IG1vc3QgMiAqKVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgKCogQ3JlYXRlcyBhIG5ldyBub2RlIHdpdGggbGVmdCBzb24gbCwgdmFsdWUgdiBhbmQgcmlnaHQgc29uIHIuXG4gICAgICAgV2UgbXVzdCBoYXZlIGFsbCBlbGVtZW50cyBvZiBsIDwgdiA8IGFsbCBlbGVtZW50cyBvZiByLlxuICAgICAgIGwgYW5kIHIgbXVzdCBiZSBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi5cbiAgICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGhlaWdodCBmb3IgYmV0dGVyIHNwZWVkLiAqKVxuXG4gICAgbGV0IGNyZWF0ZSBsIHYgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgTm9kZXtsOyB2OyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSwgYnV0IHBlcmZvcm1zIG9uZSBzdGVwIG9mIHJlYmFsYW5jaW5nIGlmIG5lY2Vzc2FyeS5cbiAgICAgICBBc3N1bWVzIGwgYW5kIHIgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDMuXG4gICAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBjcmVhdGUgZm9yIGJldHRlciBzcGVlZCBpbiB0aGUgbW9zdCBmcmVxdWVudCBjYXNlXG4gICAgICAgd2hlcmUgbm8gcmViYWxhbmNpbmcgaXMgcmVxdWlyZWQuICopXG5cbiAgICBsZXQgYmFsIGwgdiByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiAoY3JlYXRlIGxyIHYgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBscmwpIGxydiAoY3JlYXRlIGxyciB2IHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IHJsKSBydiByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgcmxsKSBybHYgKGNyZWF0ZSBybHIgcnYgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdjsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgKCogSW5zZXJ0aW9uIG9mIG9uZSBlbGVtZW50ICopXG5cbiAgICBsZXQgcmVjIGFkZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHQgZWxzZVxuICAgICAgICAgIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0IGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IGFkZCB4IHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0IGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHNpbmdsZXRvbiB4ID0gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cblxuICAgICgqIEJld2FyZTogdGhvc2UgdHdvIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCB0aGUgYWRkZWQgdiBpcyAqc3RyaWN0bHkqXG4gICAgICAgc21hbGxlciAob3IgYmlnZ2VyKSB0aGFuIGFsbCB0aGUgcHJlc2VudCBlbGVtZW50cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBlbGVtZW50LlxuICAgICAgIEluZGVlZCwgdGhleSBhcmUgb25seSB1c2VkIGR1cmluZyB0aGUgXCJqb2luXCIgb3BlcmF0aW9uIHdoaWNoXG4gICAgICAgcmVzcGVjdHMgdGhpcyBwcmVjb25kaXRpb24uXG4gICAgKilcblxuICAgIGxldCByZWMgYWRkX21pbl9lbGVtZW50IHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24geFxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICBiYWwgKGFkZF9taW5fZWxlbWVudCB4IGwpIHYgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2VsZW1lbnQgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiB4XG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgIGJhbCBsIHYgKGFkZF9tYXhfZWxlbWVudCB4IHIpXG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlXG4gICAgICAgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IHJlYyBqb2luIGwgdiByID1cbiAgICAgIG1hdGNoIChsLCByKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gYWRkX21pbl9lbGVtZW50IHYgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfZWxlbWVudCB2IGxcbiAgICAgIHwgKE5vZGV7bD1sbDsgdj1sdjsgcj1scjsgaD1saH0sIE5vZGV7bD1ybDsgdj1ydjsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgKGpvaW4gbHIgdiByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IHJsKSBydiByciBlbHNlXG4gICAgICAgICAgY3JlYXRlIGwgdiByXG5cbiAgICAoKiBTbWFsbGVzdCBhbmQgZ3JlYXRlc3QgZWxlbWVudCBvZiBhIHNldCAqKVxuXG4gICAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgdn0gLT4gdlxuICAgICAgfCBOb2Rle2x9IC0+IG1pbl9lbHQgbFxuXG4gICAgbGV0IHJlYyBtaW5fZWx0X29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyB2fSAtPiBTb21lIHZcbiAgICAgIHwgTm9kZXtsfSAtPiBtaW5fZWx0X29wdCBsXG5cbiAgICBsZXQgcmVjIG1heF9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXt2OyByPUVtcHR5fSAtPiB2XG4gICAgICB8IE5vZGV7cn0gLT4gbWF4X2VsdCByXG5cbiAgICBsZXQgcmVjIG1heF9lbHRfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle3Y7IHI9RW1wdHl9IC0+IFNvbWUgdlxuICAgICAgfCBOb2Rle3J9IC0+IG1heF9lbHRfb3B0IHJcblxuICAgICgqIFJlbW92ZSB0aGUgc21hbGxlc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gc2V0ICopXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQucmVtb3ZlX21pbl9lbHRcIlxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBiYWwgKHJlbW92ZV9taW5fZWx0IGwpIHYgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIEFzc3VtZSB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLiAqKVxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gYmFsIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IGpvaW4gdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgICgqIFNwbGl0dGluZy4gIHNwbGl0IHggcyByZXR1cm5zIGEgdHJpcGxlIChsLCBwcmVzZW50LCByKSB3aGVyZVxuICAgICAgICAtIGwgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlIDwgeFxuICAgICAgICAtIHIgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlID4geFxuICAgICAgICAtIHByZXNlbnQgaXMgZmFsc2UgaWYgcyBjb250YWlucyBubyBlbGVtZW50IGVxdWFsIHRvIHgsXG4gICAgICAgICAgb3IgdHJ1ZSBpZiBzIGNvbnRhaW5zIGFuIGVsZW1lbnQgZXF1YWwgdG8geC4gKilcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBmYWxzZSwgRW1wdHkpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIHRydWUsIHIpXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgKGxsLCBwcmVzLCBybCkgPSBzcGxpdCB4IGwgaW4gKGxsLCBwcmVzLCBqb2luIHJsIHYgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGxyLCBwcmVzLCBycilcblxuICAgICgqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBzZXQgb3BlcmF0aW9ucyAqKVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0gYXMgdCkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluXG4gICAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgcnIgPSByZW1vdmUgeCByIGluXG4gICAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHJlYyB1bmlvbiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdDIpIC0+IHQyXG4gICAgICB8ICh0MSwgRW1wdHkpIC0+IHQxXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjE7IGg9aDF9LCBOb2Rle2w9bDI7IHY9djI7IHI9cjI7IGg9aDJ9KSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyIHRoZW5cbiAgICAgICAgICAgIGlmIGgyID0gMSB0aGVuIGFkZCB2MiBzMSBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIGxldCAobDIsIF8sIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MSAodW5pb24gcjEgcjIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBoMSA9IDEgdGhlbiBhZGQgdjEgczIgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBsZXQgKGwxLCBfLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjIgKHVuaW9uIHIxIHIyKVxuICAgICAgICAgICAgZW5kXG5cbiAgICBsZXQgcmVjIGludGVyIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAoXywgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBtYXRjaCBzcGxpdCB2MSB0MiB3aXRoXG4gICAgICAgICAgICAobDIsIGZhbHNlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChpbnRlciBsMSBsMikgKGludGVyIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgam9pbiAoaW50ZXIgbDEgbDIpIHYxIChpbnRlciByMSByMilcblxuICAgICgqIFNhbWUgYXMgc3BsaXQsIGJ1dCBjb21wdXRlIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlc1xuICAgICAgIG9ubHkgaWYgdGhlIHBpdm90IGVsZW1lbnQgaXMgbm90IGluIHRoZSBzZXQuICBUaGUgcmlnaHQgc3VidHJlZVxuICAgICAgIGlzIGNvbXB1dGVkIG9uIGRlbWFuZC4gKilcblxuICAgIHR5cGUgc3BsaXRfYmlzID1cbiAgICAgIHwgRm91bmRcbiAgICAgIHwgTm90Rm91bmQgb2YgdCAqICh1bml0IC0+IHQpXG5cbiAgICBsZXQgcmVjIHNwbGl0X2JpcyB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb3RGb3VuZCAoRW1wdHksIChmdW4gKCkgLT4gRW1wdHkpKVxuICAgICAgfCBOb2Rle2w7IHY7IHI7IF99IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIEZvdW5kXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBtYXRjaCBzcGxpdF9iaXMgeCBsIHdpdGhcbiAgICAgICAgICAgIHwgRm91bmQgLT4gRm91bmRcbiAgICAgICAgICAgIHwgTm90Rm91bmQgKGxsLCBybCkgLT4gTm90Rm91bmQgKGxsLCAoZnVuICgpIC0+IGpvaW4gKHJsICgpKSB2IHIpKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1hdGNoIHNwbGl0X2JpcyB4IHIgd2l0aFxuICAgICAgICAgICAgfCBGb3VuZCAtPiBGb3VuZFxuICAgICAgICAgICAgfCBOb3RGb3VuZCAobHIsIHJyKSAtPiBOb3RGb3VuZCAoam9pbiBsIHYgbHIsIHJyKVxuXG4gICAgbGV0IHJlYyBkaXNqb2ludCBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgfCAoXywgRW1wdHkpIC0+IHRydWVcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIGlmIHMxID09IHMyIHRoZW4gZmFsc2VcbiAgICAgICAgICBlbHNlIG1hdGNoIHNwbGl0X2JpcyB2MSB0MiB3aXRoXG4gICAgICAgICAgICAgIE5vdEZvdW5kKGwyLCByMikgLT4gZGlzam9pbnQgbDEgbDIgJiYgZGlzam9pbnQgcjEgKHIyICgpKVxuICAgICAgICAgICAgfCBGb3VuZCAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBkaWZmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAodDEsIEVtcHR5KSAtPiB0MVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgbWF0Y2ggc3BsaXQgdjEgdDIgd2l0aFxuICAgICAgICAgICAgKGwyLCBmYWxzZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGpvaW4gKGRpZmYgbDEgbDIpIHYxIChkaWZmIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChkaWZmIGwxIGwyKSAoZGlmZiByMSByMilcblxuICAgIHR5cGUgZW51bWVyYXRpb24gPSBFbmQgfCBNb3JlIG9mIGVsdCAqIHQgKiBlbnVtZXJhdGlvblxuXG4gICAgbGV0IHJlYyBjb25zX2VudW0gcyBlID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gY29uc19lbnVtIGwgKE1vcmUodiwgciwgZSkpXG5cbiAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgbWF0Y2ggKGUxLCBlMikgd2l0aFxuICAgICAgICAoRW5kLCBFbmQpIC0+IDBcbiAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICB8IChfLCBFbmQpIC0+IDFcbiAgICAgIHwgKE1vcmUodjEsIHIxLCBlMSksIE1vcmUodjIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgIGVsc2UgY29tcGFyZV9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcblxuICAgIGxldCBjb21wYXJlIHMxIHMyID1cbiAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gczEgRW5kKSAoY29uc19lbnVtIHMyIEVuZClcblxuICAgIGxldCBlcXVhbCBzMSBzMiA9XG4gICAgICBjb21wYXJlIHMxIHMyID0gMFxuXG4gICAgbGV0IHJlYyBzdWJzZXQgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICBFbXB0eSwgXyAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgXywgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBOb2RlIHtsPWwxOyB2PXYxOyByPXIxfSwgKE5vZGUge2w9bDI7IHY9djI7IHI9cjJ9IGFzIHQyKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBzdWJzZXQgbDEgbDIgJiYgc3Vic2V0IHIxIHIyXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBzdWJzZXQgKE5vZGUge2w9bDE7IHY9djE7IHI9RW1wdHk7IGg9MH0pIGwyICYmIHN1YnNldCByMSB0MlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN1YnNldCAoTm9kZSB7bD1FbXB0eTsgdj12MTsgcj1yMTsgaD0wfSkgcjIgJiYgc3Vic2V0IGwxIHQyXG5cbiAgICBsZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gaXRlciBmIGw7IGYgdjsgaXRlciBmIHJcblxuICAgIGxldCByZWMgZm9sZCBmIHMgYWNjdSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGZvbGQgZiByIChmIHYgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gcCB2ICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBwIHYgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0pIGFzIHQgLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCBsJyA9IGZpbHRlciBwIGwgaW5cbiAgICAgICAgICBsZXQgcHYgPSBwIHYgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXIgcCByIGluXG4gICAgICAgICAgaWYgcHYgdGhlblxuICAgICAgICAgICAgaWYgbD09bCcgJiYgcj09cicgdGhlbiB0IGVsc2Ugam9pbiBsJyB2IHInXG4gICAgICAgICAgZWxzZSBjb25jYXQgbCcgcidcblxuICAgIGxldCByZWMgcGFydGl0aW9uIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoRW1wdHksIEVtcHR5KVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgKGx0LCBsZikgPSBwYXJ0aXRpb24gcCBsIGluXG4gICAgICAgICAgbGV0IHB2ID0gcCB2IGluXG4gICAgICAgICAgbGV0IChydCwgcmYpID0gcGFydGl0aW9uIHAgciBpblxuICAgICAgICAgIGlmIHB2XG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IHJ0LCBjb25jYXQgbGYgcmYpXG4gICAgICAgICAgZWxzZSAoY29uY2F0IGx0IHJ0LCBqb2luIGxmIHYgcmYpXG5cbiAgICBsZXQgcmVjIGNhcmRpbmFsID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2Rle2w7IHJ9IC0+IGNhcmRpbmFsIGwgKyAxICsgY2FyZGluYWwgclxuXG4gICAgbGV0IHJlYyBlbGVtZW50c19hdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBlbGVtZW50c19hdXggKHYgOjogZWxlbWVudHNfYXV4IGFjY3UgcikgbFxuXG4gICAgbGV0IGVsZW1lbnRzIHMgPVxuICAgICAgZWxlbWVudHNfYXV4IFtdIHNcblxuICAgIGxldCBjaG9vc2UgPSBtaW5fZWx0XG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9lbHRfb3B0XG5cbiAgICBsZXQgcmVjIGZpbmQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHZcbiAgICAgICAgICBlbHNlIGZpbmQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHRfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9sYXN0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdjAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIHZcbiAgICAgICAgICBlbHNlIGZpbmRfb3B0IHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgdHJ5X2pvaW4gbCB2IHIgPVxuICAgICAgKCogW2pvaW4gbCB2IHJdIGNhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIChlbGVtZW50cyBvZiBsIDwgdiA8XG4gICAgICAgICBlbGVtZW50cyBvZiByKTsgdXNlIFt0cnlfam9pbiBsIHYgcl0gd2hlbiB0aGlzIHByb3BlcnR5IG1heVxuICAgICAgICAgbm90IGhvbGQsIGJ1dCB5b3UgaG9wZSBpdCBkb2VzIGhvbGQgaW4gdGhlIGNvbW1vbiBjYXNlICopXG4gICAgICBpZiAobCA9IEVtcHR5IHx8IE9yZC5jb21wYXJlIChtYXhfZWx0IGwpIHYgPCAwKVxuICAgICAgJiYgKHIgPSBFbXB0eSB8fCBPcmQuY29tcGFyZSB2IChtaW5fZWx0IHIpIDwgMClcbiAgICAgIHRoZW4gam9pbiBsIHYgclxuICAgICAgZWxzZSB1bmlvbiBsIChhZGQgdiByKVxuXG4gICAgbGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgKCogZW5mb3JjZSBsZWZ0LXRvLXJpZ2h0IGV2YWx1YXRpb24gb3JkZXIgKilcbiAgICAgICAgIGxldCBsJyA9IG1hcCBmIGwgaW5cbiAgICAgICAgIGxldCB2JyA9IGYgdiBpblxuICAgICAgICAgbGV0IHInID0gbWFwIGYgciBpblxuICAgICAgICAgaWYgbCA9PSBsJyAmJiB2ID09IHYnICYmIHIgPT0gcicgdGhlbiB0XG4gICAgICAgICBlbHNlIHRyeV9qb2luIGwnIHYnIHInXG5cbiAgICBsZXQgdHJ5X2NvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IHRyeV9qb2luIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICBsZXQgcmVjIGZpbHRlcl9tYXAgZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgKCogZW5mb3JjZSBsZWZ0LXRvLXJpZ2h0IGV2YWx1YXRpb24gb3JkZXIgKilcbiAgICAgICAgIGxldCBsJyA9IGZpbHRlcl9tYXAgZiBsIGluXG4gICAgICAgICBsZXQgdicgPSBmIHYgaW5cbiAgICAgICAgIGxldCByJyA9IGZpbHRlcl9tYXAgZiByIGluXG4gICAgICAgICBiZWdpbiBtYXRjaCB2JyB3aXRoXG4gICAgICAgICAgIHwgU29tZSB2JyAtPlxuICAgICAgICAgICAgICBpZiBsID09IGwnICYmIHYgPT0gdicgJiYgciA9PSByJyB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSB0cnlfam9pbiBsJyB2JyByJ1xuICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgdHJ5X2NvbmNhdCBsJyByJ1xuICAgICAgICAgZW5kXG5cbiAgICBsZXQgb2Zfc29ydGVkX2xpc3QgbCA9XG4gICAgICBsZXQgcmVjIHN1YiBuIGwgPVxuICAgICAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICAgICAgfCAwLCBsIC0+IEVtcHR5LCBsXG4gICAgICAgIHwgMSwgeDAgOjogbCAtPiBOb2RlIHtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9LCBsXG4gICAgICAgIHwgMiwgeDAgOjogeDEgOjogbCAtPlxuICAgICAgICAgICAgTm9kZXtsPU5vZGV7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfTsgdj14MTsgcj1FbXB0eTsgaD0yfSwgbFxuICAgICAgICB8IDMsIHgwIDo6IHgxIDo6IHgyIDo6IGwgLT5cbiAgICAgICAgICAgIE5vZGV7bD1Ob2Rle2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX07IHY9eDE7XG4gICAgICAgICAgICAgICAgIHI9Tm9kZXtsPUVtcHR5OyB2PXgyOyByPUVtcHR5OyBoPTF9OyBoPTJ9LCBsXG4gICAgICAgIHwgbiwgbCAtPlxuICAgICAgICAgIGxldCBubCA9IG4gLyAyIGluXG4gICAgICAgICAgbGV0IGxlZnQsIGwgPSBzdWIgbmwgbCBpblxuICAgICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBtaWQgOjogbCAtPlxuICAgICAgICAgICAgbGV0IHJpZ2h0LCBsID0gc3ViIChuIC0gbmwgLSAxKSBsIGluXG4gICAgICAgICAgICBjcmVhdGUgbGVmdCBtaWQgcmlnaHQsIGxcbiAgICAgIGluXG4gICAgICBmc3QgKHN1YiAoTGlzdC5sZW5ndGggbCkgbClcblxuICAgIGxldCBvZl9saXN0IGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IGVtcHR5XG4gICAgICB8IFt4MF0gLT4gc2luZ2xldG9uIHgwXG4gICAgICB8IFt4MDsgeDFdIC0+IGFkZCB4MSAoc2luZ2xldG9uIHgwKVxuICAgICAgfCBbeDA7IHgxOyB4Ml0gLT4gYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpXG4gICAgICB8IFt4MDsgeDE7IHgyOyB4M10gLT4gYWRkIHgzIChhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSkpXG4gICAgICB8IFt4MDsgeDE7IHgyOyB4MzsgeDRdIC0+IGFkZCB4NCAoYWRkIHgzIChhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSkpKVxuICAgICAgfCBfIC0+IG9mX3NvcnRlZF9saXN0IChMaXN0LnNvcnRfdW5pcSBPcmQuY29tcGFyZSBsKVxuXG4gICAgbGV0IGFkZF9zZXEgaSBtID1cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBzIHggLT4gYWRkIHggcykgbSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPSBhZGRfc2VxIGkgZW1wdHlcblxuICAgIGxldCByZWMgc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoeCwgdCwgcmVzdCkgLT4gU2VxLkNvbnMgKHgsIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fc2VxIGMgPSBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSBjIEVuZClcblxuICAgIGxldCByZWMgc25vY19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHNub2NfZW51bSByIChNb3JlKHYsIGwsIGUpKVxuXG4gICAgbGV0IHJlYyByZXZfc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoeCwgdCwgcmVzdCkgLT4gU2VxLkNvbnMgKHgsIHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3Jldl9zZXEgYyA9IHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSBjIEVuZClcblxuICAgIGxldCB0b19zZXFfZnJvbSBsb3cgcyA9XG4gICAgICBsZXQgcmVjIGF1eCBsb3cgcyBjID0gbWF0Y2ggcyB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gY1xuICAgICAgICB8IE5vZGUge2w7IHI7IHY7IF99IC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBPcmQuY29tcGFyZSB2IGxvdyB3aXRoXG4gICAgICAgICAgICAgIHwgMCAtPiBNb3JlICh2LCByLCBjKVxuICAgICAgICAgICAgICB8IG4gd2hlbiBuPDAgLT4gYXV4IGxvdyByIGNcbiAgICAgICAgICAgICAgfCBfIC0+IGF1eCBsb3cgbCAoTW9yZSAodiwgciwgYykpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGluXG4gICAgICBzZXFfb2ZfZW51bV8gKGF1eCBsb3cgcyBFbmQpXG4gIGVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgdHlwZSBPcmRlcmVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICErJ2EgdFxuICAgIHZhbCBlbXB0eTogJ2EgdFxuICAgIHZhbCBpc19lbXB0eTogJ2EgdCAtPiBib29sXG4gICAgdmFsIG1lbTogIGtleSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgYWRkOiBrZXkgLT4gJ2EgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHVwZGF0ZToga2V5IC0+ICgnYSBvcHRpb24gLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgc2luZ2xldG9uOiBrZXkgLT4gJ2EgLT4gJ2EgdFxuICAgIHZhbCByZW1vdmU6IGtleSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgbWVyZ2U6XG4gICAgICAgICAgKGtleSAtPiAnYSBvcHRpb24gLT4gJ2Igb3B0aW9uIC0+ICdjIG9wdGlvbikgLT4gJ2EgdCAtPiAnYiB0IC0+ICdjIHRcbiAgICB2YWwgdW5pb246IChrZXkgLT4gJ2EgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBjb21wYXJlOiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBmb3JfYWxsOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgZmlsdGVyX21hcDogKGtleSAtPiAnYSAtPiAnYiBvcHRpb24pIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCBwYXJ0aXRpb246IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0ICogJ2EgdFxuICAgIHZhbCBjYXJkaW5hbDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgYmluZGluZ3M6ICdhIHQgLT4gKGtleSAqICdhKSBsaXN0XG4gICAgdmFsIG1pbl9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWluX2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1heF9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWF4X2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIGNob29zZTogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIGNob29zZV9vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgc3BsaXQ6IGtleSAtPiAnYSB0IC0+ICdhIHQgKiAnYSBvcHRpb24gKiAnYSB0XG4gICAgdmFsIGZpbmQ6IGtleSAtPiAnYSB0IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiBrZXkgLT4gJ2EgdCAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9maXJzdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IGtleSAqICdhXG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgZmluZF9sYXN0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4ga2V5ICogJ2FcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1hcDogKCdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgbWFwaTogKGtleSAtPiAnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19yZXZfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9mcm9tIDoga2V5IC0+ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZShPcmQ6IE9yZGVyZWRUeXBlKSA9IHN0cnVjdFxuXG4gICAgdHlwZSBrZXkgPSBPcmQudFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSBvZiB7bDonYSB0OyB2OmtleTsgZDonYTsgcjonYSB0OyBoOmludH1cblxuICAgIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2h9IC0+IGhcblxuICAgIGxldCBjcmVhdGUgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBoZWlnaHQgbCBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgTm9kZXtsOyB2PXg7IGQ7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgIGxldCBzaW5nbGV0b24geCBkID0gTm9kZXtsPUVtcHR5OyB2PXg7IGQ7IHI9RW1wdHk7IGg9MX1cblxuICAgIGxldCBiYWwgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgaWYgaGwgPiBociArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1sbDsgdj1sdjsgZD1sZDsgcj1scn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHIgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgbGwgbHYgbGQgKGNyZWF0ZSBsciB4IGQgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IGQ9bHJkOyByPWxycn0tPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbGQgbHJsKSBscnYgbHJkIChjcmVhdGUgbHJyIHggZCByKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZSBpZiBociA+IGhsICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPXJsOyB2PXJ2OyBkPXJkOyByPXJyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybCB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsKSBydiByZCByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgZD1ybGQ7IHI9cmxyfSAtPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmxsKSBybHYgcmxkIChjcmVhdGUgcmxyIHJ2IHJkIHJyKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIGFkZCB4IGRhdGEgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgaWYgZCA9PSBkYXRhIHRoZW4gbSBlbHNlIE5vZGV7bDsgdj14OyBkPWRhdGE7IHI7IGh9XG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSBhZGQgeCBkYXRhIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gYWRkIHggZGF0YSByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBmaW5kIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBkXG4gICAgICAgICAgZWxzZSBmaW5kIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2MCBkMCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3QgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHQgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2MCBkMCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3QgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHQgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfb3B0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSBkXG4gICAgICAgICAgZWxzZSBmaW5kX29wdCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGMgPSAwIHx8IG1lbSB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyB2OyBkfSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0gLT4gbWluX2JpbmRpbmcgbFxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge2x9LT4gbWluX2JpbmRpbmdfb3B0IGxcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7djsgZDsgcj1FbXB0eX0gLT4gKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nIHJcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmdfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiBTb21lICh2LCBkKVxuICAgICAgfCBOb2RlIHtyfSAtPiBtYXhfYmluZGluZ19vcHQgclxuXG4gICAgbGV0IHJlYyByZW1vdmVfbWluX2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5yZW1vdmVfbWluX2VsdFwiXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gYmFsIChyZW1vdmVfbWluX2JpbmRpbmcgbCkgdiBkIHJcblxuICAgIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgYmFsIHQxIHggZCAocmVtb3ZlX21pbl9iaW5kaW5nIHQyKVxuXG4gICAgbGV0IHJlYyByZW1vdmUgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgKE5vZGUge2w7IHY7IGQ7IHJ9IGFzIG0pIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgclxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gcmVtb3ZlIHggbCBpbiBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IHJlbW92ZSB4IHIgaW4gaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgdXBkYXRlIHggZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggZiBOb25lIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gRW1wdHlcbiAgICAgICAgICB8IFNvbWUgZGF0YSAtPiBOb2Rle2w9RW1wdHk7IHY9eDsgZD1kYXRhOyByPUVtcHR5OyBoPTF9XG4gICAgICAgICAgZW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IGFzIG0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IG1lcmdlIGwgclxuICAgICAgICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbmQgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSB1cGRhdGUgeCBmIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gdXBkYXRlIHggZiByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGl0ZXIgZiBsOyBmIHYgZDsgaXRlciBmIHJcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IC0+XG4gICAgICAgICAgbGV0IGwnID0gbWFwIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgZCBpblxuICAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIG1hcGkgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gLT5cbiAgICAgICAgICBsZXQgbCcgPSBtYXBpIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gbWFwaSBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIGZvbGQgZiBtIGFjY3UgPVxuICAgICAgbWF0Y2ggbSB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBmb2xkIGYgciAoZiB2IGQgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IHAgdiBkICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gcCB2IGQgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICAoKiBCZXdhcmU6IHRob3NlIHR3byBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgdGhlIGFkZGVkIGsgaXMgKnN0cmljdGx5KlxuICAgICAgIHNtYWxsZXIgKG9yIGJpZ2dlcikgdGhhbiBhbGwgdGhlIHByZXNlbnQga2V5cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBrZXkuXG5cbiAgICAgICBJbmRlZWQsIHRoZXkgYXJlIG9ubHkgdXNlZCBkdXJpbmcgdGhlIFwiam9pblwiIG9wZXJhdGlvbiB3aGljaFxuICAgICAgIHJlc3BlY3RzIHRoaXMgcHJlY29uZGl0aW9uLlxuICAgICopXG5cbiAgICBsZXQgcmVjIGFkZF9taW5fYmluZGluZyBrIHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24gayB4XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgIGJhbCAoYWRkX21pbl9iaW5kaW5nIGsgeCBsKSB2IGQgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2JpbmRpbmcgayB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIGsgeFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICBiYWwgbCB2IGQgKGFkZF9tYXhfYmluZGluZyBrIHggcilcblxuICAgICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGVcbiAgICAgICByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgcmVjIGpvaW4gbCB2IGQgciA9XG4gICAgICBtYXRjaCAobCwgcikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IGFkZF9taW5fYmluZGluZyB2IGQgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfYmluZGluZyB2IGQgbFxuICAgICAgfCAoTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyOyBoPWxofSxcbiAgICAgICAgIE5vZGV7bD1ybDsgdj1ydjsgZD1yZDsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgbGQgKGpvaW4gbHIgdiBkIHIpIGVsc2VcbiAgICAgICAgICBpZiByaCA+IGxoICsgMiB0aGVuIGJhbCAoam9pbiBsIHYgZCBybCkgcnYgcmQgcnIgZWxzZVxuICAgICAgICAgIGNyZWF0ZSBsIHYgZCByXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgam9pbiB0MSB4IGQgKHJlbW92ZV9taW5fYmluZGluZyB0MilcblxuICAgIGxldCBjb25jYXRfb3Jfam9pbiB0MSB2IGQgdDIgPVxuICAgICAgbWF0Y2ggZCB3aXRoXG4gICAgICB8IFNvbWUgZCAtPiBqb2luIHQxIHYgZCB0MlxuICAgICAgfCBOb25lIC0+IGNvbmNhdCB0MSB0MlxuXG4gICAgbGV0IHJlYyBzcGxpdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAoRW1wdHksIE5vbmUsIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiAobCwgU29tZSBkLCByKVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IChsbCwgcHJlcywgcmwpID0gc3BsaXQgeCBsIGluIChsbCwgcHJlcywgam9pbiBybCB2IGQgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGQgbHIsIHByZXMsIHJyKVxuXG4gICAgbGV0IHJlYyBtZXJnZSBmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBFbXB0eSkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LCBfKSB3aGVuIGgxID49IGhlaWdodCBzMiAtPlxuICAgICAgICAgIGxldCAobDIsIGQyLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MSAoZiB2MSAoU29tZSBkMSkgZDIpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCAoXywgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMn0pIC0+XG4gICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgY29uY2F0X29yX2pvaW4gKG1lcmdlIGYgbDEgbDIpIHYyIChmIHYyIGQxIChTb21lIGQyKSkgKG1lcmdlIGYgcjEgcjIpXG4gICAgICB8IF8gLT5cbiAgICAgICAgICBhc3NlcnQgZmFsc2VcblxuICAgIGxldCByZWMgdW5pb24gZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICB8IChFbXB0eSwgcykgfCAocywgRW1wdHkpIC0+IHNcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LFxuICAgICAgICAgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgbGV0IChsMiwgZDIsIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMiB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYxIGQxIHJcbiAgICAgICAgICAgIHwgU29tZSBkMiAtPiBjb25jYXRfb3Jfam9pbiBsIHYxIChmIHYxIGQxIGQyKSByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYyIGQyIHJcbiAgICAgICAgICAgIHwgU29tZSBkMSAtPiBjb25jYXRfb3Jfam9pbiBsIHYyIChmIHYyIGQxIGQyKSByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdmQgdGhlbiBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIG0gZWxzZSBqb2luIGwnIHYgZCByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIGZpbHRlcl9tYXAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbZl0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXJfbWFwIGYgbCBpblxuICAgICAgICAgIGxldCBmdmQgPSBmIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlcl9tYXAgZiByIGluXG4gICAgICAgICAgYmVnaW4gbWF0Y2ggZnZkIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBkJyAtPiBqb2luIGwnIHYgZCcgcidcbiAgICAgICAgICAgIHwgTm9uZSAtPiBjb25jYXQgbCcgcidcbiAgICAgICAgICBlbmRcblxuICAgIGxldCByZWMgcGFydGl0aW9uIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoRW1wdHksIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IChsdCwgbGYpID0gcGFydGl0aW9uIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCAocnQsIHJmKSA9IHBhcnRpdGlvbiBwIHIgaW5cbiAgICAgICAgICBpZiBwdmRcbiAgICAgICAgICB0aGVuIChqb2luIGx0IHYgZCBydCwgY29uY2F0IGxmIHJmKVxuICAgICAgICAgIGVsc2UgKGNvbmNhdCBsdCBydCwgam9pbiBsZiB2IGQgcmYpXG5cbiAgICB0eXBlICdhIGVudW1lcmF0aW9uID0gRW5kIHwgTW9yZSBvZiBrZXkgKiAnYSAqICdhIHQgKiAnYSBlbnVtZXJhdGlvblxuXG4gICAgbGV0IHJlYyBjb25zX2VudW0gbSBlID1cbiAgICAgIG1hdGNoIG0gd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGNvbnNfZW51bSBsIChNb3JlKHYsIGQsIHIsIGUpKVxuXG4gICAgbGV0IGNvbXBhcmUgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgY29tcGFyZV9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IDBcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gLTFcbiAgICAgICAgfCAoXywgRW5kKSAtPiAxXG4gICAgICAgIHwgKE1vcmUodjEsIGQxLCByMSwgZTEpLCBNb3JlKHYyLCBkMiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgZDEgZDIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgY29tcGFyZV9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGNvbXBhcmVfYXV4IChjb25zX2VudW0gbTEgRW5kKSAoY29uc19lbnVtIG0yIEVuZClcblxuICAgIGxldCBlcXVhbCBjbXAgbTEgbTIgPVxuICAgICAgbGV0IHJlYyBlcXVhbF9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IHRydWVcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gZmFsc2VcbiAgICAgICAgfCAoXywgRW5kKSAtPiBmYWxzZVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBPcmQuY29tcGFyZSB2MSB2MiA9IDAgJiYgY21wIGQxIGQyICYmXG4gICAgICAgICAgICBlcXVhbF9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGVxdWFsX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgcmVjIGNhcmRpbmFsID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtsOyByfSAtPiBjYXJkaW5hbCBsICsgMSArIGNhcmRpbmFsIHJcblxuICAgIGxldCByZWMgYmluZGluZ3NfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGJpbmRpbmdzX2F1eCAoKHYsIGQpIDo6IGJpbmRpbmdzX2F1eCBhY2N1IHIpIGxcblxuICAgIGxldCBiaW5kaW5ncyBzID1cbiAgICAgIGJpbmRpbmdzX2F1eCBbXSBzXG5cbiAgICBsZXQgY2hvb3NlID0gbWluX2JpbmRpbmdcblxuICAgIGxldCBjaG9vc2Vfb3B0ID0gbWluX2JpbmRpbmdfb3B0XG5cbiAgICBsZXQgYWRkX3NlcSBpIG0gPVxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIG0gKGssdikgLT4gYWRkIGsgdiBtKSBtIGlcblxuICAgIGxldCBvZl9zZXEgaSA9IGFkZF9zZXEgaSBlbXB0eVxuXG4gICAgbGV0IHJlYyBzZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlIChrLHYsdCxyZXN0KSAtPiBTZXEuQ29ucyAoKGssdiksIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fc2VxIG0gPVxuICAgICAgc2VxX29mX2VudW1fIChjb25zX2VudW0gbSBFbmQpXG5cbiAgICBsZXQgcmVjIHNub2NfZW51bSBzIGUgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZXtsOyB2OyBkOyByfSAtPiBzbm9jX2VudW0gciAoTW9yZSh2LCBkLCBsLCBlKSlcblxuICAgIGxldCByZWMgcmV2X3NlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKGssdix0LHJlc3QpIC0+XG4gICAgICAgICAgU2VxLkNvbnMgKChrLHYpLCByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19yZXZfc2VxIGMgPVxuICAgICAgcmV2X3NlcV9vZl9lbnVtXyAoc25vY19lbnVtIGMgRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBtID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBtIGMgPSBtYXRjaCBtIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIGQsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCBkLCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBtIEVuZClcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSB7IG11dGFibGUgYyA6ICdhIGxpc3Q7IG11dGFibGUgbGVuIDogaW50OyB9XG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG5sZXQgY3JlYXRlICgpID0geyBjID0gW107IGxlbiA9IDA7IH1cblxubGV0IGNsZWFyIHMgPSBzLmMgPC0gW107IHMubGVuIDwtIDBcblxubGV0IGNvcHkgcyA9IHsgYyA9IHMuYzsgbGVuID0gcy5sZW47IH1cblxubGV0IHB1c2ggeCBzID0gcy5jIDwtIHggOjogcy5jOyBzLmxlbiA8LSBzLmxlbiArIDFcblxubGV0IHBvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDE7IGhkXG4gIHwgW10gICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCBwb3Bfb3B0IHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjp0bCAtPiBzLmMgPC0gdGw7IHMubGVuIDwtIHMubGVuIC0gMTsgU29tZSBoZFxuICB8IFtdICAgICAtPiBOb25lXG5cbmxldCB0b3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6Ol8gLT4gaGRcbiAgfCBbXSAgICAtPiByYWlzZSBFbXB0eVxuXG5sZXQgdG9wX29wdCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6XyAtPiBTb21lIGhkXG4gIHwgW10gICAgLT4gTm9uZVxuXG5sZXQgaXNfZW1wdHkgcyA9IChzLmMgPSBbXSlcblxubGV0IGxlbmd0aCBzID0gcy5sZW5cblxubGV0IGl0ZXIgZiBzID0gTGlzdC5pdGVyIGYgcy5jXG5cbmxldCBmb2xkIGYgYWNjIHMgPSBMaXN0LmZvbGRfbGVmdCBmIGFjYyBzLmNcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID0gTGlzdC50b19zZXEgcy5jXG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcyA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcyBnO1xuICBzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEZyYW5jb2lzIFBvdHRpZXIsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgIEplcmVtaWUgRGltaW5vLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG50eXBlICdhIGNlbGwgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgeyBjb250ZW50OiAnYTsgbXV0YWJsZSBuZXh0OiAnYSBjZWxsIH1cblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIGxlbmd0aDogaW50O1xuICBtdXRhYmxlIGZpcnN0OiAnYSBjZWxsO1xuICBtdXRhYmxlIGxhc3Q6ICdhIGNlbGxcbn1cblxubGV0IGNyZWF0ZSAoKSA9IHtcbiAgbGVuZ3RoID0gMDtcbiAgZmlyc3QgPSBOaWw7XG4gIGxhc3QgPSBOaWxcbn1cblxubGV0IGNsZWFyIHEgPVxuICBxLmxlbmd0aCA8LSAwO1xuICBxLmZpcnN0IDwtIE5pbDtcbiAgcS5sYXN0IDwtIE5pbFxuXG5sZXQgYWRkIHggcSA9XG4gIGxldCBjZWxsID0gQ29ucyB7XG4gICAgY29udGVudCA9IHg7XG4gICAgbmV4dCA9IE5pbFxuICB9IGluXG4gIG1hdGNoIHEubGFzdCB3aXRoXG4gIHwgTmlsIC0+XG4gICAgcS5sZW5ndGggPC0gMTtcbiAgICBxLmZpcnN0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcbiAgfCBDb25zIGxhc3QgLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCArIDE7XG4gICAgbGFzdC5uZXh0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcblxubGV0IHB1c2ggPVxuICBhZGRcblxubGV0IHBlZWsgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50IH0gLT4gY29udGVudFxuXG5sZXQgcGVla19vcHQgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiBOb25lXG4gIHwgQ29ucyB7IGNvbnRlbnQgfSAtPiBTb21lIGNvbnRlbnRcblxubGV0IHRvcCA9XG4gIHBlZWtcblxubGV0IHRha2UgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gLT5cbiAgICBjbGVhciBxO1xuICAgIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBjb250ZW50XG5cbmxldCB0YWtlX29wdCBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IE5vbmVcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IC0+XG4gICAgY2xlYXIgcTtcbiAgICBTb21lIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBTb21lIGNvbnRlbnRcblxubGV0IHBvcCA9XG4gIHRha2VcblxubGV0IGNvcHkgPVxuICBsZXQgcmVjIGNvcHkgcV9yZXMgcHJldiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBxX3Jlcy5sYXN0IDwtIHByZXY7IHFfcmVzXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgcmVzID0gQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSBpblxuICAgICAgYmVnaW4gbWF0Y2ggcHJldiB3aXRoXG4gICAgICB8IE5pbCAtPiBxX3Jlcy5maXJzdCA8LSByZXNcbiAgICAgIHwgQ29ucyBwIC0+IHAubmV4dCA8LSByZXNcbiAgICAgIGVuZDtcbiAgICAgIGNvcHkgcV9yZXMgcmVzIG5leHRcbiAgaW5cbiAgZnVuIHEgLT4gY29weSB7IGxlbmd0aCA9IHEubGVuZ3RoOyBmaXJzdCA9IE5pbDsgbGFzdCA9IE5pbCB9IE5pbCBxLmZpcnN0XG5cbmxldCBpc19lbXB0eSBxID1cbiAgcS5sZW5ndGggPSAwXG5cbmxldCBsZW5ndGggcSA9XG4gIHEubGVuZ3RoXG5cbmxldCBpdGVyID1cbiAgbGV0IHJlYyBpdGVyIGYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGYgY29udGVudDtcbiAgICAgIGl0ZXIgZiBuZXh0XG4gIGluXG4gIGZ1biBmIHEgLT4gaXRlciBmIHEuZmlyc3RcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGZvbGQgZiBhY2N1IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IGFjY3VcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGNvbnRlbnQgaW5cbiAgICAgIGZvbGQgZiBhY2N1IG5leHRcbiAgaW5cbiAgZnVuIGYgYWNjdSBxIC0+IGZvbGQgZiBhY2N1IHEuZmlyc3RcblxubGV0IHRyYW5zZmVyIHExIHEyID1cbiAgaWYgcTEubGVuZ3RoID4gMCB0aGVuXG4gICAgbWF0Y2ggcTIubGFzdCB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMS5sZW5ndGg7XG4gICAgICBxMi5maXJzdCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG4gICAgfCBDb25zIGxhc3QgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMi5sZW5ndGggKyBxMS5sZW5ndGg7XG4gICAgICBsYXN0Lm5leHQgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHEgPVxuICBsZXQgcmVjIGF1eCBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgfCBOaWwgLT4gU2VxLk5pbFxuICAgIHwgQ29ucyB7IGNvbnRlbnQ9eDsgbmV4dDsgfSAtPiBTZXEuQ29ucyAoeCwgYXV4IG5leHQpXG4gIGluXG4gIGF1eCBxLmZpcnN0XG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcSA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcSBnO1xuICBxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICBQaWVycmUgV2VpcyBhbmQgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk5IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEV4dGVuc2libGUgYnVmZmVycyAqKVxuXG4oKiBUaGUgW2lubmVyX2J1ZmZlcl0gdHlwZSBlbnN1cmVzIHRoYXQgdGhlIFtsZW5ndGhdIGFuZCBbYnVmZmVyXSBmaWVsZHMgYXJlXG4gICBhbHdheXMgc3luY2hyb25pemVkLCBbbGVuZ3RoID0gQnl0ZXMubGVuZ3RoIGJ1ZmZlcl0sIGV2ZW4gaW4gcHJlc2VuY2VcbiAgIG9mIGRhdGEgcmFjZXMuXG4qKVxudHlwZSBpbm5lcl9idWZmZXIgPSB7XG4gIGJ1ZmZlcjogYnl0ZXM7XG4gIGxlbmd0aDogaW50O1xufVxuXG50eXBlIHQgPVxuIHttdXRhYmxlIGlubmVyIDogaW5uZXJfYnVmZmVyO1xuICBtdXRhYmxlIHBvc2l0aW9uIDogaW50O1xuICBpbml0aWFsX2J1ZmZlciA6IGJ5dGVzfVxuKCogSW52YXJpYW50czogYWxsIHBhcnRzIG9mIHRoZSBjb2RlIHByZXNlcnZlIHRoZSBpbnZhcmlhbnRzIHRoYXQ6XG4gICAtIFtpbm5lci5sZW5ndGggPSBCeXRlcy5sZW5ndGggaW5uZXIuYnVmZmVyXVxuICAgSW4gYWJzZW5jZSBvZiBkYXRhIHJhY2VzLCB3ZSBhbHNvIGhhdmVcbiAgIC0gWzAgPD0gYi5wb3NpdGlvbiA8PSBiLmlubmVyLmxlbmd0aF1cblxuICAgTm90ZSBpbiBwYXJ0aWN1bGFyIHRoYXQgW2IucG9zaXRpb24gPSBiLmlubmVyLmxlbmd0aF0gaXMgbGVnYWwsXG4gICBpdCBtZWFucyB0aGF0IHRoZSBidWZmZXIgaXMgZnVsbCBhbmQgd2lsbCBoYXZlIHRvIGJlIGV4dGVuZGVkXG4gICBiZWZvcmUgYW55IGZ1cnRoZXIgYWRkaXRpb24uICopXG5cbmxldCBjcmVhdGUgbiA9XG4gbGV0IG4gPSBpZiBuIDwgMSB0aGVuIDEgZWxzZSBuIGluXG4gbGV0IG4gPSBpZiBuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGVsc2UgbiBpblxuIGxldCBzID0gQnl0ZXMuY3JlYXRlIG4gaW5cbiB7IGlubmVyID0geyBidWZmZXIgPSBzOyBsZW5ndGggPSBufTsgcG9zaXRpb24gPSAwOyBpbml0aWFsX2J1ZmZlciA9IHN9XG5cbmxldCBjb250ZW50cyBiID0gQnl0ZXMuc3ViX3N0cmluZyBiLmlubmVyLmJ1ZmZlciAwIGIucG9zaXRpb25cbmxldCB0b19ieXRlcyBiID0gQnl0ZXMuc3ViIGIuaW5uZXIuYnVmZmVyIDAgYi5wb3NpdGlvblxuXG5sZXQgc3ViIGIgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBiLnBvc2l0aW9uIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuc3ViXCJcbiAgZWxzZSBCeXRlcy5zdWJfc3RyaW5nIGIuaW5uZXIuYnVmZmVyIG9mcyBsZW5cblxuXG5sZXQgYmxpdCBzcmMgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBzcmNvZmYgPCAwIHx8IHNyY29mZiA+IHNyYy5wb3NpdGlvbiAtIGxlblxuICAgICAgICAgICAgIHx8IGRzdG9mZiA8IDAgfHwgZHN0b2ZmID4gKEJ5dGVzLmxlbmd0aCBkc3QpIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuYmxpdFwiXG4gIGVsc2VcbiAgICBCeXRlcy5ibGl0IHNyYy5pbm5lci5idWZmZXIgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuXG5cblxubGV0IG50aCBiIG9mcyA9XG4gIGxldCBwb3NpdGlvbiA9IGIucG9zaXRpb24gaW5cbiAgbGV0IHtidWZmZXI7bGVuZ3RofSA9IGIuaW5uZXIgaW5cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPj0gcG9zaXRpb24gfHwgcG9zaXRpb24gPiBsZW5ndGggdGhlblxuICAgaW52YWxpZF9hcmcgXCJCdWZmZXIubnRoXCJcbiAgZWxzZSBCeXRlcy51bnNhZmVfZ2V0IGJ1ZmZlciBvZnNcblxuXG5sZXQgbGVuZ3RoIGIgPSBiLnBvc2l0aW9uXG5cbmxldCBjbGVhciBiID0gYi5wb3NpdGlvbiA8LSAwXG5cbmxldCByZXNldCBiID1cbiAgYi5wb3NpdGlvbiA8LSAwO1xuICBsZXQgaW5uZXIgPVxuICAgIHsgYnVmZmVyID0gYi5pbml0aWFsX2J1ZmZlcjsgbGVuZ3RoID0gQnl0ZXMubGVuZ3RoIGIuaW5pdGlhbF9idWZmZXIgfVxuICBpblxuICBiLmlubmVyIDwtIGlubmVyXG5cbigqIFtyZXNpemUgYiBtb3JlXSBlbnN1cmVzIHRoYXQgW2IucG9zaXRpb24gKyBtb3JlIDw9IGIuaW5uZXIubGVuZ3RoXSBob2xkc1xuICAgYnkgZHluYW1pY2FsbHkgZXh0ZW5kaW5nIFtiLmlubmVyXSBpZiBuZWNlc3NhcnkgLS0gYW5kIHRodXNcbiAgIGluY3JlYXNpbmcgW2IuaW5uZXIubGVuZ3RoXS5cbiopXG5sZXQgcmVzaXplIGIgbW9yZSA9XG4gIGxldCBvbGRfcG9zID0gYi5wb3NpdGlvbiBpblxuICBsZXQgb2xkX2xlbiA9IGIuaW5uZXIubGVuZ3RoIGluXG4gIGxldCBuZXdfbGVuID0gcmVmIG9sZF9sZW4gaW5cbiAgd2hpbGUgb2xkX3BvcyArIG1vcmUgPiAhbmV3X2xlbiBkbyBuZXdfbGVuIDo9IDIgKiAhbmV3X2xlbiBkb25lO1xuICBpZiAhbmV3X2xlbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIGJlZ2luXG4gICAgaWYgb2xkX3BvcyArIG1vcmUgPD0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgdGhlbiBuZXdfbGVuIDo9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgIGVsc2UgZmFpbHdpdGggXCJCdWZmZXIuYWRkOiBjYW5ub3QgZ3JvdyBidWZmZXJcIlxuICBlbmQ7XG4gIGxldCBuZXdfYnVmZmVyID0gQnl0ZXMuY3JlYXRlICFuZXdfbGVuIGluXG4gICgqIFBSIzYxNDg6IGxldCdzIGtlZXAgdXNpbmcgW2JsaXRdIHJhdGhlciB0aGFuIFt1bnNhZmVfYmxpdF0gaW5cbiAgICAgdGhpcyB0cmlja3kgZnVuY3Rpb24gdGhhdCBpcyBzbG93IGFueXdheS4gKilcbiAgQnl0ZXMuYmxpdCBiLmlubmVyLmJ1ZmZlciAwIG5ld19idWZmZXIgMCBiLnBvc2l0aW9uO1xuICBiLmlubmVyIDwtIHsgYnVmZmVyID0gbmV3X2J1ZmZlcjsgbGVuZ3RoID0gIW5ld19sZW4gfVxuXG4oKiBOb3RlOlxuICAgIFNvbWUgb2YgdGhlIGZ1bmN0aW9ucyBiZWxvdyBoYXZlIGEgZmFzdCBwYXRoIHdoZW4gdGhlIGlubmVyXG4gIGJ1ZmZlciBkb2Vzbid0IG5lZWQgdG8gYmUgZXh0ZW5kZWQuXG4gICAgSW4gdGhpcyBjYXNlLCBpdCBpcyBwb3NzaWJsZSB0byB1c2UgdW5zYWZlIGFjY2Vzc2VzIG9uIHRoZVxuICBjb250ZW50cyBvZiB0aGUgW2lubmVyXSBmaWVsZCBzaW5jZSBpdHMgZmllbGRzIGFyZSBpbW11dGFibGUuXG4gIEluIHByZXNlbmNlIG9mIGRhdGEgcmFjZXMsIHdlIG1heSBhY2Nlc3MgdGhlIHdyb25nIGlubmVyIGJ1ZmZlciwgYnV0IHdlXG4gIHdpbGwgdXNlIHRoaXMgYnVmZmVyIHNhZmVseS5cbiAgQXMgc29vbiBhcyB3ZSBuZWVkIHRvIHJlc2l6ZSB0aGUgYnVmZmVyLCB3ZSBmYWxsIGJhY2sgdG8gc2FmZSBhY2Nlc3Nlcy5cbiopXG5cbmxldCBhZGRfY2hhciBiIGMgPVxuICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICBsZXQge2J1ZmZlcjtsZW5ndGh9ID0gYi5pbm5lciBpblxuICBpZiBwb3MgPj0gbGVuZ3RoIHRoZW4gKFxuICAgIHJlc2l6ZSBiIDE7XG4gICAgQnl0ZXMuc2V0IGIuaW5uZXIuYnVmZmVyIGIucG9zaXRpb24gY1xuICApIGVsc2VcbiAgICBCeXRlcy51bnNhZmVfc2V0IGJ1ZmZlciBwb3MgYztcbiAgYi5wb3NpdGlvbiA8LSBwb3MgKyAxXG5cbmxldCB1Y2hhcl91dGZfOF9ieXRlX2xlbmd0aF9tYXggPSA0XG5sZXQgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heCA9IDRcblxubGV0IHJlYyBhZGRfdXRmXzhfdWNoYXIgYiB1ID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIuaW5uZXIubGVuZ3RoIHRoZW4gcmVzaXplIGIgdWNoYXJfdXRmXzhfYnl0ZV9sZW5ndGhfbWF4O1xuICBsZXQgbiA9IEJ5dGVzLnNldF91dGZfOF91Y2hhciBiLmlubmVyLmJ1ZmZlciBwb3MgdSBpblxuICBpZiBuID0gMFxuICB0aGVuIChyZXNpemUgYiB1Y2hhcl91dGZfOF9ieXRlX2xlbmd0aF9tYXg7IGFkZF91dGZfOF91Y2hhciBiIHUpXG4gIGVsc2UgKGIucG9zaXRpb24gPC0gcG9zICsgbilcblxubGV0IHJlYyBhZGRfdXRmXzE2YmVfdWNoYXIgYiB1ID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIuaW5uZXIubGVuZ3RoIHRoZW4gcmVzaXplIGIgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heDtcbiAgbGV0IG4gPSBCeXRlcy5zZXRfdXRmXzE2YmVfdWNoYXIgYi5pbm5lci5idWZmZXIgcG9zIHUgaW5cbiAgaWYgbiA9IDBcbiAgdGhlbiAocmVzaXplIGIgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heDsgYWRkX3V0Zl8xNmJlX3VjaGFyIGIgdSlcbiAgZWxzZSAoYi5wb3NpdGlvbiA8LSBwb3MgKyBuKVxuXG5sZXQgcmVjIGFkZF91dGZfMTZsZV91Y2hhciBiIHUgPVxuICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICBpZiBwb3MgPj0gYi5pbm5lci5sZW5ndGggdGhlbiByZXNpemUgYiB1Y2hhcl91dGZfMTZfYnl0ZV9sZW5ndGhfbWF4O1xuICBsZXQgbiA9IEJ5dGVzLnNldF91dGZfMTZsZV91Y2hhciBiLmlubmVyLmJ1ZmZlciBwb3MgdSBpblxuICBpZiBuID0gMFxuICB0aGVuIChyZXNpemUgYiB1Y2hhcl91dGZfMTZfYnl0ZV9sZW5ndGhfbWF4OyBhZGRfdXRmXzE2bGVfdWNoYXIgYiB1KVxuICBlbHNlIChiLnBvc2l0aW9uIDwtIHBvcyArIG4pXG5cbmxldCBhZGRfc3Vic3RyaW5nIGIgcyBvZmZzZXQgbGVuID1cbiAgaWYgb2Zmc2V0IDwgMCB8fCBsZW4gPCAwIHx8IG9mZnNldCA+IFN0cmluZy5sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLmFkZF9zdWJzdHJpbmcvYWRkX3N1YmJ5dGVzXCI7XG4gIGxldCBwb3NpdGlvbiA9IGIucG9zaXRpb24gaW5cbiAgbGV0IHtidWZmZXI7bGVuZ3RofSA9IGIuaW5uZXIgaW5cbiAgbGV0IG5ld19wb3NpdGlvbiA9IHBvc2l0aW9uICsgbGVuIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGxlbmd0aCB0aGVuIChcbiAgICByZXNpemUgYiBsZW47XG4gICAgQnl0ZXMuYmxpdF9zdHJpbmcgcyBvZmZzZXQgYi5pbm5lci5idWZmZXIgYi5wb3NpdGlvbiBsZW5cbiAgKSBlbHNlXG4gICAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIHMgb2Zmc2V0IGJ1ZmZlciBwb3NpdGlvbiBsZW47XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfc3ViYnl0ZXMgYiBzIG9mZnNldCBsZW4gPVxuICBhZGRfc3Vic3RyaW5nIGIgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcykgb2Zmc2V0IGxlblxuXG5sZXQgYWRkX3N0cmluZyBiIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBwb3NpdGlvbiA9IGIucG9zaXRpb24gaW5cbiAgbGV0IHtidWZmZXI7IGxlbmd0aH0gPSBiLmlubmVyIGluXG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgbGVuIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGxlbmd0aCB0aGVuIChcbiAgICByZXNpemUgYiBsZW47XG4gICAgQnl0ZXMuYmxpdF9zdHJpbmcgcyAwIGIuaW5uZXIuYnVmZmVyIGIucG9zaXRpb24gbGVuO1xuICApIGVsc2VcbiAgICBCeXRlcy51bnNhZmVfYmxpdF9zdHJpbmcgcyAwIGJ1ZmZlciBwb3NpdGlvbiBsZW47XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfYnl0ZXMgYiBzID0gYWRkX3N0cmluZyBiIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMpXG5cbmxldCBhZGRfYnVmZmVyIGIgYnMgPVxuICBhZGRfc3ViYnl0ZXMgYiBicy5pbm5lci5idWZmZXIgMCBicy5wb3NpdGlvblxuXG4oKiB0aGlzIChwcml2YXRlKSBmdW5jdGlvbiBjb3VsZCBtb3ZlIGludG8gdGhlIHN0YW5kYXJkIGxpYnJhcnkgKilcbmxldCByZWFsbHlfaW5wdXRfdXBfdG8gaWMgYnVmIG9mcyBsZW4gPVxuICBsZXQgcmVjIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQgfm9mcyB+dG9fcmVhZCA9XG4gICAgaWYgdG9fcmVhZCA9IDAgdGhlbiBhbHJlYWR5X3JlYWRcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IGlucHV0IGljIGJ1ZiBvZnMgdG9fcmVhZCBpblxuICAgICAgaWYgciA9IDAgdGhlbiBhbHJlYWR5X3JlYWRcbiAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGFscmVhZHlfcmVhZCA9IGFscmVhZHlfcmVhZCArIHIgaW5cbiAgICAgICAgbGV0IG9mcyA9IG9mcyArIHIgaW5cbiAgICAgICAgbGV0IHRvX3JlYWQgPSB0b19yZWFkIC0gciBpblxuICAgICAgICBsb29wIGljIGJ1ZiB+YWxyZWFkeV9yZWFkIH5vZnMgfnRvX3JlYWRcbiAgICAgIGVuZFxuICAgIGVuZFxuICBpbiBsb29wIGljIGJ1ZiB+YWxyZWFkeV9yZWFkOjAgfm9mcyB+dG9fcmVhZDpsZW5cblxuXG5sZXQgdW5zYWZlX2FkZF9jaGFubmVsX3VwX3RvIGIgaWMgbGVuID1cbiAgaWYgYi5wb3NpdGlvbiArIGxlbiA+IGIuaW5uZXIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBsZXQgbiA9IHJlYWxseV9pbnB1dF91cF90byBpYyBiLmlubmVyLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbiBpblxuICBiLnBvc2l0aW9uIDwtIGIucG9zaXRpb24gKyBuO1xuICBuXG5cbmxldCBhZGRfY2hhbm5lbCBiIGljIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgbGVuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gICAoKiBQUiM1MDA0ICopXG4gICAgaW52YWxpZF9hcmcgXCJCdWZmZXIuYWRkX2NoYW5uZWxcIjtcbiAgbGV0IG4gPSB1bnNhZmVfYWRkX2NoYW5uZWxfdXBfdG8gYiBpYyBsZW4gaW5cbiAgKCogSXQgaXMgaW50ZW50aW9uYWwgdGhhdCBhIGNvbnN1bWVyIGNhdGNoaW5nIEVuZF9vZl9maWxlXG4gICAgIHdpbGwgc2VlIHRoZSBkYXRhIHdyaXR0ZW4gKHNlZSAjNjcxOSwgIzcxMzYpLiAqKVxuICBpZiBuIDwgbGVuIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGU7XG4gICgpXG5cbmxldCBvdXRwdXRfYnVmZmVyIG9jIGIgPVxuICBvdXRwdXQgb2MgYi5pbm5lci5idWZmZXIgMCBiLnBvc2l0aW9uXG5cbmxldCBjbG9zaW5nID0gZnVuY3Rpb25cbiAgfCAnKCcgLT4gJyknXG4gIHwgJ3snIC0+ICd9J1xuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbigqIG9wZW5pbmcgYW5kIGNsb3Npbmc6IG9wZW4gYW5kIGNsb3NlIGNoYXJhY3RlcnMsIHR5cGljYWxseSAoIGFuZCApXG4gICBrOiBiYWxhbmNlIG9mIG9wZW5pbmcgYW5kIGNsb3NpbmcgY2hhcnNcbiAgIHM6IHRoZSBzdHJpbmcgd2hlcmUgd2UgYXJlIHNlYXJjaGluZ1xuICAgc3RhcnQ6IHRoZSBpbmRleCB3aGVyZSB3ZSBzdGFydCB0aGUgc2VhcmNoLiAqKVxubGV0IGFkdmFuY2VfdG9fY2xvc2luZyBvcGVuaW5nIGNsb3NpbmcgayBzIHN0YXJ0ID1cbiAgbGV0IHJlYyBhZHZhbmNlIGsgaSBsaW0gPVxuICAgIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgICBpZiBzLltpXSA9IG9wZW5pbmcgdGhlbiBhZHZhbmNlIChrICsgMSkgKGkgKyAxKSBsaW0gZWxzZVxuICAgIGlmIHMuW2ldID0gY2xvc2luZyB0aGVuXG4gICAgICBpZiBrID0gMCB0aGVuIGkgZWxzZSBhZHZhbmNlIChrIC0gMSkgKGkgKyAxKSBsaW1cbiAgICBlbHNlIGFkdmFuY2UgayAoaSArIDEpIGxpbSBpblxuICBhZHZhbmNlIGsgc3RhcnQgKFN0cmluZy5sZW5ndGggcylcblxubGV0IGFkdmFuY2VfdG9fbm9uX2FscGhhIHMgc3RhcnQgPVxuICBsZXQgcmVjIGFkdmFuY2UgaSBsaW0gPVxuICAgIGlmIGkgPj0gbGltIHRoZW4gbGltIGVsc2VcbiAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgfCAnYScgLi4gJ3onIHwgJ0EnIC4uICdaJyB8ICcwJyAuLiAnOScgfCAnXycgLT4gYWR2YW5jZSAoaSArIDEpIGxpbVxuICAgIHwgXyAtPiBpIGluXG4gIGFkdmFuY2Ugc3RhcnQgKFN0cmluZy5sZW5ndGggcylcblxuKCogV2UgYXJlIGp1c3QgYXQgdGhlIGJlZ2lubmluZyBvZiBhbiBpZGVudCBpbiBzLCBzdGFydGluZyBhdCBzdGFydC4gKilcbmxldCBmaW5kX2lkZW50IHMgc3RhcnQgbGltID1cbiAgaWYgc3RhcnQgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgbWF0Y2ggcy5bc3RhcnRdIHdpdGhcbiAgKCogUGFyZW50aGVzaXplZCBpZGVudCA/ICopXG4gIHwgJygnIHwgJ3snIGFzIGMgLT5cbiAgICAgbGV0IG5ld19zdGFydCA9IHN0YXJ0ICsgMSBpblxuICAgICBsZXQgc3RvcCA9IGFkdmFuY2VfdG9fY2xvc2luZyBjIChjbG9zaW5nIGMpIDAgcyBuZXdfc3RhcnQgaW5cbiAgICAgU3RyaW5nLnN1YiBzIG5ld19zdGFydCAoc3RvcCAtIHN0YXJ0IC0gMSksIHN0b3AgKyAxXG4gICgqIFJlZ3VsYXIgaWRlbnQgKilcbiAgfCBfIC0+XG4gICAgIGxldCBzdG9wID0gYWR2YW5jZV90b19ub25fYWxwaGEgcyAoc3RhcnQgKyAxKSBpblxuICAgICBTdHJpbmcuc3ViIHMgc3RhcnQgKHN0b3AgLSBzdGFydCksIHN0b3BcblxuKCogU3Vic3RpdHV0ZSAkaWRlbnQsICQoaWRlbnQpLCBvciAke2lkZW50fSBpbiBzLFxuICAgIGFjY29yZGluZyB0byB0aGUgZnVuY3Rpb24gbWFwcGluZyBmLiAqKVxubGV0IGFkZF9zdWJzdGl0dXRlIGIgZiBzID1cbiAgbGV0IGxpbSA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIHN1YnN0IHByZXZpb3VzIGkgPVxuICAgIGlmIGkgPCBsaW0gdGhlbiBiZWdpblxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnJCcgYXMgY3VycmVudCB3aGVuIHByZXZpb3VzID0gJ1xcXFwnIC0+XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCAnICcgKGkgKyAxKVxuICAgICAgfCAnJCcgLT5cbiAgICAgICAgIGxldCBqID0gaSArIDEgaW5cbiAgICAgICAgIGxldCBpZGVudCwgbmV4dF9pID0gZmluZF9pZGVudCBzIGogbGltIGluXG4gICAgICAgICBhZGRfc3RyaW5nIGIgKGYgaWRlbnQpO1xuICAgICAgICAgc3Vic3QgJyAnIG5leHRfaVxuICAgICAgfCBjdXJyZW50IHdoZW4gcHJldmlvdXMgPT0gJ1xcXFwnIC0+XG4gICAgICAgICBhZGRfY2hhciBiICdcXFxcJztcbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0ICcgJyAoaSArIDEpXG4gICAgICB8ICdcXFxcJyBhcyBjdXJyZW50IC0+XG4gICAgICAgICBzdWJzdCBjdXJyZW50IChpICsgMSlcbiAgICAgIHwgY3VycmVudCAtPlxuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgY3VycmVudCAoaSArIDEpXG4gICAgZW5kIGVsc2VcbiAgICBpZiBwcmV2aW91cyA9ICdcXFxcJyB0aGVuIGFkZF9jaGFyIGIgcHJldmlvdXMgaW5cbiAgc3Vic3QgJyAnIDBcblxubGV0IHRydW5jYXRlIGIgbGVuID1cbiAgICBpZiBsZW4gPCAwIHx8IGxlbiA+IGxlbmd0aCBiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiQnVmZmVyLnRydW5jYXRlXCJcbiAgICBlbHNlXG4gICAgICBiLnBvc2l0aW9uIDwtIGxlblxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGIgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICAoKiBOb3RlIHRoYXQgYi5wb3NpdGlvbiBpcyBub3QgYSBjb25zdGFudCBhbmQgY2Fubm90IGJlIGxpZnRlZCBvdXQgb2YgYXV4ICopXG4gICAgaWYgaSA+PSBiLnBvc2l0aW9uIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gQnl0ZXMuZ2V0IGIuaW5uZXIuYnVmZmVyIGkgaW5cbiAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCB0b19zZXFpIGIgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICAoKiBOb3RlIHRoYXQgYi5wb3NpdGlvbiBpcyBub3QgYSBjb25zdGFudCBhbmQgY2Fubm90IGJlIGxpZnRlZCBvdXQgb2YgYXV4ICopXG4gICAgaWYgaSA+PSBiLnBvc2l0aW9uIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gQnl0ZXMuZ2V0IGIuaW5uZXIuYnVmZmVyIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgYWRkX3NlcSBiIHNlcSA9IFNlcS5pdGVyIChhZGRfY2hhciBiKSBzZXFcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IGIgPSBjcmVhdGUgMzIgaW5cbiAgYWRkX3NlcSBiIGk7XG4gIGJcblxuKCoqIHs2IEJpbmFyeSBlbmNvZGluZyBvZiBpbnRlZ2Vyc30gKilcblxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDE2IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQxNnVcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQzMiA6IGJ5dGVzIC0+IGludCAtPiBpbnQzMiAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQzMnVcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQ2NCA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQ2NHVcIlxuZXh0ZXJuYWwgc2V0X2ludDggOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVieXRlc19zYWZlX3NldFwiXG5leHRlcm5hbCBzZXRfaW50MTYgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDE2XCJcbmV4dGVybmFsIHNldF9pbnQzMiA6IGJ5dGVzIC0+IGludCAtPiBpbnQzMiAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQzMlwiXG5leHRlcm5hbCBzZXRfaW50NjQgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0NjRcIlxuXG5leHRlcm5hbCBzd2FwMTYgOiBpbnQgLT4gaW50ID0gXCIlYnN3YXAxNlwiXG5leHRlcm5hbCBzd2FwMzIgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWJzd2FwX2ludDMyXCJcbmV4dGVybmFsIHN3YXA2NCA6IGludDY0IC0+IGludDY0ID0gXCIlYnN3YXBfaW50NjRcIlxuXG5cbmxldCBhZGRfaW50OCBiIHggPVxuICBsZXQgcG9zaXRpb24gPSBiLnBvc2l0aW9uIGluXG4gIGxldCB7bGVuZ3RoOyBidWZmZXJ9ID0gYi5pbm5lciBpblxuICBsZXQgbmV3X3Bvc2l0aW9uID0gcG9zaXRpb24gKyAxIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGxlbmd0aCB0aGVuIChcbiAgICByZXNpemUgYiAxO1xuICAgIHNldF9pbnQ4IGIuaW5uZXIuYnVmZmVyIGIucG9zaXRpb24geFxuICApIGVsc2VcbiAgICB1bnNhZmVfc2V0X2ludDggYnVmZmVyIHBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50MTZfbmUgYiB4ID1cbiAgbGV0IHBvc2l0aW9uID0gYi5wb3NpdGlvbiBpblxuICBsZXQge2xlbmd0aDsgYnVmZmVyfSA9IGIuaW5uZXIgaW5cbiAgbGV0IG5ld19wb3NpdGlvbiA9IHBvc2l0aW9uICsgMiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBsZW5ndGggdGhlbiAoXG4gICAgcmVzaXplIGIgMjtcbiAgICBzZXRfaW50MTYgYi5pbm5lci5idWZmZXIgYi5wb3NpdGlvbiB4XG4gICkgZWxzZVxuICAgIHVuc2FmZV9zZXRfaW50MTYgYnVmZmVyIHBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50MzJfbmUgYiB4ID1cbiAgbGV0IHBvc2l0aW9uID0gYi5wb3NpdGlvbiBpblxuICBsZXQge2xlbmd0aDsgYnVmZmVyfSA9IGIuaW5uZXIgaW5cbiAgbGV0IG5ld19wb3NpdGlvbiA9IHBvc2l0aW9uICsgNCBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBsZW5ndGggdGhlbiAoXG4gICAgcmVzaXplIGIgNDtcbiAgICBzZXRfaW50MzIgYi5pbm5lci5idWZmZXIgYi5wb3NpdGlvbiB4XG4gICkgZWxzZVxuICAgIHVuc2FmZV9zZXRfaW50MzIgYnVmZmVyIHBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50NjRfbmUgYiB4ID1cbiAgbGV0IHBvc2l0aW9uID0gYi5wb3NpdGlvbiBpblxuICBsZXQge2xlbmd0aDsgYnVmZmVyfSA9IGIuaW5uZXIgaW5cbiAgbGV0IG5ld19wb3NpdGlvbiA9IHBvc2l0aW9uICsgOCBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBsZW5ndGggdGhlbiAoXG4gICAgcmVzaXplIGIgODtcbiAgICBzZXRfaW50NjQgYi5pbm5lci5idWZmZXIgYi5wb3NpdGlvbiB4XG4gICkgZWxzZVxuICAgIHVuc2FmZV9zZXRfaW50NjQgYnVmZmVyIHBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50MTZfbGUgYiB4ID1cbiAgYWRkX2ludDE2X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDE2IHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDE2X2JlIGIgeCA9XG4gIGFkZF9pbnQxNl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwMTYgeClcblxubGV0IGFkZF9pbnQzMl9sZSBiIHggPVxuICBhZGRfaW50MzJfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMzIgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50MzJfYmUgYiB4ID1cbiAgYWRkX2ludDMyX25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXAzMiB4KVxuXG5sZXQgYWRkX2ludDY0X2xlIGIgeCA9XG4gIGFkZF9pbnQ2NF9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQ2NF9iZSBiIHggPVxuICBhZGRfaW50NjRfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDY0IHgpXG5cbmxldCBhZGRfdWludDggPSBhZGRfaW50OFxubGV0IGFkZF91aW50MTZfbmUgPSBhZGRfaW50MTZfbmVcbmxldCBhZGRfdWludDE2X2xlID0gYWRkX2ludDE2X2xlXG5sZXQgYWRkX3VpbnQxNl9iZSA9IGFkZF9pbnQxNl9iZVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgWGF2aWVyIExlcm95LCBDb2xsw6hnZSBkZSBGcmFuY2UgYW5kIElOUklBIFBhcmlzICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMjAgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCoqIFNlbWFwaG9yZXMgKilcblxudHlwZSBzZW0gPSB7XG4gIG11dDogTXV0ZXgudDsgICAgICAgICAgICAgICAgICAgICAgICAgKCogcHJvdGVjdHMgW3ZdICopXG4gIG11dGFibGUgdjogaW50OyAgICAgICAgICAgICAgICAgICAgICAgKCogdGhlIGN1cnJlbnQgdmFsdWUgKilcbiAgbm9uemVybzogQ29uZGl0aW9uLnQgICAgICAgICAgICAgICAgICAoKiBzaWduYWxlZCB3aGVuIFt2ID4gMF0gKilcbn1cblxubW9kdWxlIENvdW50aW5nID0gc3RydWN0XG5cbnR5cGUgdCA9IHNlbVxuXG5sZXQgbWFrZSB2ID1cbiAgaWYgdiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlbWFwaG9yZS5Db3VudGluZy5pbml0OiB3cm9uZyBpbml0aWFsIHZhbHVlXCI7XG4gIHsgbXV0ID0gTXV0ZXguY3JlYXRlKCk7IHY7IG5vbnplcm8gPSBDb25kaXRpb24uY3JlYXRlKCkgfVxuXG5sZXQgcmVsZWFzZSBzID1cbiAgTXV0ZXgubG9jayBzLm11dDtcbiAgaWYgcy52IDwgbWF4X2ludCB0aGVuIGJlZ2luXG4gICAgcy52IDwtIHMudiArIDE7XG4gICAgQ29uZGl0aW9uLnNpZ25hbCBzLm5vbnplcm87XG4gICAgTXV0ZXgudW5sb2NrIHMubXV0XG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgTXV0ZXgudW5sb2NrIHMubXV0O1xuICAgIHJhaXNlIChTeXNfZXJyb3IgXCJTZW1hcGhvcmUuQ291bnRpbmcucmVsZWFzZTogb3ZlcmZsb3dcIilcbiAgZW5kXG5cbmxldCBhY3F1aXJlIHMgPVxuICBNdXRleC5sb2NrIHMubXV0O1xuICB3aGlsZSBzLnYgPSAwIGRvIENvbmRpdGlvbi53YWl0IHMubm9uemVybyBzLm11dCBkb25lO1xuICBzLnYgPC0gcy52IC0gMTtcbiAgTXV0ZXgudW5sb2NrIHMubXV0XG5cbmxldCB0cnlfYWNxdWlyZSBzID1cbiAgTXV0ZXgubG9jayBzLm11dDtcbiAgbGV0IHJldCA9IGlmIHMudiA9IDAgdGhlbiBmYWxzZSBlbHNlIChzLnYgPC0gcy52IC0gMTsgdHJ1ZSkgaW5cbiAgTXV0ZXgudW5sb2NrIHMubXV0O1xuICByZXRcblxubGV0IGdldF92YWx1ZSBzID0gcy52XG5cbmVuZFxuXG5tb2R1bGUgQmluYXJ5ID0gc3RydWN0XG5cbnR5cGUgdCA9IHNlbVxuXG5sZXQgbWFrZSBiID1cbiAgeyBtdXQgPSBNdXRleC5jcmVhdGUoKTtcbiAgICB2ID0gaWYgYiB0aGVuIDEgZWxzZSAwO1xuICAgIG5vbnplcm8gPSBDb25kaXRpb24uY3JlYXRlKCkgfVxuXG5sZXQgcmVsZWFzZSBzID1cbiAgTXV0ZXgubG9jayBzLm11dDtcbiAgcy52IDwtIDE7XG4gIENvbmRpdGlvbi5zaWduYWwgcy5ub256ZXJvO1xuICBNdXRleC51bmxvY2sgcy5tdXRcblxubGV0IGFjcXVpcmUgcyA9XG4gIE11dGV4LmxvY2sgcy5tdXQ7XG4gIHdoaWxlIHMudiA9IDAgZG8gQ29uZGl0aW9uLndhaXQgcy5ub256ZXJvIHMubXV0IGRvbmU7XG4gIHMudiA8LSAwO1xuICBNdXRleC51bmxvY2sgcy5tdXRcblxubGV0IHRyeV9hY3F1aXJlIHMgPVxuICBNdXRleC5sb2NrIHMubXV0O1xuICBsZXQgcmV0ID0gaWYgcy52ID0gMCB0aGVuIGZhbHNlIGVsc2UgKHMudiA8LSAwOyB0cnVlKSBpblxuICBNdXRleC51bmxvY2sgcy5tdXQ7XG4gIHJldFxuXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgS0MgU2l2YXJhbWFrcmlzaG5hbiwgSW5kaWFuIEluc3RpdHV0ZSBvZiBUZWNobm9sb2d5LCBNYWRyYXMgICAgICAgKilcbigqICAgICAgICAgICAgICAgICBTdGVwaGVuIERvbGFuLCBVbml2ZXJzaXR5IG9mIENhbWJyaWRnZSAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgIFRvbSBLZWxseSwgT0NhbWwgTGFicyBDb25zdWx0YW5jeSAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTkgSW5kaWFuIEluc3RpdHV0ZSBvZiBUZWNobm9sb2d5LCBNYWRyYXMgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgVW5pdmVyc2l0eSBvZiBDYW1icmlkZ2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMjEgT0NhbWwgTGFicyBDb25zdWx0YW5jeSBMdGQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIFJhdyA9IHN0cnVjdFxuICAoKiBMb3ctbGV2ZWwgcHJpbWl0aXZlcyBwcm92aWRlZCBieSB0aGUgcnVudGltZSAqKVxuICB0eXBlIHQgPSBwcml2YXRlIGludFxuICBleHRlcm5hbCBzcGF3biA6ICh1bml0IC0+IHVuaXQpIC0+IE11dGV4LnQgLT4gdFxuICAgID0gXCJjYW1sX2RvbWFpbl9zcGF3blwiXG4gIGV4dGVybmFsIHNlbGYgOiB1bml0IC0+IHRcbiAgICA9IFwiY2FtbF9tbF9kb21haW5faWRcIlxuICBleHRlcm5hbCBjcHVfcmVsYXggOiB1bml0IC0+IHVuaXRcbiAgICA9IFwiY2FtbF9tbF9kb21haW5fY3B1X3JlbGF4XCJcbiAgZXh0ZXJuYWwgZ2V0X3JlY29tbWVuZGVkX2RvbWFpbl9jb3VudDogdW5pdCAtPiBpbnRcbiAgICA9IFwiY2FtbF9yZWNvbW1lbmRlZF9kb21haW5fY291bnRcIiBbQEBub2FsbG9jXVxuZW5kXG5cbmxldCBjcHVfcmVsYXggKCkgPSBSYXcuY3B1X3JlbGF4ICgpXG5cbnR5cGUgaWQgPSBSYXcudFxuXG50eXBlICdhIHN0YXRlID1cbnwgUnVubmluZ1xufCBGaW5pc2hlZCBvZiAoJ2EsIGV4bikgcmVzdWx0XG5cbnR5cGUgJ2EgdCA9IHtcbiAgZG9tYWluIDogUmF3LnQ7XG4gIHRlcm1fbXV0ZXg6IE11dGV4LnQ7XG4gIHRlcm1fY29uZGl0aW9uOiBDb25kaXRpb24udDtcbiAgdGVybV9zdGF0ZTogJ2Egc3RhdGUgcmVmICgqIHByb3RlY3RlZCBieSBbdGVybV9tdXRleF0gKilcbn1cblxubW9kdWxlIERMUyA9IHN0cnVjdFxuXG4gIHR5cGUgZGxzX3N0YXRlID0gT2JqLnQgYXJyYXlcblxuICBsZXQgdW5pcXVlX3ZhbHVlID0gT2JqLnJlcHIgKHJlZiAwKVxuXG4gIGV4dGVybmFsIGdldF9kbHNfc3RhdGUgOiB1bml0IC0+IGRsc19zdGF0ZSA9IFwiJWRsc19nZXRcIlxuXG4gIGV4dGVybmFsIHNldF9kbHNfc3RhdGUgOiBkbHNfc3RhdGUgLT4gdW5pdCA9XG4gICAgXCJjYW1sX2RvbWFpbl9kbHNfc2V0XCIgW0BAbm9hbGxvY11cblxuICBsZXQgY3JlYXRlX2RscyAoKSA9XG4gICAgbGV0IHN0ID0gQXJyYXkubWFrZSA4IHVuaXF1ZV92YWx1ZSBpblxuICAgIHNldF9kbHNfc3RhdGUgc3RcblxuICBsZXQgXyA9IGNyZWF0ZV9kbHMgKClcblxuICB0eXBlICdhIGtleSA9IGludCAqICh1bml0IC0+ICdhKVxuXG4gIGxldCBrZXlfY291bnRlciA9IEF0b21pYy5tYWtlIDBcblxuICB0eXBlIGtleV9pbml0aWFsaXplciA9XG4gICAgS0k6ICdhIGtleSAqICgnYSAtPiAnYSkgLT4ga2V5X2luaXRpYWxpemVyXG5cbiAgbGV0IHBhcmVudF9rZXlzID0gQXRvbWljLm1ha2UgKFtdIDoga2V5X2luaXRpYWxpemVyIGxpc3QpXG5cbiAgbGV0IHJlYyBhZGRfcGFyZW50X2tleSBraSA9XG4gICAgbGV0IGwgPSBBdG9taWMuZ2V0IHBhcmVudF9rZXlzIGluXG4gICAgaWYgbm90IChBdG9taWMuY29tcGFyZV9hbmRfc2V0IHBhcmVudF9rZXlzIGwgKGtpIDo6IGwpKVxuICAgIHRoZW4gYWRkX3BhcmVudF9rZXkga2lcblxuICBsZXQgbmV3X2tleSA/c3BsaXRfZnJvbV9wYXJlbnQgaW5pdF9vcnBoYW4gPVxuICAgIGxldCBpZHggPSBBdG9taWMuZmV0Y2hfYW5kX2FkZCBrZXlfY291bnRlciAxIGluXG4gICAgbGV0IGsgPSAoaWR4LCBpbml0X29ycGhhbikgaW5cbiAgICBiZWdpbiBtYXRjaCBzcGxpdF9mcm9tX3BhcmVudCB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIHNwbGl0IC0+IGFkZF9wYXJlbnRfa2V5IChLSShrLCBzcGxpdCkpXG4gICAgZW5kO1xuICAgIGtcblxuICAoKiBJZiBuZWNlc3NhcnksIGdyb3cgdGhlIGN1cnJlbnQgZG9tYWluJ3MgbG9jYWwgc3RhdGUgYXJyYXkgc3VjaCB0aGF0IFtpZHhdXG4gICAqIGlzIGEgdmFsaWQgaW5kZXggaW4gdGhlIGFycmF5LiAqKVxuICBsZXQgbWF5YmVfZ3JvdyBpZHggPVxuICAgIGxldCBzdCA9IGdldF9kbHNfc3RhdGUgKCkgaW5cbiAgICBsZXQgc3ogPSBBcnJheS5sZW5ndGggc3QgaW5cbiAgICBpZiBpZHggPCBzeiB0aGVuIHN0XG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHJlYyBjb21wdXRlX25ld19zaXplIHMgPVxuICAgICAgICBpZiBpZHggPCBzIHRoZW4gcyBlbHNlIGNvbXB1dGVfbmV3X3NpemUgKDIgKiBzKVxuICAgICAgaW5cbiAgICAgIGxldCBuZXdfc3ogPSBjb21wdXRlX25ld19zaXplIHN6IGluXG4gICAgICBsZXQgbmV3X3N0ID0gQXJyYXkubWFrZSBuZXdfc3ogdW5pcXVlX3ZhbHVlIGluXG4gICAgICBBcnJheS5ibGl0IHN0IDAgbmV3X3N0IDAgc3o7XG4gICAgICBzZXRfZGxzX3N0YXRlIG5ld19zdDtcbiAgICAgIG5ld19zdFxuICAgIGVuZFxuXG4gIGxldCBzZXQgKGlkeCwgX2luaXQpIHggPVxuICAgIGxldCBzdCA9IG1heWJlX2dyb3cgaWR4IGluXG4gICAgKCogW1N5cy5vcGFxdWVfaWRlbnRpdHldIGVuc3VyZXMgdGhhdCBmbGFtYmRhIGRvZXMgbm90IGxvb2sgYXQgdGhlIHR5cGUgb2ZcbiAgICAgKiBbeF0sIHdoaWNoIG1heSBiZSBhIFtmbG9hdF0gYW5kIGNvbmNsdWRlIHRoYXQgdGhlIFtzdF0gaXMgYSBmbG9hdCBhcnJheS5cbiAgICAgKiBXZSBkbyBub3Qgd2FudCBPQ2FtbCdzIGZsb2F0IGFycmF5IG9wdGltaXNhdGlvbiBraWNraW5nIGluIGhlcmUuICopXG4gICAgc3QuKGlkeCkgPC0gT2JqLnJlcHIgKFN5cy5vcGFxdWVfaWRlbnRpdHkgeClcblxuICBsZXQgZ2V0IChpZHgsIGluaXQpID1cbiAgICBsZXQgc3QgPSBtYXliZV9ncm93IGlkeCBpblxuICAgIGxldCB2ID0gc3QuKGlkeCkgaW5cbiAgICBpZiB2ID09IHVuaXF1ZV92YWx1ZSB0aGVuXG4gICAgICBsZXQgdicgPSBPYmoucmVwciAoaW5pdCAoKSkgaW5cbiAgICAgIHN0LihpZHgpIDwtIChTeXMub3BhcXVlX2lkZW50aXR5IHYnKTtcbiAgICAgIE9iai5tYWdpYyB2J1xuICAgIGVsc2UgT2JqLm1hZ2ljIHZcblxuICBsZXQgZ2V0X2luaXRpYWxfa2V5cyAoKSA6IChpbnQgKiBPYmoudCkgbGlzdCA9XG4gICAgTGlzdC5tYXBcbiAgICAgIChmdW4gKEtJICgoaWR4LCBfKSBhcyBrLCBzcGxpdCkpIC0+XG4gICAgICAgICAgIChpZHgsIE9iai5yZXByIChzcGxpdCAoZ2V0IGspKSkpXG4gICAgICAoQXRvbWljLmdldCBwYXJlbnRfa2V5cylcblxuICBsZXQgc2V0X2luaXRpYWxfa2V5cyAobDogKGludCAqIE9iai50KSBsaXN0KSA9XG4gICAgTGlzdC5pdGVyXG4gICAgICAoZnVuIChpZHgsIHYpIC0+XG4gICAgICAgIGxldCBzdCA9IG1heWJlX2dyb3cgaWR4IGluIHN0LihpZHgpIDwtIHYpXG4gICAgICBsXG5cbmVuZFxuXG4oKioqKioqKiogSWRlbnRpdHkgKioqKioqKioqKilcblxubGV0IGdldF9pZCB7IGRvbWFpbjsgXyB9ID0gZG9tYWluXG5cbmxldCBzZWxmICgpID0gUmF3LnNlbGYgKClcblxubGV0IGlzX21haW5fZG9tYWluICgpID0gKHNlbGYgKCkgOj4gaW50KSA9IDBcblxuKCoqKioqKioqIENhbGxiYWNrcyAqKioqKioqKioqKVxuXG4oKiBmaXJzdCBzcGF3biwgZG9tYWluIHN0YXJ0dXAgYW5kIGF0IGV4aXQgZnVuY3Rpb25hbGl0eSAqKVxubGV0IGZpcnN0X2RvbWFpbl9zcGF3bmVkID0gQXRvbWljLm1ha2UgZmFsc2VcblxubGV0IGZpcnN0X3NwYXduX2Z1bmN0aW9uID0gcmVmIChmdW4gKCkgLT4gKCkpXG5cbmxldCBiZWZvcmVfZmlyc3Rfc3Bhd24gZiA9XG4gIGlmIEF0b21pYy5nZXQgZmlyc3RfZG9tYWluX3NwYXduZWQgdGhlblxuICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiZmlyc3QgZG9tYWluIGFscmVhZHkgc3Bhd25lZFwiKVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IG9sZF9mID0gIWZpcnN0X3NwYXduX2Z1bmN0aW9uIGluXG4gICAgbGV0IG5ld19mICgpID0gb2xkX2YgKCk7IGYgKCkgaW5cbiAgICBmaXJzdF9zcGF3bl9mdW5jdGlvbiA6PSBuZXdfZlxuICBlbmRcblxubGV0IGRvX2JlZm9yZV9maXJzdF9zcGF3biAoKSA9XG4gIGlmIG5vdCAoQXRvbWljLmdldCBmaXJzdF9kb21haW5fc3Bhd25lZCkgdGhlbiBiZWdpblxuICAgIEF0b21pYy5zZXQgZmlyc3RfZG9tYWluX3NwYXduZWQgdHJ1ZTtcbiAgICAhZmlyc3Rfc3Bhd25fZnVuY3Rpb24oKTtcbiAgICAoKiBSZWxlYXNlIHRoZSBvbGQgZnVuY3Rpb24gKilcbiAgICBmaXJzdF9zcGF3bl9mdW5jdGlvbiA6PSAoZnVuICgpIC0+ICgpKVxuICBlbmRcblxubGV0IGF0X2V4aXRfa2V5ID0gRExTLm5ld19rZXkgKGZ1biAoKSAtPiAoZnVuICgpIC0+ICgpKSlcblxubGV0IGF0X2V4aXQgZiA9XG4gIGxldCBvbGRfZXhpdCA6IHVuaXQgLT4gdW5pdCA9IERMUy5nZXQgYXRfZXhpdF9rZXkgaW5cbiAgbGV0IG5ld19leGl0ICgpID1cbiAgICAoKiBUaGUgZG9tYWluIHRlcm1pbmF0aW9uIGNhbGxiYWNrcyAoW2F0X2V4aXRdKSBhcmUgcnVuIGluXG4gICAgICAgbGFzdC1pbi1maXJzdC1vdXQgKExJRk8pIG9yZGVyIGluIG9yZGVyIHRvIGJlIHN5bW1ldHJpYyB3aXRoIHRoZSBkb21haW5cbiAgICAgICBjcmVhdGlvbiBjYWxsYmFja3MgKFthdF9lYWNoX3NwYXduXSkgd2hpY2ggcnVuIGluIGZpcnN0LWluLWZpc3J0LW91dFxuICAgICAgIChGSUZPKSBvcmRlci4gKilcbiAgICBmICgpOyBvbGRfZXhpdCAoKVxuICBpblxuICBETFMuc2V0IGF0X2V4aXRfa2V5IG5ld19leGl0XG5cbmxldCBkb19hdF9leGl0ICgpID1cbiAgbGV0IGYgOiB1bml0IC0+IHVuaXQgPSBETFMuZ2V0IGF0X2V4aXRfa2V5IGluXG4gIGYgKClcblxubGV0IF8gPSBTdGRsaWIuZG9fZG9tYWluX2xvY2FsX2F0X2V4aXQgOj0gZG9fYXRfZXhpdFxuXG4oKioqKioqKiBDcmVhdGlvbiBhbmQgVGVybWluYXRpb24gKioqKioqKiopXG5cbmxldCBzcGF3biBmID1cbiAgZG9fYmVmb3JlX2ZpcnN0X3NwYXduICgpO1xuICBsZXQgcGsgPSBETFMuZ2V0X2luaXRpYWxfa2V5cyAoKSBpblxuXG4gICgqIFRoZSBbdGVybV9tdXRleF0gYW5kIFt0ZXJtX2NvbmRpdGlvbl0gYXJlIHVzZWQgdG9cbiAgICAgc3luY2hyb25pemUgd2l0aCB0aGUgam9pbmluZyBkb21haW5zICopXG4gIGxldCB0ZXJtX211dGV4ID0gTXV0ZXguY3JlYXRlICgpIGluXG4gIGxldCB0ZXJtX2NvbmRpdGlvbiA9IENvbmRpdGlvbi5jcmVhdGUgKCkgaW5cbiAgbGV0IHRlcm1fc3RhdGUgPSByZWYgUnVubmluZyBpblxuXG4gIGxldCBib2R5ICgpID1cbiAgICBsZXQgcmVzdWx0ID1cbiAgICAgIG1hdGNoXG4gICAgICAgIERMUy5jcmVhdGVfZGxzICgpO1xuICAgICAgICBETFMuc2V0X2luaXRpYWxfa2V5cyBwaztcbiAgICAgICAgbGV0IHJlcyA9IGYgKCkgaW5cbiAgICAgICAgcmVzXG4gICAgICB3aXRoXG4gICAgICB8IHggLT4gT2sgeFxuICAgICAgfCBleGNlcHRpb24gZXggLT4gRXJyb3IgZXhcbiAgICBpblxuXG4gICAgbGV0IHJlc3VsdCcgPVxuICAgICAgKCogUnVuIHRoZSBbYXRfZXhpdF0gY2FsbGJhY2tzIHdoZW4gdGhlIGRvbWFpbiBjb21wdXRhdGlvbiBlaXRoZXJcbiAgICAgICAgIHRlcm1pbmF0ZXMgbm9ybWFsbHkgb3IgZXhjZXB0aW9uYWxseS4gKilcbiAgICAgIG1hdGNoIGRvX2F0X2V4aXQgKCkgd2l0aFxuICAgICAgfCAoKSAtPiByZXN1bHRcbiAgICAgIHwgZXhjZXB0aW9uIGV4IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgICB8IE9rIF8gLT5cbiAgICAgICAgICAgICAgKCogSWYgdGhlIGRvbWFpbiBjb21wdXRhdGlvbiB0ZXJtaW5hdGVkIG5vcm1hbGx5LCBidXQgdGhlXG4gICAgICAgICAgICAgICAgIFthdF9leGl0XSBjYWxsYmFja3MgcmFpc2VkIGFuIGV4Y2VwdGlvbiwgdGhlbiByZXR1cm4gdGhlXG4gICAgICAgICAgICAgICAgIGV4Y2VwdGlvbi4gKilcbiAgICAgICAgICAgICAgRXJyb3IgZXhcbiAgICAgICAgICB8IEVycm9yIF8gLT5cbiAgICAgICAgICAgICAgKCogSWYgYm90aCB0aGUgZG9tYWluIGNvbXB1dGF0aW9uIGFuZCB0aGUgW2F0X2V4aXRdIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgICByYWlzZWQgZXhjZXB0aW9ucywgdGhlbiBpZ25vcmUgdGhlIGV4Y2VwdGlvbiBmcm9tIHRoZVxuICAgICAgICAgICAgICAgICBbYXRfZXhpdF0gY2FsbGJhY2tzIGFuZCByZXR1cm4gdGhlIG9yaWdpbmFsIGV4Y2VwdGlvbi4gKilcbiAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgZW5kXG4gICAgaW5cblxuICAgICgqIFN5bmNocm9uaXplIHdpdGggam9pbmluZyBkb21haW5zICopXG4gICAgTXV0ZXgubG9jayB0ZXJtX211dGV4O1xuICAgIG1hdGNoICF0ZXJtX3N0YXRlIHdpdGhcbiAgICB8IFJ1bm5pbmcgLT5cbiAgICAgICAgdGVybV9zdGF0ZSA6PSBGaW5pc2hlZCByZXN1bHQnO1xuICAgICAgICBDb25kaXRpb24uYnJvYWRjYXN0IHRlcm1fY29uZGl0aW9uO1xuICAgIHwgRmluaXNoZWQgXyAtPlxuICAgICAgICBmYWlsd2l0aCBcImludGVybmFsIGVycm9yOiBBbSBJIGFscmVhZHkgZmluaXNoZWQ/XCJcbiAgICAoKiBbdGVybV9tdXRleF0gaXMgdW5sb2NrZWQgaW4gdGhlIHJ1bnRpbWUgYWZ0ZXIgdGhlIGNsZWFudXAgZnVuY3Rpb25zIG9uXG4gICAgICAgdGhlIEMgc2lkZSBhcmUgZmluaXNoZWQuICopXG4gIGluXG4gIHsgZG9tYWluID0gUmF3LnNwYXduIGJvZHkgdGVybV9tdXRleDtcbiAgICB0ZXJtX211dGV4O1xuICAgIHRlcm1fY29uZGl0aW9uO1xuICAgIHRlcm1fc3RhdGUgfVxuXG5sZXQgam9pbiB7IHRlcm1fbXV0ZXg7IHRlcm1fY29uZGl0aW9uOyB0ZXJtX3N0YXRlOyBfIH0gPVxuICBNdXRleC5sb2NrIHRlcm1fbXV0ZXg7XG4gIGxldCByZWMgbG9vcCAoKSA9XG4gICAgbWF0Y2ggIXRlcm1fc3RhdGUgd2l0aFxuICAgIHwgUnVubmluZyAtPlxuICAgICAgICBDb25kaXRpb24ud2FpdCB0ZXJtX2NvbmRpdGlvbiB0ZXJtX211dGV4O1xuICAgICAgICBsb29wICgpXG4gICAgfCBGaW5pc2hlZCByZXMgLT5cbiAgICAgICAgTXV0ZXgudW5sb2NrIHRlcm1fbXV0ZXg7XG4gICAgICAgIHJlc1xuICBpblxuICBtYXRjaCBsb29wICgpIHdpdGhcbiAgfCBPayB4IC0+IHhcbiAgfCBFcnJvciBleCAtPiByYWlzZSBleFxuXG5sZXQgcmVjb21tZW5kZWRfZG9tYWluX2NvdW50ID0gUmF3LmdldF9yZWNvbW1lbmRlZF9kb21haW5fY291bnRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICBCZW5vaXQgVmF1Z29uLCBFTlNUQSAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3NcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgKCogVG9vbHMgdG8gbWFuaXB1bGF0ZSBzY2FubmluZyBzZXQgb2YgY2hhcnMgKHNlZSAlWy4uLl0pICopXG5cbnR5cGUgbXV0YWJsZV9jaGFyX3NldCA9IGJ5dGVzXG5cbigqIENyZWF0ZSBhIGZyZXNoLCBlbXB0eSwgbXV0YWJsZSBjaGFyIHNldC4gKilcbmxldCBjcmVhdGVfY2hhcl9zZXQgKCkgPSBCeXRlcy5tYWtlIDMyICdcXDAwMCdcblxuKCogQWRkIGEgY2hhciBpbiBhIG11dGFibGUgY2hhciBzZXQuICopXG5sZXQgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgPVxuICBsZXQgaW5kID0gaW50X29mX2NoYXIgYyBpblxuICBsZXQgc3RyX2luZCA9IGluZCBsc3IgMyBhbmQgbWFzayA9IDEgbHNsIChpbmQgbGFuZCAwYjExMSkgaW5cbiAgQnl0ZXMuc2V0IGNoYXJfc2V0IHN0cl9pbmRcbiAgICAoY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIChCeXRlcy5nZXQgY2hhcl9zZXQgc3RyX2luZCkgbG9yIG1hc2spKVxuXG5sZXQgZnJlZXplX2NoYXJfc2V0IGNoYXJfc2V0ID1cbiAgQnl0ZXMudG9fc3RyaW5nIGNoYXJfc2V0XG5cbigqIENvbXB1dGUgdGhlIGNvbXBsZW1lbnQgb2YgYSBjaGFyIHNldC4gKilcbmxldCByZXZfY2hhcl9zZXQgY2hhcl9zZXQgPVxuICBsZXQgY2hhcl9zZXQnID0gY3JlYXRlX2NoYXJfc2V0ICgpIGluXG4gIGZvciBpID0gMCB0byAzMSBkb1xuICAgIEJ5dGVzLnNldCBjaGFyX3NldCcgaVxuICAgICAgKGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciAoU3RyaW5nLmdldCBjaGFyX3NldCBpKSBseG9yIDB4RkYpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBjaGFyX3NldCdcblxuKCogUmV0dXJuIHRydWUgaWYgYSBgYycgaXMgaW4gYGNoYXJfc2V0Jy4gKilcbmxldCBpc19pbl9jaGFyX3NldCBjaGFyX3NldCBjID1cbiAgbGV0IGluZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgbGV0IHN0cl9pbmQgPSBpbmQgbHNyIDMgYW5kIG1hc2sgPSAxIGxzbCAoaW5kIGxhbmQgMGIxMTEpIGluXG4gIChpbnRfb2ZfY2hhciAoU3RyaW5nLmdldCBjaGFyX3NldCBzdHJfaW5kKSBsYW5kIG1hc2spIDw+IDBcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICgqIElnbm9yZWQgcGFyYW0gY29udmVyc2lvbiAqKVxuXG4oKiBHQURUIHVzZWQgdG8gYWJzdHJhY3QgYW4gZXhpc3RlbnRpYWwgdHlwZSBwYXJhbWV0ZXIuICopXG4oKiBTZWUgcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0LiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFyYW1fZm9ybWF0X2ViYiA9IFBhcmFtX2Zvcm1hdF9FQkIgOlxuICAgICgneCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFyYW1fZm9ybWF0X2ViYlxuXG4oKiBDb21wdXRlIGEgcGFkZGluZyBhc3NvY2lhdGVkIHRvIGEgcGFkX29wdGlvbiAoc2VlIFwiJV80MmRcIikuICopXG5sZXQgcGFkX29mX3BhZF9vcHQgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gTm9fcGFkZGluZ1xuICB8IFNvbWUgd2lkdGggLT4gTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aClcblxuKCogQ29tcHV0ZSBhIHByZWNpc2lvbiBhc3NvY2lhdGVkIHRvIGEgcHJlY19vcHRpb24gKHNlZSBcIiVfLjQyZlwiKS4gKilcbmxldCBwcmVjX29mX3ByZWNfb3B0IHByZWNfb3B0ID0gbWF0Y2ggcHJlY19vcHQgd2l0aFxuICB8IE5vbmUgLT4gTm9fcHJlY2lzaW9uXG4gIHwgU29tZSBuZGVjIC0+IExpdF9wcmVjaXNpb24gbmRlY1xuXG4oKiBUdXJuIGFuIGlnbm9yZWQgcGFyYW0gaW50byBpdHMgZXF1aXZhbGVudCBub3QtaWdub3JlZCBmb3JtYXQgbm9kZS4gKilcbigqIFVzZWQgZm9yIGZvcm1hdCBwcmV0dHktcHJpbnRpbmcgYW5kIFNjYW5mLiAqKVxubGV0IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IC5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPiAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+XG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFyYW1fZm9ybWF0X2ViYiA9XG5mdW4gaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENoYXIgZm10KVxuICB8IElnbm9yZWRfY2FtbF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2FtbF9jaGFyIGZtdClcbiAgfCBJZ25vcmVkX3N0cmluZyBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU3RyaW5nIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENhbWxfc3RyaW5nIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfaW50IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChJbnQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQzMiAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEludDMyIChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfbmF0aXZlaW50IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoTmF0aXZlaW50IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfaW50NjQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChJbnQ2NCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2Zsb2F0IChwYWRfb3B0LCBwcmVjX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoRmxvYXQgKChGbG9hdF9mbGFnXywgRmxvYXRfZiksXG4gICAgICAgICAgICAgIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIHByZWNfb2ZfcHJlY19vcHQgcHJlY19vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9ib29sIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChCb29sIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHkpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIGZtdCkpXG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCBmbXQpKVxuICB8IElnbm9yZWRfcmVhZGVyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoUmVhZGVyIGZtdClcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10KSlcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdCkpXG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fbmV4dF9jaGFyIGZtdClcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVHlwZXMgKilcblxudHlwZSAoJ2IsICdjKSBhY2NfZm9ybWF0dGluZ19nZW4gPVxuICB8IEFjY19vcGVuX3RhZyBvZiAoJ2IsICdjKSBhY2NcbiAgfCBBY2Nfb3Blbl9ib3ggb2YgKCdiLCAnYykgYWNjXG5cbigqIFJldmVyc2VkIGxpc3Qgb2YgcHJpbnRpbmcgYXRvbXMuICopXG4oKiBVc2VkIHRvIGFjY3VtdWxhdGUgcHJpbnRmIGFyZ3VtZW50cy4gKilcbmFuZCAoJ2IsICdjKSBhY2MgPVxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCBvZiAoJ2IsICdjKSBhY2MgKiBmb3JtYXR0aW5nX2xpdFxuICAgICAgKCogU3BlY2lhbCBmbXR0aW5nIChib3gpICopXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIG9mICgnYiwgJ2MpIGFjYyAqICgnYiwgJ2MpIGFjY19mb3JtYXR0aW5nX2dlblxuICAgICAgKCogU3BlY2lhbCBmbXR0aW5nIChib3gpICopXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZyAgICAgKCogTGl0ZXJhbCBzdHJpbmcgKilcbiAgfCBBY2NfY2hhcl9saXRlcmFsICAgb2YgKCdiLCAnYykgYWNjICogY2hhciAgICAgICAoKiBMaXRlcmFsIGNoYXIgKilcbiAgfCBBY2NfZGF0YV9zdHJpbmcgICAgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nICAgICAoKiBHZW5lcmF0ZWQgc3RyaW5nICopXG4gIHwgQWNjX2RhdGFfY2hhciAgICAgIG9mICgnYiwgJ2MpIGFjYyAqIGNoYXIgICAgICAgKCogR2VuZXJhdGVkIGNoYXIgKilcbiAgfCBBY2NfZGVsYXkgICAgICAgICAgb2YgKCdiLCAnYykgYWNjICogKCdiIC0+ICdjKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRGVsYXllZCBwcmludGluZyAoJWEsICV0KSAqKVxuICB8IEFjY19mbHVzaCAgICAgICAgICBvZiAoJ2IsICdjKSBhY2MgICAgICAgICAgICAgICgqIEZsdXNoICopXG4gIHwgQWNjX2ludmFsaWRfYXJnICAgIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZ1xuICAgICAgKCogUmFpc2UgSW52YWxpZF9hcmd1bWVudCBtc2cgKilcbiAgfCBFbmRfb2ZfYWNjXG5cbigqIExpc3Qgb2YgaGV0ZXJvZ2VuZW91cyB2YWx1ZXMuICopXG4oKiBVc2VkIHRvIGFjY3VtdWxhdGUgc2NhbmYgY2FsbGJhY2sgYXJndW1lbnRzLiAqKVxudHlwZSAoJ2EsICdiKSBoZXRlcl9saXN0ID1cbiAgfCBDb25zIDogJ2MgKiAoJ2EsICdiKSBoZXRlcl9saXN0IC0+ICgnYyAtPiAnYSwgJ2IpIGhldGVyX2xpc3RcbiAgfCBOaWwgOiAoJ2IsICdiKSBoZXRlcl9saXN0XG5cbigqIEV4aXN0ZW50aWFsIEJsYWNrIEJveGVzLiAqKVxuKCogVXNlZCB0byBhYnN0cmFjdCBzb21lIGV4aXN0ZW50aWFsIHR5cGUgcGFyYW1ldGVycy4gKilcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZyBhbmQgYW4gZm10dHkuICopXG4oKiBTZWUgdGhlIHR5cGVfcGFkZGluZyBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZGRpbmdfZm10dHlfZWJiID0gUGFkZGluZ19mbXR0eV9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRkaW5nX2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYW4gZm10dHkuICopXG4oKiBTZWUgdGhlIHR5cGVfcGFkcHJlYyBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZHByZWNfZm10dHlfZWJiID0gUGFkcHJlY19mbXR0eV9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAneikgcHJlY2lzaW9uICogKCd6LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRwcmVjX2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZSwgJ2YpIHBhZGRpbmdfZm10X2ViYiA9IFBhZGRpbmdfZm10X0VCQiA6XG4gICAgIChfLCAneCAtPiAnYSkgcGFkZGluZyAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdlLCAnZikgcGFkZGluZ19mbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHByZWNpc2lvbiBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZSwgJ2YpIHByZWNpc2lvbl9mbXRfZWJiID0gUHJlY2lzaW9uX2ZtdF9FQkIgOlxuICAgICAoXywgJ3ggLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdlLCAnZikgcHJlY2lzaW9uX2ZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3BhZHByZWNfZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdwLCAnYiwgJ2MsICdlLCAnZikgcGFkcHJlY19mbXRfZWJiID0gUGFkcHJlY19mbXRfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ3AgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCdwLCAnYiwgJ2MsICdlLCAnZikgcGFkcHJlY19mbXRfZWJiXG5cbigqIEFic3RyYWN0IHRoZSAnYSBhbmQgJ2QgcGFyYW1ldGVycyBvZiBhbiBmbXQuICopXG4oKiBPdXRwdXQgdHlwZSBvZiB0aGUgZm9ybWF0IHBhcnNpbmcgZnVuY3Rpb24uICopXG50eXBlICgnYiwgJ2MsICdlLCAnZikgZm10X2ViYiA9IEZtdF9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgnYiwgJ2MsICdlLCAnZikgZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYW4gZm10dHkgYW5kIGFuIGZtdC4gKilcbigqIFNlZSB0aGUgdHlwZV9mb3JtYXRfZ2VuIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10X2ZtdHR5X2ViYiA9IEZtdF9mbXR0eV9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgZm10ICpcbiAgICAgKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhbiBmbXR0eSBhbmQgYW4gZm10LiAqKVxuKCogU2VlIHRoZSB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X2ZtdF9lYmIgPSBGbXR0eV9mbXRfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGZtdHR5ICpcbiAgICAgKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmIgLT5cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X2ZtdF9lYmJcblxuKCogQWJzdHJhY3QgYWxsIGZtdHR5IHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBmb3JtYXQgdHlwZXMuICopXG50eXBlIGZtdHR5X2ViYiA9IEZtdHR5X0VCQiA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPiBmbXR0eV9lYmJcblxuKCogQWJzdHJhY3QgYWxsIHBhZGRpbmcgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIHBhZGRpbmdzLiAqKVxudHlwZSBwYWRkaW5nX2ViYiA9IFBhZGRpbmdfRUJCIDogKCdhLCAnYikgcGFkZGluZyAtPiBwYWRkaW5nX2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgcHJlY2lzaW9uIHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBwcmVjaXNpb25zLiAqKVxudHlwZSBwcmVjaXNpb25fZWJiID0gUHJlY2lzaW9uX0VCQiA6ICgnYSwgJ2IpIHByZWNpc2lvbiAtPiBwcmVjaXNpb25fZWJiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQ29uc3RhbnRzICopXG5cbigqIERlZmF1bHQgcHJlY2lzaW9uIGZvciBmbG9hdCBwcmludGluZy4gKilcbmxldCBkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udiA9XG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0cgfCBGbG9hdF9oIHwgRmxvYXRfSFxuICB8IEZsb2F0X0NGIC0+IC02XG4gICgqIEZvciAlaCAlSCBhbmQgJSNGIGZvcm1hdHMsIGEgbmVnYXRpdmUgcHJlY2lzaW9uIG1lYW5zIFwiYXMgbWFueSBkaWdpdHMgYXNcbiAgICAgbmVjZXNzYXJ5XCIuICBGb3IgdGhlIG90aGVyIEZQIGZvcm1hdHMsIHdlIHRha2UgdGhlIGFic29sdXRlIHZhbHVlXG4gICAgIG9mIHRoZSBwcmVjaXNpb24sIGhlbmNlIDYgZGlnaXRzIGJ5IGRlZmF1bHQuICopXG4gIHwgRmxvYXRfRiAtPiAxMlxuICAoKiBEZWZhdWx0IHByZWNpc2lvbiBmb3IgT0NhbWwgZmxvYXQgcHJpbnRpbmcgKCVGKS4gKilcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBFeHRlcm5hbHMgKilcblxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0OiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5leHRlcm5hbCBmb3JtYXRfaW50OiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQzMjogc3RyaW5nIC0+IGludDMyIC0+IHN0cmluZ1xuICA9IFwiY2FtbF9pbnQzMl9mb3JtYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X25hdGl2ZWludDogc3RyaW5nIC0+IG5hdGl2ZWludCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfbmF0aXZlaW50X2Zvcm1hdFwiXG5leHRlcm5hbCBmb3JtYXRfaW50NjQ6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmV4dGVybmFsIGhleHN0cmluZ19vZl9mbG9hdDogZmxvYXQgLT4gaW50IC0+IGNoYXIgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2hleHN0cmluZ19vZl9mbG9hdFwiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAoKiBUb29scyB0byBwcmV0dHktcHJpbnQgZm9ybWF0cyAqKVxuXG4oKiBUeXBlIG9mIGV4dGVuc2libGUgY2hhcmFjdGVyIGJ1ZmZlcnMuICopXG50eXBlIGJ1ZmZlciA9IHtcbiAgbXV0YWJsZSBpbmQgOiBpbnQ7XG4gIG11dGFibGUgYnl0ZXMgOiBieXRlcztcbn1cblxuKCogQ3JlYXRlIGEgZnJlc2ggYnVmZmVyLiAqKVxubGV0IGJ1ZmZlcl9jcmVhdGUgaW5pdF9zaXplID0geyBpbmQgPSAwOyBieXRlcyA9IEJ5dGVzLmNyZWF0ZSBpbml0X3NpemUgfVxuXG4oKiBDaGVjayBzaXplIG9mIHRoZSBidWZmZXIgYW5kIGdyb3cgaXQgaWYgbmVlZGVkLiAqKVxubGV0IGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiBvdmVyaGVhZCA9XG4gIGxldCBsZW4gPSBCeXRlcy5sZW5ndGggYnVmLmJ5dGVzIGluXG4gIGxldCBtaW5fbGVuID0gYnVmLmluZCArIG92ZXJoZWFkIGluXG4gIGlmIG1pbl9sZW4gPiBsZW4gdGhlbiAoXG4gICAgbGV0IG5ld19sZW4gPSBJbnQubWF4IChsZW4gKiAyKSBtaW5fbGVuIGluXG4gICAgbGV0IG5ld19zdHIgPSBCeXRlcy5jcmVhdGUgbmV3X2xlbiBpblxuICAgIEJ5dGVzLmJsaXQgYnVmLmJ5dGVzIDAgbmV3X3N0ciAwIGxlbjtcbiAgICBidWYuYnl0ZXMgPC0gbmV3X3N0cjtcbiAgKVxuXG4oKiBBZGQgdGhlIGNoYXJhY3RlciBgYycgdG8gdGhlIGJ1ZmZlciBgYnVmJy4gKilcbmxldCBidWZmZXJfYWRkX2NoYXIgYnVmIGMgPVxuICBidWZmZXJfY2hlY2tfc2l6ZSBidWYgMTtcbiAgQnl0ZXMuc2V0IGJ1Zi5ieXRlcyBidWYuaW5kIGM7XG4gIGJ1Zi5pbmQgPC0gYnVmLmluZCArIDFcblxuKCogQWRkIHRoZSBzdHJpbmcgYHMnIHRvIHRoZSBidWZmZXIgYGJ1ZicuICopXG5sZXQgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHMgPVxuICBsZXQgc3RyX2xlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBidWZmZXJfY2hlY2tfc2l6ZSBidWYgc3RyX2xlbjtcbiAgU3RyaW5nLmJsaXQgcyAwIGJ1Zi5ieXRlcyBidWYuaW5kIHN0cl9sZW47XG4gIGJ1Zi5pbmQgPC0gYnVmLmluZCArIHN0cl9sZW5cblxuKCogR2V0IHRoZSBjb250ZW50IG9mIHRoZSBidWZmZXIuICopXG5sZXQgYnVmZmVyX2NvbnRlbnRzIGJ1ZiA9XG4gIEJ5dGVzLnN1Yl9zdHJpbmcgYnVmLmJ5dGVzIDAgYnVmLmluZFxuXG4oKioqKVxuXG4oKiBDb252ZXJ0IGFuIGludGVnZXIgY29udmVyc2lvbiB0byBjaGFyLiAqKVxubGV0IGNoYXJfb2ZfaWNvbnYgaWNvbnYgPSBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X2QgfCBJbnRfcGQgfCBJbnRfc2QgfCBJbnRfQ2QgLT4gJ2QnIHwgSW50X2kgfCBJbnRfcGkgfCBJbnRfc2lcbiAgfCBJbnRfQ2kgLT4gJ2knIHwgSW50X3ggfCBJbnRfQ3ggLT4gJ3gnIHwgSW50X1ggfCBJbnRfQ1ggLT4gJ1gnIHwgSW50X29cbiAgfCBJbnRfQ28gLT4gJ28nIHwgSW50X3UgfCBJbnRfQ3UgLT4gJ3UnXG5cbigqIENvbnZlcnQgYSBmbG9hdCBjb252ZXJzaW9uIHRvIGNoYXIuICopXG4oKiBgY0YnIHdpbGwgYmUgJ0YnIGZvciBkaXNwbGF5aW5nIGZvcm1hdCBhbmQgJ2cnIHRvIGNhbGwgbGliYyBwcmludGYgKilcbmxldCBjaGFyX29mX2Zjb252ID8oY0Y9J0YnKSBmY29udiA9IG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZiAtPiAnZicgfCBGbG9hdF9lIC0+ICdlJ1xuICB8IEZsb2F0X0UgLT4gJ0UnIHwgRmxvYXRfZyAtPiAnZydcbiAgfCBGbG9hdF9HIC0+ICdHJyB8IEZsb2F0X0YgLT4gY0ZcbiAgfCBGbG9hdF9oIC0+ICdoJyB8IEZsb2F0X0ggLT4gJ0gnXG4gIHwgRmxvYXRfQ0YgLT4gJ0YnXG5cblxuKCogQ29udmVydCBhIHNjYW5uaW5nIGNvdW50ZXIgdG8gY2hhci4gKilcbmxldCBjaGFyX29mX2NvdW50ZXIgY291bnRlciA9IG1hdGNoIGNvdW50ZXIgd2l0aFxuICB8IExpbmVfY291bnRlciAgLT4gJ2wnXG4gIHwgQ2hhcl9jb3VudGVyICAtPiAnbidcbiAgfCBUb2tlbl9jb3VudGVyIC0+ICdOJ1xuXG4oKioqKVxuXG4oKiBQcmludCBhIGNoYXJfc2V0IGluIGEgYnVmZmVyIHdpdGggdGhlIE9DYW1sIGZvcm1hdCBsZXhpY2FsIGNvbnZlbnRpb24uICopXG5sZXQgYnByaW50X2NoYXJfc2V0IGJ1ZiBjaGFyX3NldCA9XG4gIGxldCByZWMgcHJpbnRfc3RhcnQgc2V0ID1cbiAgICBsZXQgaXNfYWxvbmUgYyA9XG4gICAgICBsZXQgYmVmb3JlLCBhZnRlciA9IENoYXIuKGNociAoY29kZSBjIC0gMSksIGNociAoY29kZSBjICsgMSkpIGluXG4gICAgICBpc19pbl9jaGFyX3NldCBzZXQgY1xuICAgICAgJiYgbm90IChpc19pbl9jaGFyX3NldCBzZXQgYmVmb3JlICYmIGlzX2luX2NoYXJfc2V0IHNldCBhZnRlcikgaW5cbiAgICBpZiBpc19hbG9uZSAnXScgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICddJztcbiAgICBwcmludF9vdXQgc2V0IDE7XG4gICAgaWYgaXNfYWxvbmUgJy0nIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLSc7XG4gIGFuZCBwcmludF9vdXQgc2V0IGkgPVxuICAgIGlmIGkgPCAyNTYgdGhlblxuICAgICAgaWYgaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBpKSB0aGVuIHByaW50X2ZpcnN0IHNldCBpXG4gICAgICBlbHNlIHByaW50X291dCBzZXQgKGkgKyAxKVxuICBhbmQgcHJpbnRfZmlyc3Qgc2V0IGkgPVxuICAgIG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgIHwgJ1xcMjU1JyAtPiBwcmludF9jaGFyIGJ1ZiAyNTU7XG4gICAgfCAnXScgfCAnLScgLT4gcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgIHwgXyAtPiBwcmludF9zZWNvbmQgc2V0IChpICsgMSk7XG4gIGFuZCBwcmludF9zZWNvbmQgc2V0IGkgPVxuICAgIGlmIGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaSkgdGhlblxuICAgICAgbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgICB8ICdcXDI1NScgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgMjU0O1xuICAgICAgICBwcmludF9jaGFyIGJ1ZiAyNTU7XG4gICAgICB8ICddJyB8ICctJyB3aGVuIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCAoaSArIDEpKSkgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgICAgfCBfIHdoZW4gbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IChpICsgMSkpKSAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgICBwcmludF9jaGFyIGJ1ZiBpO1xuICAgICAgICBwcmludF9vdXQgc2V0IChpICsgMik7XG4gICAgICB8IF8gLT5cbiAgICAgICAgcHJpbnRfaW4gc2V0IChpIC0gMSkgKGkgKyAyKTtcbiAgICBlbHNlIChcbiAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgKVxuICBhbmQgcHJpbnRfaW4gc2V0IGkgaiA9XG4gICAgaWYgaiA9IDI1NiB8fCBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaikpIHRoZW4gKFxuICAgICAgcHJpbnRfY2hhciBidWYgaTtcbiAgICAgIHByaW50X2NoYXIgYnVmIChpbnRfb2ZfY2hhciAnLScpO1xuICAgICAgcHJpbnRfY2hhciBidWYgKGogLSAxKTtcbiAgICAgIGlmIGogPCAyNTYgdGhlbiBwcmludF9vdXQgc2V0IChqICsgMSk7XG4gICAgKSBlbHNlXG4gICAgICBwcmludF9pbiBzZXQgaSAoaiArIDEpO1xuICBhbmQgcHJpbnRfY2hhciBidWYgaSA9IG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgIHwgJyUnIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgICB8ICdAJyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQCc7XG4gICAgfCBjICAgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjO1xuICBpblxuICBidWZmZXJfYWRkX2NoYXIgYnVmICdbJztcbiAgcHJpbnRfc3RhcnQgKFxuICAgIGlmIGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0ICdcXDAwMCdcbiAgICB0aGVuICggYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXic7IHJldl9jaGFyX3NldCBjaGFyX3NldCApXG4gICAgZWxzZSBjaGFyX3NldFxuICApO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmICddJ1xuXG4oKioqKVxuXG4oKiBQcmludCBhIHBhZHR5IGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcGFkdHkgYnVmIHBhZHR5ID0gbWF0Y2ggcGFkdHkgd2l0aFxuICB8IExlZnQgIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJy0nXG4gIHwgUmlnaHQgLT4gKClcbiAgfCBaZXJvcyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcwJ1xuXG4oKiBQcmludCB0aGUgJ18nIG9mIGFuIGlnbm9yZWQgZmxhZyBpZiBuZWVkZWQuICopXG5sZXQgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWcgPVxuICBpZiBpZ25fZmxhZyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ18nXG5cbigqKiopXG5cbmxldCBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIHdpZHRoIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyB3aWR0aClcblxuKCoqKilcblxuKCogUHJpbnQgcGFkZGluZyBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3BhZGRpbmcgOiB0eXBlIGEgYiAuIGJ1ZmZlciAtPiAoYSwgYikgcGFkZGluZyAtPiB1bml0ID1cbmZ1biBidWYgcGFkIC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAtPiAoKVxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgbikgLT5cbiAgICBicHJpbnRfcGFkdHkgYnVmIHBhZHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyBuKTtcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSAtPlxuICAgIGJwcmludF9wYWR0eSBidWYgcGFkdHk7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKidcblxuKCogUHJpbnQgcHJlY2lzaW9uIGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcHJlY2lzaW9uIDogdHlwZSBhIGIgLiBidWZmZXIgLT4gKGEsIGIpIHByZWNpc2lvbiAtPiB1bml0ID1cbiAgZnVuIGJ1ZiBwcmVjIC0+IG1hdGNoIHByZWMgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiAtPiAoKVxuICB8IExpdF9wcmVjaXNpb24gbiAtPlxuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy4nO1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyBuKTtcbiAgfCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiLipcIlxuXG4oKioqKVxuXG4oKiBQcmludCB0aGUgb3B0aW9uYWwgJysnLCAnICcgb3IgJyMnIGFzc29jaWF0ZWQgdG8gYW4gaW50IGNvbnZlcnNpb24uICopXG5sZXQgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252ID0gbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9wZCB8IEludF9waSAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcrJ1xuICB8IEludF9zZCB8IEludF9zaSAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcgJ1xuICB8IEludF9DeCB8IEludF9DWCB8IEludF9DbyB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnIydcbiAgfCBJbnRfZCB8IEludF9pIHwgSW50X3ggfCBJbnRfWCB8IEludF9vIHwgSW50X3UgLT4gKClcblxuKCogUHJpbnQgYW4gY29tcGxldGUgaW50IGZvcm1hdCBpbiBhIGJ1ZmZlciAoZXg6IFwiJTMuKmRcIikuICopXG5sZXQgYnByaW50X2ludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpXG5cbigqIFByaW50IGEgY29tcGxldGUgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NCBmb3JtYXQgaW4gYSBidWZmZXIuICopXG5sZXQgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjIGMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2ljb252IGljb252KVxuXG4oKioqKVxuXG4oKiBQcmludCB0aGUgb3B0aW9uYWwgJysnLCAnICcgYW5kL29yICcjJyBhc3NvY2lhdGVkIHRvIGEgZmxvYXQgY29udmVyc2lvbi4gKilcbmxldCBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnYgPVxuICBiZWdpbiBtYXRjaCBmc3QgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2ZsYWdfcCAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcrJ1xuICB8IEZsb2F0X2ZsYWdfcyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcgJ1xuICB8IEZsb2F0X2ZsYWdfIC0+ICgpIGVuZDtcbiAgbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9DRiAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcjJ1xuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HXG4gIHwgRmxvYXRfRiB8IEZsb2F0X2ggfCBGbG9hdF9IIC0+ICgpXG5cbigqIFByaW50IGEgY29tcGxldGUgZmxvYXQgZm9ybWF0IGluIGEgYnVmZmVyIChleDogXCIlKyouM2ZcIikuICopXG5sZXQgYnByaW50X2Zsb2F0X2ZtdCBidWYgaWduX2ZsYWcgZmNvbnYgcGFkIHByZWMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9mY29udiBmY29udilcblxuKCogQ29tcHV0ZSB0aGUgbGl0ZXJhbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBGb3JtYXR0aW5nX2xpdC4gKilcbigqIFVzZWQgYnkgUHJpbnRmIGFuZCBTY2FuZiB3aGVyZSBmb3JtYXR0aW5nIGlzIG5vdCBpbnRlcnByZXRlZC4gKilcbmxldCBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm9ybWF0dGluZ19saXQgPSBtYXRjaCBmb3JtYXR0aW5nX2xpdCB3aXRoXG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgLT4gXCJAXVwiXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgLT4gXCJAfVwiXG4gIHwgQnJlYWsgKHN0ciwgXywgXykgICAgLT4gc3RyXG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgLT4gXCJAP1wiXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgLT4gXCJAXFxuXCJcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAtPiBcIkAuXCJcbiAgfCBNYWdpY19zaXplIChzdHIsIF8pICAtPiBzdHJcbiAgfCBFc2NhcGVkX2F0ICAgICAgICAgICAtPiBcIkBAXCJcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAtPiBcIkAlXCJcbiAgfCBTY2FuX2luZGljIGMgLT4gXCJAXCIgXiAoU3RyaW5nLm1ha2UgMSBjKVxuXG4oKioqKVxuXG4oKiBQcmludCBhIGxpdGVyYWwgY2hhciBpbiBhIGJ1ZmZlciwgZXNjYXBlICclJyBieSBcIiUlXCIuICopXG5sZXQgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgY2hyID0gbWF0Y2ggY2hyIHdpdGhcbiAgfCAnJScgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSVcIlxuICB8IF8gLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjaHJcblxuKCogUHJpbnQgYSBsaXRlcmFsIHN0cmluZyBpbiBhIGJ1ZmZlciwgZXNjYXBlIGFsbCAnJScgYnkgXCIlJVwiLiAqKVxubGV0IGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgc3RyID1cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggc3RyIC0gMSBkb1xuICAgIGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIHN0ci5baV1cbiAgZG9uZVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgcHJldHR5LXByaW50aW5nICopXG5cbigqIFByaW50IGEgY29tcGxldGUgZm9ybWF0IHR5cGUgKGFuIGZtdHR5KSBpbiBhIGJ1ZmZlci4gKilcbmxldCByZWMgYnByaW50X2ZtdHR5IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggaSBqIGsgbCAuXG4gICAgYnVmZmVyIC0+IChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsKSBmbXR0eV9yZWwgLT4gdW5pdCA9XG5mdW4gYnVmIGZtdHR5IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlY1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFN0cmluZ190eSByZXN0ICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVzXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50X3R5IHJlc3QgICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWlcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnQzMl90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlbGlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IE5hdGl2ZWludF90eSByZXN0IC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVuaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJUxpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBGbG9hdF90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlZlwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEJvb2xfdHkgcmVzdCAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVCXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWFcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBUaGV0YV90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIldFwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEFueV90eSByZXN0ICAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiU/XCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgUmVhZGVyX3R5IHJlc3QgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXJcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlX3JcIjtcbiAgICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBGb3JtYXRfYXJnX3R5IChzdWJfZm10dHksIHJlc3QpIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXtcIjsgYnByaW50X2ZtdHR5IGJ1ZiBzdWJfZm10dHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJX1cIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEZvcm1hdF9zdWJzdF90eSAoc3ViX2ZtdHR5LCBfLCByZXN0KSAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUoXCI7IGJwcmludF9mbXR0eSBidWYgc3ViX2ZtdHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IEVuZF9vZl9mbXR0eSAtPiAoKVxuXG4oKioqKVxuXG5sZXQgcmVjIGludF9vZl9jdXN0b21fYXJpdHkgOiB0eXBlIGEgYiBjIC5cbiAgKGEsIGIsIGMpIGN1c3RvbV9hcml0eSAtPiBpbnQgPVxuICBmdW5jdGlvblxuICB8IEN1c3RvbV96ZXJvIC0+IDBcbiAgfCBDdXN0b21fc3VjYyB4IC0+IDEgKyBpbnRfb2ZfY3VzdG9tX2FyaXR5IHhcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmb3JtYXQgaW4gYSBidWZmZXIuICopXG5sZXQgYnByaW50X2ZtdCBidWYgZm10ID1cbiAgbGV0IHJlYyBmbXRpdGVyIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGJvb2wgLT4gdW5pdCA9XG4gIGZ1biBmbXQgaWduX2ZsYWcgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAncyc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnUyc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9pbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICdsJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnbic7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnTCc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9mbG9hdF9mbXQgYnVmIGlnbl9mbGFnIGZjb252IHBhZCBwcmVjO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBDaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ2MnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQyc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0InO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQWxwaGEgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnYSc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFRoZXRhIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3QnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAtPlxuICAgICAgZm9yIF9pID0gMSB0byBpbnRfb2ZfY3VzdG9tX2FyaXR5IGFyaXR5IGRvXG4gICAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnPyc7XG4gICAgICBkb25lO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgUmVhZGVyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3InOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGbHVzaCByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlIVwiO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBzdHI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG4gICAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIGNocjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAneyc7XG4gICAgICBicHJpbnRfZm10dHkgYnVmIGZtdHR5OyBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnfSc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJygnO1xuICAgICAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyknO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHdpZHRoX29wdDsgYnByaW50X2NoYXJfc2V0IGJ1ZiBjaGFyX3NldDtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2NvdW50ZXIgY291bnRlcik7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIFwiMGNcIjsgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgICBsZXQgUGFyYW1fZm9ybWF0X0VCQiBmbXQnID0gcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0IGluXG4gICAgICBmbXRpdGVyIGZtdCcgdHJ1ZTtcblxuICAgIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCk7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgLT5cbiAgICAgIGJlZ2luIG1hdGNoIGZtdGluZ19nZW4gd2l0aFxuICAgICAgfCBPcGVuX3RhZyAoRm9ybWF0IChfLCBzdHIpKSAtPlxuICAgICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCJAe1wiOyBidWZmZXJfYWRkX3N0cmluZyBidWYgc3RyXG4gICAgICB8IE9wZW5fYm94IChGb3JtYXQgKF8sIHN0cikpIC0+XG4gICAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIkBbXCI7IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzdHJcbiAgICAgIGVuZDtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgRW5kX29mX2Zvcm1hdCAtPiAoKVxuXG4gIGluIGZtdGl0ZXIgZm10IGZhbHNlXG5cbigqKiopXG5cbigqIENvbnZlcnQgYSBmb3JtYXQgdG8gc3RyaW5nLiAqKVxubGV0IHN0cmluZ19vZl9mbXQgZm10ID1cbiAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgYnByaW50X2ZtdCBidWYgZm10O1xuICBidWZmZXJfY29udGVudHMgYnVmXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIFR5cGUgZXh0cmFjdGlvbiAqKVxuXG50eXBlIChfLCBfKSBlcSA9IFJlZmwgOiAoJ2EsICdhKSBlcVxuXG4oKiBJbnZhcmlhbnQ6IHRoaXMgZnVuY3Rpb24gaXMgdGhlIGlkZW50aXR5IG9uIHZhbHVlcy5cblxuICAgSW4gcGFydGljdWxhciwgaWYgKHR5MSwgdHkyKSBoYXZlIGVxdWFsIHZhbHVlcywgdGhlblxuICAgKHRyYW5zIChzeW1tIHR5MSkgdHkyKSByZXNwZWN0cyB0aGUgJ3RyYW5zJyBwcmVjb25kaXRpb24uICopXG5sZXQgcmVjIHN5bW0gOiB0eXBlIGExIGIxIGMxIGQxIGUxIGYxIGEyIGIyIGMyIGQyIGUyIGYyIC5cbiAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIsXG4gICAgYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10dHlfcmVsXG49IGZ1bmN0aW9uXG4gIHwgQ2hhcl90eSByZXN0IC0+IENoYXJfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnRfdHkgcmVzdCAtPiBJbnRfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnQzMl90eSByZXN0IC0+IEludDMyX3R5IChzeW1tIHJlc3QpXG4gIHwgSW50NjRfdHkgcmVzdCAtPiBJbnQ2NF90eSAoc3ltbSByZXN0KVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+IE5hdGl2ZWludF90eSAoc3ltbSByZXN0KVxuICB8IEZsb2F0X3R5IHJlc3QgLT4gRmxvYXRfdHkgKHN5bW0gcmVzdClcbiAgfCBCb29sX3R5IHJlc3QgLT4gQm9vbF90eSAoc3ltbSByZXN0KVxuICB8IFN0cmluZ190eSByZXN0IC0+IFN0cmluZ190eSAoc3ltbSByZXN0KVxuICB8IFRoZXRhX3R5IHJlc3QgLT4gVGhldGFfdHkgKHN5bW0gcmVzdClcbiAgfCBBbHBoYV90eSByZXN0IC0+IEFscGhhX3R5IChzeW1tIHJlc3QpXG4gIHwgQW55X3R5IHJlc3QgLT4gQW55X3R5IChzeW1tIHJlc3QpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT4gUmVhZGVyX3R5IChzeW1tIHJlc3QpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPiBJZ25vcmVkX3JlYWRlcl90eSAoc3ltbSByZXN0KVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBzeW1tIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MiwgdHkxLCBzeW1tIHJlc3QpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuXG5sZXQgcmVjIGZtdHR5X3JlbF9kZXQgOiB0eXBlIGExIGIgYyBkMSBlMSBmMSBhMiBkMiBlMiBmMiAuXG4gIChhMSwgYiwgYywgZDEsIGUxLCBmMSxcbiAgIGEyLCBiLCBjLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWwgLT5cbiAgICAoKGYxLCBmMikgZXEgLT4gKGExLCBhMikgZXEpXG4gICogKChhMSwgYTIpIGVxIC0+IChmMSwgZjIpIGVxKVxuICAqICgoZTEsIGUyKSBlcSAtPiAoZDEsIGQyKSBlcSlcbiAgKiAoKGQxLCBkMikgZXEgLT4gKGUxLCBlMikgZXEpXG49IGZ1bmN0aW9uXG4gIHwgRW5kX29mX2ZtdHR5IC0+XG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcblxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuICB8IEZvcm1hdF9hcmdfdHkgKF90eSwgcmVzdCkgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIGxldCBhZywgZ2EsIGRqLCBqZCA9IGZtdHR5X3JlbF9kZXQgdHkgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIGxldCBSZWZsID0gYWcgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBnYSBSZWZsIGluIGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIGxldCBSZWZsID0gZGogUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBqZCBSZWZsIGluIGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuXG4oKiBQcmVjb25kaXRpb246IHdlIGFzc3VtZSB0aGF0IHRoZSB0d28gZm10dHlfcmVsIGFyZ3VtZW50cyBoYXZlIGVxdWFsXG4gICB2YWx1ZXMgKGF0IHBvc3NpYmx5IGRpc3RpbmN0IHR5cGVzKTsgdGhpcyBpbnZhcmlhbnQgY29tZXMgZnJvbSB0aGUgd2F5XG4gICBmbXR0eV9yZWwgd2l0bmVzc2VzIGFyZSBwcm9kdWNlZCBieSB0aGUgdHlwZS1jaGVja2VyXG5cbiAgIFRoZSBjb2RlIGJlbG93IHVzZXMgKGFzc2VydCBmYWxzZSkgd2hlbiB0aGlzIGFzc3VtcHRpb24gaXMgYnJva2VuLiBUaGVcbiAgIGNvZGUgcGF0dGVybiBpcyB0aGUgZm9sbG93aW5nOlxuXG4gICAgIHwgRm9vIHgsIEZvbyB5IC0+XG4gICAgICAgKCogY2FzZSB3aGVyZSBpbmRlZWQgYm90aCB2YWx1ZXNcbiAgICAgICAgICBzdGFydCB3aXRoIGNvbnN0cnVjdG9yIEZvbyAqKVxuICAgICB8IEZvbyBfLCBfXG4gICAgIHwgXywgRm9vIF8gLT5cbiAgICAgICAoKiBkaWZmZXJlbnQgaGVhZCBjb25zdHJ1Y3RvcnM6IGJyb2tlbiBwcmVjb25kaXRpb24gKilcbiAgICAgICBhc3NlcnQgZmFsc2VcbiopXG5hbmQgdHJhbnMgOiB0eXBlXG4gIGExIGIxIGMxIGQxIGUxIGYxXG4gIGEyIGIyIGMyIGQyIGUyIGYyXG4gIGEzIGIzIGMzIGQzIGUzIGYzXG4uXG4gICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbi0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLFxuICAgIGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5X3JlbFxuLT4gKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHlfcmVsXG49IGZ1biB0eTEgdHkyIC0+IG1hdGNoIHR5MSwgdHkyIHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QxLCBDaGFyX3R5IHJlc3QyIC0+IENoYXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFN0cmluZ190eSByZXN0MSwgU3RyaW5nX3R5IHJlc3QyIC0+IFN0cmluZ190eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQm9vbF90eSByZXN0MSwgQm9vbF90eSByZXN0MiAtPiBCb29sX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnRfdHkgcmVzdDEsIEludF90eSByZXN0MiAtPiBJbnRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludDMyX3R5IHJlc3QxLCBJbnQzMl90eSByZXN0MiAtPiBJbnQzMl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50NjRfdHkgcmVzdDEsIEludDY0X3R5IHJlc3QyIC0+IEludDY0X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdDEsIE5hdGl2ZWludF90eSByZXN0MiAtPiBOYXRpdmVpbnRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZsb2F0X3R5IHJlc3QxLCBGbG9hdF90eSByZXN0MiAtPiBGbG9hdF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG5cbiAgfCBBbHBoYV90eSByZXN0MSwgQWxwaGFfdHkgcmVzdDIgLT4gQWxwaGFfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEFscGhhX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgQWxwaGFfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IFRoZXRhX3R5IHJlc3QxLCBUaGV0YV90eSByZXN0MiAtPiBUaGV0YV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgVGhldGFfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBUaGV0YV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgQW55X3R5IHJlc3QxLCBBbnlfdHkgcmVzdDIgLT4gQW55X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBBbnlfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBBbnlfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IFJlYWRlcl90eSByZXN0MSwgUmVhZGVyX3R5IHJlc3QyIC0+IFJlYWRlcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgUmVhZGVyX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgUmVhZGVyX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0MSwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdDIgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBJZ25vcmVkX3JlYWRlcl90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRm9ybWF0X2FyZ190eSAodHkxLCByZXN0MSksIEZvcm1hdF9hcmdfdHkgKHR5MiwgcmVzdDIpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHJhbnMgdHkxIHR5MiwgdHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRm9ybWF0X2FyZ190eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEZvcm1hdF9hcmdfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxMSwgdHkxMiwgcmVzdDEpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkyMSwgdHkyMiwgcmVzdDIpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxMikgdHkyMSBpblxuICAgIGxldCBfLCBmMiwgXywgZjQgPSBmbXR0eV9yZWxfZGV0IHR5IGluXG4gICAgbGV0IFJlZmwgPSBmMiBSZWZsIGluXG4gICAgbGV0IFJlZmwgPSBmNCBSZWZsIGluXG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTExLCB0eTIyLCB0cmFucyByZXN0MSByZXN0MilcbiAgfCBGb3JtYXRfc3Vic3RfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBGb3JtYXRfc3Vic3RfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEVuZF9vZl9mbXR0eSwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuICB8IEVuZF9vZl9mbXR0eSwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBFbmRfb2ZfZm10dHkgLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCByZWMgZm10dHlfb2ZfZm9ybWF0dGluZ19nZW4gOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZvcm1hdHRpbmdfZ2VuIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBmb3JtYXR0aW5nX2dlbiAtPiBtYXRjaCBmb3JtYXR0aW5nX2dlbiB3aXRoXG4gIHwgT3Blbl90YWcgKEZvcm1hdCAoZm10LCBfKSkgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IE9wZW5fYm94IChGb3JtYXQgKGZtdCwgXykpIC0+IGZtdHR5X29mX2ZtdCBmbXRcblxuKCogRXh0cmFjdCB0aGUgdHlwZSByZXByZXNlbnRhdGlvbiAoYW4gZm10dHkpIG9mIGEgZm9ybWF0LiAqKVxuYW5kIGZtdHR5X29mX2ZtdCA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gZm10dHkgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcblxuICB8IEludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgSW50MzIgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50MzJfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgTmF0aXZlaW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKE5hdGl2ZWludF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBJbnQ2NCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnQ2NF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBGbG9hdCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChGbG9hdF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcblxuICB8IENoYXIgcmVzdCAgICAgICAgICAgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IENhbWxfY2hhciByZXN0ICAgICAgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEJvb2wgKHBhZCwgcmVzdCkgICAgICAgICAgIC0+XG4gICAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoQm9vbF90eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuICB8IEFscGhhIHJlc3QgICAgICAgICAgICAgICAgIC0+IEFscGhhX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAtPiBUaGV0YV90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgICAgLT4gZm10dHlfb2ZfY3VzdG9tIGFyaXR5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBSZWFkZXIgcmVzdCAgICAgICAgICAgICAgICAtPiBSZWFkZXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRm9ybWF0X2FyZyAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEZvcm1hdF9zdWJzdCAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eSwgdHksIGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRmx1c2ggcmVzdCAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgICAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPiBTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+IEludF90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgLT4gZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAgLT5cbiAgICBjb25jYXRfZm10dHkgKGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIGZtdGluZ19nZW4pIChmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgIC0+IEVuZF9vZl9mbXR0eVxuXG5hbmQgZm10dHlfb2ZfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAoeSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGFyaXR5IGZtdHR5IC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBmbXR0eVxuICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+IEFueV90eSAoZm10dHlfb2ZfY3VzdG9tIGFyaXR5IGZtdHR5KVxuXG4oKiBFeHRyYWN0IHRoZSBmbXR0eSBvZiBhbiBpZ25vcmVkIHBhcmFtZXRlciBmb2xsb3dlZCBieSB0aGUgcmVzdCBvZlxuICAgdGhlIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IGNvbmNhdF9mbXR0eSBmbXR0eSAoZm10dHlfb2ZfZm10IGZtdClcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IElnbm9yZWRfcmVhZGVyX3R5IChmbXR0eV9vZl9mbXQgZm10KVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcGFkZGluZyBpcyB0YWtlbiBhcyBhbiBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpzXCIpLiAqKVxuYW5kIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgOiB0eXBlIHggYSBiIGMgZCBlIGYgLlxuICAgICh4LCBhKSBwYWRkaW5nIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcGFkIGZtdHR5IC0+IG1hdGNoIHBhZCB3aXRoXG4gICAgfCBOb19wYWRkaW5nICAgIC0+IGZtdHR5XG4gICAgfCBMaXRfcGFkZGluZyBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcGFkZGluZyBfIC0+IEludF90eSBmbXR0eVxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcHJlY2lzaW9uIGlzIHRha2VuIGFzIGFuIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpLiopXG5hbmQgZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IDogdHlwZSB4IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgYSkgcHJlY2lzaW9uIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcHJlYyBmbXR0eSAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgICB8IE5vX3ByZWNpc2lvbiAgICAtPiBmbXR0eVxuICAgIHwgTGl0X3ByZWNpc2lvbiBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcHJlY2lzaW9uICAgLT4gSW50X3R5IGZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGluZyAqKVxuXG4oKiBFeGNlcHRpb24gcmFpc2VkIHdoZW4gYSBmb3JtYXQgZG9lcyBub3QgbWF0Y2ggYSBnaXZlbiBmb3JtYXQgdHlwZS4gKilcbmV4Y2VwdGlvbiBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBwYWRkaW5nLiAqKVxuKCogVGFrZSBhbiBJbnRfdHkgZnJvbSB0aGUgZm10dHkgaWYgdGhlIGludGVnZXIgc2hvdWxkIGJlIGtlcHQgYXMgYXJndW1lbnQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZGRpbmcgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkZGluZ19mbXR0eV9lYmIgPVxuZnVuIHBhZCBmbXR0eSAtPiBtYXRjaCBwYWQsIGZtdHR5IHdpdGhcbiAgfCBOb19wYWRkaW5nLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChOb19wYWRkaW5nLCBmbXR0eSlcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChMaXRfcGFkZGluZyAocGFkdHksdyksZm10dHkpXG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEludF90eSByZXN0IC0+IFBhZGRpbmdfZm10dHlfRUJCIChBcmdfcGFkZGluZyBwYWR0eSxyZXN0KVxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBDb252ZXJ0IGEgKHVwYWRkaW5nLCB1cHJlY2lzaW9uKSB0byBhIChwYWRkaW5nLCBwcmVjaXNpb24pLiAqKVxuKCogVGFrZSBvbmUgb3IgdHdvIEludF90eSBmcm9tIHRoZSBmbXR0eSBpZiBuZWVkZWQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZHByZWMgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSB6IC5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHopIHByZWNpc2lvbiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkcHJlY19mbXR0eV9lYmIgPVxuZnVuIHBhZCBwcmVjIGZtdHR5IC0+IG1hdGNoIHByZWMsIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBOb19wcmVjaXNpb24sIHJlc3QpXG4gIHwgTGl0X3ByZWNpc2lvbiBwLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIExpdF9wcmVjaXNpb24gcCwgcmVzdClcbiAgfCBBcmdfcHJlY2lzaW9uLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBJbnRfdHkgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBBcmdfcHJlY2lzaW9uLCByZXN0KVxuICB8IF8sIFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBmb3JtYXQgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuKCogSWYgdHlwaW5nIHN1Y2NlZWQsIGdlbmVyYXRlIGEgY29weSBvZiB0aGUgZm9ybWF0IHdpdGggdGhlIHNhbWVcbiAgICB0eXBlIHBhcmFtZXRlcnMgYXMgdGhlIGZtdHR5LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgcmVjIHR5cGVfZm9ybWF0IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPiBtYXRjaCB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5IHdpdGhcbiAgfCBGbXRfZm10dHlfRUJCIChmbXQnLCBFbmRfb2ZfZm10dHkpIC0+IGZtdCdcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuYW5kIHR5cGVfZm9ybWF0X2dlbiA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eVxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10X2ZtdHR5X2ViYlxuPSBmdW4gZm10IGZtdHR5IC0+IG1hdGNoIGZtdCwgZm10dHkgd2l0aFxuICB8IENoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyIGZtdCcsIGZtdHR5JylcbiAgfCBDYW1sX2NoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDYW1sX2NoYXIgZm10JywgZm10dHknKVxuICB8IFN0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChTdHJpbmcgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBDYW1sX3N0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChDYW1sX3N0cmluZyAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludDMyX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIE5hdGl2ZWludF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnQ2NF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50NjQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEZsb2F0X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBCb29sIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBCb29sX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChCb29sIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmx1c2ggZm10X3Jlc3QsIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRmx1c2ggZm10JywgZm10dHknKVxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFN0cmluZ19saXRlcmFsIChzdHIsIGZtdCcpLCBmbXR0eScpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyX2xpdGVyYWwgKGNociwgZm10JyksIGZtdHR5JylcblxuICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpLFxuICAgIEZvcm1hdF9hcmdfdHkgKHN1Yl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIHN1Yl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViX2ZtdHR5JyB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eScsIGZtdCcpLCBmbXR0eScpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHksIGZtdF9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1Yl9mbXR0eTEsIF9zdWJfZm10dHkyLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1Yl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViX2ZtdHR5MSkgdGhlblxuICAgICAgcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9XG4gICAgICB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgKGVyYXNlX3JlbCBmbXR0eV9yZXN0KVxuICAgIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkxLCBmbXQnKSwgZm10dHknKVxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgQWxwaGEgZm10X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQWxwaGEgZm10JywgZm10dHknKVxuICB8IFRoZXRhIGZtdF9yZXN0LCBUaGV0YV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFRoZXRhIGZtdCcsIGZtdHR5JylcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10JyksIGZtdHR5JylcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZ19nZW4sIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIHR5cGVfZm9ybWF0dGluZ19nZW4gZm9ybWF0dGluZ19nZW4gZm10X3Jlc3QgZm10dHlfcmVzdFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBSZWFkZXIgZm10X3Jlc3QsIFJlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFJlYWRlciBmbXQnLCBmbXR0eScpXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10X3Jlc3QpLCBTdHJpbmdfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXQnKSwgZm10dHknKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSwgSW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10JyksIGZtdHR5JylcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgdHlwZV9pZ25vcmVkX3BhcmFtIGlnbiByZXN0IGZtdHR5X3Jlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQsIGZtdHR5X3Jlc3QgLT4gRm10X2ZtdHR5X0VCQiAoRW5kX29mX2Zvcm1hdCwgZm10dHlfcmVzdClcblxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG5hbmQgdHlwZV9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYTEgYTMgYjEgYjMgYzEgYzMgZDEgZDMgZTEgZTIgZTMgZjEgZjIgZjMgLlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChmMSwgYjEsIGMxLCBlMSwgZTIsIGYyKSBmbXQgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHkgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10X2ZtdHR5X2ViYiA9XG5mdW4gZm9ybWF0dGluZ19nZW4gZm10MCBmbXR0eTAgLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdDEsIHN0cikpIC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDIsIGZtdHR5MikgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MSBmbXR0eTAgaW5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MywgZm10dHkzKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQwIGZtdHR5MiBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQyLCBzdHIpKSwgZm10MyksIGZtdHR5MylcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQxLCBzdHIpKSAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQyLCBmbXR0eTIpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDEgZm10dHkwIGluXG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDMsIGZtdHR5MykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MCBmbXR0eTIgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10Miwgc3RyKSksIGZtdDMpLCBmbXR0eTMpXG5cbigqIFR5cGUgYW4gSWdub3JlZF9wYXJhbSBub2RlIGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbmFuZCB0eXBlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHAgcSB4IHkgeiB0IHUgdiBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIHksIHosIHQsIHEsIHApIGlnbm9yZWQgLT5cbiAgICAocCwgeSwgeiwgcSwgdSwgdikgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdF9mbXR0eV9lYmIgPVxuZnVuIGlnbiBmbXQgZm10dHkgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludCBfICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDMyIF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX25hdGl2ZWludCBfICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDY0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zsb2F0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkgLT5cbiAgICB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIChJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkpIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkpIC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eScsIEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eSBmbXQgZm10dHkgaW5cbiAgICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm10JyksXG4gICAgICAgICAgICAgICAgICAgZm10dHknKVxuICB8IElnbm9yZWRfcmVhZGVyIC0+IChcbiAgICBtYXRjaCBmbXR0eSB3aXRoXG4gICAgfCBJZ25vcmVkX3JlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9yZWFkZXIsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuXG5hbmQgdHlwZV9pZ25vcmVkX3BhcmFtX29uZSA6IHR5cGUgYTEgYTIgYjEgYjIgYzEgYzIgZDEgZDIgZTEgZTIgZjEgZjIgLlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZDIsIGEyKSBpZ25vcmVkIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdCAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eSAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRfZm10dHlfZWJiXG49IGZ1biBpZ24gZm10IGZtdHR5IC0+XG4gIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSBpblxuICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChpZ24sIGZtdCcpLCBmbXR0eScpXG5cbigqIFR5cGluZyBvZiB0aGUgY29tcGxleCBjYXNlOiBcIiVfKC4uLiUpXCIuICopXG5hbmQgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gOiB0eXBlIHcgeCB5IHogcCBzIHQgdSBhIGIgYyBkIGUgZiAuXG4gICAgKHcsIHgsIHksIHosIHMsIHApIGZtdHR5IC0+XG4gICAgKHAsIHgsIHksIHMsIHQsIHUpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlfZm10X2ViYiA9XG5mdW4gc3ViX2ZtdHR5IGZtdCBmbXR0eSAtPiBtYXRjaCBzdWJfZm10dHksIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHN1Yl9mbXR0eV9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKENoYXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50X3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnQzMl90eSBzdWJfZm10dHlfcmVzdCwgSW50MzJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50MzJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCwgTmF0aXZlaW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50NjRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludDY0X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludDY0X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBGbG9hdF90eSBzdWJfZm10dHlfcmVzdCwgRmxvYXRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRmxvYXRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEJvb2xfdHkgc3ViX2ZtdHR5X3Jlc3QsIEJvb2xfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQm9vbF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgQWxwaGFfdHkgc3ViX2ZtdHR5X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEFscGhhX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBUaGV0YV90eSBzdWJfZm10dHlfcmVzdCwgVGhldGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoVGhldGFfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCwgUmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIElnbm9yZWRfcmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKElnbm9yZWRfcmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcblxuICB8IEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHksIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgc3ViMl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViMl9mbXR0eScgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eScsIHN1Yl9mbXR0eV9yZXN0JyksIGZtdCcpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5LCAgc3ViMl9mbXR0eSwgIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICAoKiBUT0RPIGRlZmluZSBGbXR0eV9yZWxfRUJCIHRvIHJlbW92ZSB0aG9zZSBlcmFzZV9yZWwgKilcbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5JylcbiAgICB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eScpXG4gICAgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBzdWJfZm10dHknID0gdHJhbnMgKHN5bW0gc3ViMV9mbXR0eScpIHN1YjJfZm10dHknIGluXG4gICAgbGV0IF8sIGYyLCBfLCBmNCA9IGZtdHR5X3JlbF9kZXQgc3ViX2ZtdHR5JyBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIChlcmFzZV9yZWwgc3ViX2ZtdHR5X3Jlc3QpIGZtdCBmbXR0eV9yZXN0XG4gICAgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bW0gc3ViX2ZtdHR5X3Jlc3QnKSxcbiAgICAgICAgICAgICAgICAgICBmbXQnKVxuICB8IEVuZF9vZl9mbXR0eSwgZm10dHkgLT5cbiAgICBGbXR0eV9mbXRfRUJCIChFbmRfb2ZfZm10dHksIHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkpXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFRoaXMgaW1wbGVtZW50YXRpb24gb2YgYHJlY2FzdGAgaXMgYSBiaXQgZGlzYXBwb2ludGluZy4gVGhlXG4gICBpbnZhcmlhbnQgcHJvdmlkZWQgYnkgdGhlIHR5cGUgYXJlIHZlcnkgc3Ryb25nOiB0aGUgaW5wdXQgZm9ybWF0J3NcbiAgIHR5cGUgaXMgaW4gcmVsYXRpb24gdG8gdGhlIG91dHB1dCB0eXBlJ3MgYXMgd2l0bmVzc2VkIGJ5IHRoZVxuICAgZm10dHlfcmVsIGFyZ3VtZW50LiBPbmUgd291bGQgYXQgZmlyc3QgZXhwZWN0IHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgIHRvdGFsLCBhbmQgaW1wbGVtZW50YWJsZSBieSBleGhhdXN0aXZlIHBhdHRlcm4gbWF0Y2hpbmcuIEluc3RlYWQsXG4gICB3ZSByZXVzZSB0aGUgaGlnaGx5IHBhcnRpYWwgYW5kIG11Y2ggbGVzcyB3ZWxsLWRlZmluZWQgZnVuY3Rpb25cbiAgIGB0eXBlX2Zvcm1hdGAgdGhhdCBoYXMgbG9zdCBhbGwga25vd2xlZGdlIG9mIHRoZSBjb3JyZXNwb25kZW5jZVxuICAgYmV0d2VlbiB0aGUgYXJndW1lbnQncyB0eXBlcy5cblxuICAgQmVzaWRlcyB0aGUgZmFjdCB0aGF0IHRoaXMgZnVuY3Rpb24gcmV1c2VzIGEgbG90IG9mIHRoZVxuICAgYHR5cGVfZm9ybWF0YCBsb2dpYyAoZWcuOiBzZWVpbmcgSW50X3R5IGluIHRoZSBmbXR0eSBwYXJhbWV0ZXIgZG9lc1xuICAgbm90IGxldCB5b3UgbWF0Y2ggb24gSW50IG9ubHksIGFzIHlvdSBtYXkgaW4gZmFjdCBoYXZlIEZsb2F0XG4gICAoQXJnX3BhZGRpbmcsIC4uLikgKFwiJS4qZFwiKSBiZWdpbm5pbmcgd2l0aCBhbiBJbnRfdHkpLCBpdCBpcyBhbHNvXG4gICBhIHBhcnRpYWwgZnVuY3Rpb24sIGJlY2F1c2UgdGhlIHR5cGluZyBpbmZvcm1hdGlvbiBpbiBhIGZvcm1hdCBpc1xuICAgbm90IHF1aXRlIGVub3VnaCB0byByZWNvbnN0cnVjdCBpdCB1bmFtYmlndW91c2x5LiBGb3IgZXhhbXBsZSwgdGhlXG4gICBmb3JtYXQgdHlwZXMgb2YgXCIlZCVfclwiIGFuZCBcIiVfciVkXCIgaGF2ZSB0aGUgc2FtZSBmb3JtYXQ2XG4gICBwYXJhbWV0ZXJzLCBidXQgdGhleSBhcmUgbm90IGF0IGFsbCBleGNoYW5nZWFibGUsIGFuZCBwdXR0aW5nIG9uZVxuICAgaW4gcGxhY2Ugb2YgdGhlIG90aGVyIG11c3QgcmVzdWx0IGluIGEgZHluYW1pYyBmYWlsdXJlLlxuXG4gICBHaXZlbiB0aGF0OlxuICAgLSB3ZSdkIGhhdmUgdG8gZHVwbGljYXRlIGEgbG90IG9mIG5vbi10cml2aWFsIHR5cGluZyBsb2dpYyBmcm9tIHR5cGVfZm9ybWF0XG4gICAtIHRoaXMgd291bGRuJ3QgZXZlbiBlbGltaW5hdGUgKGFsbCkgdGhlIGR5bmFtaWMgZmFpbHVyZXNcbiAgIHdlIGRlY2lkZWQgdG8ganVzdCByZXVzZSB0eXBlX2Zvcm1hdCBkaXJlY3RseSBmb3Igbm93LlxuKilcbmxldCByZWNhc3QgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPlxuICB0eXBlX2Zvcm1hdCBmbXQgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFByaW50aW5nIHRvb2xzICopXG5cbigqIEFkZCBwYWRkaW5nIHNwYWNlcyBhcm91bmQgYSBzdHJpbmcuICopXG5sZXQgZml4X3BhZGRpbmcgcGFkdHkgd2lkdGggc3RyID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCB3aWR0aCwgcGFkdHkgPVxuICAgIGFicyB3aWR0aCxcbiAgICAoKiB3aGlsZSBsaXRlcmFsIHBhZGRpbmcgd2lkdGhzIGFyZSBhbHdheXMgbm9uLW5lZ2F0aXZlLFxuICAgICAgIGR5bmFtaWNhbGx5LXNldCB3aWR0aHMgKEFyZ19wYWRkaW5nLCBlZy4gJSpkKSBtYXkgYmUgbmVnYXRpdmU7XG4gICAgICAgd2UgaW50ZXJwcmV0IHRob3NlIGFzIHNwZWNpZnlpbmcgYSBwYWRkaW5nLXRvLXRoZS1sZWZ0OyB0aGlzXG4gICAgICAgbWVhbnMgdGhhdCAnMCcgbWF5IGdldCBkcm9wcGVkIGV2ZW4gaWYgaXQgd2FzIGV4cGxpY2l0bHkgc2V0LFxuICAgICAgIGJ1dDpcbiAgICAgICAtIHRoaXMgaXMgd2hhdCB0aGUgbGVnYWN5IGltcGxlbWVudGF0aW9uIGRvZXMsIGFuZFxuICAgICAgICAgd2UgcHJlc2VydmUgY29tcGF0aWJpbGl0eSBpZiBwb3NzaWJsZVxuICAgICAgIC0gd2UgY291bGQgb25seSBzaWduYWwgdGhpcyBpc3N1ZSBieSBmYWlsaW5nIGF0IHJ1bnRpbWUsXG4gICAgICAgICB3aGljaCBpcyBub3QgdmVyeSBuaWNlLi4uICopXG4gICAgaWYgd2lkdGggPCAwIHRoZW4gTGVmdCBlbHNlIHBhZHR5IGluXG4gIGlmIHdpZHRoIDw9IGxlbiB0aGVuIHN0ciBlbHNlXG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2Ugd2lkdGggKGlmIHBhZHR5ID0gWmVyb3MgdGhlbiAnMCcgZWxzZSAnICcpIGluXG4gICAgYmVnaW4gbWF0Y2ggcGFkdHkgd2l0aFxuICAgIHwgTGVmdCAgLT4gU3RyaW5nLmJsaXQgc3RyIDAgcmVzIDAgbGVuXG4gICAgfCBSaWdodCAtPiBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMCAmJiAoc3RyLlswXSA9ICcrJyB8fCBzdHIuWzBdID0gJy0nIHx8IHN0ci5bMF0gPSAnICcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDAgc3RyLlswXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAod2lkdGggLSBsZW4gKyAxKSAobGVuIC0gMSlcbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMSAmJiBzdHIuWzBdID0gJzAnICYmIChzdHIuWzFdID0gJ3gnIHx8IHN0ci5bMV0gPSAnWCcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDEgc3RyLlsxXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAod2lkdGggLSBsZW4gKyAyKSAobGVuIC0gMilcbiAgICB8IFplcm9zIC0+XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICBlbmQ7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogQWRkICcwJyBwYWRkaW5nIHRvIGludCwgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24uICopXG5sZXQgZml4X2ludF9wcmVjaXNpb24gcHJlYyBzdHIgPVxuICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBtYXRjaCBzdHIuWzBdIHdpdGhcbiAgfCAoJysnIHwgJy0nIHwgJyAnKSBhcyBjIHdoZW4gcHJlYyArIDEgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDEpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMCBjO1xuICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAocHJlYyAtIGxlbiArIDIpIChsZW4gLSAxKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyB3aGVuIHByZWMgKyAyID4gbGVuICYmIGxlbiA+IDEgJiYgKHN0ci5bMV0gPSAneCcgfHwgc3RyLlsxXSA9ICdYJykgLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDIpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMSBzdHIuWzFdO1xuICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAocHJlYyAtIGxlbiArIDQpIChsZW4gLSAyKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyB3aGVuIHByZWMgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSBwcmVjICcwJyBpblxuICAgIFN0cmluZy5ibGl0IHN0ciAwIHJlcyAocHJlYyAtIGxlbikgbGVuO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgXyAtPlxuICAgIHN0clxuXG4oKiBFc2NhcGUgYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBPQ2FtbCBsZXhpbmcgY29udmVudGlvbi4gKilcbmxldCBzdHJpbmdfdG9fY2FtbF9zdHJpbmcgc3RyID1cbiAgbGV0IHN0ciA9IFN0cmluZy5lc2NhcGVkIHN0ciBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCByZXMgPSBCeXRlcy5tYWtlIChsICsgMikgJ1xcXCInIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2ludC9pbnQzMi9uYXRpdmVpbnQvaW50NjQgZmlyc3QgYXJndW1lbnRcbiAgIGZyb20gYW4gaW50X2NvbnYuICopXG5sZXQgZm9ybWF0X29mX2ljb252ID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVkXCIgfCBJbnRfcGQgLT4gXCIlK2RcIiB8IEludF9zZCAtPiBcIiUgZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlaVwiIHwgSW50X3BpIC0+IFwiJStpXCIgfCBJbnRfc2kgLT4gXCIlIGlcIlxuICB8IEludF94IC0+IFwiJXhcIiB8IEludF9DeCAtPiBcIiUjeFwiXG4gIHwgSW50X1ggLT4gXCIlWFwiIHwgSW50X0NYIC0+IFwiJSNYXCJcbiAgfCBJbnRfbyAtPiBcIiVvXCIgfCBJbnRfQ28gLT4gXCIlI29cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJXVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252TCA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlTGRcIiB8IEludF9wZCAtPiBcIiUrTGRcIiB8IEludF9zZCAtPiBcIiUgTGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJUxpXCIgfCBJbnRfcGkgLT4gXCIlK0xpXCIgfCBJbnRfc2kgLT4gXCIlIExpXCJcbiAgfCBJbnRfeCAtPiBcIiVMeFwiIHwgSW50X0N4IC0+IFwiJSNMeFwiXG4gIHwgSW50X1ggLT4gXCIlTFhcIiB8IEludF9DWCAtPiBcIiUjTFhcIlxuICB8IEludF9vIC0+IFwiJUxvXCIgfCBJbnRfQ28gLT4gXCIlI0xvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVMdVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZsID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVsZFwiIHwgSW50X3BkIC0+IFwiJStsZFwiIHwgSW50X3NkIC0+IFwiJSBsZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlbGlcIiB8IEludF9waSAtPiBcIiUrbGlcIiB8IEludF9zaSAtPiBcIiUgbGlcIlxuICB8IEludF94IC0+IFwiJWx4XCIgfCBJbnRfQ3ggLT4gXCIlI2x4XCJcbiAgfCBJbnRfWCAtPiBcIiVsWFwiIHwgSW50X0NYIC0+IFwiJSNsWFwiXG4gIHwgSW50X28gLT4gXCIlbG9cIiB8IEludF9DbyAtPiBcIiUjbG9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJWx1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udm4gPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJW5kXCIgfCBJbnRfcGQgLT4gXCIlK25kXCIgfCBJbnRfc2QgLT4gXCIlIG5kXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVuaVwiIHwgSW50X3BpIC0+IFwiJStuaVwiIHwgSW50X3NpIC0+IFwiJSBuaVwiXG4gIHwgSW50X3ggLT4gXCIlbnhcIiB8IEludF9DeCAtPiBcIiUjbnhcIlxuICB8IEludF9YIC0+IFwiJW5YXCIgfCBJbnRfQ1ggLT4gXCIlI25YXCJcbiAgfCBJbnRfbyAtPiBcIiVub1wiIHwgSW50X0NvIC0+IFwiJSNub1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlbnVcIlxuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2Zsb2F0IGZpcnN0IGFyZ3VtZW50IGZyb20gYSBmbG9hdF9jb252LiAqKVxubGV0IGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjID1cbiAgICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gICAgbGV0IHN5bWIgPSBjaGFyX29mX2Zjb252IH5jRjonZycgZmNvbnYgaW5cbiAgICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICAgIGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udjtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcuJztcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgcHJlYyk7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBzeW1iO1xuICAgIGJ1ZmZlcl9jb250ZW50cyBidWZcblxubGV0IHRyYW5zZm9ybV9pbnRfYWx0IGljb252IHMgPVxuICBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X0NkIHwgSW50X0NpIHwgSW50X0N1IC0+XG4gICAgbGV0IGRpZ2l0cyA9XG4gICAgICBsZXQgbiA9IHJlZiAwIGluXG4gICAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgICBtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgICB8ICcwJy4uJzknIC0+IGluY3IgblxuICAgICAgICB8IF8gLT4gKClcbiAgICAgIGRvbmU7XG4gICAgICAhblxuICAgIGluXG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSAoU3RyaW5nLmxlbmd0aCBzICsgKGRpZ2l0cyAtIDEpIC8gMykgaW5cbiAgICBsZXQgcG9zID0gcmVmIDAgaW5cbiAgICBsZXQgcHV0IGMgPSBCeXRlcy5zZXQgYnVmICFwb3MgYzsgaW5jciBwb3MgaW5cbiAgICBsZXQgbGVmdCA9IHJlZiAoKGRpZ2l0cyAtIDEpIG1vZCAzICsgMSkgaW5cbiAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgbWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgJzAnLi4nOScgYXMgYyAtPlxuICAgICAgICAgIGlmICFsZWZ0ID0gMCB0aGVuIChwdXQgJ18nOyBsZWZ0IDo9IDMpOyBkZWNyIGxlZnQ7IHB1dCBjXG4gICAgICB8IGMgLT4gcHV0IGNcbiAgICBkb25lO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYnVmXG4gIHwgXyAtPiBzXG5cbigqIENvbnZlcnQgYW4gaW50ZWdlciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gYSBjb252ZXJzaW9uLiAqKVxubGV0IGNvbnZlcnRfaW50IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludCAoZm9ybWF0X29mX2ljb252IGljb252KSBuKVxubGV0IGNvbnZlcnRfaW50MzIgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfaW50MzIgKGZvcm1hdF9vZl9pY29udmwgaWNvbnYpIG4pXG5sZXQgY29udmVydF9uYXRpdmVpbnQgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfbmF0aXZlaW50IChmb3JtYXRfb2ZfaWNvbnZuIGljb252KSBuKVxubGV0IGNvbnZlcnRfaW50NjQgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfaW50NjQgKGZvcm1hdF9vZl9pY29udkwgaWNvbnYpIG4pXG5cbigqIENvbnZlcnQgYSBmbG9hdCB0byBzdHJpbmcuICopXG4oKiBGaXggc3BlY2lhbCBjYXNlIG9mIFwiT0NhbWwgZmxvYXQgZm9ybWF0XCIuICopXG5sZXQgY29udmVydF9mbG9hdCBmY29udiBwcmVjIHggPVxuICBsZXQgaGV4ICgpID1cbiAgICBsZXQgc2lnbiA9XG4gICAgICBtYXRjaCBmc3QgZmNvbnYgd2l0aFxuICAgICAgfCBGbG9hdF9mbGFnX3AgLT4gJysnXG4gICAgICB8IEZsb2F0X2ZsYWdfcyAtPiAnICdcbiAgICAgIHwgXyAtPiAnLScgaW5cbiAgICBoZXhzdHJpbmdfb2ZfZmxvYXQgeCBwcmVjIHNpZ24gaW5cbiAgbGV0IGFkZF9kb3RfaWZfbmVlZGVkIHN0ciA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgbGV0IHJlYyBpc192YWxpZCBpID1cbiAgICAgIGlmIGkgPSBsZW4gdGhlbiBmYWxzZSBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICB8ICcuJyB8ICdlJyB8ICdFJyAtPiB0cnVlXG4gICAgICAgIHwgXyAtPiBpc192YWxpZCAoaSArIDEpIGluXG4gICAgaWYgaXNfdmFsaWQgMCB0aGVuIHN0ciBlbHNlIHN0ciBeIFwiLlwiIGluXG4gIGxldCBjYW1sX3NwZWNpYWxfdmFsIHN0ciA9IG1hdGNoIGNsYXNzaWZ5X2Zsb2F0IHggd2l0aFxuICAgIHwgRlBfbm9ybWFsIHwgRlBfc3Vibm9ybWFsIHwgRlBfemVybyAtPiBzdHJcbiAgICB8IEZQX2luZmluaXRlIC0+IGlmIHggPCAwLjAgdGhlbiBcIm5lZ19pbmZpbml0eVwiIGVsc2UgXCJpbmZpbml0eVwiXG4gICAgfCBGUF9uYW4gLT4gXCJuYW5cIiBpblxuICBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2ggLT4gaGV4ICgpXG4gIHwgRmxvYXRfSCAtPiBTdHJpbmcudXBwZXJjYXNlX2FzY2lpIChoZXggKCkpXG4gIHwgRmxvYXRfQ0YgLT4gY2FtbF9zcGVjaWFsX3ZhbCAoaGV4ICgpKVxuICB8IEZsb2F0X0YgLT5cbiAgICBsZXQgc3RyID0gZm9ybWF0X2Zsb2F0IChmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYykgeCBpblxuICAgIGNhbWxfc3BlY2lhbF92YWwgKGFkZF9kb3RfaWZfbmVlZGVkIHN0cilcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfRyAtPlxuICAgIGZvcm1hdF9mbG9hdCAoZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMpIHhcblxuKCogQ29udmVydCBhIGNoYXIgdG8gYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBPQ2FtbCBsZXhpY2FsIGNvbnZlbnRpb24uICopXG5sZXQgZm9ybWF0X2NhbWxfY2hhciBjID1cbiAgbGV0IHN0ciA9IENoYXIuZXNjYXBlZCBjIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKGwgKyAyKSAnXFwnJyBpblxuICBTdHJpbmcudW5zYWZlX2JsaXQgc3RyIDAgcmVzIDEgbDtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogQ29udmVydCBhIGZvcm1hdCB0eXBlIHRvIHN0cmluZyAqKVxubGV0IHN0cmluZ19vZl9mbXR0eSBmbXR0eSA9XG4gIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gIGJwcmludF9mbXR0eSBidWYgZm10dHk7XG4gIGJ1ZmZlcl9jb250ZW50cyBidWZcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICgqIEdlbmVyaWMgcHJpbnRpbmcgZnVuY3Rpb24gKilcblxuKCogTWFrZSBhIGdlbmVyaWMgcHJpbnRpbmcgZnVuY3Rpb24uICopXG4oKiBVc2VkIHRvIGdlbmVyYXRlIFByaW50ZiBhbmQgRm9ybWF0IHByaW50aW5nIGZ1bmN0aW9ucy4gKilcbigqIFBhcmFtZXRlcnM6XG4gICAgIGs6IGEgY29udGludWF0aW9uIGZpbmFsbHkgYXBwbGllZCB0byB0aGUgb3V0cHV0IHN0cmVhbSBhbmQgdGhlIGFjY3VtdWxhdG9yLlxuICAgICBvOiB0aGUgb3V0cHV0IHN0cmVhbSAoc2VlIGssICVhIGFuZCAldCkuXG4gICAgIGFjYzogcmV2IGxpc3Qgb2YgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1c2gsIGZvcm1hdHRpbmcsIC4uLikuXG4gICAgIGZtdDogdGhlIGZvcm1hdC4gKilcbmxldCByZWMgbWFrZV9wcmludGYgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBDaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9jaGFyIChhY2MsIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZvcm1hdF9jYW1sX2NoYXIgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIChmdW4gc3RyIC0+IHN0cilcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIGFjYyByZXN0IHBhZCBzdHJpbmdfdG9fY2FtbF9zdHJpbmdcbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludCBpY29udlxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQzMiBpY29udlxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfbmF0aXZlaW50IGljb252XG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDY0IGljb252XG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGZjb252XG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIGFjYyByZXN0IHBhZCBzdHJpbmdfb2ZfYm9vbFxuICB8IEFscGhhIHJlc3QgLT5cbiAgICBmdW4gZiB4IC0+IG1ha2VfcHJpbnRmIGsgKEFjY19kZWxheSAoYWNjLCBmdW4gbyAtPiBmIG8geCkpIHJlc3RcbiAgfCBUaGV0YSByZXN0IC0+XG4gICAgZnVuIGYgLT4gbWFrZV9wcmludGYgayAoQWNjX2RlbGF5IChhY2MsIGYpKSByZXN0XG4gIHwgQ3VzdG9tIChhcml0eSwgZiwgcmVzdCkgLT5cbiAgICBtYWtlX2N1c3RvbSBrIGFjYyByZXN0IGFyaXR5IChmICgpKVxuICB8IFJlYWRlciBfIC0+XG4gICAgKCogVGhpcyBjYXNlIGlzIGltcG9zc2libGUsIGJ5IHR5cGluZyBvZiBmb3JtYXRzLiAqKVxuICAgICgqIEluZGVlZCwgc2luY2UgcHJpbnRmIGFuZCBjby4gdGFrZSBhIGZvcm1hdDQgYXMgYXJndW1lbnQsIHRoZSAnZCBhbmQgJ2VcbiAgICAgICB0eXBlIHBhcmFtZXRlcnMgb2YgZm10IGFyZSBvYnZpb3VzbHkgZXF1YWxzLiBUaGUgUmVhZGVyIGlzIHRoZVxuICAgICAgIG9ubHkgY29uc3RydWN0b3Igd2hpY2ggdG91Y2ggJ2QgYW5kICdlIHR5cGUgcGFyYW1ldGVycyBvZiB0aGUgZm9ybWF0XG4gICAgICAgdHlwZSwgaXQgYWRkcyBhbiAoLT4pIHRvIHRoZSAnZCBwYXJhbWV0ZXJzLiBDb25zZXF1ZW50bHksIGEgZm9ybWF0NFxuICAgICAgIGNhbm5vdCBjb250YWluIGEgUmVhZGVyIG5vZGUsIGV4Y2VwdCBpbiB0aGUgc3ViLWZvcm1hdCBhc3NvY2lhdGVkIHRvXG4gICAgICAgYW4gJXsuLi4lfS4gSXQncyBub3QgYSBwcm9ibGVtIGJlY2F1c2UgbWFrZV9wcmludGYgZG8gbm90IGNhbGxcbiAgICAgICBpdHNlbGYgcmVjdXJzaXZlbHkgb24gdGhlIHN1Yi1mb3JtYXQgYXNzb2NpYXRlZCB0byAley4uLiV9LiAqKVxuICAgIGFzc2VydCBmYWxzZVxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfZmx1c2ggYWNjKSByZXN0XG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19zdHJpbmdfbGl0ZXJhbCAoYWNjLCBzdHIpKSByZXN0XG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX2NoYXJfbGl0ZXJhbCAoYWNjLCBjaHIpKSByZXN0XG5cbiAgfCBGb3JtYXRfYXJnIChfLCBzdWJfZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gc3RyaW5nX29mX2ZtdHR5IHN1Yl9mbXR0eSBpblxuICAgIChmdW4gc3RyIC0+XG4gICAgICBpZ25vcmUgc3RyO1xuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHR5KSkgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAtPlxuICAgIGZ1biAoRm9ybWF0IChmbXQsIF8pKSAtPiBtYWtlX3ByaW50ZiBrIGFjY1xuICAgICAgKGNvbmNhdF9mbXQgKHJlY2FzdCBmbXQgZm10dHkpIHJlc3QpXG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPlxuICAgIGxldCBuZXdfYWNjID0gQWNjX2ludmFsaWRfYXJnIChhY2MsIFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlW1wiKSBpblxuICAgIGZ1biBfIC0+IG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT5cbiAgICAoKiBUaGlzIGNhc2Ugc2hvdWxkIGJlIHJlZnVzZWQgZm9yIFByaW50Zi4gKilcbiAgICAoKiBBY2NlcHRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gKilcbiAgICAoKiBJbnRlcnByZXQgJWwsICVuIGFuZCAlTCBhcyAldS4gKilcbiAgICBmdW4gbiAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZm9ybWF0X2ludCBcIiV1XCIgbikgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIG1ha2VfaWdub3JlZF9wYXJhbSBrIGFjYyBpZ24gcmVzdFxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX2Zvcm1hdHRpbmdfbGl0IChhY2MsIGZtdGluZ19saXQpKSByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBsZXQgaycga2FjYyA9XG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZm9ybWF0dGluZ19nZW4gKGFjYywgQWNjX29wZW5fdGFnIGthY2MpKSByZXN0IGluXG4gICAgbWFrZV9wcmludGYgaycgRW5kX29mX2FjYyBmbXQnXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBsZXQgaycga2FjYyA9XG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZm9ybWF0dGluZ19nZW4gKGFjYywgQWNjX29wZW5fYm94IGthY2MpKSByZXN0IGluXG4gICAgbWFrZV9wcmludGYgaycgRW5kX29mX2FjYyBmbXQnXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgayBhY2NcblxuKCogRGVsYXkgdGhlIGVycm9yIChJbnZhbGlkX2FyZ3VtZW50IFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlX1wiKS4gKilcbigqIEdlbmVyYXRlIGZ1bmN0aW9ucyB0byB0YWtlIHJlbWFpbmluZyBhcmd1bWVudHMgKGFmdGVyIHRoZSBcIiVfXCIpLiAqKVxuYW5kIG1ha2VfaWdub3JlZF9wYXJhbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfaW50MzIgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfZmxvYXQgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChfLCBmbXR0eSkgLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIGZtdHR5IGZtdFxuICB8IElnbm9yZWRfcmVhZGVyICAgICAgICAgICAgICAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG5cblxuKCogU3BlY2lhbCBjYXNlIG9mIHByaW50ZiBcIiVfKFwiLiAqKVxuYW5kIG1ha2VfZnJvbV9mbXR0eSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGZtdHR5IC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBmbXR0eSBmbXQgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEludF90eSByZXN0ICAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEludDMyX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEludDY0X3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEZsb2F0X3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEFscGhhX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQW55X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgUmVhZGVyX3R5IF8gICAgICAgICAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgXyAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgRm9ybWF0X2FyZ190eSAoXywgcmVzdCkgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgRW5kX29mX2ZtdHR5ICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIChjb25jYXRfZm10dHkgdHkgcmVzdCkgZm10XG5cbigqIEluc2VydCBhbiBBY2NfaW52YWxpZF9hcmcgaW4gdGhlIGFjY3VtdWxhdG9yIGFuZCBjb250aW51ZSB0byBnZW5lcmF0ZVxuICAgY2xvc3VyZXMgdG8gZ2V0IHRoZSByZW1haW5pbmcgYXJndW1lbnRzLiAqKVxuYW5kIG1ha2VfaW52YWxpZF9hcmcgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBmbXQgLT5cbiAgbWFrZV9wcmludGYgayAoQWNjX2ludmFsaWRfYXJnIChhY2MsIFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlX1wiKSkgZm10XG5cbigqIEZpeCBwYWRkaW5nLCB0YWtlIGl0IGFzIGFuIGV4dHJhIGludGVnZXIgYXJndW1lbnQgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfcGFkZGluZyA6IHR5cGUgeCB6IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB6IC0+IGEpIHBhZGRpbmcgLT4gKHogLT4gc3RyaW5nKSAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgdHJhbnMgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIHRyYW5zIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3aWR0aCkgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZml4X3BhZGRpbmcgcGFkdHkgd2lkdGggKHRyYW5zIHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5IC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgZm10XG5cbigqIEZpeCBwYWRkaW5nIGFuZCBwcmVjaXNpb24gZm9yIGludCwgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NC4gKilcbigqIFRha2Ugb25lIG9yIHR3byBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50cyBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gOiB0eXBlIHggeSB6IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPiAoaW50X2NvbnYgLT4geiAtPiBzdHJpbmcpIC0+XG4gICAgaW50X2NvbnYgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHByZWMgdHJhbnMgaWNvbnYgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IHRyYW5zIGljb252IHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcblxuKCogQ29udmVydCBhIGZsb2F0LCBmaXggcGFkZGluZyBhbmQgcHJlY2lzaW9uIGlmIG5lZWRlZC4gKilcbigqIFRha2UgdGhlIGZsb2F0IGFyZ3VtZW50IGFuZCBvbmUgb3IgdHdvIGV4dHJhIGludGVnZXIgYXJndW1lbnRzIGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX2Zsb2F0X3BhZGRpbmdfcHJlY2lzaW9uIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIGZsb2F0IC0+IGEpIHByZWNpc2lvbiAtPiBmbG9hdF9jb252IC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCBwcmVjIGZjb252IC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IChkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udikgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBwIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IChkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udikgeCBpblxuICAgICAgbGV0IHN0cicgPSBmaXhfcGFkZGluZyBwYWR0eSB3IHN0ciBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cicpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IChkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udikgeCBpblxuICAgICAgbGV0IHN0cicgPSBmaXhfcGFkZGluZyBwYWR0eSB3IHN0ciBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cicpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG5hbmQgbWFrZV9jdXN0b20gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IHggLT4geSA9XG4gIGZ1biBrIGFjYyByZXN0IGFyaXR5IGYgLT4gbWF0Y2ggYXJpdHkgd2l0aFxuICB8IEN1c3RvbV96ZXJvIC0+IG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBmKSkgcmVzdFxuICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+XG4gICAgZnVuIHggLT5cbiAgICAgIG1ha2VfY3VzdG9tIGsgYWNjIHJlc3QgYXJpdHkgKGYgeClcblxubGV0IGNvbnN0IHggXyA9IHhcblxubGV0IHJlYyBtYWtlX2lwcmludGYgOiB0eXBlIGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT4gc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbiAgZnVuIGsgbyBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IENoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgQ2FtbF9zdHJpbmcgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX3N0cmluZyAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfc3RyaW5nIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBJbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEludDMyIChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBOYXRpdmVpbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEludDY0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBGbG9hdCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgQm9vbCAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEJvb2wgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBCb29sIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBBbHBoYSByZXN0IC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IFRoZXRhIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX2N1c3RvbV9hcml0eSBrIG8gcmVzdCBhcml0eVxuICAgIHwgUmVhZGVyIF8gLT5cbiAgICAgICAgKCogVGhpcyBjYXNlIGlzIGltcG9zc2libGUsIGJ5IHR5cGluZyBvZiBmb3JtYXRzLiAgU2VlIHRoZVxuICAgICAgICAgICBub3RlIGluIHRoZSBjb3JyZXNwb25kaW5nIGNhc2UgZm9yIG1ha2VfcHJpbnRmLiAqKVxuICAgICAgICBhc3NlcnQgZmFsc2VcbiAgICB8IEZsdXNoIHJlc3QgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgRm9ybWF0X2FyZyAoXywgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpIC0+XG4gICAgICAgIGZ1biAoRm9ybWF0IChmbXQsIF8pKSAtPlxuICAgICAgICAgIG1ha2VfaXByaW50ZiBrIG9cbiAgICAgICAgICAgIChjb25jYXRfZm10IChyZWNhc3QgZm10IGZtdHR5KSByZXN0KVxuICAgIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaWdub3JlZF9wYXJhbSAoZnVuIF8gLT4gayBvKSAoRW5kX29mX2FjYykgaWduIHJlc3RcbiAgICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiAoZnVuIGtvYyAtPiBtYWtlX2lwcmludGYgayBrb2MgcmVzdCkgbyBmbXQnXG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgKGZ1biBrb2MgLT4gbWFrZV9pcHJpbnRmIGsga29jIHJlc3QpIG8gZm10J1xuICAgIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgICAgICBrIG9cbmFuZCBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiA6XG4gIHR5cGUgeCB5IHogYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPiBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPiB4ID1cbiAgZnVuIGsgbyBmbXQgcGFkIHByZWMgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgICAsIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBOb19wYWRkaW5nICAgLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTm9fcGFkZGluZyAgICwgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgTGl0X3BhZGRpbmcgXywgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IExpdF9wYWRkaW5nIF8sIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKSlcbmFuZCBmbl9vZl9jdXN0b21fYXJpdHkgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+XG4gIHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiB5ID1cbiAgZnVuIGsgbyBmbXQgLT4gZnVuY3Rpb25cbiAgICB8IEN1c3RvbV96ZXJvIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gZm10XG4gICAgfCBDdXN0b21fc3VjYyBhcml0eSAtPlxuICAgICAgICBjb25zdCAoZm5fb2ZfY3VzdG9tX2FyaXR5IGsgbyBmbXQgYXJpdHkpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIENvbnRpbnVhdGlvbnMgZm9yIG1ha2VfcHJpbnRmICopXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYW4gb3V0cHV0X3N0cmVhbS4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIG91dHB1dF9hY2MgbyBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBcIkB7XCI7IG91dHB1dF9hY2MgbyBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBcIkBbXCI7IG91dHB1dF9hY2MgbyBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9jaGFyIG8gY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgZiBvXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBmbHVzaCBvXG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IG91dHB1dF9hY2MgbyBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBidWZwdXRfYWNjIGIgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkB7XCI7IGJ1ZnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAW1wiOyBidWZwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBidWZwdXRfYWNjIGIgcDsgZiBiXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBidWZwdXRfYWNjIGIgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogRGlmZmVyIGZyb20gYnVmcHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgJWEgYW5kICV0LiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgc3RycHV0X2FjYyBiIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAe1wiOyBzdHJwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQFtcIjsgc3RycHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgKGYgKCkpXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IHN0cnB1dF9hY2MgYiBwO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBzdHJwdXRfYWNjIGIgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBFcnJvciBtYW5hZ2VtZW50ICopXG5cbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgcHJldHR5LXByaW50ZWQgZXJyb3IgbWVzc2FnZS4gKilcbmxldCBmYWlsd2l0aF9tZXNzYWdlIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMjU2IGluXG4gIGxldCBrIGFjYyA9IHN0cnB1dF9hY2MgYnVmIGFjYzsgZmFpbHdpdGggKEJ1ZmZlci5jb250ZW50cyBidWYpIGluXG4gIG1ha2VfcHJpbnRmIGsgRW5kX29mX2FjYyBmbXRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXR0aW5nIHRvb2xzICopXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYW4gb3BlbiBibG9jayBkZXNjcmlwdGlvbiAoaW5kZW50LCBibG9ja190eXBlKSAqKVxubGV0IG9wZW5fYm94X29mX3N0cmluZyBzdHIgPVxuICBpZiBzdHIgPSBcIlwiIHRoZW4gKDAsIFBwX2JveCkgZWxzZVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxldCBpbnZhbGlkX2JveCAoKSA9IGZhaWx3aXRoX21lc3NhZ2UgXCJpbnZhbGlkIGJveCBkZXNjcmlwdGlvbiAlU1wiIHN0ciBpblxuICAgIGxldCByZWMgcGFyc2Vfc3BhY2VzIGkgPVxuICAgICAgaWYgaSA9IGxlbiB0aGVuIGkgZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2ldIHdpdGhcbiAgICAgICAgfCAnICcgfCAnXFx0JyAtPiBwYXJzZV9zcGFjZXMgKGkgKyAxKVxuICAgICAgICB8IF8gLT4gaVxuICAgIGFuZCBwYXJzZV9sd29yZCBpIGogPVxuICAgICAgaWYgaiA9IGxlbiB0aGVuIGogZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2pdIHdpdGhcbiAgICAgICAgfCAnYScgLi4gJ3onIC0+IHBhcnNlX2x3b3JkIGkgKGogKyAxKVxuICAgICAgICB8IF8gLT4galxuICAgIGFuZCBwYXJzZV9pbnQgaSBqID1cbiAgICAgIGlmIGogPSBsZW4gdGhlbiBqIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltqXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBwYXJzZV9pbnQgaSAoaiArIDEpXG4gICAgICAgIHwgXyAtPiBqIGluXG4gICAgbGV0IHdzdGFydCA9IHBhcnNlX3NwYWNlcyAwIGluXG4gICAgbGV0IHdlbmQgPSBwYXJzZV9sd29yZCB3c3RhcnQgd3N0YXJ0IGluXG4gICAgbGV0IGJveF9uYW1lID0gU3RyaW5nLnN1YiBzdHIgd3N0YXJ0ICh3ZW5kIC0gd3N0YXJ0KSBpblxuICAgIGxldCBuc3RhcnQgPSBwYXJzZV9zcGFjZXMgd2VuZCBpblxuICAgIGxldCBuZW5kID0gcGFyc2VfaW50IG5zdGFydCBuc3RhcnQgaW5cbiAgICBsZXQgaW5kZW50ID1cbiAgICAgIGlmIG5zdGFydCA9IG5lbmQgdGhlbiAwIGVsc2VcbiAgICAgICAgdHJ5IGludF9vZl9zdHJpbmcgKFN0cmluZy5zdWIgc3RyIG5zdGFydCAobmVuZCAtIG5zdGFydCkpXG4gICAgICAgIHdpdGggRmFpbHVyZSBfIC0+IGludmFsaWRfYm94ICgpIGluXG4gICAgbGV0IGV4cF9lbmQgPSBwYXJzZV9zcGFjZXMgbmVuZCBpblxuICAgIGlmIGV4cF9lbmQgPD4gbGVuIHRoZW4gaW52YWxpZF9ib3ggKCk7XG4gICAgbGV0IGJveF90eXBlID0gbWF0Y2ggYm94X25hbWUgd2l0aFxuICAgICAgfCBcIlwiIHwgXCJiXCIgLT4gUHBfYm94XG4gICAgICB8IFwiaFwiICAgICAgLT4gUHBfaGJveFxuICAgICAgfCBcInZcIiAgICAgIC0+IFBwX3Zib3hcbiAgICAgIHwgXCJodlwiICAgICAtPiBQcF9odmJveFxuICAgICAgfCBcImhvdlwiICAgIC0+IFBwX2hvdmJveFxuICAgICAgfCBfICAgICAgICAtPiBpbnZhbGlkX2JveCAoKSBpblxuICAgIChpbmRlbnQsIGJveF90eXBlKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFBhcnNpbmcgdG9vbHMgKilcblxuKCogQ3JlYXRlIGEgcGFkZGluZ19mbXRfZWJiIGZyb20gYSBwYWRkaW5nIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHBhZGRpbmcgdG8gZGlzam9pbiB0aGUgdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50IGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgOiB0eXBlIHggeSAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgICAgKF8sIF8sIF8sIF8sIF8pIHBhZGRpbmdfZm10X2ViYiA9XG5mdW4gcGFkIGZtdCAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgICAgICAgICAtPiBQYWRkaW5nX2ZtdF9FQkIgKE5vX3BhZGRpbmcsIGZtdClcbiAgfCBMaXRfcGFkZGluZyAocywgdykgLT4gUGFkZGluZ19mbXRfRUJCIChMaXRfcGFkZGluZyAocywgdyksIGZtdClcbiAgfCBBcmdfcGFkZGluZyBzICAgICAgLT4gUGFkZGluZ19mbXRfRUJCIChBcmdfcGFkZGluZyBzLCBmbXQpXG5cbigqIENyZWF0ZSBhIHByZWNpc2lvbl9mbXRfZWJiIGZyb20gYSBwcmVjaXNpb24gYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcHJlY2lzaW9uIHRvIGRpc2pvaW4gdGhlIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudCBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgOiB0eXBlIHggeSAuXG4gICAgKHgsIHkpIHByZWNpc2lvbiAtPiAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgICAoXywgXywgXywgXywgXykgcHJlY2lzaW9uX2ZtdF9lYmIgPVxuZnVuIHByZWMgZm10IC0+IG1hdGNoIHByZWMgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiAgICAtPiBQcmVjaXNpb25fZm10X0VCQiAoTm9fcHJlY2lzaW9uLCBmbXQpXG4gIHwgTGl0X3ByZWNpc2lvbiBwIC0+IFByZWNpc2lvbl9mbXRfRUJCIChMaXRfcHJlY2lzaW9uIHAsIGZtdClcbiAgfCBBcmdfcHJlY2lzaW9uICAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKEFyZ19wcmVjaXNpb24sIGZtdClcblxuKCogQ3JlYXRlIGEgcGFkcHJlY19mbXRfZWJiIGZyb20gYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwYWRkaW5nIGFuZCB0aGUgcHJlY2lzaW9uIHRvIGRpc2pvaW4gdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50c1xuICAgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3BhZHByZWNfZm10X2ViYiA6IHR5cGUgeCB5IHogdCAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHosIHQpIHByZWNpc2lvbiAtPlxuICAgIChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAoXywgXywgXywgXywgXykgcGFkcHJlY19mbXRfZWJiID1cbmZ1biBwYWQgcHJlYyBmbXQgLT5cbiAgbGV0IFByZWNpc2lvbl9mbXRfRUJCIChwcmVjLCBmbXQnKSA9IG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgcHJlYyBmbXQgaW5cbiAgbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nICAgICAgICAgLT4gUGFkcHJlY19mbXRfRUJCIChOb19wYWRkaW5nLCBwcmVjLCBmbXQnKVxuICB8IExpdF9wYWRkaW5nIChzLCB3KSAtPiBQYWRwcmVjX2ZtdF9FQkIgKExpdF9wYWRkaW5nIChzLCB3KSwgcHJlYywgZm10JylcbiAgfCBBcmdfcGFkZGluZyBzICAgICAgLT4gUGFkcHJlY19mbXRfRUJCIChBcmdfcGFkZGluZyBzLCBwcmVjLCBmbXQnKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgcGFyc2luZyAqKVxuXG4oKiBQYXJzZSBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBmb3JtYXQgYW5kIGNyZWF0ZSBhIGZtdF9lYmIuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gaW4gY2FzZSBvZiBpbnZhbGlkIGZvcm1hdC4gKilcbmxldCBmbXRfZWJiX29mX3N0cmluZyA/bGVnYWN5X2JlaGF2aW9yIHN0ciA9XG4gICgqIFBhcmFtZXRlcnMgbmFtaW5nIGNvbnZlbnRpb246ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIGxpdF9zdGFydDogc3RhcnQgb2YgdGhlIGxpdGVyYWwgc2VxdWVuY2UuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gc3RyX2luZDogY3VycmVudCBpbmRleCBpbiB0aGUgc3RyaW5nLiAgICAgICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBlbmRfaW5kOiBlbmQgb2YgdGhlIGN1cnJlbnQgKHN1Yi0pZm9ybWF0LiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHBjdF9pbmQ6IGluZGV4IG9mIHRoZSAnJScgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAqKVxuICAoKiAgIC0gemVybzogIGlzIHRoZSAnMCcgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBtaW51czogaXMgdGhlICctJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHBsdXM6ICBpcyB0aGUgJysnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gaGFzaDogIGlzIHRoZSAnIycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBzcGFjZTogaXMgdGhlICcgJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIGlnbjogICBpcyB0aGUgJ18nIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gcGFkOiBwYWRkaW5nIG9mIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBwcmVjOiBwcmVjaXNpb24gb2YgdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHN5bWI6IGNoYXIgcmVwcmVzZW50aW5nIHRoZSBjb252ZXJzaW9uICgnYycsICdzJywgJ2QnLCAuLi4pLiAqKVxuICAoKiAgIC0gY2hhcl9zZXQ6IHNldCBvZiBjaGFyYWN0ZXJzIGFzIGJpdG1hcCAoc2VlIHNjYW5mICVbLi4uXSkuICAgICopXG5cbiAgbGV0IGxlZ2FjeV9iZWhhdmlvciA9IG1hdGNoIGxlZ2FjeV9iZWhhdmlvciB3aXRoXG4gICAgfCBTb21lIGZsYWcgLT4gZmxhZ1xuICAgIHwgTm9uZSAtPiB0cnVlXG4gICgqICBXaGVuIHRoaXMgZmxhZyBpcyBlbmFibGVkLCB0aGUgZm9ybWF0IHBhcnNlciB0cmllcyB0byBiZWhhdmUgYXNcbiAgICAgIHRoZSA8NC4wMiBpbXBsZW1lbnRhdGlvbnMsIGluIHBhcnRpY3VsYXIgaXQgaWdub3JlcyBtb3N0IGJlbmluZVxuICAgICAgbm9uc2Vuc2ljYWwgZm9ybWF0LiBXaGVuIHRoZSBmbGFnIGlzIGRpc2FibGVkLCBpdCB3aWxsIHJlamVjdCBhbnlcbiAgICAgIGZvcm1hdCB0aGF0IGlzIG5vdCBhY2NlcHRlZCBieSB0aGUgc3BlY2lmaWNhdGlvbi5cblxuICAgICAgQSB0eXBpY2FsIGV4YW1wbGUgd291bGQgYmUgXCIlKyBkXCI6IHNwZWNpZnlpbmcgYm90aCAnKycgKGlmIHRoZVxuICAgICAgbnVtYmVyIGlzIHBvc2l0aXZlLCBwYWQgd2l0aCBhICcrJyB0byBnZXQgdGhlIHNhbWUgd2lkdGggYXNcbiAgICAgIG5lZ2F0aXZlIG51bWJlcnMpIGFuZCAnICcgKGlmIHRoZSBudW1iZXIgaXMgcG9zaXRpdmUsIHBhZCB3aXRoXG4gICAgICBhIHNwYWNlKSBkb2VzIG5vdCBtYWtlIHNlbnNlLCBidXQgdGhlIGxlZ2FjeSAoPCA0LjAyKVxuICAgICAgaW1wbGVtZW50YXRpb24gd2FzIGhhcHB5IHRvIGp1c3QgaWdub3JlIHRoZSBzcGFjZS5cbiAgKilcbiAgaW5cblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UuICopXG4gIGxldCBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIHN0cl9pbmQgbXNnID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAlc1wiXG4gICAgICBzdHIgc3RyX2luZCBtc2dcbiAgaW5cblxuICAoKiBVc2VkIHdoZW4gdGhlIGVuZCBvZiB0aGUgZm9ybWF0IChvciB0aGUgY3VycmVudCBzdWItZm9ybWF0KSB3YXMgZW5jb3VudGVyZWRcbiAgICAgIHVuZXhwZWN0ZWRseS4gKilcbiAgbGV0IHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kID1cbiAgICBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIGVuZF9pbmRcbiAgICAgIFwidW5leHBlY3RlZCBlbmQgb2YgZm9ybWF0XCJcbiAgaW5cblxuICAoKiBVc2VkIGZvciAlMGM6IG5vIG90aGVyIHdpZHRocyBhcmUgaW1wbGVtZW50ZWQgKilcbiAgbGV0IGludmFsaWRfbm9ubnVsbF9jaGFyX3dpZHRoIHN0cl9pbmQgPVxuICAgIGludmFsaWRfZm9ybWF0X21lc3NhZ2Ugc3RyX2luZFxuICAgICAgXCJub24temVybyB3aWR0aHMgYXJlIHVuc3VwcG9ydGVkIGZvciAlYyBjb252ZXJzaW9uc1wiXG4gIGluXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBhbiBvcHRpb24gZGVwZW5kZW5jeVxuICAgICBwcm9ibGVtLiAqKVxuICBsZXQgaW52YWxpZF9mb3JtYXRfd2l0aG91dCBzdHJfaW5kIGMgcyA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJyVjJyB3aXRob3V0ICVzXCJcbiAgICAgIHN0ciBzdHJfaW5kIGMgc1xuICBpblxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBhbiB1bmV4cGVjdGVkXG4gICAgIGNoYXJhY3Rlci4gKilcbiAgbGV0IGV4cGVjdGVkX2NoYXJhY3RlciBzdHJfaW5kIGV4cGVjdGVkIHJlYWQgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJXMgZXhwZWN0ZWQsIHJlYWQgJUNcIlxuICAgICAgc3RyIHN0cl9pbmQgZXhwZWN0ZWQgcmVhZFxuICBpblxuXG4gICgqIFBhcnNlIHRoZSBzdHJpbmcgZnJvbSBiZWdfaW5kIChpbmNsdWRlZCkgdG8gZW5kX2luZCAoZXhjbHVkZWQpLiAqKVxuICBsZXQgcmVjIHBhcnNlIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGJlZ19pbmQgZW5kX2luZCAtPiBwYXJzZV9saXRlcmFsIGJlZ19pbmQgYmVnX2luZCBlbmRfaW5kXG5cbiAgKCogUmVhZCBsaXRlcmFsIGNoYXJhY3RlcnMgdXAgdG8gJyUnIG9yICdAJyBzcGVjaWFsIGNoYXJhY3RlcnMuICopXG4gIGFuZCBwYXJzZV9saXRlcmFsIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBsaXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBFbmRfb2ZfZm9ybWF0IGVsc2VcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZV9mb3JtYXQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIGZtdF9yZXN0XG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlX2FmdGVyX2F0IChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBmbXRfcmVzdFxuICAgICAgfCBfIC0+XG4gICAgICAgIHBhcnNlX2xpdGVyYWwgbGl0X3N0YXJ0IChzdHJfaW5kICsgMSkgZW5kX2luZFxuXG4gICgqIFBhcnNlIGEgZm9ybWF0IGFmdGVyICclJyAqKVxuICBhbmQgcGFyc2VfZm9ybWF0IDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgZW5kX2luZCAtPiBwYXJzZV9pZ24gcGN0X2luZCAocGN0X2luZCArIDEpIGVuZF9pbmRcblxuICBhbmQgcGFyc2VfaWduIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdfJyAtPiBwYXJzZV9mbGFncyBwY3RfaW5kIChzdHJfaW5kKzEpIGVuZF9pbmQgdHJ1ZVxuICAgICAgfCBfIC0+IHBhcnNlX2ZsYWdzIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIGZhbHNlXG5cbiAgYW5kIHBhcnNlX2ZsYWdzIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiXG4gID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIGlnbiAtPlxuICAgIGxldCB6ZXJvID0gcmVmIGZhbHNlIGFuZCBtaW51cyA9IHJlZiBmYWxzZVxuICAgIGFuZCBwbHVzID0gcmVmIGZhbHNlIGFuZCBzcGFjZSA9IHJlZiBmYWxzZVxuICAgIGFuZCBoYXNoID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IHNldF9mbGFnIHN0cl9pbmQgZmxhZyA9XG4gICAgICAoKiBpbiBsZWdhY3kgbW9kZSwgZHVwbGljYXRlIGZsYWdzIGFyZSBhY2NlcHRlZCAqKVxuICAgICAgaWYgIWZsYWcgJiYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBkdXBsaWNhdGUgZmxhZyAlQ1wiXG4gICAgICAgICAgc3RyIHN0cl9pbmQgc3RyLltzdHJfaW5kXTtcbiAgICAgIGZsYWcgOj0gdHJ1ZTtcbiAgICBpblxuICAgIGxldCByZWMgcmVhZF9mbGFncyBzdHJfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzAnIC0+IHNldF9mbGFnIHN0cl9pbmQgemVybzsgIHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnLScgLT4gc2V0X2ZsYWcgc3RyX2luZCBtaW51czsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcrJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHBsdXM7ICByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJyMnIC0+IHNldF9mbGFnIHN0cl9pbmQgaGFzaDsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcgJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHNwYWNlOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgXyAtPlxuICAgICAgICBwYXJzZV9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kXG4gICAgICAgICAgIXplcm8gIW1pbnVzICFwbHVzICFoYXNoICFzcGFjZSBpZ25cbiAgICAgIGVuZFxuICAgIGluXG4gICAgcmVhZF9mbGFncyBzdHJfaW5kXG5cbiAgKCogVHJ5IHRvIHJlYWQgYSBkaWdpdGFsIG9yIGEgJyonIHBhZGRpbmcuICopXG4gIGFuZCBwYXJzZV9wYWRkaW5nIDogdHlwZSBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgemVybyBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFkdHkgPSBtYXRjaCB6ZXJvLCBtaW51cyB3aXRoXG4gICAgICB8IGZhbHNlLCBmYWxzZSAtPiBSaWdodFxuICAgICAgfCBmYWxzZSwgdHJ1ZSAgLT4gTGVmdFxuICAgICAgfCAgdHJ1ZSwgZmFsc2UgLT4gWmVyb3NcbiAgICAgIHwgIHRydWUsIHRydWUgIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIExlZnRcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJy0nIFwiMFwiIGluXG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+XG4gICAgICBsZXQgbmV3X2luZCwgd2lkdGggPSBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMCBpblxuICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIG5ld19pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIChMaXRfcGFkZGluZyAocGFkdHksIHdpZHRoKSlcbiAgICB8ICcqJyAtPlxuICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2VcbiAgICAgICAgaWduIChBcmdfcGFkZGluZyBwYWR0eSlcbiAgICB8IF8gLT5cbiAgICAgIGJlZ2luIG1hdGNoIHBhZHR5IHdpdGhcbiAgICAgIHwgTGVmdCAgLT5cbiAgICAgICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICAgaW52YWxpZF9mb3JtYXRfd2l0aG91dCAoc3RyX2luZCAtIDEpICctJyBcInBhZGRpbmdcIjtcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgTm9fcGFkZGluZ1xuICAgICAgfCBaZXJvcyAtPlxuICAgICAgICAgKCogYSAnMCcgcGFkZGluZyBpbmRpY2F0aW9uIG5vdCBmb2xsb3dlZCBieSBhbnl0aGluZyBzaG91bGRcbiAgICAgICAgICAgYmUgaW50ZXJwcmV0ZWQgYXMgYSBSaWdodCBwYWRkaW5nIG9mIHdpZHRoIDAuIFRoaXMgaXMgdXNlZFxuICAgICAgICAgICBieSBzY2FubmluZyBjb252ZXJzaW9ucyAlMHMgYW5kICUwYyAqKVxuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICAoTGl0X3BhZGRpbmcgKFJpZ2h0LCAwKSlcbiAgICAgIHwgUmlnaHQgLT5cbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgTm9fcGFkZGluZ1xuICAgICAgZW5kXG5cbiAgKCogSXMgcHJlY2lzaW9uIGRlZmluZWQ/ICopXG4gIGFuZCBwYXJzZV9hZnRlcl9wYWRkaW5nIDogdHlwZSB4IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIF8pIHBhZGRpbmcgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJy4nIC0+XG4gICAgICBwYXJzZV9wcmVjaXNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICBwYWRcbiAgICB8IHN5bWIgLT5cbiAgICAgIHBhcnNlX2NvbnZlcnNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWRcbiAgICAgICAgTm9fcHJlY2lzaW9uIHBhZCBzeW1iXG5cbiAgKCogUmVhZCB0aGUgZGlnaXRhbCBvciAnKicgcHJlY2lzaW9uLiAqKVxuICBhbmQgcGFyc2VfcHJlY2lzaW9uIDogdHlwZSB4IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIF8pIHBhZGRpbmcgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYXJzZV9saXRlcmFsIG1pbnVzIHN0cl9pbmQgPVxuICAgICAgbGV0IG5ld19pbmQsIHByZWMgPSBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMCBpblxuICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgbmV3X2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgcGFkIChMaXRfcHJlY2lzaW9uIHByZWMpIGluXG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX2xpdGVyYWwgbWludXMgc3RyX2luZFxuICAgIHwgKCcrJyB8ICctJykgYXMgc3ltYiB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPlxuICAgICAgKCogTGVnYWN5IG1vZGUgd291bGQgYWNjZXB0IGFuZCBpZ25vcmUgJysnIG9yICctJyBiZWZvcmUgdGhlXG4gICAgICAgICBpbnRlZ2VyIGRlc2NyaWJpbmcgdGhlIGRlc2lyZWQgcHJlY2lzaW9uOyBub3RlIHRoYXQgdGhpc1xuICAgICAgICAgY2Fubm90IGhhcHBlbiBmb3IgcGFkZGluZyB3aWR0aCwgYXMgJysnIGFuZCAnLScgYWxyZWFkeSBoYXZlXG4gICAgICAgICBhIHNlbWFudGljcyB0aGVyZS5cblxuICAgICAgICAgVGhhdCBzYWlkLCB0aGUgaWRlYSAoc3VwcG9ydGVkIGJ5IHRoaXMgdHdlYWspIHRoYXQgd2lkdGggYW5kXG4gICAgICAgICBwcmVjaXNpb24gbGl0ZXJhbHMgYXJlIFwiaW50ZWdlciBsaXRlcmFsc1wiIGluIHRoZSBPQ2FtbCBzZW5zZSBpc1xuICAgICAgICAgc3RpbGwgYmxhdGFudGx5IHdyb25nLCBhcyAxMjNfNDU2IG9yIDB4RkYgYXJlIHJlamVjdGVkLiAqKVxuICAgICAgcGFyc2VfbGl0ZXJhbCAobWludXMgfHwgc3ltYiA9ICctJykgKHN0cl9pbmQgKyAxKVxuICAgIHwgJyonIC0+XG4gICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlXG4gICAgICAgIGlnbiBwYWQgQXJnX3ByZWNpc2lvblxuICAgIHwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogbm90ZSB0aGF0IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBkaWQgbm90IGlnbm9yZSAnLicgd2l0aG91dFxuICAgICAgICAgICBhIG51bWJlciAoYXMgaXQgZG9lcyBmb3IgcGFkZGluZyBpbmRpY2F0aW9ucyksIGJ1dFxuICAgICAgICAgICBpbnRlcnByZXRzIGl0IGFzICcuMCcgKilcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBwYWQgKExpdF9wcmVjaXNpb24gMClcbiAgICAgIGVsc2VcbiAgICAgICAgaW52YWxpZF9mb3JtYXRfd2l0aG91dCAoc3RyX2luZCAtIDEpICcuJyBcInByZWNpc2lvblwiXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIGNvbnZlcnNpb24uICopXG4gIGFuZCBwYXJzZV9hZnRlcl9wcmVjaXNpb24gOiB0eXBlIHggeSB6IHQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgeSkgcGFkZGluZyAtPiAoeiwgdCkgcHJlY2lzaW9uIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIHByZWMgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYXJzZV9jb252ICh0eXBlIHUpICh0eXBlIHYpIChwYWRwcmVjIDogKHUsIHYpIHBhZGRpbmcpID1cbiAgICAgIHBhcnNlX2NvbnZlcnNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWRcbiAgICAgICAgcHJlYyBwYWRwcmVjIHN0ci5bc3RyX2luZF0gaW5cbiAgICAoKiBpbiBsZWdhY3kgbW9kZSwgc29tZSBmb3JtYXRzICglcyBhbmQgJVMpIGFjY2VwdCBhIHdlaXJkIG1peCBvZlxuICAgICAgIHBhZGRpbmcgYW5kIHByZWNpc2lvbiwgd2hpY2ggaXMgbWVyZ2VkIGFzIGEgc2luZ2xlIHBhZGRpbmdcbiAgICAgICBpbmZvcm1hdGlvbi4gRm9yIGV4YW1wbGUsIGluICUuMTBzIHRoZSBwcmVjaXNpb24gaXMgaW1wbGljaXRseVxuICAgICAgIHVuZGVyc3Rvb2QgYXMgcGFkZGluZyAlMTBzLCBidXQgdGhlIGxlZnQtcGFkZGluZyBjb21wb25lbnQgbWF5XG4gICAgICAgYmUgc3BlY2lmaWVkIGVpdGhlciBhcyBhIGxlZnQgcGFkZGluZyBvciBhIG5lZ2F0aXZlIHByZWNpc2lvbjpcbiAgICAgICAlLS4zcyBhbmQgJS4tM3MgYXJlIGVxdWl2YWxlbnQgdG8gJS0zcyAqKVxuICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgfCBOb19wYWRkaW5nIC0+IChcbiAgICAgIG1hdGNoIG1pbnVzLCBwcmVjIHdpdGhcbiAgICAgICAgfCBfLCBOb19wcmVjaXNpb24gLT4gcGFyc2VfY29udiBOb19wYWRkaW5nXG4gICAgICAgIHwgZmFsc2UsIExpdF9wcmVjaXNpb24gbiAtPiBwYXJzZV9jb252IChMaXRfcGFkZGluZyAoUmlnaHQsIG4pKVxuICAgICAgICB8IHRydWUsIExpdF9wcmVjaXNpb24gbiAtPiBwYXJzZV9jb252IChMaXRfcGFkZGluZyAoTGVmdCwgbikpXG4gICAgICAgIHwgZmFsc2UsIEFyZ19wcmVjaXNpb24gLT4gcGFyc2VfY29udiAoQXJnX3BhZGRpbmcgUmlnaHQpXG4gICAgICAgIHwgdHJ1ZSwgQXJnX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IChBcmdfcGFkZGluZyBMZWZ0KVxuICAgIClcbiAgICB8IHBhZCAtPiBwYXJzZV9jb252IHBhZFxuXG4gICgqIENhc2UgYW5hbHlzaXMgb24gY29udmVyc2lvbi4gKilcbiAgYW5kIHBhcnNlX2NvbnZlcnNpb24gOiB0eXBlIHggeSB6IHQgdSB2IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+ICh4LCB5KSBwYWRkaW5nIC0+XG4gICAgICAgICh6LCB0KSBwcmVjaXNpb24gLT4gKHUsIHYpIHBhZGRpbmcgLT4gY2hhciAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCBwcmVjIHBhZHByZWMgc3ltYiAtPlxuICAgICgqIEZsYWdzIHVzZWQgdG8gY2hlY2sgb3B0aW9uIHVzYWdlcy9jb21wYXRpYmlsaXRpZXMuICopXG4gICAgbGV0IHBsdXNfdXNlZCAgPSByZWYgZmFsc2UgYW5kIGhhc2hfdXNlZCA9IHJlZiBmYWxzZVxuICAgIGFuZCBzcGFjZV91c2VkID0gcmVmIGZhbHNlIGFuZCBpZ25fdXNlZCAgID0gcmVmIGZhbHNlXG4gICAgYW5kIHBhZF91c2VkICAgPSByZWYgZmFsc2UgYW5kIHByZWNfdXNlZCAgPSByZWYgZmFsc2UgaW5cblxuICAgICgqIEFjY2VzcyB0byBvcHRpb25zLCB1cGRhdGUgZmxhZ3MuICopXG4gICAgbGV0IGdldF9wbHVzICAgICgpID0gcGx1c191c2VkICA6PSB0cnVlOyBwbHVzXG4gICAgYW5kIGdldF9oYXNoICAgKCkgPSBoYXNoX3VzZWQgOj0gdHJ1ZTsgaGFzaFxuICAgIGFuZCBnZXRfc3BhY2UgICAoKSA9IHNwYWNlX3VzZWQgOj0gdHJ1ZTsgc3BhY2VcbiAgICBhbmQgZ2V0X2lnbiAgICAgKCkgPSBpZ25fdXNlZCAgIDo9IHRydWU7IGlnblxuICAgIGFuZCBnZXRfcGFkICAgICAoKSA9IHBhZF91c2VkICAgOj0gdHJ1ZTsgcGFkXG4gICAgYW5kIGdldF9wcmVjICAgICgpID0gcHJlY191c2VkICA6PSB0cnVlOyBwcmVjXG4gICAgYW5kIGdldF9wYWRwcmVjICgpID0gcGFkX3VzZWQgICA6PSB0cnVlOyBwYWRwcmVjIGluXG5cbiAgICBsZXQgZ2V0X2ludF9wYWQgKCkgOiAoeCx5KSBwYWRkaW5nID1cbiAgICAgICgqICU1LjNkIGlzIGFjY2VwdGVkIGFuZCBtZWFuaW5nZnVsOiBwYWQgdG8gbGVuZ3RoIDUgd2l0aFxuICAgICAgICAgc3BhY2VzLCBidXQgZmlyc3QgcGFkIHdpdGggemVyb3MgdXB0byBsZW5ndGggMyAoMC1wYWRkaW5nXG4gICAgICAgICBpcyB0aGUgaW50ZXJwcmV0YXRpb24gb2YgXCJwcmVjaXNpb25cIiBmb3IgaW50ZWdlciBmb3JtYXRzKS5cblxuICAgICAgICAgJTA1LjNkIGlzIHJlZHVuZGFudDogcGFkIHRvIGxlbmd0aCA1ICp3aXRoIHplcm9zKiwgYnV0XG4gICAgICAgICBmaXJzdCBwYWQgd2l0aCB6ZXJvcy4uLiBUbyBhZGQgaW5zdWx0IHRvIHRoZSBpbmp1cnksIHRoZVxuICAgICAgICAgbGVnYWN5IGltcGxlbWVudGF0aW9uIGlnbm9yZXMgdGhlIDAtcGFkZGluZyBpbmRpY2F0aW9uIGFuZFxuICAgICAgICAgZG9lcyB0aGUgNSBwYWRkaW5nIHdpdGggc3BhY2VzIGluc3RlYWQuIFdlIHJldXNlIHRoaXNcbiAgICAgICAgIGludGVycHJldGF0aW9uIGZvciBjb21wYXRpYmlsaXR5LCBidXQgc3RhdGljYWxseSByZWplY3QgdGhpc1xuICAgICAgICAgZm9ybWF0IHdoZW4gdGhlIGxlZ2FjeSBtb2RlIGlzIGRpc2FibGVkLCB0byBwcm90ZWN0IHN0cmljdFxuICAgICAgICAgdXNlcnMgZnJvbSB0aGlzIGNvcm5lciBjYXNlLiAqKVxuICAgICAgIG1hdGNoIGdldF9wYWQgKCksIGdldF9wcmVjICgpIHdpdGhcbiAgICAgICAgIHwgcGFkLCBOb19wcmVjaXNpb24gLT4gcGFkXG4gICAgICAgICB8IE5vX3BhZGRpbmcsIF8gICAgIC0+IE5vX3BhZGRpbmdcbiAgICAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCBuKSwgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIG4pXG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IEFyZ19wYWRkaW5nIFplcm9zLCBfIC0+XG4gICAgICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IExpdF9wYWRkaW5nIF8gYXMgcGFkLCBfIC0+IHBhZFxuICAgICAgICAgfCBBcmdfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWQgaW5cblxuICAgICgqIENoZWNrIHRoYXQgcGFkdHkgPD4gWmVyb3MuICopXG4gICAgbGV0IGNoZWNrX25vXzAgc3ltYiAodHlwZSBhIGIpIChwYWQgOiAoYSwgYikgcGFkZGluZykgOiAoYSxiKSBwYWRkaW5nID1cbiAgICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gcGFkXG4gICAgICB8IExpdF9wYWRkaW5nICgoTGVmdCB8IFJpZ2h0KSwgXykgLT4gcGFkXG4gICAgICB8IEFyZ19wYWRkaW5nIChMZWZ0IHwgUmlnaHQpIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgICB8IEFyZ19wYWRkaW5nIFplcm9zIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCIwXCJcbiAgICBpblxuXG4gICAgKCogR2V0IHBhZGRpbmcgYXMgYSBwYWRfb3B0aW9uIChzZWUgXCIlX1wiLCBcIiV7XCIsIFwiJShcIiBhbmQgXCIlW1wiKS5cbiAgICAgICAobm8gbmVlZCBmb3IgbGVnYWN5IG1vZGUgdHdlYWtpbmcsIHRob3NlIHdlcmUgcmVqZWN0ZWQgYnkgdGhlXG4gICAgICAgbGVnYWN5IHBhcnNlciBhcyB3ZWxsKSAqKVxuICAgIGxldCBvcHRfb2ZfcGFkIGMgKHR5cGUgYSkgKHR5cGUgYikgKHBhZCA6IChhLCBiKSBwYWRkaW5nKSA9IG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gTm9uZVxuICAgICAgfCBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKSAtPiBTb21lIHdpZHRoXG4gICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicwJ1wiXG4gICAgICB8IExpdF9wYWRkaW5nIChMZWZ0LCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gU29tZSB3aWR0aFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJy0nXCJcbiAgICAgIHwgQXJnX3BhZGRpbmcgXyAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicqJ1wiXG4gICAgaW5cbiAgICBsZXQgZ2V0X3BhZF9vcHQgYyA9IG9wdF9vZl9wYWQgYyAoZ2V0X3BhZCAoKSkgaW5cbiAgICBsZXQgZ2V0X3BhZHByZWNfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWRwcmVjICgpKSBpblxuXG4gICAgKCogR2V0IHByZWNpc2lvbiBhcyBhIHByZWNfb3B0aW9uIChzZWUgXCIlX2ZcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgZ2V0X3ByZWNfb3B0ICgpID0gbWF0Y2ggZ2V0X3ByZWMgKCkgd2l0aFxuICAgICAgfCBOb19wcmVjaXNpb24gICAgICAgLT4gTm9uZVxuICAgICAgfCBMaXRfcHJlY2lzaW9uIG5kZWMgLT4gU29tZSBuZGVjXG4gICAgICB8IEFyZ19wcmVjaXNpb24gICAgICAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJ18nIFwiJyonXCJcbiAgICBpblxuXG4gICAgbGV0IGZtdF9yZXN1bHQgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICcsJyAtPlxuICAgICAgcGFyc2Ugc3RyX2luZCBlbmRfaW5kXG4gICAgfCAnYycgLT5cbiAgICAgIGxldCBjaGFyX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICVjICopXG4gICAgICAgIGlmIGdldF9pZ24gKClcbiAgICAgICAgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChDaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBzY2FuX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICUwYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9zY2FuX25leHRfY2hhciwgZm10X3Jlc3QpKVxuICAgICAgICBlbHNlIEZtdF9FQkIgKFNjYW5fbmV4dF9jaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBiZWdpbiBtYXRjaCBnZXRfcGFkX29wdCAnYycgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gY2hhcl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIDAgLT4gc2Nhbl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIF9uIC0+XG4gICAgICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3JcbiAgICAgICAgICAgdGhlbiBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kXG4gICAgICAgICAgIGVsc2UgKCogbGVnYWN5IGlnbm9yZXMgJWMgd2lkdGhzICopIGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICBlbmRcbiAgICB8ICdDJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NhbWxfY2hhcixmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKENhbWxfY2hhciBmbXRfcmVzdClcbiAgICB8ICdzJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKFN0cmluZyAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdTJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9jYW1sX3N0cmluZyAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnZCcgfCAnaScgfCAneCcgfCAnWCcgfCAnbycgfCAndScgLT5cbiAgICAgIGxldCBpY29udiA9IGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAoZ2V0X3NwYWNlICgpKSBzeW1iIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdOJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gVG9rZW5fY291bnRlciBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCkpXG4gICAgfCAnbCcgfCAnbicgfCAnTCcgd2hlbiBzdHJfaW5kPWVuZF9pbmQgfHwgbm90IChpc19pbnRfYmFzZSBzdHIuW3N0cl9pbmRdKSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gY291bnRlcl9vZl9jaGFyIHN5bWIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQzMiAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDMyIChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnbicgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSlcbiAgICAgICAgICAoZ2V0X2hhc2ggKCkpIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKE5hdGl2ZWludCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ0wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQ2NCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDY0IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnZicgfCAnZScgfCAnRScgfCAnZycgfCAnRycgfCAnRicgfCAnaCcgfCAnSCcgLT5cbiAgICAgIGxldCBmY29udiA9XG4gICAgICAgIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmRcbiAgICAgICAgICAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSkgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZmxvYXQgKGdldF9wYWRfb3B0ICdfJywgZ2V0X3ByZWNfb3B0ICgpKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2InIHwgJ0InIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Jvb2wgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEJvb2wgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnYScgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChBbHBoYSBmbXRfcmVzdClcbiAgICB8ICd0JyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKFRoZXRhIGZtdF9yZXN0KVxuICAgIHwgJ3InIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfcmVhZGVyLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKFJlYWRlciBmbXRfcmVzdClcbiAgICB8ICchJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZsdXNoIGZtdF9yZXN0KVxuICAgIHwgKCclJyB8ICdAJykgYXMgYyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoYywgZm10X3Jlc3QpKVxuICAgIHwgJ3snIC0+XG4gICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCAnfScgaW5cbiAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIHN1Yl9lbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2ZtdHR5ID0gZm10dHlfb2ZfZm10IHN1Yl9mbXQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ3snLCBzdWJfZm10dHksIGZtdF9yZXN0KSlcbiAgICB8ICcoJyAtPlxuICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgJyknIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdWJfZW5kICsgMikgZW5kX2luZCBpblxuICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgc3ViX2VuZCBpblxuICAgICAgbGV0IHN1Yl9mbXR0eSA9IGZtdHR5X29mX2ZtdCBzdWJfZm10IGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X3N1YnN0IChnZXRfcGFkX29wdCAnKCcsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpKVxuICAgIHwgJ1snIC0+XG4gICAgICBsZXQgbmV4dF9pbmQsIGNoYXJfc2V0ID0gcGFyc2VfY2hhcl9zZXQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAoZ2V0X3BhZF9vcHQgJ18nLCBjaGFyX3NldCkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2NoYXJfc2V0IChnZXRfcGFkX29wdCAnWycsIGNoYXJfc2V0LCBmbXRfcmVzdCkpXG4gICAgfCAnLScgfCAnKycgfCAnIycgfCAnICcgfCAnXycgLT5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgIGZsYWcgJUMgaXMgb25seSBhbGxvd2VkIGFmdGVyIHRoZSAnJSUnLCBiZWZvcmUgcGFkZGluZyBhbmQgcHJlY2lzaW9uXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgc3ltYlxuICAgIHwgXyAtPlxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgaW52YWxpZCBjb252ZXJzaW9uIFxcXCIlJSVjXFxcIlwiIHN0ciAoc3RyX2luZCAtIDEpIHN5bWJcbiAgICBpblxuICAgICgqIENoZWNrIGZvciB1bnVzZWQgb3B0aW9ucywgYW5kIHJlamVjdCB0aGVtIGFzIGluY29tcGF0aWJsZS5cblxuICAgICAgIFN1Y2ggY2hlY2tzIG5lZWQgdG8gYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsIGFzIHRoZSBsZWdhY3lcbiAgICAgICBwYXJzZXIgc2lsZW50bHkgaWdub3JlZCBpbmNvbXBhdGlibGUgZmxhZ3MuICopXG4gICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuIGJlZ2luXG4gICAgaWYgbm90ICFwbHVzX3VzZWQgJiYgcGx1cyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiO1xuICAgIGlmIG5vdCAhaGFzaF91c2VkICYmIGhhc2ggdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIjtcbiAgICBpZiBub3QgIXNwYWNlX3VzZWQgJiYgc3BhY2UgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInICdcIjtcbiAgICBpZiBub3QgIXBhZF91c2VkICAmJiBQYWRkaW5nX0VCQiBwYWQgPD4gUGFkZGluZ19FQkIgTm9fcGFkZGluZyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcImBwYWRkaW5nJ1wiO1xuICAgIGlmIG5vdCAhcHJlY191c2VkICYmIFByZWNpc2lvbl9FQkIgcHJlYyA8PiBQcmVjaXNpb25fRUJCIE5vX3ByZWNpc2lvbiB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgKGlmIGlnbiB0aGVuICdfJyBlbHNlIHN5bWIpXG4gICAgICAgIFwiYHByZWNpc2lvbidcIjtcbiAgICBpZiBpZ24gJiYgcGx1cyB0aGVuIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnXycgXCInKydcIjtcbiAgICBlbmQ7XG4gICAgKCogdGhpcyBsYXN0IHRlc3QgbXVzdCBub3QgYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsXG4gICAgICAgYXMgaWdub3JpbmcgaXQgd291bGQgdHlwaWNhbGx5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0eXBpbmdcbiAgICAgICB0aGFuIHdoYXQgdGhlIGxlZ2FjeSBwYXJzZXIgdXNlZCAqKVxuICAgIGlmIG5vdCAhaWduX3VzZWQgJiYgaWduIHRoZW5cbiAgICAgIGJlZ2luIG1hdGNoIHN5bWIgd2l0aFxuICAgICAgICAoKiBhcmd1bWVudC1sZXNzIGZvcm1hdHMgY2FuIHNhZmVseSBiZSBpZ25vcmVkIGluIGxlZ2FjeSBtb2RlICopXG4gICAgICAgIHwgKCdAJyB8ICclJyB8ICchJyB8ICcsJykgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gKClcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInXydcIlxuICAgICAgZW5kO1xuICAgIGZtdF9yZXN1bHRcblxuICAoKiBQYXJzZSBmb3JtYXR0aW5nIGluZm9ybWF0aW9uIChhZnRlciAnQCcpLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKCdAJywgRW5kX29mX2Zvcm1hdCkpXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdbJyAtPlxuICAgICAgICBwYXJzZV90YWcgZmFsc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICddJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfYm94LCBmbXRfcmVzdCkpXG4gICAgICB8ICd7JyAtPlxuICAgICAgICBwYXJzZV90YWcgdHJ1ZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ30nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChDbG9zZV90YWcsIGZtdF9yZXN0KSlcbiAgICAgIHwgJywnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJALFwiLCAwLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEJyZWFrIChcIkAgXCIsIDEsIDApLCBmbXRfcmVzdCkpXG4gICAgICB8ICc7JyAtPlxuICAgICAgICBwYXJzZV9nb29kX2JyZWFrIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnPycgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZGbHVzaCwgZm10X3Jlc3QpKVxuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRm9yY2VfbmV3bGluZSwgZm10X3Jlc3QpKVxuICAgICAgfCAnLicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZsdXNoX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIHBhcnNlX21hZ2ljX3NpemUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRXNjYXBlZF9hdCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgd2hlbiBzdHJfaW5kICsgMSA8IGVuZF9pbmQgJiYgc3RyLltzdHJfaW5kICsgMV0gPSAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfcGVyY2VudCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIGZtdF9yZXN0KSlcbiAgICAgIHwgYyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyBjLCBmbXRfcmVzdCkpXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIG9wdGlvbmFsIDxuYW1lPiBhZnRlciBcIkB7XCIgb3IgXCJAW1wiLiAqKVxuICBhbmQgcGFyc2VfdGFnIDogdHlwZSBlIGYgLiBib29sIC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gaXNfb3Blbl90YWcgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgdHJ5XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnPCcgLT5cbiAgICAgICAgbGV0IGluZCA9IFN0cmluZy5pbmRleF9mcm9tIHN0ciAoc3RyX2luZCArIDEpICc+JyBpblxuICAgICAgICBpZiBpbmQgPj0gZW5kX2luZCB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciBzdHJfaW5kIChpbmQgLSBzdHJfaW5kICsgMSkgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCAoaW5kICsgMSkgaW5cbiAgICAgICAgbGV0IHN1Yl9mb3JtYXQgPSBGb3JtYXQgKHN1Yl9mbXQsIHN1Yl9zdHIpIGluXG4gICAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgICBpZiBpc19vcGVuX3RhZyB0aGVuIE9wZW5fdGFnIHN1Yl9mb3JtYXQgZWxzZSBPcGVuX2JveCBzdWJfZm9ybWF0IGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2Zvcm1hdCA9IEZvcm1hdCAoRW5kX29mX2Zvcm1hdCwgXCJcIikgaW5cbiAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmcsIGZtdF9yZXN0KSlcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgb3B0aW9uYWwgPHdpZHRoIG9mZnNldD4gYWZ0ZXIgXCJAO1wiLiAqKVxuICBhbmQgcGFyc2VfZ29vZF9icmVhayA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBsZXQgbmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0ID1cbiAgICAgIHRyeVxuICAgICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB8fCBzdHIuW3N0cl9pbmRdIDw+ICc8JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN0cl9pbmRfMSA9IHBhcnNlX3NwYWNlcyAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzFdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IChcbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCB3aWR0aCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8xIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8zXSB3aXRoXG4gICAgICAgICAgICAgIHwgJz4nIC0+XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF8zLXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzMgKyAxLCBCcmVhayAocywgd2lkdGgsIDApXG4gICAgICAgICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgICAgICAgIGxldCBzdHJfaW5kXzQsIG9mZnNldCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8zIGVuZF9pbmQgaW5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF81ID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfNCBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgaWYgc3RyLltzdHJfaW5kXzVdIDw+ICc+JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kLTIpIChzdHJfaW5kXzUtc3RyX2luZCszKSBpblxuICAgICAgICAgICAgICAgIHN0cl9pbmRfNSArIDEsIEJyZWFrIChzLCB3aWR0aCwgb2Zmc2V0KVxuICAgICAgICAgICAgICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIClcbiAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgd2l0aCBOb3RfZm91bmQgfCBGYWlsdXJlIF8gLT5cbiAgICAgICAgc3RyX2luZCwgQnJlYWsgKFwiQDtcIiwgMSwgMClcbiAgICBpblxuICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIHRoZSBzaXplIGluIGEgPG4+LiAqKVxuICBhbmQgcGFyc2VfbWFnaWNfc2l6ZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBtYXRjaFxuICAgICAgdHJ5XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgIGxldCBzdHJfaW5kXzIsIHNpemUgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMyA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzIgZW5kX2luZCBpblxuICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF8zXSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZCAtIDIpIChzdHJfaW5kXzMgLSBzdHJfaW5kICsgMykgaW5cbiAgICAgICAgICBTb21lIChzdHJfaW5kXzMgKyAxLCBNYWdpY19zaXplIChzLCBzaXplKSlcbiAgICAgICAgfCBfIC0+IE5vbmVcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIE5vbmVcbiAgICB3aXRoXG4gICAgfCBTb21lIChuZXh0X2luZCwgZm9ybWF0dGluZ19saXQpIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChTY2FuX2luZGljICc8JywgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIGFuZCBjb25zdHJ1Y3QgYSBjaGFyIHNldC4gKilcbiAgYW5kIHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcblxuICAgIGxldCBjaGFyX3NldCA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICAgIGxldCBhZGRfY2hhciBjID1cbiAgICAgIGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjO1xuICAgIGluXG4gICAgbGV0IGFkZF9yYW5nZSBjIGMnID1cbiAgICAgIGZvciBpID0gaW50X29mX2NoYXIgYyB0byBpbnRfb2ZfY2hhciBjJyBkb1xuICAgICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgKGNoYXJfb2ZfaW50IGkpO1xuICAgICAgZG9uZTtcbiAgICBpblxuXG4gICAgbGV0IGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZCA9XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6ICclJScgYWxvbmUgaXMgbm90IGFjY2VwdGVkIGluIGNoYXJhY3RlciBzZXRzLCBcXFxuICAgICAgICAgdXNlICUlJSUgaW5zdGVhZCBhdCBwb3NpdGlvbiAlZC5cIiBzdHIgc3RyX2luZFxuICAgIGluXG5cbiAgICAoKiBQYXJzZSB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgY2hhciBzZXQuICopXG4gICAgbGV0IHJlYyBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGxldCBjID0gc3RyLltzdHJfaW5kXSBpblxuICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICAgKCogUGFyc2UgdGhlIGNvbnRlbnQgb2YgYSBjaGFyIHNldCB1bnRpbCB0aGUgZmlyc3QgJ10nLiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9jb250ZW50IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgYWRkX2NoYXIgJy0nO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjIC0+XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFRlc3QgZm9yIHJhbmdlIGluIGNoYXIgc2V0LiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICctJyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyB3aGVuIGMgPSAnJScgLT5cbiAgICAgICAgYWRkX2NoYXIgYyc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGlmIGMgPSAnJScgdGhlbiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQ7XG4gICAgICAgICgqIG5vdGUgdGhhdCAnQCcgYWxvbmUgaXMgYWNjZXB0ZWQsIGFzIGRvbmUgYnkgdGhlIGxlZ2FjeVxuICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjsgdGhlIGRvY3VtZW50YXRpb24gc3BlY2lmaWNhbGx5IHJlcXVpcmVzICVAXG4gICAgICAgICAgIHNvIHdlIGNvdWxkIHdhcm4gb24gdGhhdCAqKVxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjJ1xuXG4gICAgKCogTWFuYWdlIHJhbmdlIGluIGNoYXIgc2V0IChleGNlcHQgaWYgdGhlICctJyB0aGUgbGFzdCBjaGFyIGJlZm9yZSAnXScpICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2FmdGVyX21pbnVzIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyAtPlxuICAgICAgICAgICAgYWRkX3JhbmdlIGMgYyc7XG4gICAgICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMikgZW5kX2luZFxuICAgICAgICAgIHwgXyAtPiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmRcbiAgICAgICAgZW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgIGluXG4gICAgbGV0IHN0cl9pbmQsIHJldmVyc2UgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgICB8ICdeJyAtPiBzdHJfaW5kICsgMSwgdHJ1ZVxuICAgICAgICB8IF8gLT4gc3RyX2luZCwgZmFsc2UgaW5cbiAgICBsZXQgbmV4dF9pbmQgPSBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICBsZXQgY2hhcl9zZXQgPSBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgaW5cbiAgICBuZXh0X2luZCwgKGlmIHJldmVyc2UgdGhlbiByZXZfY2hhcl9zZXQgY2hhcl9zZXQgZWxzZSBjaGFyX3NldClcblxuICAoKiBDb25zdW1lIGFsbCBuZXh0IHNwYWNlcywgcmFpc2UgYW4gRmFpbHVyZSBpZiBlbmRfaW5kIGlzIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGlmIHN0ci5bc3RyX2luZF0gPSAnICcgdGhlbiBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGVsc2Ugc3RyX2luZFxuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlIGlmIGVuZF9pbmQgaXNcbiAgICAgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCBhY2MgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gYWNjICogMTAgKyAoaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJykgaW5cbiAgICAgIGlmIG5ld19hY2MgPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogaW50ZWdlciAlZCBpcyBncmVhdGVyIHRoYW4gdGhlIGxpbWl0ICVkXCJcbiAgICAgICAgICBzdHIgbmV3X2FjYyBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICAgIGVsc2VcbiAgICAgICAgcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG5ld19hY2NcbiAgICB8IF8gLT4gc3RyX2luZCwgYWNjXG5cbiAgKCogUmVhZCBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIgZnJvbSB0aGUgc3RyaW5nLCByYWlzZSBhIEZhaWx1cmVcbiAgICAgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2VfaW50ZWdlciBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwXG4gICAgfCAnLScgLT4gKFxuICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgICAgbGV0IG5leHRfaW5kLCBuID0gcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIDAgaW5cbiAgICAgICAgbmV4dF9pbmQsIC1uXG4gICAgICB8IGMgLT5cbiAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJkaWdpdFwiIGNcbiAgICApXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIEFkZCBhIGxpdGVyYWwgdG8gYSBmb3JtYXQgZnJvbSBhIGxpdGVyYWwgY2hhcmFjdGVyIHN1Yi1zZXF1ZW5jZS4gKilcbiAgYW5kIGFkZF9saXRlcmFsIDogdHlwZSBhIGQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gKGEsIF8sIF8sIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZm10IC0+IG1hdGNoIHN0cl9pbmQgLSBsaXRfc3RhcnQgd2l0aFxuICAgIHwgMCAgICAtPiBGbXRfRUJCIGZtdFxuICAgIHwgMSAgICAtPiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKHN0ci5bbGl0X3N0YXJ0XSwgZm10KSlcbiAgICB8IHNpemUgLT4gRm10X0VCQiAoU3RyaW5nX2xpdGVyYWwgKFN0cmluZy5zdWIgc3RyIGxpdF9zdGFydCBzaXplLCBmbXQpKVxuXG4gICgqIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXRcbiAgICAgKGkuZS4gdGhlIGNvcnJlc3BvbmRpbmcgXCIlfVwiIG9yIFwiJSlcIikgKilcbiAgYW5kIHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuXG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IHVuY2xvc2VkIHN1Yi1mb3JtYXQsIFxcXG4gICAgICAgICBleHBlY3RlZCBcXFwiJSUlY1xcXCIgYXQgY2hhcmFjdGVyIG51bWJlciAlZFwiIHN0ciBjIGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnJScgLT5cbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgaWYgc3RyLltzdHJfaW5kICsgMV0gPSBjIHRoZW4gKCogRW5kIG9mIGZvcm1hdCBmb3VuZCAqKSBzdHJfaW5kIGVsc2VcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICB8ICdfJyAtPlxuICAgICAgICAgICgqIFNlYXJjaCBmb3IgXCIlXyhcIiBvciBcIiVfe1wiLiAqKVxuICAgICAgICAgIGlmIHN0cl9pbmQgKyAyID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDJdIHdpdGhcbiAgICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJ30nIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgICAgfCBfIC0+IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCBjXG4gICAgICAgICAgZW5kXG4gICAgICAgIHwgJ3snIC0+XG4gICAgICAgICAgKCogJXsuLi4lfSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgKCogJSguLi4lKSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICcpJyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJ30nIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICUoLi4uJX0uICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJyknXCIgJ30nXG4gICAgICAgIHwgJyknIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICV7Li4uJSkuICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJ30nXCIgJyknXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIGVuZFxuICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICgqIENoZWNrIGlmIHN5bWIgaXMgYSB2YWxpZCBpbnQgY29udmVyc2lvbiBhZnRlciBcIiVsXCIsIFwiJW5cIiBvciBcIiVMXCIgKilcbiAgYW5kIGlzX2ludF9iYXNlIHN5bWIgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICdkJyB8ICdpJyB8ICd4JyB8ICdYJyB8ICdvJyB8ICd1JyAtPiB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG5cbiAgKCogQ29udmVydCBhIGNoYXIgKGwsIG4gb3IgTCkgdG8gaXRzIGFzc29jaWF0ZWQgY291bnRlci4gKilcbiAgYW5kIGNvdW50ZXJfb2ZfY2hhciBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnbCcgLT4gTGluZV9jb3VudGVyICB8ICduJyAtPiBDaGFyX2NvdW50ZXJcbiAgICB8ICdMJyAtPiBUb2tlbl9jb3VudGVyIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBpbnRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBtYXRjaCBwbHVzLCBoYXNoLCBzcGFjZSwgc3ltYiB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnZCcgLT4gSW50X2QgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2knIC0+IEludF9pXG4gICAgfCBmYWxzZSwgZmFsc2UsICB0cnVlLCAnZCcgLT4gSW50X3NkIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2knIC0+IEludF9zaVxuICAgIHwgIHRydWUsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9wZCB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfcGlcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd4JyAtPiBJbnRfeCAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnWCcgLT4gSW50X1hcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd4JyAtPiBJbnRfQ3ggfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnWCcgLT4gSW50X0NYXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnbycgLT4gSW50X29cbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdvJyAtPiBJbnRfQ29cbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd1JyAtPiBJbnRfdVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2QnIC0+IEludF9DZFxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2knIC0+IEludF9DaVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ3UnIC0+IEludF9DdVxuICAgIHwgXywgdHJ1ZSwgXywgJ3gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DeFxuICAgIHwgXywgdHJ1ZSwgXywgJ1gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DWFxuICAgIHwgXywgdHJ1ZSwgXywgJ28nIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9Db1xuICAgIHwgXywgdHJ1ZSwgXywgKCdkJyB8ICdpJyB8ICd1JykgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGZhbHNlIHNwYWNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIlxuICAgIHwgdHJ1ZSwgXywgdHJ1ZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogcGx1cyBhbmQgc3BhY2U6IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBwcmVmZXJzIHBsdXMgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgdHJ1ZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCJcbiAgICB8IHRydWUsIF8sIGZhbHNlLCBfICAgIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgZmFsc2UgaGFzaCBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCJcbiAgICB8IGZhbHNlLCBfLCBmYWxzZSwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzcGFjZSwgc3ltYikgdG8gaXRzIGFzc29jaWF0ZWQgZmxvYXRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIHNwYWNlIHN5bWIgPVxuICAgIGxldCBmbGFnID0gbWF0Y2ggcGx1cywgc3BhY2Ugd2l0aFxuICAgIHwgZmFsc2UsIGZhbHNlIC0+IEZsb2F0X2ZsYWdfXG4gICAgfCBmYWxzZSwgIHRydWUgLT4gRmxvYXRfZmxhZ19zXG4gICAgfCAgdHJ1ZSwgZmFsc2UgLT4gRmxvYXRfZmxhZ19wXG4gICAgfCAgdHJ1ZSwgIHRydWUgLT5cbiAgICAgICgqIHBsdXMgYW5kIHNwYWNlOiBsZWdhY3kgaW1wbGVtZW50YXRpb24gcHJlZmVycyBwbHVzICopXG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBGbG9hdF9mbGFnX3BcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiIGluXG4gICAgbGV0IGtpbmQgPSBtYXRjaCBoYXNoLCBzeW1iIHdpdGhcbiAgICB8IF8sICdmJyAtPiBGbG9hdF9mXG4gICAgfCBfLCAnZScgLT4gRmxvYXRfZVxuICAgIHwgXywgJ0UnIC0+IEZsb2F0X0VcbiAgICB8IF8sICdnJyAtPiBGbG9hdF9nXG4gICAgfCBfLCAnRycgLT4gRmxvYXRfR1xuICAgIHwgXywgJ2gnIC0+IEZsb2F0X2hcbiAgICB8IF8sICdIJyAtPiBGbG9hdF9IXG4gICAgfCBmYWxzZSwgJ0YnIC0+IEZsb2F0X0ZcbiAgICB8IHRydWUsICdGJyAtPiBGbG9hdF9DRlxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgaW5cbiAgICBmbGFnLCBraW5kXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGluY29tcGF0aWJsZSBvcHRpb25zLiopXG4gIGFuZCBpbmNvbXBhdGlibGVfZmxhZyA6IHR5cGUgYSAuIGludCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmcgLT4gYSA9XG4gICAgZnVuIHBjdF9pbmQgc3RyX2luZCBzeW1iIG9wdGlvbiAtPlxuICAgICAgbGV0IHN1YmZtdCA9IFN0cmluZy5zdWIgc3RyIHBjdF9pbmQgKHN0cl9pbmQgLSBwY3RfaW5kKSBpblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgJXMgaXMgaW5jb21wYXRpYmxlIHdpdGggJyVjJyBpbiBzdWItZm9ybWF0ICVTXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgb3B0aW9uIHN5bWIgc3ViZm10XG5cbiAgaW4gcGFyc2UgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAoKiBHdWFyZGVkIHN0cmluZyB0byBmb3JtYXQgY29udmVyc2lvbnMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHN0ciBmbXR0eSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgZm10dHksIHN0cilcbiAgd2l0aCBUeXBlX21pc21hdGNoIC0+XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJiYWQgaW5wdXQ6IGZvcm1hdCB0eXBlIG1pc21hdGNoIGJldHdlZW4gJVMgYW5kICVTXCJcbiAgICAgIHN0ciAoc3RyaW5nX29mX2ZtdHR5IGZtdHR5KVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgZm9ybWF0IGNvbXBhdGlibGUgd2l0aCBhbiBvdGhlciBmb3JtYXQuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgKEZvcm1hdCAoZm10Jywgc3RyJykpID1cbiAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgc3RyIGluXG4gIHRyeSBGb3JtYXQgKHR5cGVfZm9ybWF0IGZtdCAoZm10dHlfb2ZfZm10IGZtdCcpLCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiIHN0ciBzdHInXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIFhhdmllciBMZXJveSBhbmQgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG5sZXQga2ZwcmludGYgayBvIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGYgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyBvIGFjYzsgayBvKSBFbmRfb2ZfYWNjIGZtdFxubGV0IGticHJpbnRmIGsgYiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gYWNjIC0+IGJ1ZnB1dF9hY2MgYiBhY2M7IGsgYikgRW5kX29mX2FjYyBmbXRcbmxldCBpa2ZwcmludGYgayBvYyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBrIG9jIGZtdFxubGV0IGlrYnByaW50ZiA9IGlrZnByaW50ZlxuXG5sZXQgZnByaW50ZiBvYyBmbXQgPSBrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgYnByaW50ZiBiIGZtdCA9IGticHJpbnRmIGlnbm9yZSBiIGZtdFxubGV0IGlmcHJpbnRmIG9jIGZtdCA9IGlrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgaWJwcmludGYgYiBmbXQgPSBpa2JwcmludGYgaWdub3JlIGIgZm10XG5sZXQgcHJpbnRmIGZtdCA9IGZwcmludGYgc3Rkb3V0IGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBzdGRlcnIgZm10XG5cbmxldCBrc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGsnIGFjYyA9XG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgNjQgaW5cbiAgICBzdHJwdXRfYWNjIGJ1ZiBhY2M7XG4gICAgayAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgaycgRW5kX29mX2FjYyBmbXRcblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgKGZ1biBzIC0+IHMpIGZtdFxuXG5sZXQga3ByaW50ZiA9IGtzcHJpbnRmXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUga2V5ID0gc3RyaW5nXG50eXBlIGRvYyA9IHN0cmluZ1xudHlwZSB1c2FnZV9tc2cgPSBzdHJpbmdcbnR5cGUgYW5vbl9mdW4gPSAoc3RyaW5nIC0+IHVuaXQpXG5cbnR5cGUgc3BlYyA9XG4gIHwgVW5pdCBvZiAodW5pdCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB1bml0IGFyZ3VtZW50ICopXG4gIHwgQm9vbCBvZiAoYm9vbCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIGJvb2wgYXJndW1lbnQgKilcbiAgfCBTZXQgb2YgYm9vbCByZWYgICAgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0cnVlICopXG4gIHwgQ2xlYXIgb2YgYm9vbCByZWYgICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gZmFsc2UgKilcbiAgfCBTdHJpbmcgb2YgKHN0cmluZyAtPiB1bml0KSAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgc3RyaW5nIGFyZ3VtZW50ICopXG4gIHwgU2V0X3N0cmluZyBvZiBzdHJpbmcgcmVmICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIHN0cmluZyBhcmd1bWVudCAqKVxuICB8IEludCBvZiAoaW50IC0+IHVuaXQpICAgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYW4gaW50IGFyZ3VtZW50ICopXG4gIHwgU2V0X2ludCBvZiBpbnQgcmVmICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIGludCBhcmd1bWVudCAqKVxuICB8IEZsb2F0IG9mIChmbG9hdCAtPiB1bml0KSAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFNldF9mbG9hdCBvZiBmbG9hdCByZWYgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFR1cGxlIG9mIHNwZWMgbGlzdCAgICAgICAgICgqIFRha2Ugc2V2ZXJhbCBhcmd1bWVudHMgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWMgbGlzdCAqKVxuICB8IFN5bWJvbCBvZiBzdHJpbmcgbGlzdCAqIChzdHJpbmcgLT4gdW5pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUYWtlIG9uZSBvZiB0aGUgc3ltYm9scyBhcyBhcmd1bWVudCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBzeW1ib2wuICopXG4gIHwgUmVzdCBvZiAoc3RyaW5nIC0+IHVuaXQpICAgKCogU3RvcCBpbnRlcnByZXRpbmcga2V5d29yZHMgYW5kIGNhbGwgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gd2l0aCBlYWNoIHJlbWFpbmluZyBhcmd1bWVudCAqKVxuICB8IFJlc3RfYWxsIG9mIChzdHJpbmcgbGlzdCAtPiB1bml0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFN0b3AgaW50ZXJwcmV0aW5nIGtleXdvcmRzIGFuZCBjYWxsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdpdGggYWxsIHJlbWFpbmluZyBhcmd1bWVudHMuICopXG4gIHwgRXhwYW5kIG9mIChzdHJpbmcgLT4gc3RyaW5nIGFycmF5KSAoKiBJZiB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cyB0byBwcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgb2YgdGhlIGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtbXCItZm9vXCI7IFwiYXJnXCJdIEAgcmVzdF0gd2hlcmUgXCJmb29cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgcmVnaXN0ZXJlZCBhcyBbRXhwYW5kIGZdLCB0aGVuIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzIFtmIFwiYXJnXCIgQCByZXN0XSBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZC4gT25seSBhbGxvd2VkIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNdLiAqKVxuXG5leGNlcHRpb24gQmFkIG9mIHN0cmluZ1xuZXhjZXB0aW9uIEhlbHAgb2Ygc3RyaW5nXG5cbnR5cGUgZXJyb3IgPVxuICB8IFVua25vd24gb2Ygc3RyaW5nXG4gIHwgV3Jvbmcgb2Ygc3RyaW5nICogc3RyaW5nICogc3RyaW5nICAoKiBvcHRpb24sIGFjdHVhbCwgZXhwZWN0ZWQgKilcbiAgfCBNaXNzaW5nIG9mIHN0cmluZ1xuICB8IE1lc3NhZ2Ugb2Ygc3RyaW5nXG5cbmV4Y2VwdGlvbiBTdG9wIG9mIGVycm9yICgqIHVzZWQgaW50ZXJuYWxseSAqKVxuXG5vcGVuIFByaW50ZlxuXG5sZXQgcmVjIGFzc29jMyB4IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoeTEsIHkyLCBfKSA6OiBfIHdoZW4geTEgPSB4IC0+IHkyXG4gIHwgXyA6OiB0IC0+IGFzc29jMyB4IHRcblxuXG5sZXQgc3BsaXQgcyA9XG4gIGxldCBpID0gU3RyaW5nLmluZGV4IHMgJz0nIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgU3RyaW5nLnN1YiBzIDAgaSwgU3RyaW5nLnN1YiBzIChpKzEpIChsZW4tKGkrMSkpXG5cblxubGV0IG1ha2Vfc3ltbGlzdCBwcmVmaXggc2VwIHN1ZmZpeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gXCI8bm9uZT5cIlxuICB8IGg6OnQgLT4gKExpc3QuZm9sZF9sZWZ0IChmdW4geCB5IC0+IHggXiBzZXAgXiB5KSAocHJlZml4IF4gaCkgdCkgXiBzdWZmaXhcblxuXG5sZXQgcHJpbnRfc3BlYyBidWYgKGtleSwgc3BlYywgZG9jKSA9XG4gIGlmIFN0cmluZy5sZW5ndGggZG9jID4gMCB0aGVuXG4gICAgbWF0Y2ggc3BlYyB3aXRoXG4gICAgfCBTeW1ib2wgKGwsIF8pIC0+XG4gICAgICAgIGJwcmludGYgYnVmIFwiICAlcyAlcyVzXFxuXCIga2V5IChtYWtlX3N5bWxpc3QgXCJ7XCIgXCJ8XCIgXCJ9XCIgbCkgZG9jXG4gICAgfCBfIC0+XG4gICAgICAgIGJwcmludGYgYnVmIFwiICAlcyAlc1xcblwiIGtleSBkb2NcblxuXG5sZXQgaGVscF9hY3Rpb24gKCkgPSByYWlzZSAoU3RvcCAoVW5rbm93biBcIi1oZWxwXCIpKVxuXG5sZXQgYWRkX2hlbHAgc3BlY2xpc3QgPVxuICBsZXQgYWRkMSA9XG4gICAgdHJ5IGlnbm9yZSAoYXNzb2MzIFwiLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi1oZWxwXCIsIFVuaXQgaGVscF9hY3Rpb24sIFwiIERpc3BsYXkgdGhpcyBsaXN0IG9mIG9wdGlvbnNcIl1cbiAgYW5kIGFkZDIgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi0taGVscFwiIHNwZWNsaXN0KTsgW11cbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgICAgW1wiLS1oZWxwXCIsIFVuaXQgaGVscF9hY3Rpb24sIFwiIERpc3BsYXkgdGhpcyBsaXN0IG9mIG9wdGlvbnNcIl1cbiAgaW5cbiAgc3BlY2xpc3QgQCAoYWRkMSBAIGFkZDIpXG5cblxubGV0IHVzYWdlX2IgYnVmIHNwZWNsaXN0IGVycm1zZyA9XG4gIGJwcmludGYgYnVmIFwiJXNcXG5cIiBlcnJtc2c7XG4gIExpc3QuaXRlciAocHJpbnRfc3BlYyBidWYpIChhZGRfaGVscCBzcGVjbGlzdClcblxuXG5sZXQgdXNhZ2Vfc3RyaW5nIHNwZWNsaXN0IGVycm1zZyA9XG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgdXNhZ2VfYiBiIHNwZWNsaXN0IGVycm1zZztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuXG5sZXQgdXNhZ2Ugc3BlY2xpc3QgZXJybXNnID1cbiAgZXByaW50ZiBcIiVzXCIgKHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cpXG5cblxubGV0IGN1cnJlbnQgPSByZWYgMFxuXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoYm9vbF9vZl9zdHJpbmcgeClcbiAgd2l0aCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gTm9uZVxuXG5sZXQgaW50X29mX3N0cmluZ19vcHQgeCA9XG4gIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgeCA9XG4gIHRyeSBTb21lIChmbG9hdF9vZl9zdHJpbmcgeClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IGFsbG93X2V4cGFuZCBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1blxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJtc2cgPVxuICBsZXQgaW5pdHBvcyA9ICFjdXJyZW50IGluXG4gIGxldCBjb252ZXJ0X2Vycm9yIGVycm9yID1cbiAgICAoKiBjb252ZXJ0IGFuIGludGVybmFsIGVycm9yIHRvIGEgQmFkL0hlbHAgZXhjZXB0aW9uXG4gICAgICAgKm9yKiBhZGQgdGhlIHByb2dyYW0gbmFtZSBhcyBhIHByZWZpeCBhbmQgdGhlIHVzYWdlIG1lc3NhZ2UgYXMgYSBzdWZmaXhcbiAgICAgICB0byBhbiB1c2VyLXJhaXNlZCBCYWQgZXhjZXB0aW9uLlxuICAgICopXG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDIwMCBpblxuICAgIGxldCBwcm9nbmFtZSA9XG4gICAgICBpZiBpbml0cG9zIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oaW5pdHBvcykgZWxzZSBcIig/KVwiIGluXG4gICAgYmVnaW4gbWF0Y2ggZXJyb3Igd2l0aFxuICAgICAgfCBVbmtub3duIFwiLWhlbHBcIiAtPiAoKVxuICAgICAgfCBVbmtub3duIFwiLS1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IHVua25vd24gb3B0aW9uICclcycuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBNaXNzaW5nIHMgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogb3B0aW9uICclcycgbmVlZHMgYW4gYXJndW1lbnQuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBXcm9uZyAob3B0LCBhcmcsIGV4cGVjdGVkKSAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB3cm9uZyBhcmd1bWVudCAnJXMnOyBvcHRpb24gJyVzJyBleHBlY3RzICVzLlxcblwiXG4gICAgICAgICAgICAgICAgICBwcm9nbmFtZSBhcmcgb3B0IGV4cGVjdGVkXG4gICAgICB8IE1lc3NhZ2UgcyAtPiAoKiB1c2VyIGVycm9yIG1lc3NhZ2UgKilcbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogJXMuXFxuXCIgcHJvZ25hbWUgc1xuICAgIGVuZDtcbiAgICB1c2FnZV9iIGIgIXNwZWNsaXN0IGVycm1zZztcbiAgICBpZiBlcnJvciA9IFVua25vd24gXCItaGVscFwiIHx8IGVycm9yID0gVW5rbm93biBcIi0taGVscFwiXG4gICAgdGhlbiBIZWxwIChCdWZmZXIuY29udGVudHMgYilcbiAgICBlbHNlIEJhZCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gIGluXG4gIGluY3IgY3VycmVudDtcbiAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSBkb1xuICAgIGJlZ2luIHRyeVxuICAgICAgbGV0IHMgPSAhYXJndi4oIWN1cnJlbnQpIGluXG4gICAgICBpZiBTdHJpbmcubGVuZ3RoIHMgPj0gMSAmJiBzLlswXSA9ICctJyB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBhY3Rpb24sIGZvbGxvdyA9XG4gICAgICAgICAgdHJ5IGFzc29jMyBzICFzcGVjbGlzdCwgTm9uZVxuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBsZXQga2V5d29yZCwgYXJnID0gc3BsaXQgcyBpblxuICAgICAgICAgICAgYXNzb2MzIGtleXdvcmQgIXNwZWNsaXN0LCBTb21lIGFyZ1xuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+IHJhaXNlIChTdG9wIChVbmtub3duIHMpKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbm9fYXJnICgpID1cbiAgICAgICAgICBtYXRjaCBmb2xsb3cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwibm8gYXJndW1lbnRcIikpKSBpblxuICAgICAgICBsZXQgZ2V0X2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgaWYgIWN1cnJlbnQgKyAxIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgICBlbHNlIHJhaXNlIChTdG9wIChNaXNzaW5nIHMpKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gYXJnXG4gICAgICAgIGluXG4gICAgICAgIGxldCBjb25zdW1lX2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gaW5jciBjdXJyZW50XG4gICAgICAgICAgfCBTb21lIF8gLT4gKClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHJlYyB0cmVhdF9hY3Rpb24gPSBmdW5jdGlvblxuICAgICAgICB8IFVuaXQgZiAtPiBub19hcmcgKCk7IGYgKCk7XG4gICAgICAgIHwgQm9vbCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggYm9vbF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBib29sZWFuXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSBzIC0+IGYgc1xuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0IHIgLT4gbm9fYXJnICgpOyByIDo9IHRydWU7XG4gICAgICAgIHwgQ2xlYXIgciAtPiBub19hcmcgKCk7IHIgOj0gZmFsc2U7XG4gICAgICAgIHwgU3RyaW5nIGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBmIGFyZztcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFN5bWJvbCAoc3ltYiwgZikgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBpZiBMaXN0Lm1lbSBhcmcgc3ltYiB0aGVuIGJlZ2luXG4gICAgICAgICAgICAgIGYgYXJnO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcIm9uZSBvZjogXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF4gKG1ha2Vfc3ltbGlzdCBcIlwiIFwiIFwiIFwiXCIgc3ltYikpKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IFNldF9zdHJpbmcgciAtPlxuICAgICAgICAgICAgciA6PSBnZXRfYXJnICgpO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgSW50IGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBpbnRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImFuIGludGVnZXJcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gZiB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXRfaW50IHIgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBpbnRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImFuIGludGVnZXJcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gciA6PSB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBGbG9hdCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggZmxvYXRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgZmxvYXRcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gZiB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXRfZmxvYXQgciAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGZsb2F0X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGZsb2F0XCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IHIgOj0geFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgVHVwbGUgc3BlY3MgLT5cbiAgICAgICAgICAgIG5vX2FyZyAoKTtcbiAgICAgICAgICAgIExpc3QuaXRlciB0cmVhdF9hY3Rpb24gc3BlY3M7XG4gICAgICAgIHwgUmVzdCBmIC0+XG4gICAgICAgICAgICBub19hcmcgKCk7XG4gICAgICAgICAgICB3aGlsZSAhY3VycmVudCA8IChBcnJheS5sZW5ndGggIWFyZ3YpIC0gMSBkb1xuICAgICAgICAgICAgICBmICFhcmd2LighY3VycmVudCArIDEpO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGRvbmU7XG4gICAgICAgIHwgUmVzdF9hbGwgZiAtPlxuICAgICAgICAgICAgbm9fYXJnICgpO1xuICAgICAgICAgICAgbGV0IGFjYyA9IHJlZiBbXSBpblxuICAgICAgICAgICAgd2hpbGUgIWN1cnJlbnQgPCBBcnJheS5sZW5ndGggIWFyZ3YgLSAxIGRvXG4gICAgICAgICAgICAgIGFjYyA6PSAhYXJndi4oIWN1cnJlbnQgKyAxKSA6OiAhYWNjO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGRvbmU7XG4gICAgICAgICAgICBmIChMaXN0LnJldiAhYWNjKVxuICAgICAgICB8IEV4cGFuZCBmIC0+XG4gICAgICAgICAgICBpZiBub3QgYWxsb3dfZXhwYW5kIHRoZW5cbiAgICAgICAgICAgICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJBcmcuRXhwYW5kIGlzIGlzIG9ubHkgYWxsb3dlZCB3aXRoIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcmcucGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNcIik7XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgbGV0IG5ld2FyZyA9IGYgYXJnIGluXG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBBcnJheS5zdWIgIWFyZ3YgMCAoIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgYW5kIGFmdGVyID1cbiAgICAgICAgICAgICAgQXJyYXkuc3ViICFhcmd2ICghY3VycmVudCArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAoKEFycmF5Lmxlbmd0aCAhYXJndikgLSAhY3VycmVudCAtIDEpIGluXG4gICAgICAgICAgICBhcmd2Oj0gQXJyYXkuY29uY2F0IFtiZWZvcmU7bmV3YXJnO2FmdGVyXTtcbiAgICAgICAgaW5cbiAgICAgICAgdHJlYXRfYWN0aW9uIGFjdGlvbiBlbmRcbiAgICAgIGVsc2UgYW5vbmZ1biBzXG4gICAgd2l0aCB8IEJhZCBtIC0+IHJhaXNlIChjb252ZXJ0X2Vycm9yIChNZXNzYWdlIG0pKTtcbiAgICAgICAgIHwgU3RvcCBlIC0+IHJhaXNlIChjb252ZXJ0X2Vycm9yIGUpO1xuICAgIGVuZDtcbiAgICBpbmNyIGN1cnJlbnRcbiAgZG9uZVxuXG5sZXQgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IHRydWUgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnXG5cbmxldCBwYXJzZV9hcmd2X2R5bmFtaWMgPyhjdXJyZW50PWN1cnJlbnQpIGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXggZmFsc2UgY3VycmVudCAocmVmIGFyZ3YpIHNwZWNsaXN0IGFub25mdW5cbiAgICBlcnJtc2dcblxuXG5sZXQgcGFyc2VfYXJndiA/KGN1cnJlbnQ9Y3VycmVudCkgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FyZ3ZfZHluYW1pYyB+Y3VycmVudDpjdXJyZW50IGFyZ3YgKHJlZiBzcGVjbGlzdCkgYW5vbmZ1biBlcnJtc2dcblxuXG5sZXQgcGFyc2UgbCBmIG1zZyA9XG4gIHRyeVxuICAgIHBhcnNlX2FyZ3YgU3lzLmFyZ3YgbCBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxuXG5sZXQgcGFyc2VfZHluYW1pYyBsIGYgbXNnID1cbiAgdHJ5XG4gICAgcGFyc2VfYXJndl9keW5hbWljIFN5cy5hcmd2IGwgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cbmxldCBwYXJzZV9leHBhbmQgbCBmIG1zZyA9XG4gIHRyeVxuICAgIGxldCBhcmd2ID0gcmVmIFN5cy5hcmd2IGluXG4gICAgbGV0IHNwZWMgPSByZWYgbCBpblxuICAgIGxldCBjdXJyZW50ID0gcmVmICghY3VycmVudCkgaW5cbiAgICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyBjdXJyZW50IGFyZ3Ygc3BlYyBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxuXG5sZXQgc2Vjb25kX3dvcmQgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIG4gPVxuICAgIGlmIG4gPj0gbGVuIHRoZW4gbGVuXG4gICAgZWxzZSBpZiBzLltuXSA9ICcgJyB0aGVuIGxvb3AgKG4rMSlcbiAgICBlbHNlIG5cbiAgaW5cbiAgbWF0Y2ggU3RyaW5nLmluZGV4IHMgJ1xcdCcgd2l0aFxuICB8IG4gLT4gbG9vcCAobisxKVxuICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT5cbiAgICAgIGJlZ2luIG1hdGNoIFN0cmluZy5pbmRleCBzICcgJyB3aXRoXG4gICAgICB8IG4gLT4gbG9vcCAobisxKVxuICAgICAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+IGxlblxuICAgICAgZW5kXG5cblxubGV0IG1heF9hcmdfbGVuIGN1ciAoa3dkLCBzcGVjLCBkb2MpID1cbiAgbWF0Y2ggc3BlYyB3aXRoXG4gIHwgU3ltYm9sIF8gLT4gSW50Lm1heCBjdXIgKFN0cmluZy5sZW5ndGgga3dkKVxuICB8IF8gLT4gSW50Lm1heCBjdXIgKFN0cmluZy5sZW5ndGgga3dkICsgc2Vjb25kX3dvcmQgZG9jKVxuXG5cbmxldCByZXBsYWNlX2xlYWRpbmdfdGFiIHMgPVxuICBsZXQgc2VlbiA9IHJlZiBmYWxzZSBpblxuICBTdHJpbmcubWFwIChmdW5jdGlvbiAnXFx0JyB3aGVuIG5vdCAhc2VlbiAtPiBzZWVuIDo9IHRydWU7ICcgJyB8IGMgLT4gYykgc1xuXG5sZXQgYWRkX3BhZGRpbmcgbGVuIGtzZCA9XG4gIG1hdGNoIGtzZCB3aXRoXG4gIHwgKF8sIF8sIFwiXCIpIC0+XG4gICAgICAoKiBEbyBub3QgcGFkIHVuZG9jdW1lbnRlZCBvcHRpb25zLCBzbyB0aGF0IHRoZXkgc3RpbGwgZG9uJ3Qgc2hvdyB1cCB3aGVuXG4gICAgICAgKiBydW4gdGhyb3VnaCBbdXNhZ2VdIG9yIFtwYXJzZV0uICopXG4gICAgICBrc2RcbiAgfCAoa3dkLCAoU3ltYm9sIF8gYXMgc3BlYyksIG1zZykgLT5cbiAgICAgIGxldCBjdXRjb2wgPSBzZWNvbmRfd29yZCBtc2cgaW5cbiAgICAgIGxldCBzcGFjZXMgPSBTdHJpbmcubWFrZSAoKEludC5tYXggMCAobGVuIC0gY3V0Y29sKSkgKyAzKSAnICcgaW5cbiAgICAgIChrd2QsIHNwZWMsIFwiXFxuXCIgXiBzcGFjZXMgXiByZXBsYWNlX2xlYWRpbmdfdGFiIG1zZylcbiAgfCAoa3dkLCBzcGVjLCBtc2cpIC0+XG4gICAgICBsZXQgY3V0Y29sID0gc2Vjb25kX3dvcmQgbXNnIGluXG4gICAgICBsZXQga3dkX2xlbiA9IFN0cmluZy5sZW5ndGgga3dkIGluXG4gICAgICBsZXQgZGlmZiA9IGxlbiAtIGt3ZF9sZW4gLSBjdXRjb2wgaW5cbiAgICAgIGlmIGRpZmYgPD0gMCB0aGVuXG4gICAgICAgIChrd2QsIHNwZWMsIHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgc3BhY2VzID0gU3RyaW5nLm1ha2UgZGlmZiAnICcgaW5cbiAgICAgICAgbGV0IHByZWZpeCA9IFN0cmluZy5zdWIgKHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKSAwIGN1dGNvbCBpblxuICAgICAgICBsZXQgc3VmZml4ID0gU3RyaW5nLnN1YiBtc2cgY3V0Y29sIChTdHJpbmcubGVuZ3RoIG1zZyAtIGN1dGNvbCkgaW5cbiAgICAgICAgKGt3ZCwgc3BlYywgcHJlZml4IF4gc3BhY2VzIF4gc3VmZml4KVxuXG5cbmxldCBhbGlnbiA/KGxpbWl0PW1heF9pbnQpIHNwZWNsaXN0ID1cbiAgbGV0IGNvbXBsZXRlZCA9IGFkZF9oZWxwIHNwZWNsaXN0IGluXG4gIGxldCBsZW4gPSBMaXN0LmZvbGRfbGVmdCBtYXhfYXJnX2xlbiAwIGNvbXBsZXRlZCBpblxuICBsZXQgbGVuID0gSW50Lm1pbiBsZW4gbGltaXQgaW5cbiAgTGlzdC5tYXAgKGFkZF9wYWRkaW5nIGxlbikgY29tcGxldGVkXG5cbmxldCB0cmltX2NyIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGlmIGxlbiA+IDAgJiYgU3RyaW5nLmdldCBzIChsZW4gLSAxKSA9ICdcXHInIHRoZW5cbiAgICBTdHJpbmcuc3ViIHMgMCAobGVuIC0gMSlcbiAgZWxzZVxuICAgIHNcblxubGV0IHJlYWRfYXV4IHRyaW0gc2VwIGZpbGUgPVxuICBsZXQgaWMgPSBvcGVuX2luX2JpbiBmaWxlIGluXG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDIwMCBpblxuICBsZXQgd29yZHMgPSByZWYgW10gaW5cbiAgbGV0IHN0YXNoICgpID1cbiAgICBsZXQgd29yZCA9IEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgICBsZXQgd29yZCA9IGlmIHRyaW0gdGhlbiB0cmltX2NyIHdvcmQgZWxzZSB3b3JkIGluXG4gICAgd29yZHMgOj0gd29yZCA6OiAhd29yZHM7XG4gICAgQnVmZmVyLmNsZWFyIGJ1ZlxuICBpblxuICBiZWdpblxuICAgIHRyeSB3aGlsZSB0cnVlIGRvXG4gICAgICAgIGxldCBjID0gaW5wdXRfY2hhciBpYyBpblxuICAgICAgICBpZiBjID0gc2VwIHRoZW4gc3Rhc2ggKCkgZWxzZSBCdWZmZXIuYWRkX2NoYXIgYnVmIGNcbiAgICAgIGRvbmVcbiAgICB3aXRoIEVuZF9vZl9maWxlIC0+ICgpXG4gIGVuZDtcbiAgaWYgQnVmZmVyLmxlbmd0aCBidWYgPiAwIHRoZW4gc3Rhc2ggKCk7XG4gIGNsb3NlX2luIGljO1xuICBBcnJheS5vZl9saXN0IChMaXN0LnJldiAhd29yZHMpXG5cbmxldCByZWFkX2FyZyA9IHJlYWRfYXV4IHRydWUgJ1xcbidcblxubGV0IHJlYWRfYXJnMCA9IHJlYWRfYXV4IGZhbHNlICdcXHgwMCdcblxubGV0IHdyaXRlX2F1eCBzZXAgZmlsZSBhcmdzID1cbiAgbGV0IG9jID0gb3Blbl9vdXRfYmluIGZpbGUgaW5cbiAgQXJyYXkuaXRlciAoZnVuIHMgLT4gZnByaW50ZiBvYyBcIiVzJWNcIiBzIHNlcCkgYXJncztcbiAgY2xvc2Vfb3V0IG9jXG5cbmxldCB3cml0ZV9hcmcgPSB3cml0ZV9hdXggJ1xcbidcblxubGV0IHdyaXRlX2FyZzAgPSB3cml0ZV9hdXggJ1xceDAwJ1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIFByaW50ZlxuXG50eXBlIHQgPSBleG4gPSAuLlxuXG5sZXQgcHJpbnRlcnMgPSBBdG9taWMubWFrZSBbXVxuXG5sZXQgbG9jZm10ID0gZm9ybWF0X29mX3N0cmluZyBcIkZpbGUgXFxcIiVzXFxcIiwgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZDogJXNcIlxuXG5sZXQgZmllbGQgeCBpID1cbiAgbGV0IGYgPSBPYmouZmllbGQgeCBpIGluXG4gIGlmIG5vdCAoT2JqLmlzX2Jsb2NrIGYpIHRoZW5cbiAgICBzcHJpbnRmIFwiJWRcIiAoT2JqLm1hZ2ljIGYgOiBpbnQpICAgICAgICAgICAoKiBjYW4gYWxzbyBiZSBhIGNoYXIgKilcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouc3RyaW5nX3RhZyB0aGVuXG4gICAgc3ByaW50ZiBcIiVTXCIgKE9iai5tYWdpYyBmIDogc3RyaW5nKVxuICBlbHNlIGlmIE9iai50YWcgZiA9IE9iai5kb3VibGVfdGFnIHRoZW5cbiAgICBzdHJpbmdfb2ZfZmxvYXQgKE9iai5tYWdpYyBmIDogZmxvYXQpXG4gIGVsc2VcbiAgICBcIl9cIlxuXG5sZXQgcmVjIG90aGVyX2ZpZWxkcyB4IGkgPVxuICBpZiBpID49IE9iai5zaXplIHggdGhlbiBcIlwiXG4gIGVsc2Ugc3ByaW50ZiBcIiwgJXMlc1wiIChmaWVsZCB4IGkpIChvdGhlcl9maWVsZHMgeCAoaSsxKSlcblxubGV0IGZpZWxkcyB4ID1cbiAgbWF0Y2ggT2JqLnNpemUgeCB3aXRoXG4gIHwgMCAtPiBcIlwiXG4gIHwgMSAtPiBcIlwiXG4gIHwgMiAtPiBzcHJpbnRmIFwiKCVzKVwiIChmaWVsZCB4IDEpXG4gIHwgXyAtPiBzcHJpbnRmIFwiKCVzJXMpXCIgKGZpZWxkIHggMSkgKG90aGVyX2ZpZWxkcyB4IDIpXG5cbmxldCB1c2VfcHJpbnRlcnMgeCA9XG4gIGxldCByZWMgY29udiA9IGZ1bmN0aW9uXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICAobWF0Y2ggaGQgeCB3aXRoXG4gICAgICAgICB8IE5vbmUgfCBleGNlcHRpb24gXyAtPiBjb252IHRsXG4gICAgICAgICB8IFNvbWUgcyAtPiBTb21lIHMpXG4gICAgfCBbXSAtPiBOb25lIGluXG4gIGNvbnYgKEF0b21pYy5nZXQgcHJpbnRlcnMpXG5cbmxldCBkZXN0cnVjdF9leHRfY29uc3RydWN0b3IgeCA9XG4gIGlmIE9iai50YWcgeCA8PiAwIHRoZW5cbiAgICAoKE9iai5tYWdpYyAoT2JqLmZpZWxkIHggMCkgOiBzdHJpbmcpLCBOb25lKVxuICBlbHNlXG4gICAgbGV0IGNvbnN0cnVjdG9yID1cbiAgICAgIChPYmoubWFnaWMgKE9iai5maWVsZCAoT2JqLmZpZWxkIHggMCkgMCkgOiBzdHJpbmcpIGluXG4gICAgKGNvbnN0cnVjdG9yLCBTb21lIChmaWVsZHMgeCkpXG5cbmxldCBzdHJpbmdfb2ZfZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIHQgPVxuICBsZXQgY29uc3RydWN0b3IsIGZpZWxkc19vcHQgPSBkZXN0cnVjdF9leHRfY29uc3RydWN0b3IgdCBpblxuICBtYXRjaCBmaWVsZHNfb3B0IHdpdGhcbiAgfCBOb25lIC0+IGNvbnN0cnVjdG9yXG4gIHwgU29tZSBmIC0+IGNvbnN0cnVjdG9yIF4gZlxuXG5sZXQgdG9fc3RyaW5nX2RlZmF1bHQgPSBmdW5jdGlvblxuICB8IE91dF9vZl9tZW1vcnkgLT4gXCJPdXQgb2YgbWVtb3J5XCJcbiAgfCBTdGFja19vdmVyZmxvdyAtPiBcIlN0YWNrIG92ZXJmbG93XCJcbiAgfCBNYXRjaF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis1KSBcIlBhdHRlcm4gbWF0Y2hpbmcgZmFpbGVkXCJcbiAgfCBBc3NlcnRfZmFpbHVyZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJBc3NlcnRpb24gZmFpbGVkXCJcbiAgfCBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJVbmRlZmluZWQgcmVjdXJzaXZlIG1vZHVsZVwiXG4gIHwgeCAtPlxuICAgICAgc3RyaW5nX29mX2V4dGVuc2lvbl9jb25zdHJ1Y3RvciAoT2JqLnJlcHIgeClcblxubGV0IHRvX3N0cmluZyBlID1cbiAgbWF0Y2ggdXNlX3ByaW50ZXJzIGUgd2l0aFxuICB8IFNvbWUgcyAtPiBzXG4gIHwgTm9uZSAtPiB0b19zdHJpbmdfZGVmYXVsdCBlXG5cbmxldCBwcmludCBmY3QgYXJnID1cbiAgdHJ5XG4gICAgZmN0IGFyZ1xuICB3aXRoIHggLT5cbiAgICBlcHJpbnRmIFwiVW5jYXVnaHQgZXhjZXB0aW9uOiAlc1xcblwiICh0b19zdHJpbmcgeCk7XG4gICAgZmx1c2ggc3RkZXJyO1xuICAgIHJhaXNlIHhcblxubGV0IGNhdGNoIGZjdCBhcmcgPVxuICB0cnlcbiAgICBmY3QgYXJnXG4gIHdpdGggeCAtPlxuICAgIGZsdXNoIHN0ZG91dDtcbiAgICBlcHJpbnRmIFwiVW5jYXVnaHQgZXhjZXB0aW9uOiAlc1xcblwiICh0b19zdHJpbmcgeCk7XG4gICAgZXhpdCAyXG5cbnR5cGUgcmF3X2JhY2t0cmFjZV9zbG90XG50eXBlIHJhd19iYWNrdHJhY2VfZW50cnkgPSBwcml2YXRlIGludFxudHlwZSByYXdfYmFja3RyYWNlID0gcmF3X2JhY2t0cmFjZV9lbnRyeSBhcnJheVxuXG5sZXQgcmF3X2JhY2t0cmFjZV9lbnRyaWVzIGJ0ID0gYnRcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2U6XG4gIHVuaXQgLT4gcmF3X2JhY2t0cmFjZSA9IFwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2VcIlxuXG5leHRlcm5hbCByYWlzZV93aXRoX2JhY2t0cmFjZTogZXhuIC0+IHJhd19iYWNrdHJhY2UgLT4gJ2FcbiAgPSBcIiVyYWlzZV93aXRoX2JhY2t0cmFjZVwiXG5cbnR5cGUgYmFja3RyYWNlX3Nsb3QgPVxuICB8IEtub3duX2xvY2F0aW9uIG9mIHtcbiAgICAgIGlzX3JhaXNlICAgIDogYm9vbDtcbiAgICAgIGZpbGVuYW1lICAgIDogc3RyaW5nO1xuICAgICAgbGluZV9udW1iZXIgOiBpbnQ7XG4gICAgICBzdGFydF9jaGFyICA6IGludDtcbiAgICAgIGVuZF9jaGFyICAgIDogaW50O1xuICAgICAgaXNfaW5saW5lICAgOiBib29sO1xuICAgICAgZGVmbmFtZSAgICAgOiBzdHJpbmc7XG4gICAgfVxuICB8IFVua25vd25fbG9jYXRpb24gb2Yge1xuICAgICAgaXNfcmFpc2UgOiBib29sXG4gICAgfVxuXG4oKiB0byBhdm9pZCB3YXJuaW5nICopXG5sZXQgXyA9IFtLbm93bl9sb2NhdGlvbiB7IGlzX3JhaXNlID0gZmFsc2U7IGZpbGVuYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZV9udW1iZXIgPSAwOyBzdGFydF9jaGFyID0gMDsgZW5kX2NoYXIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc19pbmxpbmUgPSBmYWxzZTsgZGVmbmFtZSA9IFwiXCIgfTtcbiAgICAgICAgIFVua25vd25fbG9jYXRpb24geyBpc19yYWlzZSA9IGZhbHNlIH1dXG5cbmV4dGVybmFsIGNvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90OlxuICByYXdfYmFja3RyYWNlX3Nsb3QgLT4gYmFja3RyYWNlX3Nsb3QgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIlxuXG5leHRlcm5hbCBjb252ZXJ0X3Jhd19iYWNrdHJhY2U6XG4gIHJhd19iYWNrdHJhY2UgLT4gYmFja3RyYWNlX3Nsb3QgYXJyYXkgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlXCJcblxubGV0IGNvbnZlcnRfcmF3X2JhY2t0cmFjZSBidCA9XG4gIHRyeSBTb21lIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgYnQpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBwb3Mgc2xvdCA9XG4gIGxldCBpbmZvIGlzX3JhaXNlID1cbiAgICBpZiBpc19yYWlzZSB0aGVuXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYXRcIiBlbHNlIFwiUmUtcmFpc2VkIGF0XCJcbiAgICBlbHNlXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYnkgcHJpbWl0aXZlIG9wZXJhdGlvbiBhdFwiIGVsc2UgXCJDYWxsZWQgZnJvbVwiXG4gIGluXG4gIG1hdGNoIHNsb3Qgd2l0aFxuICB8IFVua25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgaWYgbC5pc19yYWlzZSB0aGVuXG4gICAgICAgICgqIGNvbXBpbGVyLWluc2VydGVkIHJlLXJhaXNlLCBza2lwcGVkICopIE5vbmVcbiAgICAgIGVsc2VcbiAgICAgICAgU29tZSAoc3ByaW50ZiBcIiVzIHVua25vd24gbG9jYXRpb25cIiAoaW5mbyBmYWxzZSkpXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgU29tZSAoc3ByaW50ZiBcIiVzICVzIGluIGZpbGUgXFxcIiVzXFxcIiVzLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkXCJcbiAgICAgICAgICAgICAgKGluZm8gbC5pc19yYWlzZSkgbC5kZWZuYW1lIGwuZmlsZW5hbWVcbiAgICAgICAgICAgICAgKGlmIGwuaXNfaW5saW5lIHRoZW4gXCIgKGlubGluZWQpXCIgZWxzZSBcIlwiKVxuICAgICAgICAgICAgICBsLmxpbmVfbnVtYmVyIGwuc3RhcnRfY2hhciBsLmVuZF9jaGFyKVxuXG5sZXQgcHJpbnRfZXhjZXB0aW9uX2JhY2t0cmFjZSBvdXRjaGFuIGJhY2t0cmFjZSA9XG4gIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICAgZnByaW50ZiBvdXRjaGFuXG4gICAgICAgIFwiKFByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBjYW5ub3QgcHJpbnQgc3RhY2sgYmFja3RyYWNlKVxcblwiXG4gIHwgU29tZSBhIC0+XG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgIG1hdGNoIGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBpIGEuKGkpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgc3RyIC0+IGZwcmludGYgb3V0Y2hhbiBcIiVzXFxuXCIgc3RyXG4gICAgICBkb25lXG5cbmxldCBwcmludF9yYXdfYmFja3RyYWNlIG91dGNoYW4gcmF3X2JhY2t0cmFjZSA9XG4gIHByaW50X2V4Y2VwdGlvbl9iYWNrdHJhY2Ugb3V0Y2hhbiAoY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2UpXG5cbigqIGNvbmZ1c2luZ2x5IG5hbWVkOiBwcmludHMgdGhlIGdsb2JhbCBjdXJyZW50IGJhY2t0cmFjZSAqKVxubGV0IHByaW50X2JhY2t0cmFjZSBvdXRjaGFuID1cbiAgcHJpbnRfcmF3X2JhY2t0cmFjZSBvdXRjaGFuIChnZXRfcmF3X2JhY2t0cmFjZSAoKSlcblxubGV0IGJhY2t0cmFjZV90b19zdHJpbmcgYmFja3RyYWNlID1cbiAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgIFwiKFByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBjYW5ub3QgcHJpbnQgc3RhY2sgYmFja3RyYWNlKVxcblwiXG4gIHwgU29tZSBhIC0+XG4gICAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMTAyNCBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBhIC0gMSBkb1xuICAgICAgICBtYXRjaCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgaSBhLihpKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIHN0ciAtPiBicHJpbnRmIGIgXCIlc1xcblwiIHN0clxuICAgICAgZG9uZTtcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBiXG5cbmxldCByYXdfYmFja3RyYWNlX3RvX3N0cmluZyByYXdfYmFja3RyYWNlID1cbiAgYmFja3RyYWNlX3RvX3N0cmluZyAoY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2UpXG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZSA9IGZ1bmN0aW9uXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBsLmlzX3JhaXNlXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfcmFpc2VcblxubGV0IGJhY2t0cmFjZV9zbG90X2lzX2lubGluZSA9IGZ1bmN0aW9uXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBsLmlzX2lubGluZVxuICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBmYWxzZVxuXG50eXBlIGxvY2F0aW9uID0ge1xuICBmaWxlbmFtZSA6IHN0cmluZztcbiAgbGluZV9udW1iZXIgOiBpbnQ7XG4gIHN0YXJ0X2NoYXIgOiBpbnQ7XG4gIGVuZF9jaGFyIDogaW50O1xufVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfbG9jYXRpb24gPSBmdW5jdGlvblxuICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBOb25lXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPlxuICAgIFNvbWUge1xuICAgICAgZmlsZW5hbWUgICAgPSBsLmZpbGVuYW1lO1xuICAgICAgbGluZV9udW1iZXIgPSBsLmxpbmVfbnVtYmVyO1xuICAgICAgc3RhcnRfY2hhciAgPSBsLnN0YXJ0X2NoYXI7XG4gICAgICBlbmRfY2hhciAgICA9IGwuZW5kX2NoYXI7XG4gICAgfVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfZGVmbmFtZSA9IGZ1bmN0aW9uXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfXG4gIHwgS25vd25fbG9jYXRpb24geyBkZWZuYW1lID0gXCJcIiB9IC0+IE5vbmVcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IFNvbWUgbC5kZWZuYW1lXG5cbmxldCBiYWNrdHJhY2Vfc2xvdHMgcmF3X2JhY2t0cmFjZSA9XG4gICgqIFRoZSBkb2N1bWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gZ3VhcmFudGVlcyB0aGF0IFNvbWUgaXNcbiAgICAgcmV0dXJuZWQgb25seSBpZiBhIHBhcnQgb2YgdGhlIHRyYWNlIGlzIHVzYWJsZS4gVGhpcyBnaXZlcyB1c1xuICAgICBhIGJpdCBtb3JlIHdvcmsgdGhhbiBqdXN0IGNvbnZlcnRfcmF3X2JhY2t0cmFjZSwgYnV0IGl0IG1ha2VzIHRoZVxuICAgICBBUEkgbW9yZSB1c2VyLWZyaWVuZGx5IC0tIG90aGVyd2lzZSBtb3N0IHVzZXJzIHdvdWxkIGhhdmUgdG9cbiAgICAgcmVpbXBsZW1lbnQgdGhlIFwiUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIHNvcnJ5XCIgbG9naWNcbiAgICAgdGhlbXNlbHZlcy4gKilcbiAgbWF0Y2ggY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2Ugd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGJhY2t0cmFjZSAtPlxuICAgICAgbGV0IHVzYWJsZV9zbG90ID0gZnVuY3Rpb25cbiAgICAgICAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gZmFsc2VcbiAgICAgICAgfCBLbm93bl9sb2NhdGlvbiBfIC0+IHRydWUgaW5cbiAgICAgIGxldCByZWMgZXhpc3RzX3VzYWJsZSA9IGZ1bmN0aW9uXG4gICAgICAgIHwgKC0xKSAtPiBmYWxzZVxuICAgICAgICB8IGkgLT4gdXNhYmxlX3Nsb3QgYmFja3RyYWNlLihpKSB8fCBleGlzdHNfdXNhYmxlIChpIC0gMSkgaW5cbiAgICAgIGlmIGV4aXN0c191c2FibGUgKEFycmF5Lmxlbmd0aCBiYWNrdHJhY2UgLSAxKVxuICAgICAgdGhlbiBTb21lIGJhY2t0cmFjZVxuICAgICAgZWxzZSBOb25lXG5cbmxldCBiYWNrdHJhY2Vfc2xvdHNfb2ZfcmF3X2VudHJ5IGVudHJ5ID1cbiAgYmFja3RyYWNlX3Nsb3RzIFt8IGVudHJ5IHxdXG5cbm1vZHVsZSBTbG90ID0gc3RydWN0XG4gIHR5cGUgdCA9IGJhY2t0cmFjZV9zbG90XG4gIGxldCBmb3JtYXQgPSBmb3JtYXRfYmFja3RyYWNlX3Nsb3RcbiAgbGV0IGlzX3JhaXNlID0gYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2VcbiAgbGV0IGlzX2lubGluZSA9IGJhY2t0cmFjZV9zbG90X2lzX2lubGluZVxuICBsZXQgbG9jYXRpb24gPSBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvblxuICBsZXQgbmFtZSA9IGJhY2t0cmFjZV9zbG90X2RlZm5hbWVcbmVuZFxuXG5sZXQgcmF3X2JhY2t0cmFjZV9sZW5ndGggYnQgPSBBcnJheS5sZW5ndGggYnRcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2Vfc2xvdCA6XG4gIHJhd19iYWNrdHJhY2UgLT4gaW50IC0+IHJhd19iYWNrdHJhY2Vfc2xvdCA9IFwiY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3RcIlxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QgOlxuICByYXdfYmFja3RyYWNlX3Nsb3QgLT4gcmF3X2JhY2t0cmFjZV9zbG90IG9wdGlvblxuICA9IFwiY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdFwiXG5cbigqIGNvbmZ1c2luZ2x5IG5hbWVkOlxuICAgcmV0dXJucyB0aGUgKnN0cmluZyogY29ycmVzcG9uZGluZyB0byB0aGUgZ2xvYmFsIGN1cnJlbnQgYmFja3RyYWNlICopXG5sZXQgZ2V0X2JhY2t0cmFjZSAoKSA9IHJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIChnZXRfcmF3X2JhY2t0cmFjZSAoKSlcblxuZXh0ZXJuYWwgcmVjb3JkX2JhY2t0cmFjZTogYm9vbCAtPiB1bml0ID0gXCJjYW1sX3JlY29yZF9iYWNrdHJhY2VcIlxuZXh0ZXJuYWwgYmFja3RyYWNlX3N0YXR1czogdW5pdCAtPiBib29sID0gXCJjYW1sX2JhY2t0cmFjZV9zdGF0dXNcIlxuXG5sZXQgcmVjIHJlZ2lzdGVyX3ByaW50ZXIgZm4gPVxuICBsZXQgb2xkX3ByaW50ZXJzID0gQXRvbWljLmdldCBwcmludGVycyBpblxuICBsZXQgbmV3X3ByaW50ZXJzID0gZm4gOjogb2xkX3ByaW50ZXJzIGluXG4gIGxldCBzdWNjZXNzID0gQXRvbWljLmNvbXBhcmVfYW5kX3NldCBwcmludGVycyBvbGRfcHJpbnRlcnMgbmV3X3ByaW50ZXJzIGluXG4gIGlmIG5vdCBzdWNjZXNzIHRoZW4gcmVnaXN0ZXJfcHJpbnRlciBmblxuXG5leHRlcm5hbCBnZXRfY2FsbHN0YWNrOiBpbnQgLT4gcmF3X2JhY2t0cmFjZSA9IFwiY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2tcIlxuXG5sZXQgZXhuX3Nsb3QgeCA9XG4gIGxldCB4ID0gT2JqLnJlcHIgeCBpblxuICBpZiBPYmoudGFnIHggPSAwIHRoZW4gT2JqLmZpZWxkIHggMCBlbHNlIHhcblxubGV0IGV4bl9zbG90X2lkIHggPVxuICBsZXQgc2xvdCA9IGV4bl9zbG90IHggaW5cbiAgKE9iai5vYmogKE9iai5maWVsZCBzbG90IDEpIDogaW50KVxuXG5sZXQgZXhuX3Nsb3RfbmFtZSB4ID1cbiAgbGV0IHNsb3QgPSBleG5fc2xvdCB4IGluXG4gIChPYmoub2JqIChPYmouZmllbGQgc2xvdCAwKSA6IHN0cmluZylcblxuZXh0ZXJuYWwgZ2V0X2RlYnVnX2luZm9fc3RhdHVzIDogdW5pdCAtPiBpbnQgPSBcImNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXNcIlxuXG4oKiBEZXNjcmlwdGlvbnMgZm9yIGVycm9ycyBpbiBzdGFydHVwLmguIFNlZSBhbHNvIGJhY2t0cmFjZS5jICopXG5sZXQgZXJyb3JzID0gW3wgXCJcIjtcbiAgKCogRklMRV9OT1RfRk9VTkQgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIG5vdCBmb3VuZClcIjtcbiAgKCogQkFEX0JZVEVDT0RFICopXG4gIFwiKENhbm5vdCBwcmludCBsb2NhdGlvbnM6XFxuIFxcXG4gICAgICBieXRlY29kZSBleGVjdXRhYmxlIHByb2dyYW0gZmlsZSBhcHBlYXJzIHRvIGJlIGNvcnJ1cHQpXCI7XG4gICgqIFdST05HX01BR0lDICopXG4gIFwiKENhbm5vdCBwcmludCBsb2NhdGlvbnM6XFxuIFxcXG4gICAgICBieXRlY29kZSBleGVjdXRhYmxlIHByb2dyYW0gZmlsZSBoYXMgd3JvbmcgbWFnaWMgbnVtYmVyKVwiO1xuICAoKiBOT19GRFMgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIGNhbm5vdCBiZSBvcGVuZWQ7XFxuIFxcXG4gICAgICAtLSB0b28gbWFueSBvcGVuIGZpbGVzLiBUcnkgcnVubmluZyB3aXRoIE9DQU1MUlVOUEFSQU09Yj0yKVwiXG58XVxuXG5sZXQgZGVmYXVsdF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBleG4gcmF3X2JhY2t0cmFjZSA9XG4gIGVwcmludGYgXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uICVzXFxuXCIgKHRvX3N0cmluZyBleG4pO1xuICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlO1xuICBsZXQgc3RhdHVzID0gZ2V0X2RlYnVnX2luZm9fc3RhdHVzICgpIGluXG4gIGlmIHN0YXR1cyA8IDAgdGhlblxuICAgIHByZXJyX2VuZGxpbmUgZXJyb3JzLihhYnMgc3RhdHVzKTtcbiAgZmx1c2ggc3RkZXJyXG5cbmxldCB1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciA9IHJlZiBkZWZhdWx0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyXG5cbmxldCBzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZm4gPSB1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciA6PSBmblxuXG5sZXQgZW1wdHlfYmFja3RyYWNlIDogcmF3X2JhY2t0cmFjZSA9IFt8IHxdXG5cbmxldCB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgPVxuICB0cnlcbiAgICBnZXRfcmF3X2JhY2t0cmFjZSAoKVxuICB3aXRoIF8gKCogT3V0X29mX21lbW9yeT8gKikgLT5cbiAgICBlbXB0eV9iYWNrdHJhY2VcblxubGV0IGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24nIGV4biBkZWJ1Z2dlcl9pbl91c2UgPVxuICB0cnlcbiAgICAoKiBHZXQgdGhlIGJhY2t0cmFjZSBub3csIGluIGNhc2Ugb25lIG9mIHRoZSBbYXRfZXhpdF0gZnVuY3Rpb25cbiAgICAgICBkZXN0cm95cyBpdC4gKilcbiAgICBsZXQgcmF3X2JhY2t0cmFjZSA9XG4gICAgICBpZiBkZWJ1Z2dlcl9pbl91c2UgKCogU2FtZSB0ZXN0IGFzIGluIFtydW50aW1lL3ByaW50ZXhjLmNdICopIHRoZW5cbiAgICAgICAgZW1wdHlfYmFja3RyYWNlXG4gICAgICBlbHNlXG4gICAgICAgIHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKVxuICAgIGluXG4gICAgKHRyeSBTdGRsaWIuZG9fYXRfZXhpdCAoKSB3aXRoIF8gLT4gKCkpO1xuICAgIHRyeVxuICAgICAgIXVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIGV4biByYXdfYmFja3RyYWNlXG4gICAgd2l0aCBleG4nIC0+XG4gICAgICBsZXQgcmF3X2JhY2t0cmFjZScgPSB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uICVzXFxuXCIgKHRvX3N0cmluZyBleG4pO1xuICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvciBpbiB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlcjogZXhjZXB0aW9uICVzXFxuXCJcbiAgICAgICAgKHRvX3N0cmluZyBleG4nKTtcbiAgICAgIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2UnO1xuICAgICAgZmx1c2ggc3RkZXJyXG4gIHdpdGhcbiAgICB8IE91dF9vZl9tZW1vcnkgLT5cbiAgICAgICAgcHJlcnJfZW5kbGluZVxuICAgICAgICAgIFwiRmF0YWwgZXJyb3I6IG91dCBvZiBtZW1vcnkgaW4gdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXJcIlxuXG4oKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBbY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb25dIGluXG4gICBbcnVudGltZS9wcmludGV4Yy5jXSB3aGljaCBleHBlY3RzIG5vIGV4Y2VwdGlvbiBpcyByYWlzZWQuICopXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbiBleG4gZGVidWdnZXJfaW5fdXNlID1cbiAgdHJ5XG4gICAgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbicgZXhuIGRlYnVnZ2VyX2luX3VzZVxuICB3aXRoIF8gLT5cbiAgICAoKiBUaGVyZSBpcyBub3QgbXVjaCB3ZSBjYW4gZG8gYXQgdGhpcyBwb2ludCAqKVxuICAgICgpXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+ICdhIC0+IHVuaXRcbiAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgKCkgPVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIlxuICAgIGhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXh0ZXJuYWwgaWQgOiAnYSAtPiAnYSA9IFwiJWlkZW50aXR5XCJcbmxldCBjb25zdCBjIF8gPSBjXG5sZXQgZmxpcCBmIHggeSA9IGYgeSB4XG5sZXQgbmVnYXRlIHAgdiA9IG5vdCAocCB2KVxuXG5leGNlcHRpb24gRmluYWxseV9yYWlzZWQgb2YgZXhuXG5cbmxldCAoKSA9IFByaW50ZXhjLnJlZ2lzdGVyX3ByaW50ZXIgQEAgZnVuY3Rpb25cbnwgRmluYWxseV9yYWlzZWQgZXhuIC0+IFNvbWUgKFwiRnVuLkZpbmFsbHlfcmFpc2VkOiBcIiBeIFByaW50ZXhjLnRvX3N0cmluZyBleG4pXG58IF8gLT4gTm9uZVxuXG5sZXQgcHJvdGVjdCB+KGZpbmFsbHkgOiB1bml0IC0+IHVuaXQpIHdvcmsgPVxuICBsZXQgZmluYWxseV9ub19leG4gKCkgPVxuICAgIHRyeSBmaW5hbGx5ICgpIHdpdGggZSAtPlxuICAgICAgbGV0IGJ0ID0gUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgIFByaW50ZXhjLnJhaXNlX3dpdGhfYmFja3RyYWNlIChGaW5hbGx5X3JhaXNlZCBlKSBidFxuICBpblxuICBtYXRjaCB3b3JrICgpIHdpdGhcbiAgfCByZXN1bHQgLT4gZmluYWxseV9ub19leG4gKCkgOyByZXN1bHRcbiAgfCBleGNlcHRpb24gd29ya19leG4gLT5cbiAgICAgIGxldCB3b3JrX2J0ID0gUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgIGZpbmFsbHlfbm9fZXhuICgpIDtcbiAgICAgIFByaW50ZXhjLnJhaXNlX3dpdGhfYmFja3RyYWNlIHdvcmtfZXhuIHdvcmtfYnRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgSmFjcXVlcy1IZW5yaSBKb3VyZGFuLCBwcm9qZXQgR2FsbGl1bSwgSU5SSUEgUGFyaXMgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYtMjAxNiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlICAgKilcbigqICAgICBldCBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBzdGF0ID0ge1xuICBtaW5vcl93b3JkcyA6IGZsb2F0O1xuICBwcm9tb3RlZF93b3JkcyA6IGZsb2F0O1xuICBtYWpvcl93b3JkcyA6IGZsb2F0O1xuICBtaW5vcl9jb2xsZWN0aW9ucyA6IGludDtcbiAgbWFqb3JfY29sbGVjdGlvbnMgOiBpbnQ7XG4gIGhlYXBfd29yZHMgOiBpbnQ7XG4gIGhlYXBfY2h1bmtzIDogaW50O1xuICBsaXZlX3dvcmRzIDogaW50O1xuICBsaXZlX2Jsb2NrcyA6IGludDtcbiAgZnJlZV93b3JkcyA6IGludDtcbiAgZnJlZV9ibG9ja3MgOiBpbnQ7XG4gIGxhcmdlc3RfZnJlZSA6IGludDtcbiAgZnJhZ21lbnRzIDogaW50O1xuICBjb21wYWN0aW9ucyA6IGludDtcbiAgdG9wX2hlYXBfd29yZHMgOiBpbnQ7XG4gIHN0YWNrX3NpemUgOiBpbnQ7XG4gIGZvcmNlZF9tYWpvcl9jb2xsZWN0aW9uczogaW50O1xufVxuXG50eXBlIGNvbnRyb2wgPSB7XG4gIG1pbm9yX2hlYXBfc2l6ZSA6IGludDtcbiAgbWFqb3JfaGVhcF9pbmNyZW1lbnQgOiBpbnQ7XG4gIHNwYWNlX292ZXJoZWFkIDogaW50O1xuICB2ZXJib3NlIDogaW50O1xuICBtYXhfb3ZlcmhlYWQgOiBpbnQ7XG4gIHN0YWNrX2xpbWl0IDogaW50O1xuICBhbGxvY2F0aW9uX3BvbGljeSA6IGludDtcbiAgd2luZG93X3NpemUgOiBpbnQ7XG4gIGN1c3RvbV9tYWpvcl9yYXRpbyA6IGludDtcbiAgY3VzdG9tX21pbm9yX3JhdGlvIDogaW50O1xuICBjdXN0b21fbWlub3JfbWF4X3NpemUgOiBpbnQ7XG59XG5cbmV4dGVybmFsIHN0YXQgOiB1bml0IC0+IHN0YXQgPSBcImNhbWxfZ2Nfc3RhdFwiXG5leHRlcm5hbCBxdWlja19zdGF0IDogdW5pdCAtPiBzdGF0ID0gXCJjYW1sX2djX3F1aWNrX3N0YXRcIlxuZXh0ZXJuYWwgY291bnRlcnMgOiB1bml0IC0+IChmbG9hdCAqIGZsb2F0ICogZmxvYXQpID0gXCJjYW1sX2djX2NvdW50ZXJzXCJcbmV4dGVybmFsIG1pbm9yX3dvcmRzIDogdW5pdCAtPiAoZmxvYXQgW0B1bmJveGVkXSlcbiAgPSBcImNhbWxfZ2NfbWlub3Jfd29yZHNcIiBcImNhbWxfZ2NfbWlub3Jfd29yZHNfdW5ib3hlZFwiXG5leHRlcm5hbCBnZXQgOiB1bml0IC0+IGNvbnRyb2wgPSBcImNhbWxfZ2NfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGNvbnRyb2wgLT4gdW5pdCA9IFwiY2FtbF9nY19zZXRcIlxuZXh0ZXJuYWwgbWlub3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfbWlub3JcIlxuZXh0ZXJuYWwgbWFqb3Jfc2xpY2UgOiBpbnQgLT4gaW50ID0gXCJjYW1sX2djX21ham9yX3NsaWNlXCJcbmV4dGVybmFsIG1ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21ham9yXCJcbmV4dGVybmFsIGZ1bGxfbWFqb3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfZnVsbF9tYWpvclwiXG5leHRlcm5hbCBjb21wYWN0IDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX2NvbXBhY3Rpb25cIlxuZXh0ZXJuYWwgZ2V0X21pbm9yX2ZyZWUgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nZXRfbWlub3JfZnJlZVwiXG5cbmxldCBldmVudGxvZ19wYXVzZSAoKSA9ICgpXG5sZXQgZXZlbnRsb2dfcmVzdW1lICgpID0gKClcblxub3BlbiBQcmludGZcblxubGV0IHByaW50X3N0YXQgYyA9XG4gIGxldCBzdCA9IHN0YXQgKCkgaW5cbiAgZnByaW50ZiBjIFwibWlub3JfY29sbGVjdGlvbnM6ICAgICAgJWRcXG5cIiBzdC5taW5vcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwibWFqb3JfY29sbGVjdGlvbnM6ICAgICAgJWRcXG5cIiBzdC5tYWpvcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwiY29tcGFjdGlvbnM6ICAgICAgICAgICAgJWRcXG5cIiBzdC5jb21wYWN0aW9ucztcbiAgZnByaW50ZiBjIFwiZm9yY2VkX21ham9yX2NvbGxlY3Rpb25zOiAlZFxcblwiIHN0LmZvcmNlZF9tYWpvcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGxldCBsMSA9IFN0cmluZy5sZW5ndGggKHNwcmludGYgXCIlLjBmXCIgc3QubWlub3Jfd29yZHMpIGluXG4gIGZwcmludGYgYyBcIm1pbm9yX3dvcmRzOiAgICAlKi4wZlxcblwiIGwxIHN0Lm1pbm9yX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJwcm9tb3RlZF93b3JkczogJSouMGZcXG5cIiBsMSBzdC5wcm9tb3RlZF93b3JkcztcbiAgZnByaW50ZiBjIFwibWFqb3Jfd29yZHM6ICAgICUqLjBmXFxuXCIgbDEgc3QubWFqb3Jfd29yZHM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBsZXQgbDIgPSBTdHJpbmcubGVuZ3RoIChzcHJpbnRmIFwiJWRcIiBzdC50b3BfaGVhcF93b3JkcykgaW5cbiAgZnByaW50ZiBjIFwidG9wX2hlYXBfd29yZHM6ICUqZFxcblwiIGwyIHN0LnRvcF9oZWFwX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJoZWFwX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QuaGVhcF93b3JkcztcbiAgZnByaW50ZiBjIFwibGl2ZV93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmxpdmVfd29yZHM7XG4gIGZwcmludGYgYyBcImZyZWVfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5mcmVlX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJsYXJnZXN0X2ZyZWU6ICAgJSpkXFxuXCIgbDIgc3QubGFyZ2VzdF9mcmVlO1xuICBmcHJpbnRmIGMgXCJmcmFnbWVudHM6ICAgICAgJSpkXFxuXCIgbDIgc3QuZnJhZ21lbnRzO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgZnByaW50ZiBjIFwibGl2ZV9ibG9ja3M6ICVkXFxuXCIgc3QubGl2ZV9ibG9ja3M7XG4gIGZwcmludGYgYyBcImZyZWVfYmxvY2tzOiAlZFxcblwiIHN0LmZyZWVfYmxvY2tzO1xuICBmcHJpbnRmIGMgXCJoZWFwX2NodW5rczogJWRcXG5cIiBzdC5oZWFwX2NodW5rc1xuXG5cbmxldCBhbGxvY2F0ZWRfYnl0ZXMgKCkgPVxuICBsZXQgKG1pLCBwcm8sIG1hKSA9IGNvdW50ZXJzICgpIGluXG4gIChtaSArLiBtYSAtLiBwcm8pICouIGZsb2F0X29mX2ludCAoU3lzLndvcmRfc2l6ZSAvIDgpXG5cblxuZXh0ZXJuYWwgZmluYWxpc2UgOiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9maW5hbF9yZWdpc3RlclwiXG5leHRlcm5hbCBmaW5hbGlzZV9sYXN0IDogKHVuaXQgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9XG4gIFwiY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZVwiXG5leHRlcm5hbCBmaW5hbGlzZV9yZWxlYXNlIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2ZpbmFsX3JlbGVhc2VcIlxuXG5cbnR5cGUgYWxhcm0gPSBib29sIEF0b21pYy50XG50eXBlIGFsYXJtX3JlYyA9IHthY3RpdmUgOiBhbGFybTsgZiA6IHVuaXQgLT4gdW5pdH1cblxubGV0IHJlYyBjYWxsX2FsYXJtIGFyZWMgPVxuICBpZiBBdG9taWMuZ2V0IGFyZWMuYWN0aXZlIHRoZW4gYmVnaW5cbiAgICBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWM7XG4gICAgYXJlYy5mICgpO1xuICBlbmRcblxuXG5sZXQgY3JlYXRlX2FsYXJtIGYgPVxuICBsZXQgYXJlYyA9IHsgYWN0aXZlID0gQXRvbWljLm1ha2UgdHJ1ZTsgZiA9IGYgfSBpblxuICBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWM7XG4gIGFyZWMuYWN0aXZlXG5cblxubGV0IGRlbGV0ZV9hbGFybSBhID0gQXRvbWljLnNldCBhIGZhbHNlXG5cbm1vZHVsZSBNZW1wcm9mID1cbiAgc3RydWN0XG4gICAgdHlwZSBhbGxvY2F0aW9uX3NvdXJjZSA9IE5vcm1hbCB8IE1hcnNoYWwgfCBDdXN0b21cbiAgICB0eXBlIGFsbG9jYXRpb24gPVxuICAgICAgeyBuX3NhbXBsZXMgOiBpbnQ7XG4gICAgICAgIHNpemUgOiBpbnQ7XG4gICAgICAgIHNvdXJjZSA6IGFsbG9jYXRpb25fc291cmNlO1xuICAgICAgICBjYWxsc3RhY2sgOiBQcmludGV4Yy5yYXdfYmFja3RyYWNlIH1cblxuICAgIHR5cGUgKCdtaW5vciwgJ21ham9yKSB0cmFja2VyID0ge1xuICAgICAgYWxsb2NfbWlub3I6IGFsbG9jYXRpb24gLT4gJ21pbm9yIG9wdGlvbjtcbiAgICAgIGFsbG9jX21ham9yOiBhbGxvY2F0aW9uIC0+ICdtYWpvciBvcHRpb247XG4gICAgICBwcm9tb3RlOiAnbWlub3IgLT4gJ21ham9yIG9wdGlvbjtcbiAgICAgIGRlYWxsb2NfbWlub3I6ICdtaW5vciAtPiB1bml0O1xuICAgICAgZGVhbGxvY19tYWpvcjogJ21ham9yIC0+IHVuaXQ7XG4gICAgfVxuXG4gICAgbGV0IG51bGxfdHJhY2tlciA9IHtcbiAgICAgIGFsbG9jX21pbm9yID0gKGZ1biBfIC0+IE5vbmUpO1xuICAgICAgYWxsb2NfbWFqb3IgPSAoZnVuIF8gLT4gTm9uZSk7XG4gICAgICBwcm9tb3RlID0gKGZ1biBfIC0+IE5vbmUpO1xuICAgICAgZGVhbGxvY19taW5vciA9IChmdW4gXyAtPiAoKSk7XG4gICAgICBkZWFsbG9jX21ham9yID0gKGZ1biBfIC0+ICgpKTtcbiAgICB9XG5cbiAgICBleHRlcm5hbCBjX3N0YXJ0IDpcbiAgICAgIGZsb2F0IC0+IGludCAtPiAoJ21pbm9yLCAnbWFqb3IpIHRyYWNrZXIgLT4gdW5pdFxuICAgICAgPSBcImNhbWxfbWVtcHJvZl9zdGFydFwiXG5cbiAgICBsZXQgc3RhcnRcbiAgICAgIH5zYW1wbGluZ19yYXRlXG4gICAgICA/KGNhbGxzdGFja19zaXplID0gbWF4X2ludClcbiAgICAgIHRyYWNrZXIgPVxuICAgICAgY19zdGFydCBzYW1wbGluZ19yYXRlIGNhbGxzdGFja19zaXplIHRyYWNrZXJcblxuICAgIGV4dGVybmFsIHN0b3AgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfbWVtcHJvZl9zdG9wXCJcbiAgZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1lc3NhZ2UgZGlnZXN0IChNRDUpICopXG5cbnR5cGUgdCA9IHN0cmluZ1xuXG5sZXQgY29tcGFyZSA9IFN0cmluZy5jb21wYXJlXG5sZXQgZXF1YWwgPSBTdHJpbmcuZXF1YWxcblxuZXh0ZXJuYWwgdW5zYWZlX3N0cmluZzogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9tZDVfc3RyaW5nXCJcbmV4dGVybmFsIGNoYW5uZWw6IGluX2NoYW5uZWwgLT4gaW50IC0+IHQgPSBcImNhbWxfbWQ1X2NoYW5cIlxuXG5sZXQgc3RyaW5nIHN0ciA9XG4gIHVuc2FmZV9zdHJpbmcgc3RyIDAgKFN0cmluZy5sZW5ndGggc3RyKVxuXG5sZXQgYnl0ZXMgYiA9IHN0cmluZyAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiKVxuXG5sZXQgc3Vic3RyaW5nIHN0ciBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IFN0cmluZy5sZW5ndGggc3RyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3Quc3Vic3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfc3RyaW5nIHN0ciBvZnMgbGVuXG5cbmxldCBzdWJieXRlcyBiIG9mcyBsZW4gPSBzdWJzdHJpbmcgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYikgb2ZzIGxlblxuXG5sZXQgZmlsZSBmaWxlbmFtZSA9XG4gIGxldCBpYyA9IG9wZW5faW5fYmluIGZpbGVuYW1lIGluXG4gIG1hdGNoIGNoYW5uZWwgaWMgKC0xKSB3aXRoXG4gICAgfCBkIC0+IGNsb3NlX2luIGljOyBkXG4gICAgfCBleGNlcHRpb24gZSAtPiBjbG9zZV9pbiBpYzsgcmFpc2UgZVxuXG5sZXQgb3V0cHV0IGNoYW4gZGlnZXN0ID1cbiAgb3V0cHV0X3N0cmluZyBjaGFuIGRpZ2VzdFxuXG5sZXQgaW5wdXQgY2hhbiA9IHJlYWxseV9pbnB1dF9zdHJpbmcgY2hhbiAxNlxuXG5sZXQgY2hhcl9oZXggbiA9XG4gIENoYXIudW5zYWZlX2NociAobiArIGlmIG4gPCAxMCB0aGVuIENoYXIuY29kZSAnMCcgZWxzZSAoQ2hhci5jb2RlICdhJyAtIDEwKSlcblxubGV0IHRvX2hleCBkID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBkIDw+IDE2IHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3QudG9faGV4XCI7XG4gIGxldCByZXN1bHQgPSBCeXRlcy5jcmVhdGUgMzIgaW5cbiAgZm9yIGkgPSAwIHRvIDE1IGRvXG4gICAgbGV0IHggPSBDaGFyLmNvZGUgZC5baV0gaW5cbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlc3VsdCAoaSoyKSAoY2hhcl9oZXggKHggbHNyIDQpKTtcbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlc3VsdCAoaSoyKzEpIChjaGFyX2hleCAoeCBsYW5kIDB4MGYpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXN1bHRcblxubGV0IGZyb21faGV4IHMgPVxuICBpZiBTdHJpbmcubGVuZ3RoIHMgPD4gMzIgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5mcm9tX2hleFwiO1xuICBsZXQgZGlnaXQgYyA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnMCcuLic5JyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnMCdcbiAgICB8ICdBJy4uJ0YnIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICdBJyArIDEwXG4gICAgfCAnYScuLidmJyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnYScgKyAxMFxuICAgIHwgXyAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkRpZ2VzdC5mcm9tX2hleFwiKVxuICBpblxuICBsZXQgYnl0ZSBpID0gZGlnaXQgcy5baV0gbHNsIDQgKyBkaWdpdCBzLltpKzFdIGluXG4gIGxldCByZXN1bHQgPSBCeXRlcy5jcmVhdGUgMTYgaW5cbiAgZm9yIGkgPSAwIHRvIDE1IGRvXG4gICAgQnl0ZXMuc2V0IHJlc3VsdCBpIChDaGFyLmNociAoYnl0ZSAoMiAqIGkpKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzdWx0XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgTWFudWVsIFNlcnJhbm8gZXQgWGF2aWVyIExlcm95LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAwIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbQmlnYXJyYXldOiBsYXJnZSwgbXVsdGktZGltZW5zaW9uYWwsIG51bWVyaWNhbCBhcnJheXMgKilcblxuKCogVGhlc2UgdHlwZXMgaW4gbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgdGFibGVzIGluXG4gICAuLi90eXBpbmcvdHlwZW9wdC5tbCAqKVxuXG50eXBlIGZsb2F0MzJfZWx0ID0gRmxvYXQzMl9lbHRcbnR5cGUgZmxvYXQ2NF9lbHQgPSBGbG9hdDY0X2VsdFxudHlwZSBpbnQ4X3NpZ25lZF9lbHQgPSBJbnQ4X3NpZ25lZF9lbHRcbnR5cGUgaW50OF91bnNpZ25lZF9lbHQgPSBJbnQ4X3Vuc2lnbmVkX2VsdFxudHlwZSBpbnQxNl9zaWduZWRfZWx0ID0gSW50MTZfc2lnbmVkX2VsdFxudHlwZSBpbnQxNl91bnNpZ25lZF9lbHQgPSBJbnQxNl91bnNpZ25lZF9lbHRcbnR5cGUgaW50MzJfZWx0ID0gSW50MzJfZWx0XG50eXBlIGludDY0X2VsdCA9IEludDY0X2VsdFxudHlwZSBpbnRfZWx0ID0gSW50X2VsdFxudHlwZSBuYXRpdmVpbnRfZWx0ID0gTmF0aXZlaW50X2VsdFxudHlwZSBjb21wbGV4MzJfZWx0ID0gQ29tcGxleDMyX2VsdFxudHlwZSBjb21wbGV4NjRfZWx0ID0gQ29tcGxleDY0X2VsdFxuXG50eXBlICgnYSwgJ2IpIGtpbmQgPVxuICAgIEZsb2F0MzIgOiAoZmxvYXQsIGZsb2F0MzJfZWx0KSBraW5kXG4gIHwgRmxvYXQ2NCA6IChmbG9hdCwgZmxvYXQ2NF9lbHQpIGtpbmRcbiAgfCBJbnQ4X3NpZ25lZCA6IChpbnQsIGludDhfc2lnbmVkX2VsdCkga2luZFxuICB8IEludDhfdW5zaWduZWQgOiAoaW50LCBpbnQ4X3Vuc2lnbmVkX2VsdCkga2luZFxuICB8IEludDE2X3NpZ25lZCA6IChpbnQsIGludDE2X3NpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQxNl91bnNpZ25lZCA6IChpbnQsIGludDE2X3Vuc2lnbmVkX2VsdCkga2luZFxuICB8IEludDMyIDogKGludDMyLCBpbnQzMl9lbHQpIGtpbmRcbiAgfCBJbnQ2NCA6IChpbnQ2NCwgaW50NjRfZWx0KSBraW5kXG4gIHwgSW50IDogKGludCwgaW50X2VsdCkga2luZFxuICB8IE5hdGl2ZWludCA6IChuYXRpdmVpbnQsIG5hdGl2ZWludF9lbHQpIGtpbmRcbiAgfCBDb21wbGV4MzIgOiAoQ29tcGxleC50LCBjb21wbGV4MzJfZWx0KSBraW5kXG4gIHwgQ29tcGxleDY0IDogKENvbXBsZXgudCwgY29tcGxleDY0X2VsdCkga2luZFxuICB8IENoYXIgOiAoY2hhciwgaW50OF91bnNpZ25lZF9lbHQpIGtpbmRcblxudHlwZSBjX2xheW91dCA9IENfbGF5b3V0X3R5cFxudHlwZSBmb3J0cmFuX2xheW91dCA9IEZvcnRyYW5fbGF5b3V0X3R5cCAoKiopXG5cbnR5cGUgJ2EgbGF5b3V0ID1cbiAgICBDX2xheW91dDogY19sYXlvdXQgbGF5b3V0XG4gIHwgRm9ydHJhbl9sYXlvdXQ6IGZvcnRyYW5fbGF5b3V0IGxheW91dFxuXG4oKiBLZWVwIHRob3NlIGNvbnN0YW50cyBpbiBzeW5jIHdpdGggdGhlIGNhbWxfYmFfa2luZCBlbnVtZXJhdGlvblxuICAgaW4gYmlnYXJyYXkuaCAqKVxuXG5sZXQgZmxvYXQzMiA9IEZsb2F0MzJcbmxldCBmbG9hdDY0ID0gRmxvYXQ2NFxubGV0IGludDhfc2lnbmVkID0gSW50OF9zaWduZWRcbmxldCBpbnQ4X3Vuc2lnbmVkID0gSW50OF91bnNpZ25lZFxubGV0IGludDE2X3NpZ25lZCA9IEludDE2X3NpZ25lZFxubGV0IGludDE2X3Vuc2lnbmVkID0gSW50MTZfdW5zaWduZWRcbmxldCBpbnQzMiA9IEludDMyXG5sZXQgaW50NjQgPSBJbnQ2NFxubGV0IGludCA9IEludFxubGV0IG5hdGl2ZWludCA9IE5hdGl2ZWludFxubGV0IGNvbXBsZXgzMiA9IENvbXBsZXgzMlxubGV0IGNvbXBsZXg2NCA9IENvbXBsZXg2NFxubGV0IGNoYXIgPSBDaGFyXG5cbmxldCBraW5kX3NpemVfaW5fYnl0ZXMgOiB0eXBlIGEgYi4gKGEsIGIpIGtpbmQgLT4gaW50ID0gZnVuY3Rpb25cbiAgfCBGbG9hdDMyIC0+IDRcbiAgfCBGbG9hdDY0IC0+IDhcbiAgfCBJbnQ4X3NpZ25lZCAtPiAxXG4gIHwgSW50OF91bnNpZ25lZCAtPiAxXG4gIHwgSW50MTZfc2lnbmVkIC0+IDJcbiAgfCBJbnQxNl91bnNpZ25lZCAtPiAyXG4gIHwgSW50MzIgLT4gNFxuICB8IEludDY0IC0+IDhcbiAgfCBJbnQgLT4gU3lzLndvcmRfc2l6ZSAvIDhcbiAgfCBOYXRpdmVpbnQgLT4gU3lzLndvcmRfc2l6ZSAvIDhcbiAgfCBDb21wbGV4MzIgLT4gOFxuICB8IENvbXBsZXg2NCAtPiAxNlxuICB8IENoYXIgLT4gMVxuXG4oKiBLZWVwIHRob3NlIGNvbnN0YW50cyBpbiBzeW5jIHdpdGggdGhlIGNhbWxfYmFfbGF5b3V0IGVudW1lcmF0aW9uXG4gICBpbiBiaWdhcnJheS5oICopXG5cbmxldCBjX2xheW91dCA9IENfbGF5b3V0XG5sZXQgZm9ydHJhbl9sYXlvdXQgPSBGb3J0cmFuX2xheW91dFxuXG5tb2R1bGUgR2VuYXJyYXkgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdFxuICBleHRlcm5hbCBjcmVhdGU6ICgnYSwgJ2IpIGtpbmQgLT4gJ2MgbGF5b3V0IC0+IGludCBhcnJheSAtPiAoJ2EsICdiLCAnYykgdFxuICAgICA9IFwiY2FtbF9iYV9jcmVhdGVcIlxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCBhcnJheSAtPiAnYVxuICAgICA9IFwiY2FtbF9iYV9nZXRfZ2VuZXJpY1wiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IGFycmF5IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcImNhbWxfYmFfc2V0X2dlbmVyaWNcIlxuXG4gIGxldCByZWMgY2xvb3AgYXJyIGlkeCBmIGNvbCBtYXggPVxuICAgIGlmIGNvbCA9IEFycmF5Lmxlbmd0aCBpZHggdGhlbiBzZXQgYXJyIGlkeCAoZiBpZHgpXG4gICAgZWxzZSBmb3IgaiA9IDAgdG8gcHJlZCBtYXguKGNvbCkgZG9cbiAgICAgICAgICAgaWR4Lihjb2wpIDwtIGo7XG4gICAgICAgICAgIGNsb29wIGFyciBpZHggZiAoc3VjYyBjb2wpIG1heFxuICAgICAgICAgZG9uZVxuICBsZXQgcmVjIGZsb29wIGFyciBpZHggZiBjb2wgbWF4ID1cbiAgICBpZiBjb2wgPCAwIHRoZW4gc2V0IGFyciBpZHggKGYgaWR4KVxuICAgIGVsc2UgZm9yIGogPSAxIHRvIG1heC4oY29sKSBkb1xuICAgICAgICAgICBpZHguKGNvbCkgPC0gajtcbiAgICAgICAgICAgZmxvb3AgYXJyIGlkeCBmIChwcmVkIGNvbCkgbWF4XG4gICAgICAgICBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW1zIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltcyBpblxuICAgIGxldCBkbGVuID0gQXJyYXkubGVuZ3RoIGRpbXMgaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY2xvb3AgYXJyIChBcnJheS5tYWtlIGRsZW4gMCkgZiAwIGRpbXM7IGFyclxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gZmxvb3AgYXJyIChBcnJheS5tYWtlIGRsZW4gMSkgZiAocHJlZCBkbGVuKSBkaW1zOyBhcnJcblxuICBleHRlcm5hbCBudW1fZGltczogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCJjYW1sX2JhX251bV9kaW1zXCJcbiAgZXh0ZXJuYWwgbnRoX2RpbTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCA9IFwiY2FtbF9iYV9kaW1cIlxuICBsZXQgZGltcyBhID1cbiAgICBsZXQgbiA9IG51bV9kaW1zIGEgaW5cbiAgICBsZXQgZCA9IEFycmF5Lm1ha2UgbiAwIGluXG4gICAgZm9yIGkgPSAwIHRvIG4tMSBkbyBkLihpKSA8LSBudGhfZGltIGEgaSBkb25lO1xuICAgIGRcblxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKEFycmF5LmZvbGRfbGVmdCAoICogKSAxIChkaW1zIGFycikpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHNsaWNlX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCBhcnJheSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zbGljZVwiXG4gIGV4dGVybmFsIHNsaWNlX3JpZ2h0OiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgYXJyYXkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc2xpY2VcIlxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0XG4gICAgID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuZW5kXG5cbm1vZHVsZSBBcnJheTAgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfHxdXG4gIGxldCBnZXQgYXJyID0gR2VuYXJyYXkuZ2V0IGFyciBbfHxdXG4gIGxldCBzZXQgYXJyID0gR2VuYXJyYXkuc2V0IGFyciBbfHxdXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID0ga2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycilcblxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuXG4gIGxldCBvZl92YWx1ZSBraW5kIGxheW91dCB2ID1cbiAgICBsZXQgYSA9IGNyZWF0ZSBraW5kIGxheW91dCBpblxuICAgIHNldCBhIHY7XG4gICAgYVxuICBsZXQgaW5pdCA9IG9mX3ZhbHVlXG5lbmRcblxubW9kdWxlIEFycmF5MSA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0gPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbXxdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfMVwiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVjYW1sX2JhX3NldF8xXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzFcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8xXCJcbiAgZXh0ZXJuYWwgZGltOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoZGltIGFycilcblxuICBleHRlcm5hbCBzdWI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgJ2MpIHQgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlICh0eXBlIHQpIChhIDogKF8sIF8sIHQpIEdlbmFycmF5LnQpIG4gPVxuICAgIG1hdGNoIGxheW91dCBhIHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IChHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF0gOiAoXywgXywgdCkgR2VuYXJyYXkudClcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IChHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdOiAoXywgXywgdCkgR2VuYXJyYXkudClcbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IGNfaW5pdCBhcnIgZGltIGYgPVxuICAgIGZvciBpID0gMCB0byBwcmVkIGRpbSBkbyB1bnNhZmVfc2V0IGFyciBpIChmIGkpIGRvbmVcbiAgbGV0IGZvcnRyYW5faW5pdCBhcnIgZGltIGYgPVxuICAgIGZvciBpID0gMSB0byBkaW0gZG8gdW5zYWZlX3NldCBhcnIgaSAoZiBpKSBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW0gZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0gaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY19pbml0IGFyciBkaW0gZjsgYXJyXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiBmb3J0cmFuX2luaXQgYXJyIGRpbSBmOyBhcnJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCAoQXJyYXkubGVuZ3RoIGRhdGEpIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZGF0YSAtIDEgZG8gdW5zYWZlX3NldCBiYSAoaSArIG9mcykgZGF0YS4oaSkgZG9uZTtcbiAgICBiYVxuZW5kXG5cbm1vZHVsZSBBcnJheTIgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW0xOyBkaW0yfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfMlwiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlY2FtbF9iYV9zZXRfMlwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2FcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfMlwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8yXCJcbiAgZXh0ZXJuYWwgZGltMTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMVwiXG4gIGV4dGVybmFsIGRpbTI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzJcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0xIGFycikgKiAoZGltMiBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OlxuICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlX2xlZnQgYSBuID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdXG4gIGxldCBzbGljZV9yaWdodCBhIG4gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBjX2luaXQgYXJyIGRpbTEgZGltMiBmID1cbiAgICBmb3IgaSA9IDAgdG8gcHJlZCBkaW0xIGRvXG4gICAgICBmb3IgaiA9IDAgdG8gcHJlZCBkaW0yIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiAoZiBpIGopXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZiA9XG4gICAgZm9yIGogPSAxIHRvIGRpbTIgZG9cbiAgICAgIGZvciBpID0gMSB0byBkaW0xIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiAoZiBpIGopXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgaW5pdCAodHlwZSB0KSBraW5kIChsYXlvdXQgOiB0IGxheW91dCkgZGltMSBkaW0yIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGluXG4gICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IGNfaW5pdCBhcnIgZGltMSBkaW0yIGY7IGFyclxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZjsgYXJyXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgZGltMSA9IEFycmF5Lmxlbmd0aCBkYXRhIGluXG4gICAgbGV0IGRpbTIgPSBpZiBkaW0xID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkgaW5cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBkaW0xIC0gMSBkb1xuICAgICAgbGV0IHJvdyA9IGRhdGEuKGkpIGluXG4gICAgICBpZiBBcnJheS5sZW5ndGggcm93IDw+IGRpbTIgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyhcIkJpZ2FycmF5LkFycmF5Mi5vZl9hcnJheTogbm9uLXJlY3Rhbmd1bGFyIGRhdGFcIik7XG4gICAgICBmb3IgaiA9IDAgdG8gZGltMiAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCBiYSAoaSArIG9mcykgKGogKyBvZnMpIHJvdy4oailcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIGJhXG5lbmRcblxubW9kdWxlIEFycmF5MyA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltMTsgZGltMjsgZGltM3xdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8zXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV9zZXRfM1wiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhXG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzNcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzNcIlxuICBleHRlcm5hbCBkaW0xOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwgZGltMjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMlwiXG4gIGV4dGVybmFsIGRpbTM6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzNcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0xIGFycikgKiAoZGltMiBhcnIpICogKGRpbTMgYXJyKVxuXG4gIGV4dGVybmFsIHN1Yl9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHN1Yl9yaWdodDpcbiAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2VfbGVmdF8xIGEgbiBtID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bjsgbXxdXG4gIGxldCBzbGljZV9yaWdodF8xIGEgbiBtID0gR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG47IG18XVxuICBsZXQgc2xpY2VfbGVmdF8yIGEgbiA9IEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XVxuICBsZXQgc2xpY2VfcmlnaHRfMiBhIG4gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBjX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGYgPVxuICAgIGZvciBpID0gMCB0byBwcmVkIGRpbTEgZG9cbiAgICAgIGZvciBqID0gMCB0byBwcmVkIGRpbTIgZG9cbiAgICAgICAgZm9yIGsgPSAwIHRvIHByZWQgZGltMyBkb1xuICAgICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiBrIChmIGkgaiBrKVxuICAgICAgICBkb25lXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmID1cbiAgICBmb3IgayA9IDEgdG8gZGltMyBkb1xuICAgICAgZm9yIGogPSAxIHRvIGRpbTIgZG9cbiAgICAgICAgZm9yIGkgPSAxIHRvIGRpbTEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IGFyciBpIGogayAoZiBpIGogaylcbiAgICAgICAgZG9uZVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgbGV0IGluaXQgKHR5cGUgdCkga2luZCAobGF5b3V0IDogdCBsYXlvdXQpIGRpbTEgZGltMiBkaW0zIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGRpbTMgaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY19pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmOyBhcnJcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IGZvcnRyYW5faW5pdCBhcnIgZGltMSBkaW0yIGRpbTMgZjsgYXJyXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgZGltMSA9IEFycmF5Lmxlbmd0aCBkYXRhIGluXG4gICAgbGV0IGRpbTIgPSBpZiBkaW0xID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkgaW5cbiAgICBsZXQgZGltMyA9IGlmIGRpbTIgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKS4oMCkgaW5cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGRpbTMgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIGRpbTEgLSAxIGRvXG4gICAgICBsZXQgcm93ID0gZGF0YS4oaSkgaW5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCByb3cgPD4gZGltMiB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkzLm9mX2FycmF5OiBub24tY3ViaWMgZGF0YVwiKTtcbiAgICAgIGZvciBqID0gMCB0byBkaW0yIC0gMSBkb1xuICAgICAgICBsZXQgY29sID0gcm93LihqKSBpblxuICAgICAgICBpZiBBcnJheS5sZW5ndGggY29sIDw+IGRpbTMgdGhlblxuICAgICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkzLm9mX2FycmF5OiBub24tY3ViaWMgZGF0YVwiKTtcbiAgICAgICAgZm9yIGsgPSAwIHRvIGRpbTMgLSAxIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBiYSAoaSArIG9mcykgKGogKyBvZnMpIChrICsgb2ZzKSBjb2wuKGspXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIGJhXG5lbmRcblxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkwOiAoJ2EsICdiLCAnYykgQXJyYXkwLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkxOiAoJ2EsICdiLCAnYykgQXJyYXkxLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkyOiAoJ2EsICdiLCAnYykgQXJyYXkyLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkzOiAoJ2EsICdiLCAnYykgQXJyYXkzLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxubGV0IGFycmF5MF9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDAgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTBfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5MV9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDEgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTFfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5Ml9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDIgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTJfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5M19vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDMgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTNfb2ZfZ2VuYXJyYXlcIlxuXG5leHRlcm5hbCByZXNoYXBlOlxuICAgKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnQgLT4gaW50IGFycmF5IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiY2FtbF9iYV9yZXNoYXBlXCJcbmxldCByZXNoYXBlXzAgYSA9IHJlc2hhcGUgYSBbfHxdXG5sZXQgcmVzaGFwZV8xIGEgZGltMSA9IHJlc2hhcGUgYSBbfGRpbTF8XVxubGV0IHJlc2hhcGVfMiBhIGRpbTEgZGltMiA9IHJlc2hhcGUgYSBbfGRpbTE7ZGltMnxdXG5sZXQgcmVzaGFwZV8zIGEgZGltMSBkaW0yIGRpbTMgPSByZXNoYXBlIGEgW3xkaW0xO2RpbTI7ZGltM3xdXG5cbigqIEZvcmNlIGNhbWxfYmFfZ2V0X3sxLDIsMyxOfSB0byBiZSBsaW5rZWQgaW4sIHNpbmNlIHdlIGRvbid0IHJlZmVyXG4gICB0byB0aG9zZSBwcmltaXRpdmVzIGRpcmVjdGx5IGluIHRoaXMgZmlsZSAqKVxuXG5sZXQgXyA9XG4gIGxldCBfID0gR2VuYXJyYXkuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkxLmdldCBpblxuICBsZXQgXyA9IEFycmF5Mi5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTMuZ2V0IGluXG4gICgpXG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTMyXCJdXG5leHRlcm5hbCBnZXQxOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzFcIlxuZXh0ZXJuYWwgZ2V0MjogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8yXCJcbmV4dGVybmFsIGdldDM6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfM1wiXG5leHRlcm5hbCBzZXQxOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzFcIlxuZXh0ZXJuYWwgc2V0MjogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8yXCJcbmV4dGVybmFsIHNldDM6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfM1wiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICopXG4oKiAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDYW1iaXVtLCBDb2xsZWdlIGRlIEZyYW5jZSBhbmQgSW5yaWEgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciAqKVxuXG5leHRlcm5hbCByYW5kb21fc2VlZDogdW5pdCAtPiBpbnQgYXJyYXkgPSBcImNhbWxfc3lzX3JhbmRvbV9zZWVkXCJcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG5cbiAgb3BlbiBCaWdhcnJheVxuXG4gIHR5cGUgdCA9IChpbnQ2NCwgaW50NjRfZWx0LCBjX2xheW91dCkgQXJyYXkxLnRcblxuICBleHRlcm5hbCBuZXh0OiB0IC0+IChpbnQ2NFtAdW5ib3hlZF0pXG4gICAgICA9IFwiY2FtbF9seG1fbmV4dFwiIFwiY2FtbF9seG1fbmV4dF91bmJveGVkXCIgW0BAbm9hbGxvY11cblxuICBsZXQgY3JlYXRlICgpIDogdCA9XG4gICAgQXJyYXkxLmNyZWF0ZSBJbnQ2NCBDX2xheW91dCA0XG5cbiAgbGV0IHNldCBzIGkxIGkyIGkzIGk0ID1cbiAgICBBcnJheTEudW5zYWZlX3NldCBzIDAgKEludDY0LmxvZ29yIGkxIDFMKTsgKCogbXVzdCBiZSBvZGQgKilcbiAgICBBcnJheTEudW5zYWZlX3NldCBzIDEgaTI7XG4gICAgQXJyYXkxLnVuc2FmZV9zZXQgcyAyIChpZiBpMyA8PiAwTCB0aGVuIGkzIGVsc2UgMUwpOyAoKiBtdXN0IG5vdCBiZSAwICopXG4gICAgQXJyYXkxLnVuc2FmZV9zZXQgcyAzIChpZiBpNCA8PiAwTCB0aGVuIGk0IGVsc2UgMkwpICgqIG11c3Qgbm90IGJlIDAgKilcblxuICBsZXQgbWsgaTEgaTIgaTMgaTQgPVxuICAgIGxldCBzID0gY3JlYXRlICgpIGluXG4gICAgc2V0IHMgaTEgaTIgaTMgaTQ7IHNcblxuICBsZXQgYXNzaWduIChkc3Q6IHQpIChzcmM6IHQpID1cbiAgICBBcnJheTEuYmxpdCBzcmMgZHN0XG5cbiAgbGV0IGNvcHkgcyA9XG4gICAgbGV0IHMnID0gY3JlYXRlKCkgaW4gYXNzaWduIHMnIHM7IHMnXG5cbiAgKCogVGhlIHNlZWQgaXMgYW4gYXJyYXkgb2YgaW50ZWdlcnMuICBJdCBjYW4gYmUganVzdCBvbmUgaW50ZWdlcixcbiAgICAgYnV0IGl0IGNhbiBhbHNvIGJlIDEyIG9yIG1vcmUgYnl0ZXMuICBUbyBoaWRlIHRoZSBkaWZmZXJlbmNlLFxuICAgICB3ZSBzZXJpYWxpemUgdGhlIGFycmF5IGFzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMsIHRoZW4gaGFzaCB0aGVcbiAgICAgc2VxdWVuY2Ugd2l0aCBNRDUgKERpZ2VzdC5ieXRlcykuICBNRDUgZ2l2ZXMgb25seSAxMjggYml0cyB3aGlsZVxuICAgICB3ZSBuZWVkIDI1NiBiaXRzLCBzbyB3ZSBoYXNoIHR3aWNlIHdpdGggZGlmZmVyZW50IHN1ZmZpeGVzLiAqKVxuICBsZXQgcmVpbml0IHMgc2VlZCA9XG4gICAgbGV0IG4gPSBBcnJheS5sZW5ndGggc2VlZCBpblxuICAgIGxldCBiID0gQnl0ZXMuY3JlYXRlIChuICogOCArIDEpIGluXG4gICAgZm9yIGkgPSAwIHRvIG4tMSBkb1xuICAgICAgQnl0ZXMuc2V0X2ludDY0X2xlIGIgKGkgKiA4KSAoSW50NjQub2ZfaW50IHNlZWQuKGkpKVxuICAgIGRvbmU7XG4gICAgQnl0ZXMuc2V0IGIgKG4gKiA4KSAnXFx4MDEnO1xuICAgIGxldCBkMSA9IERpZ2VzdC5ieXRlcyBiIGluXG4gICAgQnl0ZXMuc2V0IGIgKG4gKiA4KSAnXFx4MDInO1xuICAgIGxldCBkMiA9IERpZ2VzdC5ieXRlcyBiIGluXG4gICAgc2V0IHMgKFN0cmluZy5nZXRfaW50NjRfbGUgZDEgMClcbiAgICAgICAgICAoU3RyaW5nLmdldF9pbnQ2NF9sZSBkMSA4KVxuICAgICAgICAgIChTdHJpbmcuZ2V0X2ludDY0X2xlIGQyIDApXG4gICAgICAgICAgKFN0cmluZy5nZXRfaW50NjRfbGUgZDIgOClcblxuICBsZXQgbWFrZSBzZWVkID1cbiAgICBsZXQgcyA9IGNyZWF0ZSgpIGluIHJlaW5pdCBzIHNlZWQ7IHNcblxuICBsZXQgbWFrZV9zZWxmX2luaXQgKCkgPVxuICAgIG1ha2UgKHJhbmRvbV9zZWVkICgpKVxuXG4gICgqIFJldHVybiAzMCByYW5kb20gYml0cyBhcyBhbiBpbnRlZ2VyIDAgPD0geCA8IDEwNzM3NDE4MjQgKilcbiAgbGV0IGJpdHMgcyA9XG4gICAgSW50NjQudG9faW50IChuZXh0IHMpIGxhbmQgMHgzRkZGX0ZGRkZcblxuICAoKiBSZXR1cm4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgKGluY2x1ZGVkKSBhbmQgW2JvdW5kXSAoZXhjbHVkZWQpICopXG4gIGxldCByZWMgaW50YXV4IHMgbiA9XG4gICAgbGV0IHIgPSBiaXRzIHMgaW5cbiAgICBsZXQgdiA9IHIgbW9kIG4gaW5cbiAgICBpZiByIC0gdiA+IDB4M0ZGRkZGRkYgLSBuICsgMSB0aGVuIGludGF1eCBzIG4gZWxzZSB2XG5cbiAgbGV0IGludCBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA+IDB4M0ZGRkZGRkYgfHwgYm91bmQgPD0gMFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50XCJcbiAgICBlbHNlIGludGF1eCBzIGJvdW5kXG5cbiAgKCogUmV0dXJuIGFuIGludGVnZXIgYmV0d2VlbiAwIChpbmNsdWRlZCkgYW5kIFtib3VuZF0gKGV4Y2x1ZGVkKS5cbiAgICAgW2JvdW5kXSBtYXkgYmUgYW55IHBvc2l0aXZlIFtpbnRdLiAqKVxuICBsZXQgcmVjIGludDYzYXV4IHMgbiA9XG4gICAgbGV0IHIgPSBJbnQ2NC50b19pbnQgKG5leHQgcykgbGFuZCBtYXhfaW50IGluXG4gICAgbGV0IHYgPSByIG1vZCBuIGluXG4gICAgaWYgciAtIHYgPiBtYXhfaW50IC0gbiArIDEgdGhlbiBpbnQ2M2F1eCBzIG4gZWxzZSB2XG5cbiAgbGV0IGZ1bGxfaW50IHMgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDAgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJSYW5kb20uZnVsbF9pbnRcIlxuICAgIGVsc2UgaWYgYm91bmQgPiAweDNGRkZGRkZGIHRoZW5cbiAgICAgIGludDYzYXV4IHMgYm91bmRcbiAgICBlbHNlXG4gICAgICBpbnRhdXggcyBib3VuZFxuXG4gICgqIFJldHVybiAzMiByYW5kb20gYml0cyBhcyBhbiBbaW50MzJdICopXG4gIGxldCBiaXRzMzIgcyA9XG4gICAgSW50NjQudG9faW50MzIgKG5leHQgcylcblxuICAoKiBSZXR1cm4gYW4gW2ludDMyXSBiZXR3ZWVuIDAgKGluY2x1ZGVkKSBhbmQgW2JvdW5kXSAoZXhjbHVkZWQpLiAqKVxuICBsZXQgcmVjIGludDMyYXV4IHMgbiA9XG4gICAgbGV0IHIgPSBJbnQzMi5zaGlmdF9yaWdodF9sb2dpY2FsIChiaXRzMzIgcykgMSBpblxuICAgIGxldCB2ID0gSW50MzIucmVtIHIgbiBpblxuICAgIGlmIEludDMyLihzdWIgciB2ID4gYWRkIChzdWIgbWF4X2ludCBuKSAxbClcbiAgICB0aGVuIGludDMyYXV4IHMgblxuICAgIGVsc2UgdlxuXG4gIGxldCBpbnQzMiBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwbFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50MzJcIlxuICAgIGVsc2UgaW50MzJhdXggcyBib3VuZFxuXG4gICgqIFJldHVybiA2NCByYW5kb20gYml0cyBhcyBhbiBbaW50NjRdICopXG4gIGxldCBiaXRzNjQgcyA9XG4gICAgbmV4dCBzXG5cbiAgKCogUmV0dXJuIGFuIFtpbnQ2NF0gYmV0d2VlbiAwIChpbmNsdWRlZCkgYW5kIFtib3VuZF0gKGV4Y2x1ZGVkKS4gKilcbiAgbGV0IHJlYyBpbnQ2NGF1eCBzIG4gPVxuICAgIGxldCByID0gSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCAoYml0czY0IHMpIDEgaW5cbiAgICBsZXQgdiA9IEludDY0LnJlbSByIG4gaW5cbiAgICBpZiBJbnQ2NC4oc3ViIHIgdiA+IGFkZCAoc3ViIG1heF9pbnQgbikgMUwpXG4gICAgdGhlbiBpbnQ2NGF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50NjQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMExcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDY0XCJcbiAgICBlbHNlIGludDY0YXV4IHMgYm91bmRcblxuICAoKiBSZXR1cm4gMzIgb3IgNjQgcmFuZG9tIGJpdHMgYXMgYSBbbmF0aXZlaW50XSAqKVxuICBsZXQgbmF0aXZlYml0cyA9XG4gICAgaWYgTmF0aXZlaW50LnNpemUgPSAzMlxuICAgIHRoZW4gZnVuIHMgLT4gTmF0aXZlaW50Lm9mX2ludDMyIChiaXRzMzIgcylcbiAgICBlbHNlIGZ1biBzIC0+IEludDY0LnRvX25hdGl2ZWludCAoYml0czY0IHMpXG5cbiAgKCogUmV0dXJuIGEgW25hdGl2ZWludF0gYmV0d2VlbiAwIChpbmNsdWRlZCkgYW5kIFtib3VuZF0gKGV4Y2x1ZGVkKS4gKilcbiAgbGV0IG5hdGl2ZWludCA9XG4gICAgaWYgTmF0aXZlaW50LnNpemUgPSAzMlxuICAgIHRoZW4gZnVuIHMgYm91bmQgLT4gTmF0aXZlaW50Lm9mX2ludDMyIChpbnQzMiBzIChOYXRpdmVpbnQudG9faW50MzIgYm91bmQpKVxuICAgIGVsc2UgZnVuIHMgYm91bmQgLT4gSW50NjQudG9fbmF0aXZlaW50IChpbnQ2NCBzIChJbnQ2NC5vZl9uYXRpdmVpbnQgYm91bmQpKVxuXG4gICgqIFJldHVybiBhIGZsb2F0IDAgPCB4IDwgMSB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQgYW1vbmcgdGhlXG4gICAgIG11bHRpcGxlcyBvZiAyXi01MyAqKVxuICBsZXQgcmVjIHJhd2Zsb2F0IHMgPVxuICAgIGxldCBiID0gbmV4dCBzIGluXG4gICAgbGV0IG4gPSBJbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIGIgMTEgaW5cbiAgICBpZiBuIDw+IDBMIHRoZW4gSW50NjQudG9fZmxvYXQgbiAqLiAweDEucC01MyBlbHNlIHJhd2Zsb2F0IHNcblxuICAoKiBSZXR1cm4gYSBmbG9hdCBiZXR3ZWVuIDAgYW5kIFtib3VuZF0gKilcbiAgbGV0IGZsb2F0IHMgYm91bmQgPSByYXdmbG9hdCBzICouIGJvdW5kXG5cbiAgKCogUmV0dXJuIGEgcmFuZG9tIEJvb2xlYW4gKilcbiAgbGV0IGJvb2wgcyA9IG5leHQgcyA8IDBMXG5cbiAgKCogU3BsaXQgYSBuZXcgUFJORyBvZmYgdGhlIGdpdmVuIFBSTkcgKilcbiAgbGV0IHNwbGl0IHMgPVxuICAgIGxldCBpMSA9IGJpdHM2NCBzIGluIGxldCBpMiA9IGJpdHM2NCBzIGluXG4gICAgbGV0IGkzID0gYml0czY0IHMgaW4gbGV0IGk0ID0gYml0czY0IHMgaW5cbiAgICBtayBpMSBpMiBpMyBpNFxuZW5kXG5cbmxldCBta19kZWZhdWx0ICgpID1cbiAgKCogVGhpcyBpcyB0aGUgc3RhdGUgb2J0YWluZWQgd2l0aCBbU3RhdGUubWFrZSBbfCAzMTQxNTkyNjUgfF1dLiAqKVxuICBTdGF0ZS5tayAoLTYxOTY4NzQyODk1Njc3MDUwOTdMKVxuICAgICAgICAgICA1ODY1NzMyNDk4MzM3MTMxODlMXG4gICAgICAgICAgICgtODU5MTI2ODgwMzg2NTA0MzQwN0wpXG4gICAgICAgICAgIDYzODg2MTM1OTU4NDk3NzIwNDRMXG5cbmxldCByYW5kb21fa2V5ID1cbiAgRG9tYWluLkRMUy5uZXdfa2V5IH5zcGxpdF9mcm9tX3BhcmVudDpTdGF0ZS5zcGxpdCBta19kZWZhdWx0XG5cbmxldCBiaXRzICgpID0gU3RhdGUuYml0cyAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSlcbmxldCBpbnQgYm91bmQgPSBTdGF0ZS5pbnQgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpIGJvdW5kXG5sZXQgZnVsbF9pbnQgYm91bmQgPSBTdGF0ZS5mdWxsX2ludCAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSkgYm91bmRcbmxldCBpbnQzMiBib3VuZCA9IFN0YXRlLmludDMyIChEb21haW4uRExTLmdldCByYW5kb21fa2V5KSBib3VuZFxubGV0IG5hdGl2ZWludCBib3VuZCA9IFN0YXRlLm5hdGl2ZWludCAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSkgYm91bmRcbmxldCBpbnQ2NCBib3VuZCA9IFN0YXRlLmludDY0IChEb21haW4uRExTLmdldCByYW5kb21fa2V5KSBib3VuZFxubGV0IGZsb2F0IHNjYWxlID0gU3RhdGUuZmxvYXQgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpIHNjYWxlXG5sZXQgYm9vbCAoKSA9IFN0YXRlLmJvb2wgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpXG5sZXQgYml0czMyICgpID0gU3RhdGUuYml0czMyIChEb21haW4uRExTLmdldCByYW5kb21fa2V5KVxubGV0IGJpdHM2NCAoKSA9IFN0YXRlLmJpdHM2NCAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSlcbmxldCBuYXRpdmViaXRzICgpID0gU3RhdGUubmF0aXZlYml0cyAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSlcblxubGV0IGZ1bGxfaW5pdCBzZWVkID0gU3RhdGUucmVpbml0IChEb21haW4uRExTLmdldCByYW5kb21fa2V5KSBzZWVkXG5sZXQgaW5pdCBzZWVkID0gZnVsbF9pbml0IFt8IHNlZWQgfF1cbmxldCBzZWxmX2luaXQgKCkgPSBmdWxsX2luaXQgKHJhbmRvbV9zZWVkKCkpXG5cbigqIFNwbGl0dGluZyAqKVxuXG5sZXQgc3BsaXQgKCkgPSBTdGF0ZS5zcGxpdCAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSlcblxuKCogTWFuaXB1bGF0aW5nIHRoZSBjdXJyZW50IHN0YXRlLiAqKVxuXG5sZXQgZ2V0X3N0YXRlICgpID0gU3RhdGUuY29weSAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSlcbmxldCBzZXRfc3RhdGUgcyA9IFN0YXRlLmFzc2lnbiAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSkgc1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBIYXNoIHRhYmxlcyAqKVxuXG4oKiBXZSBkbyBkeW5hbWljIGhhc2hpbmcsIGFuZCByZXNpemUgdGhlIHRhYmxlIGFuZCByZWhhc2ggdGhlIGVsZW1lbnRzXG4gICB3aGVuIHRoZSBsb2FkIGZhY3RvciBiZWNvbWVzIHRvbyBoaWdoLiAqKVxuXG50eXBlICgnYSwgJ2IpIHQgPVxuICB7IG11dGFibGUgc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIG51bWJlciBvZiBlbnRyaWVzICopXG4gICAgbXV0YWJsZSBkYXRhOiAoJ2EsICdiKSBidWNrZXRsaXN0IGFycmF5OyAgKCogdGhlIGJ1Y2tldHMgKilcbiAgICBzZWVkOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgKCogZm9yIHJhbmRvbWl6YXRpb24gKilcbiAgICBtdXRhYmxlIGluaXRpYWxfc2l6ZTogaW50OyAgICAgICAgICAgICAgICAoKiBpbml0aWFsIGFycmF5IHNpemUgKilcbiAgfVxuXG5hbmQgKCdhLCAnYikgYnVja2V0bGlzdCA9XG4gICAgRW1wdHlcbiAgfCBDb25zIG9mIHsgbXV0YWJsZSBrZXk6ICdhO1xuICAgICAgICAgICAgICBtdXRhYmxlIGRhdGE6ICdiO1xuICAgICAgICAgICAgICBtdXRhYmxlIG5leHQ6ICgnYSwgJ2IpIGJ1Y2tldGxpc3QgfVxuXG4oKiBUaGUgc2lnbiBvZiBpbml0aWFsX3NpemUgZW5jb2RlcyB0aGUgZmFjdCB0aGF0IGEgdHJhdmVyc2FsIGlzXG4gICBvbmdvaW5nIG9yIG5vdC5cblxuICAgVGhpcyBkaXNhYmxlcyB0aGUgZWZmaWNpZW50IGluIHBsYWNlIGltcGxlbWVudGF0aW9uIG9mIHJlc2l6aW5nLlxuKilcblxubGV0IG9uZ29pbmdfdHJhdmVyc2FsIGggPVxuICBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPCA0ICgqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgaGFzaCB0YWJsZXMgKilcbiAgfHwgaC5pbml0aWFsX3NpemUgPCAwXG5cbmxldCBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGggPVxuICBoLmluaXRpYWxfc2l6ZSA8LSAtIGguaW5pdGlhbF9zaXplXG5cbigqIFRvIHBpY2sgcmFuZG9tIHNlZWRzIGlmIHJlcXVlc3RlZCAqKVxuXG5sZXQgcmFuZG9taXplZF9kZWZhdWx0ID1cbiAgbGV0IHBhcmFtcyA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJPQ0FNTFJVTlBBUkFNXCIgd2l0aCBOb3RfZm91bmQgLT5cbiAgICB0cnkgU3lzLmdldGVudiBcIkNBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+IFwiXCIgaW5cbiAgU3RyaW5nLmNvbnRhaW5zIHBhcmFtcyAnUidcblxubGV0IHJhbmRvbWl6ZWQgPSBBdG9taWMubWFrZSByYW5kb21pemVkX2RlZmF1bHRcblxubGV0IHJhbmRvbWl6ZSAoKSA9IEF0b21pYy5zZXQgcmFuZG9taXplZCB0cnVlXG5sZXQgaXNfcmFuZG9taXplZCAoKSA9IEF0b21pYy5nZXQgcmFuZG9taXplZFxuXG5sZXQgcHJuZ19rZXkgPSBEb21haW4uRExTLm5ld19rZXkgUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0XG5cbigqIEZ1bmN0aW9ucyB3aGljaCBhcHBlYXIgYmVmb3JlIHRoZSBmdW5jdG9yaWFsIGludGVyZmFjZSBtdXN0IGVpdGhlciBiZVxuICAgaW5kZXBlbmRlbnQgb2YgdGhlIGhhc2ggZnVuY3Rpb24gb3IgdGFrZSBpdCBhcyBhIHBhcmFtZXRlciAoc2VlICMyMjAyIGFuZFxuICAgY29kZSBiZWxvdyB0aGUgZnVuY3RvciBkZWZpbml0aW9ucy4gKilcblxuKCogQ3JlYXRpbmcgYSBmcmVzaCwgZW1wdHkgdGFibGUgKilcblxubGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gIGlmIHggPj0gbiB0aGVuIHhcbiAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbmxldCBjcmVhdGUgPyhyYW5kb20gPSBBdG9taWMuZ2V0IHJhbmRvbWl6ZWQpIGluaXRpYWxfc2l6ZSA9XG4gIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgbGV0IHNlZWQgPVxuICAgIGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChEb21haW4uRExTLmdldCBwcm5nX2tleSkgZWxzZSAwXG4gIGluXG4gIHsgaW5pdGlhbF9zaXplID0gczsgc2l6ZSA9IDA7IHNlZWQgPSBzZWVkOyBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5IH1cblxubGV0IGNsZWFyIGggPVxuICBpZiBoLnNpemUgPiAwIHRoZW4gYmVnaW5cbiAgICBoLnNpemUgPC0gMDtcbiAgICBBcnJheS5maWxsIGguZGF0YSAwIChBcnJheS5sZW5ndGggaC5kYXRhKSBFbXB0eVxuICBlbmRcblxubGV0IHJlc2V0IGggPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPCA0ICgqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgaGFzaCB0YWJsZXMgKilcbiAgICB8fCBsZW4gPSBhYnMgaC5pbml0aWFsX3NpemUgdGhlblxuICAgIGNsZWFyIGhcbiAgZWxzZSBiZWdpblxuICAgIGguc2l6ZSA8LSAwO1xuICAgIGguZGF0YSA8LSBBcnJheS5tYWtlIChhYnMgaC5pbml0aWFsX3NpemUpIEVtcHR5XG4gIGVuZFxuXG5sZXQgY29weV9idWNrZXRsaXN0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBFbXB0eVxuICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGxldCByZWMgbG9vcCBwcmVjID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICAgIGxldCByID0gQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgfCBDb25zIHByZWMgLT4gIHByZWMubmV4dCA8LSByXG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBsb29wIHIgbmV4dFxuICAgICAgaW5cbiAgICAgIGxldCByID0gQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSBpblxuICAgICAgbG9vcCByIG5leHQ7XG4gICAgICByXG5cbmxldCBjb3B5IGggPSB7IGggd2l0aCBkYXRhID0gQXJyYXkubWFwIGNvcHlfYnVja2V0bGlzdCBoLmRhdGEgfVxuXG5sZXQgbGVuZ3RoIGggPSBoLnNpemVcblxubGV0IGluc2VydF9hbGxfYnVja2V0cyBpbmRleGZ1biBpbnBsYWNlIG9kYXRhIG5kYXRhID1cbiAgbGV0IG5zaXplID0gQXJyYXkubGVuZ3RoIG5kYXRhIGluXG4gIGxldCBuZGF0YV90YWlsID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICBsZXQgcmVjIGluc2VydF9idWNrZXQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gYXMgY2VsbCAtPlxuICAgICAgICBsZXQgY2VsbCA9XG4gICAgICAgICAgaWYgaW5wbGFjZSB0aGVuIGNlbGxcbiAgICAgICAgICBlbHNlIENvbnMge2tleTsgZGF0YTsgbmV4dCA9IEVtcHR5fVxuICAgICAgICBpblxuICAgICAgICBsZXQgbmlkeCA9IGluZGV4ZnVuIGtleSBpblxuICAgICAgICBiZWdpbiBtYXRjaCBuZGF0YV90YWlsLihuaWR4KSB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gbmRhdGEuKG5pZHgpIDwtIGNlbGw7XG4gICAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBjZWxsO1xuICAgICAgICBlbmQ7XG4gICAgICAgIG5kYXRhX3RhaWwuKG5pZHgpIDwtIGNlbGw7XG4gICAgICAgIGluc2VydF9idWNrZXQgbmV4dFxuICBpblxuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIG9kYXRhIC0gMSBkb1xuICAgIGluc2VydF9idWNrZXQgb2RhdGEuKGkpXG4gIGRvbmU7XG4gIGlmIGlucGxhY2UgdGhlblxuICAgIGZvciBpID0gMCB0byBuc2l6ZSAtIDEgZG9cbiAgICAgIG1hdGNoIG5kYXRhX3RhaWwuKGkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBFbXB0eVxuICAgIGRvbmVcblxubGV0IHJlc2l6ZSBpbmRleGZ1biBoID1cbiAgbGV0IG9kYXRhID0gaC5kYXRhIGluXG4gIGxldCBvc2l6ZSA9IEFycmF5Lmxlbmd0aCBvZGF0YSBpblxuICBsZXQgbnNpemUgPSBvc2l6ZSAqIDIgaW5cbiAgaWYgbnNpemUgPCBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIGJlZ2luXG4gICAgbGV0IG5kYXRhID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICAgIGxldCBpbnBsYWNlID0gbm90IChvbmdvaW5nX3RyYXZlcnNhbCBoKSBpblxuICAgIGguZGF0YSA8LSBuZGF0YTsgICAgICAgICAgKCogc28gdGhhdCBpbmRleGZ1biBzZWVzIHRoZSBuZXcgYnVja2V0IGNvdW50ICopXG4gICAgaW5zZXJ0X2FsbF9idWNrZXRzIChpbmRleGZ1biBoKSBpbnBsYWNlIG9kYXRhIG5kYXRhXG4gIGVuZFxuXG5sZXQgaXRlciBmIGggPVxuICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPlxuICAgICAgICAoKVxuICAgIHwgQ29uc3trZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIGYga2V5IGRhdGE7IGRvX2J1Y2tldCBuZXh0IGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGRvX2J1Y2tldCBkLihpKVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxubGV0IHJlYyBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHByZWMgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBFbXB0eVxuICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIEVtcHR5XG4gICAgICBlbmRcbiAgfCAoQ29ucyAoe2tleTsgZGF0YTsgbmV4dH0gYXMgYykpIGFzIHNsb3QgLT5cbiAgICAgIGJlZ2luIG1hdGNoIGYga2V5IGRhdGEgd2l0aFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBwcmVjIG5leHRcbiAgICAgIHwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIHNsb3RcbiAgICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gc2xvdFxuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBjLmRhdGEgPC0gZGF0YTtcbiAgICAgICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHNsb3QgbmV4dFxuICAgICAgZW5kXG5cbmxldCBmaWx0ZXJfbWFwX2lucGxhY2UgZiBoID1cbiAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgRW1wdHkgaC5kYXRhLihpKVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoXG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG5sZXQgZm9sZCBmIGggaW5pdCA9XG4gIGxldCByZWMgZG9fYnVja2V0IGIgYWNjdSA9XG4gICAgbWF0Y2ggYiB3aXRoXG4gICAgICBFbXB0eSAtPlxuICAgICAgICBhY2N1XG4gICAgfCBDb25ze2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgZG9fYnVja2V0IG5leHQgKGYga2V5IGRhdGEgYWNjdSkgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgbGV0IGFjY3UgPSByZWYgaW5pdCBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGFjY3UgOj0gZG9fYnVja2V0IGQuKGkpICFhY2N1XG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgIWFjY3VcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbnR5cGUgc3RhdGlzdGljcyA9IHtcbiAgbnVtX2JpbmRpbmdzOiBpbnQ7XG4gIG51bV9idWNrZXRzOiBpbnQ7XG4gIG1heF9idWNrZXRfbGVuZ3RoOiBpbnQ7XG4gIGJ1Y2tldF9oaXN0b2dyYW06IGludCBhcnJheVxufVxuXG5sZXQgcmVjIGJ1Y2tldF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYWNjdVxuICB8IENvbnN7bmV4dH0gLT4gYnVja2V0X2xlbmd0aCAoYWNjdSArIDEpIG5leHRcblxubGV0IHN0YXRzIGggPVxuICBsZXQgbWJsID1cbiAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gSW50Lm1heCBtIChidWNrZXRfbGVuZ3RoIDAgYikpIDAgaC5kYXRhIGluXG4gIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgQXJyYXkuaXRlclxuICAgIChmdW4gYiAtPlxuICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoIDAgYiBpblxuICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgaC5kYXRhO1xuICB7IG51bV9iaW5kaW5ncyA9IGguc2l6ZTtcbiAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSB0YmwgPVxuICAoKiBjYXB0dXJlIGN1cnJlbnQgYXJyYXksIHNvIHRoYXQgZXZlbiBpZiB0aGUgdGFibGUgaXMgcmVzaXplZCB3ZVxuICAgICBrZWVwIGl0ZXJhdGluZyBvbiB0aGUgc2FtZSBhcnJheSAqKVxuICBsZXQgdGJsX2RhdGEgPSB0YmwuZGF0YSBpblxuICAoKiBzdGF0ZTogaW5kZXggKiBuZXh0IGJ1Y2tldCB0byB0cmF2ZXJzZSAqKVxuICBsZXQgcmVjIGF1eCBpIGJ1Y2sgKCkgPSBtYXRjaCBidWNrIHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICAgIGlmIGkgPSBBcnJheS5sZW5ndGggdGJsX2RhdGFcbiAgICAgICAgdGhlbiBTZXEuTmlsXG4gICAgICAgIGVsc2UgYXV4KGkrMSkgdGJsX2RhdGEuKGkpICgpXG4gICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIFNlcS5Db25zICgoa2V5LCBkYXRhKSwgYXV4IGkgbmV4dClcbiAgaW5cbiAgYXV4IDAgRW1wdHlcblxubGV0IHRvX3NlcV9rZXlzIG0gPSBTZXEubWFwIGZzdCAodG9fc2VxIG0pXG5cbmxldCB0b19zZXFfdmFsdWVzIG0gPSBTZXEubWFwIHNuZCAodG9fc2VxIG0pXG5cbigqIEZ1bmN0b3JpYWwgaW50ZXJmYWNlICopXG5cbm1vZHVsZSB0eXBlIEhhc2hlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGhhc2g6IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTZWVkZWRIYXNoZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBzZWVkZWRfaGFzaDogaW50IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICEnYSB0XG4gICAgdmFsIGNyZWF0ZTogaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weTogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmU6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAhJ2EgdFxuICAgIHZhbCBjcmVhdGUgOiA/cmFuZG9tOmJvb2wgLT4gaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBhZGQgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIHJlbW92ZSA6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9hbGwgOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gICAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgICB2YWwgaXRlciA6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkIDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICAgIHZhbCBzdGF0czogJ2EgdCAtPiBzdGF0aXN0aWNzXG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19zZXFfa2V5cyA6IF8gdCAtPiBrZXkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX3ZhbHVlcyA6ICdhIHQgLT4gJ2EgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIHJlcGxhY2Vfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZVNlZWRlZChIOiBTZWVkZWRIYXNoZWRUeXBlKTogKFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGtleSA9IEgudFxuICAgIHR5cGUgJ2EgaGFzaHRibCA9IChrZXksICdhKSB0XG4gICAgdHlwZSAnYSB0ID0gJ2EgaGFzaHRibFxuICAgIGxldCBjcmVhdGUgPSBjcmVhdGVcbiAgICBsZXQgY2xlYXIgPSBjbGVhclxuICAgIGxldCByZXNldCA9IHJlc2V0XG4gICAgbGV0IGNvcHkgPSBjb3B5XG5cbiAgICBsZXQga2V5X2luZGV4IGgga2V5ID1cbiAgICAgIChILnNlZWRlZF9oYXNoIGguc2VlZCBrZXkpIGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuXG4gICAgbGV0IGFkZCBoIGtleSBkYXRhID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICBsZXQgYnVja2V0ID0gQ29uc3trZXk7IGRhdGE7IG5leHQ9aC5kYXRhLihpKX0gaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9idWNrZXQgaCBpIGtleSBwcmVjID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAoKVxuICAgICAgfCAoQ29ucyB7a2V5PWs7IG5leHR9KSBhcyBjIC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIG5leHRcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxuICAgIGxldCByZW1vdmUgaCBrZXkgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjIGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgayB0aGVuIGRhdGEgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dFxuXG4gICAgbGV0IGZpbmQgaCBrZXkgPVxuICAgICAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsxIHRoZW4gZDEgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsyIHRoZW4gZDIgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMyB0aGVuIGQzIGVsc2UgZmluZF9yZWMga2V5IG5leHQzXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbiAgICBsZXQgZmluZF9vcHQgaCBrZXkgPVxuICAgICAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMSB0aGVuIFNvbWUgZDEgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMiB0aGVuIFNvbWUgZDIgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazMgdGhlbiBTb21lIGQzIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0M1xuXG4gICAgbGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgICAgIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIFtdXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE9ZDsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiBkIDo6IGZpbmRfaW5fYnVja2V0IG5leHRcbiAgICAgICAgICBlbHNlIGZpbmRfaW5fYnVja2V0IG5leHQgaW5cbiAgICAgIGZpbmRfaW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG4gICAgbGV0IHJlYyByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgfCBDb25zICh7a2V5PWs7IG5leHR9IGFzIHNsb3QpIC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gKHNsb3Qua2V5IDwtIGtleTsgc2xvdC5kYXRhIDwtIGRhdGE7IGZhbHNlKVxuICAgICAgICAgIGVsc2UgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbmV4dFxuXG4gICAgbGV0IHJlcGxhY2UgaCBrZXkgZGF0YSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgbGV0IGwgPSBoLmRhdGEuKGkpIGluXG4gICAgICBpZiByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBsIHRoZW4gYmVnaW5cbiAgICAgICAgaC5kYXRhLihpKSA8LSBDb25ze2tleTsgZGF0YTsgbmV4dD1sfTtcbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcbiAgICAgIGVuZFxuXG4gICAgbGV0IG1lbSBoIGtleSA9XG4gICAgICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnN7a2V5PWs7IG5leHR9IC0+XG4gICAgICAgICAgSC5lcXVhbCBrIGtleSB8fCBtZW1faW5fYnVja2V0IG5leHQgaW5cbiAgICAgIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbiAgICBsZXQgYWRkX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IGFkZCB0YmwgayB2KSBpXG5cbiAgICBsZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiByZXBsYWNlIHRibCBrIHYpIGlcblxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuXG4gICAgbGV0IGl0ZXIgPSBpdGVyXG4gICAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSA9IGZpbHRlcl9tYXBfaW5wbGFjZVxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgc3RhdHMgPSBzdGF0c1xuICAgIGxldCB0b19zZXEgPSB0b19zZXFcbiAgICBsZXQgdG9fc2VxX2tleXMgPSB0b19zZXFfa2V5c1xuICAgIGxldCB0b19zZXFfdmFsdWVzID0gdG9fc2VxX3ZhbHVlc1xuICBlbmRcblxubW9kdWxlIE1ha2UoSDogSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgc2VlZGVkX2hhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcblxuKCogUG9seW1vcnBoaWMgaGFzaCBmdW5jdGlvbi1iYXNlZCB0YWJsZXMgKilcbigqIENvZGUgaW5jbHVkZWQgYmVsb3cgdGhlIGZ1bmN0b3JpYWwgaW50ZXJmYWNlIHRvIGd1YXJkIGFnYWluc3QgYWNjaWRlbnRhbFxuICAgdXNlIC0gc2VlICMyMjAyICopXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxuXG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxubGV0IGhhc2hfcGFyYW0gbjEgbjIgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIG4xIG4yIDAgeFxubGV0IHNlZWRlZF9oYXNoIHNlZWQgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBzZWVkIHhcblxubGV0IGtleV9pbmRleCBoIGtleSA9XG4gIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSA0XG4gIHRoZW4gKHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBoLnNlZWQga2V5KSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkhhc2h0Ymw6IHVuc3VwcG9ydGVkIGhhc2ggdGFibGUgZm9ybWF0XCJcblxubGV0IGFkZCBoIGtleSBkYXRhID1cbiAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgbGV0IGJ1Y2tldCA9IENvbnN7a2V5OyBkYXRhOyBuZXh0PWguZGF0YS4oaSl9IGluXG4gIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuXG5sZXQgcmVjIHJlbW92ZV9idWNrZXQgaCBpIGtleSBwcmVjID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgKClcbiAgfCAoQ29ucyB7a2V5PWs7IG5leHR9KSBhcyBjIC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiBiZWdpblxuICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBuZXh0XG4gICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBuZXh0XG4gICAgICBlbmRcbiAgICAgIGVsc2UgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IGMgbmV4dFxuXG5sZXQgcmVtb3ZlIGgga2V5ID1cbiAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IEVtcHR5IGguZGF0YS4oaSlcblxubGV0IHJlYyBmaW5kX3JlYyBrZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICByYWlzZSBOb3RfZm91bmRcbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgayA9IDAgdGhlbiBkYXRhIGVsc2UgZmluZF9yZWMga2V5IG5leHRcblxubGV0IGZpbmQgaCBrZXkgPVxuICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgazEgPSAwIHRoZW4gZDEgZWxzZVxuICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgaWYgY29tcGFyZSBrZXkgazIgPSAwIHRoZW4gZDIgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGszID0gMCB0aGVuIGQzIGVsc2UgZmluZF9yZWMga2V5IG5leHQzXG5cbmxldCByZWMgZmluZF9yZWNfb3B0IGtleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIE5vbmVcbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgayA9IDAgdGhlbiBTb21lIGRhdGEgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHRcblxubGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgfCBFbXB0eSAtPiBOb25lXG4gIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrMSA9IDAgdGhlbiBTb21lIGQxIGVsc2VcbiAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMiA9IDAgdGhlbiBTb21lIGQyIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgaWYgY29tcGFyZSBrZXkgazMgPSAwIHRoZW4gU29tZSBkMyBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dDNcblxubGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgbGV0IHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIFtdXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIGRhdGEgOjogZmluZF9pbl9idWNrZXQgbmV4dFxuICAgICAgZWxzZSBmaW5kX2luX2J1Y2tldCBuZXh0IGluXG4gIGZpbmRfaW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG5sZXQgcmVjIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgdHJ1ZVxuICB8IENvbnMgKHtrZXk9azsgbmV4dH0gYXMgc2xvdCkgLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIChzbG90LmtleSA8LSBrZXk7IHNsb3QuZGF0YSA8LSBkYXRhOyBmYWxzZSlcbiAgICAgIGVsc2UgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbmV4dFxuXG5sZXQgcmVwbGFjZSBoIGtleSBkYXRhID1cbiAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgbGV0IGwgPSBoLmRhdGEuKGkpIGluXG4gIGlmIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIGwgdGhlbiBiZWdpblxuICAgIGguZGF0YS4oaSkgPC0gQ29uc3trZXk7IGRhdGE7IG5leHQ9bH07XG4gICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuICBlbmRcblxubGV0IG1lbSBoIGtleSA9XG4gIGxldCByZWMgbWVtX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIGZhbHNlXG4gIHwgQ29uc3trZXk9azsgbmV4dH0gLT5cbiAgICAgIGNvbXBhcmUgayBrZXkgPSAwIHx8IG1lbV9pbl9idWNrZXQgbmV4dCBpblxuICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG5sZXQgYWRkX3NlcSB0YmwgaSA9XG4gIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxubGV0IHJlcGxhY2Vfc2VxIHRibCBpID1cbiAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiByZXBsYWNlIHRibCBrIHYpIGlcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgdGJsXG5cbmxldCByZWJ1aWxkID8ocmFuZG9tID0gQXRvbWljLmdldCByYW5kb21pemVkKSBoID1cbiAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IChBcnJheS5sZW5ndGggaC5kYXRhKSBpblxuICBsZXQgc2VlZCA9XG4gICAgaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKERvbWFpbi5ETFMuZ2V0IHBybmdfa2V5KVxuICAgIGVsc2UgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpID49IDQgdGhlbiBoLnNlZWRcbiAgICBlbHNlIDAgaW5cbiAgbGV0IGgnID0ge1xuICAgIHNpemUgPSBoLnNpemU7XG4gICAgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eTtcbiAgICBzZWVkID0gc2VlZDtcbiAgICBpbml0aWFsX3NpemUgPSBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPj0gNCB0aGVuIGguaW5pdGlhbF9zaXplIGVsc2Ugc1xuICB9IGluXG4gIGluc2VydF9hbGxfYnVja2V0cyAoa2V5X2luZGV4IGgnKSBmYWxzZSBoLmRhdGEgaCcuZGF0YTtcbiAgaCdcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCoqIFdlYWsgYXJyYXkgb3BlcmF0aW9ucyAqKVxuXG50eXBlICEnYSB0XG5cbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiAnYSB0ID0gXCJjYW1sX3dlYWtfY3JlYXRlXCJcblxuKCoqIG51bWJlciBvZiBhZGRpdGlvbmFsIHZhbHVlcyBpbiBhIHdlYWsgcG9pbnRlclxuICogICAgLSBMaW5rXG4gKiAgICAtIERhdGEgKilcbmxldCBhZGRpdGlvbmFsX3ZhbHVlcyA9IDIgKCogQ0FNTF9FUEhFX0ZJUlNUX0tFWSBpbiB3ZWFrLmggKilcblxubGV0IGNyZWF0ZSBsID1cbiAgaWYgbm90ICgwIDw9IGwgJiYgbCA8PSBPYmouRXBoZW1lcm9uLm1heF9lcGhlX2xlbmd0aCkgdGhlblxuICAgIGludmFsaWRfYXJnKFwiV2Vhay5jcmVhdGVcIik7XG4gIGNyZWF0ZSBsXG5cblxubGV0IGxlbmd0aCB4ID0gT2JqLnNpemUoT2JqLnJlcHIgeCkgLSBhZGRpdGlvbmFsX3ZhbHVlc1xuXG5sZXQgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIG1zZyA9XG4gIGlmIG5vdCAoMCA8PSBvICYmIG8gPCBsZW5ndGggZSkgdGhlblxuICAgIGludmFsaWRfYXJnKG1zZylcblxuZXh0ZXJuYWwgc2V0JyA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfa2V5XCJcbmV4dGVybmFsIHVuc2V0IDogJ2EgdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3Vuc2V0X2tleVwiXG5sZXQgc2V0IGUgbyB4ID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5zZXRcIjtcbiAgbWF0Y2ggeCB3aXRoXG4gIHwgTm9uZSAtPiB1bnNldCBlIG9cbiAgfCBTb21lIHggLT4gc2V0JyBlIG8geFxuXG5leHRlcm5hbCBnZXQgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gPSBcImNhbWxfd2Vha19nZXRcIlxubGV0IGdldCBlIG8gPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLmdldFwiO1xuICBnZXQgZSBvXG5cbmV4dGVybmFsIGdldF9jb3B5IDogJ2EgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uID0gXCJjYW1sX3dlYWtfZ2V0X2NvcHlcIlxubGV0IGdldF9jb3B5IGUgbyA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuZ2V0X2NvcHlcIjtcbiAgZ2V0X2NvcHkgZSBvXG5cbmV4dGVybmFsIGNoZWNrIDogJ2EgdCAtPiBpbnQgLT4gYm9vbCA9IFwiY2FtbF93ZWFrX2NoZWNrXCJcbmxldCBjaGVjayBlIG8gPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLmNoZWNrXCI7XG4gIGNoZWNrIGUgb1xuXG5leHRlcm5hbCBibGl0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgdCAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfd2Vha19ibGl0XCJcblxuKCogYmxpdDogc3JjIHNyY29mZiBkc3QgZHN0b2ZmIGxlbiAqKVxubGV0IGJsaXQgZTEgbzEgZTIgbzIgbCA9XG4gIGlmIGwgPCAwIHx8IG8xIDwgMCB8fCBvMSA+IGxlbmd0aCBlMSAtIGxcbiAgICAgfHwgbzIgPCAwIHx8IG8yID4gbGVuZ3RoIGUyIC0gbFxuICB0aGVuIGludmFsaWRfYXJnIFwiV2Vhay5ibGl0XCJcbiAgZWxzZSBpZiBsIDw+IDAgdGhlbiBibGl0IGUxIG8xIGUyIG8yIGxcblxubGV0IGZpbGwgYXIgb2ZzIGxlbiB4ID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBhciAtIGxlblxuICB0aGVuIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiV2Vhay5maWxsXCIpXG4gIGVsc2UgYmVnaW5cbiAgICBmb3IgaSA9IG9mcyB0byAob2ZzICsgbGVuIC0gMSkgZG9cbiAgICAgIHNldCBhciBpIHhcbiAgICBkb25lXG4gIGVuZFxuXG5cbigqKiBXZWFrIGhhc2ggdGFibGVzICopXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSBkYXRhXG4gIHR5cGUgdFxuICB2YWwgY3JlYXRlIDogaW50IC0+IHRcbiAgdmFsIGNsZWFyIDogdCAtPiB1bml0XG4gIHZhbCBtZXJnZSA6IHQgLT4gZGF0YSAtPiBkYXRhXG4gIHZhbCBhZGQgOiB0IC0+IGRhdGEgLT4gdW5pdFxuICB2YWwgcmVtb3ZlIDogdCAtPiBkYXRhIC0+IHVuaXRcbiAgdmFsIGZpbmQgOiB0IC0+IGRhdGEgLT4gZGF0YVxuICB2YWwgZmluZF9vcHQgOiB0IC0+IGRhdGEgLT4gZGF0YSBvcHRpb25cbiAgdmFsIGZpbmRfYWxsIDogdCAtPiBkYXRhIC0+IGRhdGEgbGlzdFxuICB2YWwgbWVtIDogdCAtPiBkYXRhIC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAoZGF0YSAtPiB1bml0KSAtPiB0IC0+IHVuaXRcbiAgdmFsIGZvbGQgOiAoZGF0YSAtPiAnYSAtPiAnYSkgLT4gdCAtPiAnYSAtPiAnYVxuICB2YWwgY291bnQgOiB0IC0+IGludFxuICB2YWwgc3RhdHMgOiB0IC0+IGludCAqIGludCAqIGludCAqIGludCAqIGludCAqIGludFxuZW5kXG5cbm1vZHVsZSBNYWtlIChIIDogSGFzaHRibC5IYXNoZWRUeXBlKSA6IChTIHdpdGggdHlwZSBkYXRhID0gSC50KSA9IHN0cnVjdFxuXG4gIHR5cGUgJ2Egd2Vha190ID0gJ2EgdFxuICBsZXQgd2Vha19jcmVhdGUgPSBjcmVhdGVcbiAgbGV0IGVtcHR5YnVja2V0ID0gd2Vha19jcmVhdGUgMFxuXG4gIHR5cGUgZGF0YSA9IEgudFxuXG4gIHR5cGUgdCA9IHtcbiAgICBtdXRhYmxlIHRhYmxlIDogZGF0YSB3ZWFrX3QgYXJyYXk7XG4gICAgbXV0YWJsZSBoYXNoZXMgOiBpbnQgYXJyYXkgYXJyYXk7XG4gICAgbXV0YWJsZSBsaW1pdCA6IGludDsgICAgICAgICAgICAgICAoKiBidWNrZXQgc2l6ZSBsaW1pdCAqKVxuICAgIG11dGFibGUgb3ZlcnNpemUgOiBpbnQ7ICAgICAgICAgICAgKCogbnVtYmVyIG9mIG92ZXJzaXplIGJ1Y2tldHMgKilcbiAgICBtdXRhYmxlIHJvdmVyIDogaW50OyAgICAgICAgICAgICAgICgqIGZvciBpbnRlcm5hbCBib29ra2VlcGluZyAqKVxuICB9XG5cbiAgbGV0IGdldF9pbmRleCB0IGggPSAoaCBsYW5kIG1heF9pbnQpIG1vZCAoQXJyYXkubGVuZ3RoIHQudGFibGUpXG5cbiAgbGV0IGxpbWl0ID0gN1xuICBsZXQgb3Zlcl9saW1pdCA9IDJcblxuICBsZXQgY3JlYXRlIHN6ID1cbiAgICBsZXQgc3ogPSBpZiBzeiA8IDcgdGhlbiA3IGVsc2Ugc3ogaW5cbiAgICBsZXQgc3ogPSBpZiBzeiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4gU3lzLm1heF9hcnJheV9sZW5ndGggZWxzZSBzeiBpblxuICAgIHtcbiAgICAgIHRhYmxlID0gQXJyYXkubWFrZSBzeiBlbXB0eWJ1Y2tldDtcbiAgICAgIGhhc2hlcyA9IEFycmF5Lm1ha2Ugc3ogW3wgfF07XG4gICAgICBsaW1pdCA9IGxpbWl0O1xuICAgICAgb3ZlcnNpemUgPSAwO1xuICAgICAgcm92ZXIgPSAwO1xuICAgIH1cblxuICBsZXQgY2xlYXIgdCA9XG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LnRhYmxlIC0gMSBkb1xuICAgICAgdC50YWJsZS4oaSkgPC0gZW1wdHlidWNrZXQ7XG4gICAgICB0Lmhhc2hlcy4oaSkgPC0gW3wgfF07XG4gICAgZG9uZTtcbiAgICB0LmxpbWl0IDwtIGxpbWl0O1xuICAgIHQub3ZlcnNpemUgPC0gMFxuXG5cbiAgbGV0IGZvbGQgZiB0IGluaXQgPVxuICAgIGxldCByZWMgZm9sZF9idWNrZXQgaSBiIGFjY3UgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuIGFjY3UgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgICB8IFNvbWUgdiAtPiBmb2xkX2J1Y2tldCAoaSsxKSBiIChmIHYgYWNjdSlcbiAgICAgIHwgTm9uZSAtPiBmb2xkX2J1Y2tldCAoaSsxKSBiIGFjY3VcbiAgICBpblxuICAgIEFycmF5LmZvbGRfcmlnaHQgKGZvbGRfYnVja2V0IDApIHQudGFibGUgaW5pdFxuXG5cbiAgbGV0IGl0ZXIgZiB0ID1cbiAgICBsZXQgcmVjIGl0ZXJfYnVja2V0IGkgYiA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gKCkgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgICB8IFNvbWUgdiAtPiBmIHY7IGl0ZXJfYnVja2V0IChpKzEpIGJcbiAgICAgIHwgTm9uZSAtPiBpdGVyX2J1Y2tldCAoaSsxKSBiXG4gICAgaW5cbiAgICBBcnJheS5pdGVyIChpdGVyX2J1Y2tldCAwKSB0LnRhYmxlXG5cblxuICBsZXQgaXRlcl93ZWFrIGYgdCA9XG4gICAgbGV0IHJlYyBpdGVyX2J1Y2tldCBpIGogYiA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gKCkgZWxzZVxuICAgICAgbWF0Y2ggY2hlY2sgYiBpIHdpdGhcbiAgICAgIHwgdHJ1ZSAtPiBmIGIgdC5oYXNoZXMuKGopIGk7IGl0ZXJfYnVja2V0IChpKzEpIGogYlxuICAgICAgfCBmYWxzZSAtPiBpdGVyX2J1Y2tldCAoaSsxKSBqIGJcbiAgICBpblxuICAgIEFycmF5Lml0ZXJpIChpdGVyX2J1Y2tldCAwKSB0LnRhYmxlXG5cblxuICBsZXQgcmVjIGNvdW50X2J1Y2tldCBpIGIgYWNjdSA9XG4gICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuIGFjY3UgZWxzZVxuICAgIGNvdW50X2J1Y2tldCAoaSsxKSBiIChhY2N1ICsgKGlmIGNoZWNrIGIgaSB0aGVuIDEgZWxzZSAwKSlcblxuXG4gIGxldCBjb3VudCB0ID1cbiAgICBBcnJheS5mb2xkX3JpZ2h0IChjb3VudF9idWNrZXQgMCkgdC50YWJsZSAwXG5cblxuICBsZXQgbmV4dF9zeiBuID0gSW50Lm1pbiAoMyAqIG4gLyAyICsgMykgU3lzLm1heF9hcnJheV9sZW5ndGhcbiAgbGV0IHByZXZfc3ogbiA9ICgobiAtIDMpICogMiArIDIpIC8gM1xuXG4gIGxldCB0ZXN0X3Nocmlua19idWNrZXQgdCA9XG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKHQucm92ZXIpIGluXG4gICAgbGV0IGhidWNrZXQgPSB0Lmhhc2hlcy4odC5yb3ZlcikgaW5cbiAgICBsZXQgbGVuID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCBwcmV2X2xlbiA9IHByZXZfc3ogbGVuIGluXG4gICAgbGV0IGxpdmUgPSBjb3VudF9idWNrZXQgMCBidWNrZXQgMCBpblxuICAgIGlmIGxpdmUgPD0gcHJldl9sZW4gdGhlbiBiZWdpblxuICAgICAgbGV0IHJlYyBsb29wIGkgaiA9XG4gICAgICAgIGlmIGogPj0gcHJldl9sZW4gdGhlbiBiZWdpblxuICAgICAgICAgIGlmIGNoZWNrIGJ1Y2tldCBpIHRoZW4gbG9vcCAoaSArIDEpIGpcbiAgICAgICAgICBlbHNlIGlmIGNoZWNrIGJ1Y2tldCBqIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGJsaXQgYnVja2V0IGogYnVja2V0IGkgMTtcbiAgICAgICAgICAgIGhidWNrZXQuKGkpIDwtIGhidWNrZXQuKGopO1xuICAgICAgICAgICAgbG9vcCAoaSArIDEpIChqIC0gMSk7XG4gICAgICAgICAgZW5kIGVsc2UgbG9vcCBpIChqIC0gMSk7XG4gICAgICAgIGVuZDtcbiAgICAgIGluXG4gICAgICBsb29wIDAgKGxlbmd0aCBidWNrZXQgLSAxKTtcbiAgICAgIGlmIHByZXZfbGVuID0gMCB0aGVuIGJlZ2luXG4gICAgICAgIHQudGFibGUuKHQucm92ZXIpIDwtIGVtcHR5YnVja2V0O1xuICAgICAgICB0Lmhhc2hlcy4odC5yb3ZlcikgPC0gW3wgfF07XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsZXQgbmV3YnVja2V0ID0gd2Vha19jcmVhdGUgcHJldl9sZW4gaW5cbiAgICAgICAgYmxpdCBidWNrZXQgMCBuZXdidWNrZXQgMCBwcmV2X2xlbjtcbiAgICAgICAgdC50YWJsZS4odC5yb3ZlcikgPC0gbmV3YnVja2V0O1xuICAgICAgICB0Lmhhc2hlcy4odC5yb3ZlcikgPC0gQXJyYXkuc3ViIGhidWNrZXQgMCBwcmV2X2xlblxuICAgICAgZW5kO1xuICAgICAgaWYgbGVuID4gdC5saW1pdCAmJiBwcmV2X2xlbiA8PSB0LmxpbWl0IHRoZW4gdC5vdmVyc2l6ZSA8LSB0Lm92ZXJzaXplIC0gMTtcbiAgICBlbmQ7XG4gICAgdC5yb3ZlciA8LSAodC5yb3ZlciArIDEpIG1vZCAoQXJyYXkubGVuZ3RoIHQudGFibGUpXG5cblxuICBsZXQgcmVjIHJlc2l6ZSB0ID1cbiAgICBsZXQgb2xkbGVuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgbmV3bGVuID0gbmV4dF9zeiBvbGRsZW4gaW5cbiAgICBpZiBuZXdsZW4gPiBvbGRsZW4gdGhlbiBiZWdpblxuICAgICAgbGV0IG5ld3QgPSBjcmVhdGUgbmV3bGVuIGluXG4gICAgICBsZXQgYWRkX3dlYWsgb2Igb2ggb2kgPVxuICAgICAgICBsZXQgc2V0dGVyIG5iIG5pIF8gPSBibGl0IG9iIG9pIG5iIG5pIDEgaW5cbiAgICAgICAgbGV0IGggPSBvaC4ob2kpIGluXG4gICAgICAgIGFkZF9hdXggbmV3dCBzZXR0ZXIgTm9uZSBoIChnZXRfaW5kZXggbmV3dCBoKTtcbiAgICAgIGluXG4gICAgICBpdGVyX3dlYWsgYWRkX3dlYWsgdDtcbiAgICAgIHQudGFibGUgPC0gbmV3dC50YWJsZTtcbiAgICAgIHQuaGFzaGVzIDwtIG5ld3QuaGFzaGVzO1xuICAgICAgdC5saW1pdCA8LSBuZXd0LmxpbWl0O1xuICAgICAgdC5vdmVyc2l6ZSA8LSBuZXd0Lm92ZXJzaXplO1xuICAgICAgdC5yb3ZlciA8LSB0LnJvdmVyIG1vZCBBcnJheS5sZW5ndGggbmV3dC50YWJsZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgdC5saW1pdCA8LSBtYXhfaW50OyAgICAgICAgICAgICAoKiBtYXhpbXVtIHNpemUgYWxyZWFkeSByZWFjaGVkICopXG4gICAgICB0Lm92ZXJzaXplIDwtIDA7XG4gICAgZW5kXG5cbiAgYW5kIGFkZF9hdXggdCBzZXR0ZXIgZCBoIGluZGV4ID1cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBuZXdzeiA9XG4gICAgICAgICAgSW50Lm1pbiAoMyAqIHN6IC8gMiArIDMpIChTeXMubWF4X2FycmF5X2xlbmd0aCAtIGFkZGl0aW9uYWxfdmFsdWVzKVxuICAgICAgICBpblxuICAgICAgICBpZiBuZXdzeiA8PSBzeiB0aGVuIGZhaWx3aXRoIFwiV2Vhay5NYWtlOiBoYXNoIGJ1Y2tldCBjYW5ub3QgZ3JvdyBtb3JlXCI7XG4gICAgICAgIGxldCBuZXdidWNrZXQgPSB3ZWFrX2NyZWF0ZSBuZXdzeiBpblxuICAgICAgICBsZXQgbmV3aGFzaGVzID0gQXJyYXkubWFrZSBuZXdzeiAwIGluXG4gICAgICAgIGJsaXQgYnVja2V0IDAgbmV3YnVja2V0IDAgc3o7XG4gICAgICAgIEFycmF5LmJsaXQgaGFzaGVzIDAgbmV3aGFzaGVzIDAgc3o7XG4gICAgICAgIHNldHRlciBuZXdidWNrZXQgc3ogZDtcbiAgICAgICAgbmV3aGFzaGVzLihzeikgPC0gaDtcbiAgICAgICAgdC50YWJsZS4oaW5kZXgpIDwtIG5ld2J1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKGluZGV4KSA8LSBuZXdoYXNoZXM7XG4gICAgICAgIGlmIHN6IDw9IHQubGltaXQgJiYgbmV3c3ogPiB0LmxpbWl0IHRoZW4gYmVnaW5cbiAgICAgICAgICB0Lm92ZXJzaXplIDwtIHQub3ZlcnNpemUgKyAxO1xuICAgICAgICAgIGZvciBfaSA9IDAgdG8gb3Zlcl9saW1pdCBkbyB0ZXN0X3Nocmlua19idWNrZXQgdCBkb25lO1xuICAgICAgICBlbmQ7XG4gICAgICAgIGlmIHQub3ZlcnNpemUgPiBBcnJheS5sZW5ndGggdC50YWJsZSAvIG92ZXJfbGltaXQgdGhlbiByZXNpemUgdDtcbiAgICAgIGVuZCBlbHNlIGlmIGNoZWNrIGJ1Y2tldCBpIHRoZW4gYmVnaW5cbiAgICAgICAgbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBzZXR0ZXIgYnVja2V0IGkgZDtcbiAgICAgICAgaGFzaGVzLihpKSA8LSBoO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgYWRkIHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGFkZF9hdXggdCBzZXQgKFNvbWUgZCkgaCAoZ2V0X2luZGV4IHQgaClcblxuXG4gIGxldCBmaW5kX29yIHQgZCBpZm5vdGZvdW5kID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gaWZub3Rmb3VuZCBoIGluZGV4XG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSB2IC0+IHZcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBtZXJnZSB0IGQgPVxuICAgIGZpbmRfb3IgdCBkIChmdW4gaCBpbmRleCAtPiBhZGRfYXV4IHQgc2V0IChTb21lIGQpIGggaW5kZXg7IGQpXG5cblxuICBsZXQgZmluZCB0IGQgPSBmaW5kX29yIHQgZCAoZnVuIF9oIF9pbmRleCAtPiByYWlzZSBOb3RfZm91bmQpXG5cbiAgbGV0IGZpbmRfb3B0IHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIE5vbmVcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIF8gYXMgdiAtPiB2XG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSlcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgZmluZF9zaGFkb3cgdCBkIGlmZm91bmQgaWZub3Rmb3VuZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGlmbm90Zm91bmRcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGQgLT4gaWZmb3VuZCBidWNrZXQgaVxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IHJlbW92ZSB0IGQgPSBmaW5kX3NoYWRvdyB0IGQgKGZ1biB3IGkgLT4gc2V0IHcgaSBOb25lKSAoKVxuXG5cbiAgbGV0IG1lbSB0IGQgPSBmaW5kX3NoYWRvdyB0IGQgKGZ1biBfdyBfaSAtPiB0cnVlKSBmYWxzZVxuXG5cbiAgbGV0IGZpbmRfYWxsIHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgYWNjdSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gYWNjdVxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiBsb29wIChpICsgMSkgKHYgOjogYWNjdSlcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpIGFjY3VcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgaW5cbiAgICBsb29wIDAgW11cblxuXG4gIGxldCBzdGF0cyB0ID1cbiAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgbGVucyA9IEFycmF5Lm1hcCBsZW5ndGggdC50YWJsZSBpblxuICAgIEFycmF5LnNvcnQgY29tcGFyZSBsZW5zO1xuICAgIGxldCB0b3RsZW4gPSBBcnJheS5mb2xkX2xlZnQgKCArICkgMCBsZW5zIGluXG4gICAgKGxlbiwgY291bnQgdCwgdG90bGVuLCBsZW5zLigwKSwgbGVucy4obGVuLzIpLCBsZW5zLihsZW4tMSkpXG5cblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEEgcHJldHR5LXByaW50aW5nIGZhY2lsaXR5IGFuZCBkZWZpbml0aW9uIG9mIGZvcm1hdHRlcnMgZm9yICdwYXJhbGxlbCdcbiAgIChpLmUuIHVucmVsYXRlZCBvciBpbmRlcGVuZGVudCkgcHJldHR5LXByaW50aW5nIG9uIG11bHRpcGxlIG91dCBjaGFubmVscy4gKilcblxuKCpcbiAgIFRoZSBwcmV0dHktcHJpbnRpbmcgZW5naW5lIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiopXG5cbmxldCBpZCB4ID0geFxuXG4oKiBBIGRldm90ZWQgdHlwZSBmb3Igc2l6ZXMgdG8gYXZvaWQgY29uZnVzaW9uXG4gICBiZXR3ZWVuIHNpemVzIGFuZCBtZXJlIGludGVnZXJzLiAqKVxubW9kdWxlIFNpemUgOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHRvX2ludCA6IHQgLT4gaW50XG4gIHZhbCBvZl9pbnQgOiBpbnQgLT4gdFxuICB2YWwgemVybyA6IHRcbiAgdmFsIHVua25vd24gOiB0XG4gIHZhbCBpc19rbm93biA6IHQgLT4gYm9vbFxuZW5kICA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgdG9faW50ID0gaWRcbiAgbGV0IG9mX2ludCA9IGlkXG4gIGxldCB6ZXJvID0gMFxuICBsZXQgdW5rbm93biA9IC0xXG4gIGxldCBpc19rbm93biBuID0gbiA+PSAwXG5lbmRcblxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRpbmcgYm94ZXMgZGVmaW5pdGlvbjpcbiAgIGEgcHJldHR5LXByaW50aW5nIGJveCBpcyBlaXRoZXJcbiAgIC0gaGJveDogaG9yaXpvbnRhbCBib3ggKG5vIGxpbmUgc3BsaXR0aW5nKVxuICAgLSB2Ym94OiB2ZXJ0aWNhbCBib3ggKGV2ZXJ5IGJyZWFrIGhpbnQgc3BsaXRzIHRoZSBsaW5lKVxuICAgLSBodmJveDogaG9yaXpvbnRhbC92ZXJ0aWNhbCBib3hcbiAgICAgKHRoZSBib3ggYmVoYXZlcyBhcyBhbiBob3Jpem9udGFsIGJveCBpZiBpdCBmaXRzIG9uXG4gICAgICB0aGUgY3VycmVudCBsaW5lLCBvdGhlcndpc2UgdGhlIGJveCBiZWhhdmVzIGFzIGEgdmVydGljYWwgYm94KVxuICAgLSBob3Zib3g6IGhvcml6b250YWwgb3IgdmVydGljYWwgY29tcGFjdGluZyBib3hcbiAgICAgKHRoZSBib3ggaXMgY29tcGFjdGluZyBtYXRlcmlhbCwgcHJpbnRpbmcgYXMgbXVjaCBtYXRlcmlhbCBhcyBwb3NzaWJsZVxuICAgICAgb24gZXZlcnkgbGluZXMpXG4gICAtIGJveDogaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjb21wYWN0aW5nIGJveCB3aXRoIGVuaGFuY2VkIGJveCBzdHJ1Y3R1cmVcbiAgICAgKHRoZSBib3ggYmVoYXZlcyBhcyBhbiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGJveCBidXQgYnJlYWsgaGludHMgc3BsaXRcbiAgICAgIHRoZSBsaW5lIGlmIHNwbGl0dGluZyB3b3VsZCBtb3ZlIHRvIHRoZSBsZWZ0KVxuKilcbnR5cGUgYm94X3R5cGUgPSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCB8IFBwX3Zib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCB8IFBwX2ZpdHNcblxuXG4oKiBUaGUgcHJldHR5LXByaW50aW5nIHRva2VucyBkZWZpbml0aW9uOlxuICAgYXJlIGVpdGhlciB0ZXh0IHRvIHByaW50IG9yIHByZXR0eSBwcmludGluZ1xuICAgZWxlbWVudHMgdGhhdCBkcml2ZSBpbmRlbnRhdGlvbiBhbmQgbGluZSBzcGxpdHRpbmcuICopXG50eXBlIHBwX3Rva2VuID1cbiAgfCBQcF90ZXh0IG9mIHN0cmluZyAgICAgICAgICAoKiBub3JtYWwgdGV4dCAqKVxuICB8IFBwX2JyZWFrIG9mIHsgICAgICAgICAgICAgICgqIGNvbXBsZXRlIGJyZWFrICopXG4gICAgICBmaXRzOiBzdHJpbmcgKiBpbnQgKiBzdHJpbmc7ICAgKCogbGluZSBpcyBub3Qgc3BsaXQgKilcbiAgICAgIGJyZWFrczogc3RyaW5nICogaW50ICogc3RyaW5nOyAoKiBsaW5lIGlzIHNwbGl0ICopXG4gICAgfVxuICB8IFBwX3RicmVhayBvZiBpbnQgKiBpbnQgICAgICgqIGdvIHRvIG5leHQgdGFidWxhdGlvbiAqKVxuICB8IFBwX3N0YWIgICAgICAgICAgICAgICAgICAgICgqIHNldCBhIHRhYnVsYXRpb24gKilcbiAgfCBQcF9iZWdpbiBvZiBpbnQgKiBib3hfdHlwZSAoKiBiZWdpbm5pbmcgb2YgYSBib3ggKilcbiAgfCBQcF9lbmQgICAgICAgICAgICAgICAgICAgICAoKiBlbmQgb2YgYSBib3ggKilcbiAgfCBQcF90YmVnaW4gb2YgdGJveCAgICAgICAgICAoKiBiZWdpbm5pbmcgb2YgYSB0YWJ1bGF0aW9uIGJveCAqKVxuICB8IFBwX3RlbmQgICAgICAgICAgICAgICAgICAgICgqIGVuZCBvZiBhIHRhYnVsYXRpb24gYm94ICopXG4gIHwgUHBfbmV3bGluZSAgICAgICAgICAgICAgICAgKCogdG8gZm9yY2UgYSBuZXdsaW5lIGluc2lkZSBhIGJveCAqKVxuICB8IFBwX2lmX25ld2xpbmUgICAgICAgICAgICAgICgqIHRvIGRvIHNvbWV0aGluZyBvbmx5IGlmIHRoaXMgdmVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgaGFzIGJlZW4gYnJva2VuICopXG4gIHwgUHBfb3Blbl90YWcgb2Ygc3RhZyAgICAgICAgICgqIG9wZW5pbmcgYSB0YWcgbmFtZSAqKVxuICB8IFBwX2Nsb3NlX3RhZyAgICAgICAgICAgICAgICgqIGNsb3NpbmcgdGhlIG1vc3QgcmVjZW50bHkgb3BlbiB0YWcgKilcblxuYW5kIHN0YWcgPSAuLlxuXG5hbmQgdGJveCA9IFBwX3Rib3ggb2YgaW50IGxpc3QgcmVmICAoKiBUYWJ1bGF0aW9uIGJveCAqKVxuXG50eXBlIHRhZyA9IHN0cmluZ1xudHlwZSBzdGFnICs9IFN0cmluZ190YWcgb2YgdGFnXG5cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlOlxuICAgcHJldHR5LXByaW50aW5nIG1hdGVyaWFsIGlzIG5vdCB3cml0dGVuIGluIHRoZSBvdXRwdXQgYXMgc29vbiBhcyBlbWl0dGVkO1xuICAgaW5zdGVhZCwgdGhlIG1hdGVyaWFsIGlzIHNpbXBseSByZWNvcmRlZCBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUsXG4gICB1bnRpbCB0aGUgZW5jbG9zaW5nIGJveCBoYXMgYSBrbm93biBjb21wdXRlZCBzaXplIGFuZCBwcm9wZXIgc3BsaXR0aW5nXG4gICBkZWNpc2lvbnMgY2FuIGJlIG1hZGUuXG5cbiAgIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBjb250YWlucyBmb3JtYXR0aW5nIGVsZW1lbnRzIHRvIGJlIHByaW50ZWQuXG4gICBFYWNoIGZvcm1hdHRpbmcgZWxlbWVudCBpcyBhIHR1cGxlIChzaXplLCB0b2tlbiwgbGVuZ3RoKSwgd2hlcmVcbiAgIC0gbGVuZ3RoIGlzIHRoZSBkZWNsYXJlZCBsZW5ndGggb2YgdGhlIHRva2VuLFxuICAgLSBzaXplIGlzIGVmZmVjdGl2ZSBzaXplIG9mIHRoZSB0b2tlbiB3aGVuIGl0IGlzIHByaW50ZWRcbiAgICAgKHNpemUgaXMgc2V0IHdoZW4gdGhlIHNpemUgb2YgdGhlIGJveCBpcyBrbm93biwgc28gdGhhdCBzaXplIG9mIGJyZWFrXG4gICAgICBoaW50cyBhcmUgZGVmaW5pdGl2ZSkuICopXG50eXBlIHBwX3F1ZXVlX2VsZW0gPSB7XG4gIG11dGFibGUgc2l6ZSA6IFNpemUudDtcbiAgdG9rZW4gOiBwcF90b2tlbjtcbiAgbGVuZ3RoIDogaW50O1xufVxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9xdWV1ZSA9IHBwX3F1ZXVlX2VsZW0gUXVldWUudFxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suICopXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjazogc2Nhbm5pbmcgZWxlbWVudCBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9zY2FuX2VsZW0gPSB7XG4gIGxlZnRfdG90YWwgOiBpbnQ7ICgqIFZhbHVlIG9mIHBwX2xlZnRfdG90YWwgd2hlbiB0aGUgZWxlbWVudCB3YXMgZW5xdWV1ZWQuICopXG4gIHF1ZXVlX2VsZW0gOiBwcF9xdWV1ZV9lbGVtXG59XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrOlxuICAgdGhlIGZvcm1hdHRpbmcgc3RhY2sgY29udGFpbnMgdGhlIGRlc2NyaXB0aW9uIG9mIGFsbCB0aGUgY3VycmVudGx5IGFjdGl2ZVxuICAgYm94ZXM7IHRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrIGlzIHVzZWQgdG8gc3BsaXQgdGhlIGxpbmVzXG4gICB3aGlsZSBwcmludGluZyB0b2tlbnMuICopXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrOiBmb3JtYXR0aW5nIHN0YWNrIGVsZW1lbnQgZGVmaW5pdGlvbi5cbiAgIEVhY2ggc3RhY2sgZWxlbWVudCBkZXNjcmliZXMgYSBwcmV0dHktcHJpbnRpbmcgYm94LiAqKVxudHlwZSBwcF9mb3JtYXRfZWxlbSA9IHsgYm94X3R5cGUgOiBib3hfdHlwZTsgd2lkdGggOiBpbnQgfVxuXG4oKiBUaGUgZm9ybWF0dGVyIGRlZmluaXRpb24uXG4gICBFYWNoIGZvcm1hdHRlciB2YWx1ZSBpcyBhIHByZXR0eS1wcmludGVyIGluc3RhbmNlIHdpdGggYWxsIGl0c1xuICAgbWFjaGluZXJ5LiAqKVxudHlwZSBmb3JtYXR0ZXIgPSB7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay4gKilcbiAgcHBfc2Nhbl9zdGFjayA6IHBwX3NjYW5fZWxlbSBTdGFjay50O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjay4gKilcbiAgcHBfZm9ybWF0X3N0YWNrIDogcHBfZm9ybWF0X2VsZW0gU3RhY2sudDtcbiAgcHBfdGJveF9zdGFjayA6IHRib3ggU3RhY2sudDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHNlbWFudGljcyB0YWcgc3RhY2suICopXG4gIHBwX3RhZ19zdGFjayA6IHN0YWcgU3RhY2sudDtcbiAgcHBfbWFya19zdGFjayA6IHN0YWcgU3RhY2sudDtcbiAgKCogVmFsdWUgb2YgcmlnaHQgbWFyZ2luLiAqKVxuICBtdXRhYmxlIHBwX21hcmdpbiA6IGludDtcbiAgKCogTWluaW1hbCBzcGFjZSBsZWZ0IGJlZm9yZSBtYXJnaW4sIHdoZW4gb3BlbmluZyBhIGJveC4gKilcbiAgbXV0YWJsZSBwcF9taW5fc3BhY2VfbGVmdCA6IGludDtcbiAgKCogTWF4aW11bSB2YWx1ZSBvZiBpbmRlbnRhdGlvbjpcbiAgICAgbm8gYm94IGNhbiBiZSBvcGVuZWQgZnVydGhlci4gKilcbiAgbXV0YWJsZSBwcF9tYXhfaW5kZW50IDogaW50O1xuICAoKiBTcGFjZSByZW1haW5pbmcgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbiAgbXV0YWJsZSBwcF9zcGFjZV9sZWZ0IDogaW50O1xuICAoKiBDdXJyZW50IHZhbHVlIG9mIGluZGVudGF0aW9uLiAqKVxuICBtdXRhYmxlIHBwX2N1cnJlbnRfaW5kZW50IDogaW50O1xuICAoKiBUcnVlIHdoZW4gdGhlIGxpbmUgaGFzIGJlZW4gYnJva2VuIGJ5IHRoZSBwcmV0dHktcHJpbnRlci4gKilcbiAgbXV0YWJsZSBwcF9pc19uZXdfbGluZSA6IGJvb2w7XG4gICgqIFRvdGFsIHdpZHRoIG9mIHRva2VucyBhbHJlYWR5IHByaW50ZWQuICopXG4gIG11dGFibGUgcHBfbGVmdF90b3RhbCA6IGludDtcbiAgKCogVG90YWwgd2lkdGggb2YgdG9rZW5zIGV2ZXIgcHV0IGluIHF1ZXVlLiAqKVxuICBtdXRhYmxlIHBwX3JpZ2h0X3RvdGFsIDogaW50O1xuICAoKiBDdXJyZW50IG51bWJlciBvZiBvcGVuIGJveGVzLiAqKVxuICBtdXRhYmxlIHBwX2N1cnJfZGVwdGggOiBpbnQ7XG4gICgqIE1heGltdW0gbnVtYmVyIG9mIGJveGVzIHdoaWNoIGNhbiBiZSBzaW11bHRhbmVvdXNseSBvcGVuLiAqKVxuICBtdXRhYmxlIHBwX21heF9ib3hlcyA6IGludDtcbiAgKCogRWxsaXBzaXMgc3RyaW5nLiAqKVxuICBtdXRhYmxlIHBwX2VsbGlwc2lzIDogc3RyaW5nO1xuICAoKiBPdXRwdXQgZnVuY3Rpb24uICopXG4gIG11dGFibGUgcHBfb3V0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXQ7XG4gICgqIEZsdXNoaW5nIGZ1bmN0aW9uLiAqKVxuICBtdXRhYmxlIHBwX291dF9mbHVzaCA6IHVuaXQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIG5ldyBsaW5lcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfbmV3bGluZSA6IHVuaXQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIGJyZWFrIGhpbnRzIHNwYWNlcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBpbmRlbnRhdGlvbiBvZiBuZXcgbGluZXMuICopXG4gIG11dGFibGUgcHBfb3V0X2luZGVudCA6IGludCAtPiB1bml0O1xuICAoKiBBcmUgdGFncyBwcmludGVkID8gKilcbiAgbXV0YWJsZSBwcF9wcmludF90YWdzIDogYm9vbDtcbiAgKCogQXJlIHRhZ3MgbWFya2VkID8gKilcbiAgbXV0YWJsZSBwcF9tYXJrX3RhZ3MgOiBib29sO1xuICAoKiBGaW5kIG9wZW5pbmcgYW5kIGNsb3NpbmcgbWFya2VycyBvZiB0YWdzLiAqKVxuICBtdXRhYmxlIHBwX21hcmtfb3Blbl90YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgbXV0YWJsZSBwcF9tYXJrX2Nsb3NlX3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtdXRhYmxlIHBwX3ByaW50X29wZW5fdGFnIDogc3RhZyAtPiB1bml0O1xuICBtdXRhYmxlIHBwX3ByaW50X2Nsb3NlX3RhZyA6IHN0YWcgLT4gdW5pdDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxuICBwcF9xdWV1ZSA6IHBwX3F1ZXVlO1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgc3BlY2lmaWMgdGFnIGhhbmRsaW5nIGZ1bmN0aW9ucy4gKilcbnR5cGUgZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zID0ge1xuICBtYXJrX29wZW5fc3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtYXJrX2Nsb3NlX3N0YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgcHJpbnRfb3Blbl9zdGFnIDogc3RhZyAtPiB1bml0O1xuICBwcmludF9jbG9zZV9zdGFnIDogc3RhZyAtPiB1bml0O1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgZnVuY3Rpb25zIHRvIG91dHB1dCBtYXRlcmlhbC4gKilcbnR5cGUgZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPSB7XG4gIG91dF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0O1xuICBvdXRfZmx1c2ggOiB1bml0IC0+IHVuaXQ7XG4gIG91dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICBvdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gIG91dF9pbmRlbnQgOiBpbnQgLT4gdW5pdDtcbn1cblxuXG4oKlxuXG4gIEF1eGlsaWFyaWVzIGFuZCBiYXNpYyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIEVudGVyIGEgdG9rZW4gaW4gdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxubGV0IHBwX2VucXVldWUgc3RhdGUgdG9rZW4gPVxuICBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSBzdGF0ZS5wcF9yaWdodF90b3RhbCArIHRva2VuLmxlbmd0aDtcbiAgUXVldWUuYWRkIHRva2VuIHN0YXRlLnBwX3F1ZXVlXG5cblxubGV0IHBwX2NsZWFyX3F1ZXVlIHN0YXRlID1cbiAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSAxOyBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSAxO1xuICBRdWV1ZS5jbGVhciBzdGF0ZS5wcF9xdWV1ZVxuXG5cbigqIFBwX2luZmluaXR5OiBsYXJnZSB2YWx1ZSBmb3IgZGVmYXVsdCB0b2tlbnMgc2l6ZS5cblxuICAgUHBfaW5maW5pdHkgaXMgZG9jdW1lbnRlZCBhcyBiZWluZyBncmVhdGVyIHRoYW4gMWUxMDsgdG8gYXZvaWRcbiAgIGNvbmZ1c2lvbiBhYm91dCB0aGUgd29yZCAnZ3JlYXRlcicsIHdlIGNob29zZSBwcF9pbmZpbml0eSBncmVhdGVyXG4gICB0aGFuIDFlMTAgKyAxOyBmb3IgY29ycmVjdCBoYW5kbGluZyBvZiB0ZXN0cyBpbiB0aGUgYWxnb3JpdGhtLFxuICAgcHBfaW5maW5pdHkgbXVzdCBiZSBldmVuIG9uZSBtb3JlIHRoYW4gMWUxMCArIDE7IGxldCdzIHN0YW5kIG9uIHRoZVxuICAgc2FmZSBzaWRlIGJ5IGNob29zaW5nIDEuZTEwKzEwLlxuXG4gICBQcF9pbmZpbml0eSBjb3VsZCBwcm9iYWJseSBiZSAxMDczNzQxODIzIHRoYXQgaXMgMl4zMCAtIDEsIHRoYXQgaXNcbiAgIHRoZSBtaW5pbWFsIHVwcGVyIGJvdW5kIGZvciBpbnRlZ2Vyczsgbm93IHRoYXQgbWF4X2ludCBpcyBkZWZpbmVkLFxuICAgdGhpcyBsaW1pdCBjb3VsZCBhbHNvIGJlIGRlZmluZWQgYXMgbWF4X2ludCAtIDEuXG5cbiAgIEhvd2V2ZXIsIGJlZm9yZSBzZXR0aW5nIHBwX2luZmluaXR5IHRvIHNvbWV0aGluZyBhcm91bmQgbWF4X2ludCwgd2VcbiAgIG11c3QgY2FyZWZ1bGx5IGRvdWJsZS1jaGVjayBhbGwgdGhlIGludGVnZXIgYXJpdGhtZXRpYyBvcGVyYXRpb25zXG4gICB0aGF0IGludm9sdmUgcHBfaW5maW5pdHksIHNpbmNlIGFueSBvdmVyZmxvdyB3b3VsZCB3cmVjayBoYXZvYyB0aGVcbiAgIHByZXR0eS1wcmludGluZyBhbGdvcml0aG0ncyBpbnZhcmlhbnRzLiBHaXZlbiB0aGF0IHRoaXMgYXJpdGhtZXRpY1xuICAgY29ycmVjdG5lc3MgY2hlY2sgaXMgZGlmZmljdWx0IGFuZCBlcnJvciBwcm9uZSBhbmQgZ2l2ZW4gdGhhdCAxZTEwXG4gICArIDEgaXMgaW4gcHJhY3RpY2UgbGFyZ2UgZW5vdWdoLCB0aGVyZSBpcyBubyBuZWVkIHRvIGF0dGVtcHQgdG8gc2V0XG4gICBwcF9pbmZpbml0eSB0byB0aGUgdGhlb3JldGljYWxseSBtYXhpbXVtIGxpbWl0LiBJdCBpcyBub3Qgd29ydGggdGhlXG4gICBidXJkZW4gISAqKVxubGV0IHBwX2luZmluaXR5ID0gMTAwMDAwMDAxMFxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIGZvciB0aGUgZm9ybWF0dGVyLiAqKVxubGV0IHBwX291dHB1dF9zdHJpbmcgc3RhdGUgcyA9IHN0YXRlLnBwX291dF9zdHJpbmcgcyAwIChTdHJpbmcubGVuZ3RoIHMpXG5hbmQgcHBfb3V0cHV0X25ld2xpbmUgc3RhdGUgPSBzdGF0ZS5wcF9vdXRfbmV3bGluZSAoKVxuYW5kIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgbiA9IHN0YXRlLnBwX291dF9zcGFjZXMgblxuYW5kIHBwX291dHB1dF9pbmRlbnQgc3RhdGUgbiA9IHN0YXRlLnBwX291dF9pbmRlbnQgblxuXG4oKiBGb3JtYXQgYSB0ZXh0dWFsIHRva2VuICopXG5sZXQgZm9ybWF0X3BwX3RleHQgc3RhdGUgc2l6ZSB0ZXh0ID1cbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gc2l6ZTtcbiAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSB0ZXh0O1xuICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSBmYWxzZVxuXG4oKiBGb3JtYXQgYSBzdHJpbmcgYnkgaXRzIGxlbmd0aCwgaWYgbm90IGVtcHR5ICopXG5sZXQgZm9ybWF0X3N0cmluZyBzdGF0ZSBzID1cbiAgaWYgcyA8PiBcIlwiIHRoZW4gZm9ybWF0X3BwX3RleHQgc3RhdGUgKFN0cmluZy5sZW5ndGggcykgc1xuXG4oKiBUbyBmb3JtYXQgYSBicmVhaywgaW5kZW50aW5nIGEgbmV3IGxpbmUuICopXG5sZXQgYnJlYWtfbmV3X2xpbmUgc3RhdGUgKGJlZm9yZSwgb2Zmc2V0LCBhZnRlcikgd2lkdGggPVxuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGJlZm9yZTtcbiAgcHBfb3V0cHV0X25ld2xpbmUgc3RhdGU7XG4gIHN0YXRlLnBwX2lzX25ld19saW5lIDwtIHRydWU7XG4gIGxldCBpbmRlbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSB3aWR0aCArIG9mZnNldCBpblxuICAoKiBEb24ndCBpbmRlbnQgbW9yZSB0aGFuIHBwX21heF9pbmRlbnQuICopXG4gIGxldCByZWFsX2luZGVudCA9IEludC5taW4gc3RhdGUucHBfbWF4X2luZGVudCBpbmRlbnQgaW5cbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gcmVhbF9pbmRlbnQ7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfY3VycmVudF9pbmRlbnQ7XG4gIHBwX291dHB1dF9pbmRlbnQgc3RhdGUgc3RhdGUucHBfY3VycmVudF9pbmRlbnQ7XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYWZ0ZXJcblxuXG4oKiBUbyBmb3JjZSBhIGxpbmUgYnJlYWsgaW5zaWRlIGEgYm94OiBubyBvZmZzZXQgaXMgYWRkZWQuICopXG5sZXQgYnJlYWtfbGluZSBzdGF0ZSB3aWR0aCA9IGJyZWFrX25ld19saW5lIHN0YXRlIChcIlwiLCAwLCBcIlwiKSB3aWR0aFxuXG4oKiBUbyBmb3JtYXQgYSBicmVhayB0aGF0IGZpdHMgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbmxldCBicmVha19zYW1lX2xpbmUgc3RhdGUgKGJlZm9yZSwgd2lkdGgsIGFmdGVyKSA9XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYmVmb3JlO1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgLSB3aWR0aDtcbiAgcHBfb3V0cHV0X3NwYWNlcyBzdGF0ZSB3aWR0aDtcbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBhZnRlclxuXG5cbigqIFRvIGluZGVudCBubyBtb3JlIHRoYW4gcHBfbWF4X2luZGVudCwgaWYgb25lIHRyaWVzIHRvIG9wZW4gYSBib3hcbiAgIGJleW9uZCBwcF9tYXhfaW5kZW50LCB0aGVuIHRoZSBib3ggaXMgcmVqZWN0ZWQgb24gdGhlIGxlZnRcbiAgIGJ5IHNpbXVsYXRpbmcgYSBicmVhay4gKilcbmxldCBwcF9mb3JjZV9icmVha19saW5lIHN0YXRlID1cbiAgbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICB8IE5vbmUgLT4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGVcbiAgfCBTb21lIHsgYm94X3R5cGU7IHdpZHRoIH0gLT5cbiAgICBpZiB3aWR0aCA+IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlblxuICAgICAgbWF0Y2ggYm94X3R5cGUgd2l0aFxuICAgICAgfCBQcF9maXRzIHwgUHBfaGJveCAtPiAoKVxuICAgICAgfCBQcF92Ym94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggLT4gYnJlYWtfbGluZSBzdGF0ZSB3aWR0aFxuXG5cbigqIFRvIHNraXAgYSB0b2tlbiwgaWYgdGhlIHByZXZpb3VzIGxpbmUgaGFzIGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3NraXBfdG9rZW4gc3RhdGUgPVxuICBtYXRjaCBRdWV1ZS50YWtlX29wdCBzdGF0ZS5wcF9xdWV1ZSB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBwcmludF9pZl9uZXdsaW5lIG11c3QgaGF2ZSBiZWVuIHRoZSBsYXN0IHByaW50aW5nIGNvbW1hbmQgKilcbiAgfCBTb21lIHsgc2l6ZTsgbGVuZ3RoOyBfIH0gLT5cbiAgICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIHN0YXRlLnBwX2xlZnRfdG90YWwgLSBsZW5ndGg7XG4gICAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0ICsgU2l6ZS50b19pbnQgc2l6ZVxuXG5cbigqXG5cbiAgVGhlIG1haW4gcHJldHR5IHByaW50aW5nIGZ1bmN0aW9ucy5cblxuKilcblxuKCogRm9ybWF0dGluZyBhIHRva2VuIHdpdGggYSBnaXZlbiBzaXplLiAqKVxubGV0IGZvcm1hdF9wcF90b2tlbiBzdGF0ZSBzaXplID0gZnVuY3Rpb25cblxuICB8IFBwX3RleHQgcyAtPlxuICAgIGZvcm1hdF9wcF90ZXh0IHN0YXRlIHNpemUgc1xuXG4gIHwgUHBfYmVnaW4gKG9mZiwgdHkpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBpZiBpbnNlcnRpb25fcG9pbnQgPiBzdGF0ZS5wcF9tYXhfaW5kZW50IHRoZW5cbiAgICAgICgqIGNhbiBub3Qgb3BlbiBhIGJveCByaWdodCB0aGVyZS4gKilcbiAgICAgIGJlZ2luIHBwX2ZvcmNlX2JyZWFrX2xpbmUgc3RhdGUgZW5kO1xuICAgIGxldCB3aWR0aCA9IHN0YXRlLnBwX3NwYWNlX2xlZnQgLSBvZmYgaW5cbiAgICBsZXQgYm94X3R5cGUgPVxuICAgICAgbWF0Y2ggdHkgd2l0aFxuICAgICAgfCBQcF92Ym94IC0+IFBwX3Zib3hcbiAgICAgIHwgUHBfaGJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IHwgUHBfZml0cyAtPlxuICAgICAgICBpZiBzaXplID4gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuIHR5IGVsc2UgUHBfZml0cyBpblxuICAgIFN0YWNrLnB1c2ggeyBib3hfdHlwZTsgd2lkdGggfSBzdGF0ZS5wcF9mb3JtYXRfc3RhY2tcblxuICB8IFBwX2VuZCAtPlxuICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHw+IGlnbm9yZVxuXG4gIHwgUHBfdGJlZ2luIChQcF90Ym94IF8gYXMgdGJveCkgLT5cbiAgICBTdGFjay5wdXNoIHRib3ggc3RhdGUucHBfdGJveF9zdGFja1xuXG4gIHwgUHBfdGVuZCAtPlxuICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfdGJveF9zdGFjayB8PiBpZ25vcmVcblxuICB8IFBwX3N0YWIgLT5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIHRhYnVsYXRpb24gYm94LiAqKVxuICAgIHwgU29tZSAoUHBfdGJveCB0YWJzKSAtPlxuICAgICAgbGV0IHJlYyBhZGRfdGFiIG4gPSBmdW5jdGlvblxuICAgICAgICB8IFtdIC0+IFtuXVxuICAgICAgICB8IHggOjogbCBhcyBscyAtPiBpZiBuIDwgeCB0aGVuIG4gOjogbHMgZWxzZSB4IDo6IGFkZF90YWIgbiBsIGluXG4gICAgICB0YWJzIDo9IGFkZF90YWIgKHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQpICF0YWJzXG4gICAgZW5kXG5cbiAgfCBQcF90YnJlYWsgKG4sIG9mZikgLT5cbiAgICBsZXQgaW5zZXJ0aW9uX3BvaW50ID0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCBpblxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gdGFidWxhdGlvbiBib3guICopXG4gICAgfCBTb21lIChQcF90Ym94IHRhYnMpIC0+XG4gICAgICBsZXQgdGFiID1cbiAgICAgICAgbWF0Y2ggIXRhYnMgd2l0aFxuICAgICAgICB8IFtdIC0+IGluc2VydGlvbl9wb2ludFxuICAgICAgICB8IGZpcnN0IDo6IF8gLT5cbiAgICAgICAgICBsZXQgcmVjIGZpbmQgPSBmdW5jdGlvblxuICAgICAgICAgICAgfCBoZWFkIDo6IHRhaWwgLT5cbiAgICAgICAgICAgICAgaWYgaGVhZCA+PSBpbnNlcnRpb25fcG9pbnQgdGhlbiBoZWFkIGVsc2UgZmluZCB0YWlsXG4gICAgICAgICAgICB8IFtdIC0+IGZpcnN0IGluXG4gICAgICAgICAgZmluZCAhdGFicyBpblxuICAgICAgbGV0IG9mZnNldCA9IHRhYiAtIGluc2VydGlvbl9wb2ludCBpblxuICAgICAgaWYgb2Zmc2V0ID49IDBcbiAgICAgIHRoZW4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIChcIlwiLCBvZmZzZXQgKyBuLCBcIlwiKVxuICAgICAgZWxzZSBicmVha19uZXdfbGluZSBzdGF0ZSAoXCJcIiwgdGFiICsgb2ZmLCBcIlwiKSBzdGF0ZS5wcF9tYXJnaW5cbiAgICBlbmRcblxuICB8IFBwX25ld2xpbmUgLT5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+IHBwX291dHB1dF9uZXdsaW5lIHN0YXRlICgqIE5vIG9wZW4gYm94LiAqKVxuICAgIHwgU29tZSB7IHdpZHRoOyBffSAtPiBicmVha19saW5lIHN0YXRlIHdpZHRoXG4gICAgZW5kXG5cbiAgfCBQcF9pZl9uZXdsaW5lIC0+XG4gICAgaWYgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgIT0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgIHRoZW4gcHBfc2tpcF90b2tlbiBzdGF0ZVxuXG4gIHwgUHBfYnJlYWsgeyBmaXRzOyBicmVha3MgfSAtPlxuICAgIGxldCBiZWZvcmUsIG9mZiwgXyA9IGJyZWFrcyBpblxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiBib3guICopXG4gICAgfCBTb21lIHsgYm94X3R5cGU7IHdpZHRoIH0gLT5cbiAgICAgIGJlZ2luIG1hdGNoIGJveF90eXBlIHdpdGhcbiAgICAgIHwgUHBfaG92Ym94IC0+XG4gICAgICAgIGlmIHNpemUgKyBTdHJpbmcubGVuZ3RoIGJlZm9yZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgICAgZWxzZSBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgfCBQcF9ib3ggLT5cbiAgICAgICAgKCogSGF2ZSB0aGUgbGluZSBqdXN0IGJlZW4gYnJva2VuIGhlcmUgPyAqKVxuICAgICAgICBpZiBzdGF0ZS5wcF9pc19uZXdfbGluZSB0aGVuIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzIGVsc2VcbiAgICAgICAgaWYgc2l6ZSArIFN0cmluZy5sZW5ndGggYmVmb3JlID4gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoIGVsc2VcbiAgICAgICAgKCogYnJlYWsgdGhlIGxpbmUgaGVyZSBsZWFkcyB0byBuZXcgaW5kZW50YXRpb24gPyAqKVxuICAgICAgICBpZiBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCA+IHN0YXRlLnBwX21hcmdpbiAtIHdpZHRoICsgb2ZmXG4gICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICAgIGVsc2UgYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIHwgUHBfaHZib3ggLT4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICB8IFBwX2ZpdHMgLT4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIHwgUHBfdmJveCAtPiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgIHwgUHBfaGJveCAtPiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgIHwgUHBfb3Blbl90YWcgdGFnX25hbWUgLT5cbiAgICAgbGV0IG1hcmtlciA9IHN0YXRlLnBwX21hcmtfb3Blbl90YWcgdGFnX25hbWUgaW5cbiAgICAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBtYXJrZXI7XG4gICAgIFN0YWNrLnB1c2ggdGFnX25hbWUgc3RhdGUucHBfbWFya19zdGFja1xuXG4gICB8IFBwX2Nsb3NlX3RhZyAtPlxuICAgICBiZWdpbiBtYXRjaCBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX21hcmtfc3RhY2sgd2l0aFxuICAgICB8IE5vbmUgLT4gKCkgKCogTm8gbW9yZSB0YWcgdG8gY2xvc2UuICopXG4gICAgIHwgU29tZSB0YWdfbmFtZSAtPlxuICAgICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyB0YWdfbmFtZSBpblxuICAgICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyXG4gICAgIGVuZFxuXG5cbigqIFByaW50IGlmIHRva2VuIHNpemUgaXMga25vd24gZWxzZSBwcmludGluZyBpcyBkZWxheWVkLlxuICAgUHJpbnRpbmcgaXMgZGVsYXllZCB3aGVuIHRoZSB0ZXh0IHdhaXRpbmcgaW4gdGhlIHF1ZXVlIHJlcXVpcmVzXG4gICBtb3JlIHJvb20gdG8gZm9ybWF0IHRoYW4gZXhpc3RzIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG5sZXQgcmVjIGFkdmFuY2VfbGVmdCBzdGF0ZSA9XG4gIG1hdGNoIFF1ZXVlLnBlZWtfb3B0IHN0YXRlLnBwX3F1ZXVlIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIE5vIHRva2VucyB0byBwcmludCAqKVxuICB8IFNvbWUgeyBzaXplOyB0b2tlbjsgbGVuZ3RoIH0gLT5cbiAgICBsZXQgcGVuZGluZ19jb3VudCA9IHN0YXRlLnBwX3JpZ2h0X3RvdGFsIC0gc3RhdGUucHBfbGVmdF90b3RhbCBpblxuICAgIGlmIFNpemUuaXNfa25vd24gc2l6ZSB8fCBwZW5kaW5nX2NvdW50ID49IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlbiBiZWdpblxuICAgICAgUXVldWUudGFrZSBzdGF0ZS5wcF9xdWV1ZSB8PiBpZ25vcmU7ICgqIE5vdCBlbXB0eTogd2UgcGVlayBpbnRvIGl0ICopXG4gICAgICBsZXQgc2l6ZSA9IGlmIFNpemUuaXNfa25vd24gc2l6ZSB0aGVuIFNpemUudG9faW50IHNpemUgZWxzZSBwcF9pbmZpbml0eSBpblxuICAgICAgZm9ybWF0X3BwX3Rva2VuIHN0YXRlIHNpemUgdG9rZW47XG4gICAgICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIGxlbmd0aCArIHN0YXRlLnBwX2xlZnRfdG90YWw7XG4gICAgICAoYWR2YW5jZV9sZWZ0IFtAdGFpbGNhbGxdKSBzdGF0ZVxuICAgIGVuZFxuXG5cbigqIFRvIGVucXVldWUgYSB0b2tlbiA6IHRyeSB0byBhZHZhbmNlLiAqKVxubGV0IGVucXVldWVfYWR2YW5jZSBzdGF0ZSB0b2sgPSBwcF9lbnF1ZXVlIHN0YXRlIHRvazsgYWR2YW5jZV9sZWZ0IHN0YXRlXG5cblxuKCogVG8gZW5xdWV1ZSBzdHJpbmdzLiAqKVxubGV0IGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIHNpemUgcyA9XG4gIGVucXVldWVfYWR2YW5jZSBzdGF0ZSB7IHNpemU7IHRva2VuID0gUHBfdGV4dCBzOyBsZW5ndGggPSBTaXplLnRvX2ludCBzaXplIH1cblxuXG5sZXQgZW5xdWV1ZV9zdHJpbmcgc3RhdGUgcyA9XG4gIGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIChTaXplLm9mX2ludCAoU3RyaW5nLmxlbmd0aCBzKSkgc1xuXG5cbigqIFJvdXRpbmVzIGZvciBzY2FuIHN0YWNrXG4gICBkZXRlcm1pbmUgc2l6ZSBvZiBib3hlcy4gKilcblxuKCogVGhlIHNjYW5fc3RhY2sgaXMgbmV2ZXIgZW1wdHkuICopXG5sZXQgaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIHN0YWNrID1cbiAgU3RhY2suY2xlYXIgc3RhY2s7XG4gIGxldCBxdWV1ZV9lbGVtID0geyBzaXplID0gU2l6ZS51bmtub3duOyB0b2tlbiA9IFBwX3RleHQgXCJcIjsgbGVuZ3RoID0gMCB9IGluXG4gIFN0YWNrLnB1c2ggeyBsZWZ0X3RvdGFsID0gLTE7IHF1ZXVlX2VsZW0gfSBzdGFja1xuXG4oKiBTZXR0aW5nIHRoZSBzaXplIG9mIGJveGVzIG9uIHNjYW4gc3RhY2s6XG4gICBpZiB0eSA9IHRydWUgdGhlbiBzaXplIG9mIGJyZWFrIGlzIHNldCBlbHNlIHNpemUgb2YgYm94IGlzIHNldDtcbiAgIGluIGVhY2ggY2FzZSBwcF9zY2FuX3N0YWNrIGlzIHBvcHBlZC5cblxuICAgTm90ZTpcbiAgIFBhdHRlcm4gbWF0Y2hpbmcgb24gc2NhbiBzdGFjayBpcyBleGhhdXN0aXZlLCBzaW5jZSBzY2FuX3N0YWNrIGlzIG5ldmVyXG4gICBlbXB0eS5cbiAgIFBhdHRlcm4gbWF0Y2hpbmcgb24gdG9rZW4gaW4gc2NhbiBzdGFjayBpcyBhbHNvIGV4aGF1c3RpdmUsXG4gICBzaW5jZSBzY2FuX3B1c2ggaXMgdXNlZCBvbiBicmVha3MgYW5kIG9wZW5pbmcgb2YgYm94ZXMuICopXG5sZXQgc2V0X3NpemUgc3RhdGUgdHkgPVxuICBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX3NjYW5fc3RhY2sgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogc2Nhbl9zdGFjayBpcyBuZXZlciBlbXB0eS4gKilcbiAgfCBTb21lIHsgbGVmdF90b3RhbDsgcXVldWVfZWxlbSB9IC0+XG4gICAgbGV0IHNpemUgPSBTaXplLnRvX2ludCBxdWV1ZV9lbGVtLnNpemUgaW5cbiAgICAoKiB0ZXN0IGlmIHNjYW4gc3RhY2sgY29udGFpbnMgYW55IGRhdGEgdGhhdCBpcyBub3Qgb2Jzb2xldGUuICopXG4gICAgaWYgbGVmdF90b3RhbCA8IHN0YXRlLnBwX2xlZnRfdG90YWwgdGhlblxuICAgICAgaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIHN0YXRlLnBwX3NjYW5fc3RhY2tcbiAgICBlbHNlXG4gICAgICBtYXRjaCBxdWV1ZV9lbGVtLnRva2VuIHdpdGhcbiAgICAgIHwgUHBfYnJlYWsgXyB8IFBwX3RicmVhayAoXywgXykgLT5cbiAgICAgICAgaWYgdHkgdGhlbiBiZWdpblxuICAgICAgICAgIHF1ZXVlX2VsZW0uc2l6ZSA8LSBTaXplLm9mX2ludCAoc3RhdGUucHBfcmlnaHRfdG90YWwgKyBzaXplKTtcbiAgICAgICAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3NjYW5fc3RhY2sgfD4gaWdub3JlXG4gICAgICAgIGVuZFxuICAgICAgfCBQcF9iZWdpbiAoXywgXykgLT5cbiAgICAgICAgaWYgbm90IHR5IHRoZW4gYmVnaW5cbiAgICAgICAgICBxdWV1ZV9lbGVtLnNpemUgPC0gU2l6ZS5vZl9pbnQgKHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgc2l6ZSk7XG4gICAgICAgICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHw+IGlnbm9yZVxuICAgICAgICBlbmRcbiAgICAgIHwgUHBfdGV4dCBfIHwgUHBfc3RhYiB8IFBwX3RiZWdpbiBfIHwgUHBfdGVuZCB8IFBwX2VuZFxuICAgICAgfCBQcF9uZXdsaW5lIHwgUHBfaWZfbmV3bGluZSB8IFBwX29wZW5fdGFnIF8gfCBQcF9jbG9zZV90YWcgLT5cbiAgICAgICAgKCkgKCogc2Nhbl9wdXNoIGlzIG9ubHkgdXNlZCBmb3IgYnJlYWtzIGFuZCBib3hlcy4gKilcblxuXG4oKiBQdXNoIGEgdG9rZW4gb24gcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suXG4gICBJZiBiIGlzIHRydWUgc2V0X3NpemUgaXMgY2FsbGVkLiAqKVxubGV0IHNjYW5fcHVzaCBzdGF0ZSBiIHRva2VuID1cbiAgcHBfZW5xdWV1ZSBzdGF0ZSB0b2tlbjtcbiAgaWYgYiB0aGVuIHNldF9zaXplIHN0YXRlIHRydWU7XG4gIGxldCBlbGVtID0geyBsZWZ0X3RvdGFsID0gc3RhdGUucHBfcmlnaHRfdG90YWw7IHF1ZXVlX2VsZW0gPSB0b2tlbiB9IGluXG4gIFN0YWNrLnB1c2ggZWxlbSBzdGF0ZS5wcF9zY2FuX3N0YWNrXG5cblxuKCogVG8gb3BlbiBhIG5ldyBib3ggOlxuICAgdGhlIHVzZXIgbWF5IHNldCB0aGUgZGVwdGggYm91bmQgcHBfbWF4X2JveGVzXG4gICBhbnkgdGV4dCBuZXN0ZWQgZGVlcGVyIGlzIHByaW50ZWQgYXMgdGhlIGVsbGlwc2lzIHN0cmluZy4gKilcbmxldCBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IGJyX3R5ID1cbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoICsgMTtcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLm9mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkgaW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZTsgdG9rZW4gPSBQcF9iZWdpbiAoaW5kZW50LCBicl90eSk7IGxlbmd0aCA9IDAgfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSBmYWxzZSBlbGVtIGVsc2VcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA9IHN0YXRlLnBwX21heF9ib3hlc1xuICB0aGVuIGVucXVldWVfc3RyaW5nIHN0YXRlIHN0YXRlLnBwX2VsbGlwc2lzXG5cblxuKCogVGhlIGJveCB3aGljaCBpcyBhbHdheXMgb3Blbi4gKilcbmxldCBwcF9vcGVuX3N5c19ib3ggc3RhdGUgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgMCBQcF9ob3Zib3hcblxuKCogQ2xvc2UgYSBib3gsIHNldHRpbmcgc2l6ZXMgb2YgaXRzIHN1YiBib3hlcy4gKilcbmxldCBwcF9jbG9zZV9ib3ggc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoID4gMSB0aGVuXG4gIGJlZ2luXG4gICAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgYmVnaW5cbiAgICAgIHBwX2VucXVldWUgc3RhdGUgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2VuZDsgbGVuZ3RoID0gMCB9O1xuICAgICAgc2V0X3NpemUgc3RhdGUgdHJ1ZTsgc2V0X3NpemUgc3RhdGUgZmFsc2VcbiAgICBlbmQ7XG4gICAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoIC0gMTtcbiAgZW5kXG5cblxuKCogT3BlbiBhIHRhZywgcHVzaGluZyBpdCBvbiB0aGUgdGFnIHN0YWNrLiAqKVxubGV0IHBwX29wZW5fc3RhZyBzdGF0ZSB0YWdfbmFtZSA9XG4gIGlmIHN0YXRlLnBwX3ByaW50X3RhZ3MgdGhlblxuICBiZWdpblxuICAgIFN0YWNrLnB1c2ggdGFnX25hbWUgc3RhdGUucHBfdGFnX3N0YWNrO1xuICAgIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIHRhZ19uYW1lXG4gIGVuZDtcbiAgaWYgc3RhdGUucHBfbWFya190YWdzIHRoZW5cbiAgICBsZXQgdG9rZW4gPSBQcF9vcGVuX3RhZyB0YWdfbmFtZSBpblxuICAgIHBwX2VucXVldWUgc3RhdGUgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbjsgbGVuZ3RoID0gMCB9XG5cblxuKCogQ2xvc2UgYSB0YWcsIHBvcHBpbmcgaXQgZnJvbSB0aGUgdGFnIHN0YWNrLiAqKVxubGV0IHBwX2Nsb3NlX3N0YWcgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9tYXJrX3RhZ3MgdGhlblxuICAgIHBwX2VucXVldWUgc3RhdGUgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2Nsb3NlX3RhZzsgbGVuZ3RoID0gMCB9O1xuICBpZiBzdGF0ZS5wcF9wcmludF90YWdzIHRoZW5cbiAgICBtYXRjaCBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3RhZ19zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG1vcmUgdGFnIHRvIGNsb3NlLiAqKVxuICAgIHwgU29tZSB0YWdfbmFtZSAtPlxuICAgICAgc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnIHRhZ19uYW1lXG5cbmxldCBwcF9zZXRfcHJpbnRfdGFncyBzdGF0ZSBiID0gc3RhdGUucHBfcHJpbnRfdGFncyA8LSBiXG5sZXQgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiID0gc3RhdGUucHBfbWFya190YWdzIDwtIGJcbmxldCBwcF9nZXRfcHJpbnRfdGFncyBzdGF0ZSAoKSA9IHN0YXRlLnBwX3ByaW50X3RhZ3NcbmxldCBwcF9nZXRfbWFya190YWdzIHN0YXRlICgpID0gc3RhdGUucHBfbWFya190YWdzXG5sZXQgcHBfc2V0X3RhZ3Mgc3RhdGUgYiA9XG4gIHBwX3NldF9wcmludF90YWdzIHN0YXRlIGI7IHBwX3NldF9tYXJrX3RhZ3Mgc3RhdGUgYlxuXG5cbigqIEhhbmRsaW5nIHRhZyBoYW5kbGluZyBmdW5jdGlvbnM6IGdldC9zZXQgZnVuY3Rpb25zLiAqKVxubGV0IHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RhdGUgKCkgPSB7XG4gIG1hcmtfb3Blbl9zdGFnID0gc3RhdGUucHBfbWFya19vcGVuX3RhZztcbiAgbWFya19jbG9zZV9zdGFnID0gc3RhdGUucHBfbWFya19jbG9zZV90YWc7XG4gIHByaW50X29wZW5fc3RhZyA9IHN0YXRlLnBwX3ByaW50X29wZW5fdGFnO1xuICBwcmludF9jbG9zZV9zdGFnID0gc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnO1xufVxuXG5cbmxldCBwcF9zZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgbWFya19vcGVuX3N0YWcgPSBtb3Q7XG4gICAgIG1hcmtfY2xvc2Vfc3RhZyA9IG1jdDtcbiAgICAgcHJpbnRfb3Blbl9zdGFnID0gcG90O1xuICAgICBwcmludF9jbG9zZV9zdGFnID0gcGN0O1xuICB9ID1cbiAgc3RhdGUucHBfbWFya19vcGVuX3RhZyA8LSBtb3Q7XG4gIHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIDwtIG1jdDtcbiAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgPC0gcG90O1xuICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgPC0gcGN0XG5cblxuKCogSW5pdGlhbGl6ZSBwcmV0dHktcHJpbnRlci4gKilcbmxldCBwcF9yaW5pdCBzdGF0ZSA9XG4gIHBwX2NsZWFyX3F1ZXVlIHN0YXRlO1xuICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhdGUucHBfc2Nhbl9zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfZm9ybWF0X3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF90Ym94X3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF90YWdfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX21hcmtfc3RhY2s7XG4gIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50IDwtIDA7XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gMDtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9tYXJnaW47XG4gIHBwX29wZW5fc3lzX2JveCBzdGF0ZVxuXG5sZXQgY2xlYXJfdGFnX3N0YWNrIHN0YXRlID1cbiAgU3RhY2suaXRlciAoZnVuIF8gLT4gcHBfY2xvc2Vfc3RhZyBzdGF0ZSAoKSkgc3RhdGUucHBfdGFnX3N0YWNrXG5cblxuKCogRmx1c2hpbmcgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG5sZXQgcHBfZmx1c2hfcXVldWUgc3RhdGUgYiA9XG4gIGNsZWFyX3RhZ19zdGFjayBzdGF0ZTtcbiAgd2hpbGUgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgZG9cbiAgICBwcF9jbG9zZV9ib3ggc3RhdGUgKClcbiAgZG9uZTtcbiAgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gcHBfaW5maW5pdHk7XG4gIGFkdmFuY2VfbGVmdCBzdGF0ZTtcbiAgaWYgYiB0aGVuIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlO1xuICBwcF9yaW5pdCBzdGF0ZVxuXG4oKlxuXG4gIFByb2NlZHVyZXMgdG8gZm9ybWF0IHZhbHVlcyBhbmQgdXNlIGJveGVzLlxuXG4qKVxuXG4oKiBUbyBmb3JtYXQgYSBzdHJpbmcuICopXG5sZXQgcHBfcHJpbnRfYXNfc2l6ZSBzdGF0ZSBzaXplIHMgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzXG4gIHRoZW4gZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgc2l6ZSBzXG5cblxubGV0IHBwX3ByaW50X2FzIHN0YXRlIGlzaXplIHMgPVxuICBwcF9wcmludF9hc19zaXplIHN0YXRlIChTaXplLm9mX2ludCBpc2l6ZSkgc1xuXG5cbmxldCBwcF9wcmludF9zdHJpbmcgc3RhdGUgcyA9XG4gIHBwX3ByaW50X2FzIHN0YXRlIChTdHJpbmcubGVuZ3RoIHMpIHNcblxubGV0IHBwX3ByaW50X2J5dGVzIHN0YXRlIHMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAoQnl0ZXMubGVuZ3RoIHMpIChCeXRlcy50b19zdHJpbmcgcylcblxuKCogVG8gZm9ybWF0IGFuIGludGVnZXIuICopXG5sZXQgcHBfcHJpbnRfaW50IHN0YXRlIGkgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKEludC50b19zdHJpbmcgaSlcblxuKCogVG8gZm9ybWF0IGEgZmxvYXQuICopXG5sZXQgcHBfcHJpbnRfZmxvYXQgc3RhdGUgZiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Zsb2F0IGYpXG5cbigqIFRvIGZvcm1hdCBhIGJvb2xlYW4uICopXG5sZXQgcHBfcHJpbnRfYm9vbCBzdGF0ZSBiID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChzdHJpbmdfb2ZfYm9vbCBiKVxuXG4oKiBUbyBmb3JtYXQgYSBjaGFyLiAqKVxubGV0IHBwX3ByaW50X2NoYXIgc3RhdGUgYyA9XG4gIHBwX3ByaW50X2FzIHN0YXRlIDEgKFN0cmluZy5tYWtlIDEgYylcblxuXG4oKiBPcGVuaW5nIGJveGVzLiAqKVxubGV0IHBwX29wZW5faGJveCBzdGF0ZSAoKSA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSAwIFBwX2hib3hcbmFuZCBwcF9vcGVuX3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF92Ym94XG5cbmFuZCBwcF9vcGVuX2h2Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfaHZib3hcbmFuZCBwcF9vcGVuX2hvdmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2hvdmJveFxuYW5kIHBwX29wZW5fYm94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfYm94XG5cblxuKCogUHJpbnRpbmcgcXVldWVkIHRleHQuXG5cbiAgIFtwcF9wcmludF9mbHVzaF0gcHJpbnRzIGFsbCBwZW5kaW5nIGl0ZW1zIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBhbmRcbiAgIHRoZW4gZmx1c2hlcyB0aGUgbG93IGxldmVsIG91dHB1dCBkZXZpY2Ugb2YgdGhlIGZvcm1hdHRlciB0byBhY3R1YWxseVxuICAgZGlzcGxheSBwcmludGluZyBtYXRlcmlhbC5cblxuICAgW3BwX3ByaW50X25ld2xpbmVdIGJlaGF2ZXMgYXMgW3BwX3ByaW50X2ZsdXNoXSBhZnRlciBwcmludGluZyBhbiBhZGRpdGlvbmFsXG4gICBuZXcgbGluZS4gKilcbmxldCBwcF9wcmludF9uZXdsaW5lIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgdHJ1ZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5hbmQgcHBfcHJpbnRfZmx1c2ggc3RhdGUgKCkgPVxuICBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSBmYWxzZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5cblxuKCogVG8gZ2V0IGEgbmV3bGluZSB3aGVuIG9uZSBkb2VzIG5vdCB3YW50IHRvIGNsb3NlIHRoZSBjdXJyZW50IGJveC4gKilcbmxldCBwcF9mb3JjZV9uZXdsaW5lIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9uZXdsaW5lOyBsZW5ndGggPSAwIH1cblxuXG4oKiBUbyBmb3JtYXQgc29tZXRoaW5nLCBvbmx5IGluIGNhc2UgdGhlIGxpbmUgaGFzIGp1c3QgYmVlbiBicm9rZW4uICopXG5sZXQgcHBfcHJpbnRfaWZfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZVxuICAgICAgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2lmX25ld2xpbmU7IGxlbmd0aCA9IDAgfVxuXG5cbigqIEdlbmVyYWxpemVkIGJyZWFrIGhpbnQgdGhhdCBhbGxvd3MgcHJpbnRpbmcgc3RyaW5ncyBiZWZvcmUvYWZ0ZXJcbiAgIHNhbWUtbGluZSBvZmZzZXQgKHdpZHRoKSBvciBuZXctbGluZSBvZmZzZXQgKilcbmxldCBwcF9wcmludF9jdXN0b21fYnJlYWsgc3RhdGUgfmZpdHMgfmJyZWFrcyA9XG4gIGxldCBiZWZvcmUsIHdpZHRoLCBhZnRlciA9IGZpdHMgaW5cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLm9mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkgaW5cbiAgICBsZXQgdG9rZW4gPSBQcF9icmVhayB7IGZpdHM7IGJyZWFrcyB9IGluXG4gICAgbGV0IGxlbmd0aCA9IFN0cmluZy5sZW5ndGggYmVmb3JlICsgd2lkdGggKyBTdHJpbmcubGVuZ3RoIGFmdGVyIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuOyBsZW5ndGggfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuKCogUHJpbnRpbmcgYnJlYWsgaGludHM6XG4gICBBIGJyZWFrIGhpbnQgaW5kaWNhdGVzIHdoZXJlIGEgYm94IG1heSBiZSBicm9rZW4uXG4gICBJZiBsaW5lIGlzIGJyb2tlbiB0aGVuIG9mZnNldCBpcyBhZGRlZCB0byB0aGUgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnRcbiAgIGJveCBlbHNlICh0aGUgdmFsdWUgb2YpIHdpZHRoIGJsYW5rcyBhcmUgcHJpbnRlZC4gKilcbmxldCBwcF9wcmludF9icmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBwcF9wcmludF9jdXN0b21fYnJlYWsgc3RhdGVcbiAgICB+Zml0czooXCJcIiwgd2lkdGgsIFwiXCIpIH5icmVha3M6KFwiXCIsIG9mZnNldCwgXCJcIilcblxuXG4oKiBQcmludCBhIHNwYWNlIDpcbiAgIGEgc3BhY2UgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIGEgc2luZ2xlIHNwYWNlIGlmIHRoZSBicmVhayBkb2VzIG5vdFxuICAgc3BsaXQgdGhlIGxpbmU7XG4gICBhIGN1dCBpcyBhIGJyZWFrIGhpbnQgdGhhdCBwcmludHMgbm90aGluZyBpZiB0aGUgYnJlYWsgZG9lcyBub3Qgc3BsaXQgdGhlXG4gICBsaW5lLiAqKVxubGV0IHBwX3ByaW50X3NwYWNlIHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMSAwXG5hbmQgcHBfcHJpbnRfY3V0IHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMCAwXG5cblxuKCogVGFidWxhdGlvbiBib3hlcy4gKilcbmxldCBwcF9vcGVuX3Rib3ggc3RhdGUgKCkgPVxuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggKyAxO1xuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUuemVybyBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX3RiZWdpbiAoUHBfdGJveCAocmVmIFtdKSk7IGxlbmd0aCA9IDAgfSBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCogQ2xvc2UgYSB0YWJ1bGF0aW9uIGJveC4gKilcbmxldCBwcF9jbG9zZV90Ym94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgIGxldCBlbGVtID0geyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX3RlbmQ7IGxlbmd0aCA9IDAgfSBpblxuICAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbTtcbiAgICAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoIC0gMVxuICBlbmRcblxuXG4oKiBQcmludCBhIHRhYnVsYXRpb24gYnJlYWsuICopXG5sZXQgcHBfcHJpbnRfdGJyZWFrIHN0YXRlIHdpZHRoIG9mZnNldCA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuID0gUHBfdGJyZWFrICh3aWR0aCwgb2Zmc2V0KTsgbGVuZ3RoID0gd2lkdGggfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuXG5sZXQgcHBfcHJpbnRfdGFiIHN0YXRlICgpID0gcHBfcHJpbnRfdGJyZWFrIHN0YXRlIDAgMFxuXG5sZXQgcHBfc2V0X3RhYiBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBlbGVtID0geyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX3N0YWI7IGxlbmd0aCA9IDAgfSBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGNvbnRyb2wgdGhlIHByZXR0eS1wcmludGVyc1xuXG4qKVxuXG4oKiBTZXRfbWF4X2JveGVzLiAqKVxubGV0IHBwX3NldF9tYXhfYm94ZXMgc3RhdGUgbiA9IGlmIG4gPiAxIHRoZW4gc3RhdGUucHBfbWF4X2JveGVzIDwtIG5cblxuKCogVG8ga25vdyB0aGUgY3VycmVudCBtYXhpbXVtIG51bWJlciBvZiBib3hlcyBhbGxvd2VkLiAqKVxubGV0IHBwX2dldF9tYXhfYm94ZXMgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxubGV0IHBwX292ZXJfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfY3Vycl9kZXB0aCA9IHN0YXRlLnBwX21heF9ib3hlc1xuXG4oKiBFbGxpcHNpcy4gKilcbmxldCBwcF9zZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSBzID0gc3RhdGUucHBfZWxsaXBzaXMgPC0gc1xuYW5kIHBwX2dldF9lbGxpcHNpc190ZXh0IHN0YXRlICgpID0gc3RhdGUucHBfZWxsaXBzaXNcblxuXG4oKiBUbyBzZXQgdGhlIG1hcmdpbiBvZiBwcmV0dHktcHJpbnRlci4gKilcbmxldCBwcF9saW1pdCBuID1cbiAgaWYgbiA8IHBwX2luZmluaXR5IHRoZW4gbiBlbHNlIHByZWQgcHBfaW5maW5pdHlcblxuXG4oKiBJbnRlcm5hbCBwcmV0dHktcHJpbnRlciBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X21pbl9zcGFjZV9sZWZ0IHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0IDwtIG47XG4gICAgc3RhdGUucHBfbWF4X2luZGVudCA8LSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9yaW5pdCBzdGF0ZVxuXG5cbigqIEluaXRpYWxseSwgd2UgaGF2ZSA6XG4gICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQsIGFuZFxuICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbi4gKilcbmxldCBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBuID1cbiAgaWYgbiA+IDEgdGhlblxuICAgIHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSAoc3RhdGUucHBfbWFyZ2luIC0gbilcblxuXG5sZXQgcHBfZ2V0X21heF9pbmRlbnQgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfaW5kZW50XG5cbmxldCBwcF9zZXRfbWFyZ2luIHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21hcmdpbiA8LSBuO1xuICAgIGxldCBuZXdfbWF4X2luZGVudCA9XG4gICAgICAoKiBUcnkgdG8gbWFpbnRhaW4gbWF4X2luZGVudCB0byBpdHMgYWN0dWFsIHZhbHVlLiAqKVxuICAgICAgaWYgc3RhdGUucHBfbWF4X2luZGVudCA8PSBzdGF0ZS5wcF9tYXJnaW5cbiAgICAgIHRoZW4gc3RhdGUucHBfbWF4X2luZGVudCBlbHNlXG4gICAgICAoKiBJZiBwb3NzaWJsZSBtYWludGFpbiBwcF9taW5fc3BhY2VfbGVmdCB0byBpdHMgYWN0dWFsIHZhbHVlLFxuICAgICAgICAgaWYgdGhpcyBsZWFkcyB0byBhIHRvbyBzbWFsbCBtYXhfaW5kZW50LCB0YWtlIGhhbGYgb2YgdGhlXG4gICAgICAgICBuZXcgbWFyZ2luLCBpZiBpdCBpcyBncmVhdGVyIHRoYW4gMS4gKilcbiAgICAgICBJbnQubWF4IChJbnQubWF4IChzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdClcbiAgICAgICAgICAgICAgICAoc3RhdGUucHBfbWFyZ2luIC8gMikpIDEgaW5cbiAgICAoKiBSZWJ1aWxkIGludmFyaWFudHMuICopXG4gICAgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbmV3X21heF9pbmRlbnRcblxuXG4oKiogR2VvbWV0cnkgZnVuY3Rpb25zIGFuZCB0eXBlcyAqKVxudHlwZSBnZW9tZXRyeSA9IHsgbWF4X2luZGVudDppbnQ7IG1hcmdpbjogaW50fVxuXG5sZXQgdmFsaWRhdGVfZ2VvbWV0cnkge21hcmdpbjsgbWF4X2luZGVudH0gPVxuICBpZiBtYXhfaW5kZW50IDwgMiB0aGVuXG4gICAgRXJyb3IgXCJtYXhfaW5kZW50IDwgMlwiXG4gIGVsc2UgaWYgbWFyZ2luIDw9IG1heF9pbmRlbnQgdGhlblxuICAgIEVycm9yIFwibWFyZ2luIDw9IG1heF9pbmRlbnRcIlxuICBlbHNlIE9rICgpXG5cbmxldCBjaGVja19nZW9tZXRyeSBnZW9tZXRyeSA9XG4gIG1hdGNoIHZhbGlkYXRlX2dlb21ldHJ5IGdlb21ldHJ5IHdpdGhcbiAgfCBPayAoKSAtPiB0cnVlXG4gIHwgRXJyb3IgXyAtPiBmYWxzZVxuXG5sZXQgcHBfZ2V0X21hcmdpbiBzdGF0ZSAoKSA9IHN0YXRlLnBwX21hcmdpblxuXG5sZXQgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUge21hcmdpbjsgbWF4X2luZGVudH0gPVxuICBwcF9zZXRfbWFyZ2luIHN0YXRlIG1hcmdpbjtcbiAgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbWF4X2luZGVudDtcbiAgKClcblxubGV0IHBwX3NldF9nZW9tZXRyeSBzdGF0ZSB+bWF4X2luZGVudCB+bWFyZ2luID1cbiAgbGV0IGdlb21ldHJ5ID0geyBtYXhfaW5kZW50OyBtYXJnaW4gfSBpblxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgRXJyb3IgbXNnIC0+XG4gICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgKFwiRm9ybWF0LnBwX3NldF9nZW9tZXRyeTogXCIgXiBtc2cpKVxuICB8IE9rICgpIC0+XG4gICAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgZ2VvbWV0cnlcblxubGV0IHBwX3NhZmVfc2V0X2dlb21ldHJ5IHN0YXRlIH5tYXhfaW5kZW50IH5tYXJnaW4gPVxuICBsZXQgZ2VvbWV0cnkgPSB7IG1heF9pbmRlbnQ7IG1hcmdpbiB9IGluXG4gIG1hdGNoIHZhbGlkYXRlX2dlb21ldHJ5IGdlb21ldHJ5IHdpdGhcbiAgfCBFcnJvciBfbXNnIC0+XG4gICAgICgpXG4gIHwgT2sgKCkgLT5cbiAgICBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSBnZW9tZXRyeVxuXG5sZXQgcHBfZ2V0X2dlb21ldHJ5IHN0YXRlICgpID1cbiAgeyBtYXJnaW4gPSBwcF9nZXRfbWFyZ2luIHN0YXRlICgpOyBtYXhfaW5kZW50ID0gcHBfZ2V0X21heF9pbmRlbnQgc3RhdGUgKCkgfVxuXG5sZXQgcHBfdXBkYXRlX2dlb21ldHJ5IHN0YXRlIHVwZGF0ZSA9XG4gIGxldCBnZW9tZXRyeSA9IHBwX2dldF9nZW9tZXRyeSBzdGF0ZSAoKSBpblxuICBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSAodXBkYXRlIGdlb21ldHJ5KVxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgIG91dF9zdHJpbmcgPSBmO1xuICAgICAgb3V0X2ZsdXNoID0gZztcbiAgICAgIG91dF9uZXdsaW5lID0gaDtcbiAgICAgIG91dF9zcGFjZXMgPSBpO1xuICAgICAgb3V0X2luZGVudCA9IGo7XG4gICAgfSA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gZjtcbiAgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIGc7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGg7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gaTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBqXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RhdGUgKCkgPSB7XG4gIG91dF9zdHJpbmcgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nO1xuICBvdXRfZmx1c2ggPSBzdGF0ZS5wcF9vdXRfZmx1c2g7XG4gIG91dF9uZXdsaW5lID0gc3RhdGUucHBfb3V0X25ld2xpbmU7XG4gIG91dF9zcGFjZXMgPSBzdGF0ZS5wcF9vdXRfc3BhY2VzO1xuICBvdXRfaW5kZW50ID0gc3RhdGUucHBfb3V0X2luZGVudDtcbn1cblxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIHN0cmluZyBvdXRwdXQgYW5kIGZsdXNoIGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgZiBnID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBmOyBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gZ1xuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlICgpID1cbiAgKHN0YXRlLnBwX291dF9zdHJpbmcsIHN0YXRlLnBwX291dF9mbHVzaClcblxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgbmV3IGxpbmVzLiAqKVxubGV0IGRpc3BsYXlfbmV3bGluZSBzdGF0ZSAoKSA9IHN0YXRlLnBwX291dF9zdHJpbmcgXCJcXG5cIiAwICAxXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBzcGFjZXMuICopXG5sZXQgYmxhbmtfbGluZSA9IFN0cmluZy5tYWtlIDgwICcgJ1xubGV0IHJlYyBkaXNwbGF5X2JsYW5rcyBzdGF0ZSBuID1cbiAgaWYgbiA+IDAgdGhlblxuICBpZiBuIDw9IDgwIHRoZW4gc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgbiBlbHNlXG4gIGJlZ2luXG4gICAgc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgODA7XG4gICAgZGlzcGxheV9ibGFua3Mgc3RhdGUgKG4gLSA4MClcbiAgZW5kXG5cblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbmxldCBkaXNwbGF5X2luZGVudCA9IGRpc3BsYXlfYmxhbmtzXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucyBhcyBwcmludGluZyB0byBhIGdpdmVuXG4gICBbU3RkbGliLm91dF9jaGFubmVsXSB2YWx1ZS4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIHN0YXRlIG9jID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBvdXRwdXRfc3Vic3RyaW5nIG9jO1xuICBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gKGZ1biAoKSAtPiBmbHVzaCBvYyk7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGRpc3BsYXlfbmV3bGluZSBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBzdGF0ZVxuXG4oKlxuXG4gIERlZmluaW5nIHNwZWNpZmljIGZvcm1hdHRlcnNcblxuKilcblxubGV0IGRlZmF1bHRfcHBfbWFya19vcGVuX3RhZyA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nX3RhZyBzIC0+IFwiPFwiIF4gcyBeIFwiPlwiXG4gIHwgXyAtPiBcIlwiXG5sZXQgZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZyA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nX3RhZyBzIC0+IFwiPC9cIiBeIHMgXiBcIj5cIlxuICB8IF8gLT4gXCJcIlxuXG5sZXQgZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyA9IGlnbm9yZVxubGV0IGRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnID0gaWdub3JlXG5cbigqIEJ1aWxkaW5nIGEgZm9ybWF0dGVyIGdpdmVuIGl0cyBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLlxuICAgT3RoZXIgZmllbGRzIGdldCByZWFzb25hYmxlIGRlZmF1bHQgdmFsdWVzLiAqKVxubGV0IHBwX21ha2VfZm9ybWF0dGVyIGYgZyBoIGkgaiA9XG4gICgqIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBmb3JtYXR0ZXIgY29udGFpbnMgYSBkdW1teSBib3guICopXG4gIGxldCBwcF9xdWV1ZSA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICBsZXQgc3lzX3RvayA9XG4gICAgeyBzaXplID0gU2l6ZS51bmtub3duOyB0b2tlbiA9IFBwX2JlZ2luICgwLCBQcF9ob3Zib3gpOyBsZW5ndGggPSAwIH0gaW5cbiAgUXVldWUuYWRkIHN5c190b2sgcHBfcXVldWU7XG4gIGxldCBzY2FuX3N0YWNrID0gU3RhY2suY3JlYXRlICgpIGluXG4gIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzY2FuX3N0YWNrO1xuICBTdGFjay5wdXNoIHsgbGVmdF90b3RhbCA9IDE7IHF1ZXVlX2VsZW0gPSBzeXNfdG9rIH0gc2Nhbl9zdGFjaztcbiAgbGV0IHBwX21hcmdpbiA9IDc4XG4gIGFuZCBwcF9taW5fc3BhY2VfbGVmdCA9IDEwIGluXG4gIHtcbiAgICBwcF9zY2FuX3N0YWNrID0gc2Nhbl9zdGFjaztcbiAgICBwcF9mb3JtYXRfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfdGJveF9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF90YWdfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfbWFya19zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF9tYXJnaW4gPSBwcF9tYXJnaW47XG4gICAgcHBfbWluX3NwYWNlX2xlZnQgPSBwcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbjtcbiAgICBwcF9jdXJyZW50X2luZGVudCA9IDA7XG4gICAgcHBfaXNfbmV3X2xpbmUgPSB0cnVlO1xuICAgIHBwX2xlZnRfdG90YWwgPSAxO1xuICAgIHBwX3JpZ2h0X3RvdGFsID0gMTtcbiAgICBwcF9jdXJyX2RlcHRoID0gMTtcbiAgICBwcF9tYXhfYm94ZXMgPSBtYXhfaW50O1xuICAgIHBwX2VsbGlwc2lzID0gXCIuXCI7XG4gICAgcHBfb3V0X3N0cmluZyA9IGY7XG4gICAgcHBfb3V0X2ZsdXNoID0gZztcbiAgICBwcF9vdXRfbmV3bGluZSA9IGg7XG4gICAgcHBfb3V0X3NwYWNlcyA9IGk7XG4gICAgcHBfb3V0X2luZGVudCA9IGo7XG4gICAgcHBfcHJpbnRfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfb3Blbl90YWcgPSBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWc7XG4gICAgcHBfbWFya19jbG9zZV90YWcgPSBkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnO1xuICAgIHBwX3ByaW50X29wZW5fdGFnID0gZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZztcbiAgICBwcF9wcmludF9jbG9zZV90YWcgPSBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZztcbiAgICBwcF9xdWV1ZSA9IHBwX3F1ZXVlO1xuICB9XG5cblxuKCogQnVpbGQgYSBmb3JtYXR0ZXIgb3V0IG9mIGl0cyBvdXQgZnVuY3Rpb25zLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIG91dF9mdW5zID1cbiAgcHBfbWFrZV9mb3JtYXR0ZXJcbiAgICBvdXRfZnVucy5vdXRfc3RyaW5nXG4gICAgb3V0X2Z1bnMub3V0X2ZsdXNoXG4gICAgb3V0X2Z1bnMub3V0X25ld2xpbmVcbiAgICBvdXRfZnVucy5vdXRfc3BhY2VzXG4gICAgb3V0X2Z1bnMub3V0X2luZGVudFxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd2l0aCBkZWZhdWx0IGZ1bmN0aW9ucyB0byBvdXRwdXQgc3BhY2VzLFxuICBpbmRlbnRhdGlvbiwgYW5kIG5ldyBsaW5lcy4gKilcbmxldCBtYWtlX2Zvcm1hdHRlciBvdXRwdXQgZmx1c2ggPVxuICBsZXQgcHBmID0gcHBfbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoIGlnbm9yZSBpZ25vcmUgaWdub3JlIGluXG4gIHBwZi5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgcHBmO1xuICBwcGYucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBwcGY7XG4gIHBwZi5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHBwZjtcbiAgcHBmXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW1N0ZGxpYi5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX291dF9jaGFubmVsIG9jID1cbiAgbWFrZV9mb3JtYXR0ZXIgKG91dHB1dF9zdWJzdHJpbmcgb2MpIChmdW4gKCkgLT4gZmx1c2ggb2MpXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW0J1ZmZlci50XSB2YWx1ZS4gKilcbmxldCBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgPVxuICBtYWtlX2Zvcm1hdHRlciAoQnVmZmVyLmFkZF9zdWJzdHJpbmcgYikgaWdub3JlXG5cblxuKCogQWxsb2NhdGluZyBidWZmZXIgZm9yIHByZXR0eS1wcmludGluZyBwdXJwb3Nlcy5cbiAgIERlZmF1bHQgYnVmZmVyIHNpemUgaXMgcHBfYnVmZmVyX3NpemUgb3IgNTEyLlxuKilcbmxldCBwcF9idWZmZXJfc2l6ZSA9IDUxMlxubGV0IHBwX21ha2VfYnVmZmVyICgpID0gQnVmZmVyLmNyZWF0ZSBwcF9idWZmZXJfc2l6ZVxuXG4oKiBUaGUgc3RhbmRhcmQgKHNoYXJlZCkgYnVmZmVyLiAqKVxubGV0IHN0ZGJ1ZiA9IHBwX21ha2VfYnVmZmVyICgpXG5cbigqIFByZWRlZmluZWQgZm9ybWF0dGVycyBzdGFuZGFyZCBmb3JtYXR0ZXIgdG8gcHJpbnRcbiAgIHRvIFtTdGRsaWIuc3Rkb3V0XSwgW1N0ZGxpYi5zdGRlcnJdLCBhbmQgeyFzdGRidWZ9LiAqKVxubGV0IHN0ZF9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgU3RkbGliLnN0ZG91dFxuYW5kIGVycl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgU3RkbGliLnN0ZGVyclxuYW5kIHN0cl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIHN0ZGJ1ZlxuXG4oKiBJbml0aWFsaXNlIGRvbWFpbiBsb2NhbCBzdGF0ZSAqKVxubW9kdWxlIERMUyA9IERvbWFpbi5ETFNcblxubGV0IHN0ZGJ1Zl9rZXkgPSBETFMubmV3X2tleSBwcF9tYWtlX2J1ZmZlclxubGV0IF8gPSBETFMuc2V0IHN0ZGJ1Zl9rZXkgc3RkYnVmXG5cbmxldCBzdHJfZm9ybWF0dGVyX2tleSA9IERMUy5uZXdfa2V5IChmdW4gKCkgLT5cbiAgZm9ybWF0dGVyX29mX2J1ZmZlciAoRExTLmdldCBzdGRidWZfa2V5KSlcbmxldCBfID0gRExTLnNldCBzdHJfZm9ybWF0dGVyX2tleSBzdHJfZm9ybWF0dGVyXG5cbmxldCBidWZmZXJlZF9vdXRfc3RyaW5nIGtleSBzdHIgb2ZzIGxlbiA9XG4gIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIChEb21haW4uRExTLmdldCBrZXkpIHN0ciBvZnMgbGVuXG5cbmxldCBidWZmZXJlZF9vdXRfZmx1c2ggb2Mga2V5ICgpID1cbiAgbGV0IGJ1ZiA9IERvbWFpbi5ETFMuZ2V0IGtleSBpblxuICBsZXQgbGVuID0gQnVmZmVyLmxlbmd0aCBidWYgaW5cbiAgbGV0IHN0ciA9IEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgb3V0cHV0X3N1YnN0cmluZyBvYyBzdHIgMCBsZW4gO1xuICBTdGRsaWIuZmx1c2ggb2M7XG4gIEJ1ZmZlci5jbGVhciBidWZcblxubGV0IHN0ZF9idWZfa2V5ID0gRG9tYWluLkRMUy5uZXdfa2V5IChmdW4gKCkgLT4gQnVmZmVyLmNyZWF0ZSBwcF9idWZmZXJfc2l6ZSlcbmxldCBlcnJfYnVmX2tleSA9IERvbWFpbi5ETFMubmV3X2tleSAoZnVuICgpIC0+IEJ1ZmZlci5jcmVhdGUgcHBfYnVmZmVyX3NpemUpXG5cbmxldCBzdGRfZm9ybWF0dGVyX2tleSA9IERMUy5uZXdfa2V5IChmdW4gKCkgLT5cbiAgbGV0IHBwZiA9XG4gICAgcHBfbWFrZV9mb3JtYXR0ZXIgKGJ1ZmZlcmVkX291dF9zdHJpbmcgc3RkX2J1Zl9rZXkpXG4gICAgICAoYnVmZmVyZWRfb3V0X2ZsdXNoIFN0ZGxpYi5zdGRvdXQgc3RkX2J1Zl9rZXkpIGlnbm9yZSBpZ25vcmUgaWdub3JlXG4gIGluXG4gIHBwZi5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgcHBmO1xuICBwcGYucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBwcGY7XG4gIHBwZi5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHBwZjtcbiAgRG9tYWluLmF0X2V4aXQgKHBwX3ByaW50X2ZsdXNoIHBwZik7XG4gIHBwZilcbmxldCBfID0gRExTLnNldCBzdGRfZm9ybWF0dGVyX2tleSBzdGRfZm9ybWF0dGVyXG5cbmxldCBlcnJfZm9ybWF0dGVyX2tleSA9IERMUy5uZXdfa2V5IChmdW4gKCkgLT5cbiAgbGV0IHBwZiA9XG4gICAgcHBfbWFrZV9mb3JtYXR0ZXIgKGJ1ZmZlcmVkX291dF9zdHJpbmcgZXJyX2J1Zl9rZXkpXG4gICAgICAoYnVmZmVyZWRfb3V0X2ZsdXNoIFN0ZGxpYi5zdGRlcnIgZXJyX2J1Zl9rZXkpIGlnbm9yZSBpZ25vcmUgaWdub3JlXG4gIGluXG4gIHBwZi5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgcHBmO1xuICBwcGYucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBwcGY7XG4gIHBwZi5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHBwZjtcbiAgRG9tYWluLmF0X2V4aXQgKHBwX3ByaW50X2ZsdXNoIHBwZik7XG4gIHBwZilcbmxldCBfID0gRExTLnNldCBlcnJfZm9ybWF0dGVyX2tleSBlcnJfZm9ybWF0dGVyXG5cbmxldCBnZXRfc3RkX2Zvcm1hdHRlciAoKSA9IERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXlcbmxldCBnZXRfZXJyX2Zvcm1hdHRlciAoKSA9IERMUy5nZXQgZXJyX2Zvcm1hdHRlcl9rZXlcbmxldCBnZXRfc3RyX2Zvcm1hdHRlciAoKSA9IERMUy5nZXQgc3RyX2Zvcm1hdHRlcl9rZXlcbmxldCBnZXRfc3RkYnVmICgpID0gRExTLmdldCBzdGRidWZfa2V5XG5cbigqIFtmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGZdIGZsdXNoZXMgZm9ybWF0dGVyIFtwcGZdLFxuICAgdGhlbiByZXR1cm5zIHRoZSBjb250ZW50cyBvZiBidWZmZXIgW2J1Zl0gdGhhdCBpcyByZXNldC5cbiAgIEZvcm1hdHRlciBbcHBmXSBpcyBzdXBwb3NlZCB0byBwcmludCB0byBidWZmZXIgW2J1Zl0sIG90aGVyd2lzZSB0aGlzXG4gICBmdW5jdGlvbiBpcyBub3QgcmVhbGx5IHVzZWZ1bC4gKilcbmxldCBmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGYgPVxuICBwcF9mbHVzaF9xdWV1ZSBwcGYgZmFsc2U7XG4gIGxldCBzID0gQnVmZmVyLmNvbnRlbnRzIGJ1ZiBpblxuICBCdWZmZXIucmVzZXQgYnVmO1xuICBzXG5cbigqIEZsdXNoIFtzdHJfZm9ybWF0dGVyXSBhbmQgZ2V0IHRoZSBjb250ZW50cyBvZiBbc3RkYnVmXS4gKilcbmxldCBmbHVzaF9zdHJfZm9ybWF0dGVyICgpID1cbiAgbGV0IHN0ZGJ1ZiA9IERMUy5nZXQgc3RkYnVmX2tleSBpblxuICBsZXQgc3RyX2Zvcm1hdHRlciA9IERMUy5nZXQgc3RyX2Zvcm1hdHRlcl9rZXkgaW5cbiAgZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBzdGRidWYgc3RyX2Zvcm1hdHRlclxuXG5sZXQgbWFrZV9zeW5jaHJvbml6ZWRfZm9ybWF0dGVyIG91dHB1dCBmbHVzaCA9XG4gIERMUy5uZXdfa2V5IChmdW4gKCkgLT5cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBwcF9idWZmZXJfc2l6ZSBpblxuICAgIGxldCBvdXRwdXQnID0gQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIGluXG4gICAgbGV0IGZsdXNoJyAoKSA9XG4gICAgICBvdXRwdXQgKEJ1ZmZlci5jb250ZW50cyBidWYpIDAgKEJ1ZmZlci5sZW5ndGggYnVmKTtcbiAgICAgIEJ1ZmZlci5jbGVhciBidWY7XG4gICAgICBmbHVzaCAoKVxuICAgIGluXG4gICAgbWFrZV9mb3JtYXR0ZXIgb3V0cHV0JyBmbHVzaCcpXG5cbmxldCBzeW5jaHJvbml6ZWRfZm9ybWF0dGVyX29mX291dF9jaGFubmVsIG9jID1cbiAgbWFrZV9zeW5jaHJvbml6ZWRfZm9ybWF0dGVyIChvdXRwdXRfc3Vic3RyaW5nIG9jKSAoZnVuICgpIC0+IGZsdXNoIG9jKVxuXG4oKlxuICBTeW1ib2xpYyBwcmV0dHktcHJpbnRpbmdcbiopXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZyBpcyBwcmV0dHktcHJpbnRpbmcgd2l0aCBubyBsb3cgbGV2ZWwgb3V0cHV0LlxuXG4gIFdoZW4gdXNpbmcgYSBzeW1ib2xpYyBmb3JtYXR0ZXIsIGFsbCByZWd1bGFyIHByZXR0eS1wcmludGluZyBhY3Rpdml0aWVzXG4gIG9jY3VyIGJ1dCBvdXRwdXQgbWF0ZXJpYWwgaXMgc3ltYm9saWMgYW5kIHN0b3JlZCBpbiBhIGJ1ZmZlciBvZiBvdXRwdXRcbiAgaXRlbXMuIEF0IHRoZSBlbmQgb2YgcHJldHR5LXByaW50aW5nLCBmbHVzaGluZyB0aGUgb3V0cHV0IGJ1ZmZlciBhbGxvd3NcbiAgcG9zdC1wcm9jZXNzaW5nIG9mIHN5bWJvbGljIG91dHB1dCBiZWZvcmUgbG93IGxldmVsIG91dHB1dCBvcGVyYXRpb25zLlxuKilcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfaXRlbSA9XG4gIHwgT3V0cHV0X2ZsdXNoXG4gIHwgT3V0cHV0X25ld2xpbmVcbiAgfCBPdXRwdXRfc3RyaW5nIG9mIHN0cmluZ1xuICB8IE91dHB1dF9zcGFjZXMgb2YgaW50XG4gIHwgT3V0cHV0X2luZGVudCBvZiBpbnRcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfYnVmZmVyID0ge1xuICBtdXRhYmxlIHN5bWJvbGljX291dHB1dF9jb250ZW50cyA6IHN5bWJvbGljX291dHB1dF9pdGVtIGxpc3Q7XG59XG5cbmxldCBtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIgKCkgPVxuICB7IHN5bWJvbGljX291dHB1dF9jb250ZW50cyA9IFtdIH1cblxubGV0IGNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50cyA8LSBbXVxuXG5sZXQgZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgTGlzdC5yZXYgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgaXRlbXMgPSBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgaW5cbiAgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2I7XG4gIGl0ZW1zXG5cbmxldCBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIGl0ZW0gPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIGl0ZW0gOjogc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgbGV0IHN5bWJvbGljX2ZsdXNoIHNvYiAoKSA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBPdXRwdXRfZmx1c2hcbiAgYW5kIHN5bWJvbGljX25ld2xpbmUgc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9uZXdsaW5lXG4gIGFuZCBzeW1ib2xpY19zdHJpbmcgc29iIHMgaSBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3RyaW5nIChTdHJpbmcuc3ViIHMgaSBuKSlcbiAgYW5kIHN5bWJvbGljX3NwYWNlcyBzb2IgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X3NwYWNlcyBuKVxuICBhbmQgc3ltYm9saWNfaW5kZW50IHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfaW5kZW50IG4pIGluXG5cbiAgbGV0IGYgPSBzeW1ib2xpY19zdHJpbmcgc29iXG4gIGFuZCBnID0gc3ltYm9saWNfZmx1c2ggc29iXG4gIGFuZCBoID0gc3ltYm9saWNfbmV3bGluZSBzb2JcbiAgYW5kIGkgPSBzeW1ib2xpY19zcGFjZXMgc29iXG4gIGFuZCBqID0gc3ltYm9saWNfaW5kZW50IHNvYiBpblxuICBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGpcblxuKCpcblxuICBCYXNpYyBmdW5jdGlvbnMgb24gdGhlICdzdGFuZGFyZCcgZm9ybWF0dGVyXG4gICh0aGUgZm9ybWF0dGVyIHRoYXQgcHJpbnRzIHRvIFtTdGRsaWIuc3Rkb3V0XSkuXG5cbiopXG5cbmxldCBvcGVuX2hib3ggdiA9IHBwX29wZW5faGJveCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIG9wZW5fdmJveCB2ID0gcHBfb3Blbl92Ym94IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgb3Blbl9odmJveCB2ID0gcHBfb3Blbl9odmJveCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIG9wZW5faG92Ym94IHYgPSBwcF9vcGVuX2hvdmJveCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIG9wZW5fYm94IHYgPSBwcF9vcGVuX2JveCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIGNsb3NlX2JveCB2ID0gcHBfY2xvc2VfYm94IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgb3Blbl9zdGFnIHYgPSBwcF9vcGVuX3N0YWcgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBjbG9zZV9zdGFnIHYgPSBwcF9jbG9zZV9zdGFnIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfYXMgdiB3ID0gcHBfcHJpbnRfYXMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHYgd1xuYW5kIHByaW50X3N0cmluZyB2ID0gcHBfcHJpbnRfc3RyaW5nIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfYnl0ZXMgdiA9IHBwX3ByaW50X2J5dGVzIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfaW50IHYgPSBwcF9wcmludF9pbnQgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBwcmludF9mbG9hdCB2ID0gcHBfcHJpbnRfZmxvYXQgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBwcmludF9jaGFyIHYgPSBwcF9wcmludF9jaGFyIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfYm9vbCB2ID0gcHBfcHJpbnRfYm9vbCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIHByaW50X2JyZWFrIHYgdyA9IHBwX3ByaW50X2JyZWFrIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2IHdcbmFuZCBwcmludF9jdXQgdiA9IHBwX3ByaW50X2N1dCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIHByaW50X3NwYWNlIHYgPSBwcF9wcmludF9zcGFjZSAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIGZvcmNlX25ld2xpbmUgdiA9IHBwX2ZvcmNlX25ld2xpbmUgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBwcmludF9mbHVzaCB2ID0gcHBfcHJpbnRfZmx1c2ggKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBwcmludF9uZXdsaW5lIHYgPSBwcF9wcmludF9uZXdsaW5lIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfaWZfbmV3bGluZSB2ID0gcHBfcHJpbnRfaWZfbmV3bGluZSAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuXG5hbmQgb3Blbl90Ym94IHYgPSBwcF9vcGVuX3Rib3ggKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBjbG9zZV90Ym94IHYgPSBwcF9jbG9zZV90Ym94IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfdGJyZWFrIHYgdyA9IHBwX3ByaW50X3RicmVhayAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdiB3XG5cbmFuZCBzZXRfdGFiIHYgPSBwcF9zZXRfdGFiIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfdGFiIHYgPSBwcF9wcmludF90YWIgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuYW5kIHNldF9tYXJnaW4gdiA9IHBwX3NldF9tYXJnaW4gKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBnZXRfbWFyZ2luIHYgPSBwcF9nZXRfbWFyZ2luIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5cbmFuZCBzZXRfbWF4X2luZGVudCB2ID0gcHBfc2V0X21heF9pbmRlbnQgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBnZXRfbWF4X2luZGVudCB2ID0gcHBfZ2V0X21heF9pbmRlbnQgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuYW5kIHNldF9nZW9tZXRyeSB+bWF4X2luZGVudCB+bWFyZ2luID1cbiAgcHBfc2V0X2dlb21ldHJ5IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB+bWF4X2luZGVudCB+bWFyZ2luXG5hbmQgc2FmZV9zZXRfZ2VvbWV0cnkgfm1heF9pbmRlbnQgfm1hcmdpbiA9XG4gIHBwX3NhZmVfc2V0X2dlb21ldHJ5IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB+bWF4X2luZGVudCB+bWFyZ2luXG5hbmQgZ2V0X2dlb21ldHJ5IHYgPSBwcF9nZXRfZ2VvbWV0cnkgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCB1cGRhdGVfZ2VvbWV0cnkgdiA9IHBwX3VwZGF0ZV9nZW9tZXRyeSAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuXG5hbmQgc2V0X21heF9ib3hlcyB2ID0gcHBfc2V0X21heF9ib3hlcyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIGdldF9tYXhfYm94ZXMgdiA9IHBwX2dldF9tYXhfYm94ZXMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBvdmVyX21heF9ib3hlcyB2ID0gcHBfb3Zlcl9tYXhfYm94ZXMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuYW5kIHNldF9lbGxpcHNpc190ZXh0IHYgPSBwcF9zZXRfZWxsaXBzaXNfdGV4dCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIGdldF9lbGxpcHNpc190ZXh0IHYgPSBwcF9nZXRfZWxsaXBzaXNfdGV4dCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCB2ID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHYgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBnZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgdiA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHYgdyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdiB3XG5hbmQgZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHYgPVxuICBwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuYW5kIHNldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgdiA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBnZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHYgPVxuICBwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgc2V0X3ByaW50X3RhZ3MgdiA9XG4gIHBwX3NldF9wcmludF90YWdzIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgZ2V0X3ByaW50X3RhZ3MgdiA9XG4gIHBwX2dldF9wcmludF90YWdzIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgc2V0X21hcmtfdGFncyB2ID1cbiAgcHBfc2V0X21hcmtfdGFncyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIGdldF9tYXJrX3RhZ3MgdiA9XG4gIHBwX2dldF9tYXJrX3RhZ3MgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBzZXRfdGFncyB2ID1cbiAgcHBfc2V0X3RhZ3MgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuXG4oKiBDb252ZW5pZW5jZSBmdW5jdGlvbnMgKilcblxuKCogVG8gZm9ybWF0IGEgbGlzdCAqKVxubGV0IHJlYyBwcF9wcmludF9saXN0ID8ocHBfc2VwID0gcHBfcHJpbnRfY3V0KSBwcF92IHBwZiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gKClcbiAgfCBbdl0gLT4gcHBfdiBwcGYgdlxuICB8IHYgOjogdnMgLT5cbiAgICBwcF92IHBwZiB2O1xuICAgIHBwX3NlcCBwcGYgKCk7XG4gICAgcHBfcHJpbnRfbGlzdCB+cHBfc2VwIHBwX3YgcHBmIHZzXG5cbigqIFRvIGZvcm1hdCBhIHNlcXVlbmNlICopXG5sZXQgcmVjIHBwX3ByaW50X3NlcV9pbiB+cHBfc2VwIHBwX3YgcHBmIHNlcSA9XG4gIG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgU2VxLk5pbCAtPiAoKVxuICB8IFNlcS5Db25zICh2LCBzZXEpIC0+XG4gICAgcHBfc2VwIHBwZiAoKTtcbiAgICBwcF92IHBwZiB2O1xuICAgIHBwX3ByaW50X3NlcV9pbiB+cHBfc2VwIHBwX3YgcHBmIHNlcVxuXG5sZXQgcHBfcHJpbnRfc2VxID8ocHBfc2VwID0gcHBfcHJpbnRfY3V0KSBwcF92IHBwZiBzZXEgPVxuICBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IFNlcS5OaWwgLT4gKClcbiAgfCBTZXEuQ29ucyAodiwgc2VxKSAtPlxuICAgIHBwX3YgcHBmIHY7XG4gICAgcHBfcHJpbnRfc2VxX2luIH5wcF9zZXAgcHBfdiBwcGYgc2VxXG5cbigqIFRvIGZvcm1hdCBmcmVlLWZsb3dpbmcgdGV4dCAqKVxubGV0IHBwX3ByaW50X3RleHQgcHBmIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBsZWZ0ID0gcmVmIDAgaW5cbiAgbGV0IHJpZ2h0ID0gcmVmIDAgaW5cbiAgbGV0IGZsdXNoICgpID1cbiAgICBwcF9wcmludF9zdHJpbmcgcHBmIChTdHJpbmcuc3ViIHMgIWxlZnQgKCFyaWdodCAtICFsZWZ0KSk7XG4gICAgaW5jciByaWdodDsgbGVmdCA6PSAhcmlnaHQ7XG4gIGluXG4gIHdoaWxlICghcmlnaHQgPD4gbGVuKSBkb1xuICAgIG1hdGNoIHMuWyFyaWdodF0gd2l0aFxuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICBmbHVzaCAoKTtcbiAgICAgICAgcHBfZm9yY2VfbmV3bGluZSBwcGYgKClcbiAgICAgIHwgJyAnIC0+XG4gICAgICAgIGZsdXNoICgpOyBwcF9wcmludF9zcGFjZSBwcGYgKClcbiAgICAgICgqIHRoZXJlIGlzIG5vIHNwZWNpZmljIHN1cHBvcnQgZm9yICdcXHQnXG4gICAgICAgICBhcyBpdCBpcyB1bmNsZWFyIHdoYXQgYSByaWdodCBzZW1hbnRpY3Mgd291bGQgYmUgKilcbiAgICAgIHwgXyAtPiBpbmNyIHJpZ2h0XG4gIGRvbmU7XG4gIGlmICFsZWZ0IDw+IGxlbiB0aGVuIGZsdXNoICgpXG5cbmxldCBwcF9wcmludF9vcHRpb24gPyhub25lID0gZnVuIF8gKCkgLT4gKCkpIHBwX3YgcHBmID0gZnVuY3Rpb25cbnwgTm9uZSAtPiBub25lIHBwZiAoKVxufCBTb21lIHYgLT4gcHBfdiBwcGYgdlxuXG5sZXQgcHBfcHJpbnRfcmVzdWx0IH5vayB+ZXJyb3IgcHBmID0gZnVuY3Rpb25cbnwgT2sgdiAtPiBvayBwcGYgdlxufCBFcnJvciBlIC0+IGVycm9yIHBwZiBlXG5cbmxldCBwcF9wcmludF9laXRoZXIgfmxlZnQgfnJpZ2h0IHBwZiA9IGZ1bmN0aW9uXG58IEVpdGhlci5MZWZ0IGwgLT4gbGVmdCBwcGYgbFxufCBFaXRoZXIuUmlnaHQgciAtPiByaWdodCBwcGYgclxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5sZXQgY29tcHV0ZV90YWcgb3V0cHV0IHRhZ19hY2MgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAxNiBpblxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBidWYgaW5cbiAgb3V0cHV0IHBwZiB0YWdfYWNjO1xuICBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIGxldCBsZW4gPSBCdWZmZXIubGVuZ3RoIGJ1ZiBpblxuICBpZiBsZW4gPCAyIHRoZW4gQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICBlbHNlIEJ1ZmZlci5zdWIgYnVmIDEgKGxlbiAtIDIpXG5cbiAoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBEZWZpbmluZyBjb250aW51YXRpb25zIHRvIGJlIHBhc3NlZCBhcyBhcmd1bWVudHMgb2ZcbiAgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLlxuXG4gICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxuKCogSW50ZXJwcmV0IGEgZm9ybWF0dGluZyBlbnRpdHkgb24gYSBmb3JtYXR0ZXIuICopXG5sZXQgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmbXRpbmdfbGl0ID0gbWF0Y2ggZm10aW5nX2xpdCB3aXRoXG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgICAgICAtPiBwcF9jbG9zZV9ib3ggcHBmICgpXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAtPiBwcF9jbG9zZV9zdGFnIHBwZiAoKVxuICB8IEJyZWFrIChfLCB3aWR0aCwgb2Zmc2V0KSAgLT4gcHBfcHJpbnRfYnJlYWsgcHBmIHdpZHRoIG9mZnNldFxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfZmx1c2ggcHBmICgpXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgICAgICAgLT4gcHBfcHJpbnRfbmV3bGluZSBwcGYgKClcbiAgfCBNYWdpY19zaXplIChfLCBfKSAgICAgICAgIC0+ICgpXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCdcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICclJ1xuICB8IFNjYW5faW5kaWMgYyAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJ0AnOyBwcF9wcmludF9jaGFyIHBwZiBjXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYW4gb3V0cHV0X3N0cmVhbS4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5vdXRwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIG91dHB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3N0YWcgcHBmIChTdHJpbmdfdGFnIChjb21wdXRlX3RhZyBvdXRwdXRfYWNjIGFjYycpKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgb3V0cHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IGYgcHBmO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IG91dHB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5idWZwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2RlbGF5IChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgZikgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoZiAoKSk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3N0YWcgcHBmIChTdHJpbmdfdGFnIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgc3RycHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgKGYgKCkpO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IHN0cnB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCpcblxuICBEZWZpbmluZyBbZnByaW50Zl0gYW5kIHZhcmlvdXMgZmxhdm9ycyBvZiBbZnByaW50Zl0uXG5cbiopXG5cbmxldCBrZnByaW50ZiBrIHBwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyBwcGYgYWNjOyBrIHBwZilcbiAgICBFbmRfb2ZfYWNjIGZtdFxuXG5hbmQgaWtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGsgcHBmIGZtdFxuXG5sZXQgaWZwcmludGYgX3BwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBpZ25vcmUgKCkgZm10XG5cbmxldCBmcHJpbnRmIHBwZiA9IGtmcHJpbnRmIGlnbm9yZSBwcGZcblxubGV0IHByaW50ZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgYWNjKVxuICAgIEVuZF9vZl9hY2MgZm10XG5cbmxldCBlcHJpbnRmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIGFjYyAtPiBvdXRwdXRfYWNjIChETFMuZ2V0IGVycl9mb3JtYXR0ZXJfa2V5KSBhY2MpXG4gICAgRW5kX29mX2FjYyBmbXRcblxubGV0IGtkcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZlxuICAgIChmdW4gYWNjIC0+IGsgKGZ1biBwcGYgLT4gb3V0cHV0X2FjYyBwcGYgYWNjKSlcbiAgICBFbmRfb2ZfYWNjIGZtdFxuXG5sZXQgZHByaW50ZiBmbXQgPSBrZHByaW50ZiAoZnVuIGkgLT4gaSkgZm10XG5cbmxldCBrc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGIgPSBwcF9tYWtlX2J1ZmZlciAoKSBpblxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gIGxldCBrIGFjYyA9XG4gICAgc3RycHV0X2FjYyBwcGYgYWNjO1xuICAgIGsgKGZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgYiBwcGYpIGluXG4gIG1ha2VfcHJpbnRmIGsgRW5kX29mX2FjYyBmbXRcblxuXG5sZXQgc3ByaW50ZiBmbXQgPSBrc3ByaW50ZiBpZCBmbXRcblxubGV0IGthc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGIgPSBwcF9tYWtlX2J1ZmZlciAoKSBpblxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gIGxldCBrIGFjYyA9XG4gICAgb3V0cHV0X2FjYyBwcGYgYWNjO1xuICAgIGsgKGZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgYiBwcGYpIGluXG4gIG1ha2VfcHJpbnRmIGsgRW5kX29mX2FjYyBmbXRcblxuXG5sZXQgYXNwcmludGYgZm10ID0ga2FzcHJpbnRmIGlkIGZtdFxuXG4oKiBGbHVzaGluZyBzdGFuZGFyZCBmb3JtYXR0ZXJzIGF0IGVuZCBvZiBleGVjdXRpb24uICopXG5cbmxldCBmbHVzaF9zdGFuZGFyZF9mb3JtYXR0ZXJzICgpID1cbiAgcHBfcHJpbnRfZmx1c2ggKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpICgpO1xuICBwcF9wcmludF9mbHVzaCAoRExTLmdldCBlcnJfZm9ybWF0dGVyX2tleSkgKClcblxubGV0ICgpID0gYXRfZXhpdCBmbHVzaF9zdGFuZGFyZF9mb3JtYXR0ZXJzXG5cbmxldCAoKSA9IERvbWFpbi5iZWZvcmVfZmlyc3Rfc3Bhd24gKGZ1biAoKSAtPlxuICBmbHVzaF9zdGFuZGFyZF9mb3JtYXR0ZXJzICgpO1xuICBsZXQgZnMgPSBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlciAoKSBpblxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuICAgIHtmcyB3aXRoIG91dF9zdHJpbmcgPSBidWZmZXJlZF9vdXRfc3RyaW5nIHN0ZF9idWZfa2V5O1xuICAgICAgICAgICAgIG91dF9mbHVzaCA9IGJ1ZmZlcmVkX291dF9mbHVzaCBTdGRsaWIuc3Rkb3V0IHN0ZF9idWZfa2V5fTtcblxuICBsZXQgZnMgPSBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgZXJyX2Zvcm1hdHRlciAoKSBpblxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgZXJyX2Zvcm1hdHRlclxuICAgIHtmcyB3aXRoIG91dF9zdHJpbmcgPSBidWZmZXJlZF9vdXRfc3RyaW5nIGVycl9idWZfa2V5O1xuICAgICAgICAgICAgIG91dF9mbHVzaCA9IGJ1ZmZlcmVkX291dF9mbHVzaCBTdGRsaWIuc3RkZXJyIGVycl9idWZfa2V5fTtcbilcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIGFsaWFzIHRvIGF2b2lkIHdhcm5pbmcgZm9yIGFtYmlndWl0eSBiZXR3ZWVuXG4gICBTdGRsaWIuZm9ybWF0NlxuICAgYW5kIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG5cbiAgICh0aGUgZm9ybWVyIGlzIGluIGZhY3QgYW4gYWxpYXMgZm9yIHRoZSBsYXR0ZXIsXG4gICAgYnV0IHRoZSBhbWJpZ3VpdHkgd2FybmluZyBkb2Vzbid0IGNhcmUpXG4qKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBTdGRsaWIuZm9ybWF0NlxuXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FubmVycy4gKilcblxuKCogU2Nhbm5pbmcgYnVmZmVycy4gKilcbm1vZHVsZSB0eXBlIFNDQU5OSU5HID0gc2lnXG5cbiAgdHlwZSBpbl9jaGFubmVsXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIHR5cGUgZmlsZV9uYW1lID0gc3RyaW5nXG5cbiAgdmFsIHN0ZGluIDogaW5fY2hhbm5lbFxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbU3RkbGliLnN0ZGluXS4gKilcblxuICB2YWwgbmV4dF9jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFtTY2FubmluZy5uZXh0X2NoYXIgaWJdIGFkdmFuY2UgdGhlIHNjYW5uaW5nIGJ1ZmZlciBmb3JcbiAgICAgb25lIGNoYXJhY3Rlci5cbiAgICAgSWYgbm8gbW9yZSBjaGFyYWN0ZXIgY2FuIGJlIHJlYWQsIHNldHMgYSBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXSBtYXJrIHRoZSBjdXJyZW50X2NoYXIgYXMgYWxyZWFkeVxuICAgICBzY2FubmVkLiAqKVxuXG4gIHZhbCBwZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogW1NjYW5uaW5nLnBlZWtfY2hhciBpYl0gcmV0dXJucyB0aGUgY3VycmVudCBjaGFyIGF2YWlsYWJsZSBpblxuICAgICB0aGUgYnVmZmVyIG9yIHJlYWRzIG9uZSBpZiBuZWNlc3NhcnkgKHdoZW4gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzXG4gICAgIGFscmVhZHkgc2Nhbm5lZCkuXG4gICAgIElmIG5vIGNoYXJhY3RlciBjYW4gYmUgcmVhZCwgc2V0cyBhbiBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgY2hlY2tlZF9wZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogU2FtZSBhcyBbU2Nhbm5pbmcucGVla19jaGFyXSBhYm92ZSBidXQgYWx3YXlzIHJldHVybnMgYSB2YWxpZCBjaGFyIG9yXG4gICAgIGZhaWxzOiBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG51bGwgY2hhciB3aGVuIHRoZSByZWFkaW5nIG1ldGhvZCBvZiB0aGVcbiAgICAgaW5wdXQgYnVmZmVyIGhhcyByZWFjaGVkIGFuIGVuZCBvZiBmaWxlLCB0aGUgZnVuY3Rpb24gcmFpc2VzIGV4Y2VwdGlvblxuICAgICBbRW5kX29mX2ZpbGVdLiAqKVxuXG4gIHZhbCBzdG9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gY2hhciAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnN0b3JlX2NoYXIgbGltIGliIGNdIGFkZHMgW2NdIHRvIHRoZSB0b2tlbiBidWZmZXJcbiAgICAgb2YgdGhlIHNjYW5uaW5nIGJ1ZmZlciBbaWJdLiBJdCBhbHNvIGFkdmFuY2VzIHRoZSBzY2FubmluZyBidWZmZXIgZm9yXG4gICAgIG9uZSBjaGFyYWN0ZXIgYW5kIHJldHVybnMgW2xpbSAtIDFdLCBpbmRpY2F0aW5nIHRoZSBuZXcgbGltaXQgZm9yIHRoZVxuICAgICBsZW5ndGggb2YgdGhlIGN1cnJlbnQgdG9rZW4uICopXG5cbiAgdmFsIHNraXBfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuc2tpcF9jaGFyIGxpbSBpYl0gaWdub3JlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuICopXG5cbiAgdmFsIGlnbm9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5pZ25vcmVfY2hhciBpYiBsaW1dIGlnbm9yZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGFuZFxuICAgICBkZWNyZW1lbnRzIHRoZSBsaW1pdC4gKilcblxuICB2YWwgdG9rZW4gOiBzY2FuYnVmIC0+IHN0cmluZ1xuICAoKiBbU2Nhbm5pbmcudG9rZW4gaWJdIHJldHVybnMgdGhlIHN0cmluZyBzdG9yZWQgaW50byB0aGUgdG9rZW5cbiAgICAgYnVmZmVyIG9mIHRoZSBzY2FubmluZyBidWZmZXI6IGl0IHJldHVybnMgdGhlIHRva2VuIG1hdGNoZWQgYnkgdGhlXG4gICAgIGZvcm1hdC4gKilcblxuICB2YWwgcmVzZXRfdG9rZW4gOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLnJlc2V0X3Rva2VuIGliXSByZXNldHMgdGhlIHRva2VuIGJ1ZmZlciBvZlxuICAgICB0aGUgZ2l2ZW4gc2Nhbm5pbmcgYnVmZmVyLiAqKVxuXG4gIHZhbCBjaGFyX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmNoYXJfY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgIHJlYWQgc28gZmFyIGZyb20gdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgbGluZV9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5saW5lX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgbmV3IGxpbmVcbiAgICAgY2hhcmFjdGVycyByZWFkIHNvIGZhciBmcm9tIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIHRva2VuX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnRva2VuX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgdG9rZW5zIHJlYWRcbiAgICAgc28gZmFyIGZyb20gW2liXS4gKilcblxuICB2YWwgZW9mIDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lb2YgaWJdIHJldHVybnMgdGhlIGVuZCBvZiBpbnB1dCBjb25kaXRpb25cbiAgICAgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgZW5kX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWJdIHRlc3RzIHRoZSBlbmQgb2YgaW5wdXQgY29uZGl0aW9uXG4gICAgIG9mIHRoZSBnaXZlbiBidWZmZXIgKGlmIG5vIGNoYXIgaGFzIGV2ZXIgYmVlbiByZWFkLCBhbiBhdHRlbXB0IHRvXG4gICAgIHJlYWQgb25lIGlzIHBlcmZvcm1lZCkuICopXG5cbiAgdmFsIGJlZ2lubmluZ19vZl9pbnB1dCA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuYmVnaW5uaW5nX29mX2lucHV0IGliXSB0ZXN0cyB0aGUgYmVnaW5uaW5nIG9mIGlucHV0XG4gICAgIGNvbmRpdGlvbiBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBuYW1lX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBzdHJpbmdcbiAgKCogW1NjYW5uaW5nLm5hbWVfb2ZfaW5wdXQgaWJdIHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGNoYXJhY3RlclxuICAgICBzb3VyY2UgZm9yIGlucHV0IGJ1ZmZlciBbaWJdLiAqKVxuXG4gIHZhbCBvcGVuX2luIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIG9wZW5faW5fYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZmlsZSA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2ZpbGVfYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fc3RyaW5nIDogc3RyaW5nIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZnVuY3Rpb24gOiAodW5pdCAtPiBjaGFyKSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2NoYW5uZWwgOiBTdGRsaWIuaW5fY2hhbm5lbCAtPiBpbl9jaGFubmVsXG5cbiAgdmFsIGNsb3NlX2luIDogaW5fY2hhbm5lbCAtPiB1bml0XG5cbmVuZFxuXG5cbm1vZHVsZSBTY2FubmluZyA6IFNDQU5OSU5HID0gc3RydWN0XG5cbiAgKCogVGhlIHJ1bi10aW1lIGxpYnJhcnkgZm9yIHNjYW5mLiAqKVxuXG4gIHR5cGUgZmlsZV9uYW1lID0gc3RyaW5nXG5cbiAgdHlwZSBpbl9jaGFubmVsX25hbWUgPVxuICAgIHwgRnJvbV9jaGFubmVsIG9mIFN0ZGxpYi5pbl9jaGFubmVsXG4gICAgfCBGcm9tX2ZpbGUgb2YgZmlsZV9uYW1lICogU3RkbGliLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZnVuY3Rpb25cbiAgICB8IEZyb21fc3RyaW5nXG5cblxuICB0eXBlIGluX2NoYW5uZWwgPSB7XG4gICAgbXV0YWJsZSBpY19lb2YgOiBib29sO1xuICAgIG11dGFibGUgaWNfY3VycmVudF9jaGFyIDogY2hhcjtcbiAgICBtdXRhYmxlIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA6IGJvb2w7XG4gICAgbXV0YWJsZSBpY19jaGFyX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfbGluZV9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX3Rva2VuX2NvdW50IDogaW50O1xuICAgIGljX2dldF9uZXh0X2NoYXIgOiB1bml0IC0+IGNoYXI7XG4gICAgaWNfdG9rZW5fYnVmZmVyIDogQnVmZmVyLnQ7XG4gICAgaWNfaW5wdXRfbmFtZSA6IGluX2NoYW5uZWxfbmFtZTtcbiAgfVxuXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIGxldCBudWxsX2NoYXIgPSAnXFwwMDAnXG5cbiAgKCogUmVhZHMgYSBuZXcgY2hhcmFjdGVyIGZyb20gaW5wdXQgYnVmZmVyLlxuICAgICBOZXh0X2NoYXIgbmV2ZXIgZmFpbHMsIGV2ZW4gaW4gY2FzZSBvZiBlbmQgb2YgaW5wdXQ6XG4gICAgIGl0IHRoZW4gc2ltcGx5IHNldHMgdGhlIGVuZCBvZiBmaWxlIGNvbmRpdGlvbi4gKilcbiAgbGV0IG5leHRfY2hhciBpYiA9XG4gICAgdHJ5XG4gICAgICBsZXQgYyA9IGliLmljX2dldF9uZXh0X2NoYXIgKCkgaW5cbiAgICAgIGliLmljX2N1cnJlbnRfY2hhciA8LSBjO1xuICAgICAgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIHRydWU7XG4gICAgICBpYi5pY19jaGFyX2NvdW50IDwtIHN1Y2MgaWIuaWNfY2hhcl9jb3VudDtcbiAgICAgIGlmIGMgPSAnXFxuJyB0aGVuIGliLmljX2xpbmVfY291bnQgPC0gc3VjYyBpYi5pY19saW5lX2NvdW50O1xuICAgICAgYyB3aXRoXG4gICAgfCBFbmRfb2ZfZmlsZSAtPlxuICAgICAgbGV0IGMgPSBudWxsX2NoYXIgaW5cbiAgICAgIGliLmljX2N1cnJlbnRfY2hhciA8LSBjO1xuICAgICAgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIGZhbHNlO1xuICAgICAgaWIuaWNfZW9mIDwtIHRydWU7XG4gICAgICBjXG5cblxuICBsZXQgcGVla19jaGFyIGliID1cbiAgICBpZiBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWRcbiAgICB0aGVuIGliLmljX2N1cnJlbnRfY2hhclxuICAgIGVsc2UgbmV4dF9jaGFyIGliXG5cblxuICAoKiBSZXR1cm5zIGEgdmFsaWQgY3VycmVudCBjaGFyIGZvciB0aGUgaW5wdXQgYnVmZmVyLiBJbiBwYXJ0aWN1bGFyXG4gICAgIG5vIGlycmVsZXZhbnQgbnVsbCBjaGFyYWN0ZXIgKGFzIHNldCBieSBbbmV4dF9jaGFyXSBpbiBjYXNlIG9mIGVuZFxuICAgICBvZiBpbnB1dCkgaXMgcmV0dXJuZWQsIHNpbmNlIFtFbmRfb2ZfZmlsZV0gaXMgcmFpc2VkIHdoZW5cbiAgICAgW25leHRfY2hhcl0gc2V0cyB0aGUgZW5kIG9mIGZpbGUgY29uZGl0aW9uIHdoaWxlIHRyeWluZyB0byByZWFkIGFcbiAgICAgbmV3IGNoYXJhY3Rlci4gKilcbiAgbGV0IGNoZWNrZWRfcGVla19jaGFyIGliID1cbiAgICBsZXQgYyA9IHBlZWtfY2hhciBpYiBpblxuICAgIGlmIGliLmljX2VvZiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlO1xuICAgIGNcblxuXG4gIGxldCBlbmRfb2ZfaW5wdXQgaWIgPVxuICAgIGlnbm9yZSAocGVla19jaGFyIGliKTtcbiAgICBpYi5pY19lb2ZcblxuXG4gIGxldCBlb2YgaWIgPSBpYi5pY19lb2ZcblxuICBsZXQgYmVnaW5uaW5nX29mX2lucHV0IGliID0gaWIuaWNfY2hhcl9jb3VudCA9IDBcblxuICBsZXQgbmFtZV9vZl9pbnB1dCBpYiA9XG4gICAgbWF0Y2ggaWIuaWNfaW5wdXRfbmFtZSB3aXRoXG4gICAgfCBGcm9tX2NoYW5uZWwgX2ljIC0+IFwidW5uYW1lZCBTdGRsaWIgaW5wdXQgY2hhbm5lbFwiXG4gICAgfCBGcm9tX2ZpbGUgKGZuYW1lLCBfaWMpIC0+IGZuYW1lXG4gICAgfCBGcm9tX2Z1bmN0aW9uIC0+IFwidW5uYW1lZCBmdW5jdGlvblwiXG4gICAgfCBGcm9tX3N0cmluZyAtPiBcInVubmFtZWQgY2hhcmFjdGVyIHN0cmluZ1wiXG5cblxuICBsZXQgY2hhcl9jb3VudCBpYiA9XG4gICAgaWYgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkXG4gICAgdGhlbiBpYi5pY19jaGFyX2NvdW50IC0gMVxuICAgIGVsc2UgaWIuaWNfY2hhcl9jb3VudFxuXG5cbiAgbGV0IGxpbmVfY291bnQgaWIgPSBpYi5pY19saW5lX2NvdW50XG5cbiAgbGV0IHJlc2V0X3Rva2VuIGliID0gQnVmZmVyLnJlc2V0IGliLmljX3Rva2VuX2J1ZmZlclxuXG4gIGxldCBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiA9IGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSBmYWxzZVxuXG4gIGxldCB0b2tlbiBpYiA9XG4gICAgbGV0IHRva2VuX2J1ZmZlciA9IGliLmljX3Rva2VuX2J1ZmZlciBpblxuICAgIGxldCB0b2sgPSBCdWZmZXIuY29udGVudHMgdG9rZW5fYnVmZmVyIGluXG4gICAgQnVmZmVyLmNsZWFyIHRva2VuX2J1ZmZlcjtcbiAgICBpYi5pY190b2tlbl9jb3VudCA8LSBzdWNjIGliLmljX3Rva2VuX2NvdW50O1xuICAgIHRva1xuXG5cbiAgbGV0IHRva2VuX2NvdW50IGliID0gaWIuaWNfdG9rZW5fY291bnRcblxuICBsZXQgc2tpcF9jaGFyIHdpZHRoIGliID1cbiAgICBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjtcbiAgICB3aWR0aFxuXG5cbiAgbGV0IGlnbm9yZV9jaGFyIHdpZHRoIGliID0gc2tpcF9jaGFyICh3aWR0aCAtIDEpIGliXG5cbiAgbGV0IHN0b3JlX2NoYXIgd2lkdGggaWIgYyA9XG4gICAgQnVmZmVyLmFkZF9jaGFyIGliLmljX3Rva2VuX2J1ZmZlciBjO1xuICAgIGlnbm9yZV9jaGFyIHdpZHRoIGliXG5cblxuICBsZXQgZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZSA9IDEwMjRcblxuICBsZXQgY3JlYXRlIGluYW1lIG5leHQgPSB7XG4gICAgaWNfZW9mID0gZmFsc2U7XG4gICAgaWNfY3VycmVudF9jaGFyID0gbnVsbF9jaGFyO1xuICAgIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA9IGZhbHNlO1xuICAgIGljX2NoYXJfY291bnQgPSAwO1xuICAgIGljX2xpbmVfY291bnQgPSAwO1xuICAgIGljX3Rva2VuX2NvdW50ID0gMDtcbiAgICBpY19nZXRfbmV4dF9jaGFyID0gbmV4dDtcbiAgICBpY190b2tlbl9idWZmZXIgPSBCdWZmZXIuY3JlYXRlIGRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemU7XG4gICAgaWNfaW5wdXRfbmFtZSA9IGluYW1lO1xuICB9XG5cblxuICBsZXQgZnJvbV9zdHJpbmcgcyA9XG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA+PSBsZW4gdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlXG4gICAgICBsZXQgYyA9IHMuWyFpXSBpblxuICAgICAgaW5jciBpO1xuICAgICAgYyBpblxuICAgIGNyZWF0ZSBGcm9tX3N0cmluZyBuZXh0XG5cblxuICBsZXQgZnJvbV9mdW5jdGlvbiA9IGNyZWF0ZSBGcm9tX2Z1bmN0aW9uXG5cbiAgKCogU2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsLiAqKVxuXG4gICgqIFBvc2l0aW9uIG9mIHRoZSBwcm9ibGVtOlxuXG4gICAgIFdlIGNhbm5vdCBwcmV2ZW50IHRoZSBzY2FubmluZyBtZWNoYW5pc20gdG8gdXNlIG9uZSBsb29rYWhlYWQgY2hhcmFjdGVyLFxuICAgICBpZiBuZWVkZWQgYnkgdGhlIHNlbWFudGljcyBvZiB0aGUgZm9ybWF0IHN0cmluZyBzcGVjaWZpY2F0aW9ucyAoZS5nLiBhXG4gICAgIHRyYWlsaW5nICdza2lwIHNwYWNlJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBmb3JtYXQgc3RyaW5nKTsgaW4gdGhpcyBjYXNlLFxuICAgICB0aGUgbWFuZGF0b3J5IGxvb2thaGVhZCBjaGFyYWN0ZXIgaXMgaW5kZWVkIHJlYWQgZnJvbSB0aGUgaW5wdXQgYW5kIG5vdFxuICAgICB1c2VkIHRvIHJldHVybiB0aGUgdG9rZW4gcmVhZC4gSXQgaXMgdGh1cyBtYW5kYXRvcnkgdG8gYmUgYWJsZSB0byBzdG9yZVxuICAgICBhbiB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBzb21ld2hlcmUgdG8gZ2V0IGl0IGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgb2YgdGhlIG5leHQgc2Nhbi5cblxuICAgICBUbyBjaXJjdW12ZW50IHRoaXMgcHJvYmxlbSwgYWxsIHRoZSBzY2FubmluZyBmdW5jdGlvbnMgZ2V0IGEgbG93IGxldmVsXG4gICAgIGlucHV0IGJ1ZmZlciBhcmd1bWVudCB3aGVyZSB0aGV5IHN0b3JlIHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyIHdoZW5cbiAgICAgbmVlZGVkOyBhZGRpdGlvbmFsbHksIHRoZSBpbnB1dCBidWZmZXIgaXMgdGhlIG9ubHkgc291cmNlIG9mIGNoYXJhY3RlciBvZlxuICAgICBhIHNjYW5uZXIuIFRoZSBbc2NhbmJ1Zl0gaW5wdXQgYnVmZmVycyBhcmUgZGVmaW5lZCBpbiBtb2R1bGUgeyFTY2FubmluZ30uXG5cbiAgICAgTm93IHdlIHVuZGVyc3RhbmQgdGhhdCBpdCBpcyBleHRyZW1lbHkgaW1wb3J0YW50IHRoYXQgcmVsYXRlZCBhbmRcbiAgICAgc3VjY2Vzc2l2ZSBjYWxscyB0byBzY2FubmVycyBpbmRlZWQgcmVhZCBmcm9tIHRoZSBzYW1lIGlucHV0IGJ1ZmZlci5cbiAgICAgSW4gZWZmZWN0LCBpZiBhIHNjYW5uZXIgW3NjYW4xXSBpcyByZWFkaW5nIGZyb20gW2liMV0gYW5kIHN0b3JlcyBhblxuICAgICB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBbYzFdIGludG8gaXRzIGlucHV0IGJ1ZmZlciBbaWIxXSwgdGhlblxuICAgICBhbm90aGVyIHNjYW5uZXIgW3NjYW4yXSBub3QgcmVhZGluZyBmcm9tIHRoZSBzYW1lIGJ1ZmZlciBbaWIxXSB3aWxsIG1pc3NcbiAgICAgdGhlIGNoYXJhY3RlciBbYzFdLCBzZWVtaW5nbHkgdmFuaXNoZWQgaW4gdGhlIGFpciBmcm9tIHRoZSBwb2ludCBvZiB2aWV3XG4gICAgIG9mIFtzY2FuMl0uXG5cbiAgICAgVGhpcyBtZWNoYW5pc20gd29ya3MgcGVyZmVjdGx5IHRvIHJlYWQgZnJvbSBzdHJpbmdzLCBmcm9tIGZpbGVzLCBhbmQgZnJvbVxuICAgICBmdW5jdGlvbnMsIHNpbmNlIGluIHRob3NlIGNhc2VzLCBhbGxvY2F0aW5nIHR3byBidWZmZXJzIHJlYWRpbmcgZnJvbSB0aGVcbiAgICAgc2FtZSBzb3VyY2UgaXMgdW5uYXR1cmFsLlxuXG4gICAgIFN0aWxsLCB0aGVyZSBpcyBhIGRpZmZpY3VsdHkgaW4gdGhlIGNhc2Ugb2Ygc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dFxuICAgICBjaGFubmVsLiBJbiBlZmZlY3QsIHdoZW4gc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsIFtpY10sIHRoaXMgY2hhbm5lbFxuICAgICBtYXkgbm90IGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB3aXRoaW4gdGhpcyBsaWJyYXJ5LiBIZW5jZSwgaXQgbWF5IGJlXG4gICAgIHNoYXJlZCAodHdvIGZ1bmN0aW9ucyBvZiB0aGUgdXNlcidzIHByb2dyYW0gbWF5IHN1Y2Nlc3NpdmVseSByZWFkIGZyb21cbiAgICAgW2ljXSkuIFRoaXMgaXMgaGlnaGx5IGVycm9yIHByb25lIHNpbmNlLCBvbmUgb2YgdGhlIGZ1bmN0aW9uIG1heSBzZWVrIHRoZVxuICAgICBpbnB1dCBjaGFubmVsLCB3aGlsZSB0aGUgb3RoZXIgZnVuY3Rpb24gaGFzIHN0aWxsIGFuIHVudXNlZCBsb29rYWhlYWRcbiAgICAgY2hhcmFjdGVyIGluIGl0cyBpbnB1dCBidWZmZXIuIEluIGNvbmNsdXNpb24sIHlvdSBzaG91bGQgbmV2ZXIgbWl4IGRpcmVjdFxuICAgICBsb3cgbGV2ZWwgcmVhZGluZyBhbmQgaGlnaCBsZXZlbCBzY2FubmluZyBmcm9tIHRoZSBzYW1lIGlucHV0IGNoYW5uZWwuXG5cbiAgKilcblxuICAoKiBQZXJmb3JtIGJ1ZmZlcml6ZWQgaW5wdXQgdG8gaW1wcm92ZSBlZmZpY2llbmN5LiAqKVxuICBsZXQgZmlsZV9idWZmZXJfc2l6ZSA9IHJlZiAxMDI0XG5cbiAgKCogVGhlIHNjYW5uZXIgY2xvc2VzIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dC4gKilcbiAgbGV0IHNjYW5fY2xvc2VfYXRfZW5kIGljID0gU3RkbGliLmNsb3NlX2luIGljOyByYWlzZSBFbmRfb2ZfZmlsZVxuXG4gICgqIFRoZSBzY2FubmVyIGRvZXMgbm90IGNsb3NlIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dDpcbiAgICAgaXQganVzdCByYWlzZXMgW0VuZF9vZl9maWxlXS4gKilcbiAgbGV0IHNjYW5fcmFpc2VfYXRfZW5kIF9pYyA9IHJhaXNlIEVuZF9vZl9maWxlXG5cbiAgbGV0IGZyb21faWMgc2Nhbl9jbG9zZV9pYyBpbmFtZSBpYyA9XG4gICAgbGV0IGxlbiA9ICFmaWxlX2J1ZmZlcl9zaXplIGluXG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGxpbSA9IHJlZiAwIGluXG4gICAgbGV0IGVvZiA9IHJlZiBmYWxzZSBpblxuICAgIGxldCBuZXh0ICgpID1cbiAgICAgIGlmICFpIDwgIWxpbSB0aGVuIGJlZ2luIGxldCBjID0gQnl0ZXMuZ2V0IGJ1ZiAhaSBpbiBpbmNyIGk7IGMgZW5kIGVsc2VcbiAgICAgIGlmICFlb2YgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlIGJlZ2luXG4gICAgICAgIGxpbSA6PSBpbnB1dCBpYyBidWYgMCBsZW47XG4gICAgICAgIGlmICFsaW0gPSAwIHRoZW4gYmVnaW4gZW9mIDo9IHRydWU7IHNjYW5fY2xvc2VfaWMgaWMgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICBpIDo9IDE7XG4gICAgICAgICAgQnl0ZXMuZ2V0IGJ1ZiAwXG4gICAgICAgIGVuZFxuICAgICAgZW5kIGluXG4gICAgY3JlYXRlIGluYW1lIG5leHRcblxuXG4gIGxldCBmcm9tX2ljX2Nsb3NlX2F0X2VuZCA9IGZyb21faWMgc2Nhbl9jbG9zZV9hdF9lbmRcbiAgbGV0IGZyb21faWNfcmFpc2VfYXRfZW5kID0gZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuXG4gICgqIFRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLlxuICAgICBPbmUgY291bGQgdHJ5IHRvIGRlZmluZSBbc3RkaW5dIGFzIGEgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgYSBjaGFyYWN0ZXJcbiAgICAgYXQgYSB0aW1lIChubyBidWZmZXJpemF0aW9uIGF0IGFsbCksIGJ1dCB1bmZvcnR1bmF0ZWx5IHRoZSB0b3AtbGV2ZWxcbiAgICAgaW50ZXJhY3Rpb24gd291bGQgYmUgd3JvbmcuIFRoaXMgaXMgZHVlIHRvIHNvbWUga2luZCBvZlxuICAgICAncmFjZSBjb25kaXRpb24nIHdoZW4gcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLFxuICAgICBzaW5jZSB0aGUgaW50ZXJhY3RpdmUgY29tcGlsZXIgYW5kIFtTY2FuZi5zY2FuZl0gd2lsbCBzaW11bHRhbmVvdXNseVxuICAgICByZWFkIHRoZSBtYXRlcmlhbCB0aGV5IG5lZWQgZnJvbSBbU3RkbGliLnN0ZGluXTsgdGhlbiwgY29uZnVzaW9uXG4gICAgIHdpbGwgcmVzdWx0IGZyb20gd2hhdCBzaG91bGQgYmUgcmVhZCBieSB0aGUgdG9wLWxldmVsIGFuZCB3aGF0IHNob3VsZCBiZVxuICAgICByZWFkIGJ5IFtTY2FuZi5zY2FuZl0uXG4gICAgIFRoaXMgaXMgZXZlbiBtb3JlIGNvbXBsaWNhdGVkIGJ5IHRoZSBvbmUgY2hhcmFjdGVyIGxvb2thaGVhZCB0aGF0XG4gICAgIFtTY2FuZi5zY2FuZl0gaXMgc29tZXRpbWVzIG9ibGlnZWQgdG8gbWFpbnRhaW46IHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyXG4gICAgIHdpbGwgYmUgYXZhaWxhYmxlIGZvciB0aGUgbmV4dCBbU2NhbmYuc2NhbmZdIGVudHJ5LCBzZWVtaW5nbHkgY29taW5nIGZyb21cbiAgICAgbm93aGVyZS5cbiAgICAgQWxzbyBubyBbRW5kX29mX2ZpbGVdIGlzIHJhaXNlZCB3aGVuIHJlYWRpbmcgZnJvbSBzdGRpbjogaWYgbm90IGVub3VnaFxuICAgICBjaGFyYWN0ZXJzIGhhdmUgYmVlbiByZWFkLCB3ZSBzaW1wbHkgYXNrIHRvIHJlYWQgbW9yZS4gKilcbiAgbGV0IHN0ZGluID1cbiAgICBmcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG4gICAgICAoRnJvbV9maWxlIChcIi1cIiwgU3RkbGliLnN0ZGluKSkgU3RkbGliLnN0ZGluXG5cbiAgbGV0IG9wZW5faW5fZmlsZSBvcGVuX2luIGZuYW1lID1cbiAgICBtYXRjaCBmbmFtZSB3aXRoXG4gICAgfCBcIi1cIiAtPiBzdGRpblxuICAgIHwgZm5hbWUgLT5cbiAgICAgIGxldCBpYyA9IG9wZW5faW4gZm5hbWUgaW5cbiAgICAgIGZyb21faWNfY2xvc2VfYXRfZW5kIChGcm9tX2ZpbGUgKGZuYW1lLCBpYykpIGljXG5cblxuICBsZXQgb3Blbl9pbiA9IG9wZW5faW5fZmlsZSBTdGRsaWIub3Blbl9pblxuICBsZXQgb3Blbl9pbl9iaW4gPSBvcGVuX2luX2ZpbGUgU3RkbGliLm9wZW5faW5fYmluXG5cbiAgbGV0IGZyb21fZmlsZSA9IG9wZW5faW5cbiAgbGV0IGZyb21fZmlsZV9iaW4gPSBvcGVuX2luX2JpblxuXG4gIGxldCBmcm9tX2NoYW5uZWwgaWMgPVxuICAgIGZyb21faWNfcmFpc2VfYXRfZW5kIChGcm9tX2NoYW5uZWwgaWMpIGljXG5cblxuICBsZXQgY2xvc2VfaW4gaWIgPVxuICAgIG1hdGNoIGliLmljX2lucHV0X25hbWUgd2l0aFxuICAgIHwgRnJvbV9jaGFubmVsIGljIC0+XG4gICAgICBTdGRsaWIuY2xvc2VfaW4gaWNcbiAgICB8IEZyb21fZmlsZSAoX2ZuYW1lLCBpYykgLT4gU3RkbGliLmNsb3NlX2luIGljXG4gICAgfCBGcm9tX2Z1bmN0aW9uIHwgRnJvbV9zdHJpbmcgLT4gKClcblxuZW5kXG5cblxuKCogRm9ybWF0dGVkIGlucHV0IGZ1bmN0aW9ucy4gKilcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIHNjYW5uZXIgPVxuICAgICAoJ2EsIFNjYW5uaW5nLmluX2NoYW5uZWwsICdiLCAnYywgJ2EgLT4gJ2QsICdkKSBmb3JtYXQ2IC0+ICdjXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkKSBzY2FubmVyX29wdCA9XG4gICAgICgnYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgJ2IsICdjLCAnYSAtPiAnZCBvcHRpb24sICdkKSBmb3JtYXQ2IC0+ICdjXG5cbigqIFJlcG9ydGluZyBlcnJvcnMuICopXG5leGNlcHRpb24gU2Nhbl9mYWlsdXJlIG9mIHN0cmluZ1xuXG5sZXQgYmFkX2lucHV0IHMgPSByYWlzZSAoU2Nhbl9mYWlsdXJlIHMpXG5cbmxldCBiYWRfaW5wdXRfZXNjYXBlIGMgPVxuICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiaWxsZWdhbCBlc2NhcGUgY2hhcmFjdGVyICVDXCIgYylcblxuXG5sZXQgYmFkX3Rva2VuX2xlbmd0aCBtZXNzYWdlID1cbiAgYmFkX2lucHV0XG4gICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgXCJzY2FubmluZyBvZiAlcyBmYWlsZWQ6IFxcXG4gICAgICAgIHRoZSBzcGVjaWZpZWQgbGVuZ3RoIHdhcyB0b28gc2hvcnQgZm9yIHRva2VuXCJcbiAgICAgICBtZXNzYWdlKVxuXG5cbmxldCBiYWRfZW5kX29mX2lucHV0IG1lc3NhZ2UgPVxuICBiYWRfaW5wdXRcbiAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICBcInNjYW5uaW5nIG9mICVzIGZhaWxlZDogXFxcbiAgICAgICAgcHJlbWF0dXJlIGVuZCBvZiBmaWxlIG9jY3VycmVkIGJlZm9yZSBlbmQgb2YgdG9rZW5cIlxuICAgICAgIG1lc3NhZ2UpXG5cblxubGV0IGJhZF9mbG9hdCAoKSA9XG4gIGJhZF9pbnB1dCBcIm5vIGRvdCBvciBleHBvbmVudCBwYXJ0IGZvdW5kIGluIGZsb2F0IHRva2VuXCJcblxuXG5sZXQgYmFkX2hleF9mbG9hdCAoKSA9XG4gIGJhZF9pbnB1dCBcIm5vdCBhIHZhbGlkIGZsb2F0IGluIGhleGFkZWNpbWFsIG5vdGF0aW9uXCJcblxuXG5sZXQgY2hhcmFjdGVyX21pc21hdGNoX2VyciBjIGNpID1cbiAgUHJpbnRmLnNwcmludGYgXCJsb29raW5nIGZvciAlQywgZm91bmQgJUNcIiBjIGNpXG5cblxubGV0IGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpID1cbiAgYmFkX2lucHV0IChjaGFyYWN0ZXJfbWlzbWF0Y2hfZXJyIGMgY2kpXG5cblxubGV0IHJlYyBza2lwX3doaXRlcyBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIG5vdCAoU2Nhbm5pbmcuZW9mIGliKSB0aGVuIGJlZ2luXG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnICcgfCAnXFx0JyB8ICdcXG4nIHwgJ1xccicgLT5cbiAgICAgIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliOyBza2lwX3doaXRlcyBpYlxuICAgIHwgXyAtPiAoKVxuICBlbmRcblxuXG4oKiBDaGVja2luZyB0aGF0IFtjXSBpcyBpbmRlZWQgaW4gdGhlIGlucHV0LCB0aGVuIHNraXBzIGl0LlxuICAgSW4gdGhpcyBjYXNlLCB0aGUgY2hhcmFjdGVyIFtjXSBoYXMgYmVlbiBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiB0aGVcbiAgIGZvcm1hdCBhcyBiZWluZyBtYW5kYXRvcnkgaW4gdGhlIGlucHV0OyBoZW5jZSB3ZSBzaG91bGQgZmFpbCB3aXRoXG4gICBbRW5kX29mX2ZpbGVdIGluIGNhc2Ugb2YgZW5kX29mX2lucHV0LlxuICAgKFJlbWVtYmVyIHRoYXQgW1NjYW5fZmFpbHVyZV0gaXMgcmFpc2VkIG9ubHkgd2hlbiAod2UgY2FuIHByb3ZlIGJ5XG4gICBldmlkZW5jZSkgdGhhdCB0aGUgaW5wdXQgZG9lcyBub3QgbWF0Y2ggdGhlIGZvcm1hdCBzdHJpbmcgZ2l2ZW4uIFdlIG11c3RcbiAgIHRodXMgZGlmZmVyZW50aWF0ZSBbRW5kX29mX2ZpbGVdIGFzIGFuIGVycm9yIGR1ZSB0byBsYWNrIG9mIGlucHV0LCBhbmRcbiAgIFtTY2FuX2ZhaWx1cmVdIHdoaWNoIGlzIGR1ZSB0byBwcm92YWJseSB3cm9uZyBpbnB1dC4gSSBhbSBub3Qgc3VyZSB0aGlzIGlzXG4gICB3b3J0aCB0aGUgYnVyZGVuOiBpdCBpcyBjb21wbGV4IGFuZCBzb21laG93IHN1YmxpbWluYWw7IHNob3VsZCBiZSBjbGVhcmVyXG4gICB0byBmYWlsIHdpdGggU2Nhbl9mYWlsdXJlIFwiTm90IGVub3VnaCBpbnB1dCB0byBjb21wbGV0ZSBzY2FubmluZ1wiISlcblxuICAgVGhhdCdzIHdoeSwgd2FpdGluZyBmb3IgYSBiZXR0ZXIgc29sdXRpb24sIHdlIHVzZSBjaGVja2VkX3BlZWtfY2hhciBoZXJlLlxuICAgV2UgYXJlIGFsc28gY2FyZWZ1bCB0byB0cmVhdCBcIlxcclxcblwiIGluIHRoZSBpbnB1dCBhcyBhbiBlbmQgb2YgbGluZSBtYXJrZXI6XG4gICBpdCBhbHdheXMgbWF0Y2hlcyBhICdcXG4nIHNwZWNpZmljYXRpb24gaW4gdGhlIGlucHV0IGZvcm1hdCBzdHJpbmcuICopXG5sZXQgcmVjIGNoZWNrX2NoYXIgaWIgYyA9XG4gIG1hdGNoIGMgd2l0aFxuICB8ICcgJyAtPiBza2lwX3doaXRlcyBpYlxuICB8ICdcXG4nIC0+IGNoZWNrX25ld2xpbmUgaWJcbiAgfCBjIC0+IGNoZWNrX3RoaXNfY2hhciBpYiBjXG5cbmFuZCBjaGVja190aGlzX2NoYXIgaWIgYyA9XG4gIGxldCBjaSA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGlmIGNpID0gYyB0aGVuIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliIGVsc2VcbiAgY2hhcmFjdGVyX21pc21hdGNoIGMgY2lcblxuYW5kIGNoZWNrX25ld2xpbmUgaWIgPVxuICBsZXQgY2kgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjaSB3aXRoXG4gIHwgJ1xcbicgLT4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJcbiAgfCAnXFxyJyAtPiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjsgY2hlY2tfdGhpc19jaGFyIGliICdcXG4nXG4gIHwgXyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcbicgY2lcblxuXG4oKiBFeHRyYWN0aW5nIHRva2VucyBmcm9tIHRoZSBvdXRwdXQgdG9rZW4gYnVmZmVyLiAqKVxuXG5sZXQgdG9rZW5fY2hhciBpYiA9IChTY2FubmluZy50b2tlbiBpYikuWzBdXG5cbmxldCB0b2tlbl9zdHJpbmcgPSBTY2FubmluZy50b2tlblxuXG5sZXQgdG9rZW5fYm9vbCBpYiA9XG4gIG1hdGNoIFNjYW5uaW5nLnRva2VuIGliIHdpdGhcbiAgfCBcInRydWVcIiAtPiB0cnVlXG4gIHwgXCJmYWxzZVwiIC0+IGZhbHNlXG4gIHwgcyAtPiBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiaW52YWxpZCBib29sZWFuICclcydcIiBzKVxuXG5cbigqIFRoZSB0eXBlIG9mIGludGVnZXIgY29udmVyc2lvbnMuICopXG50eXBlIGludGVnZXJfY29udmVyc2lvbiA9XG4gIHwgQl9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGJpbmFyeSBjb252ZXJzaW9uICopXG4gIHwgRF9jb252ZXJzaW9uICgqIFNpZ25lZCBkZWNpbWFsIGNvbnZlcnNpb24gKilcbiAgfCBJX2NvbnZlcnNpb24gKCogU2lnbmVkIGludGVnZXIgY29udmVyc2lvbiAqKVxuICB8IE9fY29udmVyc2lvbiAoKiBVbnNpZ25lZCBvY3RhbCBjb252ZXJzaW9uICopXG4gIHwgVV9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGRlY2ltYWwgY29udmVyc2lvbiAqKVxuICB8IFhfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBoZXhhZGVjaW1hbCBjb252ZXJzaW9uICopXG5cblxubGV0IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyID0gZnVuY3Rpb25cbiAgfCAnYicgLT4gQl9jb252ZXJzaW9uXG4gIHwgJ2QnIC0+IERfY29udmVyc2lvblxuICB8ICdpJyAtPiBJX2NvbnZlcnNpb25cbiAgfCAnbycgLT4gT19jb252ZXJzaW9uXG4gIHwgJ3UnIC0+IFVfY29udmVyc2lvblxuICB8ICd4JyB8ICdYJyAtPiBYX2NvbnZlcnNpb25cbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5cbigqIEV4dHJhY3QgYW4gaW50ZWdlciBsaXRlcmFsIHRva2VuLlxuICAgU2luY2UgdGhlIGZ1bmN0aW9ucyBTdGRsaWIuKmludCpfb2Zfc3RyaW5nIGRvIG5vdCBhY2NlcHQgYSBsZWFkaW5nICssXG4gICB3ZSBza2lwIGl0IGlmIG5lY2Vzc2FyeS4gKilcbmxldCB0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliID1cbiAgbGV0IHRvayA9XG4gICAgbWF0Y2ggY29udiB3aXRoXG4gICAgfCBEX2NvbnZlcnNpb24gfCBJX2NvbnZlcnNpb24gLT4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IFVfY29udmVyc2lvbiAtPiBcIjB1XCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgT19jb252ZXJzaW9uIC0+IFwiMG9cIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBYX2NvbnZlcnNpb24gLT4gXCIweFwiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IEJfY29udmVyc2lvbiAtPiBcIjBiXCIgXiBTY2FubmluZy50b2tlbiBpYiBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggdG9rIGluXG4gIGlmIGwgPSAwIHx8IHRvay5bMF0gPD4gJysnIHRoZW4gdG9rIGVsc2UgU3RyaW5nLnN1YiB0b2sgMSAobCAtIDEpXG5cblxuKCogQWxsIHRoZSBmdW5jdGlvbnMgdGhhdCBjb252ZXJ0IGEgc3RyaW5nIHRvIGEgbnVtYmVyIHJhaXNlIHRoZSBleGNlcHRpb25cbiAgIEZhaWx1cmUgd2hlbiB0aGUgY29udmVyc2lvbiBpcyBub3QgcG9zc2libGUuXG4gICBUaGlzIGV4Y2VwdGlvbiBpcyB0aGVuIHRyYXBwZWQgaW4gW2tzY2FuZl0uICopXG5sZXQgdG9rZW5faW50IGNvbnYgaWIgPSBpbnRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxuXG5sZXQgdG9rZW5fZmxvYXQgaWIgPSBmbG9hdF9vZl9zdHJpbmcgKFNjYW5uaW5nLnRva2VuIGliKVxuXG4oKiBUbyBzY2FuIG5hdGl2ZSBpbnRzLCBpbnQzMiBhbmQgaW50NjQgaW50ZWdlcnMuXG4gICBXZSBjYW5ub3QgYWNjZXNzIHRvIGNvbnZlcnNpb25zIHRvL2Zyb20gc3RyaW5ncyBmb3IgdGhvc2UgdHlwZXMsXG4gICBOYXRpdmVpbnQub2Zfc3RyaW5nLCBJbnQzMi5vZl9zdHJpbmcsIGFuZCBJbnQ2NC5vZl9zdHJpbmcsXG4gICBzaW5jZSB0aG9zZSBtb2R1bGVzIGFyZSBub3QgYXZhaWxhYmxlIHRvIFtTY2FuZl0uXG4gICBIb3dldmVyLCB3ZSBjYW4gYmluZCBhbmQgdXNlIHRoZSBjb3JyZXNwb25kaW5nIHByaW1pdGl2ZXMgdGhhdCBhcmVcbiAgIGF2YWlsYWJsZSBpbiB0aGUgcnVudGltZS4gKilcbmV4dGVybmFsIG5hdGl2ZWludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gbmF0aXZlaW50XG4gID0gXCJjYW1sX25hdGl2ZWludF9vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCBpbnQzMl9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgaW50NjRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X29mX3N0cmluZ1wiXG5cblxubGV0IHRva2VuX25hdGl2ZWludCBjb252IGliID0gbmF0aXZlaW50X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcbmxldCB0b2tlbl9pbnQzMiBjb252IGliID0gaW50MzJfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxubGV0IHRva2VuX2ludDY0IGNvbnYgaWIgPSBpbnQ2NF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5cbigqIFNjYW5uaW5nIG51bWJlcnMuICopXG5cbigqIERpZ2l0cyBzY2FubmluZyBmdW5jdGlvbnMgc3VwcG9zZSB0aGF0IG9uZSBjaGFyYWN0ZXIgaGFzIGJlZW4gY2hlY2tlZCBhbmRcbiAgIGlzIGF2YWlsYWJsZSwgc2luY2UgdGhleSByZXR1cm4gYXQgZW5kIG9mIGZpbGUgd2l0aCB0aGUgY3VycmVudGx5IGZvdW5kXG4gICB0b2tlbiBzZWxlY3RlZC5cblxuICAgUHV0IGl0IGluIGFub3RoZXIgd2F5LCB0aGUgZGlnaXRzIHNjYW5uaW5nIGZ1bmN0aW9ucyBzY2FuIGZvciBhIHBvc3NpYmx5XG4gICBlbXB0eSBzZXF1ZW5jZSBvZiBkaWdpdHMsIChoZW5jZSwgYSBzdWNjZXNzZnVsIHNjYW5uaW5nIGZyb20gb25lIG9mIHRob3NlXG4gICBmdW5jdGlvbnMgZG9lcyBub3QgaW1wbHkgdGhhdCB0aGUgdG9rZW4gaXMgYSB3ZWxsLWZvcm1lZCBudW1iZXI6IHRvIGdldCBhXG4gICB0cnVlIG51bWJlciwgaXQgaXMgbWFuZGF0b3J5IHRvIGNoZWNrIHRoYXQgYXQgbGVhc3Qgb25lIHZhbGlkIGRpZ2l0IGlzXG4gICBhdmFpbGFibGUgYmVmb3JlIGNhbGxpbmcgb25lIG9mIHRoZSBkaWdpdCBzY2FubmluZyBmdW5jdGlvbnMpLiAqKVxuXG4oKiBUaGUgZGVjaW1hbCBjYXNlIGlzIHRyZWF0ZWQgZXNwZWNpYWxseSBmb3Igb3B0aW1pemF0aW9uIHB1cnBvc2VzLiAqKVxubGV0IHJlYyBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8ICdfJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxubGV0IHNjYW5fZGVjaW1hbF9kaWdpdF9wbHVzIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImRlY2ltYWwgZGlnaXRzXCIgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8IGMgLT5cbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiY2hhcmFjdGVyICVDIGlzIG5vdCBhIGRlY2ltYWwgZGlnaXRcIiBjKVxuXG5cbigqIFRvIHNjYW4gbnVtYmVycyBmcm9tIG90aGVyIGJhc2VzLCB3ZSB1c2UgYSBwcmVkaWNhdGUgYXJndW1lbnQgdG9cbiAgIHNjYW4gZGlnaXRzLiAqKVxubGV0IHNjYW5fZGlnaXRfc3RhciBkaWdpdHAgd2lkdGggaWIgPVxuICBsZXQgcmVjIHNjYW5fZGlnaXRzIHdpZHRoIGliID1cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCBjIHdoZW4gZGlnaXRwIGMgLT5cbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcbiAgICB8ICdfJyAtPlxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIgaW5cbiAgICAgIHNjYW5fZGlnaXRzIHdpZHRoIGliXG4gICAgfCBfIC0+IHdpZHRoIGluXG4gIHNjYW5fZGlnaXRzIHdpZHRoIGliXG5cblxubGV0IHNjYW5fZGlnaXRfcGx1cyBiYXNpcyBkaWdpdHAgd2lkdGggaWIgPVxuICAoKiBFbnN1cmUgd2UgaGF2ZSBnb3QgZW5vdWdoIHdpZHRoIGxlZnQsXG4gICAgIGFuZCByZWFkIGF0IGxlYXN0IG9uZSBkaWdpdC4gKilcbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImRpZ2l0c1wiIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBpZiBkaWdpdHAgYyB0aGVuXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kaWdpdF9zdGFyIGRpZ2l0cCB3aWR0aCBpYlxuICBlbHNlXG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImNoYXJhY3RlciAlQyBpcyBub3QgYSB2YWxpZCAlcyBkaWdpdFwiIGMgYmFzaXMpXG5cblxubGV0IGlzX2JpbmFyeV9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICcxJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX2JpbmFyeV9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJiaW5hcnlcIiBpc19iaW5hcnlfZGlnaXRcblxubGV0IGlzX29jdGFsX2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzcnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5fb2N0YWxfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwib2N0YWxcIiBpc19vY3RhbF9kaWdpdFxuXG5sZXQgaXNfaGV4YV9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgfCAnQScgLi4gJ0YnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5faGV4YWRlY2ltYWxfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwiaGV4YWRlY2ltYWxcIiBpc19oZXhhX2RpZ2l0XG5cbigqIFNjYW4gYSBkZWNpbWFsIGludGVnZXIuICopXG5sZXQgc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCA9IHNjYW5fZGVjaW1hbF9kaWdpdF9wbHVzXG5cbmxldCBzY2FuX3NpZ24gd2lkdGggaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcrJyAtPiBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGNcbiAgfCAnLScgLT4gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjXG4gIHwgXyAtPiB3aWR0aFxuXG5cbmxldCBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG4oKiBTY2FuIGFuIHVuc2lnbmVkIGludGVnZXIgdGhhdCBjb3VsZCBiZSBnaXZlbiBpbiBhbnkgKGNvbW1vbikgYmFzaXMuXG4gICBJZiBkaWdpdHMgYXJlIHByZWZpeGVkIGJ5IG9uZSBvZiAweCwgMFgsIDBvLCBvciAwYiwgdGhlIG51bWJlciBpc1xuICAgYXNzdW1lZCB0byBiZSB3cml0dGVuIHJlc3BlY3RpdmVseSBpbiBoZXhhZGVjaW1hbCwgaGV4YWRlY2ltYWwsXG4gICBvY3RhbCwgb3IgYmluYXJ5LiAqKVxubGV0IHNjYW5fdW5zaWduZWRfaW50IHdpZHRoIGliID1cbiAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgIGJlZ2luIG1hdGNoIGMgd2l0aFxuICAgIHwgJ3gnIHwgJ1gnIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCAnbycgLT4gc2Nhbl9vY3RhbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8ICdiJyAtPiBzY2FuX2JpbmFyeV9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8IF8gLT4gc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgZW5kXG4gIHwgXyAtPiBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG5cblxubGV0IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfaW50IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fdW5zaWduZWRfaW50IHdpZHRoIGliXG5cblxubGV0IHNjYW5faW50X2NvbnZlcnNpb24gY29udiB3aWR0aCBpYiA9XG4gIG1hdGNoIGNvbnYgd2l0aFxuICB8IEJfY29udmVyc2lvbiAtPiBzY2FuX2JpbmFyeV9pbnQgd2lkdGggaWJcbiAgfCBEX2NvbnZlcnNpb24gLT4gc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICB8IElfY29udmVyc2lvbiAtPiBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2ludCB3aWR0aCBpYlxuICB8IE9fY29udmVyc2lvbiAtPiBzY2FuX29jdGFsX2ludCB3aWR0aCBpYlxuICB8IFVfY29udmVyc2lvbiAtPiBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gIHwgWF9jb252ZXJzaW9uIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliXG5cblxuKCogU2Nhbm5pbmcgZmxvYXRpbmcgcG9pbnQgbnVtYmVycy4gKilcblxuKCogRnJhY3Rpb25hbCBwYXJ0IGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVkdWNlZCB0byAwIGRpZ2l0cy4gKilcbmxldCBzY2FuX2ZyYWN0aW9uYWxfcGFydCB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG4oKiBFeHAgcGFydCBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlZHVjZWQgdG8gMCBkaWdpdHMuICopXG5sZXQgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICdlJyB8ICdFJyBhcyBjIC0+XG4gICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG4oKiBTY2FuIHRoZSBpbnRlZ2VyIHBhcnQgb2YgYSBmbG9hdGluZyBwb2ludCBudW1iZXIsIChub3QgdXNpbmcgdGhlXG4gICBPQ2FtbCBsZXhpY2FsIGNvbnZlbnRpb24gc2luY2UgdGhlIGludGVnZXIgcGFydCBjYW4gYmUgZW1wdHkpOlxuICAgYW4gb3B0aW9uYWwgc2lnbiwgZm9sbG93ZWQgYnkgYSBwb3NzaWJseSBlbXB0eSBzZXF1ZW5jZSBvZiBkZWNpbWFsXG4gICBkaWdpdHMgKGUuZy4gLS4xKS4gKilcbmxldCBzY2FuX2ludGVnZXJfcGFydCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuXG5cbigqXG4gICBGb3IgdGhlIHRpbWUgYmVpbmcgd2UgaGF2ZSAoYXMgZm91bmQgaW4gc2NhbmYubWxpKTpcbiAgIHRoZSBmaWVsZCB3aWR0aCBpcyBjb21wb3NlZCBvZiBhbiBvcHRpb25hbCBpbnRlZ2VyIGxpdGVyYWxcbiAgIGluZGljYXRpbmcgdGhlIG1heGltYWwgd2lkdGggb2YgdGhlIHRva2VuIHRvIHJlYWQuXG4gICBVbmZvcnR1bmF0ZWx5LCB0aGUgdHlwZS1jaGVja2VyIGxldCB0aGUgdXNlciB3cml0ZSBhbiBvcHRpb25hbCBwcmVjaXNpb24sXG4gICBzaW5jZSB0aGlzIGlzIHZhbGlkIGZvciBwcmludGYgZm9ybWF0IHN0cmluZ3MuXG5cbiAgIFRodXMsIHRoZSBuZXh0IHN0ZXAgZm9yIFNjYW5mIGlzIHRvIHN1cHBvcnQgYSBmdWxsIHdpZHRoIGFuZCBwcmVjaXNpb25cbiAgIGluZGljYXRpb24sIG1vcmUgb3IgbGVzcyBzaW1pbGFyIHRvIHRoZSBvbmUgZm9yIHByaW50ZiwgcG9zc2libHkgZXh0ZW5kZWRcbiAgIHRvIHRoZSBzcGVjaWZpY2F0aW9uIG9mIGEgW21heCwgbWluXSByYW5nZSBmb3IgdGhlIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkXG4gICBmb3Igc3RyaW5ncy4gU29tZXRoaW5nIGxpa2UgdGhlIGZvbGxvd2luZyBzcGVjIGZvciBzY2FuZi5tbGk6XG5cbiAgIFRoZSBvcHRpb25hbCBbd2lkdGhdIGlzIGFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgbWF4aW1hbFxuICAgd2lkdGggb2YgdGhlIHRva2VuIHJlYWQuIEZvciBpbnN0YW5jZSwgWyU2ZF0gcmVhZHMgYW4gaW50ZWdlcixcbiAgIGhhdmluZyBhdCBtb3N0IDYgY2hhcmFjdGVycy5cblxuICAgVGhlIG9wdGlvbmFsIFtwcmVjaXNpb25dIGlzIGEgZG90IFsuXSBmb2xsb3dlZCBieSBhbiBpbnRlZ2VyOlxuXG4gICAtIGluIHRoZSBmbG9hdGluZyBwb2ludCBudW1iZXIgY29udmVyc2lvbnMgKFslZl0sIFslZV0sIFslZ10sIFslRl0sIFslRV0sXG4gICBhbmQgWyVGXSBjb252ZXJzaW9ucywgdGhlIFtwcmVjaXNpb25dIGluZGljYXRlcyB0aGUgbWF4aW11bSBudW1iZXIgb2ZcbiAgIGRpZ2l0cyB0aGF0IG1heSBmb2xsb3cgdGhlIGRlY2ltYWwgcG9pbnQuIEZvciBpbnN0YW5jZSwgWyUuNGZdIHJlYWRzIGFcbiAgIFtmbG9hdF0gd2l0aCBhdCBtb3N0IDQgZnJhY3Rpb25hbCBkaWdpdHMsXG5cbiAgIC0gaW4gdGhlIHN0cmluZyBjb252ZXJzaW9ucyAoWyVzXSwgWyVTXSwgWyVcXFsgcmFuZ2UgXFxdXSksIGFuZCBpbiB0aGVcbiAgIGludGVnZXIgbnVtYmVyIGNvbnZlcnNpb25zIChbJWldLCBbJWRdLCBbJXVdLCBbJXhdLCBbJW9dLCBhbmQgdGhlaXJcbiAgIFtpbnQzMl0sIFtpbnQ2NF0sIGFuZCBbbmF0aXZlX2ludF0gY29ycmVzcG9uZGVudCksIHRoZSBbcHJlY2lzaW9uXVxuICAgaW5kaWNhdGVzIHRoZSByZXF1aXJlZCBtaW5pbXVtIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLFxuXG4gICAtIG9uIGFsbCBvdGhlciBjb252ZXJzaW9ucywgdGhlIHdpZHRoIGFuZCBwcmVjaXNpb24gc3BlY2lmeSB0aGUgW21heCwgbWluXVxuICAgcmFuZ2UgZm9yIHRoZSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZC5cbiopXG5sZXQgc2Nhbl9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX2ludGVnZXJfcGFydCB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCwgcHJlY2lzaW9uIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGgsIHByZWNpc2lvbiBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcuJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGxldCBwcmVjaXNpb24gPSBJbnQubWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgIGxldCB3aWR0aCA9IHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHByZWNpc2lvbiBpYikgaW5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIsIHByZWNpc2lvblxuICB8IF8gLT5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIsIHByZWNpc2lvblxuXG5cbmxldCBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBlcnJvciBzdHIgPVxuICBsZXQgbG93ZXJjYXNlIGMgPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJ0EnIC4uICdaJyAtPlxuICAgICAgY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKyBpbnRfb2ZfY2hhciAnYScpXG4gICAgfCBfIC0+IGMgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCB3aWR0aCA9IHJlZiB3aWR0aCBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgbG93ZXJjYXNlIGMgPD4gbG93ZXJjYXNlIHN0ci5baV0gdGhlbiBlcnJvciAoKTtcbiAgICBpZiAhd2lkdGggPSAwIHRoZW4gZXJyb3IgKCk7XG4gICAgd2lkdGggOj0gU2Nhbm5pbmcuc3RvcmVfY2hhciAhd2lkdGggaWIgYztcbiAgZG9uZTtcbiAgIXdpZHRoXG5cblxubGV0IHNjYW5faGV4X2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT4gKFxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGxldCB3aWR0aCA9IGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJ4XCIgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAnLicgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgfCBfIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgIHwgJy4nIGFzIGMgLT4gKFxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0gSW50Lm1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgICB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2hleGFkZWNpbWFsX2ludCBwcmVjaXNpb24gaWIpXG4gICAgICAgICAgKVxuICAgICAgICAgIHwgXyAtPiB3aWR0aCBpblxuICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgfCAncCcgfCAnUCcgYXMgYyAtPlxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgICAgICAgICB8IF8gLT4gd2lkdGhcbiAgKVxuICB8ICduJyB8ICdOJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcImFuXCJcbiAgfCAnaScgfCAnSScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJuZmluaXR5XCJcbiAgfCBfIC0+IGJhZF9oZXhfZmxvYXQgKClcblxuXG5sZXQgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgKCogVGhlIGVmZmVjdGl2ZSB3aWR0aCBhdmFpbGFibGUgZm9yIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgaXNcbiAgICAgICB0aGUgbWluaW11bSBvZiBkZWNsYXJlZCBwcmVjaXNpb24gYW5kIHdpZHRoIGxlZnQuICopXG4gICAgbGV0IHByZWNpc2lvbiA9IEludC5taW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgKCogQWZ0ZXIgc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCB3aXRoIFtwcmVjaXNpb25dIHByb3Zpc2lvbmFsIHdpZHRoLFxuICAgICAgIFt3aWR0aF9wcmVjaXNpb25dIGlzIGxlZnQuICopXG4gICAgbGV0IHdpZHRoX3ByZWNpc2lvbiA9IHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHByZWNpc2lvbiBpYiBpblxuICAgICgqIEhlbmNlLCBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IHRvb2sgZXhhY3RseVxuICAgICAgIFtwcmVjaXNpb24gLSB3aWR0aF9wcmVjaXNpb25dIGNoYXJzLiAqKVxuICAgIGxldCBmcmFjX3dpZHRoID0gcHJlY2lzaW9uIC0gd2lkdGhfcHJlY2lzaW9uIGluXG4gICAgKCogQW5kIG5ldyBwcm92aXNpb25hbCB3aWR0aCBpcyBbd2lkdGggLSB3aWR0aF9wcmVjaXNpb24uICopXG4gICAgbGV0IHdpZHRoID0gd2lkdGggLSBmcmFjX3dpZHRoIGluXG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliXG4gIHwgJ2UnIHwgJ0UnIC0+XG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliXG4gIHwgXyAtPiBiYWRfZmxvYXQgKClcblxuXG5sZXQgc2Nhbl9jYW1sX2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+IChcbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAneCcgfCAnWCcgYXMgYyAtPiAoXG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgICBsZXQgd2lkdGggPSBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYiBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJy4nIGFzIGMgLT4gKFxuICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0gSW50Lm1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgcHJlY2lzaW9uIGliKVxuICAgICAgICApXG4gICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBiYWRfZmxvYXQgKCkgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJ3AnIHwgJ1AnIGFzIGMgLT5cbiAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gICAgICAgIHwgXyAtPiB3aWR0aFxuICAgIClcbiAgICB8IF8gLT5cbiAgICAgIHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYlxuICApXG4gIHwgJzEnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbigqIFNwZWNpYWwgY2FzZSBvZiBuYW4gYW5kIGluZmluaXR5OlxuICB8ICdpJyAtPlxuICB8ICduJyAtPlxuKilcbiAgfCBfIC0+IGJhZF9mbG9hdCAoKVxuXG5cbigqIFNjYW4gYSByZWd1bGFyIHN0cmluZzpcbiAgIHN0b3BzIHdoZW4gZW5jb3VudGVyaW5nIGEgc3BhY2UsIGlmIG5vIHNjYW5uaW5nIGluZGljYXRpb24gaGFzIGJlZW4gZ2l2ZW47XG4gICBvdGhlcndpc2UsIHN0b3BzIHdoZW4gZW5jb3VudGVyaW5nIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBzY2FubmluZ1xuICAgaW5kaWNhdGlvbiBbc3RwXS5cbiAgIEl0IGFsc28gc3RvcHMgYXQgZW5kIG9mIGZpbGUgb3Igd2hlbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBoYXNcbiAgIGJlZW4gcmVhZC4gKilcbmxldCBzY2FuX3N0cmluZyBzdHAgd2lkdGggaWIgPVxuICBsZXQgcmVjIGxvb3Agd2lkdGggPVxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIG1hdGNoIHN0cCB3aXRoXG4gICAgICB8IFNvbWUgYycgd2hlbiBjID0gYycgLT4gU2Nhbm5pbmcuc2tpcF9jaGFyIHdpZHRoIGliXG4gICAgICB8IFNvbWUgXyAtPiBsb29wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBsb29wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGluXG4gIGxvb3Agd2lkdGhcblxuXG4oKiBTY2FuIGEgY2hhcjogcGVlayBzdHJpY3RseSBvbmUgY2hhcmFjdGVyIGluIHRoZSBpbnB1dCwgd2hhdHNvZXZlci4gKilcbmxldCBzY2FuX2NoYXIgd2lkdGggaWIgPVxuICAoKiBUaGUgY2FzZSB3aWR0aCA9IDAgY291bGQgbm90IGhhcHBlbiBoZXJlLCBzaW5jZSBpdCBpcyB0ZXN0ZWQgYmVmb3JlXG4gICAgIGNhbGxpbmcgc2Nhbl9jaGFyLCBpbiB0aGUgbWFpbiBzY2FubmluZyBmdW5jdGlvbi5cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiYSBjaGFyYWN0ZXJcIiBlbHNlICopXG4gIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliKVxuXG5cbmxldCBjaGFyX2Zvcl9iYWNrc2xhc2ggPSBmdW5jdGlvblxuICB8ICduJyAtPiAnXFwwMTAnXG4gIHwgJ3InIC0+ICdcXDAxMydcbiAgfCAnYicgLT4gJ1xcMDA4J1xuICB8ICd0JyAtPiAnXFwwMDknXG4gIHwgYyAtPiBjXG5cblxuKCogVGhlIGludGVnZXIgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZmFjaWFsIHZhbHVlIG9mIGEgdmFsaWRcbiAgIGRlY2ltYWwgZGlnaXQgY2hhcmFjdGVyLiAqKVxubGV0IGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID0gaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJ1xuXG5sZXQgY2hhcl9mb3JfZGVjaW1hbF9jb2RlIGMwIGMxIGMyID1cbiAgbGV0IGMgPVxuICAgIDEwMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMCArXG4gICAgIDEwICogZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMxICtcbiAgICAgICAgICBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzIgaW5cbiAgaWYgYyA8IDAgfHwgYyA+IDI1NSB0aGVuXG4gICAgYmFkX2lucHV0XG4gICAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICAgIFwiYmFkIGNoYXJhY3RlciBkZWNpbWFsIGVuY29kaW5nIFxcXFwlYyVjJWNcIiBjMCBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogVGhlIGludGVnZXIgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZmFjaWFsIHZhbHVlIG9mIGEgdmFsaWRcbiAgIGhleGFkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMgPVxuICBsZXQgZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgKCogQ291bGQgYWxzbyBiZTpcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICc5JyB0aGVuIGQgLSBpbnRfb2ZfY2hhciAnMCcgZWxzZVxuICAgIGlmIGQgPD0gaW50X29mX2NoYXIgJ0YnIHRoZW4gMTAgKyBkIC0gaW50X29mX2NoYXIgJ0EnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdmJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdhJyBlbHNlIGFzc2VydCBmYWxzZVxuICAqKVxuICBpZiBkID49IGludF9vZl9jaGFyICdhJyB0aGVuXG4gICAgZCAtIDg3ICgqIDEwICsgaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdhJyAqKSBlbHNlXG4gIGlmIGQgPj0gaW50X29mX2NoYXIgJ0EnIHRoZW5cbiAgICBkIC0gNTUgICgqIDEwICsgaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdBJyAqKSBlbHNlXG4gICAgZCAtIGludF9vZl9jaGFyICcwJ1xuXG5cbmxldCBjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyID1cbiAgbGV0IGMgPVxuICAgIDE2ICogaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmIFwiYmFkIGNoYXJhY3RlciBoZXhhZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlY1wiIGMxIGMyKSBlbHNlXG4gIGNoYXJfb2ZfaW50IGNcblxuXG4oKiBDYWxsZWQgaW4gcGFydGljdWxhciB3aGVuIGVuY291bnRlcmluZyAnXFxcXCcgYXMgc3RhcnRlciBvZiBhIGNoYXIuXG4gICBTdG9wcyBiZWZvcmUgdGhlIGNvcnJlc3BvbmRpbmcgJ1xcJycuICopXG5sZXQgY2hlY2tfbmV4dF9jaGFyIG1lc3NhZ2Ugd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIG1lc3NhZ2UgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiBiYWRfZW5kX29mX2lucHV0IG1lc3NhZ2UgZWxzZVxuICBjXG5cblxubGV0IGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciA9IGNoZWNrX25leHRfY2hhciBcImEgQ2hhclwiXG5sZXQgY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgPSBjaGVja19uZXh0X2NoYXIgXCJhIFN0cmluZ1wiXG5cbmxldCBzY2FuX2JhY2tzbGFzaF9jaGFyIHdpZHRoIGliID1cbiAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgfCAnXFxcXCcgfCAnXFwnJyB8ICdcXFwiJyB8ICduJyB8ICd0JyB8ICdiJyB8ICdyJyBhcyBjIC0+XG4gICAgU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAoY2hhcl9mb3JfYmFja3NsYXNoIGMpXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgYXMgYyAtPiBjXG4gICAgICB8IGMgLT4gYmFkX2lucHV0X2VzY2FwZSBjIGluXG4gICAgbGV0IGMwID0gYyBpblxuICAgIGxldCBjMSA9IGdldF9kaWdpdCAoKSBpblxuICAgIGxldCBjMiA9IGdldF9kaWdpdCAoKSBpblxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgKHdpZHRoIC0gMikgaWIgKGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMilcbiAgfCAneCcgLT5cbiAgICBsZXQgZ2V0X2RpZ2l0ICgpID1cbiAgICAgIGxldCBjID0gU2Nhbm5pbmcubmV4dF9jaGFyIGliIGluXG4gICAgICBtYXRjaCBjIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyB8ICdBJyAuLiAnRicgfCAnYScgLi4gJ2YnIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMSA9IGdldF9kaWdpdCAoKSBpblxuICAgIGxldCBjMiA9IGdldF9kaWdpdCAoKSBpblxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgKHdpZHRoIC0gMikgaWIgKGNoYXJfZm9yX2hleGFkZWNpbWFsX2NvZGUgYzEgYzIpXG4gIHwgYyAtPlxuICAgIGJhZF9pbnB1dF9lc2NhcGUgY1xuXG5cbigqIFNjYW4gYSBjaGFyYWN0ZXIgKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2NhbWxfY2hhciB3aWR0aCBpYiA9XG5cbiAgbGV0IHJlYyBmaW5kX3N0YXJ0IHdpZHRoID1cbiAgICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBmaW5kX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgY1xuXG4gIGFuZCBmaW5kX2NoYXIgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxcXCcgLT5cbiAgICAgIGZpbmRfc3RvcCAoc2Nhbl9iYWNrc2xhc2hfY2hhciAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpIGliKVxuICAgIHwgYyAtPlxuICAgICAgZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIGZpbmRfc3RvcCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXCcnIC0+IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFwnJyBjIGluXG5cbiAgZmluZF9zdGFydCB3aWR0aFxuXG5cbigqIFNjYW4gYSBkZWxpbWl0ZWQgc3RyaW5nIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX3N0cmluZyB3aWR0aCBpYiA9XG5cbiAgbGV0IHJlYyBmaW5kX3N0YXJ0IHdpZHRoID1cbiAgICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAnXFxcIicgLT4gZmluZF9zdG9wIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXFwiJyBjXG5cbiAgYW5kIGZpbmRfc3RvcCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliXG4gICAgfCAnXFxcXCcgLT4gc2Nhbl9iYWNrc2xhc2ggKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYylcblxuICBhbmQgc2Nhbl9iYWNrc2xhc2ggd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXHInIC0+IHNraXBfbmV3bGluZSAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCAnXFxuJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCAoc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYilcblxuICBhbmQgc2tpcF9uZXdsaW5lIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxuJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAnXFxyJylcblxuICBhbmQgc2tpcF9zcGFjZXMgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICcgJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCB3aWR0aCBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgYm9vbGVhbiAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fYm9vbCBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbGV0IG0gPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJ3QnIC0+IDRcbiAgICB8ICdmJyAtPiA1XG4gICAgfCBjIC0+XG4gICAgICBiYWRfaW5wdXRcbiAgICAgICAgKFByaW50Zi5zcHJpbnRmIFwidGhlIGNoYXJhY3RlciAlQyBjYW5ub3Qgc3RhcnQgYSBib29sZWFuXCIgYykgaW5cbiAgc2Nhbl9zdHJpbmcgTm9uZSBtIGliXG5cblxuKCogU2NhbiBhIHN0cmluZyBjb250YWluaW5nIGVsZW1lbnRzIGluIGNoYXJfc2V0IGFuZCB0ZXJtaW5hdGVkIGJ5IHNjYW5faW5kaWNcbiAgIGlmIHByb3ZpZGVkLiAqKVxubGV0IHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgc2Nhbl9pbmRpYyB3aWR0aCBpYiA9XG4gIGxldCByZWMgc2Nhbl9jaGFycyBpIHN0cCA9XG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBpID4gMCAmJiBub3QgKFNjYW5uaW5nLmVvZiBpYikgJiZcbiAgICAgICBpc19pbl9jaGFyX3NldCBjaGFyX3NldCBjICYmXG4gICAgICAgaW50X29mX2NoYXIgYyA8PiBzdHAgdGhlblxuICAgICAgbGV0IF8gPSBTY2FubmluZy5zdG9yZV9jaGFyIG1heF9pbnQgaWIgYyBpblxuICAgICAgc2Nhbl9jaGFycyAoaSAtIDEpIHN0cCBpblxuICBtYXRjaCBzY2FuX2luZGljIHdpdGhcbiAgfCBOb25lIC0+IHNjYW5fY2hhcnMgd2lkdGggKC0xKTtcbiAgfCBTb21lIGMgLT5cbiAgICBzY2FuX2NoYXJzIHdpZHRoIChpbnRfb2ZfY2hhciBjKTtcbiAgICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlblxuICAgICAgbGV0IGNpID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgICBpZiBjID0gY2lcbiAgICAgIHRoZW4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJcbiAgICAgIGVsc2UgY2hhcmFjdGVyX21pc21hdGNoIGMgY2lcblxuXG4oKiBUaGUgZ2xvYmFsIGVycm9yIHJlcG9ydCBmdW5jdGlvbiBmb3IgW1NjYW5mXS4gKilcbmxldCBzY2FuZl9iYWRfaW5wdXQgaWIgPSBmdW5jdGlvblxuICB8IFNjYW5fZmFpbHVyZSBzIHwgRmFpbHVyZSBzIC0+XG4gICAgbGV0IGkgPSBTY2FubmluZy5jaGFyX2NvdW50IGliIGluXG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcInNjYW5mOiBiYWQgaW5wdXQgYXQgY2hhciBudW1iZXIgJWk6ICVzXCIgaSBzKVxuICB8IHggLT4gcmFpc2UgeFxuXG5cbigqIEdldCB0aGUgY29udGVudCBvZiBhIGNvdW50ZXIgZnJvbSBhbiBpbnB1dCBidWZmZXIuICopXG5sZXQgZ2V0X2NvdW50ZXIgaWIgY291bnRlciA9XG4gIG1hdGNoIGNvdW50ZXIgd2l0aFxuICB8IExpbmVfY291bnRlciAtPiBTY2FubmluZy5saW5lX2NvdW50IGliXG4gIHwgQ2hhcl9jb3VudGVyIC0+IFNjYW5uaW5nLmNoYXJfY291bnQgaWJcbiAgfCBUb2tlbl9jb3VudGVyIC0+IFNjYW5uaW5nLnRva2VuX2NvdW50IGliXG5cblxuKCogQ29tcHV0ZSB0aGUgd2lkdGggb2YgYSBwYWRkaW5nIG9wdGlvbiAoc2VlIFwiJTQye1wiIGFuZCBcIiUxMjMoXCIpLiAqKVxubGV0IHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gbWF4X2ludFxuICB8IFNvbWUgd2lkdGggLT4gd2lkdGhcblxuXG5sZXQgc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmcgPVxuICBpZiBmbXRpbmcgPSBFc2NhcGVkX3BlcmNlbnQgdGhlbiAnJScsIFwiXCIgZWxzZVxuICAgIGxldCBzdHIgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nIGluXG4gICAgbGV0IHN0cCA9IHN0ci5bMV0gaW5cbiAgICBsZXQgc3ViX3N0ciA9IFN0cmluZy5zdWIgc3RyIDIgKFN0cmluZy5sZW5ndGggc3RyIC0gMikgaW5cbiAgICBzdHAsIHN1Yl9zdHJcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUmVhZGVyIG1hbmFnZW1lbnQgKilcblxuKCogQSBjYWxsIHRvIHRha2VfZm9ybWF0X3JlYWRlcnMgb24gYSBmb3JtYXQgaXMgZXZhbHVhdGVkIGludG8gZnVuY3Rpb25zXG4gICB0YWtpbmcgcmVhZGVycyBhcyBhcmd1bWVudHMgYW5kIGFnZ3JlZ2F0ZSB0aGVtIGludG8gYW4gaGV0ZXJvZ2VuZW91cyBsaXN0ICopXG4oKiBXaGVuIGFsbCByZWFkZXJzIGFyZSB0YWtlbiwgZmluYWxseSBwYXNzIHRoZSBsaXN0IG9mIHRoZSByZWFkZXJzIHRvIHRoZVxuICAgY29udGludWF0aW9uIGsuICopXG5sZXQgcmVjIHRha2VfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICBkID1cbmZ1biBrIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IFJlYWRlciBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0XG4gIHwgQ2hhciByZXN0ICAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDYW1sX2NoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFN0cmluZyAoXywgcmVzdCkgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9zdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEludDMyIChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgTmF0aXZlaW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQ2NCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsb2F0IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQm9vbCAoXywgcmVzdCkgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBBbHBoYSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFRoZXRhIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRmx1c2ggcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ3VzdG9tIChfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTY2FuX25leHRfY2hhciByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuXG4gIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10LCBfKSksIHJlc3QpIC0+XG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXQgZm10IHJlc3QpXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuXG4gIHwgRm9ybWF0X2FyZyAoXywgXywgcmVzdCkgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAgICAtPlxuICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpICAgICAgICAtPiB0YWtlX2lnbm9yZWRfZm9ybWF0X3JlYWRlcnMgayBpZ24gcmVzdFxuXG4gIHwgRW5kX29mX2Zvcm1hdCAgICAgICAgICAgICAgICAgICAgLT4gayBOaWxcblxuKCogVGFrZSByZWFkZXJzIGFzc29jaWF0ZWQgdG8gYW4gZm10dHkgY29taW5nIGZyb20gYSBGb3JtYXRfc3Vic3QgXCIlKC4uLiUpXCIuICopXG5hbmQgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBmbXR0eSAtPlxuICAgICAgKHksIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIHgsIGUsIGYpIGZtdCAtPiBkID1cbmZ1biBrIGZtdHR5IGZtdCAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgUmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdCBmbXRcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludF90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQzMl90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludDY0X3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGbG9hdF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQm9vbF90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFscGhhX3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBUaGV0YV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQW55X3R5IHJlc3QgICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEZvcm1hdF9hcmdfdHkgKF8sIHJlc3QpICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBFbmRfb2ZfZm10dHkgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogVGFrZSByZWFkZXJzIGFzc29jaWF0ZWQgdG8gYW4gaWdub3JlZCBwYXJhbWV0ZXIuICopXG5hbmQgdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSB4IHkgYSBjIGQgZSBmIC5cbiAgICAoKGQsIGUpIGhldGVyX2xpc3QgLT4gZSkgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIHgsIHkpIGlnbm9yZWQgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9yZWFkZXIgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayBmbXR0eSBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBzY2FubmluZyAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBzY2FubmluZyBmdW5jdGlvbi4gKilcbigqIFNjYW4gYSBzdHJlYW0gYWNjb3JkaW5nIHRvIGEgZm9ybWF0IGFuZCByZWFkZXJzIG9idGFpbmVkIGJ5XG4gICB0YWtlX2Zvcm1hdF9yZWFkZXJzLCBhbmQgYWdncmVnYXRlIHNjYW5uZWQgdmFsdWVzIGludG8gYW5cbiAgIGhldGVyb2dlbmVvdXMgbGlzdC4gKilcbigqIFJldHVybiB0aGUgaGV0ZXJvZ2VuZW91cyBsaXN0IG9mIHNjYW5uZWQgdmFsdWVzLiAqKVxubGV0IHJlYyBtYWtlX3NjYW5mIDogdHlwZSBhIGMgZCBlIGYuXG4gICAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoZCwgZSkgaGV0ZXJfbGlzdCAtPiAoYSwgZikgaGV0ZXJfbGlzdCA9XG5mdW4gaWIgZm10IHJlYWRlcnMgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBDaGFyIHJlc3QgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9jaGFyIDAgaWIgaW5cbiAgICBsZXQgYyA9IHRva2VuX2NoYXIgaWIgaW5cbiAgICBDb25zIChjLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcblxuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lIHN0cCkgd2lkdGggaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHN0cl9yZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgKFNvbWUgJ3snKSB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW5cbiAgICAgICAgICAgICAgICAgICB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICdbJykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIE5vbmUgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9jYW1sX3N0cmluZyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fc3RyaW5nXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQgYylcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50MzIgYylcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX25hdGl2ZWludCBjKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQ2NCBjKVxuICB8IEZsb2F0ICgoXywgKEZsb2F0X0YgfCBGbG9hdF9DRikpLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5fY2FtbF9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoXywgKEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HKSksXG4gICAgICAgICAgIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoXywgKEZsb2F0X2ggfCBGbG9hdF9IKSksIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9oZXhfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gXyBfIGliID0gc2Nhbl9ib29sIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9ib29sXG4gIHwgQWxwaGEgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlYVxcXCJcIlxuICB8IFRoZXRhIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJXRcXFwiXCJcbiAgfCBDdXN0b20gXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlP1xcXCIgKGN1c3RvbSBjb252ZXJ0ZXIpXCJcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBiZWdpbiBtYXRjaCByZWFkZXJzIHdpdGhcbiAgICB8IENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSAtPlxuICAgICAgICBsZXQgeCA9IHJlYWRlciBpYiBpblxuICAgICAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdF9yZXN0IHJlYWRlcnNfcmVzdClcbiAgICB8IE5pbCAtPlxuICAgICAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBtaXNzaW5nIHJlYWRlclwiXG4gICAgZW5kXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIGlmIFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gICAgZWxzZSBiYWRfaW5wdXQgXCJlbmQgb2YgaW5wdXQgbm90IGZvdW5kXCJcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIHN0cjtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgY2hyO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG5cbiAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgKHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCkgaWIgaW5cbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm10dHkgcyBmbXR0eVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChmbXQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nICh3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQpIGliIGluXG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10LCBmbXQnID1cbiAgICAgIHRyeVxuICAgICAgICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdCcgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgICgqIFRPRE86IGZpbmQgYSB3YXkgdG8gYXZvaWQgcmVwYXJzaW5nIHR3aWNlICopXG5cbiAgICAgICAgKCogVE9ETzogdGhlc2UgdHlwZS1jaGVja3MgYmVsb3cgKmNhbiogZmFpbCBiZWNhdXNlIG9mIHR5cGVcbiAgICAgICAgICAgYW1iaWd1aXR5IGluIHByZXNlbmNlIG9mIGlnbm9yZWQtcmVhZGVyczogXCIlX3IlZFwiIGFuZCBcIiVkJV9yXCJcbiAgICAgICAgICAgYXJlIHR5cGVkIGluIHRoZSBzYW1lIHdheS5cblxuICAgICAgICAgICAjIFNjYW5mLnNzY2FuZiBcIlxcXCIlX3IlZFxcXCIzXCIgXCIlKCVkJV9yJSlcIiBpZ25vcmVcbiAgICAgICAgICAgICAoZnVuIGZtdCBuIC0+IHN0cmluZ19vZl9mb3JtYXQgZm10LCBuKVxuICAgICAgICAgICBFeGNlcHRpb246IENhbWxpbnRlcm5hbEZvcm1hdC5UeXBlX21pc21hdGNoLlxuXG4gICAgICAgICAgIFdlIHNob3VsZCBwcm9wZXJseSBjYXRjaCB0aGlzIGV4Y2VwdGlvbi5cbiAgICAgICAgKilcbiAgICAgICAgdHlwZV9mb3JtYXQgZm10IChlcmFzZV9yZWwgZm10dHkpLFxuICAgICAgICB0eXBlX2Zvcm1hdCBmbXQnIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChGb3JtYXQgKGZtdCwgcyksXG4gICAgICAgICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHdpZHRoID0gd2lkdGhfb2ZfcGFkX29wdCB3aWR0aF9vcHQgaW5cbiAgICBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IChTb21lIHN0cCkgd2lkdGggaWI7XG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIENvbnMgKHMsIG1ha2Vfc2NhbmYgaWIgc3RyX3Jlc3QgcmVhZGVycylcbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIGxldCB3aWR0aCA9IHdpZHRoX29mX3BhZF9vcHQgd2lkdGhfb3B0IGluXG4gICAgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCBOb25lIHdpZHRoIGliO1xuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgQ29ucyAocywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICBsZXQgY291bnQgPSBnZXRfY291bnRlciBpYiBjb3VudGVyIGluXG4gICAgQ29ucyAoY291bnQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm9ybWF0dGluZ19saXQpO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliICdAJzsgY2hlY2tfY2hhciBpYiAneyc7XG4gICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnNcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgJ0AnOyBjaGVja19jaGFyIGliICdbJztcbiAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVyc1xuXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICBiZWdpbiBtYXRjaCBtYWtlX3NjYW5mIGliIGZtdCcgcmVhZGVycyB3aXRoXG4gICAgfCBDb25zIChfLCBhcmdfcmVzdCkgLT4gYXJnX3Jlc3RcbiAgICB8IE5pbCAtPiBhc3NlcnQgZmFsc2VcbiAgICBlbmRcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBOaWxcblxuKCogQ2FzZSBhbmFseXNpcyBvbiBwYWRkaW5nIGFuZCBwcmVjaXNpb24uICopXG4oKiBSZWplY3QgZm9ybWF0cyBjb250YWluaW5nIFwiJSpcIiBvciBcIiUuKlwiLiAqKVxuKCogUGFzcyBwYWRkaW5nIGFuZCBwcmVjaXNpb24gdG8gdGhlIGdlbmVyaWMgc2Nhbm5lciBgc2NhbicuICopXG5hbmQgcGFkX3ByZWNfc2NhbmYgOiB0eXBlIGEgYyBkIGUgZiB4IHkgeiB0IC5cbiAgICBTY2FubmluZy5pbl9jaGFubmVsIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChkLCBlKSBoZXRlcl9saXN0IC0+ICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPlxuICAgICAgKGludCAtPiBpbnQgLT4gU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiB0KSAtPlxuICAgICAgKFNjYW5uaW5nLmluX2NoYW5uZWwgLT4geikgLT5cbiAgICAgICh4LCBmKSBoZXRlcl9saXN0ID1cbmZ1biBpYiBmbXQgcmVhZGVycyBwYWQgcHJlYyBzY2FuIHRva2VuIC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIG1heF9pbnQgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGxldCBfID0gc2NhbiBtYXhfaW50IHAgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIHcgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBsZXQgXyA9IHNjYW4gdyBwIGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKExlZnQsIF8pLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUtXFxcIlwiXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgXyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcbiAgfCBBcmdfcGFkZGluZyBfLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgKCogRGVmaW5pbmcgW3NjYW5mXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtzY2FuZl0gKilcblxubGV0IGtzY2FuZl9nZW4gaWIgZWYgYWYgKEZvcm1hdCAoZm10LCBzdHIpKSA9XG4gIGxldCByZWMgYXBwbHkgOiB0eXBlIGEgYiAuIGEgLT4gKGEsIGIpIGhldGVyX2xpc3QgLT4gYiA9XG4gICAgZnVuIGYgYXJncyAtPiBtYXRjaCBhcmdzIHdpdGhcbiAgICB8IENvbnMgKHgsIHIpIC0+IGFwcGx5IChmIHgpIHJcbiAgICB8IE5pbCAtPiBmXG4gIGluXG4gIGxldCBrIHJlYWRlcnMgZiA9XG4gICAgU2Nhbm5pbmcucmVzZXRfdG9rZW4gaWI7XG4gICAgbWF0Y2ggbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycyB3aXRoXG4gICAgfCBleGNlcHRpb24gKFNjYW5fZmFpbHVyZSBfIHwgRmFpbHVyZSBfIHwgRW5kX29mX2ZpbGUgYXMgZXhjKSAtPlxuICAgICAgICBlZiBpYiBleGNcbiAgICB8IGV4Y2VwdGlvbiBJbnZhbGlkX2FyZ3VtZW50IG1zZyAtPlxuICAgICAgICBpbnZhbGlkX2FyZyAobXNnIF4gXCIgaW4gZm9ybWF0IFxcXCJcIiBeIFN0cmluZy5lc2NhcGVkIHN0ciBeIFwiXFxcIlwiKVxuICAgIHwgYXJncyAtPlxuICAgICAgICBhZiAoYXBwbHkgZiBhcmdzKVxuICBpblxuICB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG5cbmxldCBrc2NhbmYgaWIgZWYgZm10ID1cbiAga3NjYW5mX2dlbiBpYiBlZiAoZnVuIHggLT4geCkgZm10XG5cbmxldCBrc2NhbmZfb3B0IGliIGZtdCA9XG4gIGtzY2FuZl9nZW4gaWIgKGZ1biBfIF8gLT4gTm9uZSkgKGZ1biB4IC0+IFNvbWUgeCkgZm10XG5cbigqKiopXG5cbmxldCBrYnNjYW5mID0ga3NjYW5mXG5sZXQgYnNjYW5mIGliIGZtdCA9IGtic2NhbmYgaWIgc2NhbmZfYmFkX2lucHV0IGZtdFxubGV0IGJzY2FuZl9vcHQgaWIgZm10ID0ga3NjYW5mX29wdCBpYiBmbXRcblxubGV0IGtzc2NhbmYgcyBlZiBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBlZiBmbXRcbmxldCBzc2NhbmYgcyBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBzY2FuZl9iYWRfaW5wdXQgZm10XG5sZXQgc3NjYW5mX29wdCBzIGZtdCA9IGtzY2FuZl9vcHQgKFNjYW5uaW5nLmZyb21fc3RyaW5nIHMpIGZtdFxuXG5sZXQgc2NhbmYgZm10ID0ga3NjYW5mIFNjYW5uaW5nLnN0ZGluIHNjYW5mX2JhZF9pbnB1dCBmbXRcbmxldCBzY2FuZl9vcHQgZm10ID0ga3NjYW5mX29wdCBTY2FubmluZy5zdGRpbiBmbXRcblxuKCoqKilcblxuKCogU2Nhbm5pbmcgZm9ybWF0IHN0cmluZ3MuICopXG5sZXQgYnNjYW5mX2Zvcm1hdCA6XG4gIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAgKCgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICdnKSAtPiAnZyA9XG4gIGZ1biBpYiBmb3JtYXQgZiAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyBtYXhfaW50IGliIGluXG4gICAgbGV0IHN0ciA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQnID1cbiAgICAgIHRyeSBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgZm9ybWF0XG4gICAgICB3aXRoIEZhaWx1cmUgbXNnIC0+IGJhZF9pbnB1dCBtc2cgaW5cbiAgICBmIGZtdCdcblxuXG5sZXQgc3NjYW5mX2Zvcm1hdCA6XG4gIHN0cmluZyAtPiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gJ2cpIC0+ICdnID1cbiAgZnVuIHMgZm9ybWF0IGYgLT4gYnNjYW5mX2Zvcm1hdCAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgZm9ybWF0IGZcblxuXG5sZXQgZm9ybWF0X2Zyb21fc3RyaW5nIHMgZm10ID1cbiAgc3NjYW5mX2Zvcm1hdCAoXCJcXFwiXCIgXiBTdHJpbmcuZXNjYXBlZCBzIF4gXCJcXFwiXCIpIGZtdCAoZnVuIHggLT4geClcblxuXG5sZXQgdW5lc2NhcGVkIHMgPVxuICBzc2NhbmYgKFwiXFxcIlwiIF4gcyBeIFwiXFxcIlwiKSBcIiVTJSFcIiAoZnVuIHggLT4geClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUmVnaXN0ZXJpbmcgT0NhbWwgdmFsdWVzIHdpdGggdGhlIEMgcnVudGltZSBmb3IgbGF0ZXIgY2FsbGJhY2tzICopXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+IE9iai50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0IHJlZ2lzdGVyIG5hbWUgdiA9XG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIG5hbWUgKE9iai5yZXByIHYpXG5cbmxldCByZWdpc3Rlcl9leGNlcHRpb24gbmFtZSAoZXhuIDogZXhuKSA9XG4gIGxldCBleG4gPSBPYmoucmVwciBleG4gaW5cbiAgbGV0IHNsb3QgPSBpZiBPYmoudGFnIGV4biA9IE9iai5vYmplY3RfdGFnIHRoZW4gZXhuIGVsc2UgT2JqLmZpZWxkIGV4biAwIGluXG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIG5hbWUgc2xvdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgSmVyb21lIFZvdWlsbG9uLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIE9ialxuXG4oKioqKiBPYmplY3QgcmVwcmVzZW50YXRpb24gKioqKilcblxuZXh0ZXJuYWwgc2V0X2lkOiAnYSAtPiAnYSA9IFwiY2FtbF9zZXRfb29faWRcIiBbQEBub2FsbG9jXVxuXG4oKioqKiBPYmplY3QgY29weSAqKioqKVxuXG5sZXQgY29weSBvID1cbiAgbGV0IG8gPSAoT2JqLm9iaiAoT2JqLmR1cCAoT2JqLnJlcHIgbykpKSBpblxuICBzZXRfaWQgb1xuXG4oKioqKiBDb21wcmVzc2lvbiBvcHRpb25zICoqKiopXG4oKiBQYXJhbWV0ZXJzICopXG50eXBlIHBhcmFtcyA9IHtcbiAgICBtdXRhYmxlIGNvbXBhY3RfdGFibGUgOiBib29sO1xuICAgIG11dGFibGUgY29weV9wYXJlbnQgOiBib29sO1xuICAgIG11dGFibGUgY2xlYW5fd2hlbl9jb3B5aW5nIDogYm9vbDtcbiAgICBtdXRhYmxlIHJldHJ5X2NvdW50IDogaW50O1xuICAgIG11dGFibGUgYnVja2V0X3NtYWxsX3NpemUgOiBpbnRcbiAgfVxuXG5sZXQgcGFyYW1zID0ge1xuICBjb21wYWN0X3RhYmxlID0gdHJ1ZTtcbiAgY29weV9wYXJlbnQgPSB0cnVlO1xuICBjbGVhbl93aGVuX2NvcHlpbmcgPSB0cnVlO1xuICByZXRyeV9jb3VudCA9IDM7XG4gIGJ1Y2tldF9zbWFsbF9zaXplID0gMTZcbn1cblxuKCoqKiogUGFyYW1ldGVycyAqKioqKVxuXG5sZXQgaW5pdGlhbF9vYmplY3Rfc2l6ZSA9IDJcblxuKCoqKiogSXRlbXMgKioqKilcblxudHlwZSBpdGVtID0gRHVtbXlBIHwgRHVtbXlCIHwgRHVtbXlDIG9mIGludFxubGV0IF8gPSBbRHVtbXlBOyBEdW1teUI7IER1bW15QyAwXSAoKiB0byBhdm9pZCB3YXJuaW5ncyAqKVxuXG5sZXQgZHVtbXlfaXRlbSA9IChtYWdpYyAoKSA6IGl0ZW0pXG5cbigqKioqIFR5cGVzICoqKiopXG5cbnR5cGUgdGFnXG50eXBlIGxhYmVsID0gaW50XG50eXBlIGNsb3N1cmUgPSBpdGVtXG50eXBlIHQgPSBEdW1teUEgfCBEdW1teUIgfCBEdW1teUMgb2YgaW50XG5sZXQgXyA9IFtEdW1teUE7IER1bW15QjsgRHVtbXlDIDBdICgqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5cbnR5cGUgb2JqID0gdCBhcnJheVxuZXh0ZXJuYWwgcmV0IDogKG9iaiAtPiAnYSkgLT4gY2xvc3VyZSA9IFwiJWlkZW50aXR5XCJcblxuKCoqKiogTGFiZWxzICoqKiopXG5cbmxldCBwdWJsaWNfbWV0aG9kX2xhYmVsIHMgOiB0YWcgPVxuICBsZXQgYWNjdSA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgYWNjdSA6PSAyMjMgKiAhYWNjdSArIENoYXIuY29kZSBzLltpXVxuICBkb25lO1xuICAoKiByZWR1Y2UgdG8gMzEgYml0cyAqKVxuICBhY2N1IDo9ICFhY2N1IGxhbmQgKDEgbHNsIDMxIC0gMSk7XG4gICgqIG1ha2UgaXQgc2lnbmVkIGZvciA2NCBiaXRzIGFyY2hpdGVjdHVyZXMgKilcbiAgbGV0IHRhZyA9IGlmICFhY2N1ID4gMHgzRkZGRkZGRiB0aGVuICFhY2N1IC0gKDEgbHNsIDMxKSBlbHNlICFhY2N1IGluXG4gICgqIFByaW50Zi5lcHJpbnRmIFwiJXMgPSAlZFxcblwiIHMgdGFnOyBmbHVzaCBzdGRlcnI7ICopXG4gIG1hZ2ljIHRhZ1xuXG4oKioqKiBTcGFyc2UgYXJyYXkgKioqKilcblxubW9kdWxlIFZhcnMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gc3RyaW5nIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIHZhcnMgPSBpbnQgVmFycy50XG5cbm1vZHVsZSBNZXRocyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBzdHJpbmcgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgbWV0aHMgPSBsYWJlbCBNZXRocy50XG5tb2R1bGUgTGFicyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBsYWJlbCBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSBsYWJzID0gYm9vbCBMYWJzLnRcblxuKCogVGhlIGNvbXBpbGVyIGFzc3VtZXMgdGhhdCB0aGUgZmlyc3QgZmllbGQgb2YgdGhpcyBzdHJ1Y3R1cmUgaXMgW3NpemVdLiAqKVxudHlwZSB0YWJsZSA9XG4geyBtdXRhYmxlIHNpemU6IGludDtcbiAgIG11dGFibGUgbWV0aG9kczogY2xvc3VyZSBhcnJheTtcbiAgIG11dGFibGUgbWV0aG9kc19ieV9uYW1lOiBtZXRocztcbiAgIG11dGFibGUgbWV0aG9kc19ieV9sYWJlbDogbGFicztcbiAgIG11dGFibGUgcHJldmlvdXNfc3RhdGVzOlxuICAgICAobWV0aHMgKiBsYWJzICogKGxhYmVsICogaXRlbSkgbGlzdCAqIHZhcnMgKlxuICAgICAgbGFiZWwgbGlzdCAqIHN0cmluZyBsaXN0KSBsaXN0O1xuICAgbXV0YWJsZSBoaWRkZW5fbWV0aHM6IChsYWJlbCAqIGl0ZW0pIGxpc3Q7XG4gICBtdXRhYmxlIHZhcnM6IHZhcnM7XG4gICBtdXRhYmxlIGluaXRpYWxpemVyczogKG9iaiAtPiB1bml0KSBsaXN0IH1cblxubGV0IGR1bW15X3RhYmxlID1cbiAgeyBtZXRob2RzID0gW3wgZHVtbXlfaXRlbSB8XTtcbiAgICBtZXRob2RzX2J5X25hbWUgPSBNZXRocy5lbXB0eTtcbiAgICBtZXRob2RzX2J5X2xhYmVsID0gTGFicy5lbXB0eTtcbiAgICBwcmV2aW91c19zdGF0ZXMgPSBbXTtcbiAgICBoaWRkZW5fbWV0aHMgPSBbXTtcbiAgICB2YXJzID0gVmFycy5lbXB0eTtcbiAgICBpbml0aWFsaXplcnMgPSBbXTtcbiAgICBzaXplID0gMCB9XG5cbmxldCB0YWJsZV9jb3VudCA9IHJlZiAwXG5cbigqIGR1bW15X21ldCBzaG91bGQgYmUgYSBwb2ludGVyLCBzbyB1c2UgYW4gYXRvbSAqKVxubGV0IGR1bW15X21ldCA6IGl0ZW0gPSBvYmogKE9iai5uZXdfYmxvY2sgMCAwKVxuKCogaWYgZGVidWdnaW5nIGlzIG5lZWRlZCwgdGhpcyBjb3VsZCBiZSBhIGdvb2QgaWRlYTogKilcbigqIGxldCBkdW1teV9tZXQgKCkgPSBmYWlsd2l0aCBcIlVuZGVmaW5lZCBtZXRob2RcIiAqKVxuXG5sZXQgcmVjIGZpdF9zaXplIG4gPVxuICBpZiBuIDw9IDIgdGhlbiBuIGVsc2VcbiAgZml0X3NpemUgKChuKzEpLzIpICogMlxuXG5sZXQgbmV3X3RhYmxlIHB1Yl9sYWJlbHMgPVxuICBpbmNyIHRhYmxlX2NvdW50O1xuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIHB1Yl9sYWJlbHMgaW5cbiAgbGV0IG1ldGhvZHMgPSBBcnJheS5tYWtlIChsZW4qMisyKSBkdW1teV9tZXQgaW5cbiAgbWV0aG9kcy4oMCkgPC0gbWFnaWMgbGVuO1xuICBtZXRob2RzLigxKSA8LSBtYWdpYyAoZml0X3NpemUgbGVuICogU3lzLndvcmRfc2l6ZSAvIDggLSAxKTtcbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG8gbWV0aG9kcy4oaSoyKzMpIDwtIG1hZ2ljIHB1Yl9sYWJlbHMuKGkpIGRvbmU7XG4gIHsgbWV0aG9kcyA9IG1ldGhvZHM7XG4gICAgbWV0aG9kc19ieV9uYW1lID0gTWV0aHMuZW1wdHk7XG4gICAgbWV0aG9kc19ieV9sYWJlbCA9IExhYnMuZW1wdHk7XG4gICAgcHJldmlvdXNfc3RhdGVzID0gW107XG4gICAgaGlkZGVuX21ldGhzID0gW107XG4gICAgdmFycyA9IFZhcnMuZW1wdHk7XG4gICAgaW5pdGlhbGl6ZXJzID0gW107XG4gICAgc2l6ZSA9IGluaXRpYWxfb2JqZWN0X3NpemUgfVxuXG5sZXQgcmVzaXplIGFycmF5IG5ld19zaXplID1cbiAgbGV0IG9sZF9zaXplID0gQXJyYXkubGVuZ3RoIGFycmF5Lm1ldGhvZHMgaW5cbiAgaWYgbmV3X3NpemUgPiBvbGRfc2l6ZSB0aGVuIGJlZ2luXG4gICAgbGV0IG5ld19idWNrID0gQXJyYXkubWFrZSBuZXdfc2l6ZSBkdW1teV9tZXQgaW5cbiAgICBBcnJheS5ibGl0IGFycmF5Lm1ldGhvZHMgMCBuZXdfYnVjayAwIG9sZF9zaXplO1xuICAgIGFycmF5Lm1ldGhvZHMgPC0gbmV3X2J1Y2tcbiBlbmRcblxubGV0IHB1dCBhcnJheSBsYWJlbCBlbGVtZW50ID1cbiAgcmVzaXplIGFycmF5IChsYWJlbCArIDEpO1xuICBhcnJheS5tZXRob2RzLihsYWJlbCkgPC0gZWxlbWVudFxuXG4oKioqKiBDbGFzc2VzICoqKiopXG5cbmxldCBtZXRob2RfY291bnQgPSByZWYgMFxubGV0IGluc3RfdmFyX2NvdW50ID0gcmVmIDBcblxuKCogdHlwZSB0ICopXG50eXBlIG1ldGggPSBpdGVtXG5cbmxldCBuZXdfbWV0aG9kIHRhYmxlID1cbiAgbGV0IGluZGV4ID0gQXJyYXkubGVuZ3RoIHRhYmxlLm1ldGhvZHMgaW5cbiAgcmVzaXplIHRhYmxlIChpbmRleCArIDEpO1xuICBpbmRleFxuXG5sZXQgZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSBuYW1lID1cbiAgdHJ5XG4gICAgTWV0aHMuZmluZCBuYW1lIHRhYmxlLm1ldGhvZHNfYnlfbmFtZVxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGxldCBsYWJlbCA9IG5ld19tZXRob2QgdGFibGUgaW5cbiAgICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gTWV0aHMuYWRkIG5hbWUgbGFiZWwgdGFibGUubWV0aG9kc19ieV9uYW1lO1xuICAgIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gTGFicy5hZGQgbGFiZWwgdHJ1ZSB0YWJsZS5tZXRob2RzX2J5X2xhYmVsO1xuICAgIGxhYmVsXG5cbmxldCBnZXRfbWV0aG9kX2xhYmVscyB0YWJsZSBuYW1lcyA9XG4gIEFycmF5Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgbmFtZXNcblxubGV0IHNldF9tZXRob2QgdGFibGUgbGFiZWwgZWxlbWVudCA9XG4gIGluY3IgbWV0aG9kX2NvdW50O1xuICBpZiBMYWJzLmZpbmQgbGFiZWwgdGFibGUubWV0aG9kc19ieV9sYWJlbCB0aGVuXG4gICAgcHV0IHRhYmxlIGxhYmVsIGVsZW1lbnRcbiAgZWxzZVxuICAgIHRhYmxlLmhpZGRlbl9tZXRocyA8LSAobGFiZWwsIGVsZW1lbnQpIDo6IHRhYmxlLmhpZGRlbl9tZXRoc1xuXG5sZXQgZ2V0X21ldGhvZCB0YWJsZSBsYWJlbCA9XG4gIHRyeSBMaXN0LmFzc29jIGxhYmVsIHRhYmxlLmhpZGRlbl9tZXRoc1xuICB3aXRoIE5vdF9mb3VuZCAtPiB0YWJsZS5tZXRob2RzLihsYWJlbClcblxubGV0IHRvX2xpc3QgYXJyID1cbiAgaWYgYXJyID09IG1hZ2ljIDAgdGhlbiBbXSBlbHNlIEFycmF5LnRvX2xpc3QgYXJyXG5cbmxldCBuYXJyb3cgdGFibGUgdmFycyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzID1cbiAgbGV0IHZhcnMgPSB0b19saXN0IHZhcnNcbiAgYW5kIHZpcnRfbWV0aHMgPSB0b19saXN0IHZpcnRfbWV0aHNcbiAgYW5kIGNvbmNyX21ldGhzID0gdG9fbGlzdCBjb25jcl9tZXRocyBpblxuICBsZXQgdmlydF9tZXRoX2xhYnMgPSBMaXN0Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgdmlydF9tZXRocyBpblxuICBsZXQgY29uY3JfbWV0aF9sYWJzID0gTGlzdC5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIGNvbmNyX21ldGhzIGluXG4gIHRhYmxlLnByZXZpb3VzX3N0YXRlcyA8LVxuICAgICAodGFibGUubWV0aG9kc19ieV9uYW1lLCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsLCB0YWJsZS5oaWRkZW5fbWV0aHMsXG4gICAgICB0YWJsZS52YXJzLCB2aXJ0X21ldGhfbGFicywgdmFycylcbiAgICAgOjogdGFibGUucHJldmlvdXNfc3RhdGVzO1xuICB0YWJsZS52YXJzIDwtXG4gICAgVmFycy5mb2xkXG4gICAgICAoZnVuIGxhYiBpbmZvIHR2YXJzIC0+XG4gICAgICAgIGlmIExpc3QubWVtIGxhYiB2YXJzIHRoZW4gVmFycy5hZGQgbGFiIGluZm8gdHZhcnMgZWxzZSB0dmFycylcbiAgICAgIHRhYmxlLnZhcnMgVmFycy5lbXB0eTtcbiAgbGV0IGJ5X25hbWUgPSByZWYgTWV0aHMuZW1wdHkgaW5cbiAgbGV0IGJ5X2xhYmVsID0gcmVmIExhYnMuZW1wdHkgaW5cbiAgTGlzdC5pdGVyMlxuICAgIChmdW4gbWV0IGxhYmVsIC0+XG4gICAgICAgYnlfbmFtZSA6PSBNZXRocy5hZGQgbWV0IGxhYmVsICFieV9uYW1lO1xuICAgICAgIGJ5X2xhYmVsIDo9XG4gICAgICAgICAgTGFicy5hZGQgbGFiZWxcbiAgICAgICAgICAgICh0cnkgTGFicy5maW5kIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgd2l0aCBOb3RfZm91bmQgLT4gdHJ1ZSlcbiAgICAgICAgICAgICFieV9sYWJlbClcbiAgICBjb25jcl9tZXRocyBjb25jcl9tZXRoX2xhYnM7XG4gIExpc3QuaXRlcjJcbiAgICAoZnVuIG1ldCBsYWJlbCAtPlxuICAgICAgIGJ5X25hbWUgOj0gTWV0aHMuYWRkIG1ldCBsYWJlbCAhYnlfbmFtZTtcbiAgICAgICBieV9sYWJlbCA6PSBMYWJzLmFkZCBsYWJlbCBmYWxzZSAhYnlfbGFiZWwpXG4gICAgdmlydF9tZXRocyB2aXJ0X21ldGhfbGFicztcbiAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtICFieV9uYW1lO1xuICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtICFieV9sYWJlbDtcbiAgdGFibGUuaGlkZGVuX21ldGhzIDwtXG4gICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgIChmdW4gKChsYWIsIF8pIGFzIG1ldCkgaG0gLT5cbiAgICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmlydF9tZXRoX2xhYnMgdGhlbiBobSBlbHNlIG1ldDo6aG0pXG4gICAgICAgdGFibGUuaGlkZGVuX21ldGhzXG4gICAgICAgW11cblxubGV0IHdpZGVuIHRhYmxlID1cbiAgbGV0IChieV9uYW1lLCBieV9sYWJlbCwgc2F2ZWRfaGlkZGVuX21ldGhzLCBzYXZlZF92YXJzLCB2aXJ0X21ldGhzLCB2YXJzKSA9XG4gICAgTGlzdC5oZCB0YWJsZS5wcmV2aW91c19zdGF0ZXNcbiAgaW5cbiAgdGFibGUucHJldmlvdXNfc3RhdGVzIDwtIExpc3QudGwgdGFibGUucHJldmlvdXNfc3RhdGVzO1xuICB0YWJsZS52YXJzIDwtXG4gICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAgKGZ1biBzIHYgLT4gVmFycy5hZGQgdiAoVmFycy5maW5kIHYgdGFibGUudmFycykgcylcbiAgICAgICBzYXZlZF92YXJzIHZhcnM7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSBieV9uYW1lO1xuICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIGJ5X2xhYmVsO1xuICB0YWJsZS5oaWRkZW5fbWV0aHMgPC1cbiAgICAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgICAgKGZ1biAoKGxhYiwgXykgYXMgbWV0KSBobSAtPlxuICAgICAgICAgIGlmIExpc3QubWVtIGxhYiB2aXJ0X21ldGhzIHRoZW4gaG0gZWxzZSBtZXQ6OmhtKVxuICAgICAgIHRhYmxlLmhpZGRlbl9tZXRoc1xuICAgICAgIHNhdmVkX2hpZGRlbl9tZXRoc1xuXG5sZXQgbmV3X3Nsb3QgdGFibGUgPVxuICBsZXQgaW5kZXggPSB0YWJsZS5zaXplIGluXG4gIHRhYmxlLnNpemUgPC0gaW5kZXggKyAxO1xuICBpbmRleFxuXG5sZXQgbmV3X3ZhcmlhYmxlIHRhYmxlIG5hbWUgPVxuICB0cnkgVmFycy5maW5kIG5hbWUgdGFibGUudmFyc1xuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGxldCBpbmRleCA9IG5ld19zbG90IHRhYmxlIGluXG4gICAgaWYgbmFtZSA8PiBcIlwiIHRoZW4gdGFibGUudmFycyA8LSBWYXJzLmFkZCBuYW1lIGluZGV4IHRhYmxlLnZhcnM7XG4gICAgaW5kZXhcblxubGV0IHRvX2FycmF5IGFyciA9XG4gIGlmIGFyciA9IE9iai5tYWdpYyAwIHRoZW4gW3x8XSBlbHNlIGFyclxuXG5sZXQgbmV3X21ldGhvZHNfdmFyaWFibGVzIHRhYmxlIG1ldGhzIHZhbHMgPVxuICBsZXQgbWV0aHMgPSB0b19hcnJheSBtZXRocyBpblxuICBsZXQgbm1ldGhzID0gQXJyYXkubGVuZ3RoIG1ldGhzIGFuZCBudmFscyA9IEFycmF5Lmxlbmd0aCB2YWxzIGluXG4gIGxldCByZXMgPSBBcnJheS5tYWtlIChubWV0aHMgKyBudmFscykgMCBpblxuICBmb3IgaSA9IDAgdG8gbm1ldGhzIC0gMSBkb1xuICAgIHJlcy4oaSkgPC0gZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSBtZXRocy4oaSlcbiAgZG9uZTtcbiAgZm9yIGkgPSAwIHRvIG52YWxzIC0gMSBkb1xuICAgIHJlcy4oaStubWV0aHMpIDwtIG5ld192YXJpYWJsZSB0YWJsZSB2YWxzLihpKVxuICBkb25lO1xuICByZXNcblxubGV0IGdldF92YXJpYWJsZSB0YWJsZSBuYW1lID1cbiAgdHJ5IFZhcnMuZmluZCBuYW1lIHRhYmxlLnZhcnMgd2l0aCBOb3RfZm91bmQgLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBnZXRfdmFyaWFibGVzIHRhYmxlIG5hbWVzID1cbiAgQXJyYXkubWFwIChnZXRfdmFyaWFibGUgdGFibGUpIG5hbWVzXG5cbmxldCBhZGRfaW5pdGlhbGl6ZXIgdGFibGUgZiA9XG4gIHRhYmxlLmluaXRpYWxpemVycyA8LSBmOjp0YWJsZS5pbml0aWFsaXplcnNcblxuKCpcbm1vZHVsZSBLZXlzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHRhZyBhcnJheSBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxubGV0IGtleV9tYXAgPSByZWYgS2V5cy5lbXB0eVxubGV0IGdldF9rZXkgdGFncyA6IGl0ZW0gPVxuICB0cnkgbWFnaWMgKEtleXMuZmluZCB0YWdzICFrZXlfbWFwIDogdGFnIGFycmF5KVxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGtleV9tYXAgOj0gS2V5cy5hZGQgdGFncyB0YWdzICFrZXlfbWFwO1xuICAgIG1hZ2ljIHRhZ3NcbiopXG5cbmxldCBjcmVhdGVfdGFibGUgcHVibGljX21ldGhvZHMgPVxuICBpZiBwdWJsaWNfbWV0aG9kcyA9PSBtYWdpYyAwIHRoZW4gbmV3X3RhYmxlIFt8fF0gZWxzZVxuICAoKiBbcHVibGljX21ldGhvZHNdIG11c3QgYmUgaW4gYXNjZW5kaW5nIG9yZGVyIGZvciBieXRlY29kZSAqKVxuICBsZXQgdGFncyA9IEFycmF5Lm1hcCBwdWJsaWNfbWV0aG9kX2xhYmVsIHB1YmxpY19tZXRob2RzIGluXG4gIGxldCB0YWJsZSA9IG5ld190YWJsZSB0YWdzIGluXG4gIEFycmF5Lml0ZXJpXG4gICAgKGZ1biBpIG1ldCAtPlxuICAgICAgbGV0IGxhYiA9IGkqMisyIGluXG4gICAgICB0YWJsZS5tZXRob2RzX2J5X25hbWUgIDwtIE1ldGhzLmFkZCBtZXQgbGFiIHRhYmxlLm1ldGhvZHNfYnlfbmFtZTtcbiAgICAgIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gTGFicy5hZGQgbGFiIHRydWUgdGFibGUubWV0aG9kc19ieV9sYWJlbClcbiAgICBwdWJsaWNfbWV0aG9kcztcbiAgdGFibGVcblxubGV0IGluaXRfY2xhc3MgdGFibGUgPVxuICBpbnN0X3Zhcl9jb3VudCA6PSAhaW5zdF92YXJfY291bnQgKyB0YWJsZS5zaXplIC0gMTtcbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIExpc3QucmV2IHRhYmxlLmluaXRpYWxpemVycztcbiAgcmVzaXplIHRhYmxlICgzICsgbWFnaWMgdGFibGUubWV0aG9kcy4oMSkgKiAxNiAvIFN5cy53b3JkX3NpemUpXG5cbmxldCBpbmhlcml0cyBjbGEgdmFscyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzIChfLCBzdXBlciwgXywgZW52KSB0b3AgPVxuICBuYXJyb3cgY2xhIHZhbHMgdmlydF9tZXRocyBjb25jcl9tZXRocztcbiAgbGV0IGluaXQgPVxuICAgIGlmIHRvcCB0aGVuIHN1cGVyIGNsYSBlbnYgZWxzZSBPYmoucmVwciAoc3VwZXIgY2xhKSBpblxuICB3aWRlbiBjbGE7XG4gIEFycmF5LmNvbmNhdFxuICAgIFtbfCByZXByIGluaXQgfF07XG4gICAgIG1hZ2ljIChBcnJheS5tYXAgKGdldF92YXJpYWJsZSBjbGEpICh0b19hcnJheSB2YWxzKSA6IGludCBhcnJheSk7XG4gICAgIEFycmF5Lm1hcFxuICAgICAgIChmdW4gbm0gLT4gcmVwciAoZ2V0X21ldGhvZCBjbGEgKGdldF9tZXRob2RfbGFiZWwgY2xhIG5tKSA6IGNsb3N1cmUpKVxuICAgICAgICh0b19hcnJheSBjb25jcl9tZXRocykgXVxuXG5sZXQgbWFrZV9jbGFzcyBwdWJfbWV0aHMgY2xhc3NfaW5pdCA9XG4gIGxldCB0YWJsZSA9IGNyZWF0ZV90YWJsZSBwdWJfbWV0aHMgaW5cbiAgbGV0IGVudl9pbml0ID0gY2xhc3NfaW5pdCB0YWJsZSBpblxuICBpbml0X2NsYXNzIHRhYmxlO1xuICAoZW52X2luaXQgKE9iai5yZXByIDApLCBjbGFzc19pbml0LCBlbnZfaW5pdCwgT2JqLnJlcHIgMClcblxudHlwZSBpbml0X3RhYmxlID0geyBtdXRhYmxlIGVudl9pbml0OiB0OyBtdXRhYmxlIGNsYXNzX2luaXQ6IHRhYmxlIC0+IHQgfVxuW0BAd2FybmluZyBcIi11bnVzZWQtZmllbGRcIl1cblxubGV0IG1ha2VfY2xhc3Nfc3RvcmUgcHViX21ldGhzIGNsYXNzX2luaXQgaW5pdF90YWJsZSA9XG4gIGxldCB0YWJsZSA9IGNyZWF0ZV90YWJsZSBwdWJfbWV0aHMgaW5cbiAgbGV0IGVudl9pbml0ID0gY2xhc3NfaW5pdCB0YWJsZSBpblxuICBpbml0X2NsYXNzIHRhYmxlO1xuICBpbml0X3RhYmxlLmNsYXNzX2luaXQgPC0gY2xhc3NfaW5pdDtcbiAgaW5pdF90YWJsZS5lbnZfaW5pdCA8LSBlbnZfaW5pdFxuXG5sZXQgZHVtbXlfY2xhc3MgbG9jID1cbiAgbGV0IHVuZGVmID0gZnVuIF8gLT4gcmFpc2UgKFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlIGxvYykgaW5cbiAgKE9iai5tYWdpYyB1bmRlZiwgdW5kZWYsIHVuZGVmLCBPYmoucmVwciAwKVxuXG4oKioqKiBPYmplY3RzICoqKiopXG5cbmxldCBjcmVhdGVfb2JqZWN0IHRhYmxlID1cbiAgKCogWFhYIEFwcGVsIGRlIFtvYmpfYmxvY2tdIHwgQ2FsbCB0byBbb2JqX2Jsb2NrXSAgKilcbiAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAoKiBYWFggQXBwZWwgZGUgW2NhbWxfbW9kaWZ5XSB8IENhbGwgdG8gW2NhbWxfbW9kaWZ5XSAqKVxuICBPYmouc2V0X2ZpZWxkIG9iaiAwIChPYmoucmVwciB0YWJsZS5tZXRob2RzKTtcbiAgT2JqLm9iaiAoc2V0X2lkIG9iailcblxubGV0IGNyZWF0ZV9vYmplY3Rfb3B0IG9ial8wIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqXzAgZWxzZSBiZWdpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbb2JqX2Jsb2NrXSB8IENhbGwgdG8gW29ial9ibG9ja10gICopXG4gICAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbY2FtbF9tb2RpZnldIHwgQ2FsbCB0byBbY2FtbF9tb2RpZnldICopXG4gICAgT2JqLnNldF9maWVsZCBvYmogMCAoT2JqLnJlcHIgdGFibGUubWV0aG9kcyk7XG4gICAgT2JqLm9iaiAoc2V0X2lkIG9iailcbiAgZW5kXG5cbmxldCByZWMgaXRlcl9mIG9iaiA9XG4gIGZ1bmN0aW9uXG4gICAgW10gICAtPiAoKVxuICB8IGY6OmwgLT4gZiBvYmo7IGl0ZXJfZiBvYmogbFxuXG5sZXQgcnVuX2luaXRpYWxpemVycyBvYmogdGFibGUgPVxuICBsZXQgaW5pdHMgPSB0YWJsZS5pbml0aWFsaXplcnMgaW5cbiAgaWYgaW5pdHMgPD4gW10gdGhlblxuICAgIGl0ZXJfZiBvYmogaW5pdHNcblxubGV0IHJ1bl9pbml0aWFsaXplcnNfb3B0IG9ial8wIG9iaiB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9iaiBlbHNlIGJlZ2luXG4gICAgbGV0IGluaXRzID0gdGFibGUuaW5pdGlhbGl6ZXJzIGluXG4gICAgaWYgaW5pdHMgPD4gW10gdGhlbiBpdGVyX2Ygb2JqIGluaXRzO1xuICAgIG9ialxuICBlbmRcblxubGV0IGNyZWF0ZV9vYmplY3RfYW5kX3J1bl9pbml0aWFsaXplcnMgb2JqXzAgdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmpfMCBlbHNlIGJlZ2luXG4gICAgbGV0IG9iaiA9IGNyZWF0ZV9vYmplY3QgdGFibGUgaW5cbiAgICBydW5faW5pdGlhbGl6ZXJzIG9iaiB0YWJsZTtcbiAgICBvYmpcbiAgZW5kXG5cbigqIEVxdWl2YWxlbnQgcHJpbWl0aXZlIGJlbG93XG5sZXQgc2VuZHNlbGYgb2JqIGxhYiA9XG4gIChtYWdpYyBvYmogOiAob2JqIC0+IHQpIGFycmF5IGFycmF5KS4oMCkuKGxhYikgb2JqXG4qKVxuZXh0ZXJuYWwgc2VuZCA6IG9iaiAtPiB0YWcgLT4gJ2EgPSBcIiVzZW5kXCJcbmV4dGVybmFsIHNlbmRjYWNoZSA6IG9iaiAtPiB0YWcgLT4gdCAtPiBpbnQgLT4gJ2EgPSBcIiVzZW5kY2FjaGVcIlxuZXh0ZXJuYWwgc2VuZHNlbGYgOiBvYmogLT4gbGFiZWwgLT4gJ2EgPSBcIiVzZW5kc2VsZlwiXG5leHRlcm5hbCBnZXRfcHVibGljX21ldGhvZCA6IG9iaiAtPiB0YWcgLT4gY2xvc3VyZVxuICAgID0gXCJjYW1sX2dldF9wdWJsaWNfbWV0aG9kXCIgW0BAbm9hbGxvY11cblxuKCoqKiogdGFibGUgY29sbGVjdGlvbiBhY2Nlc3MgKioqKilcblxudHlwZSB0YWJsZXMgPVxuICB8IEVtcHR5XG4gIHwgQ29ucyBvZiB7a2V5IDogY2xvc3VyZTsgbXV0YWJsZSBkYXRhOiB0YWJsZXM7IG11dGFibGUgbmV4dDogdGFibGVzfVxuXG5sZXQgc2V0X2RhdGEgdGFibGVzIHYgPSBtYXRjaCB0YWJsZXMgd2l0aFxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5kYXRhIDwtIHZcbmxldCBzZXRfbmV4dCB0YWJsZXMgdiA9IG1hdGNoIHRhYmxlcyB3aXRoXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHQgPC0gdlxubGV0IGdldF9rZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5rZXlcbmxldCBnZXRfZGF0YSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmRhdGFcbmxldCBnZXRfbmV4dCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHRcblxubGV0IGJ1aWxkX3BhdGggbiBrZXlzIHRhYmxlcyA9XG4gIGxldCByZXMgPSBDb25zIHtrZXkgPSBPYmoubWFnaWMgMDsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gIGxldCByID0gcmVmIHJlcyBpblxuICBmb3IgaSA9IDAgdG8gbiBkb1xuICAgIHIgOj0gQ29ucyB7a2V5ID0ga2V5cy4oaSk7IGRhdGEgPSAhcjsgbmV4dCA9IEVtcHR5fVxuICBkb25lO1xuICBzZXRfZGF0YSB0YWJsZXMgIXI7XG4gIHJlc1xuXG5sZXQgcmVjIGxvb2t1cF9rZXlzIGkga2V5cyB0YWJsZXMgPVxuICBpZiBpIDwgMCB0aGVuIHRhYmxlcyBlbHNlXG4gIGxldCBrZXkgPSBrZXlzLihpKSBpblxuICBsZXQgcmVjIGxvb2t1cF9rZXkgKHRhYmxlczp0YWJsZXMpID1cbiAgICBpZiBnZXRfa2V5IHRhYmxlcyA9PSBrZXkgdGhlblxuICAgICAgbWF0Y2ggZ2V0X2RhdGEgdGFibGVzIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IENvbnMgXyBhcyB0YWJsZXNfZGF0YSAtPlxuICAgICAgICAgIGxvb2t1cF9rZXlzIChpLTEpIGtleXMgdGFibGVzX2RhdGFcbiAgICBlbHNlXG4gICAgICBtYXRjaCBnZXRfbmV4dCB0YWJsZXMgd2l0aFxuICAgICAgfCBDb25zIF8gYXMgbmV4dCAtPiBsb29rdXBfa2V5IG5leHRcbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBsZXQgbmV4dCA6IHRhYmxlcyA9IENvbnMge2tleTsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gICAgICAgICAgc2V0X25leHQgdGFibGVzIG5leHQ7XG4gICAgICAgICAgYnVpbGRfcGF0aCAoaS0xKSBrZXlzIG5leHRcbiAgaW5cbiAgbG9va3VwX2tleSB0YWJsZXNcblxubGV0IGxvb2t1cF90YWJsZXMgcm9vdCBrZXlzID1cbiAgbWF0Y2ggZ2V0X2RhdGEgcm9vdCB3aXRoXG4gIHwgQ29ucyBfIGFzIHJvb3RfZGF0YSAtPlxuICAgIGxvb2t1cF9rZXlzIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdF9kYXRhXG4gIHwgRW1wdHkgLT5cbiAgICBidWlsZF9wYXRoIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdFxuXG4oKioqKiBidWlsdGluIG1ldGhvZHMgKioqKilcblxubGV0IGdldF9jb25zdCB4ID0gcmV0IChmdW4gX29iaiAtPiB4KVxubGV0IGdldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIC0+IEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pXG5sZXQgZ2V0X2VudiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKVxubGV0IGdldF9tZXRoIG4gID0gcmV0IChmdW4gb2JqIC0+IHNlbmRzZWxmIG9iaiBuKVxubGV0IHNldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIHggLT4gQXJyYXkudW5zYWZlX3NldCBvYmogbiB4KVxubGV0IGFwcF9jb25zdCBmIHggPSByZXQgKGZ1biBfb2JqIC0+IGYgeClcbmxldCBhcHBfdmFyIGYgbiAgID0gcmV0IChmdW4gb2JqIC0+IGYgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9lbnYgZiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSlcbmxldCBhcHBfbWV0aCBmIG4gID0gcmV0IChmdW4gb2JqIC0+IGYgKHNlbmRzZWxmIG9iaiBuKSlcbmxldCBhcHBfY29uc3RfY29uc3QgZiB4IHkgPSByZXQgKGZ1biBfb2JqIC0+IGYgeCB5KVxubGV0IGFwcF9jb25zdF92YXIgZiB4IG4gICA9IHJldCAoZnVuIG9iaiAtPiBmIHggKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9jb25zdF9tZXRoIGYgeCBuID0gcmV0IChmdW4gb2JqIC0+IGYgeCAoc2VuZHNlbGYgb2JqIG4pKVxubGV0IGFwcF92YXJfY29uc3QgZiBuIHggPSByZXQgKGZ1biBvYmogLT4gZiAoQXJyYXkudW5zYWZlX2dldCBvYmogbikgeClcbmxldCBhcHBfbWV0aF9jb25zdCBmIG4geCA9IHJldCAoZnVuIG9iaiAtPiBmIChzZW5kc2VsZiBvYmogbikgeClcbmxldCBhcHBfY29uc3RfZW52IGYgeCBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIHggKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pKVxubGV0IGFwcF9lbnZfY29uc3QgZiBlIG4geCA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pIHgpXG5sZXQgbWV0aF9hcHBfY29uc3QgbiB4ID0gcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgeClcbmxldCBtZXRoX2FwcF92YXIgbiBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG0pKVxubGV0IG1ldGhfYXBwX2VudiBuIGUgbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pXG4gICAgICAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbSkpXG5sZXQgbWV0aF9hcHBfbWV0aCBuIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSAoc2VuZHNlbGYgb2JqIG0pKVxubGV0IHNlbmRfY29uc3QgbSB4IGMgPVxuICByZXQgKGZ1biBvYmogLT4gc2VuZGNhY2hlIHggbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX3ZhciBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSA6IG9iaikgbVxuICAgICAgKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF9lbnYgbSBlIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZVxuICAgICAgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldFxuICAgICAgICAgICAgICAgICAgICAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikgOiBvYmopXG4gICAgICBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfbWV0aCBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoc2VuZHNlbGYgb2JqIG4pIG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgbmV3X2NhY2hlIHRhYmxlID1cbiAgbGV0IG4gPSBuZXdfbWV0aG9kIHRhYmxlIGluXG4gIGxldCBuID1cbiAgICBpZiBuIG1vZCAyID0gMCB8fCBuID4gMiArIG1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplXG4gICAgdGhlbiBuIGVsc2UgbmV3X21ldGhvZCB0YWJsZVxuICBpblxuICB0YWJsZS5tZXRob2RzLihuKSA8LSBPYmoubWFnaWMgMDtcbiAgblxuXG50eXBlIGltcGwgPVxuICAgIEdldENvbnN0XG4gIHwgR2V0VmFyXG4gIHwgR2V0RW52XG4gIHwgR2V0TWV0aFxuICB8IFNldFZhclxuICB8IEFwcENvbnN0XG4gIHwgQXBwVmFyXG4gIHwgQXBwRW52XG4gIHwgQXBwTWV0aFxuICB8IEFwcENvbnN0Q29uc3RcbiAgfCBBcHBDb25zdFZhclxuICB8IEFwcENvbnN0RW52XG4gIHwgQXBwQ29uc3RNZXRoXG4gIHwgQXBwVmFyQ29uc3RcbiAgfCBBcHBFbnZDb25zdFxuICB8IEFwcE1ldGhDb25zdFxuICB8IE1ldGhBcHBDb25zdFxuICB8IE1ldGhBcHBWYXJcbiAgfCBNZXRoQXBwRW52XG4gIHwgTWV0aEFwcE1ldGhcbiAgfCBTZW5kQ29uc3RcbiAgfCBTZW5kVmFyXG4gIHwgU2VuZEVudlxuICB8IFNlbmRNZXRoXG4gIHwgQ2xvc3VyZSBvZiBjbG9zdXJlXG5cbmxldCBtZXRob2RfaW1wbCB0YWJsZSBpIGFyciA9XG4gIGxldCBuZXh0ICgpID0gaW5jciBpOyBtYWdpYyBhcnIuKCFpKSBpblxuICBtYXRjaCBuZXh0KCkgd2l0aFxuICAgIEdldENvbnN0IC0+IGxldCB4IDogdCA9IG5leHQoKSBpbiBnZXRfY29uc3QgeFxuICB8IEdldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIGdldF92YXIgblxuICB8IEdldEVudiAgIC0+IGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGdldF9lbnYgZSBuXG4gIHwgR2V0TWV0aCAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X21ldGggblxuICB8IFNldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIHNldF92YXIgblxuICB8IEFwcENvbnN0IC0+IGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGFwcF9jb25zdCBmIHhcbiAgfCBBcHBWYXIgICAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gYXBwX3ZhciBmIG5cbiAgfCBBcHBFbnYgICAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gIGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfZW52IGYgZSBuXG4gIHwgQXBwTWV0aCAgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIGFwcF9tZXRoIGYgblxuICB8IEFwcENvbnN0Q29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCB5ID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfY29uc3QgZiB4IHlcbiAgfCBBcHBDb25zdFZhciAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF92YXIgZiB4IG5cbiAgfCBBcHBDb25zdEVudiAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0ICgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfZW52IGYgeCBlIG5cbiAgfCBBcHBDb25zdE1ldGggLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfbWV0aCBmIHggblxuICB8IEFwcFZhckNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX3Zhcl9jb25zdCBmIG4geFxuICB8IEFwcEVudkNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQgKCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9lbnZfY29uc3QgZiBlIG4geFxuICB8IEFwcE1ldGhDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9tZXRoX2NvbnN0IGYgbiB4XG4gIHwgTWV0aEFwcENvbnN0IC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBtZXRoX2FwcF9jb25zdCBuIHhcbiAgfCBNZXRoQXBwVmFyIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF92YXIgbiBtXG4gIHwgTWV0aEFwcEVudiAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW5cbiAgICAgIG1ldGhfYXBwX2VudiBuIGUgbVxuICB8IE1ldGhBcHBNZXRoIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF9tZXRoIG4gbVxuICB8IFNlbmRDb25zdCAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gc2VuZF9jb25zdCBtIHggKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kVmFyIC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gc2VuZF92YXIgbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZEVudiAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIHNlbmRfZW52IG0gZSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZE1ldGggLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBzZW5kX21ldGggbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgQ2xvc3VyZSBfIGFzIGNsbyAtPiBtYWdpYyBjbG9cblxubGV0IHNldF9tZXRob2RzIHRhYmxlIG1ldGhvZHMgPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIG1ldGhvZHMgaW4gbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiBkb1xuICAgIGxldCBsYWJlbCA9IG1ldGhvZHMuKCFpKSBpbiBsZXQgY2xvID0gbWV0aG9kX2ltcGwgdGFibGUgaSBtZXRob2RzIGluXG4gICAgc2V0X21ldGhvZCB0YWJsZSBsYWJlbCBjbG87XG4gICAgaW5jciBpXG4gIGRvbmVcblxuKCoqKiogU3RhdGlzdGljcyAqKioqKVxuXG50eXBlIHN0YXRzID1cbiAgeyBjbGFzc2VzOiBpbnQ7IG1ldGhvZHM6IGludDsgaW5zdF92YXJzOiBpbnQ7IH1cblxubGV0IHN0YXRzICgpID1cbiAgeyBjbGFzc2VzID0gIXRhYmxlX2NvdW50O1xuICAgIG1ldGhvZHMgPSAhbWV0aG9kX2NvdW50OyBpbnN0X3ZhcnMgPSAhaW5zdF92YXJfY291bnQ7IH1cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBzaGFwZSA9XG4gIHwgRnVuY3Rpb25cbiAgfCBMYXp5XG4gIHwgQ2xhc3NcbiAgfCBNb2R1bGUgb2Ygc2hhcGUgYXJyYXlcbiAgfCBWYWx1ZSBvZiBPYmoudFxuXG5sZXQgcmVjIGluaXRfbW9kX2ZpZWxkIG1vZHUgaSBsb2Mgc2hhcGUgPVxuICBsZXQgaW5pdCA9XG4gICAgbWF0Y2ggc2hhcGUgd2l0aFxuICAgIHwgRnVuY3Rpb24gLT5cbiAgICAgICBsZXQgcmVjIGZuICh4IDogJ2EpID1cbiAgICAgICAgIGxldCBmbicgOiAnYSAtPiAnYiA9IE9iai5vYmogKE9iai5maWVsZCBtb2R1IGkpIGluXG4gICAgICAgICBpZiBmbiA9PSBmbicgdGhlblxuICAgICAgICAgICByYWlzZSAoVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgbG9jKVxuICAgICAgICAgZWxzZVxuICAgICAgICAgICBmbicgeCBpblxuICAgICAgIE9iai5yZXByIGZuXG4gICAgfCBMYXp5IC0+XG4gICAgICAgbGV0IHJlYyBsID1cbiAgICAgICAgIGxhenkgKFxuICAgICAgICAgICBsZXQgbCcgPSBPYmoub2JqIChPYmouZmllbGQgbW9kdSBpKSBpblxuICAgICAgICAgICBpZiBsID09IGwnIHRoZW5cbiAgICAgICAgICAgICByYWlzZSAoVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgbG9jKVxuICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgTGF6eS5mb3JjZSBsJykgaW5cbiAgICAgICBPYmoucmVwciBsXG4gICAgfCBDbGFzcyAtPlxuICAgICAgIE9iai5yZXByIChDYW1saW50ZXJuYWxPTy5kdW1teV9jbGFzcyBsb2MpXG4gICAgfCBNb2R1bGUgY29tcHMgLT5cbiAgICAgICBPYmoucmVwciAoaW5pdF9tb2RfYmxvY2sgbG9jIGNvbXBzKVxuICAgIHwgVmFsdWUgdiAtPiB2XG4gIGluXG4gIE9iai5zZXRfZmllbGQgbW9kdSBpIGluaXRcblxuYW5kIGluaXRfbW9kX2Jsb2NrIGxvYyBjb21wcyA9XG4gIGxldCBsZW5ndGggPSBBcnJheS5sZW5ndGggY29tcHMgaW5cbiAgbGV0IG1vZHUgPSBPYmoubmV3X2Jsb2NrIDAgbGVuZ3RoIGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggLSAxIGRvXG4gICAgaW5pdF9tb2RfZmllbGQgbW9kdSBpIGxvYyBjb21wcy4oaSlcbiAgZG9uZTtcbiAgbW9kdVxuXG5sZXQgaW5pdF9tb2QgbG9jIHNoYXBlID1cbiAgbWF0Y2ggc2hhcGUgd2l0aFxuICB8IE1vZHVsZSBjb21wcyAtPlxuICAgICBPYmoucmVwciAoaW5pdF9tb2RfYmxvY2sgbG9jIGNvbXBzKVxuICB8IF8gLT4gZmFpbHdpdGggXCJDYW1saW50ZXJuYWxNb2QuaW5pdF9tb2Q6IG5vdCBhIG1vZHVsZVwiXG5cbmxldCByZWMgdXBkYXRlX21vZF9maWVsZCBtb2R1IGkgc2hhcGUgbiA9XG4gIG1hdGNoIHNoYXBlIHdpdGhcbiAgfCBGdW5jdGlvbiB8IExhenkgLT5cbiAgICAgT2JqLnNldF9maWVsZCBtb2R1IGkgblxuICB8IFZhbHVlIF8gLT5cbiAgICAgKCkgKCogdGhlIHZhbHVlIGlzIGFscmVhZHkgdGhlcmUgKilcbiAgfCBDbGFzcyAtPlxuICAgICBhc3NlcnQgKE9iai50YWcgbiA9IDAgJiYgT2JqLnNpemUgbiA9IDQpO1xuICAgICBsZXQgY2wgPSBPYmouZmllbGQgbW9kdSBpIGluXG4gICAgIGZvciBqID0gMCB0byAzIGRvXG4gICAgICAgT2JqLnNldF9maWVsZCBjbCBqIChPYmouZmllbGQgbiBqKVxuICAgICBkb25lXG4gIHwgTW9kdWxlIGNvbXBzIC0+XG4gICAgIHVwZGF0ZV9tb2RfYmxvY2sgY29tcHMgKE9iai5maWVsZCBtb2R1IGkpIG5cblxuYW5kIHVwZGF0ZV9tb2RfYmxvY2sgY29tcHMgbyBuID1cbiAgYXNzZXJ0IChPYmoudGFnIG4gPSAwICYmIE9iai5zaXplIG4gPj0gQXJyYXkubGVuZ3RoIGNvbXBzKTtcbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBjb21wcyAtIDEgZG9cbiAgICB1cGRhdGVfbW9kX2ZpZWxkIG8gaSBjb21wcy4oaSkgKE9iai5maWVsZCBuIGkpXG4gIGRvbmVcblxubGV0IHVwZGF0ZV9tb2Qgc2hhcGUgbyBuID1cbiAgbWF0Y2ggc2hhcGUgd2l0aFxuICB8IE1vZHVsZSBjb21wcyAtPlxuICAgICB1cGRhdGVfbW9kX2Jsb2NrIGNvbXBzIG8gblxuICB8IF8gLT4gZmFpbHdpdGggXCJDYW1saW50ZXJuYWxNb2QudXBkYXRlX21vZDogbm90IGEgbW9kdWxlXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9IHNpZ1xuXG4gIHR5cGUga2V5XG4gIHR5cGUgISdhIHRcbiAgdmFsIGNyZWF0ZSA6ID9yYW5kb20gKCp0aHdhcnQgdG9vbHMvc3luY19zdGRsaWJfZG9jcyopIDogYm9vbCAtPiBpbnQgLT4gJ2EgdFxuICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgdmFsIHJlc2V0IDogJ2EgdCAtPiB1bml0XG4gIHZhbCBjb3B5IDogJ2EgdCAtPiAnYSB0XG4gIHZhbCBhZGQgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gIHZhbCByZW1vdmUgOiAnYSB0IC0+IGtleSAtPiB1bml0XG4gIHZhbCBmaW5kIDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgdmFsIGZpbmRfb3B0IDogJ2EgdCAtPiBrZXkgLT4gJ2Egb3B0aW9uXG4gIHZhbCBmaW5kX2FsbCA6ICdhIHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICB2YWwgc3RhdHMgOiAnYSB0IC0+IEhhc2h0Ymwuc3RhdGlzdGljc1xuICB2YWwgYWRkX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgdmFsIGNsZWFuOiAnYSB0IC0+IHVuaXRcbiAgdmFsIHN0YXRzX2FsaXZlOiAnYSB0IC0+IEhhc2h0Ymwuc3RhdGlzdGljc1xuICAgICgqKiBzYW1lIGFzIHshc3RhdHN9IGJ1dCBvbmx5IGNvdW50IHRoZSBhbGl2ZSBiaW5kaW5ncyAqKVxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcblxuICB0eXBlIGtleVxuICB0eXBlICEnYSB0XG4gIHZhbCBjcmVhdGUgOiBpbnQgLT4gJ2EgdFxuICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgdmFsIHJlc2V0IDogJ2EgdCAtPiB1bml0XG4gIHZhbCBjb3B5IDogJ2EgdCAtPiAnYSB0XG4gIHZhbCBhZGQgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gIHZhbCByZW1vdmUgOiAnYSB0IC0+IGtleSAtPiB1bml0XG4gIHZhbCBmaW5kIDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgdmFsIGZpbmRfb3B0IDogJ2EgdCAtPiBrZXkgLT4gJ2Egb3B0aW9uXG4gIHZhbCBmaW5kX2FsbCA6ICdhIHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICB2YWwgc3RhdHMgOiAnYSB0IC0+IEhhc2h0Ymwuc3RhdGlzdGljc1xuICB2YWwgYWRkX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgdmFsIGNsZWFuOiAnYSB0IC0+IHVuaXRcbiAgdmFsIHN0YXRzX2FsaXZlOiAnYSB0IC0+IEhhc2h0Ymwuc3RhdGlzdGljc1xuICAgICgqKiBzYW1lIGFzIHshc3RhdHN9IGJ1dCBvbmx5IGNvdW50IHRoZSBhbGl2ZSBiaW5kaW5ncyAqKVxuZW5kXG5cbm1vZHVsZSBHZW5IYXNoVGFibGUgPSBzdHJ1Y3RcblxuICB0eXBlIGVxdWFsID1cbiAgfCBFVHJ1ZSB8IEVGYWxzZVxuICB8IEVEZWFkICgqKiB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IgcmVjbGFpbWVkIHRoZSBkYXRhICopXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQoSDogc2lnXG4gICAgdHlwZSB0XG4gICAgdHlwZSAnYSBjb250YWluZXJcbiAgICB2YWwgY3JlYXRlOiB0IC0+ICdhIC0+ICdhIGNvbnRhaW5lclxuICAgIHZhbCBzZWVkZWRfaGFzaDogaW50IC0+IHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAnYSBjb250YWluZXIgLT4gdCAtPiBlcXVhbFxuICAgIHZhbCBnZXRfZGF0YTogJ2EgY29udGFpbmVyIC0+ICdhIG9wdGlvblxuICAgIHZhbCBzZXRfa2V5X2RhdGE6ICdhIGNvbnRhaW5lciAtPiB0IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgY2hlY2tfa2V5OiAnYSBjb250YWluZXIgLT4gYm9vbFxuICBlbmQpIDogU2VlZGVkUyB3aXRoIHR5cGUga2V5ID0gSC50XG4gID0gc3RydWN0XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyBtdXRhYmxlIHNpemU6IGludDsgICAgICAgICAgICAgICAgICAoKiBudW1iZXIgb2YgZW50cmllcyAqKVxuICAgICAgICBtdXRhYmxlIGRhdGE6ICdhIGJ1Y2tldGxpc3QgYXJyYXk7ICAoKiB0aGUgYnVja2V0cyAqKVxuICAgICAgICBzZWVkOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBmb3IgcmFuZG9taXphdGlvbiAqKVxuICAgICAgICBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgICAoKiBpbml0aWFsIGFycmF5IHNpemUgKilcbiAgICAgIH1cblxuICAgIGFuZCAnYSBidWNrZXRsaXN0ID1cbiAgICB8IEVtcHR5XG4gICAgfCBDb25zIG9mIGludCAoKiBoYXNoIG9mIHRoZSBrZXkgKikgKiAnYSBILmNvbnRhaW5lciAqICdhIGJ1Y2tldGxpc3RcblxuICAgICgqKiB0aGUgaGFzaCBvZiB0aGUga2V5IGlzIGtlcHQgaW4gb3JkZXIgdG8gdGVzdCB0aGUgZXF1YWxpdHkgb2YgdGhlIGhhc2hcbiAgICAgIGJlZm9yZSB0aGUga2V5LiBTYW1lIHJlYXNvbiBhcyBmb3IgV2Vhay5NYWtlICopXG5cbiAgICB0eXBlIGtleSA9IEgudFxuXG4gICAgbGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gICAgICBpZiB4ID49IG4gdGhlbiB4XG4gICAgICBlbHNlIGlmIHggKiAyID4gU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiB4XG4gICAgICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbiAgICBsZXQgcHJuZyA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCgpKVxuXG4gICAgbGV0IGNyZWF0ZSA/KHJhbmRvbSA9IChIYXNodGJsLmlzX3JhbmRvbWl6ZWQgKCkpKSBpbml0aWFsX3NpemUgPVxuICAgICAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IGluaXRpYWxfc2l6ZSBpblxuICAgICAgbGV0IHNlZWQgPSBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSBlbHNlIDAgaW5cbiAgICAgIHsgaW5pdGlhbF9zaXplID0gczsgc2l6ZSA9IDA7IHNlZWQgPSBzZWVkOyBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5IH1cblxuICAgIGxldCBjbGVhciBoID1cbiAgICAgIGguc2l6ZSA8LSAwO1xuICAgICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgICAgIGRvbmVcblxuICAgIGxldCByZXNldCBoID1cbiAgICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gICAgICBpZiBsZW4gPSBoLmluaXRpYWxfc2l6ZSB0aGVuXG4gICAgICAgIGNsZWFyIGhcbiAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgaC5zaXplIDwtIDA7XG4gICAgICAgIGguZGF0YSA8LSBBcnJheS5tYWtlIGguaW5pdGlhbF9zaXplIEVtcHR5XG4gICAgICBlbmRcblxuICAgIGxldCBjb3B5IGggPSB7IGggd2l0aCBkYXRhID0gQXJyYXkuY29weSBoLmRhdGEgfVxuXG4gICAgbGV0IGtleV9pbmRleCBoIGhrZXkgPVxuICAgICAgaGtleSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcblxuICAgIGxldCBjbGVhbiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgRW1wdHlcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIHdoZW4gbm90IChILmNoZWNrX2tleSBjKSAtPlxuICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICB8IENvbnMoaGtleSwgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIENvbnMoaGtleSwgYywgZG9fYnVja2V0IHJlc3QpXG4gICAgICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgZC4oaSkgPC0gZG9fYnVja2V0IGQuKGkpXG4gICAgICBkb25lXG5cbiAgICAoKiogcmVzaXplIGlzIHRoZSBvbmx5IGZ1bmN0aW9uIHRvIGRvIHRoZSBhY3R1YWwgY2xlYW5pbmcgb2YgZGVhZCBrZXlzXG4gICAgICAgIChyZW1vdmUgZG9lcyBpdCBqdXN0IGJlY2F1c2UgaXQgY291bGQpLlxuXG4gICAgICAgIFRoZSBnb2FsIGlzIHRvOlxuXG4gICAgICAgIC0gbm90IHJlc2l6ZSBpbmZpbml0ZWx5IHdoZW4gdGhlIGFjdHVhbCBudW1iZXIgb2YgYWxpdmUga2V5cyBpc1xuICAgICAgICBib3VuZGVkIGJ1dCBrZXlzIGFyZSBjb250aW51b3VzbHkgYWRkZWQuIFRoYXQgd291bGQgaGFwcGVuIGlmXG4gICAgICAgIHRoaXMgZnVuY3Rpb24gYWx3YXlzIHJlc2l6ZS5cbiAgICAgICAgLSBub3QgY2FsbCB0aGlzIGZ1bmN0aW9uIGFmdGVyIGVhY2ggYWRkaXRpb24sIHRoYXQgd291bGQgaGFwcGVuIGlmIHRoaXNcbiAgICAgICAgZnVuY3Rpb24gZG9uJ3QgcmVzaXplIGV2ZW4gd2hlbiBvbmx5IG9uZSBrZXkgaXMgZGVhZC5cblxuICAgICAgICBTbyB0aGUgYWxnb3JpdGhtOlxuICAgICAgICAtIGNsZWFuIHRoZSBrZXlzIGJlZm9yZSByZXNpemluZ1xuICAgICAgICAtIGlmIHRoZSBudW1iZXIgb2YgcmVtYWluaW5nIGtleXMgaXMgbGVzcyB0aGFuIGhhbGYgdGhlIHNpemUgb2YgdGhlXG4gICAgICAgIGFycmF5LCBkb24ndCByZXNpemUuXG4gICAgICAgIC0gaWYgaXQgaXMgbW9yZSwgcmVzaXplLlxuXG4gICAgICAgIFRoZSBzZWNvbmQgcHJvYmxlbSByZW1haW5zIGlmIHRoZSB0YWJsZSByZWFjaGVzIHshU3lzLm1heF9hcnJheV9sZW5ndGh9LlxuXG4gICAgKilcbiAgICBsZXQgcmVzaXplIGggPVxuICAgICAgbGV0IG9kYXRhID0gaC5kYXRhIGluXG4gICAgICBsZXQgb3NpemUgPSBBcnJheS5sZW5ndGggb2RhdGEgaW5cbiAgICAgIGxldCBuc2l6ZSA9IG9zaXplICogMiBpblxuICAgICAgY2xlYW4gaDtcbiAgICAgIGlmIG5zaXplIDwgU3lzLm1heF9hcnJheV9sZW5ndGggJiYgaC5zaXplID49IG9zaXplIGxzciAxIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IG5kYXRhID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICAgICAgICBoLmRhdGEgPC0gbmRhdGE7ICAgICAgICgqIHNvIHRoYXQga2V5X2luZGV4IHNlZXMgdGhlIG5ldyBidWNrZXQgY291bnQgKilcbiAgICAgICAgbGV0IHJlYyBpbnNlcnRfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICAgICAgfCBDb25zKGhrZXksIGRhdGEsIHJlc3QpIC0+XG4gICAgICAgICAgICAgIGluc2VydF9idWNrZXQgcmVzdDsgKCogcHJlc2VydmUgb3JpZ2luYWwgb3JkZXIgb2YgZWxlbWVudHMgKilcbiAgICAgICAgICAgICAgbGV0IG5pZHggPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICAgICAgICAgIG5kYXRhLihuaWR4KSA8LSBDb25zKGhrZXksIGRhdGEsIG5kYXRhLihuaWR4KSkgaW5cbiAgICAgICAgZm9yIGkgPSAwIHRvIG9zaXplIC0gMSBkb1xuICAgICAgICAgIGluc2VydF9idWNrZXQgb2RhdGEuKGkpXG4gICAgICAgIGRvbmVcbiAgICAgIGVuZFxuXG4gICAgbGV0IGFkZCBoIGtleSBpbmZvID1cbiAgICAgIGxldCBoa2V5ID0gSC5zZWVkZWRfaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGxldCBjb250YWluZXIgPSBILmNyZWF0ZSBrZXkgaW5mbyBpblxuICAgICAgbGV0IGJ1Y2tldCA9IENvbnMoaGtleSwgY29udGFpbmVyLCBoLmRhdGEuKGkpKSBpblxuICAgICAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUgaFxuXG4gICAgbGV0IHJlbW92ZSBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguc2VlZGVkX2hhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyByZW1vdmVfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgICB8IENvbnMoaGssIGMsIG5leHQpIHdoZW4gaGtleSA9IGhrIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICAgIHwgRVRydWUgLT4gaC5zaXplIDwtIGguc2l6ZSAtIDE7IG5leHRcbiAgICAgICAgICAgIHwgRUZhbHNlIC0+IENvbnMoaGssIGMsIHJlbW92ZV9idWNrZXQgbmV4dClcbiAgICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgICAoKiBUaGUgZGVhZCBrZXkgaXMgYXV0b21hdGljYWxseSByZW1vdmVkLiBJdCBpcyBhY2NlcHRhYmxlXG4gICAgICAgICAgICAgICAgICAgIGZvciB0aGlzIGZ1bmN0aW9uIHNpbmNlIGl0IGFscmVhZHkgcmVtb3ZlcyBhIGJpbmRpbmcgKilcbiAgICAgICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgICAgICByZW1vdmVfYnVja2V0IG5leHRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IENvbnMoaGssYyxuZXh0KSAtPiBDb25zKGhrLCBjLCByZW1vdmVfYnVja2V0IG5leHQpIGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gcmVtb3ZlX2J1Y2tldCBoLmRhdGEuKGkpXG5cbiAgICAoKiogeyFmaW5kfSBkb24ndCByZW1vdmUgZGVhZCBrZXlzIGJlY2F1c2UgaXQgd291bGQgYmUgc3VycHJpc2luZyBmb3JcbiAgICAgICAgdGhlIHVzZXIgdGhhdCBhIHJlYWQtb25seSBmdW5jdGlvbiBtdXRhdGVzIHRoZSBzdGF0ZSAoZWcuIGNvbmN1cnJlbnRcbiAgICAgICAgYWNjZXNzKS4gU2FtZSBmb3IgeyFtZW19LlxuICAgICopXG4gICAgbGV0IHJlYyBmaW5kX3JlYyBrZXkgaGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT5cbiAgICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAoKiBUaGlzIGNhc2UgaXMgbm90IGltcG9zc2libGUgYmVjYXVzZSB0aGUgZ2MgY2FuIHJ1biBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgICAgSC5lcXVhbCBhbmQgSC5nZXRfZGF0YSAqKVxuICAgICAgICAgICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgZCAtPiBkXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcblxuICAgIGxldCBmaW5kIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5zZWVkZWRfaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICAoKiBUT0RPIGlubGluZSAzIGl0ZXJhdGlvbnMgKilcbiAgICAgIGZpbmRfcmVjIGtleSBoa2V5IChoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpKVxuXG4gICAgbGV0IHJlYyBmaW5kX3JlY19vcHQga2V5IGhrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPlxuICAgICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICgqIFRoaXMgY2FzZSBpcyBub3QgaW1wb3NzaWJsZSBiZWNhdXNlIHRoZSBnYyBjYW4gcnVuIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICBILmVxdWFsIGFuZCBILmdldF9kYXRhICopXG4gICAgICAgICAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgXyBhcyBkIC0+IGRcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuXG4gICAgbGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5zZWVkZWRfaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICAoKiBUT0RPIGlubGluZSAzIGl0ZXJhdGlvbnMgKilcbiAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSAoaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KSlcblxuICAgIGxldCBmaW5kX2FsbCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguc2VlZGVkX2hhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IFtdXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT4gYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBkIC0+IGQ6OmZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3QgaW5cbiAgICAgIGZpbmRfaW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGggaGtleSlcblxuXG4gICAgbGV0IHJlcGxhY2UgaCBrZXkgaW5mbyA9XG4gICAgICBsZXQgaGtleSA9IEguc2VlZGVkX2hhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyByZXBsYWNlX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIHwgQ29ucyhoaywgYywgbmV4dCkgd2hlbiBoa2V5ID0gaGsgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgICAgfCBFVHJ1ZSAtPiBILnNldF9rZXlfZGF0YSBjIGtleSBpbmZvXG4gICAgICAgICAgICB8IEVGYWxzZSB8IEVEZWFkIC0+IHJlcGxhY2VfYnVja2V0IG5leHRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IENvbnMoXyxfLG5leHQpIC0+IHJlcGxhY2VfYnVja2V0IG5leHRcbiAgICAgIGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGxldCBsID0gaC5kYXRhLihpKSBpblxuICAgICAgdHJ5XG4gICAgICAgIHJlcGxhY2VfYnVja2V0IGxcbiAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgIGxldCBjb250YWluZXIgPSBILmNyZWF0ZSBrZXkgaW5mbyBpblxuICAgICAgICBoLmRhdGEuKGkpIDwtIENvbnMoaGtleSwgY29udGFpbmVyLCBsKTtcbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUgaFxuXG4gICAgbGV0IG1lbSBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguc2VlZGVkX2hhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrID0gaGtleSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT4gdHJ1ZVxuICAgICAgICAgIHwgRUZhbHNlIHwgRURlYWQgLT4gbWVtX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoX2hrLCBfYywgcmVzdCkgLT4gbWVtX2luX2J1Y2tldCByZXN0IGluXG4gICAgICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGggaGtleSlcblxuICAgIGxldCBsZW5ndGggaCA9IGguc2l6ZVxuXG4gICAgbGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT4gYnVja2V0X2xlbmd0aCAoYWNjdSArIDEpIHJlc3RcblxuICAgIGxldCBzdGF0cyBoID1cbiAgICAgIGxldCBtYmwgPVxuICAgICAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gSW50Lm1heCBtIChidWNrZXRfbGVuZ3RoIDAgYikpIDAgaC5kYXRhIGluXG4gICAgICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gICAgICBBcnJheS5pdGVyXG4gICAgICAgIChmdW4gYiAtPlxuICAgICAgICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGggMCBiIGluXG4gICAgICAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgICAgICBoLmRhdGE7XG4gICAgICB7IEhhc2h0YmwubnVtX2JpbmRpbmdzID0gaC5zaXplO1xuICAgICAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgICAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4gICAgbGV0IHJlYyBidWNrZXRfbGVuZ3RoX2FsaXZlIGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IENvbnMoXywgYywgcmVzdCkgd2hlbiBILmNoZWNrX2tleSBjIC0+XG4gICAgICAgICAgYnVja2V0X2xlbmd0aF9hbGl2ZSAoYWNjdSArIDEpIHJlc3RcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPiBidWNrZXRfbGVuZ3RoX2FsaXZlIGFjY3UgcmVzdFxuXG4gICAgbGV0IHN0YXRzX2FsaXZlIGggPVxuICAgICAgbGV0IHNpemUgPSByZWYgMCBpblxuICAgICAgbGV0IG1ibCA9XG4gICAgICAgIEFycmF5LmZvbGRfbGVmdFxuICAgICAgICAgIChmdW4gbSBiIC0+IEludC5tYXggbSAoYnVja2V0X2xlbmd0aF9hbGl2ZSAwIGIpKSAwIGguZGF0YVxuICAgICAgaW5cbiAgICAgIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgICAgIEFycmF5Lml0ZXJcbiAgICAgICAgKGZ1biBiIC0+XG4gICAgICAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aF9hbGl2ZSAwIGIgaW5cbiAgICAgICAgICAgc2l6ZSA6PSAhc2l6ZSArIGw7XG4gICAgICAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgICAgICBoLmRhdGE7XG4gICAgICB7IEhhc2h0YmwubnVtX2JpbmRpbmdzID0gIXNpemU7XG4gICAgICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICAgICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbiAgICBsZXQgYWRkX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IGFkZCB0YmwgayB2KSBpXG5cbiAgICBsZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiByZXBsYWNlIHRibCBrIHYpIGlcblxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBPYmpFcGggPSBPYmouRXBoZW1lcm9uXG5cbmxldCBfb2JqX29wdCA6IE9iai50IG9wdGlvbiAtPiAnYSBvcHRpb24gPSBmdW4geCAtPlxuICBtYXRjaCB4IHdpdGhcbiAgfCBOb25lIC0+IHhcbiAgfCBTb21lIHYgLT4gU29tZSAoT2JqLm9iaiB2KVxuXG4oKiogVGhlIHByZXZpb3VzIGZ1bmN0aW9uIGlzIHR5cGVkIHNvIHRoaXMgb25lIGlzIGFsc28gY29ycmVjdCAqKVxubGV0IG9ial9vcHQgOiBPYmoudCBvcHRpb24gLT4gJ2Egb3B0aW9uID0gZnVuIHggLT4gT2JqLm1hZ2ljIHhcblxuXG5tb2R1bGUgSzEgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgKCkgOiAoJ2ssJ2QpIHQgPSBPYmpFcGguY3JlYXRlIDFcblxuICBsZXQgZ2V0X2tleSAodDooJ2ssJ2QpIHQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAwKVxuICBsZXQgc2V0X2tleSAodDooJ2ssJ2QpIHQpIChrOidrKSA6IHVuaXQgPSBPYmpFcGguc2V0X2tleSB0IDAgKE9iai5yZXByIGspXG4gIGxldCBjaGVja19rZXkgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMFxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2ssJ2QpIHQpIChkOidkKSA6IHVuaXQgPSBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG5cbiAgbGV0IG1ha2Uga2V5IGRhdGEgPVxuICAgIGxldCBlcGggPSBjcmVhdGUgKCkgaW5cbiAgICBzZXRfZGF0YSBlcGggZGF0YTtcbiAgICBzZXRfa2V5IGVwaCBrZXk7XG4gICAgZXBoXG5cbiAgbGV0IHF1ZXJ5IGVwaCBrZXkgPVxuICAgIG1hdGNoIGdldF9rZXkgZXBoIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBrIHdoZW4gayA9PSBrZXkgLT4gZ2V0X2RhdGEgZXBoXG4gICAgfCBTb21lIF8gLT4gTm9uZVxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkIChIOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSC50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBILnRcbiAgICAgIGxldCBjcmVhdGUgayBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKCkgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBzZXRfa2V5IGMgaztcbiAgICAgICAgY1xuICAgICAgbGV0IHNlZWRlZF9oYXNoID0gSC5zZWVkZWRfaGFzaFxuICAgICAgbGV0IGVxdWFsIGMgayA9XG4gICAgICAgICgqIHshZ2V0X2tleV9jb3B5fSBpcyBub3QgdXNlZCBiZWNhdXNlIHRoZSBlcXVhbGl0eSBvZiB0aGUgdXNlciBjYW4gYmVcbiAgICAgICAgICAgIHRoZSBwaHlzaWNhbCBlcXVhbGl0eSAqKVxuICAgICAgICBtYXRjaCBnZXRfa2V5IGMgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgIHwgU29tZSBrJyAtPlxuICAgICAgICAgICAgaWYgSC5lcXVhbCBrIGsnIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyBrIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIHNldF9rZXkgYyBrO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgPSBjaGVja19rZXlcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDogSGFzaHRibC5IYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBzZWVkZWRfaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuXG4gIG1vZHVsZSBCdWNrZXQgPSBzdHJ1Y3RcblxuICAgIHR5cGUgbm9ucmVjICgnaywgJ2QpIHQgPSAoJ2ssICdkKSB0IGxpc3QgcmVmXG4gICAgbGV0IGsxX21ha2UgPSBtYWtlXG4gICAgbGV0IG1ha2UgKCkgPSByZWYgW11cbiAgICBsZXQgYWRkIGIgayBkID0gYiA6PSBrMV9tYWtlIGsgZCA6OiAhYlxuXG4gICAgbGV0IHRlc3Rfa2V5IGsgZSA9XG4gICAgICBtYXRjaCBnZXRfa2V5IGUgd2l0aFxuICAgICAgfCBTb21lIHggd2hlbiB4ID09IGsgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVtb3ZlIGIgayA9XG4gICAgICBsZXQgcmVjIGxvb3AgbCBhY2MgPVxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgfCBbXSAtPiAoKVxuICAgICAgICB8IGggOjogdCB3aGVuIHRlc3Rfa2V5IGsgaCAtPiBiIDo9IExpc3QucmV2X2FwcGVuZCBhY2MgdFxuICAgICAgICB8IGggOjogdCAtPiBsb29wIHQgKGggOjogYWNjKVxuICAgICAgaW5cbiAgICAgIGxvb3AgIWIgW11cblxuICAgIGxldCBmaW5kIGIgayA9XG4gICAgICBtYXRjaCBMaXN0LmZpbmRfb3B0ICh0ZXN0X2tleSBrKSAhYiB3aXRoXG4gICAgICB8IFNvbWUgZSAtPiBnZXRfZGF0YSBlXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuXG4gICAgbGV0IGxlbmd0aCBiID0gTGlzdC5sZW5ndGggIWJcbiAgICBsZXQgY2xlYXIgYiA9IGIgOj0gW11cblxuICBlbmRcblxuZW5kXG5cbm1vZHVsZSBLMiA9IHN0cnVjdFxuICB0eXBlICgnazEsICdrMiwgJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgKCkgOiAoJ2sxLCdrMiwnZCkgdCA9IE9iakVwaC5jcmVhdGUgMlxuXG4gIGxldCBnZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazEgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAwKVxuICBsZXQgc2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIChrOidrMSkgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IDAgKE9iai5yZXByIGspXG4gIGxldCBjaGVja19rZXkxICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMFxuXG4gIGxldCBnZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazIgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAxKVxuICBsZXQgc2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIChrOidrMikgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IDEgKE9iai5yZXByIGspXG4gIGxldCBjaGVja19rZXkyICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMVxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IHNldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSAoZDonZCkgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcblxuICBsZXQgbWFrZSBrZXkxIGtleTIgZGF0YSA9XG4gICAgbGV0IGVwaCA9IGNyZWF0ZSAoKSBpblxuICAgIHNldF9kYXRhIGVwaCBkYXRhO1xuICAgIHNldF9rZXkxIGVwaCBrZXkxO1xuICAgIHNldF9rZXkyIGVwaCBrZXkyO1xuICAgIGlnbm9yZSAoU3lzLm9wYXF1ZV9pZGVudGl0eSBrZXkxKTtcbiAgICBlcGhcblxuICBsZXQgcXVlcnkgZXBoIGtleTEga2V5MiA9XG4gICAgbWF0Y2ggZ2V0X2tleTEgZXBoIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBrIHdoZW4gayA9PSBrZXkxIC0+XG4gICAgICAgIGJlZ2luIG1hdGNoIGdldF9rZXkyIGVwaCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgIHwgU29tZSBrIHdoZW4gayA9PSBrZXkyIC0+IGdldF9kYXRhIGVwaFxuICAgICAgICB8IFNvbWUgXyAtPiBOb25lXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBfIC0+IE5vbmVcblxuICBtb2R1bGUgTWFrZVNlZWRlZFxuICAgICAgKEgxOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSlcbiAgICAgIChIMjpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgxLnQsSDIudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSDEudCAqIEgyLnRcbiAgICAgIGxldCBjcmVhdGUgKGsxLGsyKSBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKCkgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBzZXRfa2V5MSBjIGsxOyBzZXRfa2V5MiBjIGsyO1xuICAgICAgICBjXG4gICAgICBsZXQgc2VlZGVkX2hhc2ggc2VlZCAoazEsazIpID1cbiAgICAgICAgSDEuc2VlZGVkX2hhc2ggc2VlZCBrMSArIEgyLnNlZWRlZF9oYXNoIHNlZWQgazIgKiA2NTU5OVxuICAgICAgbGV0IGVxdWFsIGMgKGsxLGsyKSA9XG4gICAgICAgIG1hdGNoIGdldF9rZXkxIGMsIGdldF9rZXkyIGMgd2l0aFxuICAgICAgICB8IE5vbmUsIF8gfCBfICwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgfCBTb21lIGsxJywgU29tZSBrMicgLT5cbiAgICAgICAgICAgIGlmIEgxLmVxdWFsIGsxIGsxJyAmJiBIMi5lcXVhbCBrMiBrMidcbiAgICAgICAgICAgIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyAoazEsazIpIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIHNldF9rZXkxIGMgazE7IHNldF9rZXkyIGMgazI7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSBjID0gY2hlY2tfa2V5MSBjICYmIGNoZWNrX2tleTIgY1xuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIMTogSGFzaHRibC5IYXNoZWRUeXBlKShIMjogSGFzaHRibC5IYXNoZWRUeXBlKTpcbiAgICAoUyB3aXRoIHR5cGUga2V5ID0gSDEudCAqIEgyLnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkXG4gICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICB0eXBlIHQgPSBIMS50XG4gICAgICAgICAgbGV0IGVxdWFsID0gSDEuZXF1YWxcbiAgICAgICAgICBsZXQgc2VlZGVkX2hhc2ggKF9zZWVkOiBpbnQpIHggPSBIMS5oYXNoIHhcbiAgICAgICAgZW5kKVxuICAgICAgICAoc3RydWN0XG4gICAgICAgICAgdHlwZSB0ID0gSDIudFxuICAgICAgICAgIGxldCBlcXVhbCA9IEgyLmVxdWFsXG4gICAgICAgICAgbGV0IHNlZWRlZF9oYXNoIChfc2VlZDogaW50KSB4ID0gSDIuaGFzaCB4XG4gICAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbiAgbW9kdWxlIEJ1Y2tldCA9IHN0cnVjdFxuXG4gICAgdHlwZSBub25yZWMgKCdrMSwgJ2syLCAnZCkgdCA9ICgnazEsICdrMiwgJ2QpIHQgbGlzdCByZWZcbiAgICBsZXQgazJfbWFrZSA9IG1ha2VcbiAgICBsZXQgbWFrZSAoKSA9IHJlZiBbXVxuICAgIGxldCBhZGQgYiBrMSBrMiBkID0gYiA6PSBrMl9tYWtlIGsxIGsyIGQgOjogIWJcblxuICAgIGxldCB0ZXN0X2tleXMgazEgazIgZSA9XG4gICAgICBtYXRjaCBnZXRfa2V5MSBlLCBnZXRfa2V5MiBlIHdpdGhcbiAgICAgIHwgU29tZSB4MSwgU29tZSB4MiB3aGVuIHgxID09IGsxICYmIHgyID09IGsyIC0+IHRydWVcbiAgICAgIHwgXyAtPiBmYWxzZVxuXG4gICAgbGV0IHJlbW92ZSBiIGsxIGsyID1cbiAgICAgIGxldCByZWMgbG9vcCBsIGFjYyA9XG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICB8IFtdIC0+ICgpXG4gICAgICAgIHwgaCA6OiB0IHdoZW4gdGVzdF9rZXlzIGsxIGsyIGggLT4gYiA6PSBMaXN0LnJldl9hcHBlbmQgYWNjIHRcbiAgICAgICAgfCBoIDo6IHQgLT4gbG9vcCB0IChoIDo6IGFjYylcbiAgICAgIGluXG4gICAgICBsb29wICFiIFtdXG5cbiAgICBsZXQgZmluZCBiIGsxIGsyID1cbiAgICAgIG1hdGNoIExpc3QuZmluZF9vcHQgKHRlc3Rfa2V5cyBrMSBrMikgIWIgd2l0aFxuICAgICAgfCBTb21lIGUgLT4gZ2V0X2RhdGEgZVxuICAgICAgfCBOb25lIC0+IE5vbmVcblxuICAgIGxldCBsZW5ndGggYiA9IExpc3QubGVuZ3RoICFiXG4gICAgbGV0IGNsZWFyIGIgPSBiIDo9IFtdXG5cbiAgZW5kXG5cbmVuZFxuXG5tb2R1bGUgS24gPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgbiA6ICgnaywnZCkgdCA9IE9iakVwaC5jcmVhdGUgblxuICBsZXQgbGVuZ3RoIChrOignaywnZCkgdCkgOiBpbnQgPSBPYmpFcGgubGVuZ3RoIGtcblxuICBsZXQgZ2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IG4pXG4gIGxldCBzZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSAoazonaykgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IG4gKE9iai5yZXByIGspXG4gIGxldCBjaGVja19rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCBuXG5cbiAgbGV0IGdldF9kYXRhICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IHNldF9kYXRhICh0OignaywnZCkgdCkgKGQ6J2QpIDogdW5pdCA9IE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcblxuICBsZXQgbWFrZSBrZXlzIGRhdGEgPVxuICAgIGxldCBsID0gQXJyYXkubGVuZ3RoIGtleXMgaW5cbiAgICBsZXQgZXBoID0gY3JlYXRlIGwgaW5cbiAgICBzZXRfZGF0YSBlcGggZGF0YTtcbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG8gc2V0X2tleSBlcGggaSBrZXlzLihpKSBkb25lO1xuICAgIGVwaFxuXG4gIGxldCBxdWVyeSBlcGgga2V5cyA9XG4gICAgbGV0IGwgPSBsZW5ndGggZXBoIGluXG4gICAgdHJ5XG4gICAgICBpZiBsIDw+IEFycmF5Lmxlbmd0aCBrZXlzIHRoZW4gcmFpc2UgRXhpdDtcbiAgICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgICBtYXRjaCBnZXRfa2V5IGVwaCBpIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHJhaXNlIEV4aXRcbiAgICAgICAgfCBTb21lIGsgd2hlbiBrID09IGtleXMuKGkpIC0+ICgpXG4gICAgICAgIHwgU29tZSBfIC0+IHJhaXNlIEV4aXRcbiAgICAgIGRvbmU7XG4gICAgICBnZXRfZGF0YSBlcGhcbiAgICB3aXRoIEV4aXQgLT4gTm9uZVxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkIChIOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSC50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBILnQgYXJyYXlcbiAgICAgIGxldCBjcmVhdGUgayBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKEFycmF5Lmxlbmd0aCBrKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBzZXRfa2V5IGMgaSBrLihpKTtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgY1xuICAgICAgbGV0IHNlZWRlZF9oYXNoIHNlZWQgayA9XG4gICAgICAgIGxldCBoID0gcmVmIDAgaW5cbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIGggOj0gSC5zZWVkZWRfaGFzaCBzZWVkIGsuKGkpICogNjU1OTkgKyAhaDtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgIWhcbiAgICAgIGxldCBlcXVhbCBjIGsgPVxuICAgICAgICBsZXQgbGVuICA9IEFycmF5Lmxlbmd0aCBrIGluXG4gICAgICAgIGxldCBsZW4nID0gbGVuZ3RoIGMgaW5cbiAgICAgICAgaWYgbGVuICE9IGxlbicgdGhlbiBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgcmVjIGVxdWFsX2FycmF5IGsgYyBpID1cbiAgICAgICAgICAgIGlmIGkgPCAwIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyBpIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICAgICAgICB8IFNvbWUga2kgLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwgay4oaSkga2lcbiAgICAgICAgICAgICAgICAgIHRoZW4gZXF1YWxfYXJyYXkgayBjIChpLTEpXG4gICAgICAgICAgICAgICAgICBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgICAgICBpblxuICAgICAgICAgIGVxdWFsX2FycmF5IGsgYyAobGVuLTEpXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIGsgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIHNldF9rZXkgYyBpIGsuKGkpO1xuICAgICAgICBkb25lO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgYyA9XG4gICAgICAgIGxldCByZWMgY2hlY2sgYyBpID1cbiAgICAgICAgICBpIDwgMCB8fCAoY2hlY2tfa2V5IGMgaSAmJiBjaGVjayBjIChpLTEpKSBpblxuICAgICAgICBjaGVjayBjIChsZW5ndGggYyAtIDEpXG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEg6IEhhc2h0YmwuSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQgYXJyYXkpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgc2VlZGVkX2hhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcblxuICBtb2R1bGUgQnVja2V0ID0gc3RydWN0XG5cbiAgICB0eXBlIG5vbnJlYyAoJ2ssICdkKSB0ID0gKCdrLCAnZCkgdCBsaXN0IHJlZlxuICAgIGxldCBrbl9tYWtlID0gbWFrZVxuICAgIGxldCBtYWtlICgpID0gcmVmIFtdXG4gICAgbGV0IGFkZCBiIGsgZCA9IGIgOj0ga25fbWFrZSBrIGQgOjogIWJcblxuICAgIGxldCB0ZXN0X2tleXMgayBlID1cbiAgICAgIHRyeVxuICAgICAgICBpZiBsZW5ndGggZSA8PiBBcnJheS5sZW5ndGggayB0aGVuIHJhaXNlIEV4aXQ7XG4gICAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggayAtIDEgZG9cbiAgICAgICAgICBtYXRjaCBnZXRfa2V5IGUgaSB3aXRoXG4gICAgICAgICAgfCBTb21lIHggd2hlbiB4ID09IGsuKGkpIC0+ICgpXG4gICAgICAgICAgfCBfIC0+IHJhaXNlIEV4aXRcbiAgICAgICAgZG9uZTtcbiAgICAgICAgdHJ1ZVxuICAgICAgd2l0aCBFeGl0IC0+IGZhbHNlXG5cbiAgICBsZXQgcmVtb3ZlIGIgayA9XG4gICAgICBsZXQgcmVjIGxvb3AgbCBhY2MgPVxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgfCBbXSAtPiAoKVxuICAgICAgICB8IGggOjogdCB3aGVuIHRlc3Rfa2V5cyBrIGggLT4gYiA6PSBMaXN0LnJldl9hcHBlbmQgYWNjIHRcbiAgICAgICAgfCBoIDo6IHQgLT4gbG9vcCB0IChoIDo6IGFjYylcbiAgICAgIGluXG4gICAgICBsb29wICFiIFtdXG5cbiAgICBsZXQgZmluZCBiIGsgPVxuICAgICAgbWF0Y2ggTGlzdC5maW5kX29wdCAodGVzdF9rZXlzIGspICFiIHdpdGhcbiAgICAgIHwgU29tZSBlIC0+IGdldF9kYXRhIGVcbiAgICAgIHwgTm9uZSAtPiBOb25lXG5cbiAgICBsZXQgbGVuZ3RoIGIgPSBMaXN0Lmxlbmd0aCAhYlxuICAgIGxldCBjbGVhciBiID0gYiA6PSBbXVxuXG4gIGVuZFxuXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBYYXZpZXIgTGVyb3kgYW5kIERhbWllbiBEb2xpZ2V6LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGdlbmVyaWNfcXVvdGUgcXVvdGVxdW90ZSBzID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXCcnO1xuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBpZiBzLltpXSA9ICdcXCcnXG4gICAgdGhlbiBCdWZmZXIuYWRkX3N0cmluZyBiIHF1b3RlcXVvdGVcbiAgICBlbHNlIEJ1ZmZlci5hZGRfY2hhciBiICBzLltpXVxuICBkb25lO1xuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFwnJztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1sxXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Jhc2VuYW1lLmh0bWxcbiAgSW4gc3RlcCAxIG9mIFtbMV1dLCB3ZSBjaG9vc2UgdG8gcmV0dXJuIFwiLlwiIGZvciBlbXB0eSBpbnB1dC5cbiAgICAoZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBPQ2FtbClcbiAgSW4gc3RlcCAyLCB3ZSBjaG9vc2UgdG8gcHJvY2VzcyBcIi8vXCIgbm9ybWFsbHkuXG4gIFN0ZXAgNiBpcyBub3QgaW1wbGVtZW50ZWQ6IHdlIGNvbnNpZGVyIHRoYXQgdGhlIFtzdWZmaXhdIG9wZXJhbmQgaXNcbiAgICBhbHdheXMgYWJzZW50LiAgU3VmZml4ZXMgYXJlIGhhbmRsZWQgYnkgW2Nob3Bfc3VmZml4XSBhbmQgW2Nob3BfZXh0ZW5zaW9uXS5cbiopXG5sZXQgZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgbmFtZSA9XG4gIGxldCByZWMgZmluZF9lbmQgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGZpbmRfZW5kIChuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIG4gKG4gKyAxKVxuICBhbmQgZmluZF9iZWcgbiBwID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIHBcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gU3RyaW5nLnN1YiBuYW1lIChuICsgMSkgKHAgLSBuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIChuIC0gMSkgcFxuICBpblxuICBpZiBuYW1lID0gXCJcIlxuICB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgZWxzZSBmaW5kX2VuZCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1syXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Rpcm5hbWUuaHRtbFxuICBJbiBzdGVwIDYgb2YgW1syXV0sIHdlIGNob29zZSB0byBwcm9jZXNzIFwiLy9cIiBub3JtYWxseS5cbiopXG5sZXQgZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBuYW1lID1cbiAgbGV0IHJlYyB0cmFpbGluZ19zZXAgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIHRyYWlsaW5nX3NlcCAobiAtIDEpXG4gICAgZWxzZSBiYXNlIG5cbiAgYW5kIGJhc2UgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGludGVybWVkaWF0ZV9zZXAgblxuICAgIGVsc2UgYmFzZSAobiAtIDEpXG4gIGFuZCBpbnRlcm1lZGlhdGVfc2VwIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBpbnRlcm1lZGlhdGVfc2VwIChuIC0gMSlcbiAgICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChuICsgMSlcbiAgaW5cbiAgaWYgbmFtZSA9IFwiXCJcbiAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gIGVsc2UgdHJhaWxpbmdfc2VwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5tb2R1bGUgdHlwZSBTWVNERVBTID0gc2lnXG4gIHZhbCBudWxsIDogc3RyaW5nXG4gIHZhbCBjdXJyZW50X2Rpcl9uYW1lIDogc3RyaW5nXG4gIHZhbCBwYXJlbnRfZGlyX25hbWUgOiBzdHJpbmdcbiAgdmFsIGRpcl9zZXAgOiBzdHJpbmdcbiAgdmFsIGlzX2Rpcl9zZXAgOiBzdHJpbmcgLT4gaW50IC0+IGJvb2xcbiAgdmFsIGlzX3JlbGF0aXZlIDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGlzX2ltcGxpY2l0IDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGNoZWNrX3N1ZmZpeCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbFxuICB2YWwgY2hvcF9zdWZmaXhfb3B0IDogc3VmZml4OnN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nIG9wdGlvblxuICB2YWwgdGVtcF9kaXJfbmFtZSA6IHN0cmluZ1xuICB2YWwgcXVvdGUgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBxdW90ZV9jb21tYW5kIDpcbiAgICBzdHJpbmcgLT4gP3N0ZGluOiBzdHJpbmcgLT4gP3N0ZG91dDogc3RyaW5nIC0+ID9zdGRlcnI6IHN0cmluZ1xuICAgICAgICAgICAtPiBzdHJpbmcgbGlzdCAtPiBzdHJpbmdcbiAgdmFsIGJhc2VuYW1lIDogc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgZGlybmFtZSA6IHN0cmluZyAtPiBzdHJpbmdcbmVuZFxuXG5tb2R1bGUgVW5peCA6IFNZU0RFUFMgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIi9kZXYvbnVsbFwiXG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwIHMgaSA9IHMuW2ldID0gJy8nXG4gIGxldCBpc19yZWxhdGl2ZSBuID0gU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLydcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gIGxldCBjaGVja19zdWZmaXggbmFtZSBzdWZmID1cbiAgICBTdHJpbmcuZW5kc193aXRoIH5zdWZmaXg6c3VmZiBuYW1lXG5cbiAgbGV0IGNob3Bfc3VmZml4X29wdCB+c3VmZml4IGZpbGVuYW1lID1cbiAgICBsZXQgbGVuX3MgPSBTdHJpbmcubGVuZ3RoIHN1ZmZpeCBhbmQgbGVuX2YgPSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgaWYgbGVuX2YgPj0gbGVuX3MgdGhlblxuICAgICAgbGV0IHIgPSBTdHJpbmcuc3ViIGZpbGVuYW1lIChsZW5fZiAtIGxlbl9zKSBsZW5fcyBpblxuICAgICAgaWYgciA9IHN1ZmZpeCB0aGVuXG4gICAgICAgIFNvbWUgKFN0cmluZy5zdWIgZmlsZW5hbWUgMCAobGVuX2YgLSBsZW5fcykpXG4gICAgICBlbHNlXG4gICAgICAgIE5vbmVcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVE1QRElSXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIvdG1wXCJcbiAgbGV0IHF1b3RlID0gZ2VuZXJpY19xdW90ZSBcIidcXFxcJydcIlxuICBsZXQgcXVvdGVfY29tbWFuZCBjbWQgP3N0ZGluID9zdGRvdXQgP3N0ZGVyciBhcmdzID1cbiAgICBTdHJpbmcuY29uY2F0IFwiIFwiIChMaXN0Lm1hcCBxdW90ZSAoY21kIDo6IGFyZ3MpKVxuICAgIF4gKG1hdGNoIHN0ZGluICB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA8XCIgXiBxdW90ZSBmKVxuICAgIF4gKG1hdGNoIHN0ZG91dCB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA+XCIgXiBxdW90ZSBmKVxuICAgIF4gKG1hdGNoIHN0ZGVyciB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBpZiBzdGRlcnIgPSBzdGRvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gXCIgMj4mMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIFwiIDI+XCIgXiBxdW90ZSBmKVxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5tb2R1bGUgV2luMzIgOiBTWVNERVBTID0gc3RydWN0XG4gIGxldCBudWxsID0gXCJOVUxcIlxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIlxcXFxcIlxuICBsZXQgaXNfZGlyX3NlcCBzIGkgPSBsZXQgYyA9IHMuW2ldIGluIGMgPSAnLycgfHwgYyA9ICdcXFxcJyB8fCBjID0gJzonXG4gIGxldCBpc19yZWxhdGl2ZSBuID1cbiAgICAoU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLycpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJ1xcXFwnKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IG4uWzFdIDw+ICc6JylcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLlxcXFxcIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uXFxcXFwiKVxuICBsZXQgY2hlY2tfc3VmZml4IG5hbWUgc3VmZiA9XG4gICBTdHJpbmcubGVuZ3RoIG5hbWUgPj0gU3RyaW5nLmxlbmd0aCBzdWZmICYmXG4gICAobGV0IHMgPSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoU3RyaW5nLmxlbmd0aCBzdWZmKSBpblxuICAgIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgcyA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgc3VmZilcblxuICBsZXQgY2hvcF9zdWZmaXhfb3B0IH5zdWZmaXggZmlsZW5hbWUgPVxuICAgIGxldCBsZW5fcyA9IFN0cmluZy5sZW5ndGggc3VmZml4IGFuZCBsZW5fZiA9IFN0cmluZy5sZW5ndGggZmlsZW5hbWUgaW5cbiAgICBpZiBsZW5fZiA+PSBsZW5fcyB0aGVuXG4gICAgICBsZXQgciA9IFN0cmluZy5zdWIgZmlsZW5hbWUgKGxlbl9mIC0gbGVuX3MpIGxlbl9zIGluXG4gICAgICBpZiBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHIgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN1ZmZpeCB0aGVuXG4gICAgICAgIFNvbWUgKFN0cmluZy5zdWIgZmlsZW5hbWUgMCAobGVuX2YgLSBsZW5fcykpXG4gICAgICBlbHNlXG4gICAgICAgIE5vbmVcbiAgICBlbHNlXG4gICAgICBOb25lXG5cblxuICBsZXQgdGVtcF9kaXJfbmFtZSA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJURU1QXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIuXCJcbiAgbGV0IHF1b3RlIHMgPVxuICAgIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gICAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInO1xuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBsIHRoZW4gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInIGVsc2VcbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJ1xcXCInIC0+IGxvb3BfYnMgMCBpO1xuICAgICAgfCAnXFxcXCcgLT4gbG9vcF9icyAwIGk7XG4gICAgICB8IGMgICAgLT4gQnVmZmVyLmFkZF9jaGFyIGIgYzsgbG9vcCAoaSsxKTtcbiAgICBhbmQgbG9vcF9icyBuIGkgPVxuICAgICAgaWYgaSA9IGwgdGhlbiBiZWdpblxuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gICAgICAgIGFkZF9icyBuO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgICB8ICdcXFwiJyAtPiBhZGRfYnMgKDIqbisxKTsgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInOyBsb29wIChpKzEpO1xuICAgICAgICB8ICdcXFxcJyAtPiBsb29wX2JzIChuKzEpIChpKzEpO1xuICAgICAgICB8IF8gICAgLT4gYWRkX2JzIG47IGxvb3AgaVxuICAgICAgZW5kXG4gICAgYW5kIGFkZF9icyBuID0gZm9yIF9qID0gMSB0byBuIGRvIEJ1ZmZlci5hZGRfY2hhciBiICdcXFxcJzsgZG9uZVxuICAgIGluXG4gICAgbG9vcCAwO1xuICAgIEJ1ZmZlci5jb250ZW50cyBiXG4oKlxuUXVvdGluZyBjb21tYW5kcyBmb3IgZXhlY3V0aW9uIGJ5IGNtZC5leGUgaXMgZGlmZmljdWx0LlxuMS0gRWFjaCBhcmd1bWVudCBpcyBmaXJzdCBxdW90ZWQgdXNpbmcgdGhlIFwicXVvdGVcIiBmdW5jdGlvbiBhYm92ZSwgdG9cbiAgIHByb3RlY3QgaXQgYWdhaW5zdCB0aGUgcHJvY2Vzc2luZyBwZXJmb3JtZWQgYnkgdGhlIEMgcnVudGltZSBzeXN0ZW0sXG4gICB0aGVuIGNtZC5leGUncyBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQgd2l0aCAnXicsIHVzaW5nXG4gICB0aGUgXCJxdW90ZV9jbWRcIiBmdW5jdGlvbiBiZWxvdy4gIEZvciBtb3JlIGRldGFpbHMsIHNlZVxuICAgaHR0cHM6Ly9ibG9ncy5tc2RuLm1pY3Jvc29mdC5jb20vdHdpc3R5bGl0dGxlcGFzc2FnZXNhbGxhbGlrZS8yMDExLzA0LzIzXG4yLSBUaGUgY29tbWFuZCBhbmQgdGhlIHJlZGlyZWN0aW9uIGZpbGVzLCBpZiBhbnksIG11c3QgYmUgZG91YmxlLXF1b3RlZFxuICAgaW4gY2FzZSB0aGV5IGNvbnRhaW4gc3BhY2VzLiAgVGhpcyBxdW90aW5nIGlzIGludGVycHJldGVkIGJ5IGNtZC5leGUsXG4gICBub3QgYnkgdGhlIEMgcnVudGltZSBzeXN0ZW0sIGhlbmNlIHRoZSBcInF1b3RlXCIgZnVuY3Rpb24gYWJvdmVcbiAgIGNhbm5vdCBiZSB1c2VkLiAgVGhlIHR3byBjaGFyYWN0ZXJzIHdlIGRvbid0IGtub3cgaG93IHRvIHF1b3RlXG4gICBpbnNpZGUgYSBkb3VibGUtcXVvdGVkIGNtZC5leGUgc3RyaW5nIGFyZSBkb3VibGUtcXVvdGUgYW5kIHBlcmNlbnQuXG4gICBXZSBqdXN0IGZhaWwgaWYgdGhlIGNvbW1hbmQgbmFtZSBvciB0aGUgcmVkaXJlY3Rpb24gZmlsZSBuYW1lc1xuICAgY29udGFpbiBhIGRvdWJsZSBxdW90ZSAobm90IGFsbG93ZWQgaW4gV2luZG93cyBmaWxlIG5hbWVzLCBhbnl3YXkpXG4gICBvciBhIHBlcmNlbnQuICBTZWUgZnVuY3Rpb24gXCJxdW90ZV9jbWRfZmlsZW5hbWVcIiBiZWxvdy5cbjMtIFRoZSB3aG9sZSBzdHJpbmcgcGFzc2VkIHRvIFN5cy5jb21tYW5kIGlzIHRoZW4gZW5jbG9zZWQgaW4gZG91YmxlXG4gICBxdW90ZXMsIHdoaWNoIGFyZSBpbW1lZGlhdGVseSBzdHJpcHBlZCBieSBjbWQuZXhlLiAgT3RoZXJ3aXNlLFxuICAgc29tZSBvZiB0aGUgZG91YmxlIHF1b3RlcyBmcm9tIHN0ZXAgMiBhYm92ZSBjYW4gYmUgbWlzcGFyc2VkLlxuICAgU2VlIGUuZy4gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzk5NjUxNDFcbiopXG4gIGxldCBxdW90ZV9jbWQgcyA9XG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChTdHJpbmcubGVuZ3RoIHMgKyAyMCkgaW5cbiAgICBTdHJpbmcuaXRlclxuICAgICAgKGZ1biBjIC0+XG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8ICcoJyB8ICcpJyB8ICchJyB8ICdeJyB8ICclJyB8ICdcXFwiJyB8ICc8JyB8ICc+JyB8ICcmJyB8ICd8JyAtPlxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgJ14nOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgYylcbiAgICAgIHM7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJcbiAgbGV0IHF1b3RlX2NtZF9maWxlbmFtZSBmID1cbiAgICBpZiBTdHJpbmcuY29udGFpbnMgZiAnXFxcIicgfHwgU3RyaW5nLmNvbnRhaW5zIGYgJyUnIHRoZW5cbiAgICAgIGZhaWx3aXRoIChcIkZpbGVuYW1lLnF1b3RlX2NvbW1hbmQ6IGJhZCBmaWxlIG5hbWUgXCIgXiBmKVxuICAgIGVsc2UgaWYgU3RyaW5nLmNvbnRhaW5zIGYgJyAnIHRoZW5cbiAgICAgIFwiXFxcIlwiIF4gZiBeIFwiXFxcIlwiXG4gICAgZWxzZVxuICAgICAgZlxuICAoKiBSZWRpcmVjdGlvbnMgaW4gY21kLmV4ZTogc2VlIGh0dHBzOi8vc3M2NC5jb20vbnQvc3ludGF4LXJlZGlyZWN0aW9uLmh0bWxcbiAgICAgYW5kIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3ByZXZpb3VzLXZlcnNpb25zL3dpbmRvd3MvaXQtcHJvL3dpbmRvd3MteHAvYmI0OTA5ODIodj10ZWNobmV0LjEwKVxuICAqKVxuICBsZXQgcXVvdGVfY29tbWFuZCBjbWQgP3N0ZGluID9zdGRvdXQgP3N0ZGVyciBhcmdzID1cbiAgICBTdHJpbmcuY29uY2F0IFwiXCIgW1xuICAgICAgXCJcXFwiXCI7XG4gICAgICBxdW90ZV9jbWRfZmlsZW5hbWUgY21kO1xuICAgICAgXCIgXCI7XG4gICAgICBxdW90ZV9jbWQgKFN0cmluZy5jb25jYXQgXCIgXCIgKExpc3QubWFwIHF1b3RlIGFyZ3MpKTtcbiAgICAgIChtYXRjaCBzdGRpbiAgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPFwiIF4gcXVvdGVfY21kX2ZpbGVuYW1lIGYpO1xuICAgICAgKG1hdGNoIHN0ZG91dCB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA+XCIgXiBxdW90ZV9jbWRfZmlsZW5hbWUgZik7XG4gICAgICAobWF0Y2ggc3RkZXJyIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgc3RkZXJyID0gc3Rkb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBcIiAyPiYxXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIFwiIDI+XCIgXiBxdW90ZV9jbWRfZmlsZW5hbWUgZik7XG4gICAgICBcIlxcXCJcIlxuICAgIF1cbiAgbGV0IGhhc19kcml2ZSBzID1cbiAgICBsZXQgaXNfbGV0dGVyID0gZnVuY3Rpb25cbiAgICAgIHwgJ0EnIC4uICdaJyB8ICdhJyAuLiAneicgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBTdHJpbmcubGVuZ3RoIHMgPj0gMiAmJiBpc19sZXR0ZXIgcy5bMF0gJiYgcy5bMV0gPSAnOidcbiAgbGV0IGRyaXZlX2FuZF9wYXRoIHMgPVxuICAgIGlmIGhhc19kcml2ZSBzXG4gICAgdGhlbiAoU3RyaW5nLnN1YiBzIDAgMiwgU3RyaW5nLnN1YiBzIDIgKFN0cmluZy5sZW5ndGggcyAtIDIpKVxuICAgIGVsc2UgKFwiXCIsIHMpXG4gIGxldCBkaXJuYW1lIHMgPVxuICAgIGxldCAoZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGxldCBkaXIgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGggaW5cbiAgICBkcml2ZSBeIGRpclxuICBsZXQgYmFzZW5hbWUgcyA9XG4gICAgbGV0IChfZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGhcbmVuZFxuXG5tb2R1bGUgQ3lnd2luIDogU1lTREVQUyA9IHN0cnVjdFxuICBsZXQgbnVsbCA9IFwiL2Rldi9udWxsXCJcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCIvXCJcbiAgbGV0IGlzX2Rpcl9zZXAgPSBXaW4zMi5pc19kaXJfc2VwXG4gIGxldCBpc19yZWxhdGl2ZSA9IFdpbjMyLmlzX3JlbGF0aXZlXG4gIGxldCBpc19pbXBsaWNpdCA9IFdpbjMyLmlzX2ltcGxpY2l0XG4gIGxldCBjaGVja19zdWZmaXggPSBXaW4zMi5jaGVja19zdWZmaXhcbiAgbGV0IGNob3Bfc3VmZml4X29wdCA9IFdpbjMyLmNob3Bfc3VmZml4X29wdFxuICBsZXQgdGVtcF9kaXJfbmFtZSA9IFVuaXgudGVtcF9kaXJfbmFtZVxuICBsZXQgcXVvdGUgPSBVbml4LnF1b3RlXG4gIGxldCBxdW90ZV9jb21tYW5kID0gVW5peC5xdW90ZV9jb21tYW5kXG4gIGxldCBiYXNlbmFtZSA9IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG4gIGxldCBkaXJuYW1lID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuZW5kXG5cbm1vZHVsZSBTeXNkZXBzID1cbiAgKHZhbCAobWF0Y2ggU3lzLm9zX3R5cGUgd2l0aFxuICAgICAgIHwgXCJXaW4zMlwiIC0+IChtb2R1bGUgV2luMzI6IFNZU0RFUFMpXG4gICAgICAgfCBcIkN5Z3dpblwiIC0+IChtb2R1bGUgQ3lnd2luOiBTWVNERVBTKVxuICAgICAgIHwgXyAtPiAobW9kdWxlIFVuaXg6IFNZU0RFUFMpKSlcblxuaW5jbHVkZSBTeXNkZXBzXG5cbmxldCBjb25jYXQgZGlybmFtZSBmaWxlbmFtZSA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBkaXJuYW1lIGluXG4gIGlmIGwgPSAwIHx8IGlzX2Rpcl9zZXAgZGlybmFtZSAobC0xKVxuICB0aGVuIGRpcm5hbWUgXiBmaWxlbmFtZVxuICBlbHNlIGRpcm5hbWUgXiBkaXJfc2VwIF4gZmlsZW5hbWVcblxubGV0IGNob3Bfc3VmZml4IG5hbWUgc3VmZiA9XG4gIGlmIGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmZcbiAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmKVxuICBlbHNlIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9zdWZmaXhcIlxuXG5sZXQgZXh0ZW5zaW9uX2xlbiBuYW1lID1cbiAgbGV0IHJlYyBjaGVjayBpMCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaTAgKGkgLSAxKVxuICAgIGVsc2UgU3RyaW5nLmxlbmd0aCBuYW1lIC0gaTBcbiAgaW5cbiAgbGV0IHJlYyBzZWFyY2hfZG90IGkgPVxuICAgIGlmIGkgPCAwIHx8IGlzX2Rpcl9zZXAgbmFtZSBpIHRoZW4gMFxuICAgIGVsc2UgaWYgbmFtZS5baV0gPSAnLicgdGhlbiBjaGVjayBpIChpIC0gMSlcbiAgICBlbHNlIHNlYXJjaF9kb3QgKGkgLSAxKVxuICBpblxuICBzZWFyY2hfZG90IChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5sZXQgZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIFwiXCIgZWxzZSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpIGxcblxubGV0IGNob3BfZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9leHRlbnNpb25cIlxuICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5sZXQgcmVtb3ZlX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBuYW1lIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpXG5cbmV4dGVybmFsIG9wZW5fZGVzYzogc3RyaW5nIC0+IG9wZW5fZmxhZyBsaXN0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfc3lzX29wZW5cIlxuZXh0ZXJuYWwgY2xvc2VfZGVzYzogaW50IC0+IHVuaXQgPSBcImNhbWxfc3lzX2Nsb3NlXCJcblxubGV0IHBybmdfa2V5ID1cbiAgRG9tYWluLkRMUy5uZXdfa2V5IFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdFxuXG5sZXQgdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByYW5kb21fc3RhdGUgPSBEb21haW4uRExTLmdldCBwcm5nX2tleSBpblxuICBsZXQgcm5kID0gKFJhbmRvbS5TdGF0ZS5iaXRzIHJhbmRvbV9zdGF0ZSkgbGFuZCAweEZGRkZGRiBpblxuICBjb25jYXQgdGVtcF9kaXIgKFByaW50Zi5zcHJpbnRmIFwiJXMlMDZ4JXNcIiBwcmVmaXggcm5kIHN1ZmZpeClcblxubGV0IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSA9XG4gIERvbWFpbi5ETFMubmV3X2tleSB+c3BsaXRfZnJvbV9wYXJlbnQ6RnVuLmlkIChmdW4gKCkgLT4gdGVtcF9kaXJfbmFtZSlcblxubGV0IHNldF90ZW1wX2Rpcl9uYW1lIHMgPSBEb21haW4uRExTLnNldCBjdXJyZW50X3RlbXBfZGlyX25hbWUgc1xubGV0IGdldF90ZW1wX2Rpcl9uYW1lICgpID0gRG9tYWluLkRMUy5nZXQgY3VycmVudF90ZW1wX2Rpcl9uYW1lXG5cbmxldCB0ZW1wX2ZpbGUgPyh0ZW1wX2RpciA9IERvbWFpbi5ETFMuZ2V0IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSkgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByZWMgdHJ5X25hbWUgY291bnRlciA9XG4gICAgbGV0IG5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4IGluXG4gICAgdHJ5XG4gICAgICBjbG9zZV9kZXNjKG9wZW5fZGVzYyBuYW1lIFtPcGVuX3dyb25seTsgT3Blbl9jcmVhdDsgT3Blbl9leGNsXSAwbzYwMCk7XG4gICAgICBuYW1lXG4gICAgd2l0aCBTeXNfZXJyb3IgXyBhcyBlIC0+XG4gICAgICBpZiBjb3VudGVyID49IDEwMDAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG5cbmxldCBvcGVuX3RlbXBfZmlsZSA/KG1vZGUgPSBbT3Blbl90ZXh0XSkgPyhwZXJtcyA9IDBvNjAwKVxuICAgID8odGVtcF9kaXIgPSBEb21haW4uRExTLmdldCBjdXJyZW50X3RlbXBfZGlyX25hbWUpXG4gICAgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByZWMgdHJ5X25hbWUgY291bnRlciA9XG4gICAgbGV0IG5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4IGluXG4gICAgdHJ5XG4gICAgICAobmFtZSxcbiAgICAgICBvcGVuX291dF9nZW4gKE9wZW5fd3Jvbmx5OjpPcGVuX2NyZWF0OjpPcGVuX2V4Y2w6Om1vZGUpIHBlcm1zIG5hbWUpXG4gICAgd2l0aCBTeXNfZXJyb3IgXyBhcyBlIC0+XG4gICAgICBpZiBjb3VudGVyID49IDEwMDAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENvbXBsZXggbnVtYmVycyAqKVxuXG50eXBlIHQgPSB7IHJlOiBmbG9hdDsgaW06IGZsb2F0IH1cblxubGV0IHplcm8gPSB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG5sZXQgb25lID0geyByZSA9IDEuMDsgaW0gPSAwLjAgfVxubGV0IGkgPSB7IHJlID0gMC4wOyBpbSA9IDEuMCB9XG5cbmxldCBhZGQgeCB5ID0geyByZSA9IHgucmUgKy4geS5yZTsgaW0gPSB4LmltICsuIHkuaW0gfVxuXG5sZXQgc3ViIHggeSA9IHsgcmUgPSB4LnJlIC0uIHkucmU7IGltID0geC5pbSAtLiB5LmltIH1cblxubGV0IG5lZyB4ID0geyByZSA9IC0uIHgucmU7IGltID0gLS4geC5pbSB9XG5cbmxldCBjb25qIHggPSB7IHJlID0geC5yZTsgaW0gPSAtLiB4LmltIH1cblxubGV0IG11bCB4IHkgPSB7IHJlID0geC5yZSAqLiB5LnJlIC0uIHguaW0gKi4geS5pbTtcbiAgICAgICAgICAgICAgICBpbSA9IHgucmUgKi4geS5pbSArLiB4LmltICouIHkucmUgfVxuXG5sZXQgZGl2IHggeSA9XG4gIGlmIGFic19mbG9hdCB5LnJlID49IGFic19mbG9hdCB5LmltIHRoZW5cbiAgICBsZXQgciA9IHkuaW0gLy4geS5yZSBpblxuICAgIGxldCBkID0geS5yZSArLiByICouIHkuaW0gaW5cbiAgICB7IHJlID0gKHgucmUgKy4gciAqLiB4LmltKSAvLiBkO1xuICAgICAgaW0gPSAoeC5pbSAtLiByICouIHgucmUpIC8uIGQgfVxuICBlbHNlXG4gICAgbGV0IHIgPSB5LnJlIC8uIHkuaW0gaW5cbiAgICBsZXQgZCA9IHkuaW0gKy4gciAqLiB5LnJlIGluXG4gICAgeyByZSA9IChyICouIHgucmUgKy4geC5pbSkgLy4gZDtcbiAgICAgIGltID0gKHIgKi4geC5pbSAtLiB4LnJlKSAvLiBkIH1cblxubGV0IGludiB4ID0gZGl2IG9uZSB4XG5cbmxldCBub3JtMiB4ID0geC5yZSAqLiB4LnJlICsuIHguaW0gKi4geC5pbVxuXG5sZXQgbm9ybSB4ID0gRmxvYXQuaHlwb3QgeC5yZSB4LmltXG5cbmxldCBhcmcgeCA9IGF0YW4yIHguaW0geC5yZVxuXG5sZXQgcG9sYXIgbiBhID0geyByZSA9IGNvcyBhICouIG47IGltID0gc2luIGEgKi4gbiB9XG5cbmxldCBzcXJ0IHggPVxuICBpZiB4LnJlID0gMC4wICYmIHguaW0gPSAwLjAgdGhlbiB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGFic19mbG9hdCB4LnJlIGFuZCBpID0gYWJzX2Zsb2F0IHguaW0gaW5cbiAgICBsZXQgdyA9XG4gICAgICBpZiByID49IGkgdGhlbiBiZWdpblxuICAgICAgICBsZXQgcSA9IGkgLy4gciBpblxuICAgICAgICBzcXJ0KHIpICouIHNxcnQoMC41ICouICgxLjAgKy4gc3FydCgxLjAgKy4gcSAqLiBxKSkpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsZXQgcSA9IHIgLy4gaSBpblxuICAgICAgICBzcXJ0KGkpICouIHNxcnQoMC41ICouIChxICsuIHNxcnQoMS4wICsuIHEgKi4gcSkpKVxuICAgICAgZW5kIGluXG4gICAgaWYgeC5yZSA+PSAwLjBcbiAgICB0aGVuIHsgcmUgPSB3OyAgaW0gPSAwLjUgKi4geC5pbSAvLiB3IH1cbiAgICBlbHNlIHsgcmUgPSAwLjUgKi4gaSAvLiB3OyAgaW0gPSBpZiB4LmltID49IDAuMCB0aGVuIHcgZWxzZSAtLiB3IH1cbiAgZW5kXG5cbmxldCBleHAgeCA9XG4gIGxldCBlID0gZXhwIHgucmUgaW4geyByZSA9IGUgKi4gY29zIHguaW07IGltID0gZSAqLiBzaW4geC5pbSB9XG5cbmxldCBsb2cgeCA9IHsgcmUgPSBsb2cgKG5vcm0geCk7IGltID0gYXRhbjIgeC5pbSB4LnJlIH1cblxubGV0IHBvdyB4IHkgPSBleHAgKG11bCB5IChsb2cgeCkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDIxIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IGluX2NoYW5uZWxcblxudHlwZSBvcGVuX2ZsYWcgPSBTdGRsaWIub3Blbl9mbGFnID1cbiAgfCBPcGVuX3Jkb25seVxuICB8IE9wZW5fd3Jvbmx5XG4gIHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0XG4gIHwgT3Blbl90cnVuY1xuICB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5XG4gIHwgT3Blbl90ZXh0XG4gIHwgT3Blbl9ub25ibG9ja1xuXG5sZXQgc3RkaW4gPSBTdGRsaWIuc3RkaW5cbmxldCBvcGVuX2JpbiA9IFN0ZGxpYi5vcGVuX2luX2JpblxubGV0IG9wZW5fdGV4dCA9IFN0ZGxpYi5vcGVuX2luXG5sZXQgb3Blbl9nZW4gPSBTdGRsaWIub3Blbl9pbl9nZW5cblxubGV0IHdpdGhfb3BlbiBvcGVuZnVuIHMgZiA9XG4gIGxldCBpYyA9IG9wZW5mdW4gcyBpblxuICBGdW4ucHJvdGVjdCB+ZmluYWxseTooZnVuICgpIC0+IFN0ZGxpYi5jbG9zZV9pbl9ub2VyciBpYylcbiAgICAoZnVuICgpIC0+IGYgaWMpXG5cbmxldCB3aXRoX29wZW5fYmluIHMgZiA9XG4gIHdpdGhfb3BlbiBTdGRsaWIub3Blbl9pbl9iaW4gcyBmXG5cbmxldCB3aXRoX29wZW5fdGV4dCBzIGYgPVxuICB3aXRoX29wZW4gU3RkbGliLm9wZW5faW4gcyBmXG5cbmxldCB3aXRoX29wZW5fZ2VuIGZsYWdzIHBlcm0gcyBmID1cbiAgd2l0aF9vcGVuIChTdGRsaWIub3Blbl9pbl9nZW4gZmxhZ3MgcGVybSkgcyBmXG5cbmxldCBzZWVrID0gU3RkbGliLkxhcmdlRmlsZS5zZWVrX2luXG5sZXQgcG9zID0gU3RkbGliLkxhcmdlRmlsZS5wb3NfaW5cbmxldCBsZW5ndGggPSBTdGRsaWIuTGFyZ2VGaWxlLmluX2NoYW5uZWxfbGVuZ3RoXG5sZXQgY2xvc2UgPSBTdGRsaWIuY2xvc2VfaW5cbmxldCBjbG9zZV9ub2VyciA9IFN0ZGxpYi5jbG9zZV9pbl9ub2VyclxuXG5sZXQgaW5wdXRfY2hhciBpYyA9XG4gIG1hdGNoIFN0ZGxpYi5pbnB1dF9jaGFyIGljIHdpdGhcbiAgfCBjIC0+IFNvbWUgY1xuICB8IGV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSAtPiBOb25lXG5cbmxldCBpbnB1dF9ieXRlIGljID1cbiAgbWF0Y2ggU3RkbGliLmlucHV0X2J5dGUgaWMgd2l0aFxuICB8IG4gLT4gU29tZSBuXG4gIHwgZXhjZXB0aW9uIEVuZF9vZl9maWxlIC0+IE5vbmVcblxubGV0IGlucHV0X2xpbmUgaWMgPVxuICBtYXRjaCBTdGRsaWIuaW5wdXRfbGluZSBpYyB3aXRoXG4gIHwgcyAtPiBTb21lIHNcbiAgfCBleGNlcHRpb24gRW5kX29mX2ZpbGUgLT4gTm9uZVxuXG5sZXQgaW5wdXQgPSBTdGRsaWIuaW5wdXRcblxubGV0IHJlYWxseV9pbnB1dCBpYyBidWYgcG9zIGxlbiA9XG4gIG1hdGNoIFN0ZGxpYi5yZWFsbHlfaW5wdXQgaWMgYnVmIHBvcyBsZW4gd2l0aFxuICB8ICgpIC0+IFNvbWUgKClcbiAgfCBleGNlcHRpb24gRW5kX29mX2ZpbGUgLT4gTm9uZVxuXG5sZXQgcmVhbGx5X2lucHV0X3N0cmluZyBpYyBsZW4gPVxuICBtYXRjaCBTdGRsaWIucmVhbGx5X2lucHV0X3N0cmluZyBpYyBsZW4gd2l0aFxuICB8IHMgLT4gU29tZSBzXG4gIHwgZXhjZXB0aW9uIEVuZF9vZl9maWxlIC0+IE5vbmVcblxuKCogUmVhZCB1cCB0byBbbGVuXSBieXRlcyBpbnRvIFtidWZdLCBzdGFydGluZyBhdCBbb2ZzXS4gUmV0dXJuIHRvdGFsIGJ5dGVzXG4gICByZWFkLiAqKVxubGV0IHJlYWRfdXB0byBpYyBidWYgb2ZzIGxlbiA9XG4gIGxldCByZWMgbG9vcCBvZnMgbGVuID1cbiAgICBpZiBsZW4gPSAwIHRoZW4gb2ZzXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBTdGRsaWIuaW5wdXQgaWMgYnVmIG9mcyBsZW4gaW5cbiAgICAgIGlmIHIgPSAwIHRoZW5cbiAgICAgICAgb2ZzXG4gICAgICBlbHNlXG4gICAgICAgIGxvb3AgKG9mcyArIHIpIChsZW4gLSByKVxuICAgIGVuZFxuICBpblxuICBsb29wIG9mcyBsZW4gLSBvZnNcblxuKCogQmVzdCBlZmZvcnQgYXR0ZW1wdCB0byByZXR1cm4gYSBidWZmZXIgd2l0aCA+PSAob2ZzICsgbikgYnl0ZXMgb2Ygc3RvcmFnZSxcbiAgIGFuZCBzdWNoIHRoYXQgaXQgY29pbmNpZGVzIHdpdGggW2J1Zl0gYXQgaW5kaWNlcyA8IFtvZnNdLlxuXG4gICBUaGUgcmV0dXJuZWQgYnVmZmVyIGlzIGVxdWFsIHRvIFtidWZdIGl0c2VsZiBpZiBpdCBhbHJlYWR5IGhhcyBzdWZmaWNpZW50XG4gICBmcmVlIHNwYWNlLlxuXG4gICBUaGUgcmV0dXJuZWQgYnVmZmVyIG1heSBoYXZlICpmZXdlciogdGhhbiBbb2ZzICsgbl0gYnl0ZXMgb2Ygc3RvcmFnZSBpZiB0aGlzXG4gICBudW1iZXIgaXMgPiBbU3lzLm1heF9zdHJpbmdfbGVuZ3RoXS4gSG93ZXZlciB0aGUgcmV0dXJuZWQgYnVmZmVyIHdpbGxcbiAgICphbHdheXMqIGhhdmUgPiBbb2ZzXSBieXRlcyBvZiBzdG9yYWdlLiBJbiB0aGUgbGltaXRpbmcgY2FzZSB3aGVuIFtvZnMgPSBsZW5cbiAgID0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXSAoc28gdGhhdCBpdCBpcyBub3QgcG9zc2libGUgdG8gcmVzaXplIHRoZSBidWZmZXIgYXRcbiAgIGFsbCksIGFuIGV4Y2VwdGlvbiBpcyByYWlzZWQuICopXG5cbmxldCBlbnN1cmUgYnVmIG9mcyBuID1cbiAgbGV0IGxlbiA9IEJ5dGVzLmxlbmd0aCBidWYgaW5cbiAgaWYgbGVuID49IG9mcyArIG4gdGhlbiBidWZcbiAgZWxzZSBiZWdpblxuICAgIGxldCBuZXdfbGVuID0gcmVmIGxlbiBpblxuICAgIHdoaWxlICFuZXdfbGVuIDwgb2ZzICsgbiBkb1xuICAgICAgbmV3X2xlbiA6PSAyICogIW5ld19sZW4gKyAxXG4gICAgZG9uZTtcbiAgICBsZXQgbmV3X2xlbiA9ICFuZXdfbGVuIGluXG4gICAgbGV0IG5ld19sZW4gPVxuICAgICAgaWYgbmV3X2xlbiA8PSBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgICBuZXdfbGVuXG4gICAgICBlbHNlIGlmIG9mcyA8IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuXG4gICAgICAgIFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgICAgZWxzZVxuICAgICAgICBmYWlsd2l0aCBcIkluX2NoYW5uZWwuaW5wdXRfYWxsOiBjaGFubmVsIGNvbnRlbnQgXFxcbiAgICAgICAgICAgICAgICAgIGlzIGxhcmdlciB0aGFuIG1heGltdW0gc3RyaW5nIGxlbmd0aFwiXG4gICAgaW5cbiAgICBsZXQgbmV3X2J1ZiA9IEJ5dGVzLmNyZWF0ZSBuZXdfbGVuIGluXG4gICAgQnl0ZXMuYmxpdCBidWYgMCBuZXdfYnVmIDAgb2ZzO1xuICAgIG5ld19idWZcbiAgZW5kXG5cbmxldCBpbnB1dF9hbGwgaWMgPVxuICBsZXQgY2h1bmtfc2l6ZSA9IDY1NTM2IGluICgqIElPX0JVRkZFUl9TSVpFICopXG4gIGxldCBpbml0aWFsX3NpemUgPVxuICAgIHRyeVxuICAgICAgU3RkbGliLmluX2NoYW5uZWxfbGVuZ3RoIGljIC0gU3RkbGliLnBvc19pbiBpY1xuICAgIHdpdGggU3lzX2Vycm9yIF8gLT5cbiAgICAgIC0xXG4gIGluXG4gIGxldCBpbml0aWFsX3NpemUgPSBpZiBpbml0aWFsX3NpemUgPCAwIHRoZW4gY2h1bmtfc2l6ZSBlbHNlIGluaXRpYWxfc2l6ZSBpblxuICBsZXQgaW5pdGlhbF9zaXplID1cbiAgICBpZiBpbml0aWFsX3NpemUgPD0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW5cbiAgICAgIGluaXRpYWxfc2l6ZVxuICAgIGVsc2VcbiAgICAgIFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICBpblxuICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIGluaXRpYWxfc2l6ZSBpblxuICBsZXQgbnJlYWQgPSByZWFkX3VwdG8gaWMgYnVmIDAgaW5pdGlhbF9zaXplIGluXG4gIGlmIG5yZWFkIDwgaW5pdGlhbF9zaXplIHRoZW4gKCogRU9GIHJlYWNoZWQsIGJ1ZmZlciBwYXJ0aWFsbHkgZmlsbGVkICopXG4gICAgQnl0ZXMuc3ViX3N0cmluZyBidWYgMCBucmVhZFxuICBlbHNlIGJlZ2luICgqIG5yZWFkID0gaW5pdGlhbF9zaXplLCBtYXliZSBFT0YgcmVhY2hlZCAqKVxuICAgIG1hdGNoIFN0ZGxpYi5pbnB1dF9jaGFyIGljIHdpdGhcbiAgICB8IGV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSAtPlxuICAgICAgICAoKiBFT0YgcmVhY2hlZCwgYnVmZmVyIGlzIGNvbXBsZXRlbHkgZmlsbGVkICopXG4gICAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYnVmXG4gICAgfCBjIC0+XG4gICAgICAgICgqIEVPRiBub3QgcmVhY2hlZCAqKVxuICAgICAgICBsZXQgcmVjIGxvb3AgYnVmIG9mcyA9XG4gICAgICAgICAgbGV0IGJ1ZiA9IGVuc3VyZSBidWYgb2ZzIGNodW5rX3NpemUgaW5cbiAgICAgICAgICBsZXQgcmVtID0gQnl0ZXMubGVuZ3RoIGJ1ZiAtIG9mcyBpblxuICAgICAgICAgICgqIFtyZW1dIGNhbiBiZSA8IFtjaHVua19zaXplXSBpZiBidWZmZXIgc2l6ZSBjbG9zZSB0b1xuICAgICAgICAgICAgIFtTeXMubWF4X3N0cmluZ19sZW5ndGhdICopXG4gICAgICAgICAgbGV0IHIgPSByZWFkX3VwdG8gaWMgYnVmIG9mcyByZW0gaW5cbiAgICAgICAgICBpZiByIDwgcmVtIHRoZW4gKCogRU9GIHJlYWNoZWQgKilcbiAgICAgICAgICAgIEJ5dGVzLnN1Yl9zdHJpbmcgYnVmIDAgKG9mcyArIHIpXG4gICAgICAgICAgZWxzZSAoKiByID0gcmVtICopXG4gICAgICAgICAgICBsb29wIGJ1ZiAob2ZzICsgcmVtKVxuICAgICAgICBpblxuICAgICAgICBsZXQgYnVmID0gZW5zdXJlIGJ1ZiBucmVhZCAoY2h1bmtfc2l6ZSArIDEpIGluXG4gICAgICAgIEJ5dGVzLnNldCBidWYgbnJlYWQgYztcbiAgICAgICAgbG9vcCBidWYgKG5yZWFkICsgMSlcbiAgZW5kXG5cbmxldCBzZXRfYmluYXJ5X21vZGUgPSBTdGRsaWIuc2V0X2JpbmFyeV9tb2RlX2luXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDIxIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IG91dF9jaGFubmVsXG5cbnR5cGUgb3Blbl9mbGFnID0gU3RkbGliLm9wZW5fZmxhZyA9XG4gIHwgT3Blbl9yZG9ubHlcbiAgfCBPcGVuX3dyb25seVxuICB8IE9wZW5fYXBwZW5kXG4gIHwgT3Blbl9jcmVhdFxuICB8IE9wZW5fdHJ1bmNcbiAgfCBPcGVuX2V4Y2xcbiAgfCBPcGVuX2JpbmFyeVxuICB8IE9wZW5fdGV4dFxuICB8IE9wZW5fbm9uYmxvY2tcblxubGV0IHN0ZG91dCA9IFN0ZGxpYi5zdGRvdXRcbmxldCBzdGRlcnIgPSBTdGRsaWIuc3RkZXJyXG5sZXQgb3Blbl9iaW4gPSBTdGRsaWIub3Blbl9vdXRfYmluXG5sZXQgb3Blbl90ZXh0ID0gU3RkbGliLm9wZW5fb3V0XG5sZXQgb3Blbl9nZW4gPSBTdGRsaWIub3Blbl9vdXRfZ2VuXG5cbmxldCB3aXRoX29wZW4gb3BlbmZ1biBzIGYgPVxuICBsZXQgb2MgPSBvcGVuZnVuIHMgaW5cbiAgRnVuLnByb3RlY3QgfmZpbmFsbHk6KGZ1biAoKSAtPiBTdGRsaWIuY2xvc2Vfb3V0X25vZXJyIG9jKVxuICAgIChmdW4gKCkgLT4gZiBvYylcblxubGV0IHdpdGhfb3Blbl9iaW4gcyBmID1cbiAgd2l0aF9vcGVuIFN0ZGxpYi5vcGVuX291dF9iaW4gcyBmXG5cbmxldCB3aXRoX29wZW5fdGV4dCBzIGYgPVxuICB3aXRoX29wZW4gU3RkbGliLm9wZW5fb3V0IHMgZlxuXG5sZXQgd2l0aF9vcGVuX2dlbiBmbGFncyBwZXJtIHMgZiA9XG4gIHdpdGhfb3BlbiAoU3RkbGliLm9wZW5fb3V0X2dlbiBmbGFncyBwZXJtKSBzIGZcblxubGV0IHNlZWsgPSBTdGRsaWIuTGFyZ2VGaWxlLnNlZWtfb3V0XG5sZXQgcG9zID0gU3RkbGliLkxhcmdlRmlsZS5wb3Nfb3V0XG5sZXQgbGVuZ3RoID0gU3RkbGliLkxhcmdlRmlsZS5vdXRfY2hhbm5lbF9sZW5ndGhcbmxldCBjbG9zZSA9IFN0ZGxpYi5jbG9zZV9vdXRcbmxldCBjbG9zZV9ub2VyciA9IFN0ZGxpYi5jbG9zZV9vdXRfbm9lcnJcbmxldCBmbHVzaCA9IFN0ZGxpYi5mbHVzaFxubGV0IGZsdXNoX2FsbCA9IFN0ZGxpYi5mbHVzaF9hbGxcbmxldCBvdXRwdXRfY2hhciA9IFN0ZGxpYi5vdXRwdXRfY2hhclxubGV0IG91dHB1dF9ieXRlID0gU3RkbGliLm91dHB1dF9ieXRlXG5sZXQgb3V0cHV0X3N0cmluZyA9IFN0ZGxpYi5vdXRwdXRfc3RyaW5nXG5sZXQgb3V0cHV0X2J5dGVzID0gU3RkbGliLm91dHB1dF9ieXRlc1xubGV0IG91dHB1dCA9IFN0ZGxpYi5vdXRwdXRcbmxldCBvdXRwdXRfc3Vic3RyaW5nID0gU3RkbGliLm91dHB1dF9zdWJzdHJpbmdcbmxldCBzZXRfYmluYXJ5X21vZGUgPSBTdGRsaWIuc2V0X2JpbmFyeV9tb2RlX291dFxuXG5leHRlcm5hbCBzZXRfYnVmZmVyZWQgOiB0IC0+IGJvb2wgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZXRfYnVmZmVyZWRcIlxuXG5leHRlcm5hbCBpc19idWZmZXJlZCA6IHQgLT4gYm9vbCA9IFwiY2FtbF9tbF9pc19idWZmZXJlZFwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgIEtDIFNpdmFyYW1ha3Jpc2huYW4sIEluZGlhbiBJbnN0aXR1dGUgb2YgVGVjaG5vbG9neSwgTWFkcmFzICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDIxIEluZGlhbiBJbnN0aXR1dGUgb2YgVGVjaG5vbG9neSwgTWFkcmFzICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9IC4uXG5leHRlcm5hbCBwZXJmb3JtIDogJ2EgdCAtPiAnYSA9IFwiJXBlcmZvcm1cIlxuXG50eXBlIGV4biArPSBVbmhhbmRsZWQ6ICdhIHQgLT4gZXhuXG5leGNlcHRpb24gQ29udGludWF0aW9uX2FscmVhZHlfcmVzdW1lZFxuXG5sZXQgKCkgPVxuICBsZXQgcHJpbnRlciA9IGZ1bmN0aW9uXG4gICAgfCBVbmhhbmRsZWQgeCAtPlxuICAgICAgICBsZXQgbXNnID0gUHJpbnRmLnNwcmludGYgXCJTdGRsaWIuRWZmZWN0LlVuaGFuZGxlZCglcylcIlxuICAgICAgICAgICAgKFByaW50ZXhjLnN0cmluZ19vZl9leHRlbnNpb25fY29uc3RydWN0b3IgQEAgT2JqLnJlcHIgeClcbiAgICAgICAgaW5cbiAgICAgICAgU29tZSBtc2dcbiAgICB8IF8gLT4gTm9uZVxuICBpblxuICBQcmludGV4Yy5yZWdpc3Rlcl9wcmludGVyIHByaW50ZXJcblxuKCogUmVnaXN0ZXIgdGhlIGV4Y2VwdGlvbnMgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gYWNjZXNzIGl0ICopXG50eXBlIF8gdCArPSBTaG91bGRfbm90X3NlZV90aGlzX18gOiB1bml0IHRcbmxldCBfID0gQ2FsbGJhY2sucmVnaXN0ZXJfZXhjZXB0aW9uIFwiRWZmZWN0LlVuaGFuZGxlZFwiXG4gICAgICAgICAgKFVuaGFuZGxlZCBTaG91bGRfbm90X3NlZV90aGlzX18pXG5sZXQgXyA9IENhbGxiYWNrLnJlZ2lzdGVyX2V4Y2VwdGlvbiBcIkVmZmVjdC5Db250aW51YXRpb25fYWxyZWFkeV9yZXN1bWVkXCJcbiAgICAgICAgICBDb250aW51YXRpb25fYWxyZWFkeV9yZXN1bWVkXG5cbnR5cGUgKCdhLCAnYikgc3RhY2tcblxuZXh0ZXJuYWwgcmVzdW1lIDogKCdhLCAnYikgc3RhY2sgLT4gKCdjIC0+ICdhKSAtPiAnYyAtPiAnYiA9IFwiJXJlc3VtZVwiXG5leHRlcm5hbCBydW5zdGFjayA6ICgnYSwgJ2IpIHN0YWNrIC0+ICgnYyAtPiAnYSkgLT4gJ2MgLT4gJ2IgPSBcIiVydW5zdGFja1wiXG5cbm1vZHVsZSBEZWVwID0gc3RydWN0XG5cbiAgdHlwZSAoJ2EsJ2IpIGNvbnRpbnVhdGlvblxuICB0eXBlIGxhc3RfZmliZXJcblxuICBleHRlcm5hbCB0YWtlX2NvbnRfbm9leGMgOiAoJ2EsICdiKSBjb250aW51YXRpb24gLT4gKCdhLCAnYikgc3RhY2sgPVxuICAgIFwiY2FtbF9jb250aW51YXRpb25fdXNlX25vZXhjXCIgW0BAbm9hbGxvY11cbiAgZXh0ZXJuYWwgYWxsb2Nfc3RhY2sgOlxuICAgICgnYSAtPiAnYikgLT5cbiAgICAoZXhuIC0+ICdiKSAtPlxuICAgICgnYyB0IC0+ICgnYywgJ2IpIGNvbnRpbnVhdGlvbiAtPiBsYXN0X2ZpYmVyIC0+ICdiKSAtPlxuICAgICgnYSwgJ2IpIHN0YWNrID0gXCJjYW1sX2FsbG9jX3N0YWNrXCJcblxuICBsZXQgY29udGludWUgayB2ID0gcmVzdW1lICh0YWtlX2NvbnRfbm9leGMgaykgKGZ1biB4IC0+IHgpIHZcblxuICBsZXQgZGlzY29udGludWUgayBlID0gcmVzdW1lICh0YWtlX2NvbnRfbm9leGMgaykgKGZ1biBlIC0+IHJhaXNlIGUpIGVcblxuICBsZXQgZGlzY29udGludWVfd2l0aF9iYWNrdHJhY2UgayBlIGJ0ID0gcmVzdW1lICh0YWtlX2NvbnRfbm9leGMgaykgKGZ1biBlIC0+XG4gICAgUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2UgZSBidCkgZVxuXG4gIHR5cGUgKCdhLCdiKSBoYW5kbGVyID1cbiAgICB7IHJldGM6ICdhIC0+ICdiO1xuICAgICAgZXhuYzogZXhuIC0+ICdiO1xuICAgICAgZWZmYzogJ2MuJ2MgdCAtPiAoKCdjLCdiKSBjb250aW51YXRpb24gLT4gJ2IpIG9wdGlvbiB9XG5cbiAgZXh0ZXJuYWwgcmVwZXJmb3JtIDpcbiAgICAnYSB0IC0+ICgnYSwgJ2IpIGNvbnRpbnVhdGlvbiAtPiBsYXN0X2ZpYmVyIC0+ICdiID0gXCIlcmVwZXJmb3JtXCJcblxuICBsZXQgbWF0Y2hfd2l0aCBjb21wIGFyZyBoYW5kbGVyID1cbiAgICBsZXQgZWZmYyBlZmYgayBsYXN0X2ZpYmVyID1cbiAgICAgIG1hdGNoIGhhbmRsZXIuZWZmYyBlZmYgd2l0aFxuICAgICAgfCBTb21lIGYgLT4gZiBrXG4gICAgICB8IE5vbmUgLT4gcmVwZXJmb3JtIGVmZiBrIGxhc3RfZmliZXJcbiAgICBpblxuICAgIGxldCBzID0gYWxsb2Nfc3RhY2sgaGFuZGxlci5yZXRjIGhhbmRsZXIuZXhuYyBlZmZjIGluXG4gICAgcnVuc3RhY2sgcyBjb21wIGFyZ1xuXG4gIHR5cGUgJ2EgZWZmZWN0X2hhbmRsZXIgPVxuICAgIHsgZWZmYzogJ2IuICdiIHQgLT4gKCgnYiwnYSkgY29udGludWF0aW9uIC0+ICdhKSBvcHRpb24gfVxuXG4gIGxldCB0cnlfd2l0aCBjb21wIGFyZyBoYW5kbGVyID1cbiAgICBsZXQgZWZmYycgZWZmIGsgbGFzdF9maWJlciA9XG4gICAgICBtYXRjaCBoYW5kbGVyLmVmZmMgZWZmIHdpdGhcbiAgICAgIHwgU29tZSBmIC0+IGYga1xuICAgICAgfCBOb25lIC0+IHJlcGVyZm9ybSBlZmYgayBsYXN0X2ZpYmVyXG4gICAgaW5cbiAgICBsZXQgcyA9IGFsbG9jX3N0YWNrIChmdW4geCAtPiB4KSAoZnVuIGUgLT4gcmFpc2UgZSkgZWZmYycgaW5cbiAgICBydW5zdGFjayBzIGNvbXAgYXJnXG5cbiAgZXh0ZXJuYWwgZ2V0X2NhbGxzdGFjayA6XG4gICAgKCdhLCdiKSBjb250aW51YXRpb24gLT4gaW50IC0+IFByaW50ZXhjLnJhd19iYWNrdHJhY2UgPVxuICAgIFwiY2FtbF9nZXRfY29udGludWF0aW9uX2NhbGxzdGFja1wiXG5lbmRcblxubW9kdWxlIFNoYWxsb3cgPSBzdHJ1Y3RcblxuICB0eXBlICgnYSwnYikgY29udGludWF0aW9uXG4gIHR5cGUgbGFzdF9maWJlclxuXG4gIGV4dGVybmFsIGFsbG9jX3N0YWNrIDpcbiAgICAoJ2EgLT4gJ2IpIC0+XG4gICAgKGV4biAtPiAnYikgLT5cbiAgICAoJ2MgdCAtPiAoJ2MsICdiKSBjb250aW51YXRpb24gLT4gbGFzdF9maWJlciAtPiAnYikgLT5cbiAgICAoJ2EsICdiKSBzdGFjayA9IFwiY2FtbF9hbGxvY19zdGFja1wiXG5cblxuICBsZXQgZmliZXIgOiB0eXBlIGEgYi4gKGEgLT4gYikgLT4gKGEsIGIpIGNvbnRpbnVhdGlvbiA9IGZ1biBmIC0+XG4gICAgbGV0IG1vZHVsZSBNID0gc3RydWN0IHR5cGUgXyB0ICs9IEluaXRpYWxfc2V0dXBfXyA6IGEgdCBlbmQgaW5cbiAgICBsZXQgZXhjZXB0aW9uIEUgb2YgKGEsYikgY29udGludWF0aW9uIGluXG4gICAgbGV0IGYnICgpID0gZiAocGVyZm9ybSBNLkluaXRpYWxfc2V0dXBfXykgaW5cbiAgICBsZXQgZXJyb3IgXyA9IGZhaWx3aXRoIFwiaW1wb3NzaWJsZVwiIGluXG4gICAgbGV0IGVmZmMgZWZmIGsgX2xhc3RfZmliZXIgPVxuICAgICAgbWF0Y2ggZWZmIHdpdGhcbiAgICAgIHwgTS5Jbml0aWFsX3NldHVwX18gLT4gcmFpc2Vfbm90cmFjZSAoRSBrKVxuICAgICAgfCBfIC0+IGVycm9yICgpXG4gICAgaW5cbiAgICBsZXQgcyA9IGFsbG9jX3N0YWNrIGVycm9yIGVycm9yIGVmZmMgaW5cbiAgICBtYXRjaCBydW5zdGFjayBzIGYnICgpIHdpdGhcbiAgICB8IGV4Y2VwdGlvbiBFIGsgLT4ga1xuICAgIHwgXyAtPiBlcnJvciAoKVxuXG4gIHR5cGUgKCdhLCdiKSBoYW5kbGVyID1cbiAgICB7IHJldGM6ICdhIC0+ICdiO1xuICAgICAgZXhuYzogZXhuIC0+ICdiO1xuICAgICAgZWZmYzogJ2MuJ2MgdCAtPiAoKCdjLCdhKSBjb250aW51YXRpb24gLT4gJ2IpIG9wdGlvbiB9XG5cbiAgZXh0ZXJuYWwgdXBkYXRlX2hhbmRsZXIgOlxuICAgICgnYSwnYikgY29udGludWF0aW9uIC0+XG4gICAgKCdiIC0+ICdjKSAtPlxuICAgIChleG4gLT4gJ2MpIC0+XG4gICAgKCdkIHQgLT4gKCdkLCdiKSBjb250aW51YXRpb24gLT4gbGFzdF9maWJlciAtPiAnYykgLT5cbiAgICAoJ2EsJ2MpIHN0YWNrID0gXCJjYW1sX2NvbnRpbnVhdGlvbl91c2VfYW5kX3VwZGF0ZV9oYW5kbGVyX25vZXhjXCIgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCByZXBlcmZvcm0gOlxuICAgICdhIHQgLT4gKCdhLCAnYikgY29udGludWF0aW9uIC0+IGxhc3RfZmliZXIgLT4gJ2MgPSBcIiVyZXBlcmZvcm1cIlxuXG4gIGxldCBjb250aW51ZV9nZW4gayByZXN1bWVfZnVuIHYgaGFuZGxlciA9XG4gICAgbGV0IGVmZmMgZWZmIGsgbGFzdF9maWJlciA9XG4gICAgICBtYXRjaCBoYW5kbGVyLmVmZmMgZWZmIHdpdGhcbiAgICAgIHwgU29tZSBmIC0+IGYga1xuICAgICAgfCBOb25lIC0+IHJlcGVyZm9ybSBlZmYgayBsYXN0X2ZpYmVyXG4gICAgaW5cbiAgICBsZXQgc3RhY2sgPSB1cGRhdGVfaGFuZGxlciBrIGhhbmRsZXIucmV0YyBoYW5kbGVyLmV4bmMgZWZmYyBpblxuICAgIHJlc3VtZSBzdGFjayByZXN1bWVfZnVuIHZcblxuICBsZXQgY29udGludWVfd2l0aCBrIHYgaGFuZGxlciA9XG4gICAgY29udGludWVfZ2VuIGsgKGZ1biB4IC0+IHgpIHYgaGFuZGxlclxuXG4gIGxldCBkaXNjb250aW51ZV93aXRoIGsgdiBoYW5kbGVyID1cbiAgICBjb250aW51ZV9nZW4gayAoZnVuIGUgLT4gcmFpc2UgZSkgdiBoYW5kbGVyXG5cbiAgbGV0IGRpc2NvbnRpbnVlX3dpdGhfYmFja3RyYWNlIGsgdiBidCBoYW5kbGVyID1cbiAgICBjb250aW51ZV9nZW4gayAoZnVuIGUgLT4gUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2UgZSBidCkgdiBoYW5kbGVyXG5cbiAgZXh0ZXJuYWwgZ2V0X2NhbGxzdGFjayA6XG4gICAgKCdhLCdiKSBjb250aW51YXRpb24gLT4gaW50IC0+IFByaW50ZXhjLnJhd19iYWNrdHJhY2UgPVxuICAgIFwiY2FtbF9nZXRfY29udGludWF0aW9uX2NhbGxzdGFja1wiXG5lbmRcbiIsIigqKiBHaXZlIGludGVnZXIgbmFtZXMuICopXG5sZXQgbmFtZXIgZXEgPVxuICBsZXQgbiA9IHJlZiAwIGluXG4gIGxldCBuYW1lcyA9IHJlZiBbXSBpblxuICBmdW4gZSAtPlxuICAgIGlmIG5vdCAoTGlzdC5leGlzdHMgKGZ1biAoZScsXykgLT4gZXEgZSBlJykgIW5hbWVzKSB0aGVuXG4gICAgICAoXG4gICAgICAgIG5hbWVzIDo9IChlLCFuKSA6OiAhbmFtZXM7XG4gICAgICAgIGluY3IgblxuICAgICAgKTtcbiAgICBzbmQgKExpc3QuZmluZCAoZnVuIChlJyxfKSAtPiBlcSBlIGUnKSAhbmFtZXMpXG5cbiIsIigqKiBBbHBoYWJldHMuICopXG5cbigqKiBBbiBhbHBoYWJldCBpcyBzaW1wbHkgYW5vdGhlciBuYW1lIGZvciBhIHNldCwgYnV0IHRoZSBtb2R1bGUgW1NldF0gYWxyZWFkeVxuICAgIGV4aXN0cy4gKilcblxuKCoqIEFuIGFscGhhYmV0LiAqKVxubW9kdWxlIHR5cGUgVCA9IHNpZ1xuICAoKiogQSBsZXR0ZXIuICopXG4gIHR5cGUgdFxuXG4gIHZhbCBlcSA6IHQgLT4gdCAtPiBib29sXG5cbiAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG5cbiAgdmFsIGNvbXBhcmUgOiB0IC0+IHQgLT4gaW50XG5lbmRcblxuKCoqIFRoZSBhbHBoYWJldCBvZiBjaGFyYWN0ZXJzLiAqKVxubW9kdWxlIENoYXIgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gY2hhclxuXG4gIGxldCBlcSBjIGQgPSAoYzpjaGFyKSA9IChkOmNoYXIpXG5cbiAgbGV0IHRvX3N0cmluZyBjID0gU3RyaW5nLm1ha2UgMSBjXG5cbiAgbGV0IGNvbXBhcmUgYyBkID0gY29tcGFyZSAoYzpjaGFyKSAoZDpjaGFyKVxuXG4gIGxldCBsZXEgYyBkID0gKGM6Y2hhcikgPD0gKGQ6Y2hhcilcblxuICBsZXQgZ2VxIGMgZCA9IChjOmNoYXIpID49IChkOmNoYXIpXG5lbmRcbm1vZHVsZSBDaGFyQWxwaGFiZXQgOiAoVCB3aXRoIHR5cGUgdCA9IGNoYXIpID0gQ2hhclxuXG4oKiBCYWNrdXAgc2luY2Ugd2UgbmVlZCBpdCBhZnRlcndhcmQuICopXG5tb2R1bGUgU3RyID0gU3RyaW5nXG5cbm1vZHVsZSBTdHJpbmcgOiAoVCB3aXRoIHR5cGUgdCA9IHN0cmluZykgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gc3RyaW5nXG4gIGxldCBlcSBzIHQgPSAoczpzdHJpbmcpID0gKHQ6c3RyaW5nKVxuXG4gIGxldCB0b19zdHJpbmcgcyA9IHNcblxuICBsZXQgY29tcGFyZSBzICB0ID0gY29tcGFyZSAoczpzdHJpbmcpICh0OnN0cmluZylcbmVuZFxuXG4oKiogVGhlIGFscGhhYmV0IG9mIGludGVnZXJzLiAqKVxubW9kdWxlIEludCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcbiAgbGV0IGVxIGkgaiA9IChpOmludCkgPSAoajppbnQpXG5cbiAgbGV0IHRvX3N0cmluZyA9IHN0cmluZ19vZl9pbnRcblxuICBsZXQgY29tcGFyZSBpIGogPSBjb21wYXJlIChpOmludCkgKGo6aW50KVxuXG4gIGxldCBsZXEgaSBqID0gKGk6aW50KSA8PSAoajppbnQpXG5cbiAgbGV0IGdlcSBpIGogPSAoaTppbnQpID49IChqOmludClcbmVuZFxubW9kdWxlIEludEFscGhhYmV0IDogKFQgd2l0aCB0eXBlIHQgPSBpbnQpID0gSW50XG5cbigqKiBUaGUgYWxwaGFiZXQgd2l0aCBvbmUgZWxlbWVudC4gKilcbm1vZHVsZSBVbml0IDogVCB3aXRoIHR5cGUgdCA9IHVuaXQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gdW5pdFxuXG4gIGxldCBlcSAoKSAoKSA9IHRydWVcblxuICBsZXQgY29tcGFyZSAoKSAoKSA9IDBcblxuICBsZXQgdG9fc3RyaW5nICgpID0gXCIqXCJcbmVuZFxuXG4oKiogUHJvZHVjdCBvZiBhbHBoYWJldHMuICopXG5tb2R1bGUgUHJvZCAoQTpUKSAoQjpUKSA6IChUIHdpdGggdHlwZSB0ID0gQS50ICogQi50KSA9IHN0cnVjdFxuICB0eXBlIHQgPSBBLnQgKiBCLnRcblxuICBsZXQgZXEgKGEsYikgKGEnLGInKSA9XG4gICAgQS5lcSBhIGEnICYmIEIuZXEgYiBiJ1xuXG4gIGxldCBjb21wYXJlIChhLGIpIChhJyxiJykgPVxuICAgIGxldCBjID0gQS5jb21wYXJlIGEgYScgaW5cbiAgICBpZiBjID0gMCB0aGVuIEIuY29tcGFyZSBiIGInXG4gICAgZWxzZSBjXG5cbiAgbGV0IHRvX3N0cmluZyAoYSxiKSA9XG4gICAgXCIoXCIgXiBBLnRvX3N0cmluZyBhIF4gXCIsXCIgXiBCLnRvX3N0cmluZyBiIF4gXCIpXCJcbmVuZFxuXG4oKiogVHJpcGxlIHByb2R1Y3Qgb2YgYWxwaGFiZXRzLiAqKVxubW9kdWxlIFByb2QzIChBOlQpIChCOlQpIChDOlQpIDogKFQgd2l0aCB0eXBlIHQgPSBBLnQgKiBCLnQgKiBDLnQpID0gc3RydWN0XG4gIHR5cGUgdCA9IEEudCAqIEIudCAqIEMudFxuXG4gIGxldCBlcSAoYSxiLGMpIChhJyxiJyxjJykgPVxuICAgIEEuZXEgYSBhJyAmJiBCLmVxIGIgYicgJiYgQy5lcSBjIGMnXG5cbiAgbGV0IGNvbXBhcmUgKGEsYixjKSAoYScsYicsYycpID1cbiAgICBsZXQgY29tcCA9IEEuY29tcGFyZSBhIGEnIGluXG4gICAgaWYgY29tcCA8PiAwIHRoZW4gY29tcCBlbHNlXG4gICAgICBsZXQgY29tcCA9IEIuY29tcGFyZSBiIGInIGluXG4gICAgICBpZiBjb21wIDw+IDAgdGhlbiBjb21wIGVsc2VcbiAgICAgICAgQy5jb21wYXJlIGMgYydcblxuICBsZXQgdG9fc3RyaW5nIChhLGIsYykgPVxuICAgIFwiKFwiIF4gQS50b19zdHJpbmcgYSBeIFwiLFwiIF4gQi50b19zdHJpbmcgYiBeIFwiLFwiIF4gQy50b19zdHJpbmcgYyBeIFwiKVwiXG5lbmRcblxuKCoqIFBvd2Vyc2V0LiAqKVxubW9kdWxlIFBvdyAoQTpUKSA9IHN0cnVjdFxuICBtb2R1bGUgUyA9IFNldC5NYWtlKEEpXG4gIHR5cGUgdCA9IFMudFxuICBsZXQgZXEgKHU6dCkgKHY6dCkgPSBTLmVxdWFsIHUgdlxuICBsZXQgY29tcGFyZSAodTp0KSAodjp0KSA9IFMuY29tcGFyZSB1IHZcbiAgbGV0IHRvX3N0cmluZyAodTp0KSA9XG4gICAgbGV0IHMgPSBTLmZvbGQgKGZ1biB4IHMgLT4gaWYgcyA9IFwiXCIgdGhlbiBBLnRvX3N0cmluZyB4IGVsc2UgcyBeIFwiLFwiIF4gQS50b19zdHJpbmcgeCkgdSBcIlwiIGluXG4gICAgXCJ7XCIgXiBzIF4gXCJ9XCJcbiAgbGV0IGVtcHR5IDogdCA9IFMuZW1wdHlcbiAgbGV0IG9mX2xpc3QgbCA6IHQgPSBTLm9mX2xpc3QgbFxuICBsZXQgYWRkICh1OnQpICh4OkEudCkgPSBTLmFkZCB4IHVcbiAgbGV0IG1lbSAodTp0KSAoeDpBLnQpID0gUy5tZW0geCB1XG4gIGxldCBpdGVyIChmOkEudC0+dW5pdCkgKHU6dCkgPSBTLml0ZXIgZiB1XG5lbmRcbm1vZHVsZSBQb3dBbHBoYWJldCAoQTpUKSA6IFQgPSBQb3coQSlcblxuKCoqIEZyZWUgbW9ub2lkIG1vbmFkLiAqKVxubW9kdWxlIExpc3QgKEE6VCkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gQS50IGxpc3RcblxuICBsZXQgZXEgdSB2ID1cbiAgICB0cnlcbiAgICAgIExpc3QuZm9yX2FsbDIgKGZ1biB4IHkgLT4gQS5lcSB4IHkpIHUgdlxuICAgIHdpdGhcbiAgICB8IEludmFsaWRfYXJndW1lbnQgXyAtPiBmYWxzZVxuXG4gIGxldCB0b19zdHJpbmcgdSA9XG4gICAgU3RyLmNvbmNhdCBcIlwiIChMaXN0Lm1hcCBBLnRvX3N0cmluZyB1KVxuXG4gIGxldCByZWMgY29tcGFyZSB1IHYgPVxuICAgIG1hdGNoIHUsdiB3aXRoXG4gICAgfCB4Ojp1LCB5Ojp2IC0+XG4gICAgICAgbGV0IGMgPSBBLmNvbXBhcmUgeCB5IGluXG4gICAgICAgaWYgYyA8PiAwIHRoZW4gYyBlbHNlIGNvbXBhcmUgdSB2XG4gICAgfCBbXSwgW10gLT4gMFxuICAgIHwgW10sIF8gLT4gLTFcbiAgICB8IF8sIFtdIC0+IDFcbmVuZFxubW9kdWxlIExpc3RBbHBoYWJldCAoQTpUKSA6IFQgPSBMaXN0KEEpXG5cbigqKiBGdW5jdGlvbnMgYmV0d2VlbiBhbHBoYWJldHMuICopXG5tb2R1bGUgTWFwIChBOlQpIChCOlQpID0gc3RydWN0XG4gIG1vZHVsZSBNID0gTWFwLk1ha2UoQSlcblxuICB0eXBlIHQgPSBCLnQgTS50XG5cbiAgbGV0IGVtcHR5IDogdCA9IE0uZW1wdHlcblxuICBsZXQgYXBwIChmOnQpICh4OkEudCkgPSBNLmZpbmQgeCBmXG5cbiAgbGV0IGFkZCAoZjp0KSAoeDpBLnQpIHYgOiB0ID0gTS5hZGQgeCB2IGZcblxuICAoKiogSXMgYW4gZWxlbWVudCBpbiB0aGUgZG9tYWluPyAqKVxuICBsZXQgbWVtIChmOnQpICh4OkEudCkgPSBNLm1lbSB4IGZcblxuICBsZXQgaXRlciA9IE0uaXRlclxuZW5kXG4iLCJsZXQgcGFpciB4IHkgPSB4LCB5XG5cbmxldCB1bnBhaXIgZiAoeCx5KSA9IGYgeCB5XG5cbm1vZHVsZSBJbnQgPSBzdHJ1Y3RcbiAgbGV0IG1vZHVsbyB4IHkgPVxuICAgIGxldCBhbnMgPSB4IG1vZCB5IGluXG4gICAgaWYgYW5zID49IDAgdGhlbiBhbnNcbiAgICBlbHNlIGFucyArIHlcbmVuZFxuXG5tb2R1bGUgTGlzdCA9IHN0cnVjdFxuICBpbmNsdWRlIExpc3RcblxuICAoKiogRmlyc3QgaW5kZXggd2hlcmUgYSBwcmVkaWNhdGUgaXMgc2F0aXNmaWVkLiAqKVxuICBsZXQgaW5kZXggcCBsID1cbiAgICBsZXQgcmVjIGF1eCBuID0gZnVuY3Rpb25cbiAgICAgIHwgeDo6bCAtPiBpZiBwIHggdGhlbiBuIGVsc2UgYXV4IChuKzEpIGxcbiAgICAgIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgaW5cbiAgICBhdXggMCBsXG5cbiAgKCoqIFJlcGxhY2UgdGhlIG50aCBlbGVtZW50IG9mIGEgbGlzdC4gKilcbiAgbGV0IHJlcGxhY2VfbnRoIGwgbiB4ID1cbiAgICBsZXQgcmVjIGF1eCBuIGsgPSBmdW5jdGlvblxuICAgICAgfCB5OjpsIC0+XG4gICAgICAgIGlmIG4gPSAwIHRoZW4gayAoeDo6bClcbiAgICAgICAgZWxzZSBhdXggKG4tMSkgKGZ1biBsIC0+IGsgKHk6OmwpKSBsXG4gICAgICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgIGluXG4gICAgYXV4IG4gRnVuLmlkIGxcblxuICBsZXQgcmVwbGFjZV9hc3NvYyBrIHYgbCA9XG4gICAgTGlzdC5tYXAgKGZ1biAoaycsdicpIC0+IGlmIGsgPSBrJyB0aGVuIGssIHYgZWxzZSBrJywgdicpIGxcblxuICBsZXQgcmVjIHN1YiBsIG9mcyBsZW4gPVxuICAgIGlmIG9mcyA9IDAgJiYgbGVuID0gMCB0aGVuIFtdXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IHg6OmwgLT5cbiAgICAgICAgaWYgb2ZzID0gMCB0aGVuIHg6OihzdWIgbCBvZnMgKGxlbi0xKSlcbiAgICAgICAgZWxzZSBzdWIgbCAob2ZzLTEpIGxlblxuICAgICAgfCBbXSAtPiBpbnZhbGlkX2FyZyBcIkxpc3Quc3ViXCJcbmVuZFxuXG5tb2R1bGUgU3RyaW5nID0gc3RydWN0XG4gIGluY2x1ZGUgU3RyaW5nXG5cbiAgbGV0IHN1YnNjcmlwdCBzID1cbiAgICBTdHJpbmcuZm9sZF9sZWZ0XG4gICAgICAoZnVuIHMgLT4gZnVuY3Rpb25cbiAgICAgICAgIHwgJzAnIC0+IFwi4oKAXCJcbiAgICAgICAgIHwgJzEnIC0+IFwi4oKBXCJcbiAgICAgICAgIHwgJzInIC0+IFwi4oKCXCJcbiAgICAgICAgIHwgJzMnIC0+IFwi4oKDXCJcbiAgICAgICAgIHwgJzQnIC0+IFwi4oKEXCJcbiAgICAgICAgIHwgJzUnIC0+IFwi4oKFXCJcbiAgICAgICAgIHwgJzYnIC0+IFwi4oKGXCJcbiAgICAgICAgIHwgJzcnIC0+IFwi4oKHXCJcbiAgICAgICAgIHwgJzgnIC0+IFwi4oKIXCJcbiAgICAgICAgIHwgJzknIC0+IFwi4oKJXCJcbiAgICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICkgXCJcIiBzXG5cbiAgbGV0IHN1cGVyc2NyaXB0IHMgPVxuICAgIFN0cmluZy5mb2xkX2xlZnRcbiAgICAgIChmdW4gcyAtPiBmdW5jdGlvblxuICAgICAgICAgfCAnMCcgLT4gXCLigbBcIlxuICAgICAgICAgfCAnMScgLT4gXCLCuVwiXG4gICAgICAgICB8ICcyJyAtPiBcIsKyXCJcbiAgICAgICAgIHwgJzMnIC0+IFwiwrNcIlxuICAgICAgICAgfCAnNCcgLT4gXCLigbRcIlxuICAgICAgICAgfCAnNScgLT4gXCLigbVcIlxuICAgICAgICAgfCAnNicgLT4gXCLigbZcIlxuICAgICAgICAgfCAnNycgLT4gXCLigbdcIlxuICAgICAgICAgfCAnOCcgLT4gXCLigbhcIlxuICAgICAgICAgfCAnOScgLT4gXCLigblcIlxuICAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgKSBcIlwiIHNcbiAgXG4gICgqKiBGaW5kIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG1hdGNoaW5nIGEgcHJlZGljYXRlLiAqKVxuICBsZXQgZmluZCBwIHMgPVxuICAgIGxldCBhbnMgPSByZWYgKC0xKSBpblxuICAgIHRyeVxuICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgICAgaWYgcCBzLltpXSB0aGVuXG4gICAgICAgICAgKFxuICAgICAgICAgICAgYW5zIDo9IGk7XG4gICAgICAgICAgICByYWlzZSBFeGl0XG4gICAgICAgICAgKVxuICAgICAgZG9uZTtcbiAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgIHdpdGhcbiAgICB8IEV4aXQgLT4gIWFuc1xuXG4gIGxldCByZWMgc3BsaXRfb25fcHJlZGljYXRlIHAgcyA9XG4gICAgdHJ5XG4gICAgICBsZXQgbiA9IGZpbmQgcCBzIGluXG4gICAgICAoU3RyaW5nLnN1YiBzIDAgbik6OihzcGxpdF9vbl9wcmVkaWNhdGUgcCAoU3RyaW5nLnN1YiBzIChuKzEpIChTdHJpbmcubGVuZ3RoIHMgLSAobisxKSkpKVxuICAgIHdpdGggTm90X2ZvdW5kIC0+IFtzXVxuZW5kXG4iLCIoKiogUmluZ3MuICopXG5cbigqKiBBIHJpbmcuICopXG5tb2R1bGUgdHlwZSBUID0gc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBlcSA6IHQgLT4gdCAtPiBib29sXG5cbiAgdmFsIGFkZCA6IHQgLT4gdCAtPiB0XG5cbiAgdmFsIHplcm8gOiB0XG5cbiAgdmFsIG5lZyA6IHQgLT4gdFxuXG4gIHZhbCBtdWwgOiB0IC0+IHQgLT4gdFxuXG4gIHZhbCBvbmUgOiB0XG5cbiAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG5lbmRcblxuKCoqIEFuIGV1Y2xpZGVhbiBkb21haW4uICopXG5tb2R1bGUgdHlwZSBFdWNsaWRlYW4gPSBzaWdcbiAgaW5jbHVkZSBUXG5cbiAgdmFsIGRpdiA6IHQgLT4gdCAtPiAodCAqIHQpXG5lbmRcblxuKCoqIFRoZSByaW5nIG9mIGJvb2xlYW5zLiAqKVxubW9kdWxlIEJvb2wgOiAoVCB3aXRoIHR5cGUgdCA9IGJvb2wpID0gc3RydWN0XG4gIHR5cGUgdCA9IGJvb2xcblxuICBsZXQgZXEgeCB5ID0gKHg6Ym9vbCkgPSAoeTpib29sKVxuXG4gIGxldCBhZGQgeCB5ID0gKHggfHwgeSkgJiYgbm90ICh4ICYmIHkpXG5cbiAgbGV0IHplcm8gPSBmYWxzZVxuXG4gIGxldCBuZWcgeCA9IHhcblxuICBsZXQgbXVsIHggeSA9IHggJiYgeVxuXG4gIGxldCBvbmUgPSB0cnVlXG5cbiAgbGV0IHRvX3N0cmluZyB4ID1cbiAgICBpZiB4IHRoZW4gXCJUXCIgZWxzZSBcIkZcIlxuZW5kXG5cbigqKiBUaGUgcmluZyBvZiBpbnRlZ2Vycy4gKilcbm1vZHVsZSBJbnQgOiAoVCB3aXRoIHR5cGUgdCA9IGludCkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50XG5cbiAgbGV0IGVxIHggeSA9ICh4OmludCkgPSAoeTppbnQpXG5cbiAgbGV0IGFkZCA9ICggKyApXG5cbiAgbGV0IHplcm8gPSAwXG5cbiAgbGV0IG5lZyB4ID0gLSB4XG5cbiAgbGV0IG11bCA9ICggKiApXG5cbiAgbGV0IG9uZSA9IDFcblxuICBsZXQgdG9fc3RyaW5nID0gc3RyaW5nX29mX2ludFxuZW5kXG5cbigqKiBUaGUgcmluZyBvZiBmbG9hdHMuICopXG5tb2R1bGUgRmxvYXQgOiAoVCB3aXRoIHR5cGUgdCA9IGZsb2F0KSA9IHN0cnVjdFxuICB0eXBlIHQgPSBmbG9hdFxuXG4gIGxldCBlcSAoeDp0KSAoeTp0KSA9IHggPSB5XG5cbiAgbGV0IGFkZCA9ICggKy4gKVxuXG4gIGxldCB6ZXJvID0gMC5cblxuICBsZXQgbmVnIHggPSAtLiB4XG5cbiAgbGV0IG11bCA9ICggKi4gKVxuXG4gIGxldCBvbmUgPSAxLlxuXG4gIGxldCB0b19zdHJpbmcgPSBzdHJpbmdfb2ZfZmxvYXRcbmVuZFxuXG4oKiogUG9seW5vbWlhbCByaW5nIG92ZXIgYSByaW5nLiAqKVxubW9kdWxlIFBvbHlub21pYWwgKFIgOiBUKSA9IHN0cnVjdFxuICAoKiogQSBwb2x5bm9taWFsLiAqKVxuICB0eXBlIHQgPSBSLnQgYXJyYXlcblxuICBsZXQgbGVuZ3RoIChwOnQpID0gQXJyYXkubGVuZ3RoIHBcblxuICAoKiogRGVncmVlIG9mIGEgcG9seW5vbWlhbC4gKilcbiAgbGV0IGRlZ3JlZSAocDp0KSA9XG4gICAgbGV0IGFucyA9IHJlZiAwIGluXG4gICAgdHJ5XG4gICAgICBmb3IgaSA9IGxlbmd0aCBwIC0gMSBkb3dudG8gMCBkb1xuICAgICAgICBpZiBub3QgKFIuZXEgUi56ZXJvIHAuKGkpKSB0aGVuXG4gICAgICAgICAgKFxuICAgICAgICAgICAgYW5zIDo9IGk7XG4gICAgICAgICAgICByYWlzZSBFeGl0XG4gICAgICAgICAgKVxuICAgICAgZG9uZTtcbiAgICAgIG1pbl9pbnRcbiAgICB3aXRoXG4gICAgfCBFeGl0IC0+ICFhbnNcblxuICBsZXQgZXEgKHA6dCkgKHE6dCkgPVxuICAgIGxldCBkcCA9IGRlZ3JlZSBwIGluXG4gICAgbGV0IGRxID0gZGVncmVlIHEgaW5cbiAgICB0cnlcbiAgICAgIGlmIGRwIDw+IGRxIHRoZW4gcmFpc2UgRXhpdDtcbiAgICAgIGZvciBpID0gMCB0byBkcCAtIDEgZG9cbiAgICAgICAgaWYgbm90IChSLmVxIHAuKGkpIHEuKGkpKSB0aGVuIHJhaXNlIEV4aXRcbiAgICAgICAgZG9uZTtcbiAgICAgICAgdHJ1ZVxuICAgIHdpdGhcbiAgICB8IEV4aXQgLT4gZmFsc2VcblxuICBsZXQgY29tcGFjdCBwIDogdCA9XG4gICAgQXJyYXkuaW5pdCAoZGVncmVlIHApIChmdW4gaSAtPiBwLihpKSlcblxuICBsZXQgY29lZmYgcCBpID1cbiAgICBpZiBpIDwgbGVuZ3RoIHAgdGhlbiBwLihpKSBlbHNlIFIuemVyb1xuXG4gIGxldCBpbml0IG4gZiA6IHQgPVxuICAgIEFycmF5LmluaXQgbiBmXG5cbiAgbGV0IHJlYyBhZGQgcCBxID1cbiAgICBsZXQgcGwgPSBsZW5ndGggcCBpblxuICAgIGxldCBxbCA9IGxlbmd0aCBxIGluXG4gICAgaWYgcGwgPiBxbCB0aGVuIGFkZCBxIHAgZWxzZVxuICAgICAgaW5pdCBxbCAoZnVuIGkgLT4gaWYgaSA8IHBsIHRoZW4gUi5hZGQgcC4oaSkgcS4oaSkgZWxzZSBxLihpKSlcblxuICBsZXQgemVybyA9IFt8fF1cblxuICBsZXQgY211bCBhIChwOnQpIDogdCA9XG4gICAgQXJyYXkubWFwIChSLm11bCBhKSBwXG5cbiAgbGV0IG5lZyBwID0gY211bCAoUi5uZWcgUi5vbmUpIHBcblxuICBsZXQgc3ViIHAgcSA9XG4gICAgYWRkIHAgKG5lZyBxKVxuXG4gIGxldCBtdWwgcCBxID1cbiAgICBpbml0IChkZWdyZWUgcCArIGRlZ3JlZSBxKSAoZnVuIG4gLT5cbiAgICAgIGxldCBhbnMgPSByZWYgUi56ZXJvIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbiBkb1xuICAgICAgICBhbnMgOj0gUi5hZGQgIWFucyAoUi5tdWwgKGNvZWZmIHAgaSkgKGNvZWZmIHEgKG4taSkpKVxuICAgICAgZG9uZTtcbiAgICAgICFhbnNcbiAgICApXG5cbiAgbGV0IG9uZSA9IFt8Ui5vbmV8XVxuXG4gIGxldCB0b19zdHJpbmcgKHA6dCkgPVxuICAgIGxldCBhbnMgPSByZWYgXCJcIiBpblxuICAgIGZvciBpID0gMCB0byBsZW5ndGggcCAtIDEgZG9cbiAgICAgIGFucyA6PSAhYW5zXG4gICAgICBeIChpZiBpIDw+IDAgdGhlbiBcIitcIiBlbHNlIFwiXCIpXG4gICAgICBeIChpZiBSLmVxIFIuemVybyBwLihpKSB0aGVuIFwiXCIgZWxzZSBSLnRvX3N0cmluZyBwLihpKSBeIGlmIGkgPSAwIHRoZW4gXCJcIiBlbHNlIChcIlheXCIgXiBzdHJpbmdfb2ZfaW50IGkpKVxuICAgIGRvbmU7XG4gICAgIWFuc1xuXG4gIGxldCBtb25vbWlhbCBjIG4gPVxuICAgIGxldCBhbnMgPSBBcnJheS5tYWtlIChuKzEpIFIuemVybyBpblxuICAgIGFucy4obikgPC0gYztcbiAgICBhbnNcbmVuZFxubW9kdWxlIFBvbHlub21pYWxSaW5nIChSIDogVCkgPSAoUG9seW5vbWlhbChSKSA6IFQpXG5cbigqKiBPcHBvc2l0ZSByaW5nLiAqKVxubW9kdWxlIE9wIChSIDogVCkgOiAoVCB3aXRoIHR5cGUgdCA9IFIudCkgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBSXG5cbiAgbGV0IG11bCB4IHkgPSBtdWwgeSB4XG5lbmRcbiIsIigqKiBGaWVsZHMuICopXG5cbigqKiBBIGZpZWxkLiAqKVxubW9kdWxlIHR5cGUgVCA9IHNpZ1xuICBpbmNsdWRlIFJpbmcuVFxuXG4gICgqKiBJbnZlcnNlLiAqKVxuICB2YWwgaW52IDogdCAtPiB0XG5lbmRcblxuKCoqIFRoZSBmaWVsZCB3aXRoIHR3byBlbGVtZW50cy4gKilcbm1vZHVsZSBCb29sIDogKFQgd2l0aCB0eXBlIHQgPSBib29sKSA9IHN0cnVjdFxuICBpbmNsdWRlIFJpbmcuQm9vbFxuXG4gIGxldCBpbnYgKHg6dCkgPSB4XG5lbmRcblxuKCoqIFRoZSBmaWVsZCBvZiBmbG9hdHMuICopXG5tb2R1bGUgRmxvYXQgOiAoVCB3aXRoIHR5cGUgdCA9IGZsb2F0KSA9IHN0cnVjdFxuICBpbmNsdWRlIFJpbmcuRmxvYXRcblxuICBsZXQgaW52ICh4OnQpIDogdCA9IDEuIC8uIHhcbmVuZFxuXG4oKiogVGhlIFwiZmllbGRcIiBvZiBpbnRlZ2Vycy4gKilcbm1vZHVsZSBJbnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBSaW5nLkludFxuXG4gIGxldCBpbnYgeCA9XG4gICAgaWYgZXEgb25lIHggdGhlbiBvbmVcbiAgICBlbHNlIGlmIGVxIChuZWcgb25lKSB4IHRoZW4gKG5lZyBvbmUpXG4gICAgZWxzZVxuICAgICAgZmFpbHdpdGggKFwiQ2Fubm90IGludmVydCBcIl5zdHJpbmdfb2ZfaW50IHheXCIuXCIpXG5lbmRcblxuKCoqIEZpZWxkIG9mIGZyYWN0aW9ucyBvdmVyIGFuIGV1Y2xpZGVhbiBkb21haW4uICopXG5tb2R1bGUgRnJhY3Rpb25zIChSIDogUmluZy5FdWNsaWRlYW4pID0gc3RydWN0XG4gIHR5cGUgdCA9IFIudCAqIFIudFxuXG4gICgqKiBHcmVhdGVzdCBjb21tb24gZGl2aXNvci4gKilcbiAgbGV0IHJlYyBnY2QgYSBiID1cbiAgICBsZXQgcmVtIGEgYiA9IHNuZCAoUi5kaXYgYSBiKSBpblxuICAgIGlmIFIuZXEgUi56ZXJvIGIgdGhlbiBhIGVsc2UgZ2NkIGIgKHJlbSBhIGIpXG5cbiAgbGV0IGNhbm9uaXplICgoYSxiKTp0KSA6IHQgPVxuICAgIGxldCBkID0gZ2NkIGEgYiBpblxuICAgIGxldCBhLF8gPSBSLmRpdiBhIGQgaW5cbiAgICBsZXQgYixfID0gUi5kaXYgYSBkIGluXG4gICAgKGEsYilcblxuICBsZXQgZXEgKChhLGIpOnQpICgoYyxkKTp0KSA9XG4gICAgbGV0IChhLGIpID0gY2Fub25pemUgKGEsYikgaW5cbiAgICBsZXQgKGMsZCkgPSBjYW5vbml6ZSAoYyxkKSBpblxuICAgIChSLmVxIGEgYyAmJiBSLmVxIGIgZCkgfHwgKFIuZXEgKFIubmVnIGEpIGMgJiYgUi5lcSAoUi5uZWcgYikgZClcblxuICBsZXQgYWRkICgoYSxiKTp0KSAoKGMsZCk6dCkgOiB0ID0gKFIuYWRkIChSLm11bCBhIGQpIChSLm11bCBiIGMpLCBSLm11bCBjIGQpXG5cbiAgbGV0IHplcm8gOiB0ID0gKFIuemVybywgUi5vbmUpXG5cbiAgbGV0IG5lZyAoKGEsYik6dCkgOiB0ID0gKFIubmVnIGEsIGIpXG5cbiAgbGV0IG11bCAoKGEsYik6dCkgKChjLGQpOnQpIDogdCA9IChSLm11bCBhIGMsIFIubXVsIGMgZClcblxuICBsZXQgb25lIDogdCA9IChSLm9uZSwgUi5vbmUpXG5cbiAgbGV0IGludiAoKGEsYik6dCkgOiB0ID0gKGIsYSlcblxuICBsZXQgdG9fc3RyaW5nICgoYSxiKTp0KSA9XG4gICAgXCIoXCIgXiBSLnRvX3N0cmluZyBhIF4gXCIpLyhcIiBeIFIudG9fc3RyaW5nIGIgXiBcIilcIlxuZW5kXG5cbm1vZHVsZSBGcmFjdGlvbnNGaWVsZCAoUiA6IFJpbmcuRXVjbGlkZWFuKSA6IFQgPSBGcmFjdGlvbnMoUilcblxuKCoqIEZpZWxkIG9mIHJhdGlvbmFsIGZyYWN0aW9ucy4gKilcbm1vZHVsZSBSYXRpb25hbEZyYWN0aW9ucyAoRiA6IFQpID0gc3RydWN0XG4gICAoKiogUmluZyBvZiBwb2x5bm9taWFscyBvdmVyIGEgZmllbGQuICopXG4gIG1vZHVsZSBQb2x5bm9taWFsIChGIDogVCkgOiBSaW5nLkV1Y2xpZGVhbiB3aXRoIHR5cGUgdCA9IFJpbmcuUG9seW5vbWlhbChGKS50ID0gc3RydWN0XG4gICAgaW5jbHVkZSBSaW5nLlBvbHlub21pYWwoRilcblxuICAgICgqKiBFdWNsaWRlYW4gZGl2aXNpb24uICopXG4gICAgbGV0IGRpdiBhIGIgPVxuICAgICAgbGV0IGRiID0gZGVncmVlIGIgaW5cbiAgICAgIGFzc2VydCAoZGIgPj0gMCk7XG4gICAgICBsZXQgcSA9IHJlZiB6ZXJvIGluXG4gICAgICBsZXQgciA9IHJlZiBhIGluXG4gICAgICBsZXQgZHIgPSByZWYgKGRlZ3JlZSAhcikgaW5cbiAgICAgIHdoaWxlICFkciA+PSBkYiBkb1xuICAgICAgICAoKiBxdW90aWVudCBvZiBsZWFkaW5nIG1vbm9taWFscyBvZiByIGFuZCBiICopXG4gICAgICAgIGxldCB0ID0gbW9ub21pYWwgKEYubXVsICFyLighZHIpIChGLmludiBiLihkYikpKSAoIWRyIC0gZGIpIGluXG4gICAgICAgIHEgOj0gYWRkICFxIHQ7XG4gICAgICAgIHIgOj0gc3ViICFyIChtdWwgdCBiKTtcbiAgICAgICAgZHIgOj0gZGVncmVlICFyXG4gICAgICBkb25lO1xuICAgICAgIXEsICFyICAgIFxuICBlbmRcblxuICBpbmNsdWRlIEZyYWN0aW9ucyhQb2x5bm9taWFsKEYpKVxuZW5kXG5cbm1vZHVsZSBSYXRpb25hbEZyYWN0aW9uc0ZpZWxkIChGIDogVCkgOiBUID0gUmF0aW9uYWxGcmFjdGlvbnMoRilcblxuKCoqIFVuZGVybHlpbmcgcmluZyBvZiBhIGZpZWxkLiAqKVxubW9kdWxlIFJpbmcgKEYgOiBUKSA6IFJpbmcuVCA9IHN0cnVjdFxuICBpbmNsdWRlIEZcbmVuZFxuIiwiKCoqIE1vbm9pZHMuICopXG5cbm9wZW4gRXh0bGliXG5cbigqKiBBIG1vbm9pZC4gKilcbm1vZHVsZSB0eXBlIFQgPSBzaWdcbiAgdHlwZSB0XG5cbiAgKCoqIEVxdWFsaXR5LiAqKVxuICB2YWwgZXEgOiB0IC0+IHQgLT4gYm9vbFxuXG4gICgqKiBNdWx0aXBsaWNhdGlvbi4gKilcbiAgdmFsIG11bCA6IHQgLT4gdCAtPiB0XG5cbiAgKCoqIFVuaXQuICopXG4gIHZhbCBvbmUgOiB0XG5cbiAgKCoqIEFuIGVsZW1lbnQgZXhwbmVudGlhdGVkIHRvIGEgbmF0dXJhbCBudW1iZXIgb2YgdGltZXMuICopXG4gIHZhbCBwb3cgOiB0IC0+IGludCAtPiB0XG5cbiAgKCoqIFN0cmluZyByZXByZXNlbnRhdGlvbi4gKilcbiAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG5cbiAgKCoqIENvbXBhcmlzb24uICopXG4gIHZhbCBjb21wYXJlIDogdCAtPiB0IC0+IGludFxuXG4gICgqKiBXaGV0aGVyIHdlIGFyZSBndWFyYW50ZWVkIHRvIGJlIGNvbW11dGF0aXZlLiAqKVxuICB2YWwgaXNfY29tbXV0YXRpdmUgOiBib29sXG5lbmRcblxuKCoqIEEgY29tbXV0YXRpdmUgbW9ub2lkIHdpdGggYWRkaXRpdmUgY29udmVudGlvbnMuICopXG5tb2R1bGUgdHlwZSBBZGRpdGl2ZSA9IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgZXEgOiB0IC0+IHQgLT4gYm9vbFxuXG4gIHZhbCBjb21wYXJlIDogdCAtPiB0IC0+IGludFxuXG4gICgqKiBBZGRpdGlvbi4gKilcbiAgdmFsIGFkZCA6IHQgLT4gdCAtPiB0XG5cbiAgKCoqIFplcm8uICopXG4gIHZhbCB6ZXJvIDogdFxuXG4gICgqKiBTdHJpbmcgcmVwcmVzZW50YXRpb24uICopXG4gIHZhbCB0b19zdHJpbmcgOiB0IC0+IHN0cmluZ1xuZW5kXG5cbigqKiBDb252ZXJ0IGEgbW9ub2lkIHRvIGFkZGl0aXZlIGNvbnZlbnRpb25zLiAqKVxubW9kdWxlIFRvQWRkaXRpdmUgKE0gOiBUKSA6IEFkZGl0aXZlID0gc3RydWN0XG4gIGxldCAoKSA9IGFzc2VydCBNLmlzX2NvbW11dGF0aXZlXG4gIHR5cGUgdCA9IE0udFxuICBsZXQgZXEgPSBNLmVxXG4gIGxldCBjb21wYXJlID0gTS5jb21wYXJlXG4gIGxldCBhZGQgPSBNLm11bFxuICBsZXQgemVybyA9IE0ub25lXG4gIGxldCB0b19zdHJpbmcgPSBNLnRvX3N0cmluZ1xuZW5kXG5cbigqKiBTaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgcG93ZXIuICopXG5sZXQgc2ltcGxlX3BvdyBvbmUgbXVsIHUgbiA9XG4gIGxldCBhbnMgPSByZWYgb25lIGluXG4gIGZvciBfID0gMSB0byBuIGRvXG4gICAgYW5zIDo9IG11bCAhYW5zIHVcbiAgZG9uZTtcbiAgIWFuc1xuXG4oKiogVGhlIGZyZWUgbW9ub2lkIG9uIGEgc2V0LiAqKVxubW9kdWxlIEZyZWUgKFggOiBBbHBoYWJldC5UKSA9IHN0cnVjdFxuICB0eXBlIHQgPSBYLnQgYXJyYXlcblxuICB0eXBlIHdvcmQgPSB0XG5cbiAgbGV0IGlzX2NvbW11dGF0aXZlID0gZmFsc2VcblxuICAoKiogTXVsdGlwbGljYXRpb24sIGkuZS4gY29uY2F0ZW5hdGlvbi4gKilcbiAgbGV0IG11bCAodTp0KSAodjp0KSA6IHQgPSBBcnJheS5hcHBlbmQgdSB2XG5cbiAgKCoqIFVuaXQgb2YgdGhlIG1vbm9pZC4gKilcbiAgbGV0IG9uZSA6IHQgPSBbfHxdXG5cbiAgbGV0IHBvdyAodTp0KSBuIDogdCA9IHNpbXBsZV9wb3cgb25lIG11bCB1IG5cblxuICAoKiogQ2Fub25pY2FsIGluamVjdGlvbiBmcm9tIHRoZSBhbHBoYWJldCB0byB0aGUgbW9ub2lkLiAqKVxuICBsZXQgaW5qIGEgOiB0ID0gW3xhfF1cblxuICAoKiogTGVuZ3RoIG9mIGEgd29yZC4gKilcbiAgbGV0IGxlbmd0aCAodTp0KSA9IEFycmF5Lmxlbmd0aCB1XG5cbiAgbGV0IHN1YiAodTp0KSBvIGwgOiB0ID0gQXJyYXkuc3ViIHUgbyBsXG5cbiAgbGV0IGVxIHUgdiA9XG4gICAgbGV0IHVsID0gbGVuZ3RoIHUgaW5cbiAgICBsZXQgdmwgPSBsZW5ndGggdiBpblxuICAgIGlmIHVsIDw+IHZsIHRoZW4gZmFsc2UgZWxzZVxuICAgICAgdHJ5XG4gICAgICAgIGZvciBpID0gMCB0byB1bCAtIDEgZG9cbiAgICAgICAgICBpZiBub3QgKFguZXEgdS4oaSkgdi4oaSkpIHRoZW4gcmFpc2UgRXhpdFxuICAgICAgICBkb25lO1xuICAgICAgICB0cnVlXG4gICAgICB3aXRoXG4gICAgICB8IEV4aXQgLT4gZmFsc2VcblxuICBsZXQgY29tcGFyZSB1IHYgPVxuICAgIGxldCB1bCA9IGxlbmd0aCB1IGluXG4gICAgbGV0IHZsID0gbGVuZ3RoIHYgaW5cbiAgICBsZXQgYW5zID0gcmVmIDAgaW5cbiAgICB0cnlcbiAgICAgIGZvciBpID0gMCB0byBtaW4gdWwgdmwgLSAxIGRvXG4gICAgICAgIGxldCBjID0gWC5jb21wYXJlIHUuKGkpIHYuKGkpIGluXG4gICAgICAgIGlmIGMgPD4gMCB0aGVuIChhbnMgOj0gYzsgcmFpc2UgRXhpdClcbiAgICAgIGRvbmU7XG4gICAgICB1bCAtIHZsXG4gICAgd2l0aFxuICAgIHwgRXhpdCAtPiAhYW5zXG5cbiAgKCoqIFBhcnRpYWwgZXF1YWxpdHkgKGVxdWFsaXR5IG9uIHN1YndvcmRzKS4gKilcbiAgbGV0IHBlcSAodTp0KSB1b2ZmICh2OnQpIHZvZmYgbGVuID1cbiAgICB0cnlcbiAgICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIGlmIG5vdCAoWC5lcSB1Lih1b2ZmICsgaSkgdi4odm9mZiArIGkpKSB0aGVuIHJhaXNlIEV4aXRcbiAgICAgIGRvbmU7XG4gICAgICB0cnVlXG4gICAgd2l0aFxuICAgIHwgRXhpdCAtPiBmYWxzZVxuXG4gICgqKiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB3b3JkLiAqKVxuICBsZXQgdG9fc3RyaW5nICh1OnQpID1cbiAgICBpZiBlcSBvbmUgdSB0aGVuIFwizrVcIiBlbHNlXG4gICAgbGV0IHUgPSBBcnJheS50b19saXN0IHUgaW5cbiAgICBsZXQgdSA9IExpc3QubWFwIFgudG9fc3RyaW5nIHUgaW5cbiAgICBTdHJpbmcuY29uY2F0IFwiXCIgdVxuXG4gICgqKiBNYXBzIGZyb20gdGhlIGZyZWUgbW9ub2lkIHRvIGFub3RoZXIgbW9ub2lkLiAqKVxuICBtb2R1bGUgTWFwKE0gOiBUKSA9IHN0cnVjdFxuICAgIG1vZHVsZSBFID0gTWFwLk1ha2UoWClcblxuICAgIHR5cGUgbWFwID0gTS50IEUudFxuXG4gICAgKCoqIENyZWF0ZSBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIGxpc3QuICopXG4gICAgbGV0IG9mX2xpc3QgbCA6IG1hcCA9IEUub2Zfc2VxIChMaXN0LnRvX3NlcSBsKVxuXG4gICAgKCoqIEFwcGx5IHRoZSBtYXAgdG8gYSBsZXR0ZXIuICopXG4gICAgbGV0IGFwcCAoZjptYXApICh4OlgudCkgPVxuICAgICAgRS5maW5kIHggZlxuXG4gICAgKCoqIEV4dGVuc2lvbiBvZiB0aGUgbWFwIHRvIHdvcmRzLiAqKVxuICAgIGxldCBiaW5kIChmOm1hcCkgKHU6dCkgPVxuICAgICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4geSB4IC0+IE0ubXVsIHkgKGFwcCBmIHgpKSBNLm9uZSB1XG4gIGVuZFxuXG4gIGxldCBpbmNsdWRlZCB1IHYgPVxuICAgIGxldCB1bCA9IGxlbmd0aCB1IGluXG4gICAgbGV0IHZsID0gbGVuZ3RoIHYgaW5cbiAgICB0cnlcbiAgICAgIGZvciBpID0gMCB0byB2bCAtIHVsIGRvXG4gICAgICAgIGlmIHBlcSB1IDAgdiBpIHVsIHRoZW4gcmFpc2UgRXhpdFxuICAgICAgZG9uZTtcbiAgICBmYWxzZVxuICAgIHdpdGhcbiAgICB8IEV4aXQgLT4gdHJ1ZVxuXG4gICgqKiBUaGUgbGVmdG1vc3QgdW5pZmllciB3aGVyZSBbdV0gaXMgb24gdGhlIGxlZnQgYW5kIFt2XSBvbiB0aGUgcmlnaHQgKilcbiAgbGV0IHVuaWZpZXIgPyhpPTApIHUgdiA9XG4gICAgbGV0IHVsID0gbGVuZ3RoIHUgaW5cbiAgICBsZXQgdmwgPSBsZW5ndGggdiBpblxuICAgIGxldCBhbnMgPSByZWYgTm9uZSBpblxuICAgIHRyeVxuICAgICAgZm9yIGkgPSBpIHRvIHVsIC0gMSBkb1xuICAgICAgICBpZiBwZXEgdSBpIHYgMCAobWluICh1bC1pKSB2bCkgdGhlblxuICAgICAgICAgIChcbiAgICAgICAgICAgIGFucyA6PSBTb21lIGk7XG4gICAgICAgICAgICByYWlzZSBFeGl0XG4gICAgICAgICAgKVxuICAgICAgZG9uZTtcbiAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgIHdpdGhcbiAgICB8IEV4aXQgLT4gKG1hdGNoICFhbnMgd2l0aCBTb21lIGFucyAtPiBhbnMgfCBOb25lIC0+IGFzc2VydCBmYWxzZSlcblxuICAoKiogQWxsIHVuaWZpZXJzIHdpdGggZmlyc3Qgb24gdGhlIGxlZnQuICopXG4gIGxldCBvcmRlcmVkX3VuaWZpZXJzIHUgdiA9XG4gICAgbGV0IGFucyA9IHJlZiBbXSBpblxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICB0cnlcbiAgICAgIHdoaWxlIHRydWUgZG9cbiAgICAgICAgbGV0IGogPSB1bmlmaWVyIH5pOiFpIHUgdiBpblxuICAgICAgICBhbnMgOj0gaiA6OiAhYW5zO1xuICAgICAgICBpIDo9IGorMVxuICAgICAgZG9uZTtcbiAgICAgIGFzc2VydCBmYWxzZVxuICAgIHdpdGhcbiAgICB8IE5vdF9mb3VuZCAtPiAhYW5zXG5cbiAgbGV0IG9yZGVyZWRfdW5pZmllcnNfYmljb250ZXh0IHUgdiA9XG4gICAgbGV0IGx1ID0gbGVuZ3RoIHUgaW5cbiAgICBsZXQgbHYgPSBsZW5ndGggdiBpblxuICAgIGxldCBsID0gb3JkZXJlZF91bmlmaWVycyB1IHYgaW5cbiAgICBMaXN0Lm1hcCAoZnVuIGkgLT5cbiAgICAgIGlmIGkgKyBsdiA8PSBsdSB0aGVuXG4gICAgICAgIChvbmUsIG9uZSksXG4gICAgICAgIChzdWIgdSAwIGksIHN1YiB1IChpICsgbHYpIChsdSAtIChpICsgbHYpKSlcbiAgICAgIGVsc2VcbiAgICAgICAgKG9uZSwgc3ViIHYgKGx1IC0gaSkgKGx2IC0gKGx1IC0gaSkpKSxcbiAgICAgICAgKHN1YiB1IDAgaSwgb25lKVxuICAgICkgbFxuXG4gICgqKiBBbGwgdW5pZmllcnMsIHdpdGggY29udGV4dHMgb24gdGhlIGxlZnQgYW5kIG9uIHRoZSByaWdodC4gKilcbiAgbGV0IHVuaWZpZXJzX2JpY29udGV4dCB1IHYgPVxuICAgIGxldCBsID0gb3JkZXJlZF91bmlmaWVyc19iaWNvbnRleHQgdSB2IGluXG4gICAgbGV0IGwnID0gb3JkZXJlZF91bmlmaWVyc19iaWNvbnRleHQgdiB1IGluXG4gICAgbGV0IGwnID0gTGlzdC5tYXAgKGZ1biAoYyxkKSAtPiBkLGMpIGwnIGluXG4gICAgbEBsJ1xuXG4gIG1vZHVsZSBPcmRlciA9IHN0cnVjdFxuICAgIGxldCBsZXhpY29ncmFwaGljIGxlcSB1IHYgPVxuICAgICAgbGV0IHVsID0gbGVuZ3RoIHUgaW5cbiAgICAgIGxldCB2bCA9IGxlbmd0aCB2IGluXG4gICAgICBsZXQgYW5zID0gcmVmIHRydWUgaW5cbiAgICAgIHRyeVxuICAgICAgICBmb3IgaSA9IDAgdG8gbWluIHVsIHZsIC0gMSBkb1xuICAgICAgICAgIGlmIGxlcSB1LihpKSB2LihpKSB0aGVuXG4gICAgICAgICAgICAoaWYgbm90IChYLmVxIHUuKGkpIHYuKGkpKSB0aGVuIHJhaXNlIEV4aXQpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgKGFucyA6PSBmYWxzZTsgcmFpc2UgRXhpdClcbiAgICAgICAgZG9uZTtcbiAgICAgICAgdWwgPD0gdmxcbiAgICAgIHdpdGhcbiAgICAgIHwgRXhpdCAtPiAhYW5zXG5cbiAgICBsZXQgZGVnbGV4IGxlcSB1IHYgPVxuICAgICAgbGV0IHVsID0gbGVuZ3RoIHUgaW5cbiAgICAgIGxldCB2bCA9IGxlbmd0aCB2IGluXG4gICAgICBpZiB1bCA8IHZsIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBpZiB1bCA+IHZsIHRoZW4gZmFsc2VcbiAgICAgIGVsc2UgbGV4aWNvZ3JhcGhpYyBsZXEgdSB2XG4gIGVuZFxuXG4gICgqKiBBbmljayBjaGFpbnMuICopXG4gIG1vZHVsZSBBbmljayA9IHN0cnVjdFxuICAgICgqKiBBbiBBbmljayBjaGFpbi4gKilcbiAgICB0eXBlIHQgPSB3b3JkIGxpc3RcblxuICAgICgqKiBUaGUgZW1wdHkgY2hhaW4uICopXG4gICAgbGV0IGVtcHR5IDogdCA9IFtdXG5cbiAgICAoKiogVGhlIHNpbmdsZXRvbiBjaGFpbi4gKilcbiAgICBsZXQgc2luZ2xldG9uIGEgOiB0ID0gW2luaiBhXVxuXG4gICAgKCoqIFNpbmdsZXRvbiBjaGFpbnMuICopXG4gICAgbGV0IHNpbmdsZXRvbnMgbCA9IExpc3QubWFwIHNpbmdsZXRvbiBsXG5cbiAgICAoKiogSGVhZCBvZiB0aGUgY2hhaW4uICopXG4gICAgbGV0IGhkIChsOnQpIDogd29yZCA9IExpc3QuaGQgbFxuXG4gICAgKCoqIFRhaWwgb2YgdGhlIGNoYWluLiAqKVxuICAgIGxldCB0bCAobDp0KSA6IHQgPSBMaXN0LnRsIGxcblxuICAgIGxldCB3ZXEgPSBlcVxuXG4gICAgbGV0IGVxIGMgZCA9XG4gICAgICBsZXQgd2VxID0gZXEgaW5cbiAgICAgIGxldCByZWMgYXV4IGMgZCA9XG4gICAgICAgIG1hdGNoIChjLGQpIHdpdGhcbiAgICAgICAgfCB1OjpjLCB2OjpkIC0+IHdlcSB1IHYgJiYgYXV4IGMgZFxuICAgICAgICB8IFtdLCBbXSAtPiB0cnVlXG4gICAgICAgIHwgW10sIF8gLT4gZmFsc2VcbiAgICAgICAgfCBfLCBbXSAtPiBmYWxzZVxuICAgICAgaW5cbiAgICAgIGF1eCBjIGRcblxuICAgIGxldCBjb21wYXJlIGMgZCA9XG4gICAgICBsZXQgd2MgPSBjb21wYXJlIGluXG4gICAgICBsZXQgcmVjIGF1eCBjIGQgPVxuICAgICAgICBtYXRjaCAoYyxkKSB3aXRoXG4gICAgICAgIHwgdTo6Yywgdjo6ZCAtPlxuICAgICAgICAgICBsZXQgY21wID0gd2MgdSB2IGluXG4gICAgICAgICAgIGlmIGNtcCA9IDAgdGhlbiBhdXggYyBkIGVsc2UgY21wXG4gICAgICAgIHwgW10sIFtdIC0+IDBcbiAgICAgICAgfCBbXSwgXyAtPiAtMVxuICAgICAgICB8IF8sIFtdIC0+IDFcbiAgICAgIGluXG4gICAgICBhdXggYyBkXG5cbiAgICAoKiogQ29tcHV0ZSAobisxKS1jaGFpbnMgZnJvbSBuLWNoYWlucy4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBsaXN0IG9mXG4gICAgICAgIG1pbmltYWwgcmVkdWNpYmxlIHdvcmRzLiAqKVxuICAgIGxldCBleHRlbmQgKGw6d29yZCBsaXN0KSAoYzp0KSA6IHQgbGlzdCA9XG4gICAgICBtYXRjaCBjIHdpdGhcbiAgICAgIHwgW3x8XTo6XyB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCB1OjpjIC0+XG4gICAgICAgICBsZXQgdWwgPSBsZW5ndGggdSBpblxuICAgICAgICAgbGV0IGFucyA9IHJlZiBbXSBpblxuICAgICAgICAgbGV0IGl0ZXJfY3R4IGYgbCA9XG4gICAgICAgICAgIGxldCByZWMgYXV4IGggPSBmdW5jdGlvblxuICAgICAgICAgICAgIHwgeDo6dCAtPiBmIGggeCB0OyBhdXggKHg6OmgpIHRcbiAgICAgICAgICAgICB8IFtdIC0+ICgpXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIGF1eCBbXSBsXG4gICAgICAgICBpblxuICAgICAgICAgaXRlcl9jdHggKGZ1biBsMSB2IGwyIC0+XG4gICAgICAgICAgIGxldCB2bCA9IGxlbmd0aCB2IGluXG4gICAgICAgICAgIGZvciBpID0gbWF4ICh1bC12bCkgMCB0byB1bCAtIDEgZG9cbiAgICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICAgIGlmIG5vdCAocGVxIHUgaSB2IDAgKHVsLWkpKSB0aGVuIHJhaXNlIEV4aXQ7XG4gICAgICAgICAgICAgICBsZXQgaSA9IHVsIC0gaSBpblxuICAgICAgICAgICAgICAgbGV0IHYnID0gc3ViIHYgaSAodmwtaSkgaW5cbiAgICAgICAgICAgICAgICgqIEVuc3VyZSB0aGF0IHRoZSBzdWZmaXggaXMgbm90IHJlZHVjaWJsZSBieSBhbnkgb3RoZXIgcnVsZS4gKilcbiAgICAgICAgICAgICAgIGxldCB3ID0gbXVsIHUgdicgaW5cbiAgICAgICAgICAgICAgIGxldCBmIHUgPSBpZiBpbmNsdWRlZCB1IHcgdGhlbiByYWlzZSBFeGl0IGluXG4gICAgICAgICAgICAgICBMaXN0Lml0ZXIgZiBsMTtcbiAgICAgICAgICAgICAgIExpc3QuaXRlciBmIGwyO1xuICAgICAgICAgICAgICAgKCogLi4ub3IgYnkgdGhlIHJ1bGUgaXRzZWxmIChleGNlcHRpbmcgYXQgbGFzdCBwb3NpdGlvbikuICopXG4gICAgICAgICAgICAgICBpZiBpbmNsdWRlZCB2IChzdWIgdyAwIChsZW5ndGggdyAtIDEpKSB0aGVuIHJhaXNlIEV4aXQ7XG4gICAgICAgICAgICAgICBhbnMgOj0gKHYnOjp1OjpjKSA6OiAhYW5zXG4gICAgICAgICAgICAgd2l0aFxuICAgICAgICAgICAgIHwgRXhpdCAtPiAoKVxuICAgICAgICAgICBkb25lO1xuICAgICAgICAgKSBsO1xuICAgICAgICAgIWFuc1xuXG4gICAgKCoqIEFkZCBhbiBlbGVtZW50IHRvIGEgY2hhaW4uICopXG4gICAgbGV0IGV4dGVuZCBsIGNjID0gTGlzdC5jb25jYXQgKExpc3QubWFwIChleHRlbmQgbCkgY2MpXG5cbiAgICAoKiogQ29uY2F0ZW5hdGlvbiBvZiB0aGUgZWxlbWVudHMgb2YgdGhlIGNoYWluLiAqKVxuICAgIGxldCBldmFsIChsOnQpID0gTGlzdC5mb2xkX2xlZnQgbXVsIG9uZSAoTGlzdC5yZXYgbClcblxuICAgICgqKiBEaW1lbnNpb24gb2YgdGhlIGNoYWluLiAqKVxuICAgIGxldCBsZW5ndGggKGw6dCkgPSBMaXN0Lmxlbmd0aCBsXG4gICAgICBcbiAgICAoKiogU3RyaW5nIHJlcHJlc2VudGF0aW9uLiAqKVxuICAgIGxldCB0b19zdHJpbmcgKGM6dCkgPSBcIltcIiBeIFN0cmluZy5jb25jYXQgXCJ8XCIgKExpc3QubWFwIHRvX3N0cmluZyAoTGlzdC5yZXYgYykpIF4gXCJdXCJcbiAgZW5kXG5lbmRcblxuKCoqIFRoZSBmcmVlIG1vbm9pZCBhcyBhIG1vbm9pZC4gKilcbm1vZHVsZSBGcmVlTW9ub2lkIChYIDogQWxwaGFiZXQuVCkgOiBUID0gRnJlZShYKVxuXG4oKiogT3JpZW50ZWQgcHJlc2VudGF0aW9uIG9mIGEgbW9ub2lkLiAqKVxubW9kdWxlIFByZXMgKFggOiBBbHBoYWJldC5UKSA9IHN0cnVjdFxuICBtb2R1bGUgVyA9IEZyZWUoWClcblxuICB0eXBlIHQgPVxuICAgIHtcbiAgICAgIGdlbmVyYXRvcnMgOiBYLnQgbGlzdDtcbiAgICAgIHJ1bGVzIDogKFcudCAqIFcudCkgbGlzdDtcbiAgICB9XG5cbiAgbGV0IG1ha2UgZ2VuZXJhdG9ycyBydWxlcyA9XG4gICAgeyBnZW5lcmF0b3JzOyBydWxlcyB9XG5cbiAgKCoqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHByZXNlbnRhdGlvbi4gKilcbiAgbGV0IHRvX3N0cmluZyBwcmVzID1cbiAgICBQcmludGYuc3ByaW50ZlxuICAgICAgXCI8ICVzIHwgJXMgPlwiXG4gICAgICAoTGlzdC5tYXAgWC50b19zdHJpbmcgcHJlcy5nZW5lcmF0b3JzIHw+IFN0cmluZy5jb25jYXQgXCIsIFwiKVxuICAgICAgKExpc3QubWFwIChmdW4gKHUsdikgLT4gUHJpbnRmLnNwcmludGYgXCIlcyAtPiAlc1wiIChXLnRvX3N0cmluZyB1KSAoVy50b19zdHJpbmcgdikpIHByZXMucnVsZXMgfD4gU3RyaW5nLmNvbmNhdCBcIiwgXCIpXG5cbiAgKCoqIE9yaWVudCBydWxlcyBhY2NvcmRpbmcgdG8gYSBwYXJ0aWFsIG9yZGVyLiAqKVxuICBsZXQgb3JpZW50IGxlcSBwcmVzID1cbiAgICBsZXQgcnVsZXMgPSBMaXN0Lm1hcCAoZnVuICh1LHYpIC0+IGlmIGxlcSB2IHUgdGhlbiB1LHYgZWxzZSB2LHUpIHByZXMucnVsZXMgaW5cbiAgICB7IHByZXMgd2l0aCBydWxlcyB9XG5cbiAgKCoqIE5vcm1hbGl6ZSBhIHdvcmQuICopXG4gIGxldCByZWMgbm9ybWFsaXplIHByZXMgdSA9XG4gICAgdHJ5XG4gICAgICBsZXQgdix2JyA9IExpc3QuZmluZCAoZnVuICh2LF8pIC0+IFcuaW5jbHVkZWQgdiB1KSBwcmVzLnJ1bGVzIGluXG4gICAgICBsZXQgaSA9IFcudW5pZmllciB1IHYgaW5cbiAgICAgIGxldCB2MSA9IFcuc3ViIHUgMCBpIGluXG4gICAgICBsZXQgdjIgPSBXLnN1YiB1IChpICsgVy5sZW5ndGggdikgKFcubGVuZ3RoIHUgLSAoaSArIFcubGVuZ3RoIHYpKSBpblxuICAgICAgbm9ybWFsaXplIHByZXMgKFcubXVsIHYxIChXLm11bCB2JyB2MikpXG4gICAgd2l0aFxuICAgIHwgTm90X2ZvdW5kIC0+IHVcblxuICBsZXQgYWRkX3J1bGUgcHJlcyAodSx2KSA9XG4gICAgeyBwcmVzIHdpdGggcnVsZXMgPSAodSx2KTo6cHJlcy5ydWxlcyB9XG5cbiAgKCoqIFJlZHVjZSBhIHByZXNlbnRhdGlvbi4gKilcbiAgbGV0IHJlZHVjZSBwcmVzID1cbiAgICBsZXQgcnVsZXMgPSBMaXN0Lm1hcCAoZnVuICh1LHYpIC0+IHUsIG5vcm1hbGl6ZSBwcmVzIHYpIHByZXMucnVsZXMgaW5cbiAgICBsZXQgcmVjIGF1eCBoID0gZnVuY3Rpb25cbiAgICAgIHwgKHUsdik6OnQgLT5cbiAgICAgICAgIGxldCBmIGwgPSBMaXN0LmV4aXN0cyAoZnVuICh1Jyx2JykgLT4gVy5pbmNsdWRlZCB1JyB1KSBsIGluXG4gICAgICAgICBpZiBmIGggfHwgZiB0IHRoZW4gYXV4IGggdCBlbHNlIGF1eCAoKHUsdik6OmgpIHRcbiAgICAgIHwgW10gLT4gTGlzdC5yZXYgaFxuICAgIGluXG4gICAgbGV0IHJ1bGVzID0gYXV4IFtdIHJ1bGVzIGluXG4gICAgeyBwcmVzIHdpdGggcnVsZXMgfVxuXG4gICgqKiBLbnV0aC1CZW5kaXggY29tcGxldGlvbiB3cnQgYSB0b3RhbCBvcmRlci4gKilcbiAgbGV0IGNvbXBsZXRlIGxlcSBwcmVzID1cbiAgICBsZXQgcHJlcyA9IG9yaWVudCBsZXEgcHJlcyBpblxuICAgIGxldCB0b2RvID0gUXVldWUuY3JlYXRlICgpIGluXG4gICAgTGlzdC5pdGVyIChmdW4gciAtPiBRdWV1ZS5hZGQgciB0b2RvKSBwcmVzLnJ1bGVzO1xuICAgIGxldCBwcmVzID0gcmVmIHByZXMgaW5cbiAgICAoKiBBZGQgYSByZWxhdGlvbiAqKVxuICAgIGxldCByZWwgKHUsdikgPVxuICAgICAgbGV0IHUgPSBub3JtYWxpemUgIXByZXMgdSBpblxuICAgICAgbGV0IHYgPSBub3JtYWxpemUgIXByZXMgdiBpblxuICAgICAgaWYgbm90IChXLmVxIHUgdikgdGhlblxuICAgICAgICAoXG4gICAgICAgICAgbGV0IHUsdiA9IGlmIGxlcSB2IHUgdGhlbiB1LHYgZWxzZSB2LHUgaW5cbiAgICAgICAgICAoKiBQcmludGYucHJpbnRmIFwicmVsOiAlcyAtPiAlc1xcbiUhXCIgKFcudG9fc3RyaW5nIHUpIChXLnRvX3N0cmluZyB2KTsgKilcbiAgICAgICAgICBwcmVzIDo9IGFkZF9ydWxlICFwcmVzICh1LHYpO1xuICAgICAgICAgIFF1ZXVlLnB1c2ggKHUsdikgdG9kb1xuICAgICAgICApXG4gICAgaW5cbiAgICB3aGlsZSBub3QgKFF1ZXVlLmlzX2VtcHR5IHRvZG8pIGRvXG4gICAgICBsZXQgdSx1JyA9IFF1ZXVlLnBvcCB0b2RvIGluXG4gICAgICBMaXN0Lml0ZXJcbiAgICAgICAgKGZ1biAodix2JykgLT5cbiAgICAgICAgICAgTGlzdC5pdGVyIChmdW4gKCh1MSx1MiksKHYxLHYyKSkgLT5cbiAgICAgICAgICAgICAgIGxldCBzMSA9IFcubXVsIHUxIChXLm11bCB1JyB1MikgaW5cbiAgICAgICAgICAgICAgIGxldCBzMiA9IFcubXVsIHYxIChXLm11bCB2JyB2MikgaW5cbiAgICAgICAgICAgICAgIHJlbCAoczEsczIpXG4gICAgICAgICAgICAgKSAoVy51bmlmaWVyc19iaWNvbnRleHQgdSB2KVxuICAgICAgICApICFwcmVzLnJ1bGVzXG4gICAgZG9uZTtcbiAgICAhcHJlc1xuXG4gICgqKiBNYWtlIGEgbW9ub2lkIGZyb20gYSBjb252ZXJnZW50IHByZXNlbnRhdGlvbi4gKilcbiAgbW9kdWxlIE1ha2UgKFAgOiBzaWcgdmFsIHByZXNlbnRhdGlvbiA6IHQgZW5kKSA6IFQgPSBzdHJ1Y3RcbiAgICBsZXQgcCA9IFAucHJlc2VudGF0aW9uXG5cbiAgICBsZXQgbmYgPSBub3JtYWxpemUgcFxuXG4gICAgdHlwZSB0ID0gVy50XG5cbiAgICBsZXQgaXNfY29tbXV0YXRpdmUgPSBmYWxzZVxuXG4gICAgbGV0IG11bCA9IFcubXVsXG5cbiAgICBsZXQgb25lID0gVy5vbmVcblxuICAgIGxldCBwb3cgPSBXLnBvd1xuXG4gICAgbGV0IHRvX3N0cmluZyA9IFcudG9fc3RyaW5nXG5cbiAgICBsZXQgY29tcGFyZSB1IHYgPSBXLmNvbXBhcmUgKG5mIHUpIChuZiB2KVxuXG4gICAgbGV0IGVxIHUgdiA9IFcuZXEgKG5mIHUpIChuZiB2KVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgR2VuZXJhdGUgKFggOiBBbHBoYWJldC5UIHdpdGggdHlwZSB0ID0gaW50KSA9IHN0cnVjdFxuICBtb2R1bGUgUHJlcyA9IFByZXMoWClcblxuICBsZXQgaW50c2V0IG4gPVxuICAgIGxldCByZWMgYXV4IGsgPVxuICAgICAgaWYgayA+PSBuIHRoZW4gW10gZWxzZVxuICAgICAgICBrOjooYXV4IChrKzEpKVxuICAgIGluXG4gICAgYXV4IDBcbmVuZFxuXG4oKiogTXVsdGlzZXRzIG92ZXIgYSBzZXQsIGkuZS4gdGhlIGZyZWUgY29tbXV0YXRpdmUgbW9ub2lkLiAqKVxubW9kdWxlIE11bHRpc2V0cyhYIDogQWxwaGFiZXQuVCkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gKFgudCAqIGludCkgbGlzdFxuXG4gIGxldCBpc19jb21tdXRhdGl2ZSA9IHRydWVcblxuICBsZXQgdG9fc3RyaW5nICh1OnQpID1cbiAgICBMaXN0LmZvbGRfbGVmdCAoZnVuIHMgKHgsbikgLT5cbiAgICAgICAgaWYgbiA9IDAgdGhlbiBzXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgbiA9IGlmIG4gPSAxIHRoZW4gXCJcIiBlbHNlIFN0cmluZy5zdXBlcnNjcmlwdCAoc3RyaW5nX29mX2ludCBuKSBpblxuICAgICAgICAgIHMgXiBYLnRvX3N0cmluZyB4IF4gblxuICAgICAgKSBcIlwiIHVcblxuICAoKiogRG9tYWluIG9mIGFuIGVsZW1lbnQuICopXG4gIG1vZHVsZSBEb21haW4gPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBYLnQgbGlzdFxuXG4gICAgbGV0IGVtcHR5IDogdCA9IFtdXG5cbiAgICBsZXQgdW5pb24gKGQ6dCkgKGQnOnQpIDogdCA9XG4gICAgICBkQGQnIHw+IExpc3Quc29ydF91bmlxIFguY29tcGFyZVxuICBlbmRcblxuICBsZXQgZG9tYWluICh1OnQpIDogRG9tYWluLnQgPSBMaXN0LmZpbHRlcl9tYXAgKGZ1biAoeCxuKSAtPiBpZiBuID4gMCB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpIHVcblxuICBsZXQgb2NjdXJyZW5jZXMgeCAodTp0KSA9XG4gICAgbWF0Y2ggTGlzdC5hc3NvY19vcHQgeCB1IHdpdGhcbiAgICB8IFNvbWUgbiAtPiBuXG4gICAgfCBOb25lIC0+IDBcblxuICBsZXQgb25lIDogdCA9IFtdXG5cbiAgbGV0IG11bCB1IHYgOiB0ID1cbiAgICBsZXQgZCA9IERvbWFpbi51bmlvbiAoZG9tYWluIHUpIChkb21haW4gdikgaW5cbiAgICBMaXN0Lm1hcCAoZnVuIHggLT4geCwgb2NjdXJyZW5jZXMgeCB1ICsgb2NjdXJyZW5jZXMgeCB2KSBkXG5cbiAgbGV0IHBvdyAodTp0KSBuIDogdCA9XG4gICAgTGlzdC5tYXAgKGZ1biAoeCxtKSAtPiB4LG0qbikgdVxuXG4gIGxldCBpbmNsdWRlZCAodTp0KSAodjp0KSA9XG4gICAgTGlzdC5mb3JfYWxsIChmdW4gKHgsbikgLT4gbiA8PSBvY2N1cnJlbmNlcyB4IHYpIHVcblxuICBsZXQgZXEgdSB2ID0gaW5jbHVkZWQgdSB2ICYmIGluY2x1ZGVkIHYgdVxuXG4gICgqIFB1dCBhbiBlbGVtZW50IGluIGNhbm9uaWNhbCBmb3JtLiAqKVxuICBsZXQgbm9ybWFsaXplIHUgPVxuICAgIGxldCB1ID0gTGlzdC5maWx0ZXIgKGZ1biAoeCxuKSAtPiBuIDw+IDApIHUgaW5cbiAgICBMaXN0LnNvcnQgKGZ1biAoeCxuKSAoeSxtKSAtPlxuICAgICAgICBsZXQgYyA9IFguY29tcGFyZSB4IHkgaW5cbiAgICAgICAgaWYgYyA8PiAwIHRoZW4gYyBlbHNlIG4gLSBtXG4gICAgICApIHVcblxuICBsZXQgY29tcGFyZSAodTp0KSAodjp0KSA9XG4gICAgbGV0IHUgPSBub3JtYWxpemUgdSBpblxuICAgIGxldCB2ID0gbm9ybWFsaXplIHYgaW5cbiAgICBsZXQgcmVjIGF1eCB1IHYgPVxuICAgICAgbWF0Y2ggdSwgdiB3aXRoXG4gICAgICB8ICh4LG4pOjp1LCAoeSxtKTo6diAtPlxuICAgICAgICBsZXQgYyA9IFguY29tcGFyZSB4IHkgaW5cbiAgICAgICAgaWYgYyA8PiAwIHRoZW4gYyBlbHNlXG4gICAgICAgICAgbGV0IGMgPSBuIC0gbSBpblxuICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgYXV4IHUgdlxuICAgICAgfCBfOjpfLCBbXSAtPiAxXG4gICAgICB8IFtdLCBfOjpfIC0+IC0xXG4gICAgICB8IFtdLCBbXSAtPiAwXG4gICAgaW5cbiAgICBhdXggdSB2XG5cbiAgbGV0IGluaiB4IDogdCA9IFt4LDFdXG5cbiAgbGV0IGNtdWwgbiB1ID0gTGlzdC5tYXAgKGZ1biAoeCxtKSAtPiB4LG0qbikgdVxuXG4gIG1vZHVsZSBNYXAoTTpUKSA9IHN0cnVjdFxuICAgIGxldCAoKSA9IGFzc2VydCBNLmlzX2NvbW11dGF0aXZlXG5cbiAgICBtb2R1bGUgRSA9IE1hcC5NYWtlKFgpXG5cbiAgICB0eXBlIG1hcCA9IE0udCBFLnRcblxuICAgIGxldCBvZl9saXN0IGwgPSBFLm9mX3NlcSAoTGlzdC50b19zZXEgbClcblxuICAgIGxldCBhcHAgKGY6bWFwKSAoeDpYLnQpIDogTS50ID1cbiAgICAgIEUuZmluZCB4IGZcblxuICAgIGxldCBiaW5kIChmOm1hcCkgKHU6dCkgOiBNLnQgPVxuICAgICAgTGlzdC5mb2xkX2xlZnQgKGZ1biB2ICh4LG4pIC0+IE0ubXVsIHYgKE0ucG93IChhcHAgZiB4KSBuKSkgTS5vbmUgdVxuICBlbmRcbmVuZFxuXG4oKiogTXVsdGlzZXRzIGFzIGEgbW9ub2lkLiAqKVxubW9kdWxlIE11bHRpc2V0c01vbm9pZChYIDogQWxwaGFiZXQuVCkgOiBUID0gTXVsdGlzZXRzKFgpXG5cbigqKiBVbmRlcmx5aW5nIGFscGhhYmV0IG9mIGEgbW9ub2lkLiAqKVxubW9kdWxlIEFscGhhYmV0IChNIDogVCkgOiBBbHBoYWJldC5UID0gc3RydWN0XG4gIGluY2x1ZGUgTVxuZW5kXG4iLCIoKiogTWF0cmljZXMuICopXG5cbigqKiBNYXRyaWNlcyBvdmVyIGEgcmluZy4gKilcbm1vZHVsZSBNYWtlIChSOlJpbmcuVCkgPSBzdHJ1Y3RcbiAgKCoqIEEgbWF0cml4LiAqKVxuICB0eXBlIHQgPSBSLnQgYXJyYXkgYXJyYXlcblxuICB0eXBlIG1hdHJpeCA9IHRcblxuICAoKiogWmVybyBtYXRyaXguICopXG4gIGxldCB6ZXJvIHIgYyA6IHQgPSBBcnJheS5pbml0IHIgKGZ1biBfIC0+IEFycmF5Lm1ha2UgYyBSLnplcm8pXG5cbiAgKCoqIEluaXRpYWxpemUgYSBtYXRyaXguICopXG4gIGxldCBpbml0IHIgYyBmIDogdCA9XG4gICAgQXJyYXkuaW5pdCByIChmdW4gaSAtPiBBcnJheS5pbml0IGMgKGZ1biBqIC0+IGYgaSBqKSlcblxuICAoKiogTnVtYmVyIG9mIHJvd3MuICopXG4gIGxldCByb3dzIChtIDogdCkgPSBBcnJheS5sZW5ndGggbVxuXG4gICgqKiBOdW1iZXIgb2YgY29sdW1ucy4gKilcbiAgbGV0IGNvbHMgKG0gOiB0KSA9IEFycmF5Lmxlbmd0aCBtLigwKVxuXG4gICgqKiBDb2VmZmljaWVudC4gKilcbiAgbGV0IGdldCAobTp0KSBpIGogPSBtLihpKS4oailcblxuICAoKiogU3RyaW5nIHJlcHJlc2VudGF0aW9uLiAqKVxuICBsZXQgdG9fc3RyaW5nIG0gPVxuICAgIGxldCBhbnMgPSByZWYgXCJcIiBpblxuICAgIGZvciBpID0gMCB0byByb3dzIG0gLSAxIGRvXG4gICAgICBmb3IgaiA9IDAgdG8gY29scyBtIC0gMSBkb1xuICAgICAgICBpZiBqIDw+IDAgdGhlbiBhbnMgOj0gIWFucyBeIFwiIFwiO1xuICAgICAgICBhbnMgOj0gIWFucyBeIFIudG9fc3RyaW5nIG0uKGkpLihqKVxuICAgICAgZG9uZTtcbiAgICAgIGFucyA6PSAhYW5zIF4gXCJcXG5cIlxuICAgIGRvbmU7XG4gICAgIWFuc1xuXG4gICgqKiBPcGVyYXRpb25zIG9uIHJvd3MuICopXG4gIG1vZHVsZSBSb3cgPSBzdHJ1Y3RcbiAgICAoKiogQSBhIHJvdyBudWxsPyAqKVxuICAgIGxldCBpc196ZXJvIG0gaSA9XG4gICAgICBBcnJheS5mb3JfYWxsIChSLmVxIFIuemVybykgbS4oaSlcblxuICAgICgqKiBSZXBsYWNlIGEgcm93IGJ5IGFub3RoZXIgb25lLiAqKVxuICAgIGxldCByZXBsYWNlIG0gaSBtaSA6IHQgPVxuICAgICAgQXJyYXkuaW5pdCAocm93cyBtKSAoZnVuIGsgLT4gaWYgayA9IGkgdGhlbiBtaSBlbHNlIG0uKGspKVxuXG4gICAgKCoqIEV4Y2hhbmdlIHR3byByb3dzLiAqKVxuICAgIGxldCBleGNoYW5nZSBtIGkgaiA6IHQgPVxuICAgICAgQXJyYXkuaW5pdCAocm93cyBtKSAoZnVuIGsgLT4gaWYgayA9IGkgdGhlbiBtLihqKSBlbHNlIGlmIGsgPSBqIHRoZW4gbS4oaSkgZWxzZSBtLihrKSlcblxuICAgICgqKiBNdWx0aXBseSBhIHJvdyBieSBhIGNvZWZmaWNlbnQuICopXG4gICAgbGV0IG11bHQgbSBxIGkgPVxuICAgICAgYXNzZXJ0IChub3QgKFIuZXEgUi56ZXJvIHEpKTtcbiAgICAgIGxldCBtaSA9IEFycmF5LmluaXQgKGNvbHMgbSkgKGZ1biBrIC0+IFIubXVsIHEgbS4oaSkuKGspKSBpblxuICAgICAgcmVwbGFjZSBtIGkgbWlcblxuICAgICgqKiBBZGQgdG8gYSByb3cgW3FdIHRpbWVzIGFub3RoZXIgcm93LiAqKVxuICAgIGxldCBtYWRkIG0gaSBxIGogPVxuICAgICAgYXNzZXJ0IChpIDw+IGopO1xuICAgICAgbGV0IG1pID0gQXJyYXkuaW5pdCAoY29scyBtKSAoZnVuIGsgLT4gUi5hZGQgbS4oaSkuKGspIChSLm11bCBxIG0uKGopLihrKSkpIGluXG4gICAgICByZXBsYWNlIG0gaSBtaVxuICBlbmRcblxuICAoKiogUHV0IGEgbWF0cml4IGluIHJvdyBlY2hlbG9uIGZvcm0uICopXG4gIGxldCByb3dfZWNoZWxvbiBtID1cbiAgICBsZXQgbSA9IHJlZiBtIGluXG4gICAgbGV0IGlwID0gcmVmIDAgaW5cbiAgICBsZXQgY29scyA9IGlmIHJvd3MgIW0gPSAwIHRoZW4gMCBlbHNlIGNvbHMgIW0gaW5cbiAgICB0cnlcbiAgICAgIGZvciBqID0gMCB0byBjb2xzIC0gMSBkb1xuICAgICAgICBpZiAhaXAgPj0gcm93cyAhbSB0aGVuIHJhaXNlIEV4aXQ7XG4gICAgICAgIGlmIFIuZXEgUi56ZXJvICFtLighaXApLihqKSB0aGVuXG4gICAgICAgICAgKFxuICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgIGZvciBpID0gIWlwICsgMSB0byByb3dzICFtIC0gMSBkb1xuICAgICAgICAgICAgICAgIGlmIG5vdCAoUi5lcSBSLnplcm8gIW0uKGkpLihqKSkgdGhlbiAobSA6PSBSb3cuZXhjaGFuZ2UgIW0gIWlwIGk7IHJhaXNlIEV4aXQpXG4gICAgICAgICAgICAgIGRvbmVcbiAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgIHwgRXhpdCAtPiAoKVxuICAgICAgICAgICk7XG4gICAgICAgIGxldCBhID0gIW0uKCFpcCkuKGopIGluXG4gICAgICAgIGlmIG5vdCAoUi5lcSBSLnplcm8gYSkgdGhlblxuICAgICAgICAgIChcbiAgICAgICAgICAgIGZvciBpID0gIWlwICsgMSB0byByb3dzICFtIC0gMSBkb1xuICAgICAgICAgICAgICBsZXQgYiA9ICFtLihpKS4oaikgaW5cbiAgICAgICAgICAgICAgaWYgbm90IChSLmVxIFIuemVybyBiKSB0aGVuXG4gICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgbSA6PSBSb3cubXVsdCAhbSAoUi5uZWcgYSkgaTtcbiAgICAgICAgICAgICAgICAgIG0gOj0gUm93Lm1hZGQgIW0gaSBiICFpcFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIGRvbmU7XG4gICAgICAgICAgICBpbmNyIGlwXG4gICAgICAgICAgKVxuICAgICAgZG9uZTtcbiAgICAgICFtXG4gICAgd2l0aFxuICAgIHwgRXhpdCAtPiAhbVxuXG4gICgqKiBEaW1lbnNpb24gb2YgdGhlIGltYWdlLiAqKVxuICBsZXQgcmFuayBtID1cbiAgICBsZXQgbSA9IHJvd19lY2hlbG9uIG0gaW5cbiAgICBsZXQgbiA9IHJlZiAwIGluXG4gICAgdHJ5XG4gICAgICAoKlxuICAgICAgaWYgcm93cyBtID0gMCB0aGVuIHJhaXNlIEV4aXQ7ICgqIEF2b2lkIGEgcHJvYmxlbSB3aXRoIHVuZGVmaW5lZCBjb2xzIGJlbG93LiAqKVxuICAgICAgZm9yIGkgPSAwIHRvIG1pbiAocm93cyBtKSAoY29scyBtKSAtIDEgZG9cbiAgICAgICAgaWYgUi5lcSBSLnplcm8gbS4oaSkuKGkpIHRoZW4gcmFpc2UgRXhpdCBlbHNlIGluY3IgblxuICAgICAgZG9uZTtcbiAgICAgICopXG4gICAgICBmb3IgaSA9IDAgdG8gcm93cyBtIC0gMSBkb1xuICAgICAgICBpZiBSb3cuaXNfemVybyBtIGkgdGhlbiByYWlzZSBFeGl0O1xuICAgICAgICBpbmNyIG5cbiAgICAgIGRvbmU7XG4gICAgICAhblxuICAgIHdpdGhcbiAgICB8IEV4aXQgLT4gIW5cblxuICAoKiogRGltZW5zaW9uIG9mIHRoZSBrZXJuZWwuICopXG4gIGxldCBudWxsaXR5IG0gPVxuICAgIHJvd3MgbSAtIHJhbmsgbVxuXG4gICgqKiBNYXRyaWNlcyB3aXRoIGxhYmVsZWQgYmFzaXMgZWxlbWVudHMuICopXG4gIG1vZHVsZSBMYWJlbGVkIChYOkFscGhhYmV0LlQpID0gc3RydWN0XG4gICAgbW9kdWxlIEwgPSBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTWFwLk1ha2UoWClcblxuICAgICAgbGV0IGZpbmQgOiBYLnQgLT4gJ2EgdCAtPiAnYSA9IGZpbmRcblxuICAgICAgbGV0IGl0ZXIgOiAoWC50IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdCA9IGl0ZXJcblxuICAgICAgbGV0IG9mX2FycmF5IChhOlgudCBhcnJheSkgPVxuICAgICAgICBsZXQgYW5zID0gcmVmIGVtcHR5IGluXG4gICAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggYSAtIDEgZG9cbiAgICAgICAgICBhbnMgOj0gYWRkIGEuKGkpIGkgIWFuc1xuICAgICAgICBkb25lO1xuICAgICAgICAhYW5zXG4gICAgZW5kXG5cbiAgICB0eXBlIG1hcCA9IGludCBMLnRcblxuICAgICgqKiBBIG1hdHJpeCB3aXRoIGxhYmVsZWQgYmFzaXMgZWxlbWVudHMuICopXG4gICAgdHlwZSB0ID0gbWFwICogbWFwICogbWF0cml4XG5cbiAgICAoKiogVW5kZXJseWluZyAobm9uLWxhYmVsZWQpIG1hdHJpeC4gKilcbiAgICBsZXQgbWF0cml4ICgoXyxfLG0pOnQpID0gbVxuXG4gICAgbGV0IHplcm8gcm93cyBjb2xzIDogdCA9XG4gICAgICBsZXQgbSA9IHplcm8gKEFycmF5Lmxlbmd0aCByb3dzKSAoQXJyYXkubGVuZ3RoIGNvbHMpIGluXG4gICAgICBMLm9mX2FycmF5IHJvd3MsIEwub2ZfYXJyYXkgY29scywgbVxuXG4gICAgKCoqIFNldCBjb2VmZmljaWVudC4gKilcbiAgICBsZXQgc2V0ICgocixjLG0pOnQpIGkgaiB4ID1cbiAgICAgIGxldCBpID0gTC5maW5kIGkgciBpblxuICAgICAgbGV0IGogPSBMLmZpbmQgaiBjIGluXG4gICAgICBtLihpKS4oaikgPC0geFxuXG4gICAgKCoqIENvZWZmaWNpZW50LiAqKVxuICAgIGxldCBnZXQgKChyLGMsbSk6dCkgaSBqID1cbiAgICAgIGxldCBpID0gTC5maW5kIGkgciBpblxuICAgICAgbGV0IGogPSBMLmZpbmQgaiBjIGluXG4gICAgICBtLihpKS4oailcblxuICAgICgqKiBSYW5rLiAqKVxuICAgIGxldCByYW5rICgocixjLG0pOnQpID0gcmFuayBtXG5cbiAgICBsZXQgbnVsbGl0eSAoKHIsYyxtKTp0KSA9IG51bGxpdHkgbVxuXG4gICAgKCoqIEl0ZXJhdGUgb3ZlciBzb3VyY2UgYmFzaXMuICopXG4gICAgbGV0IGl0ZXJfc3JjIGYgKChyLGMsbSk6dCkgPVxuICAgICAgTC5pdGVyIChmdW4geCBfIC0+IGYgeCkgclxuXG4gICAgKCoqIEl0ZXJhdGUgb3ZlciB0YXJnZXQgYmFzaXMuICopXG4gICAgbGV0IGl0ZXJfdGd0IGYgKChyLGMsbSk6dCkgPVxuICAgICAgTC5pdGVyIChmdW4geCBfIC0+IGYgeCkgY1xuXG4gICAgKCoqIEl0ZXJhdGUgb3ZlciBzb3VyY2UgYW5kIHRhcmdldCBiYXNpcy4gKilcbiAgICBsZXQgaXRlciBmIChtOnQpID1cbiAgICAgIGl0ZXJfc3JjIChmdW4geCAtPiBpdGVyX3RndCAoZnVuIHkgLT4gZiB4IHkpIG0pIG1cbiAgZW5kXG5lbmRcblxuKCoqIEZ1bmN0b3JzIGJldHdlZW4gZGlmZmVyZW50IHJpbmdzLiAqKVxubW9kdWxlIEZ1bmN0b3IgKFI6UmluZy5UKSAoUic6UmluZy5UKSA9IHN0cnVjdFxuICBtb2R1bGUgTSA9IE1ha2UoUilcbiAgbW9kdWxlIE0nID0gTWFrZShSJylcblxuICBsZXQgbWFwIGYgKG06TS50KSA6IE0nLnQgPVxuICAgIGxldCByID0gTS5yb3dzIG0gaW5cbiAgICBsZXQgYyA9IGlmIHIgPSAwIHRoZW4gMCBlbHNlIE0uY29scyBtIGluXG4gICAgTScuaW5pdCByIGMgKGZ1biBpIGogLT4gZiAoTS5nZXQgbSBpIGopKVxuXG4gIG1vZHVsZSBMYWJlbGVkIChYOkFscGhhYmV0LlQpIChYJzpBbHBoYWJldC5UKSA9IHN0cnVjdFxuICAgIG1vZHVsZSBMID0gTS5MYWJlbGVkKFgpXG4gICAgbW9kdWxlIEwnID0gTScuTGFiZWxlZChYJylcblxuICAgIGxldCBtYXAgcyB0IGYgKG06TC50KSA6IEwnLnQgPVxuICAgICAgbGV0IHIsYyxtID0gbSBpblxuICAgICAgbGV0IGxtYXAgKGY6WC50LT5YJy50KSAobDpMLm1hcCkgOiBMJy5tYXAgPSBMLkwuZm9sZCAoZnVuIHggaSBsJyAtPiBMJy5MLmFkZCAoZiB4KSBpIGwnKSBsIEwnLkwuZW1wdHkgaW5cbiAgICAgIGxldCByID0gbG1hcCBzIHIgaW5cbiAgICAgIGxldCBjID0gbG1hcCB0IGMgaW5cbiAgICAgIGxldCBtID0gbWFwIGYgbSBpblxuICAgICAgcixjLG1cbiAgZW5kXG5lbmRcbiIsIigqKiBNb2R1bGVzLiAqKVxuXG4oKiogQSBsZWZ0IG1vZHVsZS4gKilcbm1vZHVsZSB0eXBlIExlZnQgPSBzaWdcbiAgKCoqIEFuIGVsZW1lbnQgb2YgdGhlIG1vZHVsZS4gKilcbiAgdHlwZSB0XG5cbiAgKCoqIEFuIGVsZW1lbnQgb2YgdGhlIHJpbmcuICopXG4gIHR5cGUgclxuXG4gIG1vZHVsZSBSaW5nIDogc2lnXG4gICAgaW5jbHVkZSBSaW5nLlQgd2l0aCB0eXBlIHQgOj0gclxuICBlbmRcblxuICBpbmNsdWRlIEdyb3VwLkFkZGl0aXZlIHdpdGggdHlwZSB0IDo9IHRcblxuICAoKiogTGVmdCBhY3Rpb24gb2YgdGhlIHJpbmcuICopXG4gIHZhbCBjbXVsIDogciAtPiB0IC0+IHRcbmVuZFxuXG4oKiogQSByaWdodCBtb2R1bGUuICopXG5tb2R1bGUgdHlwZSBSaWdodCA9IHNpZ1xuICBpbmNsdWRlIExlZnRcblxuICAoKiogUmlnaHQgYWN0aW9uIG9mIHRoZSByaW5nLiAqKVxuICB2YWwgY211bCA6IHQgLT4gciAtPiB0XG5lbmRcblxuKCpcbigqKiBBIGJpbW9kdWxlLiAqKVxubW9kdWxlIHR5cGUgQmkgPSBzaWdcbiAgaW5jbHVkZSBMZWZ0XG4gIGluY2x1ZGUgUmlnaHRcbmVuZFxuKilcblxuKCoqIEJ5IGRlZmF1bHQsIGJ5IGEgbW9kdWxlLCB3ZSBtZWFuIGEgbGVmdCBtb2R1bGUuICopXG5tb2R1bGUgdHlwZSBUID0gTGVmdFxuXG4oKiogRnJlZSBsZWZ0IG1vZHVsZS4gKilcbm1vZHVsZSBGcmVlTGVmdCAoUiA6IFJpbmcuVCkgKFggOiBBbHBoYWJldC5UKSA9IHN0cnVjdFxuICBtb2R1bGUgUmluZyA9IFJcblxuICBtb2R1bGUgRSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgTWFwLk1ha2UoWClcblxuICAgIGxldCBhZGQgeCBhIHAgPVxuICAgICAgaWYgUi5lcSBSLnplcm8gYSB0aGVuXG4gICAgICAgIHJlbW92ZSB4IHBcbiAgICAgIGVsc2VcbiAgICAgICAgYWRkIHggYSBwXG4gIGVuZFxuXG4gICgqKiBBbiBlbGVtZW50IG9mIHRoZSByaW5nLiAqKVxuICB0eXBlIHIgPSBSLnRcblxuICAoKiogQW4gZWxlbWVudCBvZiB0aGUgbW9kdWxlLiAqKVxuICB0eXBlIHQgPSByIEUudFxuICAoKiB0eXBlIGVsZW1lbnQgPSB0ICopXG5cbiAgbGV0IHplcm8gOiB0ID0gRS5lbXB0eVxuXG4gIGxldCBjaW5qIChhOlIudCkgKHg6WC50KSA6IHQgPSBFLmFkZCB4IGEgemVyb1xuXG4gIGxldCBpbmogeCA9IGNpbmogUi5vbmUgeFxuXG4gICgqKiBDb2VmZmljaWVudCBvZiBhbiBlbGVtZW50LiAqKVxuICBsZXQgY29lZmYgKHA6dCkgKHg6WC50KSA9XG4gICAgdHJ5IEUuZmluZCB4IHBcbiAgICB3aXRoIE5vdF9mb3VuZCAtPiBSLnplcm9cblxuICBsZXQgaW5jbHVkZWQgeCB5ID1cbiAgICBFLmZvcl9hbGwgKGZ1biB1IGEgLT4gY29lZmYgeSB1ID0gYSkgKHg6dClcblxuICBsZXQgZXEgeCB5ID1cbiAgICBpbmNsdWRlZCB4IHkgJiYgaW5jbHVkZWQgeSB4XG5cbiAgbGV0IGNvbXBhcmUgXyBfID0gZmFpbHdpdGggXCJUT0RPOiBNb2R1bGUuRnJlZUxlZnQuY29tcGFyZVwiXG5cbiAgbGV0IGFkZF9tb25vbWlhbCAocDp0KSAoYTpyKSAoeDpYLnQpIDogdCA9XG4gICAgbGV0IGEgPSBSLmFkZCBhIChjb2VmZiBwIHgpIGluXG4gICAgRS5hZGQgeCBhIHBcblxuICBsZXQgYWRkIChwOnQpIChxOnQpIDogdCA9XG4gICAgRS5mb2xkIChmdW4geCBhIHAgLT4gYWRkX21vbm9taWFsIHAgYSB4KSBxIHBcblxuICBsZXQgY211bCBhICh4OnQpIDogdCA9XG4gICAgRS5tYXAgKFIubXVsIGEpIHhcblxuICBsZXQgbmVnICh4OnQpID1cbiAgICBjbXVsIChSLm5lZyBSLm9uZSkgeFxuXG4gIGxldCBzdWIgeCB5ID1cbiAgICBhZGQgeCAobmVnIHkpXG5cbiAgbGV0IHRvX3N0cmluZyAoeDp0KSA9XG4gICAgaWYgZXEgemVybyB4IHRoZW4gXCIwXCIgZWxzZVxuICAgIGxldCBhbnMgPSByZWYgXCJcIiBpblxuICAgIEUuaXRlciAoZnVuIHUgYSAtPlxuICAgICAgaWYgIWFucyA8PiBcIlwiIHRoZW4gYW5zIDo9ICFhbnMgXiBcIitcIjtcbiAgICAgIGxldCBhID1cbiAgICAgICAgaWYgUi5lcSBhIFIub25lIHRoZW4gXCJcIiBlbHNlXG4gICAgICAgICAgXCIoXCIgXiBSLnRvX3N0cmluZyBhIF4gXCIpXCIgXiBcIipcIlxuICAgICAgaW5cbiAgICAgIGFucyA6PSAhYW5zIF4gYSBeIFgudG9fc3RyaW5nIHVcbiAgICApIHg7XG4gICAgIWFuc1xuXG4gICgqKiBNYXAgYSBsaW5lYXIgZnVuY3Rpb24uICopXG4gIGxldCBtYXAgZiAocDp0KSA9XG4gICAgRS5mb2xkIChmdW4gKHg6WC50KSBhIHEgLT4gYWRkIHEgKGNtdWwgYSAoZiB4KSkpIHAgemVyb1xuXG4gIGxldCBpdGVyIGYgcCA9XG4gICAgRS5pdGVyIChmdW4gKHg6WC50KSAoYTpSLnQpIC0+IGYgYSB4KSBwXG5cbiAgKCoqIE1vcnBoaXNtcyBiZXR3ZWVuIGZyZWUgbW9kdWxlcy4gKilcbiAgbW9kdWxlIE1hcCA9IHN0cnVjdFxuICAgIG1vZHVsZSBFID0gTWFwLk1ha2UoWClcblxuICAgIHR5cGUgbWFwID0gdCBFLnRcblxuICAgICgqKiBEZWZpbmUgYSBtYXAgb24gYSBnZW5lcmF0b3IuICopXG4gICAgbGV0IHNldCAoZjptYXApICh4OlgudCkgKHA6dCkgOiBtYXAgPVxuICAgICAgRS5hZGQgeCBwIGZcblxuICAgICgqKiBBcHBseSBhIG1hcCB0byBhIGJhc2lzIGVsZW1lbnQgKGRlZmF1bHRpbmcgdG8gMC4pLiAqKVxuICAgIGxldCBhcHAgKGY6bWFwKSAoeDpYLnQpID1cbiAgICAgIHRyeVxuICAgICAgICBFLmZpbmQgeCBmXG4gICAgICB3aXRoXG4gICAgICB8IE5vdF9mb3VuZCAtPiB6ZXJvXG5cbiAgICAoKiogRXh0ZW5zaW9uIG9mIHRoZSBtYXAgdG8gYWxsIGVsZW1lbnRzIG9mIHRoZSBmcmVlIG1vZHVsZS4gKilcbiAgICBsZXQgYmluZCBmIChwOnQpID1cbiAgICAgIEUuZm9sZCAoZnVuICh4OlgudCkgYSBxIC0+IGFkZCBxIChjbXVsIGEgKGFwcCBmIHgpKSkgcCB6ZXJvXG5cbiAgICAoKiogVGhlIG51bGwgbW9ycGhpc20uICopXG4gICAgbGV0IHplcm8gOiBtYXAgPSBFLmVtcHR5XG5cbiAgICBsZXQgdG9fc3RyaW5nIChmOm1hcCkgPVxuICAgICAgRS5mb2xkIChmdW4gKHg6WC50KSAocDp0KSBzIC0+IHMgXiAoWC50b19zdHJpbmcgeCkgXiBcIiAtPiBcIiBeICh0b19zdHJpbmcgcCkgXiBcIlxcblwiKSBmIFwiXCJcblxuICAgIHR5cGUgdCA9IG1hcFxuICBlbmRcblxuICAoKiogQSBwcmVzZW50YXRpb24gb2YgYSBmcmVlIG1vZHVsZSAoYSBiYXNpcykuICopXG4gIG1vZHVsZSBQcmVzID0gc3RydWN0XG4gICAgKCoqIEEgcHJlc2VudGF0aW9uLiAqKVxuICAgIHR5cGUgcHJlcyA9IFgudCBhcnJheVxuXG4gICAgdHlwZSB0ID0gcHJlc1xuXG4gICAgKCoqIENyZWF0ZSBhIHByZXNlbnRhdGlvbi4gKilcbiAgICBsZXQgbWFrZSBnZW4gPSAoZ2VuIDogdClcblxuICAgICgqKiBEaW1lbnNpb24gb2YgYSBwcmVzZW50YXRpb24uICopXG4gICAgbGV0IGRpbSAocHJlcyA6IHQpID0gQXJyYXkubGVuZ3RoIHByZXNcblxuICAgIGxldCBwcmVzZW50YXRpb25fdG9fc3RyaW5nIHByZXMgPVxuICAgICAgbGV0IGFucyA9IHJlZiBcIlwiIGluXG4gICAgICBBcnJheS5pdGVyIChmdW4geCAtPlxuICAgICAgICBhbnMgOj0gIWFucyBeIChpZiAhYW5zID0gXCJcIiB0aGVuIFwiXCIgZWxzZSBcIiBcIikgXiBYLnRvX3N0cmluZyB4XG4gICAgICApIHByZXM7XG4gICAgICAhYW5zXG5cbiAgICAoKiogTGluZWFyIG1hcHMgYmV0d2VlbiBwcmVzZW50YXRpb25zLiAqKVxuICAgIG1vZHVsZSBNYXAgPSBzdHJ1Y3RcbiAgICAgIG1vZHVsZSBNID0gTWF0cml4Lk1ha2UoUilcbiAgICAgIG1vZHVsZSBMID0gTS5MYWJlbGVkKFgpXG5cbiAgICAgICgqKiBBIGxpbmVhciBtYXAgKGVuY29kZWQgYXMgYSBtYXRyaXgpLiAqKVxuICAgICAgdHlwZSBtYXAgPSBMLnRcbiAgICAgIHR5cGUgdCA9IG1hcFxuXG4gICAgICAoKiogQXBwbHkgYSBtb3JwaGlzbSB0byBhbiBlbGVtZW50LiAqKVxuICAgICAgbGV0IGFwcCAoZjp0KSBwID1cbiAgICAgICAgbWFwIChmdW4geCAtPlxuICAgICAgICAgIGxldCBhbnMgPSByZWYgemVybyBpblxuICAgICAgICAgIEwuaXRlcl90Z3QgKGZ1biB5IC0+XG4gICAgICAgICAgICBhbnMgOj0gYWRkICFhbnMgKGNpbmogKEwuZ2V0IGYgeCB5KSB5KVxuICAgICAgICAgICkgZjtcbiAgICAgICAgICAhYW5zXG4gICAgICAgICkgcFxuICAgICAgICBcbiAgICAgICgqKiBUaGUgemVybyBtb3JwaGlzbS4gKilcbiAgICAgIGxldCB6ZXJvIHNyYyB0Z3QgOiB0ID0gTC56ZXJvIHNyYyB0Z3RcblxuICAgICAgKCoqIENyZWF0ZSBmcm9tIGEgbWFwIHdpdGggZ2l2ZW4gc291cmNlIGFuZCB0YXJnZXQuICopXG4gICAgICBsZXQgb2ZfbWFwIGYgc3JjIHRndCA9XG4gICAgICAgIGxldCBhbnMgPSB6ZXJvIHNyYyB0Z3QgaW5cbiAgICAgICAgQXJyYXkuaXRlciAoZnVuIHggLT5cbiAgICAgICAgICBsZXQgcCA9IE1hcC5hcHAgZiB4IGluXG4gICAgICAgICAgaXRlciAoZnVuIGEgeSAtPiBMLnNldCBhbnMgeCB5IChSLmFkZCAoTC5nZXQgYW5zIHggeSkgYSkpIHBcbiAgICAgICAgKSBzcmM7XG4gICAgICAgIGFuc1xuXG4gICAgICAoKiogQ29udmVydCB0byBhIG1hcC4gKilcbiAgICAgIGxldCB0b19tYXAgKGY6dCkgPVxuICAgICAgICBsZXQgYW5zID0gcmVmIE1hcC56ZXJvIGluXG4gICAgICAgIEwuaXRlciAoZnVuIHggeSAtPlxuICAgICAgICAgIGFucyA6PSBNYXAuc2V0ICFhbnMgeCAoYWRkIChNYXAuYXBwICFhbnMgeCkgKGNpbmogKEwuZ2V0IGYgeCB5KSB5KSlcbiAgICAgICAgKSBmO1xuICAgICAgICAhYW5zXG5cbiAgICAgICgqKiBSYW5rIG9mIGEgbWFwLiAqKVxuICAgICAgbGV0IHJhbmsgOiB0IC0+IGludCA9IEwucmFua1xuXG4gICAgICAoKiogTnVsbGl0eSBvZiBhIG1hcC4gKilcbiAgICAgIGxldCBudWxsaXR5IDogdCAtPiBpbnQgPSBMLm51bGxpdHlcblxuICAgICAgKCogVE9ETzogaW1wcm92ZSB0aGlzICopXG4gICAgICBsZXQgdG9fc3RyaW5nIGYgPVxuICAgICAgICBNYXAudG9fc3RyaW5nICh0b19tYXAgZilcbiAgICBlbmRcblxuICAgICgqKiBJdGVyYXRlIGEgZnVuY3Rpb24gb24gdGhlIGdlbmVyYXRvcnMgb2YgYSBtb2R1bGUuICopXG4gICAgbGV0IGl0ZXIgZiAocHJlczp0KSA9IEFycmF5Lml0ZXIgZiBwcmVzXG5cbiAgICAoKiogQ2hhaW4gY29tcGxleGVzIGJldHdlZW4gZnJlZSBtb2R1bGVzLiAqKVxuICAgIG1vZHVsZSBDb21wbGV4ID0gc3RydWN0XG4gICAgICAoKiogQSBjaGFpbiBjb21wbGV4LiAqKVxuICAgICAgdHlwZSB0ID1cbiAgICAgICAge1xuICAgICAgICAgIG1vZHVsZXMgOiBwcmVzIGFycmF5O1xuICAgICAgICAgIGQgOiBNYXAudCBhcnJheVxuICAgICAgICB9XG5cbiAgICAgIGxldCBtb2R1bGVzIGMgPSBjLm1vZHVsZXNcblxuICAgICAgbGV0IG1hcHMgYyA9IGMuZFxuXG4gICAgICAoKiogTGVuZ3RoIG9mIGEgY2hhaW4gY29tcGxleC4gKilcbiAgICAgIGxldCBsZW5ndGggYyA9IEFycmF5Lmxlbmd0aCBjLmRcblxuICAgICAgKCoqIENyZWF0ZSBhIGNoYWluIGNvbXBsZXguICopXG4gICAgICBsZXQgbWFrZSBtb2R1bGVzIGQgPVxuICAgICAgICBhc3NlcnQgKEFycmF5Lmxlbmd0aCBtb2R1bGVzID0gQXJyYXkubGVuZ3RoIGQgKyAxKTtcbiAgICAgICAgeyBtb2R1bGVzOyBkIH1cblxuICAgICAgKCoqIEVuc3VyZSB0aGF0IGEgY2hhaW4gY29tcGxleCBzYXRzaWZpZXMgZF4yPTAuICopXG4gICAgICBsZXQgdmFsaWQgYyA9XG4gICAgICAgIHRyeVxuICAgICAgICAgIGZvciBpID0gMSB0byBsZW5ndGggYyAtIDEgZG9cbiAgICAgICAgICAgIGl0ZXIgKGZ1biB4IC0+XG4gICAgICAgICAgICAgIGxldCB5ID0gTWFwLmFwcCBjLmQuKGktMSkgKE1hcC5hcHAgYy5kLihpKSAoaW5qIHgpKSBpblxuICAgICAgICAgICAgICBpZiBub3QgKGVxIHplcm8geSkgdGhlblxuICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgIFByaW50Zi5wcmludGYgXCJpbnZhbGlkOiAlZFxcbiUhXCIgaTtcbiAgICAgICAgICAgICAgICAgIFByaW50Zi5wcmludGYgXCJkKCVzKSA9ICVzXFxuJSFcIiAoWC50b19zdHJpbmcgeCkgKHRvX3N0cmluZyAoTWFwLmFwcCBjLmQuKGkpIChpbmogeCkpKTtcbiAgICAgICAgICAgICAgICAgIFByaW50Zi5wcmludGYgXCJkXjIoJXMpID0gJXNcXG4lIVwiIChYLnRvX3N0cmluZyB4KSAodG9fc3RyaW5nIChNYXAuYXBwIGMuZC4oaS0xKSAoTWFwLmFwcCBjLmQuKGkpIChpbmogeCkpKSk7XG4gICAgICAgICAgICAgICAgICByYWlzZSBFeGl0XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSBjLm1vZHVsZXMuKGkrMSlcbiAgICAgICAgICBkb25lO1xuICAgICAgICAgIHRydWVcbiAgICAgICAgd2l0aFxuICAgICAgICB8IEV4aXQgLT4gZmFsc2VcblxuICAgICAgKCoqIFN0cmluZyByZXByZXNlbnRhdGlvbi4gKilcbiAgICAgIGxldCB0b19zdHJpbmcgYyA9XG4gICAgICAgIGxldCBhbnMgPSByZWYgXCJcIiBpblxuICAgICAgICAoKiBhbnMgOj0gIWFucyBeIFwiQ1wiIF4gc3RyaW5nX29mX2ludCAobGVuZ3RoIGMpIF4gXCI6IFwiIF4gcHJlc2VudGF0aW9uX3RvX3N0cmluZyBjLm1vZHVsZXMuKGxlbmd0aCBjKSBeIFwiXFxuXFxuXCI7ICopXG4gICAgICAgIGZvciBpID0gbGVuZ3RoIGMgLSAxIGRvd250byAwIGRvXG4gICAgICAgICAgYW5zIDo9ICFhbnMgXiBcImRcIiBeIHN0cmluZ19vZl9pbnQgaSBeIFwiOlxcblwiIF4gTWFwLnRvX3N0cmluZyBjLmQuKGkpIF4gXCJcXG5cIjtcbiAgICAgICAgICAoKiBhbnMgOj0gIWFucyBeIFwiQ1wiIF4gc3RyaW5nX29mX2ludCBpIF4gXCI6IFwiIF4gcHJlc2VudGF0aW9uX3RvX3N0cmluZyBjLm1vZHVsZXMuKGkpIF4gXCJcXG5cXG5cIiAqKVxuICAgICAgICBkb25lO1xuICAgICAgICAhYW5zXG5cbiAgICAgICgqKiBDb21wdXRlIGJldHRpIG51bWJlcnMgZm9yIHRoZSBjb21wbGV4LiAqKVxuICAgICAgbGV0IGJldHRpIGMgPVxuICAgICAgICBBcnJheS5pbml0IChsZW5ndGggYykgKGZ1biBpIC0+XG4gICAgICAgICAgbGV0IGtlciA9IGlmIGkgPSAwIHRoZW4gZGltIGMubW9kdWxlcy4oMCkgZWxzZSBNYXAubnVsbGl0eSBjLmQuKGktMSkgaW5cbiAgICAgICAgICBsZXQgaW0gPSBNYXAucmFuayBjLmQuKGkpIGluXG4gICAgICAgICAga2VyIC0gaW1cbiAgICAgICAgKVxuICAgIGVuZFxuXG4gICAgKCoqIFN0cmluZyByZXByZXNlbnRhdGlvbi4gKilcbiAgICBsZXQgdG9fc3RyaW5nID0gcHJlc2VudGF0aW9uX3RvX3N0cmluZ1xuICBlbmRcbmVuZFxubW9kdWxlIEZyZWVMZWZ0TW9kdWxlIChSIDogUmluZy5UKSAoWCA6IEFscGhhYmV0LlQpID0gKEZyZWVMZWZ0KFIpKFgpIDogTGVmdClcbm1vZHVsZSBGcmVlIChSIDogUmluZy5UKSAoWCA6IEFscGhhYmV0LlQpID0gRnJlZUxlZnQoUikoWClcblxubW9kdWxlIEZyZWVSaWdodCAoUiA6IFJpbmcuVCkgKFggOiBBbHBoYWJldC5UKSA9IHN0cnVjdFxuICBpbmNsdWRlIEZyZWVMZWZ0KFJpbmcuT3AoUikpKFgpXG5cbiAgbGV0IGNpbmogeCBhID0gY2luaiBhIHhcbiAgICBcbiAgbGV0IGNtdWwgeCBhID0gY211bCBhIHhcblxuICBsZXQgdG9fc3RyaW5nICh4OnQpID1cbiAgICBsZXQgYW5zID0gcmVmIFwiXCIgaW5cbiAgICBFLml0ZXIgKGZ1biB1IGEgLT5cbiAgICAgIGlmIG5vdCAoUi5lcSBhIFIuemVybykgdGhlblxuICAgICAgICAoXG4gICAgICAgICAgaWYgIWFucyA8PiBcIlwiIHRoZW4gYW5zIDo9ICFhbnMgXiBcIitcIjtcbiAgICAgICAgICBsZXQgYSA9XG4gICAgICAgICAgICBpZiBSLmVxIGEgUi5vbmUgdGhlbiBcIlwiIGVsc2VcbiAgICAgICAgICAgICAgXCIqXCIgXiBcIihcIiBeIFIudG9fc3RyaW5nIGEgXiBcIilcIlxuICAgICAgICAgIGluXG4gICAgICAgICAgYW5zIDo9ICFhbnMgXiBYLnRvX3N0cmluZyB1IF4gYVxuICAgICAgICApXG4gICAgKSB4O1xuICAgICFhbnNcbmVuZFxubW9kdWxlIEZyZWVSaWdodE1vZHVsZSAoUiA6IFJpbmcuVCkgKFggOiBBbHBoYWJldC5UKSA9IChGcmVlUmlnaHQoUikoWCkgOiBSaWdodClcbiIsIigqKiBBbGdlYnJhcy4gKilcblxuKCoqIEFuIGFsZ2VicmEuICopXG5tb2R1bGUgdHlwZSBUID0gc2lnXG4gICgqKiBBbiBlbGVtZW50IG9mIHRoZSBhbGdlYnJhLiAqKVxuICB0eXBlIHRcblxuICAoKiogQW4gZWxlbWVudCBvZiB0aGUgcmluZy4gKilcbiAgdHlwZSByXG5cbiAgaW5jbHVkZSBSaW5nLlQgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIG1vZHVsZSBGaWVsZCA6IHNpZ1xuICAgIGluY2x1ZGUgRmllbGQuVCB3aXRoIHR5cGUgdCA6PSByXG4gIGVuZFxuXG4gIHZhbCBjbXVsIDogciAtPiB0IC0+IHRcbmVuZFxuXG4oKiogQWxnZWJyYXMgb3ZlciByaW5ncyAoY29udGFyaWx5IHRvIHVzdWFsIGFsZ2VicmFzIHdoaWNoIGFyZSBvdmVyIGZpZWxkcykuICopXG5tb2R1bGUgT3ZlclJpbmcgPSBzdHJ1Y3RcbiAgKCoqIEZyZWUgYWxnZWJyYSBvZiBhIG1vbm9pZCBvdmVyIGEgcmluZy4gKilcbiAgbW9kdWxlIEZyZWUgKEsgOiBSaW5nLlQpIChNIDogTW9ub2lkLlQpID0gc3RydWN0XG4gICAgaW5jbHVkZSBNb2R1bGUuRnJlZUxlZnQoSykoTSlcblxuICAgIGxldCBvbmUgPSBpbmogTS5vbmVcblxuICAgIGxldCBtdWxfbW9ub21pYWwgcCB2ID1cbiAgICAgIG1hcCAoZnVuIHUgLT4gaW5qIChNLm11bCB1IHYpKSBwXG5cbiAgICBsZXQgbXVsIHAgcSA9XG4gICAgICBtYXAgKGZ1biB2IC0+IG11bF9tb25vbWlhbCBwIHYpIHFcblxuICAgIGxldCBsZWFkaW5nIGxlcSAocDp0KSA6IEsudCAqIE0udCA9XG4gICAgICBsZXQgYSA9IHJlZiBLLnplcm8gaW5cbiAgICAgIGxldCB1ID0gcmVmIE0ub25lIGluXG4gICAgICBpdGVyIChmdW4gYiB2IC0+IGlmIGxlcSAhdSB2IHRoZW4gKGEgOj0gYjsgdSA6PSB2KSkgcDtcbiAgICAgICFhLCAhdVxuICBlbmRcbmVuZFxuXG4oKiogRnJlZSBhbGdlYnJhIG9mIGEgbW9ub2lkIG92ZXIgYSBmaWVsZC4gKilcbm1vZHVsZSBGcmVlIChLIDogRmllbGQuVCkgKE0gOiBNb25vaWQuVCkgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBPdmVyUmluZy5GcmVlKEspKE0pXG5cbiAgbW9kdWxlIEZpZWxkID0gS1xuZW5kXG5tb2R1bGUgRnJlZUFsZ2VicmEgKEsgOiBGaWVsZC5UKSAoTSA6IE1vbm9pZC5UKSA9IChGcmVlKEspKE0pIDogVClcblxuKCoqIFByZXNlbnRhdGlvbiBvZiBhbiBhbGdlYnJhLiAqKVxubW9kdWxlIFByZXMgKEsgOiBGaWVsZC5UKSAoWCA6IEFscGhhYmV0LlQpID0gc3RydWN0XG4gIG1vZHVsZSBNID0gTW9ub2lkLkZyZWUoWClcbiAgbW9kdWxlIEEgPSBGcmVlKEspKE0pXG5cbiAgdHlwZSB0ID1cbiAgICB7XG4gICAgICBsZXEgOiBNLnQgLT4gTS50IC0+IGJvb2w7XG4gICAgICBnZW5lcmF0b3JzIDogWC50IGxpc3Q7XG4gICAgICBydWxlcyA6IChNLnQgKiBBLnQpIGxpc3Q7XG4gICAgfVxuXG4gIGxldCBmcmVlIGxlcSBnZW5lcmF0b3JzID1cbiAgICBsZXQgcnVsZXMgPSBbXSBpblxuICAgIHsgbGVxOyBnZW5lcmF0b3JzOyBydWxlcyB9XG5cbiAgKCoqIE9yaWVudCBhIHBvbHlub21pYWwgYXMgYSBydWxlLiAqKVxuICBsZXQgb3JpZW50IHByZXMgcCA9XG4gICAgbGV0IGEsdSA9IEEubGVhZGluZyBwcmVzLmxlcSBwIGluXG4gICAgbGV0IHAgPSBBLmNtdWwgKEsuaW52IGEpIHAgaW5cbiAgICBsZXQgcCA9IEEuc3ViIChBLmluaiB1KSBwIGluXG4gICAgdSxwXG5cbiAgKCoqIEFkZCBhIHJ1bGUgdG8gYSBwcmVzZW50YXRpb24uICopXG4gIGxldCBhZGRfcnVsZSBwcmVzIHIgPVxuICAgIGxldCBydWxlcyA9IHIgOjogcHJlcy5ydWxlcyBpblxuICAgIHsgcHJlcyB3aXRoIHJ1bGVzIH1cblxuICAoKiogQWRkIGEgcmVsYXRpb24gdG8gYSBwcmVzZW50YXRpb24uICopXG4gIGxldCBhZGRfcmVsYXRpb24gcHJlcyBwID1cbiAgICBhZGRfcnVsZSBwcmVzIChvcmllbnQgcHJlcyBwKVxuXG4gICgqKiBDcmVhdGUgYSBwcmVzZW50YXRpb24gZnJvbSBhbiBhbHBoYWJldCBhbmQgYSBsaXN0IG9mIG1vbm9taWFscy4gKilcbiAgbGV0IG1ha2UgbGVxIGdlbmVyYXRvcnMgcHAgOiB0ID1cbiAgICBMaXN0LmZvbGRfbGVmdCBhZGRfcmVsYXRpb24gKGZyZWUgbGVxIGdlbmVyYXRvcnMpIHBwXG5cbiAgKCoqIE1pbmltYWwgcmVkdWNpYmxlIHdvcmRzLiAqKVxuICBsZXQgaGVhZHMgcHJlcyA9XG4gICAgTGlzdC5tYXAgKGZ1biAodSxwKSAtPiB1KSBwcmVzLnJ1bGVzXG5cbiAgbGV0IHRvX3N0cmluZyBwcmVzID1cbiAgICBcIjwgXCJcbiAgICBeIFN0cmluZy5jb25jYXQgXCIgXCIgKExpc3QubWFwIFgudG9fc3RyaW5nIHByZXMuZ2VuZXJhdG9ycykgXiBcIiB8IFwiXG4gICAgXiBTdHJpbmcuY29uY2F0IFwiICwgXCIgKExpc3QubWFwIChmdW4gKHUscCkgLT4gTS50b19zdHJpbmcgdSBeIFwiIC0+IFwiIF4gQS50b19zdHJpbmcgcCkgcHJlcy5ydWxlcylcbiAgICBeIFwiID5cIlxuXG4gICgqKiBOb3JtYWxpemUgd29yZHMuICopXG4gIGxldCBub3JtYWxpemUgcHJlcyBwID1cbiAgICBsZXQgcCA9IHJlZiBwIGluXG4gICAgbGV0IGxvb3AgPSByZWYgdHJ1ZSBpbiBcbiAgICB3aGlsZSAhbG9vcCBkb1xuICAgICAgbG9vcCA6PSBmYWxzZTtcbiAgICAgIHAgOj0gQS5tYXAgKGZ1biB1IC0+XG4gICAgICAgIHRyeVxuICAgICAgICAgIGxldCB2LHYnID0gTGlzdC5maW5kIChmdW4gKHYsXykgLT4gTS5pbmNsdWRlZCB2IHUpIHByZXMucnVsZXMgaW5cbiAgICAgICAgICBsb29wIDo9IHRydWU7XG4gICAgICAgICAgbGV0IGkgPSBNLnVuaWZpZXIgdSB2IGluXG4gICAgICAgICAgbGV0IHYxID0gTS5zdWIgdSAwIGkgaW5cbiAgICAgICAgICBsZXQgdjIgPSBNLnN1YiB1IChpICsgTS5sZW5ndGggdikgKE0ubGVuZ3RoIHUgLSAoaSArIE0ubGVuZ3RoIHYpKSBpblxuICAgICAgICAgIGxldCB2MSA9IEEuaW5qIHYxIGluXG4gICAgICAgICAgbGV0IHYyID0gQS5pbmogdjIgaW5cbiAgICAgICAgICBBLm11bCB2MSAoQS5tdWwgdicgdjIpXG4gICAgICAgIHdpdGhcbiAgICAgICAgfCBOb3RfZm91bmQgLT4gQS5pbmogdVxuICAgICAgKSAhcFxuICAgIGRvbmU7XG4gICAgIXBcblxuICAoKiogQnVjaGJlcmdlcidzIGNvbXBsZXRpb24gYWxnb3JpdGhtLiAqKVxuICBsZXQgYnVjaGJlcmdlciBwcmVzID1cbiAgICAoKiBUT0RPOiBub3JtYWxpemUgdGhlIHByZXNlbnRhdGlvbiBmaXJzdCAqKVxuICAgIGxldCB0b2RvID0gUXVldWUuY3JlYXRlICgpIGluXG4gICAgTGlzdC5pdGVyIChmdW4gciAtPiBRdWV1ZS5hZGQgciB0b2RvKSBwcmVzLnJ1bGVzO1xuICAgIGxldCBwcmVzID0gcmVmIHByZXMgaW5cbiAgICAoKiBBZGQgYSByZWxhdGlvbiAqKVxuICAgIGxldCByZWwgcCA9XG4gICAgICAoKiBQcmludGYucHJpbnRmIFwicmVsOiAlc1xcbiUhXCIgKEEudG9fc3RyaW5nIHApOyAqKVxuICAgICAgaWYgbm90IChBLmVxIEEuemVybyBwKSB0aGVuXG4gICAgICAgIGxldCByID0gb3JpZW50ICFwcmVzIHAgaW5cbiAgICAgICAgcHJlcyA6PSBhZGRfcnVsZSAhcHJlcyByO1xuICAgICAgICBRdWV1ZS5wdXNoIHIgdG9kb1xuICAgIGluXG4gICAgd2hpbGUgbm90IChRdWV1ZS5pc19lbXB0eSB0b2RvKSBkb1xuICAgICAgbGV0IHUscCA9IFF1ZXVlLnBvcCB0b2RvIGluXG4gICAgICBMaXN0Lml0ZXIgKGZ1biAodixxKSAtPlxuICAgICAgICBMaXN0Lml0ZXIgKGZ1biAoKHUxLHUyKSwodjEsdjIpKSAtPlxuICAgICAgICAgICgqIFByaW50Zi5wcmludGYgXCJ1bmlmaWVyOiAlc3wlcy0+JXN8JXMgdnMgJXN8JXMtPiVzfCVzXFxuJSFcIiAqKVxuICAgICAgICAgICAgKCogKE0udG9fc3RyaW5nIHUxKSAoTS50b19zdHJpbmcgdSkgKEEudG9fc3RyaW5nIHApIChNLnRvX3N0cmluZyB1MikgKilcbiAgICAgICAgICAgICgqIChNLnRvX3N0cmluZyB2MSkgKE0udG9fc3RyaW5nIHYpIChBLnRvX3N0cmluZyBxKSAoTS50b19zdHJpbmcgdjIpOyAqKVxuICAgICAgICAgICgqIENvbXB1dGUgdGhlIFMtcG9seW5vbWlhbCAqKVxuICAgICAgICAgIGxldCB1MSA9IEEuaW5qIHUxIGluXG4gICAgICAgICAgbGV0IHUyID0gQS5pbmogdTIgaW5cbiAgICAgICAgICBsZXQgdjEgPSBBLmluaiB2MSBpblxuICAgICAgICAgIGxldCB2MiA9IEEuaW5qIHYyIGluXG4gICAgICAgICAgbGV0IHMxID0gQS5tdWwgdTEgKEEubXVsIHAgdTIpIGluXG4gICAgICAgICAgbGV0IHMyID0gQS5tdWwgdjEgKEEubXVsIHEgdjIpIGluXG4gICAgICAgICAgbGV0IHMgPSBBLnN1YiBzMSBzMiBpblxuICAgICAgICAgIGxldCBzID0gbm9ybWFsaXplICFwcmVzIHMgaW5cbiAgICAgICAgICByZWwgc1xuICAgICAgICApIChNLnVuaWZpZXJzX2JpY29udGV4dCB1IHYpXG4gICAgICApICFwcmVzLnJ1bGVzXG4gICAgZG9uZTtcbiAgICAhcHJlc1xuXG4gICgqKiBSZWR1Y2UgYSBwcmVzZW50YXRpb24uICopXG4gIGxldCByZWR1Y2UgcHJlcyA9XG4gICAgbGV0IHJ1bGVzID0gcHJlcy5ydWxlcyBpblxuICAgIGxldCBydWxlcyA9IExpc3QubWFwIChmdW4gKHUscCkgLT4gdSwgbm9ybWFsaXplIHByZXMgcCkgcnVsZXMgaW5cbiAgICBsZXQgcmVjIGF1eCBhY2MgPSBmdW5jdGlvblxuICAgICAgfCAodSxwKTo6cnVsZXMgLT5cbiAgICAgICAgIGxldCBmIGwgPSBMaXN0LmV4aXN0cyAoZnVuICh2LHEpIC0+IE0uaW5jbHVkZWQgdiB1KSBsIGluXG4gICAgICAgICBpZiBmIGFjYyB8fCBmIHJ1bGVzIHRoZW4gYXV4IGFjYyBydWxlcyBlbHNlIGF1eCAoKHUscCk6OmFjYykgcnVsZXNcbiAgICAgIHwgW10gLT4gTGlzdC5yZXYgYWNjXG4gICAgaW5cbiAgICBsZXQgcnVsZXMgPSBhdXggW10gcnVsZXMgaW5cbiAgICB7IHByZXMgd2l0aCBydWxlcyB9XG5cbiAgKCoqIEFsZ2VicmEgZ2l2ZW4gYnkgYSBjb252ZXJnZW50IHByZXNlbnRhdGlvbi4gKilcbiAgbW9kdWxlIEFsZ2VicmEgKFAgOiBzaWcgdmFsIHByZXNlbnRhdGlvbiA6IHQgZW5kKSA6IFQgd2l0aCB0eXBlIHQgPSBBLnQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIEFcblxuICAgIGxldCBuZiA9IG5vcm1hbGl6ZSBQLnByZXNlbnRhdGlvblxuXG4gICAgKCogbGV0IGluaiBtID0gbmYgKGluaiBtKSAqKVxuXG4gICAgKCogbGV0IGNpbmogYyBtID0gbmYgKGNpbmogYyBtKSAqKVxuXG4gICAgbGV0IG11bCBwIHEgPSBuZiAobXVsIHAgcSlcbiAgZW5kXG5cbiAgKCoqIEF1Z21lbnRhdGlvbnMgZm9yIHByZXNlbnRlZCBhbGdlYnJhcy4gKilcbiAgbW9kdWxlIEF1Z21lbnRhdGlvbiA9IHN0cnVjdFxuICAgICgqKiBBbiBhdWdtZW50YXRpb24uICopXG4gICAgdHlwZSB0ID0gQS50IC0+IEsudFxuXG4gICAgKCoqIEludmFsaWQgYXVnbWVudGF0aW9uLiAqKVxuICAgIGV4Y2VwdGlvbiBJbnZhbGlkXG5cbiAgICAoKiogQ29uc3RydWN0IGFuIGF1Z21lbnRhdGlvbiBieSBkZWZpbmluZyBpdCBvbiBnZW5lcmF0b3JzLiAqKVxuICAgIGxldCBtYWtlIHByZXMgKGVwcyA6IE0udCAtPiBLLnQpIDogdCA9XG4gICAgICAoKiBUT0RPOiB1c2UgYSBnZW5lcmljIGZ1bmN0aW9uICopXG4gICAgICBsZXQgZXBzIHAgPVxuICAgICAgICBsZXQgYW5zID0gcmVmIEsuemVybyBpblxuICAgICAgICBBLml0ZXIgKGZ1biBhIHUgLT5cbiAgICAgICAgICBhbnMgOj0gSy5hZGQgIWFucyAoSy5tdWwgYSAoZXBzIHUpKVxuICAgICAgICApIHA7XG4gICAgICAgICFhbnNcbiAgICAgIGluXG4gICAgICAoKiBFbnN1cmUgdGhhdCBpdCBpcyB3ZWxsLWRlZmluZWQuICopXG4gICAgICBhc3NlcnQgKEsuZXEgSy5vbmUgKGVwcyAoQS5pbmogTS5vbmUpKSk7XG4gICAgICBMaXN0Lml0ZXIgKGZ1biAodSxwKSAtPlxuICAgICAgICBpZiBub3QgKEsuZXEgKGVwcyAoQS5pbmogdSkpIChlcHMgcCkpIHRoZW4gcmFpc2UgSW52YWxpZFxuICAgICAgKSBwcmVzLnJ1bGVzO1xuICAgICAgZXBzXG5cbiAgICAoKiogVHJhZGl0aW9uYWwgYXVnbWVudGF0aW9uIGZvciBncmFkZWQgYWxnZWJyYXMuICopXG4gICAgbGV0IGdyYWRlZCBwcmVzID1cbiAgICAgIG1ha2UgcHJlcyAoZnVuIHUgLT4gaWYgTS5lcSBNLm9uZSB1IHRoZW4gSy5vbmUgZWxzZSBLLnplcm8pXG5cbiAgICAoKiogVHJhZGl0aW9uYWwgYXVnbWVudGF0aW9uIGZvciBtb25vaWRzIC8gZ3JvdXBzLiAqKVxuICAgIGxldCBtb25vaWQgcHJlcyA9XG4gICAgICBtYWtlIHByZXMgKGZ1biB1IC0+IEsub25lKVxuICBlbmRcblxuICAoKiogQW5pY2sgcmVzb2x1dGlvbi4gKilcbiAgbW9kdWxlIEFuaWNrID0gc3RydWN0XG4gICAgdHlwZSBjaGFpbiA9IE0uQW5pY2sudFxuXG4gICAgbW9kdWxlIEFNb2QgPSBzdHJ1Y3RcbiAgICAgIG1vZHVsZSBNb2QgPSBNb2R1bGUuRnJlZVJpZ2h0KEEpKE0uQW5pY2spXG5cbiAgICAgIGluY2x1ZGUgKE1vZCA6IG1vZHVsZSB0eXBlIG9mIE1vZCB3aXRoIG1vZHVsZSBNYXAgOj0gTW9kLk1hcClcblxuICAgICAgKCoqIE5vcm1hbGl6ZSBhIHBvbHlub21pYWwuICopXG4gICAgICBsZXQgbm9ybWFsaXplIHByZXMgcCA9XG4gICAgICAgIGxldCBhbnMgPSByZWYgemVybyBpblxuICAgICAgICBpdGVyIChmdW4gdSBjIC0+XG4gICAgICAgICAgbGV0IHUgPSBub3JtYWxpemUgcHJlcyB1IGluXG4gICAgICAgICAgYW5zIDo9IGFkZCAhYW5zIChjaW5qIGMgdSlcbiAgICAgICAgKSBwO1xuICAgICAgICAhYW5zXG5cbiAgICAgIG1vZHVsZSBNYXAgPSBzdHJ1Y3RcbiAgICAgICAgaW5jbHVkZSBNb2QuTWFwXG5cbiAgICAgICAgKCogV2UgbmVlZCB0byByZW5vcm1hbGl6ZSB3aGVuIGFwcGx5aW5nIGEgZnVuY3Rpb24uICopXG4gICAgICAgIGxldCBiaW5kIHByZXMgZiBwID1cbiAgICAgICAgICAoKiBUT0RPOiBtb3JlIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbj8gKilcbiAgICAgICAgICBub3JtYWxpemUgcHJlcyAoYmluZCBmIHApXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICgqKiBVbmRlcmx5aW5nIFtLXS1tb2R1bGUgb2YgW0FNb2RdLiAqKVxuICAgIG1vZHVsZSBBS01vZCA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID0gQU1vZC50XG4gICAgICB0eXBlIHIgPSBLLnRcbiAgICAgIGxldCBjaW5qIGEgYyB1ID0gQU1vZC5jaW5qIGMgKEEuY2luaiBhIHUpXG4gICAgICAoKiBsZXQgaW5qIGMgdSA9IEFNb2QuY211bCBjIChBLmluaiB1KSAqKVxuICAgICAgbGV0IGNtdWwgYSBjdSA9IEFNb2QuY211bCBjdSAoQS5jbXVsIGEgQS5vbmUpXG4gICAgICBsZXQgaXRlciBmIChwOnQpID1cbiAgICAgICAgQU1vZC5pdGVyIChmdW4gdSBjIC0+IEEuaXRlciAoZnVuIGEgdSAtPiBmIGEgYyB1KSB1KSBwXG5cbiAgICAgICgqKiBNYXAgYSBbS10tbGluZWFyIGZ1bmN0aW9uLiAqKVxuICAgICAgbGV0IG1hcCBmIHAgPVxuICAgICAgICBsZXQgYW5zID0gcmVmIEFNb2QuemVybyBpblxuICAgICAgICBpdGVyIChmdW4gYSBjIHUgLT4gYW5zIDo9IEFNb2QuYWRkICFhbnMgKGNtdWwgYSAoZiBjIHUpKSkgcDtcbiAgICAgICAgIWFuc1xuICAgIGVuZFxuXG4gICAgKCoqIEFycmF5IG9mIEFuaWNrIGNoYWlucyB1cCB0byBkZWdyZWUgbi4gKilcbiAgICBsZXQgY2hhaW5zIHByZXMgbiA9XG4gICAgICBsZXQgY2MgPSBBcnJheS5tYWtlIChuKzEpIFtNLkFuaWNrLmVtcHR5XSBpblxuICAgICAgaWYgbiA+PSAxIHRoZW4gY2MuKDEpIDwtIE0uQW5pY2suc2luZ2xldG9ucyBwcmVzLmdlbmVyYXRvcnM7XG4gICAgICBsZXQgbGVmdCA9IExpc3QubWFwIGZzdCBwcmVzLnJ1bGVzIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbiAtIDEgZG9cbiAgICAgICAgY2MuKGkrMSkgPC0gTS5Bbmljay5leHRlbmQgbGVmdCBjYy4oaSlcbiAgICAgIGRvbmU7XG4gICAgICBjY1xuXG4gICAgKCoqIENvbXB1dGUgdGhlIEFuaWNrIHJlc29sdXRpb24gdG9nZXRoZXIgd2l0aCB0aGUgY29udHJhY3RpbmcgaG9tb3RvcHkuICopXG4gICAgbGV0IHJlc29sdXRpb25fY2ggP2F1Z21lbnRhdGlvbiBwcmVzIG4gPVxuICAgICAgbGV0IGRlYnVnID0gZmFsc2UgaW5cbiAgICAgICgqIFRPRE86IGNoZWNrIHRoYXQgdGhlIFJTIGlzIGNvbnZlcmdlbnQgYW5kIHJlZHVjZWQgKilcbiAgICAgIGxldCBhdWdtZW50YXRpb24gPSBtYXRjaCBhdWdtZW50YXRpb24gd2l0aCBTb21lIGF1Z21lbnRhdGlvbiAtPiBhdWdtZW50YXRpb24gfCBOb25lIC0+IEF1Z21lbnRhdGlvbi5ncmFkZWQgcHJlcyBpblxuICAgICAgaWYgZGVidWcgdGhlbiBQcmludGYucHJpbnRmIFwiUmVzb2x2aW5nLi4uXFxuJSFcIjtcbiAgICAgICgqIFRoZSBBbmljayBjaGFpbnMuICopXG4gICAgICBsZXQgY2MgPSBjaGFpbnMgcHJlcyBuIGluXG4gICAgICBsZXQgZXBzID0gYXVnbWVudGF0aW9uIGluXG4gICAgICBsZXQgZXRhIGEgPSBBLmNpbmogYSBNLm9uZSBpblxuICAgICAgKCogVGhlIGRpZmZlcmVudGlhbC4gKilcbiAgICAgIGxldCBkID0gQXJyYXkuaW5pdCBuIChmdW4gXyAtPiBBTW9kLk1hcC56ZXJvKSBpblxuICAgICAgKCogVGhlIDAtdGggZGlmZmVyZW50aWFsLiAqKVxuICAgICAgTGlzdC5pdGVyIChmdW4geCAtPlxuICAgICAgICBkLigwKSA8LSBBTW9kLk1hcC5zZXQgZC4oMClcbiAgICAgICAgICAoTS5Bbmljay5zaW5nbGV0b24geClcbiAgICAgICAgICAoQU1vZC5jaW5qXG4gICAgICAgICAgICAgKE0uQW5pY2suZW1wdHkpXG4gICAgICAgICAgICAgKGxldCB4ID0gQS5pbmogKE0uaW5qIHgpIGluXG4gICAgICAgICAgICAgIEEuc3ViIHggKGV0YSAoZXBzIHgpKSlcbiAgICAgICAgICApO1xuICAgICAgICBpZiBkZWJ1ZyB0aGVuIFByaW50Zi5wcmludGYgXCLiiILigoAoJXMpID0gJXNcXG4lIVwiXG4gICAgICAgICAgKFgudG9fc3RyaW5nIHgpIChBTW9kLnRvX3N0cmluZyAoQU1vZC5NYXAuYXBwIGQuKDApIChNLkFuaWNrLnNpbmdsZXRvbiB4KSkpXG4gICAgICApIHByZXMuZ2VuZXJhdG9ycztcbiAgICAgICgqIFRoZSBjb250cmFjdGluZyBob21vdG9weS4gKilcbiAgICAgIGxldCByZWMgY2ggbiBwID1cbiAgICAgICAgaWYgZGVidWcgdGhlbiBQcmludGYucHJpbnRmIFwizrclZCglcykgPSA/XFxuJSFcIiBuIChBTW9kLnRvX3N0cmluZyBwKTtcbiAgICAgICAgQU1vZC5pdGVyIChmdW4gdSBjIC0+IGFzc2VydCAoTS5Bbmljay5sZW5ndGggYyA9IG4pKSBwO1xuICAgICAgICAoKiBUaGUgY29udHJhY3RpbmcgaG9tb3RvcHkgaXMgb25seSBkZWZpbmVkIG9uIHRoZSBrZXJuZWwgb2YgZC4obi0xKS4gKilcbiAgICAgICAgKCogYXNzZXJ0IChuID0gMCB8fCBBTW9kLmVxIEFNb2QuemVybyAoQU1vZC5NYXAuYmluZCBwcmVzIGQuKG4tMSkgcCkpOyAqKVxuICAgICAgICBpZiBuIDw+IDAgJiYgbm90IChBTW9kLmVxIEFNb2QuemVybyAoQU1vZC5NYXAuYmluZCBwcmVzIGQuKG4tMSkgcCkpIHRoZW4gQU1vZC56ZXJvXG4gICAgICAgIGVsc2UgaWYgQU1vZC5lcSBBTW9kLnplcm8gcCB0aGVuIEFNb2QuemVyb1xuICAgICAgICBlbHNlIGlmIG4gPSAwIHRoZW5cbiAgICAgICAgICAoKiBDb250cmFjdC4gKilcbiAgICAgICAgICBsZXQgYW5zID0gcmVmIEFNb2QuemVybyBpblxuICAgICAgICAgIEFLTW9kLml0ZXIgKGZ1biBhIGMgdSAtPlxuICAgICAgICAgICAgaWYgTS5sZW5ndGggdSA9IDAgdGhlblxuICAgICAgICAgICAgICAoKiBhc3NlcnQgKE0ubGVuZ3RoIHUgPiAwKSAqKVxuICAgICAgICAgICAgICAoKiBUT0RPOiB0aGlzIGlzIG1lc3N5IGJ1dCBzaG91bGQgd29yayAoaW5zdGVhZCBBbmljayBkZWZpbmVzIHRoZSBpbWFnZSBvZiB1LTEpICopXG4gICAgICAgICAgICAgICgpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGZvciBpID0gMCB0byBNLmxlbmd0aCB1IC0gMSBkb1xuICAgICAgICAgICAgICAgIGxldCB2ID0gTS5zdWIgdSAwIGkgaW5cbiAgICAgICAgICAgICAgICBsZXQgYyA9IE0uQW5pY2suc2luZ2xldG9uIHUuKGkpIGluXG4gICAgICAgICAgICAgICAgbGV0IHUgPSBNLnN1YiB1IChpKzEpIChNLmxlbmd0aCB1IC0gKGkrMSkpIGluXG4gICAgICAgICAgICAgICAgbGV0IGEgPSBLLm11bCBhIChlcHMgKEEuaW5qIHYpKSBpblxuICAgICAgICAgICAgICAgIGFucyA6PSBBTW9kLmFkZCAhYW5zIChBS01vZC5jaW5qIGEgYyB1KVxuICAgICAgICAgICAgICBkb25lXG4gICAgICAgICAgKSBwO1xuICAgICAgICAgICFhbnNcbiAgICAgICAgZWxzZVxuICAgICAgICAgICgqIENvbXB1dGUgbGVhZGluZyBtb25vbWlhbC4gKilcbiAgICAgICAgICBsZXQgYSA9IHJlZiBLLnplcm8gaW5cbiAgICAgICAgICBsZXQgYyA9IHJlZiBNLkFuaWNrLmVtcHR5IGluXG4gICAgICAgICAgbGV0IHUgPSByZWYgTS5vbmUgaW5cbiAgICAgICAgICBsZXQgY3UgPSByZWYgTS5vbmUgaW5cbiAgICAgICAgICAoKiBUT0RPOiByZW1vdmUgdGhpcyB3aGVuIHRoZSBhbGdvcml0aG0gaXMgd29ya2luZyAqKVxuICAgICAgICAgIGlmIG5vdCAoQU1vZC5lcSBBTW9kLnplcm8gKEFNb2QuTWFwLmJpbmQgcHJlcyBkLihuLTEpIHApKSB0aGVuXG4gICAgICAgICAgICAoKiBXZSBhcmUgb25seSBkZWZpbmVkIG9uIHRoZSBrZXJuZWwuICopXG4gICAgICAgICAgICBmYWlsd2l0aCAoQU1vZC50b19zdHJpbmcgcCBeIFwiIG5vdCBpbiB0aGUga2VybmVsLlxcbiUhXCIpO1xuICAgICAgICAgIEFLTW9kLml0ZXIgKGZ1biBhJyBjJyB1JyAtPlxuICAgICAgICAgICAgbGV0IGN1JyA9IE0ubXVsIChNLkFuaWNrLmV2YWwgYycpIHUnIGluXG4gICAgICAgICAgICBpZiBwcmVzLmxlcSAhY3UgY3UnIHRoZW5cbiAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgIGFzc2VydCAobm90IChLLmVxIGEnIEsuemVybykpO1xuICAgICAgICAgICAgICAgIGEgOj0gYSc7XG4gICAgICAgICAgICAgICAgYyA6PSBjJztcbiAgICAgICAgICAgICAgICB1IDo9IHUnO1xuICAgICAgICAgICAgICAgIGN1IDo9IGN1J1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgKSBwO1xuICAgICAgICAgIGxldCBhID0gIWEgaW5cbiAgICAgICAgICBsZXQgYyA9ICFjIGluXG4gICAgICAgICAgbGV0IHUgPSAhdSBpblxuICAgICAgICAgICgqIEZpbmQgd2hlcmUgY24gdSBpcyBsZWZ0bW9zdCByZWR1Y2libGUuICopXG4gICAgICAgICAgbGV0IGNuID0gTS5Bbmljay5oZCBjIGluXG4gICAgICAgICAgbGV0IGNubCA9IE0ubGVuZ3RoIGNuIGluXG4gICAgICAgICAgbGV0IGNudSA9IE0ubXVsIGNuIHUgaW5cbiAgICAgICAgICBsZXQgY251bCA9IE0ubGVuZ3RoIGNudSBpblxuICAgICAgICAgIGxldCBpID1cbiAgICAgICAgICAgIGxldCBhbnMgPSByZWYgKC0xKSBpblxuICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgIGZvciBpID0gMCB0byBjbnVsIC0gMSBkb1xuICAgICAgICAgICAgICAgIExpc3QuaXRlciAoZnVuICh2LF8pIC0+XG4gICAgICAgICAgICAgICAgICBsZXQgdmwgPSBNLmxlbmd0aCB2IGluXG4gICAgICAgICAgICAgICAgICBpZiBpICsgdmwgPD0gY251bCAmJiBNLnBlcSBjbnUgaSB2IDAgdmwgdGhlblxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgYW5zIDo9IGkgKyB2bCAtIGNubDtcbiAgICAgICAgICAgICAgICAgICAgICByYWlzZSBFeGl0XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApIHByZXMucnVsZXNcbiAgICAgICAgICAgICAgZG9uZTtcbiAgICAgICAgICAgICAgUHJpbnRmLnByaW50ZiBcImZhaWxlZCAobm9uLXJlZHVjaWJsZSk6ICVzXFxuJSFcIiAoQU1vZC50b19zdHJpbmcgcCk7XG4gICAgICAgICAgICAgIGxldCBsZWFkaW5nID0gQUtNb2QuY2luaiBhIGMgdSBpblxuICAgICAgICAgICAgICBQcmludGYucHJpbnRmIFwibGVhZGluZzogJXNcXG4lIVwiIChBTW9kLnRvX3N0cmluZyBsZWFkaW5nKTtcbiAgICAgICAgICAgICAgYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICB3aXRoXG4gICAgICAgICAgICB8IEV4aXQgLT4gIWFuc1xuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IHUnID0gTS5zdWIgdSAwIGkgaW5cbiAgICAgICAgICBsZXQgdScnID0gTS5zdWIgdSBpIChNLmxlbmd0aCB1IC0gaSkgaW5cbiAgICAgICAgICBsZXQgYycgPSB1JyA6OiBjIGluXG4gICAgICAgICAgbGV0IGFucyA9IEFLTW9kLmNpbmogYSBjJyB1JycgaW5cbiAgICAgICAgICBsZXQgYW5zID0gQU1vZC5ub3JtYWxpemUgcHJlcyBhbnMgaW5cbiAgICAgICAgICAoKiBDb21wdXRlIHRoZSByZW1haW5kZXIuICopXG4gICAgICAgICAgbGV0IGFucycgPSBBTW9kLk1hcC5iaW5kIHByZXMgZC4obikgYW5zIGluXG4gICAgICAgICAgbGV0IHAnID0gQU1vZC5zdWIgcCBhbnMnIGluXG4gICAgICAgICAgbGV0IHAnID0gQU1vZC5ub3JtYWxpemUgcHJlcyBwJyBpblxuICAgICAgICAgIGxldCBhbnMnID0gY2ggbiBwJyBpblxuICAgICAgICAgIGxldCBhbnMgPSBBTW9kLm5vcm1hbGl6ZSBwcmVzIChBTW9kLmFkZCBhbnMgYW5zJykgaW5cbiAgICAgICAgICBpZiBkZWJ1ZyB0aGVuIFByaW50Zi5wcmludGYgXCLOtyVkKCVzKSA9ICVzXFxuJSFcIiBuIChBTW9kLnRvX3N0cmluZyBwKSAoQU1vZC50b19zdHJpbmcgYW5zKTtcbiAgICAgICAgICBhbnNcbiAgICAgIGluXG4gICAgICAoKiBGaWxsIGluIGhpZ2hlciBkaWZmZXJlbnRpYWxzLiAqKVxuICAgICAgZm9yIGkgPSAxIHRvIG4gLSAxIGRvXG4gICAgICAgIExpc3QuaXRlciAoZnVuIGMgLT5cbiAgICAgICAgICBpZiBkZWJ1ZyB0aGVuIFByaW50Zi5wcmludGYgXCJcXG5kaWZmJWQoJXMpID0gP1xcbiUhXCIgaSAoTS5Bbmljay50b19zdHJpbmcgYyk7XG4gICAgICAgICAgbGV0IHUgPSBNLkFuaWNrLmhkIGMgaW5cbiAgICAgICAgICBsZXQgYycgPSBNLkFuaWNrLnRsIGMgaW5cbiAgICAgICAgICBsZXQgcCA9IEFNb2QuY211bCAoQU1vZC5pbmogYycpIChBLmluaiB1KSBpblxuICAgICAgICAgICgqIFByaW50Zi5wcmludGYgXCJwOiAlc1xcbiUhXCIgKEFNb2QudG9fc3RyaW5nIHApOyAqKVxuICAgICAgICAgIGxldCBwJyA9IEFNb2QuTWFwLmJpbmQgcHJlcyBkLihpLTEpIHAgaW5cbiAgICAgICAgICAoKiBQcmludGYucHJpbnRmIFwicCc6ICVzXFxuJSFcIiAoQU1vZC50b19zdHJpbmcgcCcpOyAqKVxuICAgICAgICAgIGxldCBwJyA9IGNoIChpLTEpIHAnIGluXG4gICAgICAgICAgbGV0IHAgPSBBTW9kLnN1YiBwIHAnIGluXG4gICAgICAgICAgbGV0IHAgPSBBTW9kLm5vcm1hbGl6ZSBwcmVzIHAgaW5cbiAgICAgICAgICBpZiBkZWJ1ZyB0aGVuIFByaW50Zi5wcmludGYgXCJkJWQoJXMpID0gJXNcXG5cIiBpIChNLkFuaWNrLnRvX3N0cmluZyBjKSAoQU1vZC50b19zdHJpbmcgcCk7XG4gICAgICAgICAgZC4oaSkgPC0gQU1vZC5NYXAuc2V0IGQuKGkpIGMgcFxuICAgICAgICApIGNjLihpKzEpXG4gICAgICBkb25lO1xuICAgICAgbGV0IGNjID0gQXJyYXkubWFwIChmdW4gbCAtPiBsIHw+IEFycmF5Lm9mX2xpc3QgfD4gQU1vZC5QcmVzLm1ha2UpIGNjIGluXG4gICAgICBsZXQgZCA9IEFycmF5Lm1hcGkgKGZ1biBpIGQgLT4gQU1vZC5QcmVzLk1hcC5vZl9tYXAgZCBjYy4oaSsxKSBjYy4oaSkpIGQgaW5cbiAgICAgIGxldCBzID0gQXJyYXkuaW5pdCAobi0yKSAoZnVuIGkgLT4gY2ggaSkgaW5cbiAgICAgIEFNb2QuUHJlcy5Db21wbGV4Lm1ha2UgY2MgZCwgc1xuXG4gICAgKCoqIENvbXB1dGUgdGhlIEFuaWNrIHJlc29sdXRpb24uICopXG4gICAgbGV0IHJlc29sdXRpb24gP2F1Z21lbnRhdGlvbiBwcmVzIG4gPVxuICAgICAgcmVzb2x1dGlvbl9jaCA/YXVnbWVudGF0aW9uIHByZXMgbiB8PiBmc3RcblxuICAgIG1vZHVsZSBLTW9kID0gTW9kdWxlLkZyZWUoSykoTS5BbmljaylcbiAgICBtb2R1bGUgTUYgPSBNYXRyaXguRnVuY3RvcihBKShLKVxuICAgIG1vZHVsZSBNRkwgPSBNRi5MYWJlbGVkKE0uQW5pY2spKE0uQW5pY2spXG5cbiAgICAoKiogVG9yIGNvbXBsZXgsIHdob3NlIGhvbW9sb2d5IGlzIHRoZSBvbmUgb2YgdGhlIGFsZ2VicmEgKGluIHJpZ2h0IEEtbW9kdWxlcykuICopXG4gICAgbGV0IGNvbXBsZXggP2F1Z21lbnRhdGlvbiBwcmVzIG4gPVxuICAgICAgbGV0IGF1Z21lbnRhdGlvbiA9IG1hdGNoIGF1Z21lbnRhdGlvbiB3aXRoIFNvbWUgYXVnbWVudGF0aW9uIC0+IGF1Z21lbnRhdGlvbiB8IE5vbmUgLT4gQXVnbWVudGF0aW9uLmdyYWRlZCBwcmVzIGluXG4gICAgICBsZXQgciA9IHJlc29sdXRpb24gfmF1Z21lbnRhdGlvbiBwcmVzIG4gaW5cbiAgICAgIGxldCBjYyA9IEFNb2QuUHJlcy5Db21wbGV4Lm1vZHVsZXMgciBpblxuICAgICAgbGV0IGQgPSBBTW9kLlByZXMuQ29tcGxleC5tYXBzIHIgaW5cbiAgICAgICgqIFRlbnNvciBtb3JwaGlzbXMgYnkgdGhlIGFsZ2VicmEuICopXG4gICAgICBsZXQgZCA9XG4gICAgICAgIGxldCBpZCB4ID0geCBpblxuICAgICAgICBBcnJheS5tYXAgKGZ1biBkIC0+XG4gICAgICAgICAgTUZMLm1hcCBpZCBpZCAoZnVuIHAgLT5cbiAgICAgICAgICAgICgqIGxldCB4ID0gcmVmIEsuemVybyBpbiAqKVxuICAgICAgICAgICAgKCogbGV0IHAgPSBub3JtYWxpemUgcHJlcyBwIGluICopXG4gICAgICAgICAgICAoKiBBLml0ZXIgKGZ1biB5IHUgLT4geCA6PSBLLmFkZCAheCB5KSBwOyAqKVxuICAgICAgICAgICAgKCogIXggKilcbiAgICAgICAgICAgIGxldCBwID0gbm9ybWFsaXplIHByZXMgcCBpblxuICAgICAgICAgICAgYXVnbWVudGF0aW9uIHBcbiAgICAgICAgICApIGRcbiAgICAgICAgKSBkXG4gICAgICBpblxuICAgICAgS01vZC5QcmVzLkNvbXBsZXgubWFrZSBjYyBkXG5cbiAgICBsZXQgYmV0dGkgP2F1Z21lbnRhdGlvbiBwcmVzIG4gPVxuICAgICAgbGV0IGMgPSBjb21wbGV4ID9hdWdtZW50YXRpb24gcHJlcyAobisxKSBpblxuICAgICAgS01vZC5QcmVzLkNvbXBsZXguYmV0dGkgY1xuICBlbmRcbmVuZFxuXG5tb2R1bGUgR2VuZXJhdGUgKEsgOiBGaWVsZC5UKSAoWCA6IEFscGhhYmV0LlQgd2l0aCB0eXBlIHQgPSBpbnQpID0gc3RydWN0XG4gIG1vZHVsZSBQcmVzID0gUHJlcyhLKShYKVxuICBvcGVuIFByZXNcbiAgbW9kdWxlIE0gPSBQcmVzLk1cbiAgbW9kdWxlIEEgPSBQcmVzLkFcblxuICBsZXQgaW50c2V0IG4gPVxuICAgIGxldCByZWMgYXV4IGsgPVxuICAgICAgaWYgayA+PSBuIHRoZW4gW10gZWxzZVxuICAgICAgICBrOjooYXV4IChrKzEpKVxuICAgIGluXG4gICAgYXV4IDBcblxuICBsZXQgYnJhaWQgbGVxIG4gPVxuICAgIGxldCBnZW5lcmF0b3JzID0gaW50c2V0IG4gaW5cbiAgICBsZXQgcmVsYXRpb25zID0gcmVmIFtdIGluXG4gICAgZm9yIGkgPSAwIHRvIG4gLSAyIGRvXG4gICAgIHJlbGF0aW9ucyA6PSAoQS5zdWIgKEEuaW5qIFt8aTtpKzE7aXxdKSAoQS5pbmogW3xpKzE7aTtpKzF8XSkpIDo6ICFyZWxhdGlvbnNcbiAgICBkb25lO1xuICAgIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgICAgZm9yIGogPSBpICsgMiB0byBuIC0gMSBkb1xuICAgICAgICByZWxhdGlvbnMgOj0gKEEuc3ViIChBLmluaiBbfGk7anxdKSAoQS5pbmogW3xqO2l8XSkpIDo6ICFyZWxhdGlvbnNcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIGxldCByZWxhdGlvbnMgPSBMaXN0LnJldiAhcmVsYXRpb25zIGluXG4gICAgbWFrZSBsZXEgZ2VuZXJhdG9ycyByZWxhdGlvbnNcblxuICAoKiogVGhlIHN5bW1ldHJpYyBhbGdlYnJhLiAqKVxuICBsZXQgc3ltbWV0cmljIGxlcSBuID1cbiAgICBsZXQgZ2VuZXJhdG9ycyA9IGludHNldCBuIGluXG4gICAgbGV0IHJlbGF0aW9ucyA9IHJlZiBbXSBpblxuICAgIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgICAgZm9yIGogPSBpICsgMSB0byBuIC0gMSBkb1xuICAgICAgICByZWxhdGlvbnMgOj0gKEEuc3ViIChBLmluaiBbfGk7anxdKSAoQS5pbmogW3xqO2l8XSkpIDo6ICFyZWxhdGlvbnNcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIGxldCByZWxhdGlvbnMgPSBMaXN0LnJldiAhcmVsYXRpb25zIGluXG4gICAgbWFrZSBsZXEgZ2VuZXJhdG9ycyByZWxhdGlvbnNcblxuICBsZXQgZXh0ZXJpb3IgbGVxIG4gPVxuICAgIGxldCBnZW5lcmF0b3JzID0gaW50c2V0IG4gaW5cbiAgICBsZXQgcmVsYXRpb25zID0gcmVmIFtdIGluXG4gICAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgICBmb3IgaiA9IGkgKyAxIHRvIG4gLSAxIGRvXG4gICAgICAgIHJlbGF0aW9ucyA6PSAoQS5zdWIgKEEuaW5qIFt8aTtqfF0pIChBLmNpbmogKEsubmVnIEsub25lKSBbfGo7aXxdKSkgOjogIXJlbGF0aW9uc1xuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgICByZWxhdGlvbnMgOj0gKEEuaW5qIFt8aTtpfF0pIDo6ICFyZWxhdGlvbnNcbiAgICBkb25lO1xuICAgIGxldCByZWxhdGlvbnMgPSBMaXN0LnJldiAhcmVsYXRpb25zIGluXG4gICAgbWFrZSBsZXEgZ2VuZXJhdG9ycyByZWxhdGlvbnNcbmVuZFxuIiwiKCoqIFRlcm0gcmV3cml0aW5nIHN5c3RlbXMuICopXG5cbm9wZW4gRXh0bGliXG5cbigqKiBPcGVyYXRpb25zLiAqKVxubW9kdWxlIE9wID0gc3RydWN0XG4gICgqKiBBbiBvcGVyYXRpb24uICopXG4gIHR5cGUgdCA9XG4gICAge1xuICAgICAgd2VpZ2h0IDogaW50O1xuICAgICAgbmFtZSA6IHN0cmluZztcbiAgICAgIGFyaXR5IDogaW50O1xuICAgICAgdG9fc3RyaW5nIDogc3RyaW5nIGxpc3QgLT4gc3RyaW5nO1xuICAgIH1cblxuICBsZXQgbmFtZSBmID0gZi5uYW1lXG5cbiAgbGV0IHdlaWdodCBmID0gZi53ZWlnaHRcblxuICBsZXQgYXJpdHkgZiA9IGYuYXJpdHlcblxuICAoKiogQ3JlYXRlIGFuIG9wZXJhdGlvbiB3aXRoIGdpdmVuIG5hbWUgYW5kIGFyaXR5LiAqKVxuICBsZXQgbWFrZSA/dG9fc3RyaW5nID8od2VpZ2h0PTApIG5hbWUgYXJpdHkgOiB0ID1cbiAgICBsZXQgdG9fc3RyaW5nID1cbiAgICAgIG1hdGNoIHRvX3N0cmluZyB3aXRoXG4gICAgICB8IFNvbWUgdG9fc3RyaW5nIC0+IHRvX3N0cmluZ1xuICAgICAgfCBOb25lIC0+IGZ1biBhIC0+IG5hbWUgXiBcIihcIiBeIFN0cmluZy5jb25jYXQgXCIsXCIgYSBeIFwiKVwiXG4gICAgaW5cbiAgICB7IHdlaWdodDsgbmFtZTsgYXJpdHk7IHRvX3N0cmluZyB9XG5cbiAgKCoqIENvbXBhcmUgdHdvIG9wZXJhdGlvbnMgZm9yIGVxdWFsaXR5LiAqKVxuICBsZXQgZXEgZjEgZjIgPVxuICAgIGYxLm5hbWUgPSBmMi5uYW1lICYmIGYxLmFyaXR5ID0gZjIuYXJpdHkgJiYgZjEud2VpZ2h0ID0gZjIud2VpZ2h0XG5cbiAgbGV0IHRvX3N0cmluZyBmIGEgPSBmLnRvX3N0cmluZyBhXG5lbmRcblxuKCoqIFZhcmlhYmxlcy4gKilcbm1vZHVsZSBWYXIgPSBzdHJ1Y3RcbiAgKCoqIEEgdmFyaWFibGUuICopXG4gICgqIE5vdGU6IHRoZSBpbnRlZ2VyIGlzIG9ubHkgaGVyZSB0byBpbXBsZW1lbnQgY29tcGFyZSwgYW5kIHNob3VsZCBub3QgYmUgdXNlZFxuICAgICBvdGhlcndpc2UuICopXG4gIHR5cGUgdCA9IGludCByZWZcblxuICAoKiogQ3JlYXRlIGEgZnJlc2ggdmFyaWFibGUuICopXG4gIGxldCBmcmVzaCA6IHVuaXQgLT4gdCA9XG4gICAgbGV0IG4gPSByZWYgKC0xKSBpblxuICAgIGZ1biAoKSAtPlxuICAgICAgaW5jciBuOyByZWYgIW5cblxuICAoKiogRXF1YWxpdHkgYmV0d2VlbiB2YXJpYWJsZXMuICopXG4gIGxldCBlcSAoeDp0KSAoeTp0KSA9IHggPT0geVxuXG4gIGxldCBjb21wYXJlICh4OnQpICh5OnQpID0gY29tcGFyZSB4IHlcblxuICAoKiogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBhc3NpZ24gbmFtZXMgdG8gdmFyaWFibGVzLiAqKVxuICBsZXQgbmFtZXIgKCkgPVxuICAgIGxldCBmID0gVXRpbHMubmFtZXIgZXEgaW5cbiAgICBmdW4geCAtPiBcInhcIiBeIFN0cmluZy5zdWJzY3JpcHQgKHN0cmluZ19vZl9pbnQgKGYgeCkpXG5cbiAgbGV0IG5hbWVyX25hdHVyYWwgKCkgPVxuICAgIGxldCBmID0gVXRpbHMubmFtZXIgZXEgaW5cbiAgICBsZXQgbmFtZSA9IFt8XCJ4XCI7IFwieVwiOyBcInpcIjsgXCJ0XCI7IFwidVwiOyBcInZcIjsgXCJ3XCJ8XSBpblxuICAgIGZ1biB4IC0+IG5hbWUuKGYgeClcblxuICAoKiogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmFyaWFibGUuICopXG4gIGxldCB0b19zdHJpbmcgPSBuYW1lciAoKVxuZW5kXG5cbigqKiBBIHZhcmlhYmxlLiAqKVxudHlwZSB2YXIgPSBWYXIudFxuXG4oKiogQSB0ZXJtLiAqKVxudHlwZSB0ID1cbiAgICB8IEFwcCBvZiBPcC50ICogdCBsaXN0ICgqKiBhcHBsaWNhdGlvbiAqKVxuICAgIHwgVmFyIG9mIHZhciAoKiogdmFyaWFibGUgKilcblxudHlwZSB0ZXJtID0gdFxuXG4oKiogQ3JlYXRlIGEgZnJlc2ggdmFyaWFibGUgdGVybS4gKilcbmxldCB2YXIgKCkgPSBWYXIgKFZhci5mcmVzaCAoKSlcblxuKCoqIENyZWF0ZSBhbiBhcHBsaWNhdGlvbi4gKilcbmxldCBhcHAgZiBhID1cbiAgYXNzZXJ0IChMaXN0Lmxlbmd0aCBhID0gT3AuYXJpdHkgZik7XG4gIEFwcCAoZixhKVxuXG4oKiogU2ltcGxlIHBhcnNlciBmb3IgdGVybXMgYW5kIGFwcGxpY2F0aW9ucy4gKilcbmxldCBwYXJzZXIgcyA9XG4gIGxldCByZWMgdGVybSBzID1cbiAgICBsZXQgcyA9IFN0cmluZy50cmltIHMgaW5cbiAgICB0cnlcbiAgICAgIGxldCBuID0gU3RyaW5nLmluZGV4IHMgJygnIGluXG4gICAgICBsZXQgZiA9IFN0cmluZy5zdWIgcyAwIG4gaW5cbiAgICAgIGFzc2VydCAocy5bU3RyaW5nLmxlbmd0aCBzIC0gMV0gPSAnKScpO1xuICAgICAgbGV0IGEgPSBTdHJpbmcuc3ViIHMgKG4rMSkgKFN0cmluZy5sZW5ndGggcyAtIChuKzEpIC0gMSkgaW5cbiAgICAgIGxldCBhID1cbiAgICAgICAgaWYgYSA9IFwiXCIgdGhlbiBbXSBlbHNlXG4gICAgICAgICAgbGV0IGsgPSByZWYgMCBpblxuICAgICAgICAgIGxldCBwID0gZnVuY3Rpb25cbiAgICAgICAgICAgIHwgJygnIC0+IGluY3IgazsgZmFsc2VcbiAgICAgICAgICAgIHwgJyknIC0+IGRlY3IgazsgZmFsc2VcbiAgICAgICAgICAgIHwgJywnIC0+ICFrID0gMFxuICAgICAgICAgICAgfCBfIC0+IGZhbHNlXG4gICAgICAgICAgaW5cbiAgICAgICAgICBTdHJpbmcuc3BsaXRfb25fcHJlZGljYXRlIHAgYVxuICAgICAgaW5cbiAgICAgIGxldCBhID0gTGlzdC5tYXAgdGVybSBhIGluXG4gICAgICBgQXBwIChmLCBhKVxuICAgIHdpdGhcbiAgICB8IE5vdF9mb3VuZCAtPiBgVmFyIHNcbiAgaW5cbiAgbGV0IHN0ZXAgcyA9XG4gICAgbGV0IHMgPSBTdHJpbmcudHJpbSBzIGluXG4gICAgaWYgcy5bU3RyaW5nLmxlbmd0aCBzIC0gMV0gPSAnLScgdGhlbiBgSW52ICh0ZXJtIChTdHJpbmcuc3ViIHMgMCAoU3RyaW5nLmxlbmd0aCBzIC0gMSkpKVxuICAgIGVsc2UgdGVybSBzXG4gIGluXG4gIGxldCBsID0gU3RyaW5nLnNwbGl0X29uX2NoYXIgJy4nIHMgaW5cbiAgaWYgTGlzdC5sZW5ndGggbCA9IDEgdGhlbiBzdGVwIChMaXN0LmhkIGwpXG4gIGVsc2UgYFNlcSAoTGlzdC5tYXAgc3RlcCBsKVxuXG5sZXQgcGFyc2VfdmFyID1cbiAgbGV0IHZhcnMgPSByZWYgW10gaW5cbiAgZnVuIHggLT5cbiAgICBpZiBub3QgKExpc3QubWVtX2Fzc29jIHggIXZhcnMpIHRoZW4gdmFycyA6PSAoeCwgVmFyLmZyZXNoICgpKSA6OiAhdmFycztcbiAgICBMaXN0LmFzc29jIHggIXZhcnNcblxuKCoqIFBhcnNlIGEgdGVybS4gKilcbmxldCBwYXJzZSBvcHMgcyA9XG4gIGxldCByZWMgYXV4ID0gZnVuY3Rpb25cbiAgICB8IGBBcHAgKGYsIGEpIC0+XG4gICAgICBsZXQgZiA9IExpc3QuZmluZCAoZnVuIG8gLT4gT3AubmFtZSBvID0gZikgb3BzIGluXG4gICAgICBsZXQgYSA9IExpc3QubWFwIGF1eCBhIGluXG4gICAgICBhcHAgZiBhXG4gICAgfCBgVmFyIHggLT5cbiAgICAgIFZhciAocGFyc2VfdmFyIHgpXG4gICAgfCBgU2VxIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBgSW52IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIGluXG4gIGF1eCAocGFyc2VyIHMpXG5cbigqKiBFcXVhbGl0eSBiZXR3ZWVuIHRlcm1zLiAqKVxubGV0IHJlYyBlcSB0MSB0MiA9XG4gIG1hdGNoIHQxLCB0MiB3aXRoXG4gIHwgVmFyIHgsIFZhciB5IC0+IFZhci5lcSB4IHlcbiAgfCBBcHAgKGYxLCBhMSksIEFwcCAoZjIsIGEyKSAtPlxuICAgIE9wLmVxIGYxIGYyICYmXG4gICAgTGlzdC5sZW5ndGggYTEgPSBMaXN0Lmxlbmd0aCBhMiAmJlxuICAgIExpc3QuZm9yX2FsbDIgZXEgYTEgYTJcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCBlcV90ZXJtID0gZXFcblxuKCoqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHRlcm0uICopXG5sZXQgcmVjIHRvX3N0cmluZyA/KHZhcj1WYXIudG9fc3RyaW5nKSA9IGZ1bmN0aW9uXG4gIHwgQXBwIChmLCBhKSAtPiBPcC50b19zdHJpbmcgZiAoTGlzdC5tYXAgKHRvX3N0cmluZyB+dmFyKSBhKVxuICB8IFZhciB4IC0+IHZhciB4XG5cbmxldCBzdHJpbmdfb2ZfdGVybSA/dmFyID0gdG9fc3RyaW5nID92YXJcblxuKCoqIElzIGEgdGVybSBhIHZhcmlhYmxlPyAqKVxubGV0IGlzX3ZhciA9IGZ1bmN0aW9uXG4gIHwgVmFyIF8gLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IGdldF92YXIgPSBmdW5jdGlvblxuICB8IFZhciB4IC0+IHhcbiAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuXG4oKiogVmFyaWFibGVzIGluIGEgdGVybS4gKilcbmxldCB2YXJzIHQgPVxuICBsZXQgcmVjIGF1eCB2YXJzID0gZnVuY3Rpb25cbiAgICB8IEFwcCAoXywgYSkgLT5cbiAgICAgIExpc3QuZm9sZF9sZWZ0IChmdW4gdmFycyB0IC0+IGF1eCB2YXJzIHQpIHZhcnMgYVxuICAgIHwgVmFyIHggLT5cbiAgICAgIGlmIExpc3QuZXhpc3RzIChWYXIuZXEgeCkgdmFycyB0aGVuIHZhcnNcbiAgICAgIGVsc2UgeDo6dmFyc1xuICBpblxuICBMaXN0LnJldiAoYXV4IFtdIHQpXG5cbigqKiBXaGV0aGVyIGEgdmFyaWFibGUgb2NjdXJzIGluIGEgdGVybS4gKilcbmxldCByZWMgb2NjdXJzIHggPSBmdW5jdGlvblxuICB8IEFwcCAoXywgYSkgLT4gTGlzdC5leGlzdHMgKG9jY3VycyB4KSBhXG4gIHwgVmFyIHkgLT4gVmFyLmVxIHggeVxuXG4oKiogTGV4aWNvZ3JhcGhpYyBwYXRoIG9yZGVyIG9uIHRlcm1zLiAqKVxubW9kdWxlIExQTyA9IHN0cnVjdFxuICBsZXQgcmVjIGd0IGdlX29wIHQgdSA9XG4gICAgKCogUHJpbnRmLnByaW50ZiBcIiVzID4gJXMgP1xcbiUhXCIgKHRvX3N0cmluZyB0KSAodG9fc3RyaW5nIHUpOyAqKVxuICAgIG1hdGNoIHQsIHUgd2l0aFxuICAgIHwgdCwgVmFyIHggLT4gbm90IChlcSB0IHUpICYmIG9jY3VycyB4IHRcbiAgICB8IEFwcCAoZixhKSwgQXBwIChnLCBiKSAtPlxuICAgICAgaWYgTGlzdC5leGlzdHMgKGZ1biB0IC0+IGdlIGdlX29wIHQgdSkgYSB0aGVuIHRydWUgZWxzZVxuICAgICAgaWYgT3AuZXEgZiBnIHRoZW5cbiAgICAgICAgKCogbGV4aWNvZ3JhcGhpYyA+ICopXG4gICAgICAgIGxldCByZWMgbGV4IGwxIGwyID1cbiAgICAgICAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgICAgICAgIHwgeDE6OmwxLCB4Mjo6bDIgd2hlbiBlcSB4MSB4MiAtPiBsZXggbDEgbDJcbiAgICAgICAgICB8IHgxOjpsMSwgeDI6OmwyIHdoZW4gZ3QgZ2Vfb3AgeDEgeDIgLT4gdHJ1ZVxuICAgICAgICAgIHwgXywgXyAtPiBmYWxzZVxuICAgICAgICBpblxuICAgICAgICBMaXN0LmZvcl9hbGwgKGZ1biB1IC0+IGd0IGdlX29wIHQgdSkgYiAmJlxuICAgICAgICBsZXggYSBiXG4gICAgICBlbHNlIGlmIGdlX29wIGYgZyB0aGVuIExpc3QuZm9yX2FsbCAoZnVuIHUgLT4gZ3QgZ2Vfb3AgdCB1KSBiXG4gICAgICBlbHNlIGZhbHNlXG4gICAgfCBfIC0+IGZhbHNlXG4gIGFuZCBnZSBnZV9vcCB0IHUgPVxuICAgIGVxIHQgdSB8fCBndCBnZV9vcCB0IHVcbmVuZFxuXG4oKiogU3Vic3RpdHV0aW9ucy4gKilcbm1vZHVsZSBTdWJzdGl0dXRpb24gPSBzdHJ1Y3RcbiAgKCoqIEEgc3Vic3RpdHV0aW9uLiAqKVxuICB0eXBlIHQgPSAodmFyICogdGVybSkgbGlzdFxuXG4gIGxldCB0b19zdHJpbmcgP3ZhciBzID1cbiAgICBcIltcIiBeIFN0cmluZy5jb25jYXQgXCIsXCIgKExpc3QubWFwIChmdW4gKHgsdCkgLT4gdG9fc3RyaW5nID92YXIgdCBeIFwiL1wiIF4gdG9fc3RyaW5nID92YXIgKFZhciB4KSkgcykgXiBcIl1cIlxuXG4gICgqKiBFbXRweSBzdWJzdGl0dXRpb24uICopXG4gIGxldCBlbXB0eSA6IHQgPSBbXVxuXG4gICgqKiBJZGVudGl0eSBzdWJzdGl0aW9uLiAqKVxuICBsZXQgaWQgdmFycyA6IHQgPVxuICAgIExpc3QubWFwIChmdW4geCAtPiB4LCBWYXIgeCkgdmFyc1xuXG4gICgqKiBSZW5hbWluZyBvZiB2YXJpYWJsZXMuICopXG4gIGxldCByZW5hbWUgdmFycyA6IHQgPVxuICAgIExpc3QubWFwIChmdW4geCAtPiB4LCBWYXIgKFZhci5mcmVzaCAoKSkpIHZhcnNcblxuICBsZXQgc2ltcGxlIHggdCA6IHQgPSBbeCx0XVxuXG4gIGxldCBhZGQgcyB4IHQgOiB0ID0gKHgsdCk6OnNcblxuICAoKiogRmluZCB0aGUgdmFsdWUgYXNzb2NpYXRlZCB0byBhIHZhcmlhYmxlLiAqKVxuICBsZXQgcmVjIGZpbmQgKHM6dCkgeCA9XG4gICAgbWF0Y2ggcyB3aXRoXG4gICAgfCAoeSx0KTo6cyAtPiBpZiBWYXIuZXEgeCB5IHRoZW4gdCBlbHNlIGZpbmQgcyB4XG4gICAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcblxuICAoKiogQXBwbHkgYSBzdWJzdGl0dXRpb24gdG8gYSB0ZXJtLiAqKVxuICBsZXQgcmVjIGFwcCAoczp0KSA9IGZ1bmN0aW9uXG4gICAgfCBBcHAgKGcsIGEpIC0+IEFwcCAoZywgTGlzdC5tYXAgKGFwcCBzKSBhKVxuICAgIHwgVmFyIHggLT5cbiAgICAgIHRyeSBmaW5kIHMgeFxuICAgICAgd2l0aCBOb3RfZm91bmQgLT4gVmFyIHhcblxuICAoKiogQ29tcG9zZSBzdWJzdGl0dXRpb25zLiAqKVxuICBsZXQgY29tcG9zZSAoczp0KSAocyc6dCkgOiB0ID1cbiAgICBMaXN0Lm1hcCAoZnVuICh4LHQpIC0+IHgsIGFwcCBzJyB0KSBzXG5cbiAgKCoqIEVxdWFsaXR5IG9mIHN1YnN0aXR1dGlvbnMuICopXG4gIGxldCBlcSBzMSBzMiA9XG4gICAgbGV0IGluY2x1ZGVkIChzMTp0KSAoczI6dCkgPVxuICAgICAgTGlzdC5mb3JfYWxsIChmdW4gKHgsdCkgLT4gZXEgdCAoYXBwIHMyIChWYXIgeCkpKSBzMVxuICAgIGluXG4gICAgaW5jbHVkZWQgczEgczIgJiYgaW5jbHVkZWQgczIgczFcblxuICAoKiogSXMgYSBzdWJzdGl0dXRpb24gYSByZW5hbWluZyBvZiB2YXJpYWJsZXM/ICopXG4gIGxldCBpc19yZW5hbWluZyAoczp0KSA9XG4gICAgTGlzdC5mb3JfYWxsIChmdW4gKHgsdCkgLT4gaXNfdmFyIHQpIHNcblxuICBsZXQgaXNfaW5qZWN0aXZlX3JlbmFtaW5nIChzOnQpID1cbiAgICBsZXQgcmVjIGF1eCB2YXJzID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gdHJ1ZVxuICAgICAgfCAoXyx0KTo6cyAtPlxuICAgICAgICBpZiBpc192YXIgdCB0aGVuXG4gICAgICAgICAgbGV0IHggPSBnZXRfdmFyIHQgaW5cbiAgICAgICAgICBpZiBMaXN0LmV4aXN0cyAoVmFyLmVxIHgpIHZhcnMgdGhlbiBmYWxzZVxuICAgICAgICAgIGVsc2UgYXV4ICh4Ojp2YXJzKSBzXG4gICAgICAgIGVsc2UgZmFsc2VcbiAgICBpblxuICAgIGF1eCBbXSBzXG5cbiAgKCoqIEludmVyc2Ugb2YgYSByZW5hbWluZy4gKilcbiAgbGV0IGludiAoczp0KSA6IHQgPVxuICAgIExpc3QubWFwXG4gICAgICAoZnVuICh4LHQpIC0+XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IFZhciB5IC0+IHksIFZhciB4XG4gICAgICAgIHwgXyAtPiBmYWlsd2l0aCBcIk5vdCBpbnZlcnNpYmxlLlwiXG4gICAgICApIHNcblxuICAoKiogRG9tYWluIG9mIGEgc3Vic3RpdHV0aW9uLiAqKVxuICBsZXQgZG9tYWluIChzOnQpID1cbiAgICBMaXN0Lm1hcCBmc3Qgc1xuXG4gIGxldCBpbl9kb20gKHM6dCkgeCA9XG4gICAgTGlzdC5leGlzdHMgKGZ1biAoeSxfKSAtPiBWYXIuZXEgeSB4KSBzXG5cbiAgKCoqIFJlc3RyaWN0IHRoZSBkb21haW4gb2YgYSBzdWJzdGl0dXRpb24uICopXG4gIGxldCByZXN0cmljdCB2YXJzIChzOnQpIDogdCA9XG4gICAgTGlzdC5maWx0ZXIgKGZ1biAoeCxfKSAtPiBMaXN0LmV4aXN0cyAoVmFyLmVxIHgpIHZhcnMpIHNcbmVuZFxuXG5tb2R1bGUgU3Vic3QgPSBTdWJzdGl0dXRpb25cblxudHlwZSBzdWJzdCA9IFN1YnN0LnRcblxuKCoqIEludGVycHJldGF0aW9uIG9mIHRlcm1zIGludG8gY2FydGVzaWFuIGNhdGVnb3JpZXMuICopXG5tb2R1bGUgSW50ZXJwcmV0YXRpb24gPSBzdHJ1Y3RcbiAgKCoqIFBvbHlub21pYWwgaW50ZXJwcmV0YXRpb25zLiAqKVxuICBtb2R1bGUgUG9seW5vbWlhbCA9IHN0cnVjdFxuICAgICgqIFdvcmRzLiAqKVxuICAgIG1vZHVsZSBXID0gTW9ub2lkLk11bHRpc2V0cyhWYXIpXG4gICAgKCogUG9seW5vbWlhbHMuICopXG4gICAgbW9kdWxlIFAgPSBzdHJ1Y3RcbiAgICAgIG1vZHVsZSBSID0gUmluZy5JbnRcbiAgICAgIGluY2x1ZGUgQWxnZWJyYS5PdmVyUmluZy5GcmVlKFIpKFcpXG5cbiAgICAgIGxldCBpc19jb21tdXRhdGl2ZSA9IFcuaXNfY29tbXV0YXRpdmVcblxuICAgICAgbGV0IHRvX3N0cmluZyBwID1cbiAgICAgICAgaWYgZXEgcCB6ZXJvIHRoZW4gXCIwXCIgZWxzZVxuICAgICAgICAgIGxldCBhbnMgPSByZWYgXCJcIiBpblxuICAgICAgICAgIGxldCB3IHMgPSBhbnMgOj0gIWFucyBeIHMgaW5cbiAgICAgICAgICBpdGVyIChmdW4gYSB1IC0+XG4gICAgICAgICAgICAgIGxldCBhID1cbiAgICAgICAgICAgICAgICBpZiBhIDwgMCB0aGVuICh3IFwiLVwiOyAtYSlcbiAgICAgICAgICAgICAgICBlbHNlIGlmICFhbnMgPD4gXCJcIiB0aGVuICh3IFwiK1wiOyBhKSBlbHNlIGFcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgaWYgUi5lcSBhIFIub25lICYmIFcuZXEgdSBXLm9uZSB0aGVuIHcgXCIxXCJcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgIGlmIG5vdCAoUi5lcSBhIFIub25lKSB0aGVuIHcgKFIudG9fc3RyaW5nIGEpO1xuICAgICAgICAgICAgICAgICAgaWYgbm90IChXLmVxIHUgVy5vbmUpIHRoZW4gdyAoVy50b19zdHJpbmcgdSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHA7XG4gICAgICAgICAgIWFuc1xuXG4gICAgICAoKiogQ2Fub25pY2FsIGluamVjdGlvbiBvZiB2YXJpYWJsZXMgaW50byBwb2x5bm9taWFscy4gKilcbiAgICAgIGxldCB2YXIgeCA9IGluaiAoVy5pbmogeClcblxuICAgICAgbGV0IHBvdyAodTp0KSBuID0gTW9ub2lkLnNpbXBsZV9wb3cgb25lIG11bCB1IG5cbiAgICBlbmRcbiAgICAoKiBTdWJzdGl0dXRpb25zLiAqKVxuICAgIG1vZHVsZSBTID0gc3RydWN0XG4gICAgICBpbmNsdWRlIFcuTWFwKFApXG5cbiAgICAgICgqKiBBcHBseSBhIHN1YnN0aXR1dGlvbiB0byBhIHBvbHlub21pYWwuICopXG4gICAgICBsZXQgYmluZCAocyA6IG1hcCkgKHAgOiBQLnQpID1cbiAgICAgICAgUC5tYXAgKGZ1biB1IC0+IGJpbmQgcyB1KSBwXG4gICAgZW5kXG5cbiAgICBpbmNsdWRlIFBcblxuICAgICgqKiBFeHRlbmQgYW4gdGhlIGludGVycHJldGF0aW9uIG9mIG9wZXJhdGlvbnMgdG8gdGVybXMuICopXG4gICAgbGV0IHJlYyBpbnRlcnByZXRhdGlvbiAob3A6T3AudCAtPiBWYXIudCBhcnJheSAtPiBQLnQpICh0OnRlcm0pIDogdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgQXBwIChmLCBsKSAtPlxuICAgICAgICAoKiBDYW5vbmljYWwgbmFtZSBmb3IgdmFyaWFibGVzLiAqKVxuICAgICAgICBsZXQgdiA9IExpc3QuaW5pdCAoT3AuYXJpdHkgZikgKGZ1biBpIC0+IFZhci5mcmVzaCAoKSkgaW5cbiAgICAgICAgbGV0IHMgPSBMaXN0Lm1hcDIgKGZ1biB4IHQgLT4geCwgaW50ZXJwcmV0YXRpb24gb3AgdCkgdiBsIGluXG4gICAgICAgIGxldCBzID0gUy5vZl9saXN0IHMgaW5cbiAgICAgICAgUy5iaW5kIHMgKG9wIGYgKEFycmF5Lm9mX2xpc3QgdikpXG4gICAgICB8IFZhciB4IC0+IFAudmFyIHhcbiAgZW5kXG5lbmRcblxuZXhjZXB0aW9uIE5vdF91bmlmaWFibGVcblxuKCoqIE1vc3QgZ2VuZXJhbCB1bmlmaWVyLiAqKVxubGV0IHVuaWZ5IHQxIHQyID1cbiAgKCogUHJpbnRmLnByaW50ZiBcIlVOSUZZICVzIFdJVEggJXNcXG4lIVwiICh0b19zdHJpbmcgdDEpICh0b19zdHJpbmcgdDIpOyAqKVxuICBsZXQgcmVjIGF1eCBxIHMgPVxuICAgIG1hdGNoIHEgd2l0aFxuICAgIHwgW10gLT4gc1xuICAgIHwgcDo6cSAtPlxuICAgICAgIG1hdGNoIHAgd2l0aFxuICAgICAgIHwgVmFyIHgsIHQgLT5cbiAgICAgICAgICBpZiBvY2N1cnMgeCB0IHRoZW4gcmFpc2UgTm90X3VuaWZpYWJsZTtcbiAgICAgICAgICBsZXQgcycgPSBTdWJzdC5zaW1wbGUgeCB0IGluXG4gICAgICAgICAgbGV0IGYgPSBTdWJzdC5hcHAgcycgaW5cbiAgICAgICAgICBsZXQgcSA9IExpc3QubWFwIChmdW4gKHQxLHQyKSAtPiBmIHQxLCBmIHQyKSBxIGluXG4gICAgICAgICAgbGV0IHMgPSBTdWJzdC5jb21wb3NlIHMgcycgaW5cbiAgICAgICAgICBhdXggcSAoU3Vic3QuYWRkIHMgeCB0KVxuICAgICAgIHwgdCwgVmFyIHggLT4gYXV4ICgoVmFyIHgsdCk6OnEpIHNcbiAgICAgICB8IEFwcCAoZjEsYTEpLCBBcHAgKGYyLGEyKSAtPlxuICAgICAgICAgIGlmIG5vdCAoT3AuZXEgZjEgZjIpIHRoZW4gcmFpc2UgTm90X3VuaWZpYWJsZTtcbiAgICAgICAgICBsZXQgcSA9IChMaXN0Lm1hcDIgcGFpciBhMSBhMikgQCBxIGluXG4gICAgICAgICAgYXV4IHEgc1xuICBpblxuICBsZXQgcyA9IGF1eCBbdDEsdDJdIFN1YnN0LmVtcHR5IGluXG4gIGFzc2VydCAoZXEgKFN1YnN0LmFwcCBzIHQxKSAoU3Vic3QuYXBwIHMgdDIpKTtcbiAgc1xuXG4oKlxubGV0IHVuaWZ5IHQxIHQyID1cbiAgbGV0IHMgPSB1bmlmeSB0MSB0MiBpblxuICBsZXQgdmFyID0gVmFyLm5hbWVyICgpIGluXG4gIGxldCB0MSA9IHRvX3N0cmluZyB+dmFyIHQxIGluXG4gIGxldCB0MiA9IHRvX3N0cmluZyB+dmFyIHQyIGluXG4gIGxldCBzcyA9IFN1YnN0LnRvX3N0cmluZyB+dmFyIHMgaW5cbiAgUHJpbnRmLnByaW50ZiBcIlVOSUZZICVzIFdJVEggJXMgSVMgJXNcXG4lIVwiIHQxIHQyIHNzO1xuICBzXG4qKVxuXG4oKiogV2hldGhlciBhIHBhdHRlcm4gbWF0Y2hlcyBhIHRlcm0uICopXG5sZXQgbWF0Y2hlcyB0MSB0MiA9XG4gIGxldCByZWMgYXV4IHEgcyA9XG4gICAgbWF0Y2ggcSB3aXRoXG4gICAgfCBbXSAtPiBzXG4gICAgfCBwOjpxIC0+XG4gICAgICBtYXRjaCBwIHdpdGhcbiAgICAgIHwgVmFyIHgsIHQgLT5cbiAgICAgICAgaWYgU3Vic3QuaW5fZG9tIHMgeCB0aGVuIChpZiBlcSAoU3Vic3QuYXBwIHMgKFZhciB4KSkgdCB0aGVuIGF1eCBxIHMgZWxzZSByYWlzZSBOb3RfdW5pZmlhYmxlKVxuICAgICAgICBlbHNlIGF1eCBxIChTdWJzdC5hZGQgcyB4IHQpXG4gICAgICB8IF8sIFZhciBfIC0+IHJhaXNlIE5vdF91bmlmaWFibGVcbiAgICAgIHwgQXBwIChmMSxhMSksIEFwcCAoZjIsYTIpIC0+XG4gICAgICAgIGlmIG5vdCAoT3AuZXEgZjEgZjIpIHRoZW4gcmFpc2UgTm90X3VuaWZpYWJsZTtcbiAgICAgICAgbGV0IHEgPSAoTGlzdC5tYXAyIHBhaXIgYTEgYTIpQHEgaW5cbiAgICAgICAgYXV4IHEgc1xuICBpblxuICBhdXggW3QxLHQyXSBTdWJzdC5lbXB0eVxuXG4oKlxubGV0IG1hdGNoZXMgdDEgdDIgPVxuICBsZXQgcyA9IG1hdGNoZXMgdDEgdDIgaW5cbiAgUHJpbnRmLnByaW50ZiBcIk1BVENIICVzIFdJVEggJXMgSVMgJXNcXG4lIVwiICh0b19zdHJpbmcgdDEpICh0b19zdHJpbmcgdDIpIChTdWJzdC50b19zdHJpbmcgcyk7XG4gIHNcbiAqKVxuXG4oKiogV2hldGhlciB0d28gdGVybXMgYXJlIGFscGhhLWVxdWl2YWxlbnQgKilcbmxldCBlcXVpdmFsZW50ID8ocz1TdWJzdC5lbXB0eSkgKHQxOnQpICh0Mjp0KSA9XG4gIGxldCByZWMgYXV4IHEgcyA9XG4gICAgbWF0Y2ggcSB3aXRoXG4gICAgfCBbXSAtPiBzXG4gICAgfCBwOjpxIC0+XG4gICAgICBtYXRjaCBwIHdpdGhcbiAgICAgIHwgVmFyIHgsIFZhciB5IC0+XG4gICAgICAgIGlmIFN1YnN0LmluX2RvbSBzIHggdGhlbiAoaWYgZXEgKFN1YnN0LmFwcCBzIChWYXIgeCkpIChWYXIgeSkgdGhlbiBhdXggcSBzIGVsc2UgcmFpc2UgTm90X3VuaWZpYWJsZSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCBzID0gU3Vic3QuYWRkIHMgeCAoVmFyIHkpIGluXG4gICAgICAgICAgYXV4IHEgc1xuICAgICAgfCBfLCBWYXIgXyB8IFZhciBfLCBfIC0+IHJhaXNlIE5vdF91bmlmaWFibGVcbiAgICAgIHwgQXBwIChmMSxhMSksIEFwcCAoZjIsYTIpIC0+XG4gICAgICAgIGlmIG5vdCAoT3AuZXEgZjEgZjIpIHRoZW4gcmFpc2UgTm90X3VuaWZpYWJsZTtcbiAgICAgICAgbGV0IHEgPSAoTGlzdC5tYXAyIHBhaXIgYTEgYTIpQHEgaW5cbiAgICAgICAgYXV4IHEgc1xuICBpblxuICB0cnkgaWdub3JlIChhdXggW3QxLHQyXSBzKTsgdHJ1ZVxuICB3aXRoIE5vdF91bmlmaWFibGUgLT4gZmFsc2VcblxuKCoqIFJld3JpdGluZyBzeXN0ZW1zLiAqKVxubW9kdWxlIFJTID0gc3RydWN0XG4gIGxldCBsaXN0X3JlbW92ZV9udGggbiBsID1cbiAgICBsZXQgcmVjIGF1eCBuIHAgPSBmdW5jdGlvblxuICAgICAgfCB4OjpsIC0+IGlmIG4gPSAwIHRoZW4gTGlzdC5yZXYgcCwgbCBlbHNlIGF1eCAobi0xKSAoeDo6cCkgbFxuICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICBpblxuICAgIGF1eCBuIFtdIGxcblxuICAoKiogUmV3cml0aW5nIHJ1bGVzLiAqKVxuICBtb2R1bGUgUnVsZSA9IHN0cnVjdFxuICAgICgqKiBBIHJld3JpdGluZyBydWxlLiAqKVxuICAgIHR5cGUgdCA9IHN0cmluZyAqIHRlcm0gKiB0ZXJtXG5cbiAgICBsZXQgbWFrZSByIHMgdCA6IHQgPSAocixzLHQpXG5cbiAgICBsZXQgb2Zfc3RyaW5nIG9wcyByIHMgdCA9XG4gICAgICBsZXQgcyA9IHBhcnNlIG9wcyBzIGluXG4gICAgICBsZXQgdCA9IHBhcnNlIG9wcyB0IGluXG4gICAgICBtYWtlIHIgcyB0XG5cbiAgICBsZXQgbmFtZSAoKHIscyx0KTp0KSA9IHJcblxuICAgIGxldCBzb3VyY2UgKChyLHMsdCk6dCkgPSBzXG5cbiAgICBsZXQgdGFyZ2V0ICgocixzLHQpOnQpID0gdFxuXG4gICAgKCoqIFZhcmlhYmxlcyBvZiB0aGUgcnVsZS4gKilcbiAgICBsZXQgdmFycyByID0gdmFycyAoc291cmNlIHIpXG5cbiAgICAoKiogQXJpdHkgb2YgdGhlIHJ1bGUuICopXG4gICAgbGV0IGFyaXR5IHIgPSBMaXN0Lmxlbmd0aCAodmFycyByKVxuXG4gICAgKCoqIEFyZ3VtZW50cyBvZiBhIHJ1bGUsIHNvcnRlZCBhY2NvcmRpbmcgdG8gaXRzIHZhcmlhYmxlcy4gKilcbiAgICBsZXQgYXJncyByIHMgPVxuICAgICAgbGV0IHZhcnMgPSB2YXJzIHIgaW5cbiAgICAgIGxldCBhcmdzID0gTGlzdC5zb3J0IChmdW4gKHgsdCkgKHksdSkgLT4gTGlzdC5pbmRleCAoZnVuIHogLT4gVmFyLmVxIHogeCkgdmFycyAtIExpc3QuaW5kZXggKGZ1biB6IC0+IFZhci5lcSB6IHkpIHZhcnMpIHMgaW5cbiAgICAgIExpc3QubWFwIHNuZCBhcmdzXG5cbiAgICAoKiogU3Vic3RpdHV0aW9uIGZyb20gYXJndW1lbnRzLiAqKVxuICAgIGxldCBhcmdzX3N1YnN0IHIgYSA6IFN1YnN0LnQgPVxuICAgICAgTGlzdC5tYXAyIChmdW4geCB0IC0+IHgsdCkgKHZhcnMgcikgYVxuXG4gICAgKCoqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHJ1bGUuICopXG4gICAgbGV0IHRvX3N0cmluZyA/dmFyIHIgPVxuICAgICAgbGV0IHMgPSB0b19zdHJpbmcgP3ZhciAoc291cmNlIHIpIGluXG4gICAgICBsZXQgdCA9IHRvX3N0cmluZyA/dmFyICh0YXJnZXQgcikgaW5cbiAgICAgIG5hbWUgciBeIFwiIDogXCIgXiBzIF4gXCIgLT4gXCIgXiB0XG5cbiAgICAoKiogRXF1YWxpdHkgb2YgcnVsZXMuICopXG4gICAgKCpcbiAgICBsZXQgZXEgKHIxOnQpIChyMjp0KSA9XG4gICAgICAoKiBQcmludGYucHJpbnRmIFwiRVEgJXMgV0lUSCAlc1xcbiUhXCIgKHRvX3N0cmluZyByMSkgKHRvX3N0cmluZyByMik7ICopXG4gICAgICBpZiBuYW1lIHIxIDw+IG5hbWUgcjIgdGhlbiBmYWxzZSBlbHNlXG4gICAgICAgIHRyeVxuICAgICAgICAgIGxldCBzID0gZXF1aXZhbGVudCAoc291cmNlIHIxKSAoc291cmNlIHIyKSBpblxuICAgICAgICAgIGVxIChTdWJzdC5hcHAgcyAodGFyZ2V0IHIxKSkgKHRhcmdldCByMilcbiAgICAgICAgd2l0aFxuICAgICAgICB8IE5vdF91bmlmaWFibGUgLT4gZmFsc2VcbiAgICAqKVxuICAgIGxldCBlcSByMSByMiA9IG5hbWUgcjEgPSBuYW1lIHIyXG4gIGVuZFxuXG4gIHR5cGUgcnVsZSA9IFJ1bGUudFxuXG4gICgqKiBBIHJld3JpdGluZyBzeXN0ZW0uICopXG4gIHR5cGUgdCA9XG4gICAge1xuICAgICAgb3BlcmF0aW9ucyA6IE9wLnQgbGlzdDtcbiAgICAgIHJ1bGVzIDogcnVsZSBsaXN0XG4gICAgfVxuICB0eXBlIHJzID0gdFxuXG4gIGxldCBvcGVyYXRpb25zIHJzID0gcnMub3BlcmF0aW9uc1xuXG4gIGxldCBydWxlcyBycyA9IHJzLnJ1bGVzXG5cbiAgKCoqIFNlbGVjdCBydWxlcyBzYXRpc2Z5aW5nIGEgcHJlZGljYXRlLiAqKVxuICBsZXQgZmlsdGVyIHAgcnMgPSB7IG9wZXJhdGlvbnMgPSBycy5vcGVyYXRpb25zOyBydWxlcyA9IExpc3QuZmlsdGVyIHAgcnMucnVsZXMgfVxuXG4gIGxldCBtYWtlIG9wZXJhdGlvbnMgcnVsZXMgPVxuICAgIHsgb3BlcmF0aW9uczsgcnVsZXMgfVxuXG4gICgqKiBFbXB0eSByZXdyaXRpbmcgc3lzdGVtLiAqKVxuICBsZXQgZW1wdHkgb3BzID0gbWFrZSBvcHMgW11cblxuICBsZXQgdG9fc3RyaW5nID8odmFyPVZhci5uYW1lcikgcnMgPVxuICAgIFN0cmluZy5jb25jYXQgXCJcXG5cIiAoTGlzdC5tYXAgKGZ1biByIC0+IFJ1bGUudG9fc3RyaW5nIH52YXI6KHZhcigpKSByKSAocnVsZXMgcnMpKVxuXG4gICgqKiBGaW5kIHRoZSBydWxlIHdpdGggZ2l2ZW4gbmFtZS4gKilcbiAgbGV0IGZpbmQgcnMgciA9XG4gICAgTGlzdC5maW5kIChmdW4gcicgLT4gUnVsZS5uYW1lIHInID0gcikgKHJ1bGVzIHJzKVxuXG4gICgqKiBSZXdyaXRpbmcgc3RlcHMuICopXG4gIG1vZHVsZSBTdGVwID0gc3RydWN0XG4gICAgKCoqIEEgcmV3cml0aW5nIHN0ZXAuICopXG4gICAgdHlwZSB0ID1cbiAgICAgIHwgVEFwcCBvZiBPcC50ICogdGVybSBsaXN0ICogdCAqIHRlcm0gbGlzdCAoKiogVGVybSBhcHBsaWNhdGlvbi4gKilcbiAgICAgIHwgUkFwcCBvZiBSdWxlLnQgKiBTdWJzdC50ICgqKiBSdWxlIGFwcGxpY2F0aW9uLiAqKVxuXG4gICAgbGV0IG9mX3Rlcm0gXyA9IGFzc2VydCBmYWxzZVxuXG4gICAgbGV0IHRhcHAgZiBhMSBzIGEyID1cbiAgICAgIGFzc2VydCAoTGlzdC5sZW5ndGggYTEgKyAxICsgTGlzdC5sZW5ndGggYTIgPSBPcC5hcml0eSBmKTtcbiAgICAgIFRBcHAgKGYsIGExLCBzLCBhMilcblxuICAgIGxldCByYXBwIHIgcyA9XG4gICAgICAoKiBQcmludGYucHJpbnRmIFwicmFwcDogJXMgdG8gJXNcXG4lIVwiIChSdWxlLnRvX3N0cmluZyByKSAoU3Vic3QudG9fc3RyaW5nIHMpOyAqKVxuICAgICAgbGV0IHZyID0gUnVsZS52YXJzIHIgaW5cbiAgICAgIGxldCB2cyA9IFN1YnN0LmRvbWFpbiBzIGluXG4gICAgICBhc3NlcnQgKExpc3QuZm9yX2FsbCAoZnVuIHggLT4gTGlzdC5leGlzdHMgKFZhci5lcSB4KSB2cykgdnIpO1xuICAgICAgYXNzZXJ0IChMaXN0LmZvcl9hbGwgKGZ1biB4IC0+IExpc3QuZXhpc3RzIChWYXIuZXEgeCkgdnIpIHZzKTtcbiAgICAgIFJBcHAgKHIsIHMpXG5cbiAgICAoKiogQXBwbHkgYSBzdWJzdGl0dXRpb24uICopXG4gICAgbGV0IHJlYyBzdWJzdCBzID0gZnVuY3Rpb25cbiAgICAgIHwgVEFwcCAoZiwgYTEsIHN0LCBhMikgLT4gdGFwcCBmIChMaXN0Lm1hcCAoU3Vic3QuYXBwIHMpIGExKSAoc3Vic3QgcyBzdCkgKExpc3QubWFwIChTdWJzdC5hcHAgcykgYTIpXG4gICAgICB8IFJBcHAgKHIsIHMnKSAtPiByYXBwIHIgKFN1YnN0LmNvbXBvc2UgcycgcylcblxuICAgICgqKiBTb3VyY2UuICopXG4gICAgbGV0IHJlYyBzb3VyY2UgPSBmdW5jdGlvblxuICAgICAgfCBUQXBwIChmLCBhMSwgcywgYTIpIC0+IGFwcCBmIChhMUBbc291cmNlIHNdQGEyKVxuICAgICAgfCBSQXBwIChyLCBzKSAtPiBTdWJzdC5hcHAgcyAoUnVsZS5zb3VyY2UgcilcblxuICAgICgqKiBUYXJnZXQuICopXG4gICAgbGV0IHJlYyB0YXJnZXQgPSBmdW5jdGlvblxuICAgICAgfCBUQXBwIChmLCBhMSwgcywgYTIpIC0+IGFwcCBmIChhMUBbdGFyZ2V0IHNdQGEyKVxuICAgICAgfCBSQXBwIChyLCBzKSAtPiBTdWJzdC5hcHAgcyAoUnVsZS50YXJnZXQgcilcblxuICAgIGxldCByZWMgbGFiZWwgPyh2YXI9VmFyLnRvX3N0cmluZykgPSBmdW5jdGlvblxuICAgICAgfCBUQXBwIChmLCBhMSwgcywgYTIpIC0+XG4gICAgICAgIGxldCBhMSA9IExpc3QubWFwIChzdHJpbmdfb2ZfdGVybSB+dmFyKSBhMSBpblxuICAgICAgICBsZXQgYTIgPSBMaXN0Lm1hcCAoc3RyaW5nX29mX3Rlcm0gfnZhcikgYTIgaW5cbiAgICAgICAgbGV0IGEgPSBhMUBbbGFiZWwgfnZhciBzXUBhMiBpblxuICAgICAgICBPcC50b19zdHJpbmcgZiBhXG4gICAgICB8IFJBcHAgKHIsIHMpIC0+XG4gICAgICAgIGxldCBhID0gUnVsZS5hcmdzIHIgcyBpblxuICAgICAgICBsZXQgYSA9IExpc3QubWFwIChzdHJpbmdfb2ZfdGVybSB+dmFyKSBhIGluXG4gICAgICAgIGxldCBhID0gU3RyaW5nLmNvbmNhdCBcIixcIiBhIGluXG4gICAgICAgIFJ1bGUubmFtZSByIF4gXCIoXCIgXiBhIF4gXCIpXCJcblxuICAgIGxldCB0b19zdHJpbmcgP3ZhciBzID1cbiAgICAgIHN0cmluZ19vZl90ZXJtID92YXIgKHNvdXJjZSBzKSBeIFwiIC1cIiBeIGxhYmVsID92YXIgcyBeIFwiLT4gXCIgXiBzdHJpbmdfb2ZfdGVybSA/dmFyICh0YXJnZXQgcylcblxuICAgIGxldCByZWMgcnVsZSA9IGZ1bmN0aW9uXG4gICAgICB8IFRBcHAgKGYsIGExLCBzLCBhMikgLT4gcnVsZSBzXG4gICAgICB8IFJBcHAgKHIsIF8pIC0+IHJcblxuICAgIGxldCBoYXNfY29udGV4dCA9IGZ1bmN0aW9uXG4gICAgICB8IFRBcHAgXyAtPiB0cnVlXG4gICAgICB8IFJBcHAgKHIsIHMpIC0+IG5vdCAoU3Vic3QuaXNfaW5qZWN0aXZlX3JlbmFtaW5nIHMpXG5cbiAgICBsZXQgcmVjIGVxIHMxIHMyID1cbiAgICAgICgqIFByaW50Zi5wcmludGYgXCJlcTogJXMgdnMgJXNcXG4lIVwiICh0b19zdHJpbmcgczEpICh0b19zdHJpbmcgczIpOyAqKVxuICAgICAgbWF0Y2ggczEsczIgd2l0aFxuICAgICAgfCBUQXBwIChmLCBhMSwgcywgYTIpLCBUQXBwIChmJywgYTEnLCBzJywgYTInKSAtPlxuICAgICAgICBPcC5lcSBmIGYnICYmXG4gICAgICAgIExpc3QubGVuZ3RoIGExID0gTGlzdC5sZW5ndGggYTEnICYmXG4gICAgICAgIExpc3QubGVuZ3RoIGEyID0gTGlzdC5sZW5ndGggYTInICYmXG4gICAgICAgIExpc3QuZm9yX2FsbDIgZXFfdGVybSBhMSBhMScgJiZcbiAgICAgICAgZXEgcyBzJyAmJlxuICAgICAgICBMaXN0LmZvcl9hbGwyIGVxX3Rlcm0gYTIgYTInXG4gICAgICB8IFJBcHAgKHIsIHMpLCBSQXBwIChyJywgcycpIC0+IFJ1bGUuZXEgciByJyAmJiBTdWJzdC5lcSBzIHMnXG4gICAgICB8IF8gLT4gZmFsc2VcbiAgICBcbiAgICAoKiogV2hldGhlciBhIHJ1bGUgb2NjdXJzIGluIGEgc3RlcC4gKilcbiAgICBsZXQgcmVjIGhhc19ydWxlIHIgPSBmdW5jdGlvblxuICAgICAgfCBUQXBwIChfLCBfLCBzLCBfKSAtPiBoYXNfcnVsZSByIHNcbiAgICAgIHwgUkFwcCAocicsIF8pIC0+IFJ1bGUuZXEgciByJ1xuICBlbmRcblxuICB0eXBlIHN0ZXAgPSBTdGVwLnRcblxuICAoKiogQWxsIHBvc3NpYmxlIHJld3JpdGluZyBzdGVwcy4gKilcbiAgbGV0IHN0ZXBzIChyczp0KSB0IDogc3RlcCBsaXN0ID1cbiAgICBsZXQgcmVjIGF1eCByIGN0eCA9IGZ1bmN0aW9uXG4gICAgICB8IFZhciB4IC0+IFtdXG4gICAgICB8IEFwcCAoZixhKSBhcyB0IC0+XG4gICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgIHRyeVxuICAgICAgICAgICAgIGxldCBzID0gbWF0Y2hlcyAoUnVsZS5zb3VyY2UgcikgdCBpblxuICAgICAgICAgICAgIFtjdHggKFN0ZXAucmFwcCByIHMpXVxuICAgICAgICAgICB3aXRoXG4gICAgICAgICAgIHwgTm90X3VuaWZpYWJsZSAtPiBbXVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBzJyA9XG4gICAgICAgICAgIExpc3QubWFwaVxuICAgICAgICAgICAgIChmdW4gaSB0IC0+XG4gICAgICAgICAgICAgICAgbGV0IGExLCBhMiA9IGxpc3RfcmVtb3ZlX250aCBpIGEgaW5cbiAgICAgICAgICAgICAgICBsZXQgY3R4IHQgPSBjdHggKFN0ZXAudGFwcCBmIGExIHQgYTIpIGluXG4gICAgICAgICAgICAgICAgYXV4IHIgY3R4IHRcbiAgICAgICAgICAgICApIGFcbiAgICAgICAgIGluXG4gICAgICAgICBsZXQgcycgPSBMaXN0LmZsYXR0ZW4gcycgaW5cbiAgICAgICAgIHMnIEAgc1xuICAgIGluXG4gICAgTGlzdC5mbGF0dGVuIChMaXN0Lm1hcCAoZnVuIHIgLT4gYXV4IHIgRnVuLmlkIHQpIChydWxlcyBycykpXG5cbiAgKCoqIFJld3JpdGluZyBwYXRocy4gKilcbiAgbW9kdWxlIFBhdGggPSBzdHJ1Y3QgICAgXG4gICAgKCoqIEEgcmV3cml0aW5nIHBhdGguICopXG4gICAgdHlwZSB0ID1cbiAgICAgIHwgRW1wdHkgb2YgdGVybVxuICAgICAgfCBTdGVwIG9mIHQgKiBzdGVwXG5cbiAgICBsZXQgZW1wdHkgdCA9IEVtcHR5IHRcblxuICAgIGxldCByZWMgc291cmNlID0gZnVuY3Rpb25cbiAgICAgIHwgU3RlcCAocCxfKSAtPiBzb3VyY2UgcFxuICAgICAgfCBFbXB0eSB0IC0+IHRcblxuICAgIGxldCB0YXJnZXQgPSBmdW5jdGlvblxuICAgICAgfCBTdGVwIChfLHMpIC0+IFN0ZXAudGFyZ2V0IHNcbiAgICAgIHwgRW1wdHkgdCAtPiB0XG5cbiAgICBsZXQgc3RlcCBzID1cbiAgICAgIFN0ZXAgKEVtcHR5IChTdGVwLnNvdXJjZSBzKSwgcylcbiBcbiAgICBsZXQgYXBwZW5kX3N0ZXAgcCBzID1cbiAgICAgIGFzc2VydCAoZXEgKHRhcmdldCBwKSAoU3RlcC5zb3VyY2UgcykpO1xuICAgICAgU3RlcCAocCxzKVxuXG4gICAgbGV0IHJlYyB0b19zdHJpbmcgP3ZhciA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IHQgLT4gc3RyaW5nX29mX3Rlcm0gP3ZhciB0XG4gICAgICB8IFN0ZXAgKHAscykgLT5cbiAgICAgICAgbGV0IHNyYyA9IHRvX3N0cmluZyA/dmFyIHAgaW5cbiAgICAgICAgbGV0IGxibCA9IFN0ZXAubGFiZWwgP3ZhciBzIGluXG4gICAgICAgIGxldCB0Z3QgPSBzdHJpbmdfb2ZfdGVybSA/dmFyIChTdGVwLnRhcmdldCBzKSBpblxuICAgICAgICBzcmMgXiBcIiAtXCIgXiBsYmwgXiBcIi0+IFwiIF4gdGd0XG5cbiAgICBsZXQgcmVjIGFwcGVuZCBwID0gZnVuY3Rpb25cbiAgICAgIHwgU3RlcCAocSwgcykgLT4gU3RlcCAoYXBwZW5kIHAgcSwgcylcbiAgICAgIHwgRW1wdHkgdCAtPlxuICAgICAgICAgYXNzZXJ0IChlcSAodGFyZ2V0IHApIHQpO1xuICAgICAgICAgcFxuXG4gICAgKCoqIFJ1bGVzIHdoaWNoIGFyZSB1c2VkIHdpdGhvdXQgY29udGV4dC4gKilcbiAgICBsZXQgcmVjIHRvcGxldmVsX3J1bGVzID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgdCAtPiBbXVxuICAgICAgfCBTdGVwIChwLHMpIC0+ICh0b3BsZXZlbF9ydWxlcyBwKUAoaWYgU3RlcC5oYXNfY29udGV4dCBzIHRoZW4gW10gZWxzZSBbU3RlcC5ydWxlIHNdKVxuXG4gICAgbGV0IHJlYyBlcSBwIHAnID1cbiAgICAgIG1hdGNoIHAscCcgd2l0aFxuICAgICAgfCBTdGVwIChwLHMpLCBTdGVwIChwJyxzJykgLT4gZXEgcCBwJyAmJiBTdGVwLmVxIHMgcydcbiAgICAgIHwgRW1wdHkgdCwgRW1wdHkgdCcgLT4gZXFfdGVybSB0IHQnXG4gICAgICB8IF8gLT4gZmFsc2VcblxuICAgICgqKiBSdWxlcyBvY2N1cnJpbmcgaW4gYSBzdGVwLiAqKVxuICAgIGxldCByZWMgcnVsZXMgPSBmdW5jdGlvblxuICAgICAgfCBTdGVwIChwLHMpIC0+XG4gICAgICAgIGxldCByID0gU3RlcC5ydWxlIHMgaW5cbiAgICAgICAgbGV0IHJyID0gcnVsZXMgcCBpblxuICAgICAgICBpZiBMaXN0LmV4aXN0cyAoUnVsZS5lcSByKSByciB0aGVuIHJyXG4gICAgICAgIGVsc2Ugcjo6cnJcbiAgICAgIHwgRW1wdHkgXyAtPiBbXVxuXG4gICAgKCoqIExlbmd0aCBvZiBhIHBhdGguICopXG4gICAgbGV0IHJlYyBsZW5ndGggPSBmdW5jdGlvblxuICAgICAgfCBTdGVwIChwLCBfKSAtPiAxICsgbGVuZ3RoIHBcbiAgICAgIHwgRW1wdHkgXyAtPiAwXG5cbiAgICAoKiogbnRoIHN0ZXAgaW4gYSBwYXRoLiAqKVxuICAgIGxldCBudGhfc3RlcCBuIHAgPVxuICAgICAgbGV0IHJlYyBhdXggbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgU3RlcCAocCwgcykgLT5cbiAgICAgICAgICBpZiBuID0gMCB0aGVuIHMgZWxzZSBhdXggKG4tMSkgcFxuICAgICAgICB8IEVtcHR5IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICBpblxuICAgICAgYXV4IChsZW5ndGggcCAtIDEgLSBuKSBwXG5cbiAgICAoKiogbnRoIHRlcm0gaW4gYSBwYXRoLiAqKVxuICAgIGxldCBudGhfdGVybSBuIHAgPVxuICAgICAgbGV0IHJlYyBhdXggbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgU3RlcCAocCwgcykgLT5cbiAgICAgICAgICBpZiBuID0gMCB0aGVuIFN0ZXAudGFyZ2V0IHMgZWxzZSBhdXggKG4tMSkgcFxuICAgICAgICB8IEVtcHR5IHQgLT5cbiAgICAgICAgICBpZiBuID0gMCB0aGVuIHQgZWxzZSBhc3NlcnQgZmFsc2VcbiAgICAgIGluXG4gICAgICBhdXggKGxlbmd0aCBwIC0gbikgcFxuICBlbmRcblxuICAoKiogTm9ybWFsaXplIGEgdGVybS4gKilcbiAgbGV0IG5vcm1hbGl6ZSBycyB0ID1cbiAgICBsZXQgcmVjIGF1eCBwID1cbiAgICAgIGxldCBzID0gc3RlcHMgcnMgKFBhdGgudGFyZ2V0IHApIGluXG4gICAgICBpZiBzID0gW10gdGhlbiBwIGVsc2UgYXV4IChQYXRoLmFwcGVuZF9zdGVwIHAgKExpc3QuaGQgcykpXG4gICAgaW5cbiAgICBhdXggKFBhdGguZW1wdHkgdClcblxuICAoKiogVW5pZnkgdGhlIHNvdXJjZSBvZiBbcjJdIHdpdGggYSBzdWJ0ZXJtIG9mIHRoZSBzb3VyY2Ugb2YgW3IxXS4gKilcbiAgbGV0IGNyaXRpY2FsX3J1bGVzIHIxIHIyID1cbiAgICBsZXQgcmVjIGF1eCBjdHggdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgVmFyIHggLT4gW11cbiAgICAgIHwgQXBwIChmLGEpIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIGxldCB0MiA9IFJ1bGUuc291cmNlIHIyIGluXG4gICAgICAgICAgICAoKiBXZSByZW5hbWUgcnVsZSAyIGJlZm9yZSB1bmlmaWNhdGlvbi4gTm90ZSB0aGF0IHdlIGNhbm5vdCByZW5hbWVcbiAgICAgICAgICAgICAgIHJ1bGUgMSBiZWNhdXNlIHNvbWUgb2YgaXRzIHZhcmlhYmxlcyBjYW4gb2NjdXIgaW4gdGhlIGNvbnRleHQuICopXG4gICAgICAgICAgICBsZXQgbjIgPSBTdWJzdC5yZW5hbWUgKFJ1bGUudmFycyByMikgaW5cbiAgICAgICAgICAgIGxldCBzID0gdW5pZnkgdCAoU3Vic3QuYXBwIG4yIHQyKSBpblxuICAgICAgICAgICAgKCogRXh0ZW5kIHRoZSBkb21haW4gb2YgZGVmaW5pdGlvbi4gKilcbiAgICAgICAgICAgIGxldCBzdGVwMSA9IFN0ZXAucmFwcCByMSAoU3Vic3QuY29tcG9zZSAoU3Vic3QuaWQgKFJ1bGUudmFycyByMSkpIHMpIGluXG4gICAgICAgICAgICBsZXQgc3RlcDIgPSBTdGVwLnN1YnN0IHMgKGN0eCAoU3RlcC5yYXBwIHIyIG4yKSkgaW5cbiAgICAgICAgICAgIGFzc2VydCAoZXF1aXZhbGVudCAoU3RlcC5zb3VyY2Ugc3RlcDEpIChTdGVwLnNvdXJjZSBzdGVwMikpO1xuICAgICAgICAgICAgaWYgUnVsZS5lcSByMSByMiAmJiBub3QgKFN0ZXAuaGFzX2NvbnRleHQgc3RlcDEpICYmIG5vdCAoU3RlcC5oYXNfY29udGV4dCBzdGVwMikgdGhlbiBbXSBlbHNlIFtzdGVwMSxzdGVwMl1cbiAgICAgICAgICB3aXRoXG4gICAgICAgICAgfCBOb3RfdW5pZmlhYmxlIC0+IFtdXG4gICAgICAgIGluXG4gICAgICAgIGxldCBzJyA9XG4gICAgICAgICAgTGlzdC5tYXBpXG4gICAgICAgICAgICAoZnVuIGkgdCAtPlxuICAgICAgICAgICAgICAgbGV0IGExLCBhMiA9IGxpc3RfcmVtb3ZlX250aCBpIGEgaW5cbiAgICAgICAgICAgICAgIGxldCBjdHggdCA9IGN0eCAoU3RlcC50YXBwIGYgYTEgdCBhMikgaW5cbiAgICAgICAgICAgICAgIGF1eCBjdHggdCkgYVxuICAgICAgICBpblxuICAgICAgICBsZXQgcycgPSBMaXN0LmZsYXR0ZW4gcycgaW5cbiAgICAgICAgcyBAIHMnXG4gICAgaW5cbiAgICBhdXggRnVuLmlkIChSdWxlLnNvdXJjZSByMSlcblxuICAoKiogQ3JpdGljYWwgYnJhbmNoaW5ncy4gKilcbiAgbGV0IGNyaXRpY2FsIChyczp0KSA9XG4gICAgbGV0IHN0ZXBzID0gTGlzdC5mbGF0dGVuIChMaXN0LmZsYXR0ZW4gKExpc3QubWFwIChmdW4gcjEgLT4gTGlzdC5tYXAgKGZ1biByMiAtPiBjcml0aWNhbF9ydWxlcyByMSByMikgKHJ1bGVzIHJzKSkgKHJ1bGVzIHJzKSkpIGluXG4gICAgKCogUmVtb3ZlIHN5bW1ldHJpYyBwYWlycy4gKilcbiAgICBsZXQgcmVjIHN5bSA9IGZ1bmN0aW9uXG4gICAgICB8IChzMSxzMik6OnN0ZXBzIC0+XG4gICAgICAgICBsZXQgc3RlcHMgPSBMaXN0LmZpbHRlciAoZnVuIChzMicsczEnKSAtPiBub3QgKFN0ZXAuZXEgczEgczEnICYmIFN0ZXAuZXEgczIgczInKSkgc3RlcHMgaW5cbiAgICAgICAgIChzMSxzMik6OihzeW0gc3RlcHMpXG4gICAgICB8IFtdIC0+IFtdXG4gICAgaW5cbiAgICBzeW0gc3RlcHNcblxuICAoKiogT3JpZW50IHJ1bGVzIGFjY29yZGluZyB0byBhIHBhcnRpY3VsYXIgb3JkZXIuICopXG4gIGxldCBvcmllbnQgfmd0IHJzID1cbiAgICBsZXQgcnVsZXMgPSBMaXN0Lm1hcCAoZnVuIChuLHQsdSkgLT4gaWYgbm90IChndCB0IHUpIHRoZW4gKG4sdSx0KSBlbHNlIChuLHQsdSkpIChydWxlcyBycykgaW5cbiAgICB7IG9wZXJhdGlvbnMgPSBycy5vcGVyYXRpb25zOyBydWxlcyB9XG5cbiAgKCoqIEtudXRoLUJlbmRpeCBjb21wbGV0aW9uLiBbZ3RdIGlzIHRoZSBzdHJpY3Qgb3JkZXIgb24gdGVybXMsIFtjYWxsYmFja10gaXNcbiAgICAgIGEgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIHJlZ3VsYXJseSB3aXRoIHRoZSBjdXJyZW50IHJld3JpdGluZyBzeXN0ZW0gYXNcbiAgICAgIGFyZ3VtZW50ICh1c2VmdWwgdG8gZGlzcGxheSBkdXJpbmcgdGhlIGNvbXBsZXRpb24pLiAqKVxuICBsZXQga251dGhfYmVuZGl4ID8oZ3Q9TFBPLmd0ICg+PSkpID9uYW1lciA/KGNhbGxiYWNrPWZ1biBfIC0+ICgpKSBycyA9XG4gICAgbGV0IHJzID0gb3JpZW50IH5ndCBycyBpblxuICAgICgqIE5hbWUgZm9yIG5ldyBydWxlcy4gKilcbiAgICBsZXQgbmFtZXIgPVxuICAgICAgbWF0Y2ggbmFtZXIgd2l0aFxuICAgICAgfCBTb21lIG5hbWVyIC0+IG5hbWVyXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgbGV0IG4gPSByZWYgKC0xKSBpblxuICAgICAgICBmdW4gKCkgLT4gaW5jciBuOyBcIktcIl5zdHJpbmdfb2ZfaW50ICFuXG4gICAgaW5cbiAgICAoKiBSdWxlcyB0byBoYW5kbGUuICopXG4gICAgbGV0IHF1ZXVlID0gcmVmIHJzLnJ1bGVzIGluXG4gICAgKCogUHJvZHVjZWQgcmV3cml0aW5nIHN5c3RlbS4gKilcbiAgICBsZXQgcnVsZXMgPSByZWYgcnMucnVsZXMgaW5cbiAgICBsZXQgYWRkIChyOlJ1bGUudCkgPVxuICAgICAgKCogUHJpbnRmLnByaW50ZiBcImFkZCAlc1xcbiUhXCIgKFJ1bGUudG9fc3RyaW5nIHIpOyAqKVxuICAgICAgcnVsZXMgOj0gciA6OiAhcnVsZXM7XG4gICAgICAoKiBOb3JtYWxpemUgdGhlIHJ1bGVzICopXG4gICAgICBydWxlcyA6PVxuICAgICAgICBMaXN0Lm1hcFxuICAgICAgICAgIChmdW4gKChuLHMsdCkgYXMgcikgLT5cbiAgICAgICAgICAgICAoKiBUT0RPOiBwcm9wZXIgcmVjdXJzaXZlIGZ1bmN0aW9uIGluc3RlYWQgb2YgdGhpcyBmaWx0ZXIgKilcbiAgICAgICAgICAgICBsZXQgcnVsZXMgPSBMaXN0LmZpbHRlciAoZnVuIHInIC0+IG5vdCAoUnVsZS5lcSByIHInKSkgIXJ1bGVzIGluXG4gICAgICAgICAgICAgbGV0IHJzID0geyBycyB3aXRoIHJ1bGVzIH0gaW5cbiAgICAgICAgICAgICBuLCBQYXRoLnRhcmdldCAobm9ybWFsaXplIHJzIHMpLCBQYXRoLnRhcmdldCAobm9ybWFsaXplIHJzIHQpXG4gICAgICAgICAgKSAhcnVsZXM7XG4gICAgICBydWxlcyA6PSBMaXN0LmZpbHRlciAoZnVuIChuLHMsdCkgLT4gbm90IChlcSBzIHQpKSAhcnVsZXM7XG4gICAgICBxdWV1ZSA6PSAhcXVldWVAW3JdXG4gICAgICAoKiBxdWV1ZSA6PSByIDo6ICFxdWV1ZSAqKVxuICAgIGluXG4gICAgd2hpbGUgIXF1ZXVlIDw+IFtdIGRvXG4gICAgICBsZXQgciA9IExpc3QuaGQgIXF1ZXVlIGluXG4gICAgICBxdWV1ZSA6PSBMaXN0LnRsICFxdWV1ZTtcbiAgICAgIGxldCBjcCA9IExpc3QuZmxhdHRlbiAoTGlzdC5tYXAgKGZ1biBzIC0+IChjcml0aWNhbF9ydWxlcyByIHMpQChjcml0aWNhbF9ydWxlcyBzIHIpKSAhcnVsZXMpIGluXG4gICAgICBMaXN0Lml0ZXJcbiAgICAgICAgKGZ1biAoczEsIHMyKSAtPlxuICAgICAgICAgICBsZXQgcnMgPSB7IHJzIHdpdGggcnVsZXMgPSAhcnVsZXMgfSBpblxuICAgICAgICAgICBsZXQgcDEgPSBQYXRoLmFwcGVuZCAoUGF0aC5zdGVwIHMxKSAobm9ybWFsaXplIHJzIChTdGVwLnRhcmdldCBzMSkpIGluXG4gICAgICAgICAgIGxldCBwMiA9IFBhdGguYXBwZW5kIChQYXRoLnN0ZXAgczIpIChub3JtYWxpemUgcnMgKFN0ZXAudGFyZ2V0IHMyKSkgaW5cbiAgICAgICAgICAgbGV0IHQxID0gUGF0aC50YXJnZXQgcDEgaW5cbiAgICAgICAgICAgbGV0IHQyID0gUGF0aC50YXJnZXQgcDIgaW5cbiAgICAgICAgICAgaWYgbm90IChlcSB0MSB0MikgdGhlblxuICAgICAgICAgICAgIGxldCB0MSwgdDIgPSBpZiBndCB0MSB0MiB0aGVuIHQxLCB0MiBlbHNlIHQyLCB0MSBpblxuICAgICAgICAgICAgIGxldCByID0gKG5hbWVyICgpLCB0MSwgdDIpIGluXG4gICAgICAgICAgICAgUHJpbnRmLnByaW50ZiBcImFkZCAlc1xcbiVzXFxuJXNcXG5cXG4lIVwiIChSdWxlLnRvX3N0cmluZyByKSAoUGF0aC50b19zdHJpbmcgcDEpIChQYXRoLnRvX3N0cmluZyBwMik7XG4gICAgICAgICAgICAgYWRkIHJcbiAgICAgICAgKSBjcDtcbiAgICAgIGNhbGxiYWNrIHsgcnMgd2l0aCBydWxlcyA9ICFydWxlcyB9XG4gICAgZG9uZTtcbiAgICB7IHJzIHdpdGggcnVsZXMgPSAhcnVsZXMgfVxuXG4gICgqKiBSYWlzZWQgd2hlbiB0aGUgc3lzdGVtIGlzIG5vdCBjb25mbHVlbnQuICopXG4gIGV4Y2VwdGlvbiBOb3RfY29uZmx1ZW50XG5cbiAgKCoqIFNxdWllciBjb21wbGV0aW9uLiAqKVxuICBsZXQgc3F1aWVyIHJzID1cbiAgICBMaXN0Lm1hcFxuICAgICAgKGZ1biAoczEsczIpIC0+XG4gICAgICAgICAoKiBQcmludGYucHJpbnRmIFwiYnJhbmNoaW5nXFxuJXNcXG4lc1xcblxcbiUhXCIgKFN0ZXAudG9fc3RyaW5nIHMxKSAoU3RlcC50b19zdHJpbmcgczIpOyAqKVxuICAgICAgICAgbGV0IHAxID0gUGF0aC5hcHBlbmQgKFBhdGguc3RlcCBzMSkgKG5vcm1hbGl6ZSBycyAoU3RlcC50YXJnZXQgczEpKSBpblxuICAgICAgICAgbGV0IHAyID0gUGF0aC5hcHBlbmQgKFBhdGguc3RlcCBzMikgKG5vcm1hbGl6ZSBycyAoU3RlcC50YXJnZXQgczIpKSBpblxuICAgICAgICAgaWYgbm90IChlcSAoUGF0aC50YXJnZXQgcDEpIChQYXRoLnRhcmdldCBwMikpIHRoZW5cbiAgICAgICAgICAgKFxuICAgICAgICAgICAgIFByaW50Zi5wcmludGYgXCJub3QgY29uZmx1ZW50OlxcbiVzXFxuJXNcXG4lIVwiIChQYXRoLnRvX3N0cmluZyBwMSkgKFBhdGgudG9fc3RyaW5nIHAyKTtcbiAgICAgICAgICAgICByYWlzZSBOb3RfY29uZmx1ZW50XG4gICAgICAgICAgICk7XG4gICAgICAgICBwMSwgcDJcbiAgICAgIClcbiAgICAgIChjcml0aWNhbCBycylcblxuICAoKiogUmV3cml0aW5nIHppZ3phZ3MuICopXG4gIG1vZHVsZSBaaWd6YWcgPSBzdHJ1Y3RcbiAgICAoKiogQSByZXdyaXRpbmcgemlnemFnLiAqKVxuICAgIHR5cGUgdCA9XG4gICAgICB8IFN0ZXAgb2YgU3RlcC50XG4gICAgICB8IENvbXAgb2YgdCAqIHRcbiAgICAgIHwgSWQgb2YgdGVybVxuICAgICAgfCBJbnYgb2YgdFxuXG4gICAgKCoqIFN0cmluZyByZXByZXNlbnRhdGlvbi4gKilcbiAgICBsZXQgcmVjIHRvX3N0cmluZyA/KHBhPWZhbHNlKSA/dmFyID0gZnVuY3Rpb25cbiAgICAgIHwgU3RlcCBzIC0+IFN0ZXAubGFiZWwgP3ZhciBzXG4gICAgICB8IENvbXAgKHAxLHAyKSAtPlxuICAgICAgICBsZXQgcyA9IHRvX3N0cmluZyB+cGE6dHJ1ZSA/dmFyIHAxIF4gXCIuXCIgXiB0b19zdHJpbmcgP3ZhciBwMiBpblxuICAgICAgICBpZiBwYSB0aGVuIFwiKFwiIF4gcyBeIFwiKVwiIGVsc2Ugc1xuICAgICAgfCBJZCB0IC0+IHN0cmluZ19vZl90ZXJtID92YXIgdFxuICAgICAgfCBJbnYgcCAtPiB0b19zdHJpbmcgfnBhOnRydWUgP3ZhciBwIF4gXCItXCJcblxuICAgIGxldCByZWMgc291cmNlID0gZnVuY3Rpb25cbiAgICAgIHwgU3RlcCBzIC0+IFN0ZXAuc291cmNlIHNcbiAgICAgIHwgQ29tcCAocCwgXykgLT4gc291cmNlIHBcbiAgICAgIHwgSWQgdCAtPiB0XG4gICAgICB8IEludiBwIC0+IHRhcmdldCBwXG4gICAgYW5kIHRhcmdldCA9IGZ1bmN0aW9uXG4gICAgICB8IFN0ZXAgcyAtPiBTdGVwLnRhcmdldCBzXG4gICAgICB8IENvbXAgKF8sIHApIC0+IHRhcmdldCBwXG4gICAgICB8IElkIHQgLT4gdFxuICAgICAgfCBJbnYgcCAtPiBzb3VyY2UgcFxuXG4gICAgKCoqIFBhdGggcmVkdWNlZCB0byBvbmUgc3RlcC4gKilcbiAgICBsZXQgc3RlcCBzID0gU3RlcCBzXG5cbiAgICAoKiogQ29uY2F0ZW5hdGlvbiBvZiB0d28gcGF0aHMuICopXG4gICAgbGV0IGNvbXAgcDEgcDIgPVxuICAgICAgKCogUHJpbnRmLnByaW50ZiBcImNvbXBvc2UgJXMgd2l0aCAlc1xcbiUhXCIgKHRvX3N0cmluZyBwMSkgKHRvX3N0cmluZyBwMik7ICopXG4gICAgICAoKiBQcmludGYucHJpbnRmIFwiJXMgdnMgJXNcXG4lIVwiIChzdHJpbmdfb2ZfdGVybSAodGFyZ2V0IHAxKSkgKHN0cmluZ19vZl90ZXJtIChzb3VyY2UgcDIpKTsgKilcbiAgICAgIGFzc2VydCAoZXEgKHRhcmdldCBwMSkgKHNvdXJjZSBwMikpO1xuICAgICAgQ29tcCAocDEsIHAyKVxuXG4gICAgbGV0IGFwcGVuZCBwMSBwMiA9IGNvbXAgcDEgcDJcblxuICAgICgqKiBDb25jYXRlbmF0aW9uIG9mIGEgbGlzdCBvZiBwYXRocy4gKilcbiAgICBsZXQgcmVjIGNvbmNhdCA9IGZ1bmN0aW9uXG4gICAgICB8IFtwXSAtPiBwXG4gICAgICB8IHA6OmwgLT4gYXBwZW5kIHAgKGNvbmNhdCBsKVxuICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcblxuICAgICgqKiBJbnZlcnNlIG9mIGEgcGF0aC4gKilcbiAgICBsZXQgaW52IHAgPSBJbnYgcFxuXG4gICAgKCoqIEVxdWFsaXR5IGJldHdlZW4gcGF0aHMuICopXG4gICAgbGV0IHJlYyBlcSBwIHAnID1cbiAgICAgIG1hdGNoIHAsIHAnIHdpdGhcbiAgICAgIHwgU3RlcCBzLCBTdGVwIHMnIC0+IFN0ZXAuZXEgcyBzJ1xuICAgICAgfCBDb21wIChwLCBxKSwgQ29tcCAocCcsIHEnKSAtPiBlcSBwIHAnICYmIGVxIHEgcSdcbiAgICAgIHwgSWQgdCwgSWQgdCcgLT4gZXFfdGVybSB0IHQnXG4gICAgICB8IEludiBwLCBJbnYgcCcgLT4gZXEgcCBwJ1xuICAgICAgfCBfIC0+IGZhbHNlXG5cbiAgICAoKiogTnVtYmVyIG9mIHN0ZXBzIGluIGEgcGF0aC4gKilcbiAgICBsZXQgcmVjIGxlbmd0aCA9IGZ1bmN0aW9uXG4gICAgICB8IFN0ZXAgXyAtPiAxXG4gICAgICB8IENvbXAgKHAsIHEpIC0+IGxlbmd0aCBwICsgbGVuZ3RoIHFcbiAgICAgIHwgSWQgXyAtPiAwXG4gICAgICB8IEludiBwIC0+IGxlbmd0aCBwXG5cbiAgICAoKiogQ3JlYXRlIGEgemlnemFnIGZyb20gYSBwYXRoLiAqKVxuICAgIGxldCByZWMgb2ZfcGF0aCBwID1cbiAgICAgIG1hdGNoIHAgd2l0aFxuICAgICAgfCBQYXRoLkVtcHR5IHQgLT4gSWQgdFxuICAgICAgfCBTdGVwIChwLCBzKSAtPiBjb21wIChvZl9wYXRoIHApIChzdGVwIHMpXG5cbiAgICAoKiogQXBwbHkgYSBjb250ZXh0IGZ1bmN0aW9uIHRvIGEgcGF0aC4gSW4gbmVlZCB0byBoYXZlIHR3byBmdW5jdGlvbiBiZWNhdXNlXG4gICAgICAgIG9mIHR5cGluZyBpc3N1ZXMgKHZhcmlhbmNlIGFuZCBwb2x5bW9ycGhpYyB2YXJpYW50cy4uLiksIGJ1dCB0aGV5IHdpbGxcbiAgICAgICAgYWx3YXlzIGJlIHRoZSBzYW1lIGluIHByYWN0aWNlLiAqKVxuICAgIGxldCByZWMgbWFwIHRtIHJzID0gZnVuY3Rpb25cbiAgICAgIHwgU3RlcCBzIC0+IFN0ZXAgKHJzIHMpXG4gICAgICB8IENvbXAgKHAsIHEpIC0+IENvbXAgKG1hcCB0bSBycyBwLCBtYXAgdG0gcnMgcSlcbiAgICAgIHwgSWQgdCAtPiBJZCAodG0gdClcbiAgICAgIHwgSW52IHAgLT4gSW52IChtYXAgdG0gcnMgcClcblxuICAgICgqKiBBcHBseSBhIHN1YnN0aXR1dGlvbi4gKilcbiAgICBsZXQgcmVjIHN1YnN0IHMgPSBmdW5jdGlvblxuICAgICAgfCBTdGVwIHQgLT4gU3RlcCAoU3RlcC5zdWJzdCBzIHQpXG4gICAgICB8IENvbXAgKHAxLCBwMikgLT4gQ29tcCAoc3Vic3QgcyBwMSwgc3Vic3QgcyBwMilcbiAgICAgIHwgSWQgdCAtPiBJZCAoU3Vic3QuYXBwIHMgdClcbiAgICAgIHwgSW52IHAgLT4gSW52IChzdWJzdCBzIHApXG5cbiAgICAoKiogTnVtYmVyIG9mIG9jY3VyZW5jZXMgb2YgYSBnaXZlbiBydWxlIGluIGEgcGF0aC4gKilcbiAgICBsZXQgcmVjIHJ1bGVfb2NjdXJlbmNlcyByID0gZnVuY3Rpb25cbiAgICAgIHwgU3RlcCBzIC0+IGlmIFN0ZXAuaGFzX3J1bGUgciBzIHRoZW4gMSBlbHNlIDBcbiAgICAgIHwgQ29tcCAocCwgcSkgLT4gcnVsZV9vY2N1cmVuY2VzIHIgcCArIHJ1bGVfb2NjdXJlbmNlcyByIHFcbiAgICAgIHwgSWQgXyAtPiAwXG4gICAgICB8IEludiBwIC0+IHJ1bGVfb2NjdXJlbmNlcyByIHBcblxuICAgICgqKiBOdW1iZXIgb2Ygb2NjdXJlbmNlcyBvZiBhIGdpdmVuIHJ1bGUgaW4gYSBwYXRoLCBjb3VudGVkIG5lZ2F0aXZlbHkgd2hlbiBpbnZlcnRlZC4gKilcbiAgICBsZXQgcmVjIHJ1bGVfYWxnZWJyYWljX29jY3VyZW5jZXMgciA9IGZ1bmN0aW9uXG4gICAgICB8IFN0ZXAgcyAtPiBpZiBTdGVwLmhhc19ydWxlIHIgcyB0aGVuIDEgZWxzZSAwXG4gICAgICB8IENvbXAgKHAsIHEpIC0+IHJ1bGVfYWxnZWJyYWljX29jY3VyZW5jZXMgciBwICsgcnVsZV9hbGdlYnJhaWNfb2NjdXJlbmNlcyByIHFcbiAgICAgIHwgSWQgXyAtPiAwXG4gICAgICB8IEludiBwIC0+IC0gcnVsZV9hbGdlYnJhaWNfb2NjdXJlbmNlcyByIHBcblxuICAgIGxldCBpc19pZCA9IGZ1bmN0aW9uXG4gICAgICB8IElkIF8gLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgaXNfaW52ID0gZnVuY3Rpb25cbiAgICAgIHwgSW52IF8gLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG5cbiAgICAoKiogV2hldGhlciBhIHBhdGggY29udGFpbnMgYSBydWxlLiAqKVxuICAgIGxldCBoYXNfcnVsZSByIHAgPSBydWxlX29jY3VyZW5jZXMgciBwID4gMFxuXG4gICAgKCoqIFB1dCBwYXRoIGluIGNhbm9uaWNhbCBmb3JtLiAqKVxuICAgIGxldCByZWMgY2Fub25pemUgcCA9XG4gICAgICAoKiBQcmludGYucHJpbnRmIFwiY2Fub25pemU6ICVzXFxuJSFcIiAodG9fc3RyaW5nIHApOyAqKVxuICAgICAgbWF0Y2ggcCB3aXRoXG4gICAgICB8IENvbXAgKElkIF8sIHApIC0+IGNhbm9uaXplIHBcbiAgICAgIHwgQ29tcCAocCwgSWQgXykgLT4gY2Fub25pemUgcFxuICAgICAgfCBDb21wIChDb21wIChwLCBxKSwgcikgLT4gY2Fub25pemUgKENvbXAgKHAsIENvbXAgKHEsIHIpKSlcbiAgICAgIHwgQ29tcCAoU3RlcCBzLCBwKSAtPlxuICAgICAgICAoXG4gICAgICAgICAgbWF0Y2ggY2Fub25pemUgcCB3aXRoXG4gICAgICAgICAgfCBJbnYgKFN0ZXAgcycpIHdoZW4gU3RlcC5lcSBzIHMnIC0+IElkIChTdGVwLnNvdXJjZSBzKVxuICAgICAgICAgIHwgQ29tcCAoSW52IChTdGVwIHMnKSwgcCkgd2hlbiBTdGVwLmVxIHMgcycgLT4gcFxuICAgICAgICAgIHwgSWQgXyAtPiBTdGVwIHNcbiAgICAgICAgICB8IHAgLT4gQ29tcCAoU3RlcCBzLCBwKVxuICAgICAgICApXG4gICAgICB8IENvbXAgKEludiAoU3RlcCBzKSwgcCkgLT5cbiAgICAgICAgKFxuICAgICAgICAgIG1hdGNoIGNhbm9uaXplIHAgd2l0aFxuICAgICAgICAgIHwgU3RlcCBzJyB3aGVuIFN0ZXAuZXEgcyBzJyAtPiBJZCAoU3RlcC50YXJnZXQgcycpXG4gICAgICAgICAgfCBDb21wIChTdGVwIHMnLCBwKSB3aGVuIFN0ZXAuZXEgcyBzJyAtPiBwXG4gICAgICAgICAgfCBJZCBfIC0+IEludiAoU3RlcCBzKVxuICAgICAgICAgIHwgcCAtPiBDb21wIChJbnYgKFN0ZXAgcyksIHApXG4gICAgICAgIClcbiAgICAgIHwgQ29tcCAocCwgcSkgLT4gY2Fub25pemUgKENvbXAgKGNhbm9uaXplIHAsIHEpKVxuICAgICAgfCBJbnYgKEludiBwKSAtPiBjYW5vbml6ZSBwXG4gICAgICB8IEludiAoQ29tcCAocCwgcSkpIC0+IGNhbm9uaXplIChDb21wIChJbnYgcSwgSW52IHApKVxuICAgICAgfCBJbnYgKElkIHQpIC0+IElkIHRcbiAgICAgIHwgSW52IChTdGVwIHMpIC0+IEludiAoU3RlcCBzKVxuICAgICAgfCBJZCB0IC0+IElkIHRcbiAgICAgIHwgU3RlcCBzIC0+IFN0ZXAgc1xuXG4gICAgKCoqIEV4cHJlc3MgYSBydWxlIGFzIGEgemlnemFnIGluIGEgY2VsbC4gKilcbiAgICBsZXQgdmFsdWUgciBwID1cbiAgICAgIGxldCBwID0gY2Fub25pemUgcCBpblxuICAgICAgKCogUHJpbnRmLnByaW50ZiBcInZhbHVlIG9mICVzIGluICVzXFxuJSFcIiAoUnVsZS5uYW1lIHIpICh0b19zdHJpbmcgcCk7ICopXG4gICAgICBhc3NlcnQgKHJ1bGVfb2NjdXJlbmNlcyByIHAgPSAxKTtcbiAgICAgIGxldCBwID0gaWYgcnVsZV9hbGdlYnJhaWNfb2NjdXJlbmNlcyByIHAgPSAtIDEgdGhlbiBjYW5vbml6ZSAoaW52IHApIGVsc2UgcCBpblxuICAgICAgbGV0IHJlYyBhdXggcHJlZml4ID0gZnVuY3Rpb25cbiAgICAgICAgfCBDb21wIChTdGVwIChSQXBwIChyJywgcykpLCBwKSB3aGVuIFJ1bGUuZXEgciByJy0+XG4gICAgICAgICAgYXNzZXJ0IChub3QgKGhhc19ydWxlIHIgcCkpO1xuICAgICAgICAgIGFzc2VydCAoU3Vic3QuaXNfcmVuYW1pbmcgcyk7XG4gICAgICAgICAgbGV0IHByZWZpeCA9IGNvbmNhdCAoTGlzdC5yZXYgcHJlZml4KSBpblxuICAgICAgICAgIHN1YnN0IChTdWJzdC5pbnYgcykgKGNvbmNhdCBbaW52IHByZWZpeDsgaW52IHBdKVxuICAgICAgICB8IENvbXAgKFN0ZXAgXyBhcyBzLCBwKSB8IENvbXAgKEludiAoU3RlcCBfKSBhcyBzLCBwKSAtPiBhdXggKHM6OnByZWZpeCkgcFxuICAgICAgICB8IFN0ZXAgXyB8IEludiAoU3RlcCBfKSBhcyBzIC0+IGF1eCBwcmVmaXggKENvbXAgKHMsIElkICh0YXJnZXQgcykpKVxuICAgICAgICB8IElkIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIGluXG4gICAgICBsZXQgdiA9IGNhbm9uaXplIChhdXggW0lkIChzb3VyY2UgcCldIHApIGluXG4gICAgICBhc3NlcnQgKGVxX3Rlcm0gKHNvdXJjZSB2KSAoUnVsZS5zb3VyY2UgcikpO1xuICAgICAgYXNzZXJ0IChlcV90ZXJtICh0YXJnZXQgdikgKFJ1bGUudGFyZ2V0IHIpKTtcbiAgICAgIHZcblxuICAgICgqKiBSZXBsYWNlIGEgcnVsZSBieSBhIHBhdGggaW4gYSBwYXRoLiAqKVxuICAgIGxldCByZWMgcmVwbGFjZV9ydWxlIHIgKHByOnQpIChwOnQpID1cbiAgICAgICgqIFByaW50Zi5wcmludGYgXCJyZXBsYWNlX3J1bGU6ICVzXFxuJSFcIiAodG9fc3RyaW5nIHApOyAqKVxuICAgICAgbGV0IHJlYyByZXBsYWNlX3N0ZXAgdG1fY3R4IHJzX2N0eCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgU3RlcC5UQXBwIChmLCBhMSwgcywgYTIpIC0+XG4gICAgICAgICAgbGV0IHRtX2N0eCB0ID0gdG1fY3R4IChhcHAgZiAoYTFAW3RdQGEyKSkgaW5cbiAgICAgICAgICBsZXQgcnNfY3R4IHMgPSByc19jdHggKFN0ZXAudGFwcCBmIGExIHMgYTIpIGluXG4gICAgICAgICAgcmVwbGFjZV9zdGVwIHRtX2N0eCByc19jdHggc1xuICAgICAgICB8IFJBcHAgKHInLCBzKSB3aGVuIFJ1bGUuZXEgciByJyAtPiBtYXAgdG1fY3R4IHJzX2N0eCAoc3Vic3QgcyBwcilcbiAgICAgICAgfCBSQXBwIChyLCBzKSAtPiBzdGVwIChyc19jdHggKFN0ZXAucmFwcCByIHMpKVxuICAgICAgaW5cbiAgICAgIGxldCByZXBsYWNlX3N0ZXAgPSByZXBsYWNlX3N0ZXAgRnVuLmlkIEZ1bi5pZCBpblxuICAgICAgbWF0Y2ggcCB3aXRoXG4gICAgICB8IFN0ZXAgcyAtPiByZXBsYWNlX3N0ZXAgc1xuICAgICAgfCBDb21wIChwLCBxKSAtPiBjb21wIChyZXBsYWNlX3J1bGUgciBwciBwKSAocmVwbGFjZV9ydWxlIHIgcHIgcSlcbiAgICAgIHwgSWQgdCAtPiBJZCB0XG4gICAgICB8IEludiBwIC0+IEludiAocmVwbGFjZV9ydWxlIHIgcHIgcClcblxuICAgICgqKiBudGggc3RlcCBpbiBhIHBhdGggc3VwcG9zZWQgdG8gYmUgaW4gY2Fub25pY2FsIGZvcm0uICopXG4gICAgbGV0IHJlYyBudGhfc3RlcCBuID0gZnVuY3Rpb25cbiAgICAgIHwgU3RlcCBzIHdoZW4gbiA9IDAgLT4gdHJ1ZSwgc1xuICAgICAgfCBJbnYgKFN0ZXAgcykgd2hlbiBuID0gMCAtPiBmYWxzZSwgc1xuICAgICAgfCBDb21wIChTdGVwIHMsIHApIC0+IGlmIG4gPSAwIHRoZW4gdHJ1ZSwgcyBlbHNlIG50aF9zdGVwIChuLTEpIHBcbiAgICAgIHwgQ29tcCAoSW52IChTdGVwIHMpLCBwKSAtPiBpZiBuID0gMCB0aGVuIGZhbHNlLCBzIGVsc2UgbnRoX3N0ZXAgKG4tMSkgcFxuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICAgKCoqIG50aCB0ZXJtIGluIGEgcGF0aCBzdXBwb3NlZCB0byBiZSBpbiBjYW5vbmljYWwgZm9ybS4gKilcbiAgICBsZXQgcmVjIG50aF90ZXJtIG4gPSBmdW5jdGlvblxuICAgICAgfCBTdGVwIF8gfCBJbnYgKFN0ZXAgXykgYXMgcCAtPlxuICAgICAgICBpZiBuID0gMCB0aGVuIHNvdXJjZSBwXG4gICAgICAgIGVsc2UgaWYgbiA9IDEgdGhlbiB0YXJnZXQgcFxuICAgICAgICBlbHNlIGFzc2VydCBmYWxzZVxuICAgICAgfCBDb21wIChTdGVwIF8gYXMgcCwgcSkgfCBDb21wIChJbnYgKFN0ZXAgXykgYXMgcCwgcSkgLT5cbiAgICAgICAgaWYgbiA9IDAgdGhlbiBzb3VyY2UgcCBlbHNlIG50aF90ZXJtIChuLTEpIHFcbiAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAgICgqKiBMaXN0Lm9mX3N0ZXBzIGluIGEgcGF0aC4gKilcbiAgICBsZXQgcmVjIHRvX2xpc3QgPSBmdW5jdGlvblxuICAgICAgfCBTdGVwIHMgLT4gW1N0ZXAgc11cbiAgICAgIHwgQ29tcCAocCwgcSkgLT4gKHRvX2xpc3QgcClAKHRvX2xpc3QgcSlcbiAgICAgIHwgSWQgXyAtPiBbXVxuICAgICAgfCBJbnYgcCAtPiBMaXN0Lm1hcCAoZnVuIHAgLT4gSW52IHApIChMaXN0LnJldiAodG9fbGlzdCBwKSlcblxuICAgIGxldCBwYXJzZSBycyBzID1cbiAgICAgIGxldCB1bmlkID0gZnVuY3Rpb25cbiAgICAgICAgfCBJZCB0IC0+IHRcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgaW5cbiAgICAgIGxldCByZWMgYXV4ID0gZnVuY3Rpb25cbiAgICAgICAgfCBgQXBwIChmLCBhKSAtPlxuICAgICAgICAgIChcbiAgICAgICAgICAgIGxldCBhID0gTGlzdC5tYXAgYXV4IGEgaW5cbiAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAoKiBQcmludGYucHJpbnRmIFwib3A6ICVzXFxuJSFcIiBmOyAqKVxuICAgICAgICAgICAgICBsZXQgZiA9IExpc3QuZmluZCAoZnVuIG8gLT4gT3AubmFtZSBvID0gZikgKG9wZXJhdGlvbnMgcnMpIGluXG4gICAgICAgICAgICAgICgqIExpc3QuaXRlciAoZnVuIHAgLT4gUHJpbnRmLnByaW50ZiBcIiVzXFxuJSFcIiAodG9fc3RyaW5nIHApKSBhOyAqKVxuICAgICAgICAgICAgICBpZiBMaXN0LmZvcl9hbGwgaXNfaWQgYSB0aGVuXG4gICAgICAgICAgICAgICAgbGV0IGEgPSBMaXN0Lm1hcCB1bmlkIGEgaW5cbiAgICAgICAgICAgICAgICBsZXQgdCA9IGFwcCBmIGEgaW5cbiAgICAgICAgICAgICAgICBJZCB0XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsZXQgbiA9IHRyeSBMaXN0LmluZGV4IChmdW4gcCAtPiBub3QgKGlzX2lkIHApKSBhIHdpdGggTm90X2ZvdW5kIC0+IGFzc2VydCBmYWxzZSBpblxuICAgICAgICAgICAgICAgIGxldCB0ID0gTGlzdC5udGggYSBuIGluXG4gICAgICAgICAgICAgICAgbGV0IGExLCBhMiA9IGxpc3RfcmVtb3ZlX250aCBuIGEgaW5cbiAgICAgICAgICAgICAgICBsZXQgYTEgPSBMaXN0Lm1hcCB1bmlkIGExIGluXG4gICAgICAgICAgICAgICAgbGV0IGEyID0gTGlzdC5tYXAgdW5pZCBhMiBpblxuICAgICAgICAgICAgICAgIGxldCB0bV9jdHggdCA9IGFwcCBmIChhMUBbdF1AYTIpIGluXG4gICAgICAgICAgICAgICAgbGV0IHJzX2N0eCB0ID0gU3RlcC50YXBwIGYgYTEgdCBhMiBpblxuICAgICAgICAgICAgICAgIG1hcCB0bV9jdHggcnNfY3R4IHRcbiAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgIHwgTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICAgIGxldCByID0gZmluZCBycyBmIGluXG4gICAgICAgICAgICAgIGxldCBhID0gTGlzdC5tYXAgdW5pZCBhIGluXG4gICAgICAgICAgICAgIGxldCBzID0gTGlzdC5tYXAyIHBhaXIgKFJ1bGUudmFycyByKSBhIGluXG4gICAgICAgICAgICAgIFN0ZXAgKFN0ZXAucmFwcCByIHMpXG4gICAgICAgICAgKVxuICAgICAgICB8IGBJbnYgcCAtPiBpbnYgKGF1eCBwKVxuICAgICAgICB8IGBTZXEgbCAtPiBjb25jYXQgKExpc3QubWFwIGF1eCBsKVxuICAgICAgICB8IGBWYXIgeCAtPlxuICAgICAgICAgIGxldCB4ID0gcGFyc2VfdmFyIHggaW5cbiAgICAgICAgICBJZCAoVmFyIHgpXG4gICAgICBpblxuICAgICAgYXV4IChwYXJzZXIgcylcbiAgZW5kXG5cbiAgKCoqIExvb3BzLiAqKVxuICBtb2R1bGUgTG9vcCA9IHN0cnVjdFxuICAgICgqKiBBIChwb2ludGVkKSBsb29wLiAqKVxuICAgIHR5cGUgdCA9IFppZ3phZy50XG5cbiAgICBsZXQgbWFrZSAocDpaaWd6YWcudCkgOiB0ID1cbiAgICAgIGFzc2VydCAoZXFfdGVybSAoWmlnemFnLnNvdXJjZSBwKSAoWmlnemFnLnRhcmdldCBwKSk7XG4gICAgICBwXG5cbiAgICBsZXQgdG9fc3RyaW5nID0gWmlnemFnLnRvX3N0cmluZ1xuXG4gICAgbGV0IGNvbXAgPSBaaWd6YWcuY29tcFxuXG4gICAgbGV0IGludiA9IFppZ3phZy5pbnZcblxuICAgIGxldCBvZl9jZWxsIHAxIHAyID1cbiAgICAgIGFzc2VydCAoZXFfdGVybSAoWmlnemFnLnNvdXJjZSBwMSkgKFppZ3phZy5zb3VyY2UgcDIpKTtcbiAgICAgIGFzc2VydCAoZXFfdGVybSAoWmlnemFnLnRhcmdldCBwMSkgKFppZ3phZy50YXJnZXQgcDIpKTtcbiAgICAgIGNvbXAgcDEgKGludiBwMilcblxuICAgIGxldCBjYW5vbml6ZSA9IFppZ3phZy5jYW5vbml6ZVxuXG4gICAgbGV0IHZhbHVlID0gWmlnemFnLnZhbHVlXG5cbiAgICBsZXQgcmVwbGFjZV9ydWxlID0gWmlnemFnLnJlcGxhY2VfcnVsZVxuXG4gICAgbGV0IGxlbmd0aCA9IFppZ3phZy5sZW5ndGhcblxuICAgIGxldCByb3RhdGUgayBwID1cbiAgICAgIGxldCBuID0gbGVuZ3RoIHAgaW5cbiAgICAgIGxldCBrID0gSW50Lm1vZHVsbyBrIG4gaW5cbiAgICAgIGxldCBsID0gWmlnemFnLnRvX2xpc3QgcCBpblxuICAgICAgbGV0IGwxID0gTGlzdC5zdWIgbCAwIGsgaW5cbiAgICAgIGxldCBsMiA9IExpc3Quc3ViIGwgayAobi1rKSBpblxuICAgICAgbGV0IGwxID0gWmlnemFnLmNvbmNhdCBsMSBpblxuICAgICAgbGV0IGwyID0gWmlnemFnLmNvbmNhdCBsMiBpblxuICAgICAgWmlnemFnLmNvbXAgbDIgbDFcbiAgZW5kXG5cbiAgKCoqIENvaGVyZW5jZSBjZWxscy4gKilcbiAgbW9kdWxlIENvaGVyZW5jZSA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB7XG4gICAgICAgIG5hbWUgOiBzdHJpbmc7XG4gICAgICAgIGxvb3AgOiBMb29wLnQ7XG4gICAgICB9XG5cbiAgICBsZXQgbmFtZSBjID0gYy5uYW1lXG5cbiAgICBsZXQgbG9vcCBjID0gYy5sb29wXG5cbiAgICBsZXQgbWFrZSBuYW1lIGxvb3AgPVxuICAgICAgeyBuYW1lOyBsb29wIH1cblxuICAgIGxldCB0b19zdHJpbmcgfnZhciBjID1cbiAgICAgIGxldCBwID0gTG9vcC5jYW5vbml6ZSAobG9vcCBjKSBpblxuICAgICAgUHJpbnRmLnNwcmludGYgXCIlczogJXNcXG5cIiAobmFtZSBjKSAoTG9vcC50b19zdHJpbmcgfnZhciBwKVxuXG4gICAgbGV0IHJvdGF0ZSBuIGMgPVxuICAgICAgeyBjIHdpdGggbG9vcCA9IExvb3Aucm90YXRlIG4gKGxvb3AgYykgfVxuXG4gICAgbGV0IHZhbHVlIHIgYyA9XG4gICAgICBMb29wLnZhbHVlIHIgKGxvb3AgYylcblxuICAgIGxldCByZXBsYWNlX3J1bGUgciB2IGMgPVxuICAgICAgeyBjIHdpdGggbG9vcCA9IExvb3AucmVwbGFjZV9ydWxlIHIgdiAobG9vcCBjKSB9XG5cbiAgICBtb2R1bGUgUGF0aCA9IHN0cnVjdFxuICAgIGVuZFxuICBlbmRcblxuICAoKiogQ29oZXJlbnQgcHJlc2VudGF0aW9ucy4gKilcbiAgbW9kdWxlIENvaGVyZW50ID0gc3RydWN0XG4gICAgKCoqIEEgY29oZXJlbnQgcHJlc2VudGF0aW9uLiAqKVxuICAgIHR5cGUgdCA9XG4gICAgICB7XG4gICAgICAgIHJzIDogcnM7XG4gICAgICAgIGNvaGVyZW5jZSA6IENvaGVyZW5jZS50IGxpc3Q7XG4gICAgICB9XG5cbiAgICB0eXBlIGNycyA9IHRcblxuICAgICgqKiBVbmRlcmx5aW5nIHJld3JpdGluZyBzeXN0ZW0uICopXG4gICAgbGV0IHJzIGNycyA9IGNycy5yc1xuXG4gICAgbGV0IHJ1bGVzIGNycyA9IHJ1bGVzIChycyBjcnMpXG5cbiAgICBsZXQgY29oZXJlbmNlIGNycyA9IGNycy5jb2hlcmVuY2VcblxuICAgIGxldCBzZXRfcnVsZXMgY3JzIHJ1bGVzID0geyBjcnMgd2l0aCBycyA9IHsgY3JzLnJzIHdpdGggcnVsZXMgfSB9XG5cbiAgICBsZXQgdG9fc3RyaW5nID8odmFyPVZhci5uYW1lcikgY3JzID1cbiAgICAgIGxldCBjb2hlcmVuY2UgPVxuICAgICAgICBMaXN0Lm1hcFxuICAgICAgICAgIChmdW4gYyAtPlxuICAgICAgICAgICAgIENvaGVyZW5jZS50b19zdHJpbmcgfnZhcjoodmFyICgpKSBjXG4gICAgICAgICAgKSBjcnMuY29oZXJlbmNlXG4gICAgICBpblxuICAgICAgbGV0IGNvaGVyZW5jZSA9IFN0cmluZy5jb25jYXQgXCJcXG5cIiBjb2hlcmVuY2UgaW5cbiAgICAgIGNvaGVyZW5jZVxuXG4gICAgbGV0IHRvX3RleCA/KHZhcj1WYXIubmFtZXJfbmF0dXJhbCkgY3JzID1cbiAgICAgIGxldCBhbnMgPSByZWYgXCJcIiBpblxuICAgICAgbGV0IHByaW50IHMgPSBQcmludGYua3NwcmludGYgKGZ1biBzIC0+IGFucyA6PSAhYW5zIF4gcykgczsgaW5cbiAgICAgIHByaW50IFwiXFxcXGRvY3VtZW50Y2xhc3NbYTRwYXBlciw5cHRde2V4dGFydGljbGV9XFxuXFxcbiAgICAgICAgICAgICBcXFxcdXNlcGFja2FnZVt1dGY4eF17aW5wdXRlbmN9XFxuXFxcbiAgICAgICAgICAgICBcXFxcdXNlcGFja2FnZXthbXNtYXRofVxcblxcXG4gICAgICAgICAgICAgXFxcXHVzZXBhY2thZ2V7dGlrei1jZH1cXG5cXFxuICAgICAgICAgICAgIFxcXFx1c2VwYWNrYWdlW21hcmdpbj0xY20saW5jbHVkZWZvb3Rde2dlb21ldHJ5fVxcblxcXG4gICAgICAgICAgICAgXFxcXHRpdGxle0NvaGVyZW50IHByZXNlbnRhdGlvbn1cXG5cXFxuICAgICAgICAgICAgIFxcXFxhdXRob3J7b2NhbWwtYWxnfVxcblxcblxcXG4gICAgICAgICAgICAgXFxcXGJlZ2lue2RvY3VtZW50fVxcblxcXG4gICAgICAgICAgICAgXFxcXG1ha2V0aXRsZVxcblxcblwiO1xuICAgICAgbGV0IHJ1bGVzID1cbiAgICAgICAgTGlzdC5tYXBcbiAgICAgICAgICAoZnVuIHIgLT5cbiAgICAgICAgICAgICBsZXQgdmFyID0gdmFyICgpIGluXG4gICAgICAgICAgICAgbGV0IHMgPSBzdHJpbmdfb2ZfdGVybSB+dmFyIChSdWxlLnNvdXJjZSByKSBpblxuICAgICAgICAgICAgIGxldCB0ID0gc3RyaW5nX29mX3Rlcm0gfnZhciAoUnVsZS50YXJnZXQgcikgaW5cbiAgICAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIiVzICY6ICVzIFxcXFx0byAlc1xcXFxcXFxcXCIgKFJ1bGUubmFtZSByKSBzIHRcbiAgICAgICAgICApIChydWxlcyBjcnMpXG4gICAgICBpblxuICAgICAgbGV0IHJ1bGVzID0gU3RyaW5nLmNvbmNhdCBcIlxcblwiIHJ1bGVzIGluXG4gICAgICBwcmludCBcIlxcXFxzZWN0aW9ue1J1bGVzfVxcblxcXG4gICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICBcXFxcYmVnaW57YWxpZ24qfVxcblxcXG4gICAgICAgICAgICAgJXNcXG5cXFxuICAgICAgICAgICAgIFxcXFxlbmR7YWxpZ24qfVxcblxcXG4gICAgICAgICAgICAgXFxuXCIgcnVsZXM7XG4gICAgICBwcmludCBcIlxcXFxzZWN0aW9ue0NvaGVyZW5jZX1cXG5cXG5cIjtcbiAgICAgIExpc3QuaXRlclxuICAgICAgICAoZnVuIGMgLT5cbiAgICAgICAgICAgbGV0IHAgPSBMb29wLmNhbm9uaXplIChDb2hlcmVuY2UubG9vcCBjKSBpblxuICAgICAgICAgICBQcmludGYucHJpbnRmIFwicHJpbnQgJXM6ICVzXFxuJSFcIiAoQ29oZXJlbmNlLm5hbWUgYykgKExvb3AudG9fc3RyaW5nIHApO1xuICAgICAgICAgICBsZXQgcDEsIHAyID1cbiAgICAgICAgICAgICBsZXQgbCA9IFppZ3phZy50b19saXN0IHAgaW5cbiAgICAgICAgICAgICBpZiBsIDw+IFtdIHRoZW4gaWdub3JlIChaaWd6YWcuY29uY2F0IGwpOyAoKiB0ZXN0ICopXG4gICAgICAgICAgICAgbGV0IG4gPSBMaXN0Lmxlbmd0aCBsIGluXG4gICAgICAgICAgICAgaWYgbiA9IDAgdGhlbiBwLCBwIGVsc2VcbiAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgICAoKiBUcnkgdG8gc3BsaXQgZm9yd2FyZCAvIGJhY2t3YXJkLiAqKVxuICAgICAgICAgICAgICAgICBsZXQgayA9IExpc3QuaW5kZXggWmlnemFnLmlzX2ludiBsIGluXG4gICAgICAgICAgICAgICAgIGlmIGsgPSAwIHRoZW4gcmFpc2UgRXhpdDtcbiAgICAgICAgICAgICAgICAgbGV0IGwxID0gTGlzdC5zdWIgbCAwIGsgaW5cbiAgICAgICAgICAgICAgICAgbGV0IGwyID0gTGlzdC5zdWIgbCBrIChuLWspIGluXG4gICAgICAgICAgICAgICAgIGlmIG5vdCAoTGlzdC5mb3JfYWxsIFppZ3phZy5pc19pbnYgbDIpIHRoZW4gcmFpc2UgRXhpdDtcbiAgICAgICAgICAgICAgICAgbGV0IHAxID0gWmlnemFnLmNvbmNhdCBsMSBpblxuICAgICAgICAgICAgICAgICBsZXQgcDIgPSBaaWd6YWcuY2Fub25pemUgKFppZ3phZy5pbnYgKFppZ3phZy5jb25jYXQgbDIpKSBpblxuICAgICAgICAgICAgICAgICBsZXQgcDEsIHAyID1cbiAgICAgICAgICAgICAgICAgICBpZiBMaXN0Lmxlbmd0aCBsMSA+IExpc3QubGVuZ3RoIGwyIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgIHAyLCBwMVxuICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgIHAxLCBwMlxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICBaaWd6YWcuY2Fub25pemUgcDEsIFppZ3phZy5jYW5vbml6ZSBwMlxuICAgICAgICAgICAgICAgd2l0aFxuICAgICAgICAgICAgICAgfCBFeGl0IHwgTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICAgICAgICgqIEJ5IGRlZmF1bHQsIHNwbGl0IGluIGsvayBvciBrL2srMS4gKilcbiAgICAgICAgICAgICAgICAgbGV0IGwxID0gTGlzdC5zdWIgbCAwIChuLzIpIGluXG4gICAgICAgICAgICAgICAgIGxldCBsMiA9IExpc3Quc3ViIGwgKG4vMikgKG4tbi8yKSBpblxuICAgICAgICAgICAgICAgICBaaWd6YWcuY29uY2F0IGwxLCBaaWd6YWcuY2Fub25pemUgKFppZ3phZy5pbnYgKFppZ3phZy5jb25jYXQgbDIpKVxuICAgICAgICAgICBpblxuICAgICAgICAgICBQcmludGYucHJpbnRmIFwic3BsaXQ6ICVzIC8gJXNcXG4lIVwiIChaaWd6YWcudG9fc3RyaW5nIHAxKSAoWmlnemFnLnRvX3N0cmluZyBwMik7XG4gICAgICAgICAgIGxldCB2YXIgPSB2YXIgKCkgaW5cbiAgICAgICAgICAgbGV0IHN0IG4gcCA9XG4gICAgICAgICAgICAgbGV0IGQsIHMgPSBaaWd6YWcubnRoX3N0ZXAgbiBwIGluXG4gICAgICAgICAgICAgbGV0IGQgPSBpZiBkIHRoZW4gXCJcIiBlbHNlIFwiPC0sXCIgaW5cbiAgICAgICAgICAgICBsZXQgcyA9IFN0ZXAubGFiZWwgfnZhciBzIGluXG4gICAgICAgICAgICAgZCBeIFwiXFxcIntcIiBeIHMgXiBcIn1cXFwiXCJcbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgbGV0IHRtIG4gcCA9IHN0cmluZ19vZl90ZXJtIH52YXIgKFppZ3phZy5udGhfdGVybSBuIHApIGluXG4gICAgICAgICAgIGxldCBjZCAoKSA9XG4gICAgICAgICAgICAgbWF0Y2ggWmlnemFnLmxlbmd0aCBwMSwgWmlnemFnLmxlbmd0aCBwMiB3aXRoXG4gICAgICAgICAgICAgfCAxLCAxIC0+XG4gICAgICAgICAgICAgICBwcmludCBcIiVzXFxcXGFyW2QsYmVuZCByaWdodCwlcyddXFxcXGFyW2QsYmVuZCBsZWZ0LCVzXVxcXFxcXFxcXFxuJXNcIlxuICAgICAgICAgICAgICAgICAodG0gMCBwMSkgKHN0IDAgcDEpIChzdCAwIHAyKSAodG0gMSBwMSlcbiAgICAgICAgICAgICB8IDEsIDIgLT5cbiAgICAgICAgICAgICAgIHByaW50IFwiJXNcXFxcYXJbZHIsJXMnXVxcXFxhcltyLCVzXSYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuJiVzXCJcbiAgICAgICAgICAgICAgICAgKHRtIDAgcDEpIChzdCAwIHAxKSAoc3QgMCBwMikgKHRtIDEgcDIpIChzdCAxIHAyKSAodG0gMiBwMilcbiAgICAgICAgICAgICB8IDEsIDMgLT5cbiAgICAgICAgICAgICAgIHByaW50IFwiJXNcXFxcYXJbZHJyLCVzJ11cXFxcYXJbciwlc10mJXNcXFxcYXJbciwlc10mJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcbiYmJXNcIlxuICAgICAgICAgICAgICAgICAodG0gMCBwMSkgKHN0IDAgcDEpIChzdCAwIHAyKSAodG0gMSBwMikgKHN0IDEgcDIpICh0bSAyIHAyKSAoc3QgMiBwMikgKHRtIDMgcDIpXG4gICAgICAgICAgICAgfCAxLCA0IC0+XG4gICAgICAgICAgICAgICBwcmludCBcIiVzXFxcXGFyW2RkcnIsJXMnXVxcXFxhcltyLCVzXSYlc1xcXFxhcltyLCVzXSYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuJiYlc1wiXG4gICAgICAgICAgICAgICAgICh0bSAwIHAxKSAoc3QgMCBwMSkgKHN0IDAgcDIpICh0bSAxIHAyKSAoc3QgMSBwMikgKHRtIDIgcDIpIChzdCAyIHAyKSAodG0gMyBwMikgKHN0IDMgcDIpICh0bSA0IHAyKVxuICAgICAgICAgICAgIHwgMSwgNSAtPlxuICAgICAgICAgICAgICAgcHJpbnQgXCIlc1xcXFxhcltkZGRyciwlcyddXFxcXGFyW3IsJXNdJiVzXFxcXGFyW3IsJXNdJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG4mJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG4mJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG4mJiVzXCJcbiAgICAgICAgICAgICAgICAgKHRtIDAgcDEpIChzdCAwIHAxKSAoc3QgMCBwMikgKHRtIDEgcDIpIChzdCAxIHAyKSAodG0gMiBwMikgKHN0IDIgcDIpICh0bSAzIHAyKSAoc3QgMyBwMikgKHRtIDQgcDIpIChzdCA0IHAyKSAodG0gNSBwMilcbiAgICAgICAgICAgICB8IDEsIDYgLT5cbiAgICAgICAgICAgICAgIHByaW50IFwiJXNcXFxcYXJbZGRkZHJyLCVzJ11cXFxcYXJbciwlc10mJXNcXFxcYXJbciwlc10mJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcbiYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcbiYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcbiYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcbiYmJXNcIlxuICAgICAgICAgICAgICAgICAodG0gMCBwMSkgKHN0IDAgcDEpIChzdCAwIHAyKSAodG0gMSBwMikgKHN0IDEgcDIpICh0bSAyIHAyKSAoc3QgMiBwMikgKHRtIDMgcDIpIChzdCAzIHAyKSAodG0gNCBwMikgKHN0IDQgcDIpICh0bSA1IHAyKSAoc3QgNSBwMikgKHRtIDYgcDIpXG4gICAgICAgICAgICAgfCAyLCAyIC0+XG4gICAgICAgICAgICAgICBwcmludCBcIiVzXFxcXGFyW2QsJXMnXVxcXFxhcltyLCVzXSYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuJXNcXFxcYXJbciwlcyddJiVzXCJcbiAgICAgICAgICAgICAgICAgKHRtIDAgcDEpIChzdCAwIHAxKSAoc3QgMCBwMikgKHRtIDEgcDIpIChzdCAxIHAyKSAodG0gMSBwMSkgKHN0IDEgcDEpICh0bSAyIHAxKVxuICAgICAgICAgICAgIHwgMiwgMyAtPlxuICAgICAgICAgICAgICAgcHJpbnQgXCIlc1xcXFxhcltkLCVzJ11cXFxcYXJbciwlc10mJXNcXFxcYXJbciwlc10mJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcbiVzXFxcXGFyW3JyLCVzJ10mJiVzXCJcbiAgICAgICAgICAgICAgICAgKHRtIDAgcDEpIChzdCAwIHAxKSAoc3QgMCBwMikgKHRtIDEgcDIpIChzdCAxIHAyKSAodG0gMiBwMikgKHN0IDIgcDIpICh0bSAxIHAxKSAoc3QgMSBwMSkgKHRtIDIgcDEpXG4gICAgICAgICAgICAgfCAyLCA0IC0+XG4gICAgICAgICAgICAgICBwcmludCBcIiVzXFxcXGFyW2QsJXMnXVxcXFxhcltyLCVzXSYlc1xcXFxhcltyLCVzXSYlc1xcXFxhcltyLCVzXSYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuJXNcXFxcYXJbcnJyLCVzJ10mJiYlc1wiXG4gICAgICAgICAgICAgICAgICh0bSAwIHAxKSAoc3QgMCBwMSkgKHN0IDAgcDIpICh0bSAxIHAyKSAoc3QgMSBwMikgKHRtIDIgcDIpIChzdCAyIHAyKSAodG0gMyBwMikgKHN0IDMgcDIpICh0bSAxIHAxKSAoc3QgMSBwMSkgKHRtIDIgcDEpXG4gICAgICAgICAgICAgKCpcbiAgICAgICAgICAgICB8IDMsIDMgLT5cbiAgICAgICAgICAgICAgIHByaW50IFwiJXNcXFxcYXJbZCwlcyddXFxcXGFyW3IsJXNdJiVzXFxcXGFyW3IsJXNdJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICVzXFxcXGFyW3IsJXMnXSYlc1xcXFxhcltyLCVzJ10mJXNcIlxuICAgICAgICAgICAgICAgICAodG0gMCBwMSkgKHN0IDAgcDEpIChzdCAwIHAyKSAodG0gMSBwMikgKHN0IDEgcDIpICh0bSAyIHAyKSAoc3QgMiBwMikgKHRtIDEgcDEpIChzdCAxIHAxKSAodG0gMiBwMSkgKHN0IDIgcDEpICh0bSAzIHAxKVxuICAgICAgICAgICAgIHwgMywgNCAtPlxuICAgICAgICAgICAgICAgcHJpbnQgXCIlc1xcXFxhcltkZCwlcyddXFxcXGFyW3IsJXNdJiVzXFxcXGFyW3IsJXNdJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJXNcXFxcYXJbciwlcyddJiVzXFxcXGFyW3IsJXMnXSYlc1wiXG4gICAgICAgICAgICAgICAgICh0bSAwIHAxKSAoc3QgMCBwMSkgKHN0IDAgcDIpICh0bSAxIHAyKSAoc3QgMSBwMikgKHRtIDIgcDIpIChzdCAyIHAyKSAodG0gMyBwMikgKHN0IDMgcDIpICh0bSAxIHAxKSAoc3QgMSBwMSkgKHRtIDIgcDEpIChzdCAyIHAxKSAodG0gMyBwMSlcbiAgICAgICAgICAgICAqKVxuICAgICAgICAgICAgIHwgMywgNSAtPlxuICAgICAgICAgICAgICAgcHJpbnQgXCIlc1xcXFxhcltkZGQsJXMnXVxcXFxhcltyLCVzXSYlc1xcXFxhcltyLCVzXSYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJXNcXFxcYXJbciwlcyddJiVzXFxcXGFyW3IsJXMnXSYlc1wiXG4gICAgICAgICAgICAgICAgICh0bSAwIHAxKSAoc3QgMCBwMSkgKHN0IDAgcDIpICh0bSAxIHAyKSAoc3QgMSBwMikgKHRtIDIgcDIpIChzdCAyIHAyKSAodG0gMyBwMikgKHN0IDMgcDIpICh0bSA0IHAyKSAoc3QgNCBwMikgKHRtIDEgcDEpIChzdCAxIHAxKSAodG0gMiBwMSkgKHN0IDIgcDEpICh0bSAzIHAxKVxuICAgICAgICAgICAgIHwgMywgOCAtPlxuICAgICAgICAgICAgICAgcHJpbnQgXCIlc1xcXFxhcltkZGRkZGQsJXMnXVxcXFxhcltyLCVzXSYlc1xcXFxhcltyLCVzXSYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJXNcXFxcYXJbciwlcyddJiVzXFxcXGFyW3IsJXMnXSYlc1wiXG4gICAgICAgICAgICAgICAgICh0bSAwIHAxKSAoc3QgMCBwMSkgKHN0IDAgcDIpICh0bSAxIHAyKSAoc3QgMSBwMikgKHRtIDIgcDIpIChzdCAyIHAyKSAodG0gMyBwMikgKHN0IDMgcDIpICh0bSA0IHAyKSAoc3QgNCBwMikgKHRtIDUgcDIpIChzdCA1IHAyKSAodG0gNiBwMikgKHN0IDYgcDIpICh0bSA3IHAyKSAoc3QgNyBwMikgKHRtIDEgcDEpIChzdCAxIHAxKSAodG0gMiBwMSkgKHN0IDIgcDEpICh0bSAzIHAxKVxuICAgICAgICAgICAgIHwgMywgOSAtPlxuICAgICAgICAgICAgICAgcHJpbnQgXCIlc1xcXFxhcltkZGRkZGRkLCVzJ11cXFxcYXJbciwlc10mJXNcXFxcYXJbciwlc10mJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJXNcXFxcYXJbciwlcyddJiVzXFxcXGFyW3IsJXMnXSYlc1wiXG4gICAgICAgICAgICAgICAgICh0bSAwIHAxKSAoc3QgMCBwMSkgKHN0IDAgcDIpICh0bSAxIHAyKSAoc3QgMSBwMikgKHRtIDIgcDIpIChzdCAyIHAyKSAodG0gMyBwMikgKHN0IDMgcDIpICh0bSA0IHAyKSAoc3QgNCBwMikgKHRtIDUgcDIpIChzdCA1IHAyKSAodG0gNiBwMikgKHN0IDYgcDIpICh0bSA3IHAyKSAoc3QgNyBwMikgKHRtIDggcDIpIChzdCA4IHAyKSAodG0gMSBwMSkgKHN0IDEgcDEpICh0bSAyIHAxKSAoc3QgMiBwMSkgKHRtIDMgcDEpXG4gICAgICAgICAgICAgfCAzLCAxMCAtPlxuICAgICAgICAgICAgICAgcHJpbnQgXCIlc1xcXFxhcltkZGRkZGRkZCwlcyddXFxcXGFyW3IsJXNdJiVzXFxcXGFyW3IsJXNdJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJXNcXFxcYXJbciwlcyddJiVzXFxcXGFyW3IsJXMnXSYlc1wiXG4gICAgICAgICAgICAgICAgICh0bSAwIHAxKSAoc3QgMCBwMSkgKHN0IDAgcDIpICh0bSAxIHAyKSAoc3QgMSBwMikgKHRtIDIgcDIpIChzdCAyIHAyKSAodG0gMyBwMikgKHN0IDMgcDIpICh0bSA0IHAyKSAoc3QgNCBwMikgKHRtIDUgcDIpIChzdCA1IHAyKSAodG0gNiBwMikgKHN0IDYgcDIpICh0bSA3IHAyKSAoc3QgNyBwMikgKHRtIDggcDIpIChzdCA4IHAyKSAodG0gOSBwMikgKHN0IDkgcDIpICh0bSAxIHAxKSAoc3QgMSBwMSkgKHRtIDIgcDEpIChzdCAyIHAxKSAodG0gMyBwMSlcbiAgICAgICAgICAgICAoKlxuICAgICAgICAgICAgIHwgNSwgNiAtPlxuICAgICAgICAgICAgICAgcHJpbnQgXCIlc1xcXFxhcltkLCVzJ11cXFxcYXJbciwlc10mJXNcXFxcYXJbciwlc10mJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJXNcXFxcYXJbZCwlcyddJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlc1xcXFxhcltkLCVzJ10mJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICVzXFxcXGFyW2QsJXMnXSYmJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJXNcXFxcYXJbcnIsJXMnXSYmJXNcIlxuICAgICAgICAgICAgICAgICAodG0gMCBwMSkgKHN0IDAgcDEpIChzdCAwIHAyKSAodG0gMSBwMikgKHN0IDEgcDIpICh0bSAyIHAyKSAoc3QgMiBwMilcbiAgICAgICAgICAgICAgICAgKHRtIDEgcDEpIChzdCAxIHAxKSAodG0gMyBwMikgKHN0IDMgcDIpXG4gICAgICAgICAgICAgICAgICh0bSAyIHAxKSAoc3QgMiBwMSkgKHRtIDQgcDIpIChzdCA0IHAyKVxuICAgICAgICAgICAgICAgICAodG0gMyBwMSkgKHN0IDMgcDEpICh0bSA1IHAyKSAoc3QgNSBwMilcbiAgICAgICAgICAgICAgICAgKHRtIDQgcDEpIChzdCA0IHAxKSAodG0gNiBwMilcbiAgICAgICAgICAgICAqKVxuICAgICAgICAgICAgIHwgbDEsIGwyIHdoZW4gbDEgPj0gMiAmJiBsMiA9IGwxICsgMSAtPlxuICAgICAgICAgICAgICAgcHJpbnQgXCIlc1xcXFxhcltkLCVzJ11cXFxcYXJbciwlc10mJXNcXFxcYXJbciwlc10mJXNcXFxcYXJbZCwlc11cXFxcXFxcXFxcblwiICh0bSAwIHAxKSAoc3QgMCBwMSkgKHN0IDAgcDIpICh0bSAxIHAyKSAoc3QgMSBwMikgKHRtIDIgcDIpIChzdCAyIHAyKTtcbiAgICAgICAgICAgICAgIGZvciBpID0gMSB0byBsMSAtIDIgZG9cbiAgICAgICAgICAgICAgICAgcHJpbnQgXCIlc1xcXFxhcltkLCVzJ10mJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cIiAodG0gaSBwMSkgKHN0IGkgcDEpICh0bSAoaSsyKSBwMikgKHN0IChpKzIpIHAyKVxuICAgICAgICAgICAgICAgZG9uZTtcbiAgICAgICAgICAgICAgIGxldCBpID0gbDEgLSAxIGluXG4gICAgICAgICAgICAgICBwcmludCBcIiVzXFxcXGFyW3JyLCVzJ10mJiVzXCIgKHRtIGkgcDEpIChzdCBpIHAxKSAodG0gKGkrMikgcDIpXG4gICAgICAgICAgICAgfCBsMSwgbDIgd2hlbiBsMSA+PSAzICYmIGwyID0gbDEgLT5cbiAgICAgICAgICAgICAgIHByaW50IFwiJXNcXFxcYXJbZCwlcyddXFxcXGFyW3IsJXNdJiVzXFxcXGFyW3IsJXNdJiVzXFxcXGFyW2QsJXNdXFxcXFxcXFxcXG5cIiAodG0gMCBwMSkgKHN0IDAgcDEpIChzdCAwIHAyKSAodG0gMSBwMikgKHN0IDEgcDIpICh0bSAyIHAyKSAoc3QgMiBwMik7XG4gICAgICAgICAgICAgICBmb3IgaSA9IDEgdG8gbDEgLSAzIGRvXG4gICAgICAgICAgICAgICAgIHByaW50IFwiJXNcXFxcYXJbZCwlcyddJiYlc1xcXFxhcltkLCVzXVxcXFxcXFxcXFxuXCIgKHRtIGkgcDEpIChzdCBpIHAxKSAodG0gKGkrMikgcDIpIChzdCAoaSsyKSBwMilcbiAgICAgICAgICAgICAgIGRvbmU7XG4gICAgICAgICAgICAgICBsZXQgaSA9IGwxIC0gMiBpblxuICAgICAgICAgICAgICAgcHJpbnQgXCIlc1xcXFxhcltyLCVzJ10mJXNcXFxcYXJbciwlcyddJiVzXCIgKHRtIGkgcDEpIChzdCBpIHAxKSAodG0gKGkrMSkgcDEpIChzdCAoaSsxKSBwMSkgKHRtIChpKzIpIHAyKVxuICAgICAgICAgICAgIHwgbDEsIGwyIC0+XG4gICAgICAgICAgICAgICBsZXQgcCA9IFppZ3phZy5jYW5vbml6ZSAoWmlnemFnLmFwcGVuZCBwMSAoWmlnemFnLmludiBwMikpIGluXG4gICAgICAgICAgICAgICBQcmludGYucHJpbnRmIFwiVE9ETzogJWQsICVkXFxuXCIgbDEgbDI7XG4gICAgICAgICAgICAgICBpZiBaaWd6YWcuaXNfaWQgcCB0aGVuIHByaW50IFwiJXNcIiAoWmlnemFnLnRvX3N0cmluZyB+dmFyIHApIGVsc2VcbiAgICAgICAgICAgICAgICAgbGV0IGwgPSBaaWd6YWcubGVuZ3RoIHAgaW5cbiAgICAgICAgICAgICAgICAgUHJpbnRmLnByaW50ZiBcInp6bGVuOiAlZFxcbiUhXCIgbDtcbiAgICAgICAgICAgICAgICAgbGV0IG4gPSAyIGluXG4gICAgICAgICAgICAgICAgIGZvciBpID0gMCB0byAobC0xKS9uIGRvXG4gICAgICAgICAgICAgICAgICAgcHJpbnQgXCIlc1wiICh0bSAoaSpuKSBwKTtcbiAgICAgICAgICAgICAgICAgICBmb3IgaiA9IDAgdG8gbWluIG4gKGwgLSBpKm4pIC0gMSBkb1xuICAgICAgICAgICAgICAgICAgICAgcHJpbnQgXCJcXFxcYXJbciwlc10mJXNcIiAoc3QgKGkqbitqKSBwKSAodG0gKGkqbitqKzEpIHApXG4gICAgICAgICAgICAgICAgICAgZG9uZTtcbiAgICAgICAgICAgICAgICAgICBwcmludCBcIlxcXFxcXFxcXCJcbiAgICAgICAgICAgICAgICAgZG9uZVxuICAgICAgICAgICBpblxuICAgICAgICAgICBwcmludCBcIlxcXFxub2luZGVudFxcblxcXFxzdWJzZWN0aW9uKnslc31cXG5cIiAoQ29oZXJlbmNlLm5hbWUgYyk7XG4gICAgICAgICAgICgqIHByaW50IFwiXFxcXHZzcGFjZXstOGV4fVxcblwiOyAqKVxuICAgICAgICAgICBwcmludCBcIlxcXFxbXFxuXFxcXGJlZ2lue3Rpa3pjZH1cXG5cIjtcbiAgICAgICAgICAgY2QgKCk7XG4gICAgICAgICAgIHByaW50IFwiXFxuXFxcXGVuZHt0aWt6Y2R9XFxuXFxcXF1cXG5cXG5cIlxuICAgICAgICApIChjb2hlcmVuY2UgY3JzKTtcbiAgICAgIHByaW50IFwiXFxcXGVuZHtkb2N1bWVudH1cXG5cIjtcbiAgICAgICFhbnNcblxuICAgIGxldCB2aWV3X3BkZiA/dmFyIHJzID1cbiAgICAgIGxldCBmbmFtZSwgb2MgPSBGaWxlbmFtZS5vcGVuX3RlbXBfZmlsZSBcIm9jYW1sLWFsZ1wiIFwiLnRleFwiIGluXG4gICAgICBvdXRwdXRfc3RyaW5nIG9jICh0b190ZXggP3ZhciBycyk7XG4gICAgICBjbG9zZV9vdXQgb2M7XG4gICAgICBsZXQgY21kID0gUHJpbnRmLnNwcmludGYgXCJjZCAlcyAmJiBwZGZsYXRleCAlcyAmJiBldmluY2UgYGJhc2VuYW1lICVzIC50ZXhgLnBkZlwiIChGaWxlbmFtZS5nZXRfdGVtcF9kaXJfbmFtZSAoKSkgZm5hbWUgZm5hbWUgaW5cbiAgICAgIGFzc2VydCAoU3lzLmNvbW1hbmQgY21kID0gMClcblxuICAgIGxldCBtYWtlIHJzIGNvaGVyZW5jZSA9XG4gICAgICB7IHJzOyBjb2hlcmVuY2UgfVxuXG4gICAgbGV0IGZpbmRfcnVsZSBjcnMgciA9XG4gICAgICBmaW5kIChycyBjcnMpIHJcblxuICAgICgqKiBGaW5kIGNvaGVyZW5jZSB3aXRoIGdpdmVuIG5hbWUuICopXG4gICAgbGV0IGZpbmQgcnMgY3JzID1cbiAgICAgIExpc3QuZmluZCAoZnVuIGMgLT4gQ29oZXJlbmNlLm5hbWUgYyA9IGNycykgcnMuY29oZXJlbmNlXG5cbiAgICBsZXQgYWRkX2NvaGVyZW5jZSBjcnMgYyBwID1cbiAgICAgICgqIFByaW50Zi5wcmludGYgXCJhZGRfY29oZXJlbmNlOiAlcyAvICVzXFxuJSFcIiAoWmlnemFnLnRvX3N0cmluZyBwMSkgKFppZ3phZy50b19zdHJpbmcgcDIpOyAqKVxuICAgICAgYXNzZXJ0IChlcV90ZXJtIChaaWd6YWcuc291cmNlIHApIChaaWd6YWcudGFyZ2V0IHApKTtcbiAgICAgIGxldCBjb2hlcmVuY2UgPSAoY29oZXJlbmNlIGNycylAW0NvaGVyZW5jZS5tYWtlIGMgcF0gaW5cbiAgICAgIHsgY3JzIHdpdGggY29oZXJlbmNlIH1cblxuICAgICgqKiBSb3RhdGUgYSBjb2hlcmVuY2UuICopXG4gICAgbGV0IHJvdGF0ZSBjcnMgY25hbWUgbiA9XG4gICAgICBsZXQgY29oZXJlbmNlID0gTGlzdC5tYXAgKGZ1biBjIC0+IGlmIENvaGVyZW5jZS5uYW1lIGMgPSBjbmFtZSB0aGVuIENvaGVyZW5jZS5yb3RhdGUgbiBjIGVsc2UgYykgY3JzLmNvaGVyZW5jZSBpblxuICAgICAgeyBjcnMgd2l0aCBjb2hlcmVuY2UgfVxuXG4gICAgKCoqIEVsaW1pbmF0ZSBhIHJ1bGUgd2l0aCBhIGNvaGVyZW5jZS4gKilcbiAgICBsZXQgZWxpbV9ydWxlIGNycyByIGMgPVxuICAgICAgbGV0IHIgPSBmaW5kX3J1bGUgY3JzIHIgaW5cbiAgICAgICgqIGxldCBjbmFtZSA9IGMgaW4gKilcbiAgICAgIGxldCBjID0gZmluZCBjcnMgYyBpblxuICAgICAgbGV0IHYgPSBDb2hlcmVuY2UudmFsdWUgciBjIGluXG4gICAgICBsZXQgdmFyID0gVmFyLm5hbWVyX25hdHVyYWwgKCkgaW4gUHJpbnRmLnByaW50ZiBcIlxcbmVsaW0gcnVsZTogWyVzXSA9PiAlc1xcbiUhXCIgKFJ1bGUudG9fc3RyaW5nIH52YXIgcikgKFppZ3phZy50b19zdHJpbmcgfnZhciB2KTtcbiAgICAgIGxldCBydWxlcyA9IExpc3QuZmlsdGVyIChmdW4gcicgLT4gbm90IChSdWxlLmVxIHIgcicpKSAocnVsZXMgY3JzKSBpblxuICAgICAgbGV0IGNvaGVyZW5jZSA9IExpc3QubWFwIChmdW4gYyAtPiBDb2hlcmVuY2UucmVwbGFjZV9ydWxlIHIgdiBjKSAoY29oZXJlbmNlIGNycykgaW5cbiAgICAgICgqIGxldCBjb2hlcmVuY2UgPSBMaXN0LmZpbHRlciAoZnVuIChjLF8pIC0+IGMgPD4gY25hbWUpIGNvaGVyZW5jZSBpbiAqKVxuICAgICAgeyBycyA9IHsgY3JzLnJzIHdpdGggcnVsZXMgfTsgY29oZXJlbmNlIH1cblxuICAgICgqKiBNb3JwaGlzbXMgYmV0d2VlbiBjb2hlcmVudCBwcmVzZW50YXRpb25zLiAqKVxuICAgIG1vZHVsZSBNb3JwaGlzbSA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID1cbiAgICAgICAge1xuICAgICAgICAgIHNvdXJjZSA6IGNycztcbiAgICAgICAgICB0YXJnZXQgOiBjcnM7XG4gICAgICAgICAgbXV0YWJsZSBydWxlcyA6IChSdWxlLnQgKiBaaWd6YWcudCkgbGlzdDtcbiAgICAgICAgICAoKiBtdWxhYmxlIGNvaGVyZW5jZXMgOiAoQ29oZXJlbmNlLnQgKiApICopXG4gICAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5lbmRcbiIsIigqKiBTaW1wbGljaWFsIHNldHMuICopXG5cbigqKiBBIHNpbXBsaWNpYWwgc2V0LiAqKVxubW9kdWxlIHR5cGUgVCA9IHNpZ1xuICAoKiogQSBzaW1wbGV4LiAqKVxuICB0eXBlIHRcblxuICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcblxuICAoKiogRGltZW5zaW9uIG9mIGEgc2ltcGxleC4gKilcbiAgdmFsIGRpbSA6IHQgLT4gaW50XG5cbiAgKCoqIEZhY2VzIG9mIGEgc2ltcGxleC4gKilcbiAgdmFsIGZhY2UgOiB0IC0+IGludCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgUHJlcyAoWCA6IEFscGhhYmV0LlQpID0gc3RydWN0XG5lbmRcbiIsIigqKiBGb3JtYWwgc2VyaWVzLiAqKVxuXG4oKiogRm9ybWFsIHNlcmllcyBvdmVyIGEgZ2l2ZW4gZmllbGQuICopXG5tb2R1bGUgTWFrZSAoSyA6IEZpZWxkLlQpID0gc3RydWN0XG4gICgqKiBBIGZvcm1hbCBzZXJpZXMuICopXG4gIHR5cGUgdCA9IChLLnQgV2Vhay50IHJlZiAqIChpbnQgLT4gSy50KSlcblxuICAoKiogRXF1YWxpdHkuICopXG4gIGxldCBlcSAoYTp0KSAoYjp0KSA9IGZhaWx3aXRoIFwiQ2Fubm90IGltcGxlbWVudCB0aGlzLlwiXG5cbiAgKCoqIEdldCBhIGNvZWZmaWNpZW50LiAqKVxuICBsZXQgZ2V0IChhOnQpIG4gPVxuICAgIGxldCBhdywgYWYgPSBhIGluXG4gICAgbGV0IGF3bCA9IFdlYWsubGVuZ3RoICFhdyBpblxuICAgIGxldCB4ID0gaWYgbiA8IGF3bCB0aGVuIFdlYWsuZ2V0ICFhdyBuIGVsc2UgTm9uZSBpblxuICAgIG1hdGNoIHggd2l0aFxuICAgIHwgU29tZSB4IC0+IHhcbiAgICB8IE5vbmUgLT5cbiAgICAgICBsZXQgeCA9IGFmIG4gaW5cbiAgICAgICBpZiBuID49IGF3bCB0aGVuXG4gICAgICAgICAoXG4gICAgICAgICAgIGxldCBhdycgPSBXZWFrLmNyZWF0ZSAobisxKSBpblxuICAgICAgICAgICBXZWFrLmJsaXQgYXcnIDAgIWF3IDAgYXdsO1xuICAgICAgICAgICBhdyA6PSBhdydcbiAgICAgICAgICk7XG4gICAgICAgV2Vhay5zZXQgIWF3IG4gKFNvbWUgeCk7XG4gICAgICAgeFxuXG4gIGxldCBjb2VmZiA9IGdldFxuXG4gIGxldCB0b19zdHJpbmcgYSA9XG4gICAgbGV0IGFucyA9IHJlZiAoSy50b19zdHJpbmcgKGdldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byA4IGRvXG4gICAgICBsZXQgYWkgPSBnZXQgYSBpIGluXG4gICAgICBpZiBub3QgKEsuZXEgYWkgSy56ZXJvKSB0aGVuXG4gICAgICAgIGFucyA6PVxuICAgICAgICAgICFhbnNcbiAgICAgICAgICBeIFwiK1wiXG4gICAgICAgICAgXiAoaWYgSy5lcSBhaSBLLm9uZSB0aGVuIFwiXCIgZWxzZSBLLnRvX3N0cmluZyBhaSlcbiAgICAgICAgICBeIChpZiBpID0gMSB0aGVuIFwielwiIGVsc2UgXCJ6XlwiIF4gc3RyaW5nX29mX2ludCBpKVxuICAgIGRvbmU7XG4gICAgYW5zIDo9ICFhbnMgXiBcIisuLi5cIjtcbiAgICAhYW5zXG5cbiAgbGV0IG1ha2UgZiA6IHQgPSAocmVmIChXZWFrLmNyZWF0ZSAwKSwgZilcblxuICAoKiogWmVyby4gKilcbiAgbGV0IHplcm8gPSBtYWtlIChmdW4gXyAtPiBLLnplcm8pXG5cbiAgKCoqIE9uZS4gKilcbiAgbGV0IG9uZSA9IG1ha2UgKGZ1biBuIC0+IGlmIG4gPSAwIHRoZW4gSy5vbmUgZWxzZSBLLnplcm8pXG5cbiAgbGV0IHZhciA9IG1ha2UgKGZ1biBuIC0+IGlmIG4gPSAxIHRoZW4gSy5vbmUgZWxzZSBLLnplcm8pXG5cbiAgKCoqIEFkZGl0aW9uLiAqKVxuICBsZXQgYWRkIGEgYiA9IG1ha2UgKGZ1biBuIC0+IEsuYWRkIChnZXQgYSBuKSAoZ2V0IGIgbikpXG5cbiAgKCoqIFN1YnRyYWN0aW9uLiAqKVxuICBsZXQgc3ViIGEgYiA9IG1ha2UgKGZ1biBuIC0+IEsuYWRkIChnZXQgYSBuKSAoSy5tdWwgKEsubmVnIEsub25lKSAoZ2V0IGIgbikpKVxuXG4gICgqKiBNdWx0aXBsaWNhdGlvbi4gKilcbiAgbGV0IG11bCBhIGIgPVxuICAgIGxldCBmIG4gPVxuICAgICAgbGV0IGFucyA9IHJlZiBLLnplcm8gaW5cbiAgICAgIGZvciBpID0gMCB0byBuIGRvXG4gICAgICAgIGFucyA6PSBLLmFkZCAhYW5zIChLLm11bCAoZ2V0IGEgaSkgKGdldCBiIChuLWkpKSlcbiAgICAgIGRvbmU7XG4gICAgICAhYW5zXG4gICAgaW5cbiAgICBtYWtlIGZcblxuICAoKiogSW50ZWdlciBleHBvbmVudGlhbC4gKilcbiAgbGV0IHJlYyBleHBuIGEgbiA9XG4gICAgYXNzZXJ0IChuID49IDApO1xuICAgIGlmIG4gPSAwIHRoZW4gb25lXG4gICAgZWxzZSBpZiBuID0gMSB0aGVuIGEgZWxzZVxuICAgICAgbXVsIGEgKGV4cG4gYSAobi0xKSlcblxuICAoKiogSGFkYW1hcmQgcHJvZHVjdC4gKilcbiAgbGV0IGhhZGFtYXJkIGEgYiA9IG1ha2UgKGZ1biBuIC0+IEsubXVsIChnZXQgYSBuKSAoZ2V0IGIgbikpXG5cbiAgKCoqIE11bHRpcGxpY2F0aW9uIGJ5IGEgY29uc3RhbnQuICopXG4gIGxldCBjbXVsIGEgYiA9IG1ha2UgKGZ1biBuIC0+IEsubXVsIGEgKGdldCBiIG4pKVxuXG4gICgqKiBOZWdhdGlvbi4gKilcbiAgbGV0IG5lZyBhID0gbWFrZSAoZnVuIG4gLT4gSy5uZWcgKGdldCBhIG4pKVxuXG4gIGxldCBzdGFyIGEgPVxuICAgICgqIFRPRE8gKilcbiAgICBhc3NlcnQgKEsuZXEgKGdldCBhIDApIEsuemVybyk7XG4gICAgKCogYWRkIHRoZSBleHBvbmVudHMgZnJvbSAwIHRvIG4gKilcbiAgICBsZXQgcmVjIGF1eCBuID1cbiAgICAgIGlmIG4gPSAwIHRoZW4gZXhwbiBhIDBcbiAgICAgIGVsc2UgYWRkIChleHBuIGEgbikgKGF1eCAobi0xKSlcbiAgICBpblxuICAgIG1ha2UgKGZ1biBuIC0+IGdldCAoYXV4IG4pIG4pXG5cbiAgKCoqIEludmVyc2UuICopXG4gIGxldCBpbnYgYSA9IHN0YXIgKHN1YiBvbmUgYSlcblxuICBtb2R1bGUgUG9seW5vbWlhbCA9IFJpbmcuUG9seW5vbWlhbChLKVxuXG4gICgqKiBDYW5vbmljYWwgaW5qZWN0aW9uIG9mIHBvbHlub21pYWxzLiAqKVxuICBsZXQgcG9seW5vbWlhbCAocCA6IFBvbHlub21pYWwudCkgPVxuICAgIG1ha2UgKGZ1biBuIC0+IFBvbHlub21pYWwuY29lZmYgcCBuKVxuXG4gIG1vZHVsZSBSYXRpb25hbEZyYWN0aW9ucyA9IEZpZWxkLlJhdGlvbmFsRnJhY3Rpb25zKEspXG5cbiAgKCoqIENhbm9uaWNhbCBpbmplY3Rpb24gb2YgcmF0aW9uYWwgZnJhY3Rpb25zLiAqKVxuICBsZXQgcmF0aW9uYWwgKHIgOiBSYXRpb25hbEZyYWN0aW9ucy50KSA9XG4gICAgbGV0IHAsIHEgPSByIGluXG4gICAgbGV0IHAgPSBwb2x5bm9taWFsIHAgaW5cbiAgICBsZXQgcSA9IHBvbHlub21pYWwgcSBpblxuICAgIG11bCBwIChpbnYgcSlcbmVuZFxuXG4oKiogVGhlIGZpZWxkIG9mIHNlcmllcy4gKilcbm1vZHVsZSBGaWVsZCAoSyA6IEZpZWxkLlQpIDogUmluZy5UID0gTWFrZShLKVxuIiwiKCoqIEhpZ2hlci1kaW1lbnNpb25hbCBwcmVjYXRlZ29yaWVzLiAqKVxuXG4oKiogRnJlZSBwcmVjYXRlZ29yaWVzLiAqKVxubW9kdWxlIE1ha2UgKFggOiBBbHBoYWJldC5UKSA9IHN0cnVjdFxuICAoKiogQSBjZWxsLiAqKVxuICAoKiBOb3RlOiB3ZSBzdXBwb3NlIHRoYXQgZ2VuZXJhdG9ycyBhcmUgd2hpc2tlcmVkIChieSBpZGVudGl0aWVzIGlmIG5lY2Vzc2FyeSlcbiAgYWxsIHRoZSB3YXkgZG93bi4gKilcbiAgdHlwZSBjZWxsID1cbiAgICB8IEMgb2Ygd2hpc2tlciAqIGNlbGwgKCoqIGEgY29tcG9zaXRlICopXG4gICAgfCBJIG9mIGNlbGwgKCoqIGFuIGlkZW50aXR5ICopXG5cbiAgKCoqIEEgd2hpc2tlcmVkIGdlbmVyYXRvci4gKilcbiAgYW5kIHdoaXNrZXIgPVxuICAgIHwgRyBvZiBYLnQgKCoqIGEgZ2VuZXJhdG9yICopXG4gICAgfCBXIG9mIGNlbGwgKiB3aGlza2VyICogY2VsbCAoKiogYSB3aGlza2VyIGNvbnRleHQgKilcblxuICB0eXBlIHQgPSBjZWxsXG5cbiAgKCoqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGNlbGwuICopXG4gIGxldCB0b19zdHJpbmcgYyA9XG4gICAgbGV0IHJlYyBsaXN0ID0gZnVuY3Rpb25cbiAgICAgIHwgQyAodyxjKSAtPiB3OjoobGlzdCBjKVxuICAgICAgfCBJIF8gLT4gW11cbiAgICBpblxuICAgIGxldCByZWMgY2VsbCA9IGZ1bmN0aW9uXG4gICAgICB8IEMgXyBhcyBjIC0+IFwiW1wiIF4gU3RyaW5nLmNvbmNhdCBcInxcIiAoTGlzdC5tYXAgd2hpc2tlciAobGlzdCBjKSkgXiBcIl1cIlxuICAgICAgfCBJIGMgLT4gXCJbXCIgXiBjZWxsIGMgXiBcIl1cIlxuICAgIGFuZCB3aGlza2VyID0gZnVuY3Rpb25cbiAgICAgIHwgRyBnIC0+IFgudG9fc3RyaW5nIGdcbiAgICAgIHwgVyAoYzEsdyxjMikgLT4gY2VsbCBjMSBeIHdoaXNrZXIgdyBeIGNlbGwgYzJcbiAgICBpblxuICAgIGNlbGwgY1xuXG4gICgqKiBEaW1lbnNpb24gb2YgYSBjZWxsLiAqKVxuICBsZXQgZGltIGMgPVxuICAgIGxldCByZWMgY2VsbCA9IGZ1bmN0aW9uXG4gICAgICB8IEMgKHcsXykgLT4gd2hpc2tlciB3XG4gICAgICB8IEkgYyAtPiBjZWxsIGMgKyAxXG4gICAgYW5kIHdoaXNrZXIgPSBmdW5jdGlvblxuICAgICAgfCBHIGcgLT4gMFxuICAgICAgfCBXIChfLHcsXykgLT4gd2hpc2tlciB3ICsgMVxuICAgIGluXG4gICAgY2VsbCBjXG5cbiAgKCoqIENvbXBvc2l0aW9uIG9mIHR3byBjZWxscyBvbiB0aGUgYm91bmRhcnkgb2YgbWF4aW1hbCBkaW1lbnNpb24uICopXG4gIGxldCByZWMgY29tcG9zZSBjIGQgPVxuICAgIGlmIGRpbSBjID0gZGltIGQgdGhlblxuICAgICAgbGV0IHJlYyBhdXggPSBmdW5jdGlvblxuICAgICAgICB8IEMgKHcsYykgLT4gQyAodywgYXV4IGMpXG4gICAgICAgIHwgSSBfIC0+IGRcbiAgICAgIGluXG4gICAgICBhdXggY1xuICAgIGVsc2UgaWYgZGltIGMgPiBkaW0gZCB0aGVuXG4gICAgICBsZXQgcmVjIGF1eCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgQyAodyxjKSAtPlxuICAgICAgICAgICBsZXQgdyA9XG4gICAgICAgICAgICAgbWF0Y2ggdyB3aXRoXG4gICAgICAgICAgICAgfCBXIChjMSx3LGMyKSAtPiBXIChjMSx3LGNvbXBvc2UgYzIgZClcbiAgICAgICAgICAgICB8IEcgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgbGV0IGMgPSBhdXggYyBpblxuICAgICAgICAgICBDICh3LGMpXG4gICAgICAgIHwgSSBjIC0+IEkgKGNvbXBvc2UgYyBkKVxuICAgICAgaW5cbiAgICAgIGF1eCBjXG4gICAgZWxzZVxuICAgICAgKCpcbiAgICAgIGxldCByZWMgYXV4ID0gZnVuY3Rpb25cbiAgICAgICAgfCBDICh3LGQpIC0+XG4gICAgICAgICAgIGxldCB3ID1cbiAgICAgICAgICAgICBtYXRjaCB3IHdpdGhcbiAgICAgICAgICAgICB8IFcgKGQxLHcsZDIpIC0+IFdcbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgbGV0IGQgPSBhdXggZCBpblxuICAgICAgICAgICBDICh3LGQpXG4gICAgICAgIHwgSSBkIC0+IEkgKGNvbXBvc2UgYyBkKVxuICAgICAgaW5cbiAgICAgIGF1eCBkXG4gICAgICAgKilcbiAgICAgIGZhaWx3aXRoIFwiVE9ET1wiXG5cbiAgKCoqIFByZXNlbnRhdGlvbiBvZiBhIHByZWNhdGVnb3J5OiBhIFwicHJlLXBvbHlncmFwaFwiLiAqKVxuICBtb2R1bGUgUHJlcyA9IHN0cnVjdFxuICAgIG1vZHVsZSBFID0gTWFwLk1ha2UoWClcblxuICAgICgqIEJ5IGNvbnZlbnRpb24sIGEgemVybyBjZWxsIGhhcyAocGh5c2ljYWxseSkgaXRzZWxmIGFzIHNvdXJjZSBhbmQgdGFyZ2V0LiAqKVxuICAgIHR5cGUgdCA9IChjZWxsICogY2VsbCkgRS50XG5cbiAgICAoKiogRW1wdHkgc2lnbmF0dXJlLiAqKVxuICAgIGxldCBlbXB0eSA9IEUuZW1wdHlcblxuICAgICgqKiBEb2VzIGEgZ2VuZXJhdG9yIGJlbG9uZyB0aGUgc2lnbmF0dXJlPyAqKVxuICAgIGxldCBtZW0gcyBnID1cbiAgICAgIEUubWVtIGcgc1xuXG4gICAgbGV0IGJvdW5kYXJ5IHMgZyA9XG4gICAgICBsZXQgeCx5ID0gRS5maW5kIGcgcyBpblxuICAgICAgYXNzZXJ0ICh4ICE9IGcgJiYgeSAhPSBnKTtcbiAgICAgIHgseVxuXG4gICAgKCoqIFNvdXJjZSBvZiBhIGdlbmVyYXRvci4gKilcbiAgICBsZXQgc291cmNlIHMgZyA9XG4gICAgICBmc3QgKGJvdW5kYXJ5IHMgZylcblxuICAgICgqKiBUYXJnZXQgb2YgYSBnZW5lcmF0b3IuICopXG4gICAgbGV0IHRhcmdldCBzIGcgPVxuICAgICAgc25kIChib3VuZGFyeSBzIGcpXG5cbiAgICAoKiogT3BlcmF0aW9ucyBvbiBjZWxscyBpbiBhIHByZXNlbnRhdGlvbi4gKilcbiAgICBtb2R1bGUgQ2VsbCA9IHN0cnVjdFxuICAgICAgKCoqIEVuc3VyZSB0aGF0IGEgY2VsbCB1c2VzIG9ubHkgZ2VuZXJhdG9ycyBkZWZpbmVkIGluIHRoZSBzaWduYXR1cmUuICopXG4gICAgICBsZXQgbWVtIHMgYyA9XG4gICAgICAgIGxldCByZWMgY2VsbCA9IGZ1bmN0aW9uXG4gICAgICAgICAgfCBDICh3LGMpIC0+IHdoaXNrZXIgdyAmJiBjZWxsIGNcbiAgICAgICAgICB8IEkgYyAtPiBjZWxsIGNcbiAgICAgICAgYW5kIHdoaXNrZXIgPSBmdW5jdGlvblxuICAgICAgICAgIHwgVyAoYzEsdyxjMikgLT4gY2VsbCBjMSAmJiB3aGlza2VyIHcgJiYgY2VsbCBjMlxuICAgICAgICAgIHwgRyBnIC0+IG1lbSBzIGdcbiAgICAgICAgaW5cbiAgICAgICAgY2VsbCBjXG5cbiAgICAgICgqKiBEaW1lbnNpb24gb2YgYSBjZWxsLiAqKVxuICAgICAgbGV0IGRpbSBzIGMgPSBkaW0gY1xuXG4gICAgICAoKiBsZXQgc291cmNlIHMgYyA9ICopXG4gICAgICAgICgqIGxldCByZWMgY2VsbCA9IGZ1bmN0aW9uICopXG4gICAgICAgICAgKCogfCBDICh3LGMpIC0+IHdoaXNrZXIgdyAqKVxuICAgICAgICAgICgqIHwgSSBjIC0+IGMgKilcbiAgICAgICAgKCogYW5kIHdoaXNrZXIgPSBmdW5jdGlvbiAqKVxuICAgICAgICAgICgqIHwgVyAoYzEsdyxjMikgLT4gKilcbiAgICAgICAgICAgICAoKiBjZWxsICAqKVxuICAgICAgICAgICgqIHwgRyBnIC0+ICopXG4gICAgICAgICgqIGluICopXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iLCIoKiogSHlwZXJncmFwaHMuICopXG5cbm1vZHVsZSB0eXBlIFQgPSBzaWdcbiAgKCoqIFZlcnRpY2VzLiAqKVxuICBtb2R1bGUgViA6IEFscGhhYmV0LlRcblxuICAoKiogRWRnZXMuICopXG4gIG1vZHVsZSBFIDogQWxwaGFiZXQuVFxuXG4gICgqKiBTb3VyY2UuICopXG4gIHZhbCBzcmMgOiBFLnQgLT4gVi50IGxpc3RcblxuICAoKiogVGFyZ2V0LiAqKVxuICB2YWwgdGd0IDogRS50IC0+IFYudCBsaXN0XG5lbmRcblxubW9kdWxlIEZ1bGwgKFYgOiBBbHBoYWJldC5UKSAoRSA6IEFscGhhYmV0LlQpID0gc3RydWN0XG4gIG1vZHVsZSBWID0gc3RydWN0XG4gICAgdHlwZSB0ID0geyBsYWJlbCA6IFYudCB9XG5cbiAgICBsZXQgbGFiZWwgeCA9IHgubGFiZWxcblxuICAgIGxldCBlcSB4IHkgPSB4ID09IHlcblxuICAgIGxldCBjb21wYXJlIHggeSA9IFYuY29tcGFyZSAobGFiZWwgeCkgKGxhYmVsIHkpXG5cbiAgICBsZXQgdG9fc3RyaW5nIHggPSBWLnRvX3N0cmluZyAobGFiZWwgeClcbiAgZW5kXG5cbiAgbW9kdWxlIFZMID0gQWxwaGFiZXQuTGlzdChWKVxuXG4gIG1vZHVsZSBFID0gc3RydWN0XG4gICAgKCogQWxwaGFiZXQuUHJvZChFKShBbHBoYWJldC5Qcm9kKEFscGhhYmV0Lkxpc3QoVikpKEFscGhhYmV0Lkxpc3QoVikpKSAqKVxuXG4gICAgdHlwZSB0ID0geyBsYWJlbCA6IEUudDsgc3JjIDogVi50IGxpc3Q7IHRndCA6IFYudCBsaXN0IH1cblxuICAgIGxldCBlcSBmIGcgPSBmID09IGdcblxuICAgIGxldCBjb21wYXJlIGYgZyA9IGNvbXBhcmUgZiBnXG5cbiAgICBsZXQgdG9fc3RyaW5nIGYgPSBFLnRvX3N0cmluZyBmLmxhYmVsIF4gXCIgOiBcIiBeIFZMLnRvX3N0cmluZyBmLnNyYyBeIFwiIC0+IFwiIF4gVkwudG9fc3RyaW5nIGYudGd0XG5cbiAgICBsZXQgbGFiZWwgZiA9IGYubGFiZWxcblxuICAgIGxldCBzcmMgZiA9IGYuc3JjXG5cbiAgICBsZXQgdGd0IGYgPSBmLnRndFxuXG4gICAgbGV0IG1ha2UgbCBzIHQgPSB7IGxhYmVsID0gbDsgc3JjID0gczsgdGd0ID0gdH1cbiAgZW5kXG5cbiAgbGV0IHNyYyA9IEUuc3JjXG5cbiAgbGV0IHRndCA9IEUudGd0XG5lbmRcblxuKCoqIFByZXNlbnRhdGlvbiBvZiBhbiBoeXBlcmdyYXBoLiAqKVxubW9kdWxlIFByZXMgKFYgOiBBbHBoYWJldC5UKSAoRSA6IEFscGhhYmV0LlQpID0gc3RydWN0XG4gIGluY2x1ZGUgRnVsbChWKShFKVxuXG4gIHR5cGUgdCA9XG4gICAge1xuICAgICAgdmVydGljZXMgOiBWLnQgbGlzdDtcbiAgICAgIGVkZ2VzIDogRS50IGxpc3Q7XG4gICAgfVxuXG4gIGxldCB2ZXJ0aWNlcyBnID0gZy52ZXJ0aWNlc1xuXG4gIGxldCBlZGdlcyBnID0gZy5lZGdlc1xuXG4gIGxldCBlbXB0eSA9IHsgdmVydGljZXMgPSBbXTsgZWRnZXMgPSBbXSB9XG5cbiAgbGV0IGFkZF92ZXJ0ZXggZyB4ID0geyBnIHdpdGggdmVydGljZXMgPSB4OjoodmVydGljZXMgZykgfVxuXG4gIGxldCBhZGRfZWRnZSBnIGUgPSB7IGcgd2l0aCBlZGdlcyA9IGU6OihlZGdlcyBnKSB9XG5cbiAgbGV0IHZlcnRleF9wcmVkIGcgdiA9XG4gICAgYXNzZXJ0IChMaXN0Lm1lbXEgdiAodmVydGljZXMgZykpO1xuICAgIExpc3QuZmlsdGVyIChmdW4gZSAtPiBMaXN0Lm1lbXEgdiAodGd0IGUpKSAoZWRnZXMgZylcblxuICBsZXQgdmVydGV4X3N1Y2MgZyB2ID1cbiAgICBhc3NlcnQgKExpc3QubWVtcSB2ICh2ZXJ0aWNlcyBnKSk7XG4gICAgTGlzdC5maWx0ZXIgKGZ1biBlIC0+IExpc3QubWVtcSB2IChzcmMgZSkpIChlZGdlcyBnKVxuXG4gIGxldCBlZGdlX3ByZWQgZyBlID0gc3JjIGVcblxuICBsZXQgZWRnZV9zdWNjIGcgZSA9IHRndCBlXG5lbmRcblxubW9kdWxlIE1hcCAoViA6IEFscGhhYmV0LlQpIChFIDogQWxwaGFiZXQuVCkgPSBzdHJ1Y3RcbiAgbW9kdWxlIE1WID0gTWFwLk1ha2UoVilcbiAgbW9kdWxlIE1FID0gTWFwLk1ha2UoRSlcbmVuZFxuIiwiKCoqIEdyYXBocy4gKilcblxuKCoqIEEgZ3JhcGguICopXG5tb2R1bGUgdHlwZSBUID0gc2lnXG4gICgqKiBWZXJ0aWNlcy4gKilcbiAgbW9kdWxlIFYgOiBBbHBoYWJldC5UXG5cbiAgKCoqIEVkZ2VzLiAqKVxuICBtb2R1bGUgRSA6IEFscGhhYmV0LlRcblxuICAoKiogU291cmNlLiAqKVxuICB2YWwgc3JjIDogRS50IC0+IFYudFxuXG4gICgqKiBUYXJnZXQuICopXG4gIHZhbCB0Z3QgOiBFLnQgLT4gVi50XG5lbmRcblxuKCoqIFRoZSB0ZXJtaW5hbCBncmFwaC4gKilcbm1vZHVsZSBUZXJtaW5hbCA6IFQgPSBzdHJ1Y3RcbiAgbW9kdWxlIFYgPSBBbHBoYWJldC5Vbml0XG4gIG1vZHVsZSBFID0gQWxwaGFiZXQuVW5pdFxuICBsZXQgc3JjICgpID0gKClcbiAgbGV0IHRndCAoKSA9ICgpXG5lbmRcblxubW9kdWxlIEZ1bGwgKFYgOiBBbHBoYWJldC5UKSAoRSA6IEFscGhhYmV0LlQpID0gc3RydWN0XG4gIG1vZHVsZSBWID0gVlxuXG4gIG1vZHVsZSBFID0gc3RydWN0XG4gICAgaW5jbHVkZSBBbHBoYWJldC5Qcm9kKEUpKEFscGhhYmV0LlByb2QoVikoVikpXG4gICAgbGV0IHRvX3N0cmluZyAoZiwoeCx5KSkgPSBFLnRvX3N0cmluZyBmXG4gIGVuZFxuXG4gIGxldCBzcmMgKGYsKHgseSkpID0geFxuXG4gIGxldCB0Z3QgKGYsKHgseSkpID0geVxuZW5kXG5cbigqKiBQcmVzZW50YXRpb24gb2YgYSBncmFwaC4gKilcbm1vZHVsZSBQcmVzIChWIDogQWxwaGFiZXQuVCkgKEUgOiBBbHBoYWJldC5UKSA9IHN0cnVjdFxuICBtb2R1bGUgR3JhcGggPSBGdWxsKFYpKEUpXG5cbiAgdHlwZSB0ID1cbiAgICB7XG4gICAgICB2ZXJ0aWNlcyA6IFYudCBsaXN0O1xuICAgICAgZWRnZXMgOiBHcmFwaC5FLnQgbGlzdDtcbiAgICB9XG5cbiAgbGV0IGVtcHR5ID0geyB2ZXJ0aWNlcyA9IFtdOyBlZGdlcyA9IFtdIH1cblxuICBsZXQgYWRkX3ZlcnRleCBwIHggPSB7IHAgd2l0aCB2ZXJ0aWNlcyA9IHg6OnAudmVydGljZXMgfVxuXG4gIGxldCBhZGRfZWRnZSBwIGYgKCh4OlYudCksKHk6Vi50KSkgPSB7IHAgd2l0aCBlZGdlcyA9IChmLCh4LHkpKTo6cC5lZGdlcyB9XG5cbiAgbGV0IGVkZ2UgcCBmIDogR3JhcGguRS50ID1cbiAgICBsZXQgeCx5ID0gTGlzdC5hc3NvYyBmIHAuZWRnZXMgaW5cbiAgICBmLCh4LHkpXG5cbiAgbGV0IGhhc192ZXJ0ZXggcCB4ID0gTGlzdC5leGlzdHMgKGZ1biB5IC0+IFYuZXEgeCB5KSBwLnZlcnRpY2VzXG5cbiAgbGV0IHRvX3N0cmluZyBnID1cbiAgICBsZXQgdmVydGljZXMgPSBMaXN0Lm1hcCBWLnRvX3N0cmluZyBnLnZlcnRpY2VzIGluXG4gICAgbGV0IHZlcnRpY2VzID0gU3RyaW5nLmNvbmNhdCBcIiAsIFwiIHZlcnRpY2VzIGluXG4gICAgbGV0IGVkZ2VzID0gTGlzdC5tYXAgKGZ1biAoZiwoeCx5KSkgLT4gRS50b19zdHJpbmcgZiBeIFwiOlwiIF4gVi50b19zdHJpbmcgeCBeIFwiLT5cIiBeIFYudG9fc3RyaW5nIHkpIGcuZWRnZXMgaW5cbiAgICBsZXQgZWRnZXMgPSBTdHJpbmcuY29uY2F0IFwiICwgXCIgZWRnZXMgaW5cbiAgICB2ZXJ0aWNlcyBeIFwiXFxuXCIgXiBlZGdlc1xuZW5kXG4iLCIoKiogR2xvYnVsYXIgc2V0cy4gKilcblxuKCoqIEEgZ2xvYnVsYXIgc2V0LiAqKVxubW9kdWxlIHR5cGUgVCA9IHNpZ1xuICAoKiogQSBjZWxsLiAqKVxuICB0eXBlIHRcblxuICAoKiogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgY2VsbC4gKilcbiAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG5cbiAgKCoqIERpbWVuc2lvbi4gKilcbiAgdmFsIGRpbSA6IHQgLT4gaW50XG5cbiAgKCoqIFNvdXJjZS4gKilcbiAgdmFsIHNyYyA6IHQgLT4gdFxuXG4gICgqKiBUYXJnZXQuICopXG4gIHZhbCB0Z3QgOiB0IC0+IHRcbmVuZFxuXG4oKiogVGhlIHRlcm1pbmFsIGdsb2J1bGFyIHNldC4gKilcbm1vZHVsZSBUZXJtaW5hbCA6ICBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCB0b19zdHJpbmcgPSBzdHJpbmdfb2ZfaW50XG5cbiAgbGV0IGRpbSBuID0gblxuXG4gIGxldCBzcmMgbiA9XG4gICAgYXNzZXJ0IChuID4gMCk7XG4gICAgbiAtIDFcblxuICBsZXQgdGd0IG4gPVxuICAgIGFzc2VydCAobiA+IDApO1xuICAgIG4gLSAxXG5lbmRcblxuKCoqIFByZXNlbnRlZCBnbG9idWxhciBzZXQuICopXG5tb2R1bGUgUHJlcyAoWCA6IEFscGhhYmV0LlQpID0gc3RydWN0XG4gICgqIENlbGxzIGNvZGVkIGFzIGVsZW1lbnQsIChzb3VyY2UsdGFyZ2V0KSwgdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IGJlaW5nIHRoZVxuICAgICBlbGVtZW50IGZvciAwLWNlbGxzICopXG4gIG1vZHVsZSBDZWxsID0gQWxwaGFiZXQuUHJvZDMoQWxwaGFiZXQuSW50KShYKShYKVxuICBtb2R1bGUgRSA9IEFscGhhYmV0Lk1hcChYKShDZWxsKVxuXG4gICgqKiBBIGdsb2J1bGFyIHNldC4gKilcbiAgdHlwZSB0ID0gRS50XG5cbiAgKCoqIFRoZSBlbXB0eSBnbG9idWxhciBzZXQuICopXG4gIGxldCBlbXB0eSA6IHQgPSBFLmVtcHR5XG5cbiAgbGV0IG1lbSAoczp0KSAoZzpYLnQpID0gRS5tZW0gcyBnXG5cbiAgKCoqIERpbWVuc2lvbiBvZiBhIGdlbmVyYXRvci4gKilcbiAgbGV0IGRpbSAoczp0KSAoZzpYLnQpID1cbiAgICBsZXQgbixfLF8gPSBFLmFwcCBzIGcgaW5cbiAgICBuXG5cbiAgKCoqIFNvdXJjZSBvZiBhIGNlbGwuICopXG4gIGxldCBzcmMgKHM6dCkgKGc6WC50KSA9XG4gICAgYXNzZXJ0IChkaW0gcyBnID4gMCk7XG4gICAgbGV0IG4sc3JjLF8gPSBFLmFwcCBzIGcgaW5cbiAgICBhc3NlcnQgKG4gPiAwKTtcbiAgICBzcmNcblxuICAoKiogVGFyZ2V0IG9mIGEgY2VsbC4gKilcbiAgbGV0IHRndCAoczp0KSAoZzpYLnQpID1cbiAgICBsZXQgbixfLHRndCA9IEUuYXBwIHMgZyBpblxuICAgIGFzc2VydCAobiA+IDApO1xuICAgIHRndFxuXG4gICgqKiBBZGQgYSAwLWNlbGwuICopXG4gIGxldCBhZGQwIChzOnQpIChnOlgudCkgOiB0ID1cbiAgICBFLmFkZCBzIGcgKDAsZyxnKVxuXG4gICgqKiBBZGQgYW4gbi1jZWxsLiAqKVxuICBsZXQgYWRkIHMgKGc6WC50KSBzcmMgdGd0IDogdCA9XG4gICAgYXNzZXJ0IChtZW0gcyBzcmMpO1xuICAgIGFzc2VydCAobWVtIHMgdGd0KTtcbiAgICBsZXQgbiA9IGRpbSBzIHNyYyArIDEgaW5cbiAgICBhc3NlcnQgKGRpbSBzIHRndCArIDEgPSBuKTtcbiAgICBFLmFkZCBzIGcgKG4sc3JjLHRndClcblxuICBtb2R1bGUgTWFrZSAoUCA6IHNpZyB2YWwgcHJlc2VudGF0aW9uIDogdCBlbmQpIDogVCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IFgudFxuXG4gICAgbGV0IHRvX3N0cmluZyA9IFgudG9fc3RyaW5nXG5cbiAgICBsZXQgZGltID0gZGltIFAucHJlc2VudGF0aW9uXG5cbiAgICBsZXQgc3JjID0gc3JjIFAucHJlc2VudGF0aW9uXG5cbiAgICBsZXQgdGd0ID0gdGd0IFAucHJlc2VudGF0aW9uXG4gIGVuZFxuZW5kXG5cbigqKiBBIGdsb2J1bGFyIHRoZW9yeSwgdGhlIHR5cGljYWwgZXhhbXBsZSBiZWluZyB3ZWFrIG9tZWdhLWNhdGVnb3JpZXMuICopXG5tb2R1bGUgVGhlb3J5ID0gc3RydWN0XG4gIG1vZHVsZSBWYXIgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnRcblxuICAgIGxldCBmcmVzaCA9XG4gICAgICBsZXQgbiA9IHJlZiAoLTEpIGluXG4gICAgICBmdW4gKCkgLT5cbiAgICAgIGluY3IgbjsgKCFuIDogdClcblxuICAgIGxldCB0b19zdHJpbmcgKHg6dCkgPVxuICAgICAgXCJ4XCIgXiBzdHJpbmdfb2ZfaW50IHhcbiAgZW5kXG5cbiAgbW9kdWxlIENvbnMgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnRcbiAgICAgICAgICAgXG4gICAgbGV0IGZyZXNoID1cbiAgICAgIGxldCBuID0gcmVmICgtMSkgaW5cbiAgICAgIGZ1biAoKSAtPlxuICAgICAgaW5jciBuOyAoIW4gOiB0KVxuXG4gICAgbGV0IHRvX3N0cmluZyAoeDp0KSA9XG4gICAgICBcImZcIiBeIHN0cmluZ19vZl9pbnQgeFxuICBlbmRcblxuICB0eXBlIHRlcm0gPVxuICAgIHwgVmFyIG9mIFZhci50XG4gICAgfCBDb25zIG9mIENvbnMudCAqIGNvbnRleHRcbiAgKCoqIEEgY29udGV4dCBjb250YWlucyB0ZXJtcyB3aXRoIHRoZWlyIHNvdXJjZSBhbmQgdGFyZ2V0LiAqKVxuICBhbmQgY29udGV4dCA9ICh0ZXJtICogKHRlcm0gKiB0ZXJtKSkgbGlzdFxuZW5kXG4iLCIoKiogQ2F0ZWdvcmllcy4gKilcblxuKCoqIEEgY2F0ZWdvcnkuICopXG5tb2R1bGUgdHlwZSBUID0gc2lnXG4gIGluY2x1ZGUgR3JhcGguVFxuXG4gICgqKiBDb21wb3NpdGlvbiBvZiBtb3JwaGlzbXMuICopXG4gIHZhbCBjb21wIDogRS50IC0+IEUudCAtPiBFLnRcblxuICAoKiogSWRlbnRpdHkgbW9ycGhpc20uICopXG4gIHZhbCBpZCA6IFYudCAtPiBFLnRcbmVuZFxuXG4oKiogRnJlZSBjYXRlZ29yeSBvbiBhIGdyYXBoLiAqKVxubW9kdWxlIEZyZWUgKEcgOiBHcmFwaC5UKSA9IHN0cnVjdFxuICBtb2R1bGUgViA9IEcuVlxuICBtb2R1bGUgTSA9IE1vbm9pZC5GcmVlKEcuRSlcbiAgbW9kdWxlIEUgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIEFscGhhYmV0LlByb2QzKFYpKE0pKFYpXG4gICAgbGV0IHRvX3N0cmluZyAoeCxmLHkpID1cbiAgICAgIGlmIE0uZXEgTS5vbmUgZiB0aGVuIFwiaWRcIl5WLnRvX3N0cmluZyB4IGVsc2UgTS50b19zdHJpbmcgZlxuICBlbmRcbiAgbGV0IHNyYyAoKHgsZix5KTpFLnQpID0geFxuICBsZXQgdGd0ICgoeCxmLHkpOkUudCkgPSB5XG4gIGxldCBpZCAoeDpWLnQpIDogRS50ID0gKHgsTS5vbmUseClcbiAgbGV0IGNvbXAgKCh4LGYseSk6RS50KSAoKHknLGcseik6RS50KSA6IEUudCA9XG4gICAgYXNzZXJ0IChWLmVxIHkgeScpO1xuICAgIHgsTS5tdWwgZiBnLHpcbiAgbGV0IGluaiBmIDogRS50ID0gKEcuc3JjIGYsTS5pbmogZixHLnRndCBmKVxuZW5kXG5tb2R1bGUgRnJlZUNhdGVnb3J5IChHIDogR3JhcGguVCkgOiBUID0gRnJlZShHKVxuXG4oKiogUHJlc2VudGF0aW9uIG9mIGEgY2F0ZWdvcnkuICopXG5tb2R1bGUgUHJlcyAoViA6IEFscGhhYmV0LlQpIChFIDogQWxwaGFiZXQuVCkgPSBzdHJ1Y3RcbiAgbW9kdWxlIEdQID0gR3JhcGguUHJlcyhWKShFKVxuICBtb2R1bGUgRnJlZSA9IEZyZWUoR1AuR3JhcGgpXG5cbiAgKCoqIEEgcHJlc2VudGF0aW9uLiAqKVxuICB0eXBlIHQgPVxuICAgIHtcbiAgICAgIGdyYXBoIDogR1AudDtcbiAgICAgIHJlbGF0aW9ucyA6IChGcmVlLkUudCAqIEZyZWUuRS50KSBsaXN0O1xuICAgIH1cblxuICAoKiogRW1wdHkgcHJlc2VudGF0aW9uLiAqKVxuICBsZXQgZW1wdHkgPSB7IGdyYXBoID0gR1AuZW1wdHk7IHJlbGF0aW9ucyA9IFtdIH1cblxuICBsZXQgYWRkX29iamVjdCBwIHggPVxuICAgIHsgcCB3aXRoIGdyYXBoID0gR1AuYWRkX3ZlcnRleCBwLmdyYXBoIHggfVxuXG4gIGxldCBhZGRfbW9ycGhpc20gcCBmIHggeSA9XG4gICAgYXNzZXJ0IChHUC5oYXNfdmVydGV4IHAuZ3JhcGggeCk7XG4gICAgYXNzZXJ0IChHUC5oYXNfdmVydGV4IHAuZ3JhcGggeSk7XG4gICAgeyBwIHdpdGggZ3JhcGggPSBHUC5hZGRfZWRnZSBwLmdyYXBoIGYgKHgseSkgfVxuXG4gICgqKiBNb3JwaGlzbSBjb3JyZXNwb25kaW5nIHRvIGEgZ2VuZXJhdG9yLiAqKVxuICBsZXQgbW9ycGhpc20gcCBmIDogRnJlZS5FLnQgPVxuICAgIEZyZWUuaW5qIChHUC5lZGdlIHAuZ3JhcGggZilcblxuICBsZXQgYWRkX3JlbGF0aW9uIHAgZiBnID1cbiAgICB7IHAgd2l0aCByZWxhdGlvbnMgPSAoZixnKTo6cC5yZWxhdGlvbnMgfVxuXG4gIGxldCB0b19zdHJpbmcgcCA9XG4gICAgbGV0IGdyYXBoID0gR1AudG9fc3RyaW5nIHAuZ3JhcGggaW5cbiAgICBsZXQgcmVsYXRpb25zID0gcC5yZWxhdGlvbnMgaW5cbiAgICBsZXQgcmVsYXRpb25zID0gTGlzdC5tYXAgKGZ1biAoZixnKSAtPiBGcmVlLkUudG9fc3RyaW5nIGYgXiBcIj1cIiBeIEZyZWUuRS50b19zdHJpbmcgZykgcmVsYXRpb25zIGluXG4gICAgbGV0IHJlbGF0aW9ucyA9IFN0cmluZy5jb25jYXQgXCIgLCBcIiByZWxhdGlvbnMgaW5cbiAgICBncmFwaCBeIFwiXFxuXCIgXiByZWxhdGlvbnNcbmVuZFxuXG4oKiogQ2F0ZWdvcnkgb2YgYSBtb25vaWQuICopXG5tb2R1bGUgTW9ub2lkIChNIDogTW9ub2lkLlQpIDogVCA9IHN0cnVjdFxuICBtb2R1bGUgViA9IEFscGhhYmV0LlVuaXRcbiAgbW9kdWxlIEUgPSBNXG4gIGxldCBzcmMgXyA9ICgpXG4gIGxldCB0Z3QgXyA9ICgpXG4gIGxldCBjb21wID0gTS5tdWxcbiAgbGV0IGlkICgpID0gTS5vbmVcbmVuZFxuXG4oKiogVW5kZXJseWluZyBncmFwaCBvZiBhIGNhdGVnb3J5LiAqKVxubW9kdWxlIEdyYXBoIChDIDogVCkgOiBHcmFwaC5UID0gc3RydWN0XG4gIGluY2x1ZGUgQ1xuZW5kXG4iLCIoKiogQXV0b21hdGEuICopXG5cbigqKiBSZWd1bGFyIGV4cHJlc3Npb25zLiAqKVxubW9kdWxlIFJlZ2V4cCAoWCA6IEFscGhhYmV0LlQpID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBMZXR0ZXIgb2YgWC50XG4gICAgfCBVbmlvbiBvZiB0ICogdFxuICAgIHwgRW1wdHlcbiAgICB8IENvbmNhdCBvZiB0ICogdCAoKiogY29uY2F0ZW5hdGlvbiAqKVxuICAgIHwgU2luZ2wgKCoqIGVtcHR5IHdvcmQgc2luZ2xldG9uICopXG4gICAgfCBTdGFyIG9mIHRcblxuICBsZXQgbGV0dGVyIGEgPSBMZXR0ZXIgYVxuICBsZXQgdW5pb24gciBzID0gVW5pb24gKHIscylcbiAgbGV0IGVtcHR5ID0gRW1wdHlcbiAgbGV0IGNvbmNhdCByIHMgPSBDb25jYXQgKHIscylcbiAgbGV0IHN0YXIgciA9IFN0YXIgclxuXG4gIGxldCByZWMgdW5pb25zID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IEVtcHR5XG4gICAgfCBbcl0gLT4gclxuICAgIHwgcjo6bCAtPiB1bmlvbiByICh1bmlvbnMgbClcblxuKCpcbiAgbGV0IHJlYyB0b19zdHJpbmcgPSBmdW5jdGlvblxuICAgIHwgTGV0dGVyIGEgLT4gWC50b19zdHJpbmcgYVxuICAgIHwgVW5pb24gKHIscykgLT4gXCIoXCIgXiB0b19zdHJpbmcgciBeIFwiKSArIChcIiBeIHRvX3N0cmluZyBzIF4gXCIpXCJcbiAgICB8IEVtcHR5IC0+IFwiMFwiXG4gICAgfCBDb25jYXQgKHIscykgLT4gXCIoXCIgXiB0b19zdHJpbmcgciBeIFwiKShcIiBeIHRvX3N0cmluZyBzIF4gXCIpXCJcbiAgICB8IFNpbmdsIC0+IFwiMVwiXG4gICAgfCBTdGFyIHIgLT4gXCIoXCIgXiB0b19zdHJpbmcgciBeIFwiKSpcIlxuKilcbiAgICAgICAgICAgICAgICAgICAgXG4gIGxldCB0b19zdHJpbmcgciA9XG4gICAgKCogbGV2ZWw6IDA6KyAvIDE6eCAvIDI6KiAqKVxuICAgIGxldCByZWMgYXV4IGwgciA9XG4gICAgICBsZXQgcGEgbCcgcyA9IGlmIGwnIDwgbCB0aGVuIFwiKFwiIF4gcyBeIFwiKVwiIGVsc2UgcyBpblxuICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICB8IExldHRlciBhIC0+IFgudG9fc3RyaW5nIGFcbiAgICAgIHwgVW5pb24gKHIscykgLT4gcGEgMCAoYXV4IDAgciBeIFwiK1wiIF4gYXV4IDAgcylcbiAgICAgIHwgRW1wdHkgLT4gXCIwXCJcbiAgICAgIHwgQ29uY2F0IChyLHMpIC0+IHBhIDEgKGF1eCAxIHIgXiBcIi5cIiBeIGF1eCAxIHMpXG4gICAgICB8IFNpbmdsIC0+IFwiMVwiXG4gICAgICB8IFN0YXIgciAtPiBhdXggMiByIF4gXCIqXCJcbiAgICBpblxuICAgIGF1eCAoLTEpIHIgICAgICBcblxuICBsZXQgcmVjIHNpbXBsID0gZnVuY3Rpb25cbiAgICB8IFVuaW9uIChFbXB0eSwgcikgLT4gc2ltcGwgclxuICAgIHwgVW5pb24gKHIsIEVtcHR5KSAtPiBzaW1wbCByXG4gICAgfCBVbmlvbiAociwgcykgLT4gVW5pb24gKHNpbXBsIHIsIHNpbXBsIHMpXG4gICAgfCBDb25jYXQgKEVtcHR5LCByKSAtPiBFbXB0eVxuICAgIHwgQ29uY2F0IChyLCBFbXB0eSkgLT4gRW1wdHlcbiAgICB8IENvbmNhdCAoU2luZ2wsIHIpIC0+IHNpbXBsIHJcbiAgICB8IENvbmNhdCAociwgU2luZ2wpIC0+IHNpbXBsIHJcbiAgICB8IENvbmNhdCAociwgcykgLT4gQ29uY2F0IChzaW1wbCByLCBzaW1wbCBzKVxuICAgIHwgU3RhciBFbXB0eSAtPiBFbXB0eVxuICAgIHwgU3RhciByIC0+IFN0YXIgKHNpbXBsIHIpXG4gICAgfCBMZXR0ZXIgXyB8IEVtcHR5IHwgU2luZ2wgYXMgciAtPiByXG5cbiAgbGV0IHNpbXBsIHIgPVxuICAgIGxldCByZWMgZml4IGYgeCA9XG4gICAgICBsZXQgeSA9IGYgeCBpblxuICAgICAgaWYgeSA9IHggdGhlbiB4XG4gICAgICBlbHNlIGZpeCBmIHlcbiAgICBpblxuICAgIGZpeCBzaW1wbCByXG5cbiAgbW9kdWxlIFNlcmllcyA9IFNlcmllcy5NYWtlKEZpZWxkLkludClcblxuICAoKiogR2VuZXJhdGluZyBzZXJpZXMgb2YgYSByZWd1bGFyIGV4cHJlc3Npb24uIFRoaXMgZXhwcmVzc2lvbiBpcyBhc3N1bWVkIHRvXG4gIGJlIHVuYW1iaWd1b3VzLiAqKVxuICBsZXQgcmVjIHNlcmllcyA9IGZ1bmN0aW9uXG4gICAgfCBMZXR0ZXIgYSAtPiBTZXJpZXMudmFyXG4gICAgfCBVbmlvbiAoYSwgYikgLT4gU2VyaWVzLmFkZCAoc2VyaWVzIGEpIChzZXJpZXMgYilcbiAgICB8IEVtcHR5IC0+IFNlcmllcy56ZXJvXG4gICAgfCBDb25jYXQgKGEsIGIpIC0+IFNlcmllcy5tdWwgKHNlcmllcyBhKSAoc2VyaWVzIGIpXG4gICAgfCBTaW5nbCAtPiBTZXJpZXMub25lXG4gICAgfCBTdGFyIGEgLT4gU2VyaWVzLnN0YXIgKHNlcmllcyBhKVxuZW5kXG5cbm1vZHVsZSBTdGF0ZSA9IEFscGhhYmV0LkludFxuXG5tb2R1bGUgTWFrZSAoWCA6IEFscGhhYmV0LlQpID0gc3RydWN0XG4gIG1vZHVsZSBTdGF0ZXMgPSBBbHBoYWJldC5Qb3coU3RhdGUpXG4gIG1vZHVsZSBUID0gQWxwaGFiZXQuTWFwKEFscGhhYmV0LlByb2QoU3RhdGUpKFgpKShTdGF0ZXMpXG4gIG1vZHVsZSBSZWdleHAgPSBSZWdleHAoWClcblxuICB0eXBlIHQgPVxuICAgIHtcbiAgICAgIHN0YXRlcyA6IGludDtcbiAgICAgIGluaXRpYWwgOiBTdGF0ZS50O1xuICAgICAgdGVybWluYWwgOiBTdGF0ZXMudDtcbiAgICAgIHRyYW5zaXRpb25zIDogVC50O1xuICAgIH1cblxuICBsZXQgc3RhdGVzIGF1dCA9IGF1dC5zdGF0ZXNcblxuICBsZXQgdHJhbnMgYXV0IGEgeCA9XG4gICAgdHJ5XG4gICAgICBULmFwcCBhdXQudHJhbnNpdGlvbnMgKGEseClcbiAgICB3aXRoXG4gICAgfCBOb3RfZm91bmQgLT4gU3RhdGVzLmVtcHR5XG5cbiAgbGV0IGFkZF90cmFuc2l0aW9uIGF1dCBhIHggKGIgOiBTdGF0ZS50KSA9XG4gICAgbGV0IGJiID0gdHJhbnMgYXV0IGEgeCBpblxuICAgIGxldCBiYiA9IFN0YXRlcy5hZGQgYmIgYiBpblxuICAgIGxldCB0cmFuc2l0aW9ucyA9IFQuYWRkIGF1dC50cmFuc2l0aW9ucyAoYSx4KSBiYiBpblxuICAgIHsgYXV0IHdpdGggdHJhbnNpdGlvbnMgfVxuXG4gIGxldCBjcmVhdGUgc3RhdGVzIGluaXRpYWwgdGVybWluYWwgdHJhbnNpdGlvbnMgPVxuICAgIGxldCB0ZXJtaW5hbCA9IFN0YXRlcy5vZl9saXN0IHRlcm1pbmFsIGluXG4gICAgbGV0IGFucyA9IHsgc3RhdGVzOyBpbml0aWFsOyB0ZXJtaW5hbDsgdHJhbnNpdGlvbnMgPSBULmVtcHR5IH0gaW5cbiAgICBMaXN0LmZvbGRfbGVmdCAoZnVuIGFucyAoYSx4LGIpIC0+IGFkZF90cmFuc2l0aW9uIGFucyBhIHggYikgYW5zIHRyYW5zaXRpb25zXG5cbiAgbGV0IGtsZWVuZSBhdXQgPVxuICAgIGxldCBuID0gc3RhdGVzIGF1dCBpblxuICAgIGxldCBpbml0IGYgPSBBcnJheS5pbml0IG4gKGZ1biBpIC0+IEFycmF5LmluaXQgbiAoZnVuIGogLT4gZiBpIGopKSBpblxuICAgIGxldCByciA9XG4gICAgICBpbml0XG4gICAgICAgIChmdW4gaSBqIC0+XG4gICAgICAgICAgbGV0IHIgPSByZWYgUmVnZXhwLmVtcHR5IGluXG4gICAgICAgICAgVC5pdGVyIChmdW4gKGknLGEpIGpqIC0+XG4gICAgICAgICAgICAgIGlmIFN0YXRlLmVxIGkgaScgJiYgU3RhdGVzLm1lbSBqaiBqIHRoZW4gciA6PSBSZWdleHAudW5pb24gIXIgKFJlZ2V4cC5sZXR0ZXIgYSlcbiAgICAgICAgICAgICkgYXV0LnRyYW5zaXRpb25zO1xuICAgICAgICAgIGlmIGkgPSBqIHRoZW4gciA6PSBSZWdleHAudW5pb24gUmVnZXhwLmVtcHR5ICFyO1xuICAgICAgICAgICFyXG4gICAgICAgIClcbiAgICBpblxuICAgIGxldCByciA9IHJlZiByciBpblxuICAgIGZvciBrID0gMCB0byBuIC0gMSBkb1xuICAgICAgbGV0IHNzID1cbiAgICAgICAgbGV0IHJyID0gIXJyIGluXG4gICAgICAgIGluaXRcbiAgICAgICAgICAoZnVuIGkgaiAtPlxuICAgICAgICAgICAgUmVnZXhwLnVuaW9uXG4gICAgICAgICAgICAgIHJyLihpKS4oailcbiAgICAgICAgICAgICAgKFJlZ2V4cC5jb25jYXQgcnIuKGkpLihrKSAoUmVnZXhwLmNvbmNhdCAoUmVnZXhwLnN0YXIgcnIuKGspLihrKSkgcnIuKGspLihqKSkpXG4gICAgICAgICAgKVxuICAgICAgaW5cbiAgICAgIHJyIDo9IHNzXG4gICAgZG9uZTtcbiAgICBsZXQgcnIgPSAhcnIgaW5cbiAgICBsZXQgciA9IHJlZiBSZWdleHAuZW1wdHkgaW5cbiAgICBsZXQgaSA9IGF1dC5pbml0aWFsIGluXG4gICAgU3RhdGVzLml0ZXIgKGZ1biBqIC0+IHIgOj0gUmVnZXhwLnVuaW9uICFyIHJyLihpKS4oaikpIGF1dC50ZXJtaW5hbDtcbiAgICAhclxuZW5kXG4iLCIoKiBnZW5lcmF0ZWQgYnkgZHVuZSAqKVxuXG4oKiogQGNhbm9uaWNhbCBKc29vX3J1bnRpbWUuUnVudGltZV92ZXJzaW9uICopXG5tb2R1bGUgUnVudGltZV92ZXJzaW9uID0gSnNvb19ydW50aW1lX19SdW50aW1lX3ZlcnNpb25cblxubW9kdWxlIEpzb29fcnVudGltZV9fID0gc3RydWN0IGVuZFxuW0BAZGVwcmVjYXRlZCBcInRoaXMgbW9kdWxlIGlzIHNoYWRvd2VkXCJdXG4iLCJtb2R1bGUgSnMgPSBzdHJ1Y3RcbiAgdHlwZSB0XG5cbiAgdHlwZSAnYSBqc19hcnJheSA9IHRcblxuICB0eXBlICgnYSwgJ2IpIG1ldGhfY2FsbGJhY2sgPSB0XG5cbiAgZXh0ZXJuYWwgc3RyaW5nIDogc3RyaW5nIC0+IHQgPSBcImNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXCJcblxuICBleHRlcm5hbCB0b19zdHJpbmcgOiB0IC0+IHN0cmluZyA9IFwiY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcIlxuXG4gIGV4dGVybmFsIGJ5dGVzdHJpbmcgOiBzdHJpbmcgLT4gdCA9IFwiY2FtbF9qc2J5dGVzX29mX3N0cmluZ1wiXG5cbiAgZXh0ZXJuYWwgdG9fYnl0ZXN0cmluZyA6IHQgLT4gc3RyaW5nID0gXCJjYW1sX3N0cmluZ19vZl9qc2J5dGVzXCJcblxuICBleHRlcm5hbCBib29sIDogYm9vbCAtPiB0ID0gXCJjYW1sX2pzX2Zyb21fYm9vbFwiXG5cbiAgZXh0ZXJuYWwgdG9fYm9vbCA6IHQgLT4gYm9vbCA9IFwiY2FtbF9qc190b19ib29sXCJcblxuICBleHRlcm5hbCBhcnJheSA6ICdhIGFycmF5IC0+IHQgPSBcImNhbWxfanNfZnJvbV9hcnJheVwiXG5cbiAgZXh0ZXJuYWwgdG9fYXJyYXkgOiB0IC0+ICdhIGFycmF5ID0gXCJjYW1sX2pzX3RvX2FycmF5XCJcblxuICBleHRlcm5hbCBudW1iZXJfb2ZfZmxvYXQgOiBmbG9hdCAtPiB0ID0gXCJjYW1sX2pzX2Zyb21fZmxvYXRcIlxuXG4gIGV4dGVybmFsIGZsb2F0X29mX251bWJlciA6IHQgLT4gZmxvYXQgPSBcImNhbWxfanNfdG9fZmxvYXRcIlxuXG4gIGV4dGVybmFsIHR5cGVvZiA6IHQgLT4gdCA9IFwiY2FtbF9qc190eXBlb2ZcIlxuXG4gIGV4dGVybmFsIGluc3RhbmNlb2YgOiB0IC0+IHQgLT4gYm9vbCA9IFwiY2FtbF9qc19pbnN0YW5jZW9mXCJcblxuICBleHRlcm5hbCBkZWJ1Z2dlciA6IHVuaXQgLT4gdW5pdCA9IFwiZGVidWdnZXJcIlxuXG4gIGV4dGVybmFsIGdldCA6IHQgLT4gdCAtPiB0ID0gXCJjYW1sX2pzX2dldFwiXG5cbiAgZXh0ZXJuYWwgc2V0IDogdCAtPiB0IC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9qc19zZXRcIlxuXG4gIGV4dGVybmFsIGRlbGV0ZSA6IHQgLT4gdCAtPiB1bml0ID0gXCJjYW1sX2pzX2RlbGV0ZVwiXG5cbiAgZXh0ZXJuYWwgY2FsbCA6IHQgLT4gdCAtPiB0IGFycmF5IC0+IHQgPSBcImNhbWxfanNfY2FsbFwiXG5cbiAgZXh0ZXJuYWwgZnVuX2NhbGwgOiB0IC0+IHQgYXJyYXkgLT4gdCA9IFwiY2FtbF9qc19mdW5fY2FsbFwiXG5cbiAgZXh0ZXJuYWwgbWV0aF9jYWxsIDogdCAtPiBzdHJpbmcgLT4gdCBhcnJheSAtPiB0ID0gXCJjYW1sX2pzX21ldGhfY2FsbFwiXG5cbiAgZXh0ZXJuYWwgbmV3X29iaiA6IHQgLT4gdCBhcnJheSAtPiB0ID0gXCJjYW1sX2pzX25ld1wiXG5cbiAgZXh0ZXJuYWwgbmV3X29ial9hcnIgOiB0IC0+IHQganNfYXJyYXkgLT4gdCA9IFwiY2FtbF9vanNfbmV3X2FyclwiXG5cbiAgZXh0ZXJuYWwgb2JqIDogKHN0cmluZyAqIHQpIGFycmF5IC0+IHQgPSBcImNhbWxfanNfb2JqZWN0XCJcblxuICBleHRlcm5hbCBlcXVhbHMgOiB0IC0+IHQgLT4gYm9vbCA9IFwiY2FtbF9qc19lcXVhbHNcIlxuXG4gIGV4dGVybmFsIHB1cmVfZXhwciA6ICh1bml0IC0+ICdhKSAtPiAnYSA9IFwiY2FtbF9qc19wdXJlX2V4cHJcIlxuXG4gIGV4dGVybmFsIGV2YWxfc3RyaW5nIDogc3RyaW5nIC0+ICdhID0gXCJjYW1sX2pzX2V2YWxfc3RyaW5nXCJcblxuICBleHRlcm5hbCBqc19leHByIDogc3RyaW5nIC0+ICdhID0gXCJjYW1sX2pzX2V4cHJcIlxuXG4gIGV4dGVybmFsIHB1cmVfanNfZXhwciA6IHN0cmluZyAtPiAnYSA9IFwiY2FtbF9wdXJlX2pzX2V4cHJcIlxuXG4gIGV4dGVybmFsIGNhbGxiYWNrIDogKCdiIC0+ICdhKSAtPiAoJ2IsICdhKSBtZXRoX2NhbGxiYWNrXG4gICAgPSBcImNhbWxfanNfd3JhcF9jYWxsYmFja191bnNhZmVcIlxuXG4gIGV4dGVybmFsIGNhbGxiYWNrX3dpdGhfYXJndW1lbnRzIDpcbiAgICAodCBqc19hcnJheSAtPiAnYikgLT4gKCdjLCB0IGpzX2FycmF5IC0+ICdiKSBtZXRoX2NhbGxiYWNrXG4gICAgPSBcImNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHNcIlxuXG4gIGV4dGVybmFsIGNhbGxiYWNrX3dpdGhfYXJpdHkgOiBpbnQgLT4gKCdhIC0+ICdiKSAtPiAoJ2MsICdhIC0+ICdiKSBtZXRoX2NhbGxiYWNrXG4gICAgPSBcImNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3RcIlxuXG4gIGV4dGVybmFsIG1ldGhfY2FsbGJhY2sgOiAoJ2IgLT4gJ2EpIC0+ICgnYiwgJ2EpIG1ldGhfY2FsbGJhY2tcbiAgICA9IFwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlXCJcblxuICBleHRlcm5hbCBtZXRoX2NhbGxiYWNrX3dpdGhfYXJpdHkgOiBpbnQgLT4gKCdiIC0+ICdhKSAtPiAoJ2IsICdhKSBtZXRoX2NhbGxiYWNrXG4gICAgPSBcImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdFwiXG5cbiAgZXh0ZXJuYWwgbWV0aF9jYWxsYmFja193aXRoX2FyZ3VtZW50cyA6XG4gICAgKCdiIC0+IHQganNfYXJyYXkgLT4gJ2EpIC0+ICgnYiwgdCBqc19hcnJheSAtPiAnYSkgbWV0aF9jYWxsYmFja1xuICAgID0gXCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHNcIlxuXG4gIGV4dGVybmFsIHdyYXBfY2FsbGJhY2sgOiAoJ2EgLT4gJ2IpIC0+ICgnYywgJ2EgLT4gJ2IpIG1ldGhfY2FsbGJhY2tcbiAgICA9IFwiY2FtbF9qc193cmFwX2NhbGxiYWNrXCJcblxuICBleHRlcm5hbCB3cmFwX21ldGhfY2FsbGJhY2sgOiAoJ2EgLT4gJ2IpIC0+ICgnYSwgJ2IpIG1ldGhfY2FsbGJhY2tcbiAgICA9IFwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tcIlxuZW5kXG5cbm1vZHVsZSBTeXMgPSBzdHJ1Y3RcbiAgdHlwZSAnYSBjYWxsYmFjayA9ICdhXG5cbiAgZXh0ZXJuYWwgY3JlYXRlX2ZpbGUgOiBuYW1lOnN0cmluZyAtPiBjb250ZW50OnN0cmluZyAtPiB1bml0ID0gXCJjYW1sX2NyZWF0ZV9maWxlXCJcblxuICBleHRlcm5hbCByZWFkX2ZpbGUgOiBuYW1lOnN0cmluZyAtPiBzdHJpbmcgPSBcImNhbWxfcmVhZF9maWxlX2NvbnRlbnRcIlxuXG4gIGV4dGVybmFsIHNldF9jaGFubmVsX291dHB1dCcgOiBvdXRfY2hhbm5lbCAtPiAoanNfc3RyaW5nOkpzLnQgLT4gdW5pdCkgY2FsbGJhY2sgLT4gdW5pdFxuICAgID0gXCJjYW1sX21sX3NldF9jaGFubmVsX291dHB1dFwiXG5cbiAgZXh0ZXJuYWwgc2V0X2NoYW5uZWxfaW5wdXQnIDogaW5fY2hhbm5lbCAtPiAodW5pdCAtPiBzdHJpbmcpIGNhbGxiYWNrIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGxcIlxuXG4gIGV4dGVybmFsIG1vdW50X3BvaW50IDogdW5pdCAtPiBzdHJpbmcgbGlzdCA9IFwiY2FtbF9saXN0X21vdW50X3BvaW50XCJcblxuICBleHRlcm5hbCBtb3VudF9hdXRvbG9hZCA6IHN0cmluZyAtPiAoc3RyaW5nIC0+IHN0cmluZyAtPiBzdHJpbmcgb3B0aW9uKSBjYWxsYmFjayAtPiB1bml0XG4gICAgPSBcImNhbWxfbW91bnRfYXV0b2xvYWRcIlxuXG4gIGV4dGVybmFsIHVubW91bnQgOiBzdHJpbmcgLT4gdW5pdCA9IFwiY2FtbF91bm1vdW50XCJcblxuICBtb2R1bGUgQ29uZmlnID0gc3RydWN0XG4gICAgZXh0ZXJuYWwgdXNlX2pzX3N0cmluZyA6IHVuaXQgLT4gYm9vbCA9IFwiY2FtbF9qc29vX2ZsYWdzX3VzZV9qc19zdHJpbmdcIlxuXG4gICAgZXh0ZXJuYWwgZWZmZWN0cyA6IHVuaXQgLT4gYm9vbCA9IFwiY2FtbF9qc29vX2ZsYWdzX2VmZmVjdHNcIlxuICBlbmRcblxuICBsZXQgdmVyc2lvbiA9IFJ1bnRpbWVfdmVyc2lvbi5zXG5cbiAgbGV0IGdpdF92ZXJzaW9uID0gUnVudGltZV92ZXJzaW9uLmdpdF92ZXJzaW9uXG5lbmRcblxubW9kdWxlIEVycm9yIDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCByYWlzZV8gOiB0IC0+ICdhXG5cbiAgdmFsIGF0dGFjaF9qc19iYWNrdHJhY2UgOiBleG4gLT4gZm9yY2U6Ym9vbCAtPiBleG5cbiAgKCoqIEF0dGFjaCBhIEphdmFzU2NyaXB0IGVycm9yIHRvIGFuIE9DYW1sIGV4Y2VwdGlvbi4gIGlmIFtmb3JjZSA9IGZhbHNlXSBhbmQgYVxuICAgIEphdmFzU2NyaXB0IGVycm9yIGlzIGFscmVhZHkgYXR0YWNoZWQsIGl0IHdpbGwgZG8gbm90aGluZy4gVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgdG9cbiAgICBzdG9yZSBhbmQgcmV0cmlldmUgaW5mb3JtYXRpb24gYWJvdXQgSmF2YVNjcmlwdCBzdGFjayB0cmFjZXMuXG5cbiAgICBBdHRhY2hpbmcgSmF2YXNTY3JpcHQgZXJyb3JzIHdpbGwgaGFwcGVuIGF1dG9tYXRpY2FsbHkgd2hlbiBjb21waWxpbmcgd2l0aFxuICAgIFstLWVuYWJsZSB3aXRoLWpzLWVycm9yXS4gKilcblxuICB2YWwgb2ZfZXhuIDogZXhuIC0+IHQgb3B0aW9uXG4gICgqKiBFeHRyYWN0IGEgSmF2YVNjcmlwdCBlcnJvciBhdHRhY2hlZCB0byBhbiBPQ2FtbCBleGNlcHRpb24sIGlmIGFueS4gIFRoaXMgaXMgdXNlZnVsIHRvXG4gICAgICBpbnNwZWN0IGFuIGV2ZW50dWFsIHN0YWNrIHN0cmFjZSwgZXNwZWNpYWxseSB3aGVuIHNvdXJjZW1hcCBpcyBlbmFibGVkLiAqKVxuXG4gIGV4Y2VwdGlvbiBFeG4gb2YgdFxuICAoKiogVGhlIFtFcnJvcl0gZXhjZXB0aW9uIHdyYXAgamF2YXNjcmlwdCBleGNlcHRpb25zIHdoZW4gY2F1Z2h0IGJ5IE9DYW1sIGNvZGUuXG4gICAgICBJbiBjYXNlIHRoZSBqYXZhc2NyaXB0IGV4Y2VwdGlvbiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgamF2YXNjcmlwdCBbRXJyb3JdLFxuICAgICAgaXQgd2lsbCBiZSBzZXJpYWxpemVkIGFuZCB3cmFwcGVkIGludG8gYSBbRmFpbHVyZV0gZXhjZXB0aW9uLlxuICAqKVxuZW5kID0gc3RydWN0XG4gIHR5cGUgdFxuXG4gIGV4Y2VwdGlvbiBFeG4gb2YgdFxuXG4gIGxldCBfID0gQ2FsbGJhY2sucmVnaXN0ZXJfZXhjZXB0aW9uIFwianNFcnJvclwiIChFeG4gKE9iai5tYWdpYyBbfHxdKSlcblxuICBsZXQgcmFpc2VfIDogdCAtPiAnYSA9IEpzLmpzX2V4cHIgXCIoZnVuY3Rpb24gKGV4bikgeyB0aHJvdyBleG4gfSlcIlxuXG4gIGV4dGVybmFsIG9mX2V4biA6IGV4biAtPiB0IG9wdGlvbiA9IFwiY2FtbF9qc19lcnJvcl9vcHRpb25fb2ZfZXhjZXB0aW9uXCJcblxuICBleHRlcm5hbCBhdHRhY2hfanNfYmFja3RyYWNlIDogZXhuIC0+IGZvcmNlOmJvb2wgLT4gZXhuID0gXCJjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZVwiXG5lbmRcblxuW0BAQG9jYW1sLndhcm5pbmcgXCItMzItNjBcIl1cblxubW9kdWxlIEZvcl9jb21wYXRpYmlsaXR5X29ubHkgPSBzdHJ1Y3RcbiAgKCogQWRkIHByaW1pdGl2ZXMgZm9yIGNvbXBhdGliaWxpdHkgcmVhc29ucy4gRXhpc3RpbmcgdXNlcnMgbWlnaHRcbiAgICAgZGVwZW5kIG9uIGl0IChlLmcuIGdlbl9qc19hcGkpLCB3ZSBkb250IHdhbnQgdGhlIG9jYW1sIGNvbXBpbGVyXG4gICAgIHRvIGNvbXBsYWluIGFib3V0IHRoZXNlcyBtaXNzaW5nIHByaW1pdGl2ZXMuICopXG5cbiAgZXh0ZXJuYWwgY2FtbF9qc19mcm9tX3N0cmluZyA6IHN0cmluZyAtPiBKcy50ID0gXCJjYW1sX2pzX2Zyb21fc3RyaW5nXCJcblxuICBleHRlcm5hbCBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIDogSnMudCAtPiBzdHJpbmcgPSBcImNhbWxfanNfdG9fYnl0ZV9zdHJpbmdcIlxuXG4gIGV4dGVybmFsIGNhbWxfanNfdG9fc3RyaW5nIDogSnMudCAtPiBzdHJpbmcgPSBcImNhbWxfanNfdG9fc3RyaW5nXCJcblxuICBleHRlcm5hbCBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkgOiAnYSBKcy5qc19hcnJheSAtPiAnYSBsaXN0ID0gXCJjYW1sX2xpc3Rfb2ZfanNfYXJyYXlcIlxuXG4gIGV4dGVybmFsIGNhbWxfbGlzdF90b19qc19hcnJheSA6ICdhIGxpc3QgLT4gJ2EgSnMuanNfYXJyYXkgPSBcImNhbWxfbGlzdF90b19qc19hcnJheVwiXG5cbiAgZXh0ZXJuYWwgdmFyaWFibGUgOiBzdHJpbmcgLT4gJ2EgPSBcImNhbWxfanNfdmFyXCJcbmVuZFxuXG5tb2R1bGUgVHlwZWRfYXJyYXkgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB0eXBlZEFycmF5ID0gSnMudFxuXG4gIHR5cGUgYXJyYXlCdWZmZXIgPSBKcy50XG5cbiAgdHlwZSB1aW50OEFycmF5ID0gSnMudFxuXG4gIGV4dGVybmFsIGtpbmQgOiAoJ2EsICdiKSB0eXBlZEFycmF5IC0+ICgnYSwgJ2IpIEJpZ2FycmF5LmtpbmRcbiAgICA9IFwiY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5XCJcblxuICBleHRlcm5hbCBmcm9tX2dlbmFycmF5IDpcbiAgICAoJ2EsICdiLCBCaWdhcnJheS5jX2xheW91dCkgQmlnYXJyYXkuR2VuYXJyYXkudCAtPiAoJ2EsICdiKSB0eXBlZEFycmF5XG4gICAgPSBcImNhbWxfYmFfdG9fdHlwZWRfYXJyYXlcIlxuXG4gIGV4dGVybmFsIHRvX2dlbmFycmF5IDpcbiAgICAoJ2EsICdiKSB0eXBlZEFycmF5IC0+ICgnYSwgJ2IsIEJpZ2FycmF5LmNfbGF5b3V0KSBCaWdhcnJheS5HZW5hcnJheS50XG4gICAgPSBcImNhbWxfYmFfZnJvbV90eXBlZF9hcnJheVwiXG5cbiAgbW9kdWxlIEJpZ3N0cmluZyA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IChjaGFyLCBCaWdhcnJheS5pbnQ4X3Vuc2lnbmVkX2VsdCwgQmlnYXJyYXkuY19sYXlvdXQpIEJpZ2FycmF5LkFycmF5MS50XG5cbiAgICBleHRlcm5hbCB0b19hcnJheUJ1ZmZlciA6IHQgLT4gYXJyYXlCdWZmZXIgPSBcImJpZ3N0cmluZ190b19hcnJheV9idWZmZXJcIlxuXG4gICAgZXh0ZXJuYWwgdG9fdWludDhBcnJheSA6IHQgLT4gdWludDhBcnJheSA9IFwiYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5XCJcblxuICAgIGV4dGVybmFsIG9mX2FycmF5QnVmZmVyIDogYXJyYXlCdWZmZXIgLT4gdCA9IFwiYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlclwiXG5cbiAgICBleHRlcm5hbCBvZl91aW50OEFycmF5IDogdWludDhBcnJheSAtPiB0ID0gXCJiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXlcIlxuICBlbmRcblxuICBleHRlcm5hbCBvZl91aW50OEFycmF5IDogdWludDhBcnJheSAtPiBzdHJpbmcgPSBcImNhbWxfc3RyaW5nX29mX2FycmF5XCJcbmVuZFxuXG5tb2R1bGUgSW50NjQgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgY3JlYXRlX2ludDY0X2xvX21pX2hpIDogaW50IC0+IGludCAtPiBpbnQgLT4gSW50NjQudFxuICAgID0gXCJjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaVwiXG5lbmRcbiIsIigqIGdlbmVyYXRlZCBieSBkdW5lICopXG5cbigqKiBAY2Fub25pY2FsIEpzX29mX29jYW1sLkNTUyAqKVxubW9kdWxlIENTUyA9IEpzX29mX29jYW1sX19DU1NcblxuKCoqIEBjYW5vbmljYWwgSnNfb2Zfb2NhbWwuRG9tICopXG5tb2R1bGUgRG9tID0gSnNfb2Zfb2NhbWxfX0RvbVxuXG4oKiogQGNhbm9uaWNhbCBKc19vZl9vY2FtbC5Eb21fZXZlbnRzICopXG5tb2R1bGUgRG9tX2V2ZW50cyA9IEpzX29mX29jYW1sX19Eb21fZXZlbnRzXG5cbigqKiBAY2Fub25pY2FsIEpzX29mX29jYW1sLkRvbV9odG1sICopXG5tb2R1bGUgRG9tX2h0bWwgPSBKc19vZl9vY2FtbF9fRG9tX2h0bWxcblxuKCoqIEBjYW5vbmljYWwgSnNfb2Zfb2NhbWwuRG9tX3N2ZyAqKVxubW9kdWxlIERvbV9zdmcgPSBKc19vZl9vY2FtbF9fRG9tX3N2Z1xuXG4oKiogQGNhbm9uaWNhbCBKc19vZl9vY2FtbC5FdmVudFNvdXJjZSAqKVxubW9kdWxlIEV2ZW50U291cmNlID0gSnNfb2Zfb2NhbWxfX0V2ZW50U291cmNlXG5cbigqKiBAY2Fub25pY2FsIEpzX29mX29jYW1sLkZpbGUgKilcbm1vZHVsZSBGaWxlID0gSnNfb2Zfb2NhbWxfX0ZpbGVcblxuKCoqIEBjYW5vbmljYWwgSnNfb2Zfb2NhbWwuRmlyZWJ1ZyAqKVxubW9kdWxlIEZpcmVidWcgPSBKc19vZl9vY2FtbF9fRmlyZWJ1Z1xuXG4oKiogQGNhbm9uaWNhbCBKc19vZl9vY2FtbC5Gb3JtICopXG5tb2R1bGUgRm9ybSA9IEpzX29mX29jYW1sX19Gb3JtXG5cbigqKiBAY2Fub25pY2FsIEpzX29mX29jYW1sLkdlb2xvY2F0aW9uICopXG5tb2R1bGUgR2VvbG9jYXRpb24gPSBKc19vZl9vY2FtbF9fR2VvbG9jYXRpb25cblxuKCoqIEBjYW5vbmljYWwgSnNfb2Zfb2NhbWwuSW1wb3J0ICopXG5tb2R1bGUgSW1wb3J0ID0gSnNfb2Zfb2NhbWxfX0ltcG9ydFxuXG4oKiogQGNhbm9uaWNhbCBKc19vZl9vY2FtbC5JbnRlcnNlY3Rpb25PYnNlcnZlciAqKVxubW9kdWxlIEludGVyc2VjdGlvbk9ic2VydmVyID0gSnNfb2Zfb2NhbWxfX0ludGVyc2VjdGlvbk9ic2VydmVyXG5cbigqKiBAY2Fub25pY2FsIEpzX29mX29jYW1sLkludGwgKilcbm1vZHVsZSBJbnRsID0gSnNfb2Zfb2NhbWxfX0ludGxcblxuKCoqIEBjYW5vbmljYWwgSnNfb2Zfb2NhbWwuSnMgKilcbm1vZHVsZSBKcyA9IEpzX29mX29jYW1sX19Kc1xuXG4oKiogQGNhbm9uaWNhbCBKc19vZl9vY2FtbC5Kc29uICopXG5tb2R1bGUgSnNvbiA9IEpzX29mX29jYW1sX19Kc29uXG5cbigqKiBAY2Fub25pY2FsIEpzX29mX29jYW1sLkpzdGFibGUgKilcbm1vZHVsZSBKc3RhYmxlID0gSnNfb2Zfb2NhbWxfX0pzdGFibGVcblxuKCoqIEBjYW5vbmljYWwgSnNfb2Zfb2NhbWwuTGliX3ZlcnNpb24gKilcbm1vZHVsZSBMaWJfdmVyc2lvbiA9IEpzX29mX29jYW1sX19MaWJfdmVyc2lvblxuXG4oKiogQGNhbm9uaWNhbCBKc19vZl9vY2FtbC5NdXRhdGlvbk9ic2VydmVyICopXG5tb2R1bGUgTXV0YXRpb25PYnNlcnZlciA9IEpzX29mX29jYW1sX19NdXRhdGlvbk9ic2VydmVyXG5cbigqKiBAY2Fub25pY2FsIEpzX29mX29jYW1sLlBlcmZvcm1hbmNlT2JzZXJ2ZXIgKilcbm1vZHVsZSBQZXJmb3JtYW5jZU9ic2VydmVyID0gSnNfb2Zfb2NhbWxfX1BlcmZvcm1hbmNlT2JzZXJ2ZXJcblxuKCoqIEBjYW5vbmljYWwgSnNfb2Zfb2NhbWwuUmVnZXhwICopXG5tb2R1bGUgUmVnZXhwID0gSnNfb2Zfb2NhbWxfX1JlZ2V4cFxuXG4oKiogQGNhbm9uaWNhbCBKc19vZl9vY2FtbC5SZXNpemVPYnNlcnZlciAqKVxubW9kdWxlIFJlc2l6ZU9ic2VydmVyID0gSnNfb2Zfb2NhbWxfX1Jlc2l6ZU9ic2VydmVyXG5cbigqKiBAY2Fub25pY2FsIEpzX29mX29jYW1sLlN5c19qcyAqKVxubW9kdWxlIFN5c19qcyA9IEpzX29mX29jYW1sX19TeXNfanNcblxuKCoqIEBjYW5vbmljYWwgSnNfb2Zfb2NhbWwuVHlwZWRfYXJyYXkgKilcbm1vZHVsZSBUeXBlZF9hcnJheSA9IEpzX29mX29jYW1sX19UeXBlZF9hcnJheVxuXG4oKiogQGNhbm9uaWNhbCBKc19vZl9vY2FtbC5VcmwgKilcbm1vZHVsZSBVcmwgPSBKc19vZl9vY2FtbF9fVXJsXG5cbigqKiBAY2Fub25pY2FsIEpzX29mX29jYW1sLldlYkdMICopXG5tb2R1bGUgV2ViR0wgPSBKc19vZl9vY2FtbF9fV2ViR0xcblxuKCoqIEBjYW5vbmljYWwgSnNfb2Zfb2NhbWwuV2ViU29ja2V0cyAqKVxubW9kdWxlIFdlYlNvY2tldHMgPSBKc19vZl9vY2FtbF9fV2ViU29ja2V0c1xuXG4oKiogQGNhbm9uaWNhbCBKc19vZl9vY2FtbC5Xb3JrZXIgKilcbm1vZHVsZSBXb3JrZXIgPSBKc19vZl9vY2FtbF9fV29ya2VyXG5cbigqKiBAY2Fub25pY2FsIEpzX29mX29jYW1sLlhtbEh0dHBSZXF1ZXN0ICopXG5tb2R1bGUgWG1sSHR0cFJlcXVlc3QgPSBKc19vZl9vY2FtbF9fWG1sSHR0cFJlcXVlc3RcblxubW9kdWxlIEpzX29mX29jYW1sX18gPSBzdHJ1Y3QgZW5kXG5bQEBkZXByZWNhdGVkIFwidGhpcyBtb2R1bGUgaXMgc2hhZG93ZWRcIl1cbiIsIigqIEpzX29mX29jYW1sXG4gKiBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4gKiBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICogRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbiAqKVxuXG5tb2R1bGUgUG9seSA9IHN0cnVjdFxuICBleHRlcm5hbCAoIDwgKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG5cbiAgZXh0ZXJuYWwgKCA8PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG5cbiAgZXh0ZXJuYWwgKCA8PiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcblxuICBleHRlcm5hbCAoID0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5cbiAgZXh0ZXJuYWwgKCA+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuXG4gIGV4dGVybmFsICggPj0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuXG4gIGV4dGVybmFsIGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcblxuICBleHRlcm5hbCBlcXVhbCA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5lbmRcblxubW9kdWxlIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgKCA8ICkgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG5cbiAgZXh0ZXJuYWwgKCA8PSApIDogaW50IC0+IGludCAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcblxuICBleHRlcm5hbCAoIDw+ICkgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG5cbiAgZXh0ZXJuYWwgKCA9ICkgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5cbiAgZXh0ZXJuYWwgKCA+ICkgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG5cbiAgZXh0ZXJuYWwgKCA+PSApIDogaW50IC0+IGludCAtPiBib29sID0gXCIlZ3JlYXRlcmVxdWFsXCJcblxuICBleHRlcm5hbCBjb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVjb21wYXJlXCJcblxuICBleHRlcm5hbCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWVxdWFsXCJcblxuICBsZXQgbWF4ICh4IDogaW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcblxuICBsZXQgbWluICh4IDogaW50KSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgU3RyaW5nID0gc3RydWN0XG4gIGluY2x1ZGUgU3RyaW5nXG5cbiAgbGV0IGVxdWFsICh4IDogc3RyaW5nKSAoeSA6IHN0cmluZykgPSBQb2x5LmVxdWFsIHggeVxuZW5kXG5cbm1vZHVsZSBDaGFyID0gc3RydWN0XG4gIGluY2x1ZGUgQ2hhclxuXG4gIGxldCBlcXVhbCAoeCA6IGNoYXIpICh5IDogY2hhcikgPSBQb2x5LmVxdWFsIHggeVxuZW5kXG5cbmluY2x1ZGUgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwiKCogSnNfb2Zfb2NhbWwgbGlicmFyeVxuICogaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbiAqIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuICogTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbiAqIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICopXG5vcGVuISBJbXBvcnRcblxuKCogVGhpcyBsb2NhbCBtb2R1bGUgW0pzXSBpcyBuZWVkZWQgc28gdGhhdCB0aGUgcHB4X2pzIGV4dGVuc2lvbiB3b3JrIHdpdGhpbiB0aGF0IGZpbGUuICopXG5tb2R1bGUgSnMgPSBzdHJ1Y3RcbiAgdHlwZSArJ2EgdFxuXG4gIHR5cGUgKC0nYSwgKydiKSBtZXRoX2NhbGxiYWNrXG5cbiAgbW9kdWxlIFVuc2FmZSA9IHN0cnVjdFxuICAgIHR5cGUgdG9wXG5cbiAgICB0eXBlIGFueSA9IHRvcCB0XG5cbiAgICB0eXBlIGFueV9qc19hcnJheSA9IGFueVxuXG4gICAgZXh0ZXJuYWwgaW5qZWN0IDogJ2EgLT4gYW55ID0gXCIlaWRlbnRpdHlcIlxuXG4gICAgZXh0ZXJuYWwgY29lcmNlIDogXyB0IC0+IF8gdCA9IFwiJWlkZW50aXR5XCJcblxuICAgIGV4dGVybmFsIGdldCA6ICdhIC0+ICdiIC0+ICdjID0gXCJjYW1sX2pzX2dldFwiXG5cbiAgICBleHRlcm5hbCBzZXQgOiAnYSAtPiAnYiAtPiAnYyAtPiB1bml0ID0gXCJjYW1sX2pzX3NldFwiXG5cbiAgICBleHRlcm5hbCBkZWxldGUgOiAnYSAtPiAnYiAtPiB1bml0ID0gXCJjYW1sX2pzX2RlbGV0ZVwiXG5cbiAgICBleHRlcm5hbCBjYWxsIDogJ2EgLT4gJ2IgLT4gYW55IGFycmF5IC0+ICdjID0gXCJjYW1sX2pzX2NhbGxcIlxuXG4gICAgZXh0ZXJuYWwgZnVuX2NhbGwgOiAnYSAtPiBhbnkgYXJyYXkgLT4gJ2IgPSBcImNhbWxfanNfZnVuX2NhbGxcIlxuXG4gICAgZXh0ZXJuYWwgbWV0aF9jYWxsIDogJ2EgLT4gc3RyaW5nIC0+IGFueSBhcnJheSAtPiAnYiA9IFwiY2FtbF9qc19tZXRoX2NhbGxcIlxuXG4gICAgZXh0ZXJuYWwgbmV3X29iaiA6ICdhIC0+IGFueSBhcnJheSAtPiAnYiA9IFwiY2FtbF9qc19uZXdcIlxuXG4gICAgZXh0ZXJuYWwgbmV3X29ial9hcnIgOiAnYSAtPiBhbnlfanNfYXJyYXkgLT4gJ2IgPSBcImNhbWxfb2pzX25ld19hcnJcIlxuXG4gICAgZXh0ZXJuYWwgb2JqIDogKHN0cmluZyAqIGFueSkgYXJyYXkgLT4gJ2EgPSBcImNhbWxfanNfb2JqZWN0XCJcblxuICAgIGV4dGVybmFsIGVxdWFscyA6ICdhIC0+ICdiIC0+IGJvb2wgPSBcImNhbWxfanNfZXF1YWxzXCJcblxuICAgIGV4dGVybmFsIHB1cmVfZXhwciA6ICh1bml0IC0+ICdhKSAtPiAnYSA9IFwiY2FtbF9qc19wdXJlX2V4cHJcIlxuXG4gICAgZXh0ZXJuYWwgZXZhbF9zdHJpbmcgOiBzdHJpbmcgLT4gJ2EgPSBcImNhbWxfanNfZXZhbF9zdHJpbmdcIlxuXG4gICAgZXh0ZXJuYWwganNfZXhwciA6IHN0cmluZyAtPiAnYSA9IFwiY2FtbF9qc19leHByXCJcblxuICAgIGV4dGVybmFsIHB1cmVfanNfZXhwciA6IHN0cmluZyAtPiAnYSA9IFwiY2FtbF9wdXJlX2pzX2V4cHJcIlxuXG4gICAgbGV0IGdsb2JhbCA9IHB1cmVfanNfZXhwciBcImdsb2JhbFRoaXNcIlxuXG4gICAgZXh0ZXJuYWwgY2FsbGJhY2sgOiAoJ2EgLT4gJ2IpIC0+ICgnYywgJ2EgLT4gJ2IpIG1ldGhfY2FsbGJhY2tcbiAgICAgID0gXCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfdW5zYWZlXCJcblxuICAgIGV4dGVybmFsIGNhbGxiYWNrX3dpdGhfYXJndW1lbnRzIDpcbiAgICAgIChhbnlfanNfYXJyYXkgLT4gJ2IpIC0+ICgnYywgYW55X2pzX2FycmF5IC0+ICdiKSBtZXRoX2NhbGxiYWNrXG4gICAgICA9IFwiY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50c1wiXG5cbiAgICBleHRlcm5hbCBjYWxsYmFja193aXRoX2FyaXR5IDogaW50IC0+ICgnYSAtPiAnYikgLT4gKCdjLCAnYSAtPiAnYikgbWV0aF9jYWxsYmFja1xuICAgICAgPSBcImNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3RcIlxuXG4gICAgZXh0ZXJuYWwgbWV0aF9jYWxsYmFjayA6ICgnYiAtPiAnYSkgLT4gKCdiLCAnYSkgbWV0aF9jYWxsYmFja1xuICAgICAgPSBcImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZVwiXG5cbiAgICBleHRlcm5hbCBtZXRoX2NhbGxiYWNrX3dpdGhfYXJpdHkgOiBpbnQgLT4gKCdiIC0+ICdhKSAtPiAoJ2IsICdhKSBtZXRoX2NhbGxiYWNrXG4gICAgICA9IFwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0XCJcblxuICAgIGV4dGVybmFsIG1ldGhfY2FsbGJhY2tfd2l0aF9hcmd1bWVudHMgOlxuICAgICAgKCdiIC0+IGFueV9qc19hcnJheSAtPiAnYSkgLT4gKCdiLCBhbnlfanNfYXJyYXkgLT4gJ2EpIG1ldGhfY2FsbGJhY2tcbiAgICAgID0gXCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHNcIlxuXG4gICAgKCogREVQUkVDQVRFRCAqKVxuICAgIGV4dGVybmFsIHZhcmlhYmxlIDogc3RyaW5nIC0+ICdhID0gXCJjYW1sX2pzX3ZhclwiXG4gIGVuZFxuXG4gICgqKioqKVxuXG4gIHR5cGUgJ2Egb3B0ID0gJ2FcblxuICB0eXBlICdhIG9wdGRlZiA9ICdhXG5cbiAgZXh0ZXJuYWwgZGVidWdnZXIgOiB1bml0IC0+IHVuaXQgPSBcImRlYnVnZ2VyXCJcblxuICBsZXQgbnVsbCA6ICdhIG9wdCA9IFVuc2FmZS5wdXJlX2pzX2V4cHIgXCJudWxsXCJcblxuICBleHRlcm5hbCBzb21lIDogJ2EgLT4gJ2Egb3B0ID0gXCIlaWRlbnRpdHlcIlxuXG4gIGxldCB1bmRlZmluZWQgOiAnYSBvcHRkZWYgPSBVbnNhZmUucHVyZV9qc19leHByIFwidW5kZWZpbmVkXCJcblxuICBleHRlcm5hbCBkZWYgOiAnYSAtPiAnYSBvcHRkZWYgPSBcIiVpZGVudGl0eVwiXG5cbiAgbW9kdWxlIHR5cGUgT1BUID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgZW1wdHkgOiAnYSB0XG5cbiAgICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuXG4gICAgdmFsIG1hcCA6ICdhIHQgLT4gKCdhIC0+ICdiKSAtPiAnYiB0XG5cbiAgICB2YWwgYmluZCA6ICdhIHQgLT4gKCdhIC0+ICdiIHQpIC0+ICdiIHRcblxuICAgIHZhbCB0ZXN0IDogJ2EgdCAtPiBib29sXG5cbiAgICB2YWwgaXRlciA6ICdhIHQgLT4gKCdhIC0+IHVuaXQpIC0+IHVuaXRcblxuICAgIHZhbCBjYXNlIDogJ2EgdCAtPiAodW5pdCAtPiAnYikgLT4gKCdhIC0+ICdiKSAtPiAnYlxuXG4gICAgdmFsIGdldCA6ICdhIHQgLT4gKHVuaXQgLT4gJ2EpIC0+ICdhXG5cbiAgICB2YWwgb3B0aW9uIDogJ2Egb3B0aW9uIC0+ICdhIHRcblxuICAgIHZhbCB0b19vcHRpb24gOiAnYSB0IC0+ICdhIG9wdGlvblxuICBlbmRcblxuICBtb2R1bGUgT3B0IDogT1BUIHdpdGggdHlwZSAnYSB0ID0gJ2Egb3B0ID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2Egb3B0XG5cbiAgICBsZXQgZW1wdHkgPSBudWxsXG5cbiAgICBsZXQgcmV0dXJuID0gc29tZVxuXG4gICAgbGV0IG1hcCB4IGYgPSBpZiBVbnNhZmUuZXF1YWxzIHggbnVsbCB0aGVuIG51bGwgZWxzZSByZXR1cm4gKGYgeClcblxuICAgIGxldCBiaW5kIHggZiA9IGlmIFVuc2FmZS5lcXVhbHMgeCBudWxsIHRoZW4gbnVsbCBlbHNlIGYgeFxuXG4gICAgbGV0IHRlc3QgeCA9IG5vdCAoVW5zYWZlLmVxdWFscyB4IG51bGwpXG5cbiAgICBsZXQgaXRlciB4IGYgPSBpZiBub3QgKFVuc2FmZS5lcXVhbHMgeCBudWxsKSB0aGVuIGYgeFxuXG4gICAgbGV0IGNhc2UgeCBmIGcgPSBpZiBVbnNhZmUuZXF1YWxzIHggbnVsbCB0aGVuIGYgKCkgZWxzZSBnIHhcblxuICAgIGxldCBnZXQgeCBmID0gaWYgVW5zYWZlLmVxdWFscyB4IG51bGwgdGhlbiBmICgpIGVsc2UgeFxuXG4gICAgbGV0IG9wdGlvbiB4ID1cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBOb25lIC0+IGVtcHR5XG4gICAgICB8IFNvbWUgeCAtPiByZXR1cm4geFxuXG4gICAgbGV0IHRvX29wdGlvbiB4ID0gY2FzZSB4IChmdW4gKCkgLT4gTm9uZSkgKGZ1biB4IC0+IFNvbWUgeClcbiAgZW5kXG5cbiAgbW9kdWxlIE9wdGRlZiA6IE9QVCB3aXRoIHR5cGUgJ2EgdCA9ICdhIG9wdGRlZiA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIG9wdGRlZlxuXG4gICAgbGV0IGVtcHR5ID0gdW5kZWZpbmVkXG5cbiAgICBsZXQgcmV0dXJuID0gZGVmXG5cbiAgICBsZXQgbWFwIHggZiA9IGlmIHggPT0gdW5kZWZpbmVkIHRoZW4gdW5kZWZpbmVkIGVsc2UgcmV0dXJuIChmIHgpXG5cbiAgICBsZXQgYmluZCB4IGYgPSBpZiB4ID09IHVuZGVmaW5lZCB0aGVuIHVuZGVmaW5lZCBlbHNlIGYgeFxuXG4gICAgbGV0IHRlc3QgeCA9IHggIT0gdW5kZWZpbmVkXG5cbiAgICBsZXQgaXRlciB4IGYgPSBpZiB4ICE9IHVuZGVmaW5lZCB0aGVuIGYgeFxuXG4gICAgbGV0IGNhc2UgeCBmIGcgPSBpZiB4ID09IHVuZGVmaW5lZCB0aGVuIGYgKCkgZWxzZSBnIHhcblxuICAgIGxldCBnZXQgeCBmID0gaWYgeCA9PSB1bmRlZmluZWQgdGhlbiBmICgpIGVsc2UgeFxuXG4gICAgbGV0IG9wdGlvbiB4ID1cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBOb25lIC0+IGVtcHR5XG4gICAgICB8IFNvbWUgeCAtPiByZXR1cm4geFxuXG4gICAgbGV0IHRvX29wdGlvbiB4ID0gY2FzZSB4IChmdW4gKCkgLT4gTm9uZSkgKGZ1biB4IC0+IFNvbWUgeClcbiAgZW5kXG5cbiAgKCoqKiopXG5cbiAgbGV0IGNvZXJjZSB4IGYgZyA9IE9wdC5nZXQgKGYgeCkgKGZ1biAoKSAtPiBnIHgpXG5cbiAgbGV0IGNvZXJjZV9vcHQgeCBmIGcgPSBPcHQuZ2V0IChPcHQuYmluZCB4IGYpIChmdW4gKCkgLT4gZyB4KVxuXG4gICgqKioqKVxuXG4gIHR5cGUgKydhIG1ldGhcblxuICB0eXBlICsnYSBnZW5fcHJvcFxuXG4gIHR5cGUgJ2EgcmVhZG9ubHlfcHJvcCA9IDwgZ2V0IDogJ2EgPiBnZW5fcHJvcFxuXG4gIHR5cGUgJ2Egd3JpdGVvbmx5X3Byb3AgPSA8IHNldCA6ICdhIC0+IHVuaXQgPiBnZW5fcHJvcFxuXG4gIHR5cGUgJ2EgcHJvcCA9IDwgZ2V0IDogJ2EgOyBzZXQgOiAnYSAtPiB1bml0ID4gZ2VuX3Byb3BcblxuICB0eXBlICdhIG9wdGRlZl9wcm9wID0gPCBnZXQgOiAnYSBvcHRkZWYgOyBzZXQgOiAnYSAtPiB1bml0ID4gZ2VuX3Byb3BcblxuICB0eXBlICsnYSBjb25zdHJcblxuICAoKioqKilcblxuICB0eXBlICdhIGNhbGxiYWNrID0gKHVuaXQsICdhKSBtZXRoX2NhbGxiYWNrXG5cbiAgZXh0ZXJuYWwgd3JhcF9jYWxsYmFjayA6ICgnYSAtPiAnYikgLT4gKCdjLCAnYSAtPiAnYikgbWV0aF9jYWxsYmFja1xuICAgID0gXCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tcIlxuXG4gIGV4dGVybmFsIHdyYXBfbWV0aF9jYWxsYmFjayA6ICgnYSAtPiAnYikgLT4gKCdhLCAnYikgbWV0aF9jYWxsYmFja1xuICAgID0gXCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja1wiXG5cbiAgKCoqKiopXG5cbiAgbGV0IF90cnVlID0gVW5zYWZlLnB1cmVfanNfZXhwciBcInRydWVcIlxuXG4gIGxldCBfZmFsc2UgPSBVbnNhZmUucHVyZV9qc19leHByIFwiZmFsc2VcIlxuXG4gIHR5cGUgbWF0Y2hfcmVzdWx0X2hhbmRsZVxuXG4gIHR5cGUgc3RyaW5nX2FycmF5XG5cbiAgY2xhc3MgdHlwZSBqc19zdHJpbmcgPVxuICAgIG9iamVjdFxuICAgICAgbWV0aG9kIHRvU3RyaW5nIDoganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgICBtZXRob2QgdmFsdWVPZiA6IGpzX3N0cmluZyB0IG1ldGhcblxuICAgICAgbWV0aG9kIGNoYXJBdCA6IGludCAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCBjaGFyQ29kZUF0IDogaW50IC0+IGZsb2F0IG1ldGhcblxuICAgICAgKCogVGhpcyBtYXkgcmV0dXJuIE5hTi4uLiAqKVxuICAgICAgbWV0aG9kIGNvbmNhdCA6IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IG1ldGhcblxuICAgICAgbWV0aG9kIGNvbmNhdF8yIDoganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgICBtZXRob2QgY29uY2F0XzMgOiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCBjb25jYXRfNCA6XG4gICAgICAgIGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IG1ldGhcblxuICAgICAgbWV0aG9kIGluZGV4T2YgOiBqc19zdHJpbmcgdCAtPiBpbnQgbWV0aFxuXG4gICAgICBtZXRob2QgaW5kZXhPZl9mcm9tIDoganNfc3RyaW5nIHQgLT4gaW50IC0+IGludCBtZXRoXG5cbiAgICAgIG1ldGhvZCBsYXN0SW5kZXhPZiA6IGpzX3N0cmluZyB0IC0+IGludCBtZXRoXG5cbiAgICAgIG1ldGhvZCBsYXN0SW5kZXhPZl9mcm9tIDoganNfc3RyaW5nIHQgLT4gaW50IC0+IGludCBtZXRoXG5cbiAgICAgIG1ldGhvZCBsb2NhbGVDb21wYXJlIDoganNfc3RyaW5nIHQgLT4gZmxvYXQgbWV0aFxuXG4gICAgICBtZXRob2QgX21hdGNoIDogcmVnRXhwIHQgLT4gbWF0Y2hfcmVzdWx0X2hhbmRsZSB0IG9wdCBtZXRoXG5cbiAgICAgIG1ldGhvZCBub3JtYWxpemUgOiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCBub3JtYWxpemVfZm9ybSA6IG5vcm1hbGl6YXRpb24gdCAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCByZXBsYWNlIDogcmVnRXhwIHQgLT4ganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgICBtZXRob2QgcmVwbGFjZV9zdHJpbmcgOiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCBzZWFyY2ggOiByZWdFeHAgdCAtPiBpbnQgbWV0aFxuXG4gICAgICBtZXRob2Qgc2xpY2UgOiBpbnQgLT4gaW50IC0+IGpzX3N0cmluZyB0IG1ldGhcblxuICAgICAgbWV0aG9kIHNsaWNlX2VuZCA6IGludCAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCBzcGxpdCA6IGpzX3N0cmluZyB0IC0+IHN0cmluZ19hcnJheSB0IG1ldGhcblxuICAgICAgbWV0aG9kIHNwbGl0X2xpbWl0ZWQgOiBqc19zdHJpbmcgdCAtPiBpbnQgLT4gc3RyaW5nX2FycmF5IHQgbWV0aFxuXG4gICAgICBtZXRob2Qgc3BsaXRfcmVnRXhwIDogcmVnRXhwIHQgLT4gc3RyaW5nX2FycmF5IHQgbWV0aFxuXG4gICAgICBtZXRob2Qgc3BsaXRfcmVnRXhwTGltaXRlZCA6IHJlZ0V4cCB0IC0+IGludCAtPiBzdHJpbmdfYXJyYXkgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCBzdWJzdHJpbmcgOiBpbnQgLT4gaW50IC0+IGpzX3N0cmluZyB0IG1ldGhcblxuICAgICAgbWV0aG9kIHN1YnN0cmluZ190b0VuZCA6IGludCAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCB0b0xvd2VyQ2FzZSA6IGpzX3N0cmluZyB0IG1ldGhcblxuICAgICAgbWV0aG9kIHRvTG9jYWxlTG93ZXJDYXNlIDoganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgICBtZXRob2QgdG9VcHBlckNhc2UgOiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCB0b0xvY2FsZVVwcGVyQ2FzZSA6IGpzX3N0cmluZyB0IG1ldGhcblxuICAgICAgbWV0aG9kIHRyaW0gOiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCBsZW5ndGggOiBpbnQgcmVhZG9ubHlfcHJvcFxuICAgIGVuZFxuXG4gIGFuZCByZWdFeHAgPVxuICAgIG9iamVjdFxuICAgICAgbWV0aG9kIGV4ZWMgOiBqc19zdHJpbmcgdCAtPiBtYXRjaF9yZXN1bHRfaGFuZGxlIHQgb3B0IG1ldGhcblxuICAgICAgbWV0aG9kIHRlc3QgOiBqc19zdHJpbmcgdCAtPiBib29sIHQgbWV0aFxuXG4gICAgICBtZXRob2QgdG9TdHJpbmcgOiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICAgIG1ldGhvZCBzb3VyY2UgOiBqc19zdHJpbmcgdCByZWFkb25seV9wcm9wXG5cbiAgICAgIG1ldGhvZCBnbG9iYWwgOiBib29sIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgICBtZXRob2QgaWdub3JlQ2FzZSA6IGJvb2wgdCByZWFkb25seV9wcm9wXG5cbiAgICAgIG1ldGhvZCBtdWx0aWxpbmUgOiBib29sIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgICBtZXRob2QgbGFzdEluZGV4IDogaW50IHByb3BcbiAgICBlbmRcblxuICBhbmQgbm9ybWFsaXphdGlvbiA9IGpzX3N0cmluZ1xuXG4gICgqIHN0cmluZyBpcyB1c2VkIGJ5IHBweF9qcywgaXQgbmVlZHMgdG8gY29tZSBiZWZvcmUgYW55IHVzZSBvZiB0aGVcbiAgICAgbmV3IHN5bnRheCBpbiB0aGlzIGZpbGUgKilcbiAgZXh0ZXJuYWwgc3RyaW5nIDogc3RyaW5nIC0+IGpzX3N0cmluZyB0ID0gXCJjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1wiXG5cbiAgZXh0ZXJuYWwgdG9fc3RyaW5nIDoganNfc3RyaW5nIHQgLT4gc3RyaW5nID0gXCJjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1wiXG5cbiAgbGV0IG5mYyA9IHN0cmluZyBcIk5GQ1wiXG5cbiAgbGV0IG5mZCA9IHN0cmluZyBcIk5GRFwiXG5cbiAgbGV0IG5ma2MgPSBzdHJpbmcgXCJORktDXCJcblxuICBsZXQgbmZrZCA9IHN0cmluZyBcIk5GS0RcIlxuZW5kXG5cbmluY2x1ZGUgSnNcblxuY2xhc3MgdHlwZSBzdHJpbmdfY29uc3RyID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGZyb21DaGFyQ29kZSA6IGludCAtPiBqc19zdHJpbmcgdCBtZXRoXG4gIGVuZFxuXG5sZXQgc3RyaW5nX2NvbnN0ciA9IFVuc2FmZS5nbG9iYWwjIy5fU3RyaW5nXG5cbmxldCByZWdFeHAgPSBVbnNhZmUuZ2xvYmFsIyMuX1JlZ0V4cFxuXG5sZXQgcmVnRXhwX2NvcHkgPSByZWdFeHBcblxubGV0IHJlZ0V4cF93aXRoRmxhZ3MgPSByZWdFeHBcblxuY2xhc3MgdHlwZSBbJ2FdIGpzX2FycmF5ID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIHRvU3RyaW5nIDoganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIHRvTG9jYWxlU3RyaW5nIDoganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIGNvbmNhdCA6ICdhIGpzX2FycmF5IHQgLT4gJ2EganNfYXJyYXkgdCBtZXRoXG5cbiAgICBtZXRob2Qgam9pbiA6IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IG1ldGhcblxuICAgIG1ldGhvZCBwb3AgOiAnYSBvcHRkZWYgbWV0aFxuXG4gICAgbWV0aG9kIHB1c2ggOiAnYSAtPiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIHB1c2hfMiA6ICdhIC0+ICdhIC0+IGludCBtZXRoXG5cbiAgICBtZXRob2QgcHVzaF8zIDogJ2EgLT4gJ2EgLT4gJ2EgLT4gaW50IG1ldGhcblxuICAgIG1ldGhvZCBwdXNoXzQgOiAnYSAtPiAnYSAtPiAnYSAtPiAnYSAtPiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIHJldmVyc2UgOiAnYSBqc19hcnJheSB0IG1ldGhcblxuICAgIG1ldGhvZCBzaGlmdCA6ICdhIG9wdGRlZiBtZXRoXG5cbiAgICBtZXRob2Qgc2xpY2UgOiBpbnQgLT4gaW50IC0+ICdhIGpzX2FycmF5IHQgbWV0aFxuXG4gICAgbWV0aG9kIHNsaWNlX2VuZCA6IGludCAtPiAnYSBqc19hcnJheSB0IG1ldGhcblxuICAgIG1ldGhvZCBzb3J0IDogKCdhIC0+ICdhIC0+IGZsb2F0KSBjYWxsYmFjayAtPiAnYSBqc19hcnJheSB0IG1ldGhcblxuICAgIG1ldGhvZCBzb3J0X2FzU3RyaW5ncyA6ICdhIGpzX2FycmF5IHQgbWV0aFxuXG4gICAgbWV0aG9kIHNwbGljZSA6IGludCAtPiBpbnQgLT4gJ2EganNfYXJyYXkgdCBtZXRoXG5cbiAgICBtZXRob2Qgc3BsaWNlXzEgOiBpbnQgLT4gaW50IC0+ICdhIC0+ICdhIGpzX2FycmF5IHQgbWV0aFxuXG4gICAgbWV0aG9kIHNwbGljZV8yIDogaW50IC0+IGludCAtPiAnYSAtPiAnYSAtPiAnYSBqc19hcnJheSB0IG1ldGhcblxuICAgIG1ldGhvZCBzcGxpY2VfMyA6IGludCAtPiBpbnQgLT4gJ2EgLT4gJ2EgLT4gJ2EgLT4gJ2EganNfYXJyYXkgdCBtZXRoXG5cbiAgICBtZXRob2Qgc3BsaWNlXzQgOiBpbnQgLT4gaW50IC0+ICdhIC0+ICdhIC0+ICdhIC0+ICdhIC0+ICdhIGpzX2FycmF5IHQgbWV0aFxuXG4gICAgbWV0aG9kIHVuc2hpZnQgOiAnYSAtPiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIHVuc2hpZnRfMiA6ICdhIC0+ICdhIC0+IGludCBtZXRoXG5cbiAgICBtZXRob2QgdW5zaGlmdF8zIDogJ2EgLT4gJ2EgLT4gJ2EgLT4gaW50IG1ldGhcblxuICAgIG1ldGhvZCB1bnNoaWZ0XzQgOiAnYSAtPiAnYSAtPiAnYSAtPiAnYSAtPiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIHNvbWUgOiAoJ2EgLT4gaW50IC0+ICdhIGpzX2FycmF5IHQgLT4gYm9vbCB0KSBjYWxsYmFjayAtPiBib29sIHQgbWV0aFxuXG4gICAgbWV0aG9kIGV2ZXJ5IDogKCdhIC0+IGludCAtPiAnYSBqc19hcnJheSB0IC0+IGJvb2wgdCkgY2FsbGJhY2sgLT4gYm9vbCB0IG1ldGhcblxuICAgIG1ldGhvZCBmb3JFYWNoIDogKCdhIC0+IGludCAtPiAnYSBqc19hcnJheSB0IC0+IHVuaXQpIGNhbGxiYWNrIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIG1hcCA6ICgnYSAtPiBpbnQgLT4gJ2EganNfYXJyYXkgdCAtPiAnYikgY2FsbGJhY2sgLT4gJ2IganNfYXJyYXkgdCBtZXRoXG5cbiAgICBtZXRob2QgZmlsdGVyIDogKCdhIC0+IGludCAtPiAnYSBqc19hcnJheSB0IC0+IGJvb2wgdCkgY2FsbGJhY2sgLT4gJ2EganNfYXJyYXkgdCBtZXRoXG5cbiAgICBtZXRob2QgcmVkdWNlX2luaXQgOlxuICAgICAgKCdiIC0+ICdhIC0+IGludCAtPiAnYSBqc19hcnJheSB0IC0+ICdiKSBjYWxsYmFjayAtPiAnYiAtPiAnYiBtZXRoXG5cbiAgICBtZXRob2QgcmVkdWNlIDogKCdhIC0+ICdhIC0+IGludCAtPiAnYSBqc19hcnJheSB0IC0+ICdhKSBjYWxsYmFjayAtPiAnYSBtZXRoXG5cbiAgICBtZXRob2QgcmVkdWNlUmlnaHRfaW5pdCA6XG4gICAgICAoJ2IgLT4gJ2EgLT4gaW50IC0+ICdhIGpzX2FycmF5IHQgLT4gJ2IpIGNhbGxiYWNrIC0+ICdiIC0+ICdiIG1ldGhcblxuICAgIG1ldGhvZCByZWR1Y2VSaWdodCA6ICgnYSAtPiAnYSAtPiBpbnQgLT4gJ2EganNfYXJyYXkgdCAtPiAnYSkgY2FsbGJhY2sgLT4gJ2EgbWV0aFxuXG4gICAgbWV0aG9kIGxlbmd0aCA6IGludCBwcm9wXG4gIGVuZFxuXG5sZXQgb2JqZWN0X2NvbnN0cnVjdG9yID0gVW5zYWZlLmdsb2JhbCMjLl9PYmplY3RcblxubGV0IG9iamVjdF9rZXlzIG8gOiBqc19zdHJpbmcgdCBqc19hcnJheSB0ID0gb2JqZWN0X2NvbnN0cnVjdG9yIyNrZXlzIG9cblxubGV0IGFycmF5X2NvbnN0cnVjdG9yID0gVW5zYWZlLmdsb2JhbCMjLl9BcnJheVxuXG5sZXQgYXJyYXlfZW1wdHkgPSBhcnJheV9jb25zdHJ1Y3RvclxuXG5sZXQgYXJyYXlfbGVuZ3RoID0gYXJyYXlfY29uc3RydWN0b3JcblxubGV0IGFycmF5X2dldCA6ICdhICNqc19hcnJheSB0IC0+IGludCAtPiAnYSBvcHRkZWYgPSBVbnNhZmUuZ2V0XG5cbmxldCBhcnJheV9zZXQgOiAnYSAjanNfYXJyYXkgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFVuc2FmZS5zZXRcblxubGV0IGFycmF5X21hcF9wb2x5IDpcbiAgICAnYSAjanNfYXJyYXkgdCAtPiAoJ2EgLT4gaW50IC0+ICdhICNqc19hcnJheSB0IC0+ICdiKSBjYWxsYmFjayAtPiAnYiAjanNfYXJyYXkgdCA9XG4gZnVuIGEgY2IgLT4gKFVuc2FmZS5jb2VyY2UgYSkjI21hcCBjYlxuXG5sZXQgYXJyYXlfbWFwIGYgYSA9IGFycmF5X21hcF9wb2x5IGEgKHdyYXBfY2FsbGJhY2sgKGZ1biB4IF9pZHggXyAtPiBmIHgpKVxuXG5sZXQgYXJyYXlfbWFwaSBmIGEgPSBhcnJheV9tYXBfcG9seSBhICh3cmFwX2NhbGxiYWNrIChmdW4geCBpZHggXyAtPiBmIGlkeCB4KSlcblxuY2xhc3MgdHlwZSBtYXRjaF9yZXN1bHQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IFtqc19zdHJpbmcgdF0ganNfYXJyYXlcblxuICAgIG1ldGhvZCBpbmRleCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgaW5wdXQgOiBqc19zdHJpbmcgdCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG5sZXQgc3RyX2FycmF5IDogc3RyaW5nX2FycmF5IHQgLT4ganNfc3RyaW5nIHQganNfYXJyYXkgdCA9IFVuc2FmZS5jb2VyY2VcblxubGV0IG1hdGNoX3Jlc3VsdCA6IG1hdGNoX3Jlc3VsdF9oYW5kbGUgdCAtPiBtYXRjaF9yZXN1bHQgdCA9IFVuc2FmZS5jb2VyY2VcblxuY2xhc3MgdHlwZSBudW1iZXIgPVxuICBvYmplY3RcbiAgICBtZXRob2QgdG9TdHJpbmcgOiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICBtZXRob2QgdG9TdHJpbmdfcmFkaXggOiBpbnQgLT4ganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIHRvTG9jYWxlU3RyaW5nIDoganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIHRvRml4ZWQgOiBpbnQgLT4ganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIHRvRXhwb25lbnRpYWwgOiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICBtZXRob2QgdG9FeHBvbmVudGlhbF9kaWdpdHMgOiBpbnQgLT4ganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIHRvUHJlY2lzaW9uIDogaW50IC0+IGpzX3N0cmluZyB0IG1ldGhcbiAgZW5kXG5cbmV4dGVybmFsIG51bWJlcl9vZl9mbG9hdCA6IGZsb2F0IC0+IG51bWJlciB0ID0gXCJjYW1sX2pzX2Zyb21fZmxvYXRcIlxuXG5leHRlcm5hbCBmbG9hdF9vZl9udW1iZXIgOiBudW1iZXIgdCAtPiBmbG9hdCA9IFwiY2FtbF9qc190b19mbG9hdFwiXG5cbmNsYXNzIHR5cGUgZGF0ZSA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCB0b1N0cmluZyA6IGpzX3N0cmluZyB0IG1ldGhcblxuICAgIG1ldGhvZCB0b0RhdGVTdHJpbmcgOiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICBtZXRob2QgdG9UaW1lU3RyaW5nIDoganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIHRvTG9jYWxlU3RyaW5nIDoganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIHRvTG9jYWxlRGF0ZVN0cmluZyA6IGpzX3N0cmluZyB0IG1ldGhcblxuICAgIG1ldGhvZCB0b0xvY2FsZVRpbWVTdHJpbmcgOiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICBtZXRob2QgdmFsdWVPZiA6IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRUaW1lIDogZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIGdldEZ1bGxZZWFyIDogaW50IG1ldGhcblxuICAgIG1ldGhvZCBnZXRVVENGdWxsWWVhciA6IGludCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0TW9udGggOiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIGdldFVUQ01vbnRoIDogaW50IG1ldGhcblxuICAgIG1ldGhvZCBnZXREYXRlIDogaW50IG1ldGhcblxuICAgIG1ldGhvZCBnZXRVVENEYXRlIDogaW50IG1ldGhcblxuICAgIG1ldGhvZCBnZXREYXkgOiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIGdldFVUQ0RheSA6IGludCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0SG91cnMgOiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIGdldFVUQ0hvdXJzIDogaW50IG1ldGhcblxuICAgIG1ldGhvZCBnZXRNaW51dGVzIDogaW50IG1ldGhcblxuICAgIG1ldGhvZCBnZXRVVENNaW51dGVzIDogaW50IG1ldGhcblxuICAgIG1ldGhvZCBnZXRTZWNvbmRzIDogaW50IG1ldGhcblxuICAgIG1ldGhvZCBnZXRVVENTZWNvbmRzIDogaW50IG1ldGhcblxuICAgIG1ldGhvZCBnZXRNaWxsaXNlY29uZHMgOiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIGdldFVUQ01pbGxpc2Vjb25kcyA6IGludCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0VGltZXpvbmVPZmZzZXQgOiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIHNldFRpbWUgOiBmbG9hdCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0RnVsbFllYXIgOiBpbnQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldFVUQ0Z1bGxZZWFyIDogaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBzZXRNb250aCA6IGludCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0VVRDTW9udGggOiBpbnQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldERhdGUgOiBpbnQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldFVUQ0RhdGUgOiBpbnQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldERheSA6IGludCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0VVRDRGF5IDogaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBzZXRIb3VycyA6IGludCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0VVRDSG91cnMgOiBpbnQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldE1pbnV0ZXMgOiBpbnQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldFVUQ01pbnV0ZXMgOiBpbnQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldFNlY29uZHMgOiBpbnQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldFVUQ1NlY29uZHMgOiBpbnQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldE1pbGxpc2Vjb25kcyA6IGludCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0VVRDTWlsbGlzZWNvbmRzIDogaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCB0b1VUQ1N0cmluZyA6IGpzX3N0cmluZyB0IG1ldGhcblxuICAgIG1ldGhvZCB0b0lTT1N0cmluZyA6IGpzX3N0cmluZyB0IG1ldGhcblxuICAgIG1ldGhvZCB0b0pTT04gOiAnYSAtPiBqc19zdHJpbmcgdCBtZXRoXG4gIGVuZFxuXG5jbGFzcyB0eXBlIGRhdGVfY29uc3RyID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIHBhcnNlIDoganNfc3RyaW5nIHQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIF9VVENfbW9udGggOiBpbnQgLT4gaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBfVVRDX2RheSA6IGludCAtPiBpbnQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIF9VVENfaG91ciA6IGludCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgX1VUQ19taW4gOiBpbnQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBfVVRDX3NlYyA6IGludCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBfVVRDX21zIDogaW50IC0+IGludCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBub3cgOiBmbG9hdCBtZXRoXG4gIGVuZFxuXG5sZXQgZGF0ZV9jb25zdHIgPSBVbnNhZmUuZ2xvYmFsIyMuX0RhdGVcblxubGV0IGRhdGUgOiBkYXRlX2NvbnN0ciB0ID0gZGF0ZV9jb25zdHJcblxubGV0IGRhdGVfbm93IDogZGF0ZSB0IGNvbnN0ciA9IGRhdGVfY29uc3RyXG5cbmxldCBkYXRlX2Zyb21UaW1lVmFsdWUgOiAoZmxvYXQgLT4gZGF0ZSB0KSBjb25zdHIgPSBkYXRlX2NvbnN0clxuXG5sZXQgZGF0ZV9tb250aCA6IChpbnQgLT4gaW50IC0+IGRhdGUgdCkgY29uc3RyID0gZGF0ZV9jb25zdHJcblxubGV0IGRhdGVfZGF5IDogKGludCAtPiBpbnQgLT4gaW50IC0+IGRhdGUgdCkgY29uc3RyID0gZGF0ZV9jb25zdHJcblxubGV0IGRhdGVfaG91ciA6IChpbnQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gZGF0ZSB0KSBjb25zdHIgPSBkYXRlX2NvbnN0clxuXG5sZXQgZGF0ZV9taW4gOiAoaW50IC0+IGludCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiBkYXRlIHQpIGNvbnN0ciA9IGRhdGVfY29uc3RyXG5cbmxldCBkYXRlX3NlYyA6IChpbnQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiBkYXRlIHQpIGNvbnN0ciA9IGRhdGVfY29uc3RyXG5cbmxldCBkYXRlX21zIDogKGludCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiBkYXRlIHQpIGNvbnN0ciA9XG4gIGRhdGVfY29uc3RyXG5cbmNsYXNzIHR5cGUgbWF0aCA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBfRSA6IGZsb2F0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfTE4yIDogZmxvYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9MTjEwIDogZmxvYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9MT0cyRSA6IGZsb2F0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfTE9HMTBFIDogZmxvYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9QSSA6IGZsb2F0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfU1FSVDFfMl8gOiBmbG9hdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NRUlQyIDogZmxvYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGFicyA6IGZsb2F0IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBhY29zIDogZmxvYXQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgYXRhbiA6IGZsb2F0IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBhdGFuMiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIGNvcyA6IGZsb2F0IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBleHAgOiBmbG9hdCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgbG9nIDogZmxvYXQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIG1heCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBtYXhfMyA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBtYXhfNCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBtaW4gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgbWluXzMgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgbWluXzQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgcG93IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHJhbmRvbSA6IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCByb3VuZCA6IGZsb2F0IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBzaW4gOiBmbG9hdCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2Qgc3FydCA6IGZsb2F0IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCB0YW4gOiBmbG9hdCAtPiBmbG9hdCBtZXRoXG4gIGVuZFxuXG5sZXQgbWF0aCA9IFVuc2FmZS5nbG9iYWwjIy5fTWF0aFxuXG5jbGFzcyB0eXBlIGVycm9yID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIG5hbWUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgbWVzc2FnZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBzdGFjayA6IGpzX3N0cmluZyB0IG9wdGRlZiBwcm9wXG5cbiAgICBtZXRob2QgdG9TdHJpbmcgOiBqc19zdHJpbmcgdCBtZXRoXG4gIGVuZFxuXG5sZXQgZXJyb3JfY29uc3RyID0gVW5zYWZlLmdsb2JhbCMjLl9FcnJvclxuXG5tb2R1bGUgSnNfZXJyb3IgPSBzdHJ1Y3RcbiAgdHlwZSBlcnJvcl90ID0gZXJyb3IgdFxuXG4gIGluY2x1ZGUgSnNvb19ydW50aW1lLkVycm9yXG5cbiAgZXh0ZXJuYWwgb2ZfZXJyb3IgOiBlcnJvcl90IC0+IHQgPSBcIiVpZGVudGl0eVwiXG5cbiAgZXh0ZXJuYWwgdG9fZXJyb3IgOiB0IC0+IGVycm9yX3QgPSBcIiVpZGVudGl0eVwiXG5cbiAgbGV0IG5hbWUgZSA9IHRvX3N0cmluZyAodG9fZXJyb3IgZSkjIy5uYW1lXG5cbiAgbGV0IG1lc3NhZ2UgZSA9IHRvX3N0cmluZyAodG9fZXJyb3IgZSkjIy5tZXNzYWdlXG5cbiAgbGV0IHN0YWNrIChlIDogdCkgOiBzdHJpbmcgb3B0aW9uID1cbiAgICBPcHQudG9fb3B0aW9uIChPcHQubWFwICh0b19lcnJvciBlKSMjLnN0YWNrIHRvX3N0cmluZylcblxuICBsZXQgdG9fc3RyaW5nIGUgPSB0b19zdHJpbmcgKHRvX2Vycm9yIGUpIyN0b1N0cmluZ1xuZW5kXG5cbm1vZHVsZSBNYWdpYyA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBUID0gc2lnXG4gICAgZXhjZXB0aW9uIEVycm9yIG9mIGVycm9yIHRcbiAgZW5kXG5cbiAgdHlwZSAoJ2EsICdiKSBlcSA9IEVxIDogKCdhLCAnYSkgZXFcblxuICBsZXQgKGVxIDogKGVycm9yIHQsIEpzX2Vycm9yLnQpIGVxKSA9IE9iai5tYWdpYyBFcVxuXG4gIGxldCBtID1cbiAgICBtYXRjaCBlcSB3aXRoXG4gICAgfCBFcSAtPlxuICAgICAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgICAgIGV4Y2VwdGlvbiBFcnJvciA9IEpzX2Vycm9yLkV4blxuICAgICAgICBlbmQgOiBUKVxuXG4gIG1vZHVsZSBFcnJvciA9ICh2YWwgbSA6IFQpXG5lbmRcblxuaW5jbHVkZSBNYWdpYy5FcnJvclxuXG5sZXQgcmFpc2VfanNfZXJyb3IgZSA9IEpzX2Vycm9yLnJhaXNlXyAoSnNfZXJyb3Iub2ZfZXJyb3IgZSlcblxubGV0IHN0cmluZ19vZl9lcnJvciBlID0gSnNfZXJyb3IudG9fc3RyaW5nIChKc19lcnJvci5vZl9lcnJvciBlKVxuXG5sZXQgZXhuX3dpdGhfanNfYmFja3RyYWNlID0gSnNfZXJyb3IuYXR0YWNoX2pzX2JhY2t0cmFjZVxuXG5leHRlcm5hbCBqc19lcnJvcl9vZl9leG4gOiBleG4gLT4gZXJyb3IgdCBvcHQgPSBcImNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uXCJcblxuY2xhc3MgdHlwZSBqc29uID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIHBhcnNlIDoganNfc3RyaW5nIHQgLT4gJ2EgbWV0aFxuXG4gICAgbWV0aG9kIHN0cmluZ2lmeSA6ICdhIC0+IGpzX3N0cmluZyB0IG1ldGhcbiAgZW5kXG5cbmxldCBfSlNPTiA6IGpzb24gdCA9IFVuc2FmZS5nbG9iYWwjIy5fSlNPTlxuXG5sZXQgZGVjb2RlVVJJIChzIDoganNfc3RyaW5nIHQpIDoganNfc3RyaW5nIHQgPVxuICBVbnNhZmUuZnVuX2NhbGwgVW5zYWZlLmdsb2JhbCMjLmRlY29kZVVSSSBbfCBVbnNhZmUuaW5qZWN0IHMgfF1cblxubGV0IGRlY29kZVVSSUNvbXBvbmVudCAocyA6IGpzX3N0cmluZyB0KSA6IGpzX3N0cmluZyB0ID1cbiAgVW5zYWZlLmZ1bl9jYWxsIFVuc2FmZS5nbG9iYWwjIy5kZWNvZGVVUklDb21wb25lbnQgW3wgVW5zYWZlLmluamVjdCBzIHxdXG5cbmxldCBlbmNvZGVVUkkgKHMgOiBqc19zdHJpbmcgdCkgOiBqc19zdHJpbmcgdCA9XG4gIFVuc2FmZS5mdW5fY2FsbCBVbnNhZmUuZ2xvYmFsIyMuZW5jb2RlVVJJIFt8IFVuc2FmZS5pbmplY3QgcyB8XVxuXG5sZXQgZW5jb2RlVVJJQ29tcG9uZW50IChzIDoganNfc3RyaW5nIHQpIDoganNfc3RyaW5nIHQgPVxuICBVbnNhZmUuZnVuX2NhbGwgVW5zYWZlLmdsb2JhbCMjLmVuY29kZVVSSUNvbXBvbmVudCBbfCBVbnNhZmUuaW5qZWN0IHMgfF1cblxubGV0IGVzY2FwZSAocyA6IGpzX3N0cmluZyB0KSA6IGpzX3N0cmluZyB0ID1cbiAgVW5zYWZlLmZ1bl9jYWxsIFVuc2FmZS5nbG9iYWwjIy5lc2NhcGUgW3wgVW5zYWZlLmluamVjdCBzIHxdXG5cbmxldCB1bmVzY2FwZSAocyA6IGpzX3N0cmluZyB0KSA6IGpzX3N0cmluZyB0ID1cbiAgVW5zYWZlLmZ1bl9jYWxsIFVuc2FmZS5nbG9iYWwjIy51bmVzY2FwZSBbfCBVbnNhZmUuaW5qZWN0IHMgfF1cblxuZXh0ZXJuYWwgYm9vbCA6IGJvb2wgLT4gYm9vbCB0ID0gXCJjYW1sX2pzX2Zyb21fYm9vbFwiXG5cbmV4dGVybmFsIHRvX2Jvb2wgOiBib29sIHQgLT4gYm9vbCA9IFwiY2FtbF9qc190b19ib29sXCJcblxuZXh0ZXJuYWwgYXJyYXkgOiAnYSBhcnJheSAtPiAnYSBqc19hcnJheSB0ID0gXCJjYW1sX2pzX2Zyb21fYXJyYXlcIlxuXG5leHRlcm5hbCB0b19hcnJheSA6ICdhIGpzX2FycmF5IHQgLT4gJ2EgYXJyYXkgPSBcImNhbWxfanNfdG9fYXJyYXlcIlxuXG5leHRlcm5hbCBieXRlc3RyaW5nIDogc3RyaW5nIC0+IGpzX3N0cmluZyB0ID0gXCJjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgdG9fYnl0ZXN0cmluZyA6IGpzX3N0cmluZyB0IC0+IHN0cmluZyA9IFwiY2FtbF9zdHJpbmdfb2ZfanNieXRlc1wiXG5cbmV4dGVybmFsIHR5cGVvZiA6IF8gdCAtPiBqc19zdHJpbmcgdCA9IFwiY2FtbF9qc190eXBlb2ZcIlxuXG5leHRlcm5hbCBpbnN0YW5jZW9mIDogXyB0IC0+IF8gY29uc3RyIC0+IGJvb2wgPSBcImNhbWxfanNfaW5zdGFuY2VvZlwiXG5cbmxldCBpc05hTiAoaSA6ICdhKSA6IGJvb2wgPVxuICB0b19ib29sIChVbnNhZmUuZnVuX2NhbGwgVW5zYWZlLmdsb2JhbCMjLmlzTmFOIFt8IFVuc2FmZS5pbmplY3QgaSB8XSlcblxubGV0IHBhcnNlSW50IChzIDoganNfc3RyaW5nIHQpIDogaW50ID1cbiAgbGV0IHMgPSBVbnNhZmUuZnVuX2NhbGwgVW5zYWZlLmdsb2JhbCMjLnBhcnNlSW50IFt8IFVuc2FmZS5pbmplY3QgcyB8XSBpblxuICBpZiBpc05hTiBzIHRoZW4gZmFpbHdpdGggXCJwYXJzZUludFwiIGVsc2Ugc1xuXG5sZXQgcGFyc2VGbG9hdCAocyA6IGpzX3N0cmluZyB0KSA6IGZsb2F0ID1cbiAgbGV0IHMgPSBVbnNhZmUuZnVuX2NhbGwgVW5zYWZlLmdsb2JhbCMjLnBhcnNlRmxvYXQgW3wgVW5zYWZlLmluamVjdCBzIHxdIGluXG4gIGlmIGlzTmFOIHMgdGhlbiBmYWlsd2l0aCBcInBhcnNlRmxvYXRcIiBlbHNlIHNcblxubGV0IF8gPVxuICBQcmludGV4Yy5yZWdpc3Rlcl9wcmludGVyIChmdW5jdGlvblxuICAgICAgfCBKc19lcnJvci5FeG4gZSAtPiBTb21lIChKc19lcnJvci50b19zdHJpbmcgZSlcbiAgICAgIHwgXyAtPiBOb25lKVxuXG5sZXQgXyA9XG4gIFByaW50ZXhjLnJlZ2lzdGVyX3ByaW50ZXIgKGZ1biBlIC0+XG4gICAgICBsZXQgZSA6IDwgLi4gPiB0ID0gT2JqLm1hZ2ljIGUgaW5cbiAgICAgIGlmIGluc3RhbmNlb2YgZSBhcnJheV9jb25zdHJ1Y3RvciB0aGVuIE5vbmUgZWxzZSBTb21lICh0b19zdHJpbmcgZSMjdG9TdHJpbmcpKVxuXG5sZXQgZXhwb3J0X2pzIChmaWVsZCA6IGpzX3N0cmluZyB0KSB4ID1cbiAgVW5zYWZlLnNldFxuICAgIChVbnNhZmUucHVyZV9qc19leHByIFwianNvb19leHBvcnRzXCIpXG4gICAgZmllbGRcbiAgICAoaWYgU3RyaW5nLmVxdWFsIChKcy50b19zdHJpbmcgKHR5cGVvZiAoT2JqLm1hZ2ljIHgpKSkgXCJmdW5jdGlvblwiXG4gICAgICAgICgqIGZ1bmN0aW9uIHdpdGggYXJpdHkvbGVuZ3RoIGVxdWFsIHRvIHplcm8gYXJlIGFscmVhZHkgd3JhcHBlZCAqKVxuICAgICAgICAmJiBVbnNhZmUuZ2V0IChPYmoubWFnaWMgeCkgKEpzLnN0cmluZyBcImxlbmd0aFwiKSA+IDBcbiAgICAgdGhlbiBPYmoubWFnaWMgKHdyYXBfY2FsbGJhY2sgKE9iai5tYWdpYyB4KSlcbiAgICAgZWxzZSB4KVxuXG5sZXQgZXhwb3J0IGZpZWxkIHggPSBleHBvcnRfanMgKHN0cmluZyBmaWVsZCkgeFxuXG5sZXQgZXhwb3J0X2FsbCBvYmogPVxuICBsZXQga2V5cyA9IG9iamVjdF9rZXlzIG9iaiBpblxuICBrZXlzIyNmb3JFYWNoXG4gICAgKHdyYXBfY2FsbGJhY2sgKGZ1biAoa2V5IDoganNfc3RyaW5nIHQpIF8gXyAtPiBleHBvcnRfanMga2V5IChVbnNhZmUuZ2V0IG9iaiBrZXkpKSlcblxuKCoqKiopXG5cbigqIERFUFJFQ0FURUQgKilcblxudHlwZSBmbG9hdF9wcm9wID0gZmxvYXQgcHJvcFxuXG5leHRlcm5hbCBmbG9hdCA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlaWRlbnRpdHlcIlxuXG5leHRlcm5hbCB0b19mbG9hdCA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlaWRlbnRpdHlcIlxuIiwiKCogSnNfb2Zfb2NhbWwgbGlicmFyeVxuICogaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbiAqIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuICogTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbiAqIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICopXG5cbm9wZW4gSnNcbm9wZW4hIEltcG9ydFxuXG5jbGFzcyB0eXBlIFsnbm9kZV0gbm9kZUxpc3QgPVxuICBvYmplY3RcbiAgICBtZXRob2QgaXRlbSA6IGludCAtPiAnbm9kZSB0IG9wdCBtZXRoXG5cbiAgICBtZXRob2QgbGVuZ3RoIDogaW50IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbmxldCBsaXN0X29mX25vZGVMaXN0IChub2RlTGlzdCA6ICdhIG5vZGVMaXN0IHQpID1cbiAgbGV0IGxlbmd0aCA9IG5vZGVMaXN0IyMubGVuZ3RoIGluXG4gIGxldCByZWMgYWRkX2l0ZW0gYWNjIGkgPVxuICAgIGlmIGkgPCBsZW5ndGhcbiAgICB0aGVuXG4gICAgICBtYXRjaCBPcHQudG9fb3B0aW9uIChub2RlTGlzdCMjaXRlbSBpKSB3aXRoXG4gICAgICB8IE5vbmUgLT4gYWRkX2l0ZW0gYWNjIChpICsgMSlcbiAgICAgIHwgU29tZSBlIC0+IGFkZF9pdGVtIChlIDo6IGFjYykgKGkgKyAxKVxuICAgIGVsc2UgTGlzdC5yZXYgYWNjXG4gIGluXG4gIGFkZF9pdGVtIFtdIDBcblxudHlwZSBub2RlVHlwZSA9XG4gIHwgT1RIRVJcbiAgKCogV2lsbCBub3QgaGFwcGVuICopXG4gIHwgRUxFTUVOVFxuICB8IEFUVFJJQlVURVxuICB8IFRFWFRcbiAgfCBDREFUQV9TRUNUSU9OXG4gIHwgRU5USVRZX1JFRkVSRU5DRVxuICB8IEVOVElUWVxuICB8IFBST0NFU1NJTkdfSU5TVFJVQ1RJT05cbiAgfCBDT01NRU5UXG4gIHwgRE9DVU1FTlRcbiAgfCBET0NVTUVOVF9UWVBFXG4gIHwgRE9DVU1FTlRfRlJBR01FTlRcbiAgfCBOT1RBVElPTlxuXG5tb2R1bGUgRG9jdW1lbnRQb3NpdGlvbiA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICB0eXBlIG1hc2sgPSBpbnRcblxuICBsZXQgZGlzY29ubmVjdGVkID0gMHgwMVxuXG4gIGxldCBwcmVjZWRpbmcgPSAweDAyXG5cbiAgbGV0IGZvbGxvd2luZyA9IDB4MDRcblxuICBsZXQgY29udGFpbnMgPSAweDA4XG5cbiAgbGV0IGNvbnRhaW5lZF9ieSA9IDB4MTBcblxuICBsZXQgaW1wbGVtZW50YXRpb25fc3BlY2lmaWMgPSAweDIwXG5cbiAgbGV0IGhhcyB0IG1hc2sgPSB0IGxhbmQgbWFzayA9IG1hc2tcblxuICBsZXQgYWRkIHggeSA9IHggbG9yIHlcblxuICBsZXQgKCArICkgPSBhZGRcbmVuZFxuXG5jbGFzcyB0eXBlIG5vZGUgPVxuICBvYmplY3RcbiAgICBtZXRob2Qgbm9kZU5hbWUgOiBqc19zdHJpbmcgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgbm9kZVZhbHVlIDoganNfc3RyaW5nIHQgb3B0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBub2RlVHlwZSA6IG5vZGVUeXBlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBwYXJlbnROb2RlIDogbm9kZSB0IG9wdCBwcm9wXG5cbiAgICBtZXRob2QgY2hpbGROb2RlcyA6IG5vZGUgbm9kZUxpc3QgdCBwcm9wXG5cbiAgICBtZXRob2QgZmlyc3RDaGlsZCA6IG5vZGUgdCBvcHQgcHJvcFxuXG4gICAgbWV0aG9kIGxhc3RDaGlsZCA6IG5vZGUgdCBvcHQgcHJvcFxuXG4gICAgbWV0aG9kIHByZXZpb3VzU2libGluZyA6IG5vZGUgdCBvcHQgcHJvcFxuXG4gICAgbWV0aG9kIG5leHRTaWJsaW5nIDogbm9kZSB0IG9wdCBwcm9wXG5cbiAgICBtZXRob2QgbmFtZXNwYWNlVVJJIDoganNfc3RyaW5nIHQgb3B0IHByb3BcblxuICAgIG1ldGhvZCBpbnNlcnRCZWZvcmUgOiBub2RlIHQgLT4gbm9kZSB0IG9wdCAtPiBub2RlIHQgbWV0aFxuXG4gICAgbWV0aG9kIHJlcGxhY2VDaGlsZCA6IG5vZGUgdCAtPiBub2RlIHQgLT4gbm9kZSB0IG1ldGhcblxuICAgIG1ldGhvZCByZW1vdmVDaGlsZCA6IG5vZGUgdCAtPiBub2RlIHQgbWV0aFxuXG4gICAgbWV0aG9kIGFwcGVuZENoaWxkIDogbm9kZSB0IC0+IG5vZGUgdCBtZXRoXG5cbiAgICBtZXRob2QgaGFzQ2hpbGROb2RlcyA6IGJvb2wgdCBtZXRoXG5cbiAgICBtZXRob2QgY2xvbmVOb2RlIDogYm9vbCB0IC0+IG5vZGUgdCBtZXRoXG5cbiAgICBtZXRob2QgY29tcGFyZURvY3VtZW50UG9zaXRpb24gOiBub2RlIHQgLT4gRG9jdW1lbnRQb3NpdGlvbi50IG1ldGhcblxuICAgIG1ldGhvZCBsb29rdXBOYW1lc3BhY2VVUkkgOiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCBvcHQgbWV0aFxuXG4gICAgbWV0aG9kIGxvb2t1cFByZWZpeCA6IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IG9wdCBtZXRoXG4gIGVuZFxuXG5sZXQgYXBwZW5kQ2hpbGQgKHAgOiAjbm9kZSB0KSAobiA6ICNub2RlIHQpID0gaWdub3JlIChwIyNhcHBlbmRDaGlsZCAobiA6PiBub2RlIHQpKVxuXG5sZXQgcmVtb3ZlQ2hpbGQgKHAgOiAjbm9kZSB0KSAobiA6ICNub2RlIHQpID0gaWdub3JlIChwIyNyZW1vdmVDaGlsZCAobiA6PiBub2RlIHQpKVxuXG5sZXQgcmVwbGFjZUNoaWxkIChwIDogI25vZGUgdCkgKG4gOiAjbm9kZSB0KSAobyA6ICNub2RlIHQpID1cbiAgaWdub3JlIChwIyNyZXBsYWNlQ2hpbGQgKG4gOj4gbm9kZSB0KSAobyA6PiBub2RlIHQpKVxuXG5sZXQgaW5zZXJ0QmVmb3JlIChwIDogI25vZGUgdCkgKG4gOiAjbm9kZSB0KSAobyA6ICNub2RlIHQgb3B0KSA9XG4gIGlnbm9yZSAocCMjaW5zZXJ0QmVmb3JlIChuIDo+IG5vZGUgdCkgKG8gOj4gbm9kZSB0IG9wdCkpXG5cbigqKiBTcGVjaWZpY2F0aW9uIG9mIFtBdHRyXSBvYmplY3RzLiAqKVxuY2xhc3MgdHlwZSBhdHRyID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBub2RlXG5cbiAgICBtZXRob2QgbmFtZSA6IGpzX3N0cmluZyB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBzcGVjaWZpZWQgOiBib29sIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHZhbHVlIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIG93bmVyRWxlbWVudCA6IGVsZW1lbnQgdCBwcm9wXG4gIGVuZFxuXG4oKiogU3BlY2lmaWNhdGlvbiBvZiBbTmFtZWROb2RlTWFwXSBvYmplY3RzLiAqKVxuYW5kIFsnbm9kZV0gbmFtZWROb2RlTWFwID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGdldE5hbWVkSXRlbSA6IGpzX3N0cmluZyB0IC0+ICdub2RlIHQgb3B0IG1ldGhcblxuICAgIG1ldGhvZCBzZXROYW1lZEl0ZW0gOiAnbm9kZSB0IC0+ICdub2RlIHQgb3B0IG1ldGhcblxuICAgIG1ldGhvZCByZW1vdmVOYW1lZEl0ZW0gOiBqc19zdHJpbmcgdCAtPiAnbm9kZSB0IG9wdCBtZXRoXG5cbiAgICBtZXRob2QgaXRlbSA6IGludCAtPiAnbm9kZSB0IG9wdCBtZXRoXG5cbiAgICBtZXRob2QgbGVuZ3RoIDogaW50IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbigqKiBTcGVjaWZpY2F0aW9uIG9mIFtFbGVtZW50XSBvYmplY3RzLiAqKVxuYW5kIGVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IG5vZGVcblxuICAgIG1ldGhvZCB0YWdOYW1lIDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGdldEF0dHJpYnV0ZSA6IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IG9wdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0QXR0cmlidXRlIDoganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgcmVtb3ZlQXR0cmlidXRlIDoganNfc3RyaW5nIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgaGFzQXR0cmlidXRlIDoganNfc3RyaW5nIHQgLT4gYm9vbCB0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRBdHRyaWJ1dGVOUyA6IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IG9wdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0QXR0cmlidXRlTlMgOiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCByZW1vdmVBdHRyaWJ1dGVOUyA6IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGhhc0F0dHJpYnV0ZU5TIDoganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgLT4gYm9vbCB0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRBdHRyaWJ1dGVOb2RlIDoganNfc3RyaW5nIHQgLT4gYXR0ciB0IG9wdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0QXR0cmlidXRlTm9kZSA6IGF0dHIgdCAtPiBhdHRyIHQgb3B0IG1ldGhcblxuICAgIG1ldGhvZCByZW1vdmVBdHRyaWJ1dGVOb2RlIDogYXR0ciB0IC0+IGF0dHIgdCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0QXR0cmlidXRlTm9kZU5TIDoganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgLT4gYXR0ciB0IG9wdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0QXR0cmlidXRlTm9kZU5TIDogYXR0ciB0IC0+IGF0dHIgdCBvcHQgbWV0aFxuXG4gICAgbWV0aG9kIGdldEVsZW1lbnRzQnlUYWdOYW1lIDoganNfc3RyaW5nIHQgLT4gZWxlbWVudCBub2RlTGlzdCB0IG1ldGhcblxuICAgIG1ldGhvZCBhdHRyaWJ1dGVzIDogYXR0ciBuYW1lZE5vZGVNYXAgdCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIGNoYXJhY3RlckRhdGEgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IG5vZGVcblxuICAgIG1ldGhvZCBkYXRhIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGxlbmd0aCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgc3VianNfc3RyaW5nRGF0YSA6IGludCAtPiBpbnQgLT4ganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIGFwcGVuZERhdGEgOiBqc19zdHJpbmcgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBpbnNlcnREYXRhIDogaW50IC0+IGpzX3N0cmluZyB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGRlbGV0ZURhdGEgOiBpbnQgLT4gaW50IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHJlcGxhY2VEYXRhIDogaW50IC0+IGludCAtPiBqc19zdHJpbmcgdCAtPiB1bml0IG1ldGhcbiAgZW5kXG5cbmNsYXNzIHR5cGUgY29tbWVudCA9IGNoYXJhY3RlckRhdGFcblxuY2xhc3MgdHlwZSB0ZXh0ID0gY2hhcmFjdGVyRGF0YVxuXG5jbGFzcyB0eXBlIGRvY3VtZW50RnJhZ21lbnQgPSBub2RlXG5cbmNsYXNzIHR5cGUgWydlbGVtZW50XSBkb2N1bWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgbm9kZVxuXG4gICAgbWV0aG9kIGRvY3VtZW50RWxlbWVudCA6ICdlbGVtZW50IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQgOiBkb2N1bWVudEZyYWdtZW50IHQgbWV0aFxuXG4gICAgbWV0aG9kIGNyZWF0ZUVsZW1lbnQgOiBqc19zdHJpbmcgdCAtPiAnZWxlbWVudCB0IG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVFbGVtZW50TlMgOiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCAtPiAnZWxlbWVudCB0IG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVUZXh0Tm9kZSA6IGpzX3N0cmluZyB0IC0+IHRleHQgdCBtZXRoXG5cbiAgICBtZXRob2QgY3JlYXRlQXR0cmlidXRlIDoganNfc3RyaW5nIHQgLT4gYXR0ciB0IG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVDb21tZW50IDoganNfc3RyaW5nIHQgLT4gY29tbWVudCB0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRFbGVtZW50QnlJZCA6IGpzX3N0cmluZyB0IC0+ICdlbGVtZW50IHQgb3B0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRFbGVtZW50c0J5VGFnTmFtZSA6IGpzX3N0cmluZyB0IC0+ICdlbGVtZW50IG5vZGVMaXN0IHQgbWV0aFxuXG4gICAgbWV0aG9kIGltcG9ydE5vZGUgOiBlbGVtZW50IHQgLT4gYm9vbCB0IC0+ICdlbGVtZW50IHQgbWV0aFxuXG4gICAgbWV0aG9kIGFkb3B0Tm9kZSA6IGVsZW1lbnQgdCAtPiAnZWxlbWVudCB0IG1ldGhcbiAgZW5kXG5cbnR5cGUgbm9kZV90eXBlID1cbiAgfCBFbGVtZW50IG9mIGVsZW1lbnQgdFxuICB8IEF0dHIgb2YgYXR0ciB0XG4gIHwgVGV4dCBvZiB0ZXh0IHRcbiAgfCBPdGhlciBvZiBub2RlIHRcblxubGV0IG5vZGVUeXBlIGUgPVxuICBtYXRjaCBlIyMubm9kZVR5cGUgd2l0aFxuICB8IEVMRU1FTlQgLT4gRWxlbWVudCAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICB8IEFUVFJJQlVURSAtPiBBdHRyIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gIHwgQ0RBVEFfU0VDVElPTiB8IFRFWFQgLT4gVGV4dCAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICB8IF8gLT4gT3RoZXIgKGUgOj4gbm9kZSB0KVxuXG5tb2R1bGUgQ29lcmNlVG8gPSBzdHJ1Y3RcbiAgbGV0IGNhc3QgKGUgOiAjbm9kZSBKcy50KSB0ID1cbiAgICBpZiBlIyMubm9kZVR5cGUgPT0gdCB0aGVuIEpzLnNvbWUgKEpzLlVuc2FmZS5jb2VyY2UgZSkgZWxzZSBKcy5udWxsXG5cbiAgbGV0IGVsZW1lbnQgZSA6IGVsZW1lbnQgSnMudCBKcy5vcHQgPSBjYXN0IGUgRUxFTUVOVFxuXG4gIGxldCB0ZXh0IGUgOiB0ZXh0IEpzLnQgSnMub3B0ID1cbiAgICBpZiBlIyMubm9kZVR5cGUgPT0gVEVYVCB8fCBlIyMubm9kZVR5cGUgPT0gQ0RBVEFfU0VDVElPTlxuICAgIHRoZW4gSnMuc29tZSAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICAgIGVsc2UgSnMubnVsbFxuXG4gIGxldCBhdHRyIGUgOiBhdHRyIEpzLnQgSnMub3B0ID0gY2FzdCBlIEFUVFJJQlVURVxuZW5kXG5cbnR5cGUgKCdhLCAnYikgZXZlbnRfbGlzdGVuZXIgPSAoJ2EsICdiIC0+IGJvb2wgdCkgbWV0aF9jYWxsYmFjayBvcHRcbigqKiBUaGUgdHlwZSBvZiBldmVudCBsaXN0ZW5lciBmdW5jdGlvbnMuICBUaGUgZmlyc3QgdHlwZSBwYXJhbWV0ZXJcbiAgICAgIFsnYV0gaXMgdGhlIHR5cGUgb2YgdGhlIHRhcmdldCBvYmplY3Q7IHRoZSBzZWNvbmQgcGFyYW1ldGVyXG4gICAgICBbJ2JdIGlzIHRoZSB0eXBlIG9mIHRoZSBldmVudCBvYmplY3QuICopXG5cbmNsYXNzIHR5cGUgWydhXSBldmVudCA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBfdHlwZSA6IGpzX3N0cmluZyB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB0YXJnZXQgOiAnYSB0IG9wdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgY3VycmVudFRhcmdldCA6ICdhIHQgb3B0IHJlYWRvbmx5X3Byb3BcblxuICAgICgqIExlZ2FjeSBtZXRob2RzICopXG4gICAgbWV0aG9kIHNyY0VsZW1lbnQgOiAnYSB0IG9wdCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIFsnYSwgJ2JdIGN1c3RvbUV2ZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBbJ2FdIGV2ZW50XG5cbiAgICBtZXRob2QgZGV0YWlsIDogJ2IgSnMub3B0IEpzLnJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbmxldCBub19oYW5kbGVyIDogKCdhLCAnYikgZXZlbnRfbGlzdGVuZXIgPSBKcy5udWxsXG5cbmxldCB3aW5kb3dfZXZlbnQgKCkgOiAnYSAjZXZlbnQgdCA9IEpzLlVuc2FmZS5wdXJlX2pzX2V4cHIgXCJldmVudFwiXG5cbigqIFRoZSBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCBtdXN0IGJlIGNhbGxlZCBleHBsaWNpdGx5IHdoZW5cbiAgIHVzaW5nIGFkZEV2ZW50TGlzdGVuZXIuLi4gKilcbmxldCBoYW5kbGVyIGYgPVxuICBKcy5zb21lXG4gICAgKEpzLlVuc2FmZS5jYWxsYmFjayAoZnVuIGUgLT5cbiAgICAgICAgICgqIGRlcGVuZGluZyBvbiB0aGUgaW50ZXJuZXQgZXhwbG9yZXIgdmVyc2lvbiwgZSBjYW4gYmUgbnVsbCBvciB1bmRlZmluZWQuICopXG4gICAgICAgICBpZiBub3QgKEpzLk9wdC50ZXN0IChzb21lIGUpKVxuICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgIGxldCBlID0gd2luZG93X2V2ZW50ICgpIGluXG4gICAgICAgICAgIGxldCByZXMgPSBmIGUgaW5cbiAgICAgICAgICAgaWYgbm90IChKcy50b19ib29sIHJlcykgdGhlbiBlIyMucmV0dXJuVmFsdWUgOj0gcmVzO1xuICAgICAgICAgICByZXMpXG4gICAgICAgICBlbHNlXG4gICAgICAgICAgIGxldCByZXMgPSBmIGUgaW5cbiAgICAgICAgICAgaWYgbm90IChKcy50b19ib29sIHJlcykgdGhlbiAoSnMuVW5zYWZlLmNvZXJjZSBlKSMjcHJldmVudERlZmF1bHQ7XG4gICAgICAgICAgIHJlcykpXG5cbmxldCBmdWxsX2hhbmRsZXIgZiA9XG4gIEpzLnNvbWVcbiAgICAoSnMuVW5zYWZlLm1ldGhfY2FsbGJhY2sgKGZ1biB0aGlzIGUgLT5cbiAgICAgICAgICgqIGRlcGVuZGluZyBvbiB0aGUgaW50ZXJuZXQgZXhwbG9yZXIgdmVyc2lvbiwgZSBjYW4gYmUgbnVsbCBvciB1bmRlZmluZWQgKilcbiAgICAgICAgIGlmIG5vdCAoSnMuT3B0LnRlc3QgKHNvbWUgZSkpXG4gICAgICAgICB0aGVuIChcbiAgICAgICAgICAgbGV0IGUgPSB3aW5kb3dfZXZlbnQgKCkgaW5cbiAgICAgICAgICAgbGV0IHJlcyA9IGYgdGhpcyBlIGluXG4gICAgICAgICAgIGlmIG5vdCAoSnMudG9fYm9vbCByZXMpIHRoZW4gZSMjLnJldHVyblZhbHVlIDo9IHJlcztcbiAgICAgICAgICAgcmVzKVxuICAgICAgICAgZWxzZVxuICAgICAgICAgICBsZXQgcmVzID0gZiB0aGlzIGUgaW5cbiAgICAgICAgICAgaWYgbm90IChKcy50b19ib29sIHJlcykgdGhlbiAoSnMuVW5zYWZlLmNvZXJjZSBlKSMjcHJldmVudERlZmF1bHQ7XG4gICAgICAgICAgIHJlcykpXG5cbmxldCBpbnZva2VfaGFuZGxlciAoZiA6ICgnYSwgJ2IpIGV2ZW50X2xpc3RlbmVyKSAodGhpcyA6ICdhKSAoZXZlbnQgOiAnYikgOiBib29sIHQgPVxuICBKcy5VbnNhZmUuY2FsbCBmIHRoaXMgW3wgSnMuVW5zYWZlLmluamVjdCBldmVudCB8XVxuXG5sZXQgZXZlbnRUYXJnZXQgKGUgOiAoPCAuLiA+IGFzICdhKSAjZXZlbnQgdCkgOiAnYSB0ID1cbiAgbGV0IHRhcmdldCA9XG4gICAgT3B0LmdldCBlIyMudGFyZ2V0IChmdW4gKCkgLT4gT3B0LmdldCBlIyMuc3JjRWxlbWVudCAoZnVuICgpIC0+IHJhaXNlIE5vdF9mb3VuZCkpXG4gIGluXG4gIGlmIEpzLmluc3RhbmNlb2YgdGFyZ2V0IEpzLlVuc2FmZS5nbG9iYWwjIy5fTm9kZVxuICB0aGVuXG4gICAgKCogV29ya2Fyb3VuZCBmb3IgU2FmYXJpIGJ1ZyAqKVxuICAgIGxldCB0YXJnZXQnIDogbm9kZSBKcy50ID0gSnMuVW5zYWZlLmNvZXJjZSB0YXJnZXQgaW5cbiAgICBpZiB0YXJnZXQnIyMubm9kZVR5cGUgPT0gVEVYVFxuICAgIHRoZW4gSnMuVW5zYWZlLmNvZXJjZSAoT3B0LmdldCB0YXJnZXQnIyMucGFyZW50Tm9kZSAoZnVuICgpIC0+IGFzc2VydCBmYWxzZSkpXG4gICAgZWxzZSB0YXJnZXRcbiAgZWxzZSB0YXJnZXRcblxubW9kdWxlIEV2ZW50ID0gc3RydWN0XG4gIHR5cGUgJ2EgdHlwID0gSnMuanNfc3RyaW5nIEpzLnRcblxuICBsZXQgbWFrZSBzID0gSnMuc3RyaW5nIHNcbmVuZFxuXG50eXBlIGV2ZW50X2xpc3RlbmVyX2lkID0gdW5pdCAtPiB1bml0XG5cbmNsYXNzIHR5cGUgZXZlbnRfbGlzdGVuZXJfb3B0aW9ucyA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBjYXB0dXJlIDogYm9vbCB0IHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25jZSA6IGJvb2wgdCB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHBhc3NpdmUgOiBib29sIHQgd3JpdGVvbmx5X3Byb3BcbiAgZW5kXG5cbmxldCBhZGRFdmVudExpc3RlbmVyV2l0aE9wdGlvbnMgKGUgOiAoPCAuLiA+IGFzICdhKSB0KSB0eXAgP2NhcHR1cmUgP29uY2UgP3Bhc3NpdmUgaCA9XG4gIGlmIChKcy5VbnNhZmUuY29lcmNlIGUpIyMuYWRkRXZlbnRMaXN0ZW5lciA9PSBKcy51bmRlZmluZWRcbiAgdGhlblxuICAgIGxldCBldiA9IChKcy5zdHJpbmcgXCJvblwiKSMjY29uY2F0IHR5cCBpblxuICAgIGxldCBjYWxsYmFjayBlID0gSnMuVW5zYWZlLmNhbGwgKGgsIGUsIFt8fF0pIGluXG4gICAgbGV0ICgpID0gKEpzLlVuc2FmZS5jb2VyY2UgZSkjI2F0dGFjaEV2ZW50IGV2IGNhbGxiYWNrIGluXG4gICAgZnVuICgpIC0+IChKcy5VbnNhZmUuY29lcmNlIGUpIyNkZXRhY2hFdmVudCBldiBjYWxsYmFja1xuICBlbHNlXG4gICAgbGV0IG9wdHMgOiBldmVudF9saXN0ZW5lcl9vcHRpb25zIHQgPSBKcy5VbnNhZmUub2JqIFt8fF0gaW5cbiAgICBsZXQgaXRlciB0IGYgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBiIC0+IGYgYlxuICAgIGluXG4gICAgaXRlciBjYXB0dXJlIChmdW4gYiAtPiBvcHRzIyMuY2FwdHVyZSA6PSBiKTtcbiAgICBpdGVyIG9uY2UgKGZ1biBiIC0+IG9wdHMjIy5vbmNlIDo9IGIpO1xuICAgIGl0ZXIgcGFzc2l2ZSAoZnVuIGIgLT4gb3B0cyMjLnBhc3NpdmUgOj0gYik7XG4gICAgbGV0ICgpID0gKEpzLlVuc2FmZS5jb2VyY2UgZSkjI2FkZEV2ZW50TGlzdGVuZXIgdHlwIGggb3B0cyBpblxuICAgIGZ1biAoKSAtPiAoSnMuVW5zYWZlLmNvZXJjZSBlKSMjcmVtb3ZlRXZlbnRMaXN0ZW5lciB0eXAgaCBvcHRzXG5cbmxldCBhZGRFdmVudExpc3RlbmVyIChlIDogKDwgLi4gPiBhcyAnYSkgdCkgdHlwIGggY2FwdCA9XG4gIGFkZEV2ZW50TGlzdGVuZXJXaXRoT3B0aW9ucyBlIHR5cCB+Y2FwdHVyZTpjYXB0IGhcblxubGV0IHJlbW92ZUV2ZW50TGlzdGVuZXIgaWQgPSBpZCAoKVxuXG5sZXQgcHJldmVudERlZmF1bHQgZXYgPVxuICBpZiBKcy5PcHRkZWYudGVzdCAoSnMuVW5zYWZlLmNvZXJjZSBldikjIy5wcmV2ZW50RGVmYXVsdCAoKiBJRSBoYWNrICopXG4gIHRoZW4gKEpzLlVuc2FmZS5jb2VyY2UgZXYpIyNwcmV2ZW50RGVmYXVsdFxuICBlbHNlIChKcy5VbnNhZmUuY29lcmNlIGV2KSMjLnJldHVyblZhbHVlIDo9IEpzLmJvb2wgZmFsc2VcblxubGV0IGNyZWF0ZUN1c3RvbUV2ZW50ID9idWJibGVzID9jYW5jZWxhYmxlID9kZXRhaWwgdHlwID1cbiAgbGV0IG9wdF9pdGVyIGYgPSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSB4IC0+IGYgeFxuICBpblxuICBsZXQgb3B0cyA9IFVuc2FmZS5vYmogW3x8XSBpblxuICBvcHRfaXRlciAoZnVuIHggLT4gb3B0cyMjLmJ1YmJsZXMgOj0gYm9vbCB4KSBidWJibGVzO1xuICBvcHRfaXRlciAoZnVuIHggLT4gb3B0cyMjLmNhbmNlbGFibGUgOj0gYm9vbCB4KSBjYW5jZWxhYmxlO1xuICBvcHRfaXRlciAoZnVuIHggLT4gb3B0cyMjLmRldGFpbCA6PSBzb21lIHgpIGRldGFpbDtcbiAgbGV0IGNvbnN0ciA6XG4gICAgICAoICAgKCdhLCAnYikgI2N1c3RvbUV2ZW50IEpzLnQgRXZlbnQudHlwXG4gICAgICAgLT4gPCBkZXRhaWwgOiAnYiBvcHQgcHJvcCA+IHRcbiAgICAgICAtPiAoJ2EsICdiKSBjdXN0b21FdmVudCB0KVxuICAgICAgY29uc3RyID1cbiAgICBVbnNhZmUuZ2xvYmFsIyMuX0N1c3RvbUV2ZW50XG4gIGluXG4gIG5ldyVqcyBjb25zdHIgdHlwIG9wdHNcblxuKCogSUUgPCA5ICopXG5cbmNsYXNzIHR5cGUgc3RyaW5nTGlzdCA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBpdGVtIDogaW50IC0+IGpzX3N0cmluZyB0IG9wdCBtZXRoXG5cbiAgICBtZXRob2QgbGVuZ3RoIDogaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBjb250YWlucyA6IGpzX3N0cmluZyB0IC0+IGJvb2wgdCBtZXRoXG4gIGVuZFxuIiwiKCogSnNfb2Zfb2NhbWwgbGlicmFyeVxuICogaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbiAqIENvcHlyaWdodCAoQykgMjAxMiBKw6lyw7RtZSBWb3VpbGxvblxuICogTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbiAqIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICopXG5vcGVuISBJbXBvcnRcbm9wZW4gSnNcblxudHlwZSB1aW50MzIgPSBmbG9hdFxuXG5jbGFzcyB0eXBlIGFycmF5QnVmZmVyID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGJ5dGVMZW5ndGggOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHNsaWNlIDogaW50IC0+IGludCAtPiBhcnJheUJ1ZmZlciB0IG1ldGhcblxuICAgIG1ldGhvZCBzbGljZV90b0VuZCA6IGludCAtPiBhcnJheUJ1ZmZlciB0IG1ldGhcbiAgZW5kXG5cbmxldCBhcnJheUJ1ZmZlciA6IChpbnQgLT4gYXJyYXlCdWZmZXIgdCkgY29uc3RyID0gSnMuVW5zYWZlLmdsb2JhbCMjLl9BcnJheUJ1ZmZlclxuXG5jbGFzcyB0eXBlIGFycmF5QnVmZmVyVmlldyA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBidWZmZXIgOiBhcnJheUJ1ZmZlciB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBieXRlT2Zmc2V0IDogaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBieXRlTGVuZ3RoIDogaW50IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbmNsYXNzIHR5cGUgWydhLCAnYl0gdHlwZWRBcnJheSA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgYXJyYXlCdWZmZXJWaWV3XG5cbiAgICBtZXRob2QgX0JZVEVTX1BFUl9FTEVNRU5UIDogaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBsZW5ndGggOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHNldF9mcm9tQXJyYXkgOiAnYSBqc19hcnJheSB0IC0+IGludCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzZXRfZnJvbVR5cGVkQXJyYXkgOiAoJ2EsICdiKSB0eXBlZEFycmF5IHQgLT4gaW50IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHN1YmFycmF5IDogaW50IC0+IGludCAtPiAoJ2EsICdiKSB0eXBlZEFycmF5IHQgbWV0aFxuXG4gICAgbWV0aG9kIHN1YmFycmF5X3RvRW5kIDogaW50IC0+ICgnYSwgJ2IpIHR5cGVkQXJyYXkgdCBtZXRoXG5cbiAgICBtZXRob2Qgc2xpY2UgOiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IpIHR5cGVkQXJyYXkgdCBtZXRoXG5cbiAgICBtZXRob2Qgc2xpY2VfdG9FbmQgOiBpbnQgLT4gKCdhLCAnYikgdHlwZWRBcnJheSB0IG1ldGhcblxuICAgICgqIFRoaXMgZmFrZSBtZXRob2QgaXMgbmVlZGVkIGZvciB0eXBpbmcgcHVycG9zZXMuXG4gICAgICAgV2l0aG91dCBpdCwgWydiXSB3b3VsZCBub3QgYmUgY29uc3RyYWluZWQuICopXG4gICAgbWV0aG9kIF9jb250ZW50X3R5cGVfIDogJ2Igb3B0ZGVmIHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbnR5cGUgaW50OEFycmF5ID0gKGludCwgQmlnYXJyYXkuaW50OF9zaWduZWRfZWx0KSB0eXBlZEFycmF5XG5cbnR5cGUgdWludDhBcnJheSA9IChpbnQsIEJpZ2FycmF5LmludDhfdW5zaWduZWRfZWx0KSB0eXBlZEFycmF5XG5cbnR5cGUgaW50MTZBcnJheSA9IChpbnQsIEJpZ2FycmF5LmludDE2X3NpZ25lZF9lbHQpIHR5cGVkQXJyYXlcblxudHlwZSB1aW50MTZBcnJheSA9IChpbnQsIEJpZ2FycmF5LmludDE2X3Vuc2lnbmVkX2VsdCkgdHlwZWRBcnJheVxuXG50eXBlIGludDMyQXJyYXkgPSAoaW50MzIsIEJpZ2FycmF5LmludDMyX2VsdCkgdHlwZWRBcnJheVxuXG50eXBlIHVpbnQzMkFycmF5ID0gKGludDMyLCBCaWdhcnJheS5pbnQzMl9lbHQpIHR5cGVkQXJyYXlcblxudHlwZSBmbG9hdDMyQXJyYXkgPSAoZmxvYXQsIEJpZ2FycmF5LmZsb2F0MzJfZWx0KSB0eXBlZEFycmF5XG5cbnR5cGUgZmxvYXQ2NEFycmF5ID0gKGZsb2F0LCBCaWdhcnJheS5mbG9hdDY0X2VsdCkgdHlwZWRBcnJheVxuXG5leHRlcm5hbCBraW5kIDogKCdhLCAnYikgdHlwZWRBcnJheSB0IC0+ICgnYSwgJ2IpIEJpZ2FycmF5LmtpbmRcbiAgPSBcImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheVwiXG5cbmV4dGVybmFsIGZyb21fZ2VuYXJyYXkgOlxuICAoJ2EsICdiLCBCaWdhcnJheS5jX2xheW91dCkgQmlnYXJyYXkuR2VuYXJyYXkudCAtPiAoJ2EsICdiKSB0eXBlZEFycmF5IHRcbiAgPSBcImNhbWxfYmFfdG9fdHlwZWRfYXJyYXlcIlxuXG5leHRlcm5hbCB0b19nZW5hcnJheSA6XG4gICgnYSwgJ2IpIHR5cGVkQXJyYXkgdCAtPiAoJ2EsICdiLCBCaWdhcnJheS5jX2xheW91dCkgQmlnYXJyYXkuR2VuYXJyYXkudFxuICA9IFwiY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5XCJcblxubGV0IGludDhBcnJheSA9IEpzLlVuc2FmZS5nbG9iYWwjIy5fSW50OEFycmF5XG5cbmxldCBpbnQ4QXJyYXlfZnJvbUFycmF5ID0gaW50OEFycmF5XG5cbmxldCBpbnQ4QXJyYXlfZnJvbVR5cGVkQXJyYXkgPSBpbnQ4QXJyYXlcblxubGV0IGludDhBcnJheV9mcm9tQnVmZmVyID0gaW50OEFycmF5XG5cbmxldCBpbnQ4QXJyYXlfaW5CdWZmZXIgPSBpbnQ4QXJyYXlcblxubGV0IHVpbnQ4QXJyYXkgPSBKcy5VbnNhZmUuZ2xvYmFsIyMuX1VpbnQ4QXJyYXlcblxubGV0IHVpbnQ4QXJyYXlfZnJvbUFycmF5ID0gdWludDhBcnJheVxuXG5sZXQgdWludDhBcnJheV9mcm9tVHlwZWRBcnJheSA9IHVpbnQ4QXJyYXlcblxubGV0IHVpbnQ4QXJyYXlfZnJvbUJ1ZmZlciA9IHVpbnQ4QXJyYXlcblxubGV0IHVpbnQ4QXJyYXlfaW5CdWZmZXIgPSB1aW50OEFycmF5XG5cbmxldCBpbnQxNkFycmF5ID0gSnMuVW5zYWZlLmdsb2JhbCMjLl9JbnQxNkFycmF5XG5cbmxldCBpbnQxNkFycmF5X2Zyb21BcnJheSA9IGludDE2QXJyYXlcblxubGV0IGludDE2QXJyYXlfZnJvbVR5cGVkQXJyYXkgPSBpbnQxNkFycmF5XG5cbmxldCBpbnQxNkFycmF5X2Zyb21CdWZmZXIgPSBpbnQxNkFycmF5XG5cbmxldCBpbnQxNkFycmF5X2luQnVmZmVyID0gaW50MTZBcnJheVxuXG5sZXQgdWludDE2QXJyYXkgPSBKcy5VbnNhZmUuZ2xvYmFsIyMuX1VpbnQxNkFycmF5XG5cbmxldCB1aW50MTZBcnJheV9mcm9tQXJyYXkgPSB1aW50MTZBcnJheVxuXG5sZXQgdWludDE2QXJyYXlfZnJvbVR5cGVkQXJyYXkgPSB1aW50MTZBcnJheVxuXG5sZXQgdWludDE2QXJyYXlfZnJvbUJ1ZmZlciA9IHVpbnQxNkFycmF5XG5cbmxldCB1aW50MTZBcnJheV9pbkJ1ZmZlciA9IHVpbnQxNkFycmF5XG5cbmxldCBpbnQzMkFycmF5ID0gSnMuVW5zYWZlLmdsb2JhbCMjLl9JbnQzMkFycmF5XG5cbmxldCBpbnQzMkFycmF5X2Zyb21BcnJheSA9IGludDMyQXJyYXlcblxubGV0IGludDMyQXJyYXlfZnJvbVR5cGVkQXJyYXkgPSBpbnQzMkFycmF5XG5cbmxldCBpbnQzMkFycmF5X2Zyb21CdWZmZXIgPSBpbnQzMkFycmF5XG5cbmxldCBpbnQzMkFycmF5X2luQnVmZmVyID0gaW50MzJBcnJheVxuXG5sZXQgdWludDMyQXJyYXkgPSBKcy5VbnNhZmUuZ2xvYmFsIyMuX1VpbnQzMkFycmF5XG5cbmxldCB1aW50MzJBcnJheV9mcm9tQXJyYXkgPSB1aW50MzJBcnJheVxuXG5sZXQgdWludDMyQXJyYXlfZnJvbVR5cGVkQXJyYXkgPSB1aW50MzJBcnJheVxuXG5sZXQgdWludDMyQXJyYXlfZnJvbUJ1ZmZlciA9IHVpbnQzMkFycmF5XG5cbmxldCB1aW50MzJBcnJheV9pbkJ1ZmZlciA9IHVpbnQzMkFycmF5XG5cbmxldCBmbG9hdDMyQXJyYXkgPSBKcy5VbnNhZmUuZ2xvYmFsIyMuX0Zsb2F0MzJBcnJheVxuXG5sZXQgZmxvYXQzMkFycmF5X2Zyb21BcnJheSA9IGZsb2F0MzJBcnJheVxuXG5sZXQgZmxvYXQzMkFycmF5X2Zyb21UeXBlZEFycmF5ID0gZmxvYXQzMkFycmF5XG5cbmxldCBmbG9hdDMyQXJyYXlfZnJvbUJ1ZmZlciA9IGZsb2F0MzJBcnJheVxuXG5sZXQgZmxvYXQzMkFycmF5X2luQnVmZmVyID0gZmxvYXQzMkFycmF5XG5cbmxldCBmbG9hdDY0QXJyYXkgPSBKcy5VbnNhZmUuZ2xvYmFsIyMuX0Zsb2F0NjRBcnJheVxuXG5sZXQgZmxvYXQ2NEFycmF5X2Zyb21BcnJheSA9IGZsb2F0NjRBcnJheVxuXG5sZXQgZmxvYXQ2NEFycmF5X2Zyb21UeXBlZEFycmF5ID0gZmxvYXQ2NEFycmF5XG5cbmxldCBmbG9hdDY0QXJyYXlfZnJvbUJ1ZmZlciA9IGZsb2F0NjRBcnJheVxuXG5sZXQgZmxvYXQ2NEFycmF5X2luQnVmZmVyID0gZmxvYXQ2NEFycmF5XG5cbmxldCBzZXQgOiAoJ2EsICdiKSB0eXBlZEFycmF5IHQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPVxuIGZ1biBhIGkgdiAtPiBhcnJheV9zZXQgKFVuc2FmZS5jb2VyY2UgYSkgaSB2XG5cbmxldCBnZXQgOiAoJ2EsICdiKSB0eXBlZEFycmF5IHQgLT4gaW50IC0+ICdhIG9wdGRlZiA9IGZ1biBhIGkgLT4gSnMuVW5zYWZlLmdldCBhIGlcblxubGV0IHVuc2FmZV9nZXQgOiAoJ2EsICdiKSB0eXBlZEFycmF5IHQgLT4gaW50IC0+ICdhID0gZnVuIGEgaSAtPiBKcy5VbnNhZmUuZ2V0IGEgaVxuXG5jbGFzcyB0eXBlIGRhdGFWaWV3ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBhcnJheUJ1ZmZlclZpZXdcblxuICAgIG1ldGhvZCBnZXRJbnQ4IDogaW50IC0+IGludCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0VWludDggOiBpbnQgLT4gaW50IG1ldGhcblxuICAgIG1ldGhvZCBnZXRJbnQxNiA6IGludCAtPiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIGdldEludDE2XyA6IGludCAtPiBib29sIHQgLT4gaW50IG1ldGhcblxuICAgIG1ldGhvZCBnZXRVaW50MTYgOiBpbnQgLT4gaW50IG1ldGhcblxuICAgIG1ldGhvZCBnZXRVaW50MTZfIDogaW50IC0+IGJvb2wgdCAtPiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIGdldEludDMyIDogaW50IC0+IGludCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0SW50MzJfIDogaW50IC0+IGJvb2wgdCAtPiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIGdldFVpbnQzMiA6IGludCAtPiB1aW50MzIgbWV0aFxuXG4gICAgbWV0aG9kIGdldFVpbnQzMl8gOiBpbnQgLT4gYm9vbCB0IC0+IHVpbnQzMiBtZXRoXG5cbiAgICBtZXRob2QgZ2V0RmxvYXQzMiA6IGludCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0RmxvYXQzMl8gOiBpbnQgLT4gYm9vbCB0IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRGbG9hdDY0IDogaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRGbG9hdDY0XyA6IGludCAtPiBib29sIHQgLT4gZmxvYXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldEludDggOiBpbnQgLT4gaW50IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldFVpbnQ4IDogaW50IC0+IGludCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzZXRJbnQxNiA6IGludCAtPiBpbnQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0SW50MTZfIDogaW50IC0+IGludCAtPiBib29sIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0VWludDE2IDogaW50IC0+IGludCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzZXRVaW50MTZfIDogaW50IC0+IGludCAtPiBib29sIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0SW50MzIgOiBpbnQgLT4gaW50IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldEludDMyXyA6IGludCAtPiBpbnQgLT4gYm9vbCB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldFVpbnQzMiA6IGludCAtPiB1aW50MzIgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0VWludDMyXyA6IGludCAtPiB1aW50MzIgLT4gYm9vbCB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldEZsb2F0MzIgOiBpbnQgLT4gZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0RmxvYXQzMl8gOiBpbnQgLT4gZmxvYXQgLT4gYm9vbCB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldEZsb2F0NjQgOiBpbnQgLT4gZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0RmxvYXQ2NF8gOiBpbnQgLT4gZmxvYXQgLT4gYm9vbCB0IC0+IHVuaXQgbWV0aFxuICBlbmRcblxubGV0IGRhdGFWaWV3ID0gSnMuVW5zYWZlLmdsb2JhbCMjLl9EYXRhVmlld1xuXG5sZXQgZGF0YVZpZXdfaW5CdWZmZXIgPSBkYXRhVmlld1xuXG5tb2R1bGUgQmlnc3RyaW5nID0gc3RydWN0XG4gIHR5cGUgdCA9IChjaGFyLCBCaWdhcnJheS5pbnQ4X3Vuc2lnbmVkX2VsdCwgQmlnYXJyYXkuY19sYXlvdXQpIEJpZ2FycmF5LkFycmF5MS50XG5cbiAgZXh0ZXJuYWwgdG9fYXJyYXlCdWZmZXIgOiB0IC0+IGFycmF5QnVmZmVyIEpzLnQgPSBcImJpZ3N0cmluZ190b19hcnJheV9idWZmZXJcIlxuXG4gIGV4dGVybmFsIHRvX3VpbnQ4QXJyYXkgOiB0IC0+IHVpbnQ4QXJyYXkgSnMudCA9IFwiYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5XCJcblxuICBleHRlcm5hbCBvZl9hcnJheUJ1ZmZlciA6IGFycmF5QnVmZmVyIEpzLnQgLT4gdCA9IFwiYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlclwiXG5cbiAgZXh0ZXJuYWwgb2ZfdWludDhBcnJheSA6IHVpbnQ4QXJyYXkgSnMudCAtPiB0ID0gXCJiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXlcIlxuZW5kXG5cbm1vZHVsZSBTdHJpbmcgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgb2ZfdWludDhBcnJheSA6IHVpbnQ4QXJyYXkgSnMudCAtPiBzdHJpbmcgPSBcImNhbWxfc3RyaW5nX29mX2FycmF5XCJcblxuICBsZXQgb2ZfYXJyYXlCdWZmZXIgYWIgPVxuICAgIGxldCB1aW50OCA9IG5ldyVqcyB1aW50OEFycmF5X2Zyb21CdWZmZXIgYWIgaW5cbiAgICBvZl91aW50OEFycmF5IHVpbnQ4XG5lbmRcbiIsIigqIEpzX29mX29jYW1sIGxpYnJhcnlcbiAqIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTEgUGllcnJlIENoYW1iYXJ0XG4gKiBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3RcbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuICogZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAqIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAqIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4gKilcblxub3BlbiBKc1xub3BlbiBEb21cbm9wZW4hIEltcG9ydFxuXG5jbGFzcyB0eXBlIGJsb2IgPVxuICBvYmplY3RcbiAgICBtZXRob2Qgc2l6ZSA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX3R5cGUgOiBqc19zdHJpbmcgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgc2xpY2UgOiBpbnQgLT4gaW50IC0+IGJsb2IgdCBtZXRoXG5cbiAgICBtZXRob2Qgc2xpY2Vfd2l0aENvbnRlbnRUeXBlIDogaW50IC0+IGludCAtPiBqc19zdHJpbmcgdCAtPiBibG9iIHQgbWV0aFxuICBlbmRcblxubGV0IGJsb2JfY29uc3RyID0gVW5zYWZlLmdsb2JhbCMjLl9CbG9iXG5cbnR5cGUgJ2EgbWFrZV9ibG9iID1cbiAgP2NvbnRlbnRUeXBlOnN0cmluZyAtPiA/ZW5kaW5nczpbIGBUcmFuc3BhcmVudCB8IGBOYXRpdmUgXSAtPiAnYSAtPiBibG9iIHRcblxubGV0IHJlYyBmaWx0ZXJfbWFwIGYgPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgdiA6OiBxIC0+IChcbiAgICAgIG1hdGNoIGYgdiB3aXRoXG4gICAgICB8IE5vbmUgLT4gZmlsdGVyX21hcCBmIHFcbiAgICAgIHwgU29tZSB2JyAtPiB2JyA6OiBmaWx0ZXJfbWFwIGYgcSlcblxubGV0IG1ha2VfYmxvYl9vcHRpb25zIGNvbnRlbnRUeXBlIGVuZGluZ3MgPVxuICBsZXQgb3B0aW9ucyA9XG4gICAgZmlsdGVyX21hcFxuICAgICAgKGZ1biAobmFtZSwgdikgLT5cbiAgICAgICAgbWF0Y2ggdiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgIHwgU29tZSB2IC0+IFNvbWUgKG5hbWUsIFVuc2FmZS5pbmplY3QgKHN0cmluZyB2KSkpXG4gICAgICBbIFwidHlwZVwiLCBjb250ZW50VHlwZVxuICAgICAgOyAoIFwiZW5kaW5nc1wiXG4gICAgICAgICwgbWF0Y2ggZW5kaW5ncyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICB8IFNvbWUgYFRyYW5zcGFyZW50IC0+IFNvbWUgXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgICAgfCBTb21lIGBOYXRpdmUgLT4gU29tZSBcIm5hdGl2ZVwiIClcbiAgICAgIF1cbiAgaW5cbiAgbWF0Y2ggb3B0aW9ucyB3aXRoXG4gIHwgW10gLT4gdW5kZWZpbmVkXG4gIHwgbCAtPiBVbnNhZmUub2JqIChBcnJheS5vZl9saXN0IGwpXG5cbmxldCBibG9iX3JhdyA/Y29udGVudFR5cGUgP2VuZGluZ3MgYSA9XG4gIGxldCBvcHRpb25zID0gbWFrZV9ibG9iX29wdGlvbnMgY29udGVudFR5cGUgZW5kaW5ncyBpblxuICBuZXclanMgYmxvYl9jb25zdHIgKGFycmF5IGEpIG9wdGlvbnNcblxubGV0IGJsb2JfZnJvbV9zdHJpbmcgP2NvbnRlbnRUeXBlID9lbmRpbmdzIHMgPVxuICBibG9iX3JhdyA/Y29udGVudFR5cGUgP2VuZGluZ3MgW3wgc3RyaW5nIHMgfF1cblxubGV0IGJsb2JfZnJvbV9hbnkgP2NvbnRlbnRUeXBlID9lbmRpbmdzIGwgPVxuICBsZXQgbCA9XG4gICAgTGlzdC5tYXBcbiAgICAgIChmdW5jdGlvblxuICAgICAgICB8IGBhcnJheUJ1ZmZlciBhIC0+IFVuc2FmZS5pbmplY3QgYVxuICAgICAgICB8IGBhcnJheUJ1ZmZlclZpZXcgYSAtPiBVbnNhZmUuaW5qZWN0IGFcbiAgICAgICAgfCBgc3RyaW5nIHMgLT4gVW5zYWZlLmluamVjdCAoc3RyaW5nIHMpXG4gICAgICAgIHwgYGpzX3N0cmluZyBzIC0+IFVuc2FmZS5pbmplY3Qgc1xuICAgICAgICB8IGBibG9iIGIgLT4gVW5zYWZlLmluamVjdCBiKVxuICAgICAgbFxuICBpblxuICBibG9iX3JhdyA/Y29udGVudFR5cGUgP2VuZGluZ3MgKEFycmF5Lm9mX2xpc3QgbClcblxuY2xhc3MgdHlwZSBmaWxlID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBibG9iXG5cbiAgICBtZXRob2QgbmFtZSA6IGpzX3N0cmluZyB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBsYXN0TW9kaWZpZWREYXRlIDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuKCogaW4gZmlyZWZveCAzLjAtMy41IGZpbGUubmFtZSBpcyBub3QgYXZhaWxhYmxlLCB3ZSB1c2UgdGhlIG5vbnN0YW5kYXJkIGZpbGVOYW1lIGluc3RlYWQgKilcbmNsYXNzIHR5cGUgZmlsZV9uYW1lX29ubHkgPVxuICBvYmplY3RcbiAgICBtZXRob2QgbmFtZSA6IGpzX3N0cmluZyB0IG9wdGRlZiByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgZmlsZU5hbWUgOiBqc19zdHJpbmcgdCBvcHRkZWYgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxubGV0IGZpbGVuYW1lIGZpbGUgPVxuICBsZXQgZmlsZSA6IGZpbGVfbmFtZV9vbmx5IHQgPSBKcy5VbnNhZmUuY29lcmNlIGZpbGUgaW5cbiAgbWF0Y2ggT3B0ZGVmLnRvX29wdGlvbiBmaWxlIyMubmFtZSB3aXRoXG4gIHwgTm9uZSAtPiAoXG4gICAgICBtYXRjaCBPcHRkZWYudG9fb3B0aW9uIGZpbGUjIy5maWxlTmFtZSB3aXRoXG4gICAgICB8IE5vbmUgLT4gZmFpbHdpdGggXCJjYW4ndCByZXRyaWV2ZSBmaWxlIG5hbWU6IG5vdCBpbXBsZW1lbnRlZFwiXG4gICAgICB8IFNvbWUgbmFtZSAtPiBuYW1lKVxuICB8IFNvbWUgbmFtZSAtPiBuYW1lXG5cbnR5cGUgZmlsZV9hbnkgPSA8ID4gdFxuXG5sZXQgZG9jX2NvbnN0ciA9IFVuc2FmZS5nbG9iYWwjIy5fRG9jdW1lbnRcblxubW9kdWxlIENvZXJjZVRvID0gc3RydWN0XG4gIGV4dGVybmFsIGpzb24gOiBmaWxlX2FueSAtPiAnYSBPcHQudCA9IFwiJWlkZW50aXR5XCJcblxuICBsZXQgZG9jdW1lbnQgKGUgOiBmaWxlX2FueSkgPVxuICAgIGlmIGluc3RhbmNlb2YgZSBkb2NfY29uc3RyXG4gICAgdGhlbiBKcy5zb21lIChVbnNhZmUuY29lcmNlIGUgOiBlbGVtZW50IGRvY3VtZW50IHQpXG4gICAgZWxzZSBKcy5udWxsXG5cbiAgbGV0IGJsb2IgKGUgOiBmaWxlX2FueSkgPVxuICAgIGlmIGluc3RhbmNlb2YgZSBibG9iX2NvbnN0ciB0aGVuIEpzLnNvbWUgKFVuc2FmZS5jb2VyY2UgZSA6ICNibG9iIHQpIGVsc2UgSnMubnVsbFxuXG4gIGxldCBzdHJpbmcgKGUgOiBmaWxlX2FueSkgPVxuICAgIGlmIHR5cGVvZiBlID09IHN0cmluZyBcInN0cmluZ1wiXG4gICAgdGhlbiBKcy5zb21lIChVbnNhZmUuY29lcmNlIGUgOiBqc19zdHJpbmcgdClcbiAgICBlbHNlIEpzLm51bGxcblxuICBsZXQgYXJyYXlCdWZmZXIgKGUgOiBmaWxlX2FueSkgPVxuICAgIGlmIGluc3RhbmNlb2YgZSBUeXBlZF9hcnJheS5hcnJheUJ1ZmZlclxuICAgIHRoZW4gSnMuc29tZSAoVW5zYWZlLmNvZXJjZSBlIDogVHlwZWRfYXJyYXkuYXJyYXlCdWZmZXIgdClcbiAgICBlbHNlIEpzLm51bGxcbmVuZFxuXG5jbGFzcyB0eXBlIGZpbGVMaXN0ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBbZmlsZV0gRG9tLm5vZGVMaXN0XG4gIGVuZFxuXG5jbGFzcyB0eXBlIGZpbGVFcnJvciA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBjb2RlIDogaW50IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbmNsYXNzIHR5cGUgWydhXSBwcm9ncmVzc0V2ZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBbJ2FdIGV2ZW50XG5cbiAgICBtZXRob2QgbGVuZ3RoQ29tcHV0YWJsZSA6IGJvb2wgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgbG9hZGVkIDogaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB0b3RhbCA6IGludCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIHByb2dyZXNzRXZlbnRUYXJnZXQgPVxuICBvYmplY3QgKCdzZWxmKVxuICAgIG1ldGhvZCBvbmxvYWRzdGFydCA6ICgnc2VsZiB0LCAnc2VsZiBwcm9ncmVzc0V2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25wcm9ncmVzcyA6ICgnc2VsZiB0LCAnc2VsZiBwcm9ncmVzc0V2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25sb2FkIDogKCdzZWxmIHQsICdzZWxmIHByb2dyZXNzRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbmFib3J0IDogKCdzZWxmIHQsICdzZWxmIHByb2dyZXNzRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbmVycm9yIDogKCdzZWxmIHQsICdzZWxmIHByb2dyZXNzRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbmxvYWRlbmQgOiAoJ3NlbGYgdCwgJ3NlbGYgcHJvZ3Jlc3NFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuICBlbmRcblxudHlwZSByZWFkeVN0YXRlID1cbiAgfCBFTVBUWVxuICB8IExPQURJTkdcbiAgfCBET05FXG5cbmNsYXNzIHR5cGUgZmlsZVJlYWRlciA9XG4gIG9iamVjdCAoJ3NlbGYpXG4gICAgbWV0aG9kIHJlYWRBc0FycmF5QnVmZmVyIDogI2Jsb2IgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCByZWFkQXNCaW5hcnlTdHJpbmcgOiAjYmxvYiB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHJlYWRBc1RleHQgOiAjYmxvYiB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHJlYWRBc1RleHRfd2l0aEVuY29kaW5nIDogI2Jsb2IgdCAtPiBqc19zdHJpbmcgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCByZWFkQXNEYXRhVVJMIDogI2Jsb2IgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBhYm9ydCA6IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHJlYWR5U3RhdGUgOiByZWFkeVN0YXRlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCByZXN1bHQgOiBmaWxlX2FueSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgZXJyb3IgOiBmaWxlRXJyb3IgdCByZWFkb25seV9wcm9wXG5cbiAgICBpbmhlcml0IHByb2dyZXNzRXZlbnRUYXJnZXRcbiAgZW5kXG5cbm1vZHVsZSBSZWFkZXJFdmVudCA9IHN0cnVjdFxuICB0eXBlIHR5cCA9IGZpbGVSZWFkZXIgcHJvZ3Jlc3NFdmVudCB0IERvbS5FdmVudC50eXBcblxuICBsZXQgbG9hZHN0YXJ0ID0gRXZlbnQubWFrZSBcImxvYWRzdGFydFwiXG5cbiAgbGV0IHByb2dyZXNzID0gRXZlbnQubWFrZSBcInByb2dyZXNzXCJcblxuICBsZXQgYWJvcnQgPSBFdmVudC5tYWtlIFwiYWJvcnRcIlxuXG4gIGxldCBlcnJvciA9IEV2ZW50Lm1ha2UgXCJlcnJvclwiXG5cbiAgbGV0IGxvYWQgPSBFdmVudC5tYWtlIFwibG9hZFwiXG5cbiAgbGV0IGxvYWRlbmQgPSBFdmVudC5tYWtlIFwibG9hZGVuZFwiXG5lbmRcblxubGV0IGZpbGVSZWFkZXIgOiBmaWxlUmVhZGVyIHQgY29uc3RyID0gSnMuVW5zYWZlLmdsb2JhbCMjLl9GaWxlUmVhZGVyXG5cbmxldCBhZGRFdmVudExpc3RlbmVyID0gRG9tLmFkZEV2ZW50TGlzdGVuZXJcbiIsIigqIEpzX29mX29jYW1sIGxpYnJhcnlcbiAqIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbiAqIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4gKiBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICogRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbiAqKVxuXG5vcGVuIEpzXG5vcGVuISBJbXBvcnRcblxuZXh0ZXJuYWwgY2FtbF9qc19vbl9pZSA6IHVuaXQgLT4gYm9vbCB0ID0gXCJjYW1sX2pzX29uX2llXCJcblxubGV0IG9uSUUgPSBKcy50b19ib29sIChjYW1sX2pzX29uX2llICgpKVxuXG5leHRlcm5hbCBodG1sX2VzY2FwZSA6IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0ID0gXCJjYW1sX2pzX2h0bWxfZXNjYXBlXCJcblxuZXh0ZXJuYWwgZGVjb2RlX2h0bWxfZW50aXRpZXMgOiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCA9IFwiY2FtbF9qc19odG1sX2VudGl0aWVzXCJcblxuY2xhc3MgdHlwZSBjc3NTdHlsZURlY2xhcmF0aW9uID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIHNldFByb3BlcnR5IDpcbiAgICAgIGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IG9wdGRlZiAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0UHJvcGVydHlWYWx1ZSA6IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRQcm9wZXJ0eVByaW9yaXR5IDoganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIHJlbW92ZVByb3BlcnR5IDoganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIGFuaW1hdGlvbiA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBhbmltYXRpb25EZWxheSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBhbmltYXRpb25EaXJlY3Rpb24gOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYW5pbWF0aW9uRHVyYXRpb24gOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYW5pbWF0aW9uRmlsbE1vZGUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYW5pbWF0aW9uTmFtZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBhbmltYXRpb25QbGF5U3RhdGUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYW5pbWF0aW9uVGltaW5nRnVuY3Rpb24gOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYmFja2dyb3VuZCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBiYWNrZ3JvdW5kQXR0YWNobWVudCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBiYWNrZ3JvdW5kQ29sb3IgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYmFja2dyb3VuZEltYWdlIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGJhY2tncm91bmRQb3NpdGlvbiA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBiYWNrZ3JvdW5kUmVwZWF0IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGJvcmRlciA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBib3JkZXJCb3R0b20gOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYm9yZGVyQm90dG9tQ29sb3IgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYm9yZGVyQm90dG9tU3R5bGUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYm9yZGVyQm90dG9tV2lkdGggOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYm9yZGVyQ29sbGFwc2UgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYm9yZGVyQ29sb3IgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYm9yZGVyTGVmdCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBib3JkZXJMZWZ0Q29sb3IgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYm9yZGVyTGVmdFN0eWxlIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGJvcmRlckxlZnRXaWR0aCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBib3JkZXJSYWRpdXMgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYm9yZGVyUmlnaHQgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYm9yZGVyUmlnaHRDb2xvciA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBib3JkZXJSaWdodFN0eWxlIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGJvcmRlclJpZ2h0V2lkdGggOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYm9yZGVyU3BhY2luZyA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBib3JkZXJTdHlsZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBib3JkZXJUb3AgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYm9yZGVyVG9wQ29sb3IgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYm9yZGVyVG9wU3R5bGUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYm9yZGVyVG9wV2lkdGggOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYm9yZGVyV2lkdGggOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYm90dG9tIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGNhcHRpb25TaWRlIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGNsZWFyIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGNsaXAgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgY29sb3IgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgY29udGVudCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBjb3VudGVySW5jcmVtZW50IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGNvdW50ZXJSZXNldCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBjc3NGbG9hdCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBjc3NUZXh0IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGN1cnNvciA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBkaXJlY3Rpb24gOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgZGlzcGxheSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBlbXB0eUNlbGxzIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGZpbGwgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgZm9udCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBmb250RmFtaWx5IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGZvbnRTaXplIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGZvbnRTdHlsZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBmb250VmFyaWFudCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBmb250V2VpZ2h0IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGhlaWdodCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBsZWZ0IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGxldHRlclNwYWNpbmcgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgbGluZUhlaWdodCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBsaXN0U3R5bGUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgbGlzdFN0eWxlSW1hZ2UgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgbGlzdFN0eWxlUG9zaXRpb24gOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgbGlzdFN0eWxlVHlwZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBtYXJnaW4gOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgbWFyZ2luQm90dG9tIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIG1hcmdpbkxlZnQgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgbWFyZ2luUmlnaHQgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgbWFyZ2luVG9wIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIG1heEhlaWdodCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBtYXhXaWR0aCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBtaW5IZWlnaHQgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgbWluV2lkdGggOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2Qgb3BhY2l0eSA6IGpzX3N0cmluZyB0IG9wdGRlZiBwcm9wXG5cbiAgICBtZXRob2Qgb3V0bGluZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBvdXRsaW5lQ29sb3IgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2Qgb3V0bGluZU9mZnNldCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBvdXRsaW5lU3R5bGUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2Qgb3V0bGluZVdpZHRoIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIG92ZXJmbG93IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIG92ZXJmbG93WCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBvdmVyZmxvd1kgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgcGFkZGluZyA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBwYWRkaW5nQm90dG9tIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHBhZGRpbmdMZWZ0IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHBhZGRpbmdSaWdodCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBwYWRkaW5nVG9wIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHBhZ2VCcmVha0FmdGVyIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHBhZ2VCcmVha0JlZm9yZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBwb2ludGVyRXZlbnRzIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHBvc2l0aW9uIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHJpZ2h0IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHN0cm9rZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBzdHJva2VXaWR0aCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCB0YWJsZUxheW91dCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCB0ZXh0QWxpZ24gOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgdGV4dEFuY2hvciA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCB0ZXh0RGVjb3JhdGlvbiA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCB0ZXh0SW5kZW50IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHRleHRUcmFuc2Zvcm0gOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgdG9wIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHRyYW5zZm9ybSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCB2ZXJ0aWNhbEFsaWduIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHZpc2liaWxpdHkgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2Qgd2hpdGVTcGFjZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCB3aWR0aCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCB3b3JkU3BhY2luZyA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCB6SW5kZXggOiBqc19zdHJpbmcgdCBwcm9wXG4gIGVuZFxuXG50eXBlICgnYSwgJ2IpIGV2ZW50X2xpc3RlbmVyID0gKCdhLCAnYikgRG9tLmV2ZW50X2xpc3RlbmVyXG5cbnR5cGUgbW91c2VfYnV0dG9uID1cbiAgfCBOb19idXR0b25cbiAgfCBMZWZ0X2J1dHRvblxuICB8IE1pZGRsZV9idXR0b25cbiAgfCBSaWdodF9idXR0b25cblxudHlwZSBkZWx0YV9tb2RlID1cbiAgfCBEZWx0YV9waXhlbFxuICB8IERlbHRhX2xpbmVcbiAgfCBEZWx0YV9wYWdlXG5cbmNsYXNzIHR5cGUgZXZlbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IFtlbGVtZW50XSBEb20uZXZlbnRcbiAgZW5kXG5cbmFuZCBbJ2FdIGN1c3RvbUV2ZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBbZWxlbWVudCwgJ2FdIERvbS5jdXN0b21FdmVudFxuICBlbmRcblxuYW5kIGZvY3VzRXZlbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGV2ZW50XG5cbiAgICBtZXRob2QgcmVsYXRlZFRhcmdldCA6IGVsZW1lbnQgdCBvcHQgb3B0ZGVmIHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbmFuZCBtb3VzZUV2ZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBldmVudFxuXG4gICAgbWV0aG9kIHJlbGF0ZWRUYXJnZXQgOiBlbGVtZW50IHQgb3B0IG9wdGRlZiByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgY2xpZW50WCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgY2xpZW50WSA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgc2NyZWVuWCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgc2NyZWVuWSA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb2Zmc2V0WCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb2Zmc2V0WSA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgY3RybEtleSA6IGJvb2wgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgc2hpZnRLZXkgOiBib29sIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGFsdEtleSA6IGJvb2wgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgbWV0YUtleSA6IGJvb2wgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgYnV0dG9uIDogaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB3aGljaCA6IG1vdXNlX2J1dHRvbiBvcHRkZWYgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGZyb21FbGVtZW50IDogZWxlbWVudCB0IG9wdCBvcHRkZWYgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHRvRWxlbWVudCA6IGVsZW1lbnQgdCBvcHQgb3B0ZGVmIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBwYWdlWCA6IGludCBvcHRkZWYgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHBhZ2VZIDogaW50IG9wdGRlZiByZWFkb25seV9wcm9wXG4gIGVuZFxuXG5hbmQga2V5Ym9hcmRFdmVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZXZlbnRcblxuICAgIG1ldGhvZCBhbHRLZXkgOiBib29sIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHNoaWZ0S2V5IDogYm9vbCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBjdHJsS2V5IDogYm9vbCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBtZXRhS2V5IDogYm9vbCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBsb2NhdGlvbiA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qga2V5IDoganNfc3RyaW5nIHQgb3B0ZGVmIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBjb2RlIDoganNfc3RyaW5nIHQgb3B0ZGVmIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB3aGljaCA6IGludCBvcHRkZWYgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGNoYXJDb2RlIDogaW50IG9wdGRlZiByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qga2V5Q29kZSA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgZ2V0TW9kaWZpZXJTdGF0ZSA6IGpzX3N0cmluZyB0IC0+IGJvb2wgdCBtZXRoXG5cbiAgICBtZXRob2Qga2V5SWRlbnRpZmllciA6IGpzX3N0cmluZyB0IG9wdGRlZiByZWFkb25seV9wcm9wXG4gIGVuZFxuXG5hbmQgbW91c2V3aGVlbEV2ZW50ID1cbiAgb2JqZWN0XG4gICAgKCogQWxsIG1vZGVybiBicm93c2VycyAqKVxuICAgIGluaGVyaXQgbW91c2VFdmVudFxuXG4gICAgbWV0aG9kIHdoZWVsRGVsdGEgOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHdoZWVsRGVsdGFYIDogaW50IG9wdGRlZiByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgd2hlZWxEZWx0YVkgOiBpbnQgb3B0ZGVmIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBkZWx0YVggOiBmbG9hdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgZGVsdGFZIDogZmxvYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGRlbHRhWiA6IGZsb2F0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBkZWx0YU1vZGUgOiBkZWx0YV9tb2RlIHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbmFuZCBtb3VzZVNjcm9sbEV2ZW50ID1cbiAgb2JqZWN0XG4gICAgKCogRmlyZWZveCAqKVxuICAgIGluaGVyaXQgbW91c2VFdmVudFxuXG4gICAgbWV0aG9kIGRldGFpbCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgYXhpcyA6IGludCBvcHRkZWYgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9IT1JJWk9OVEFMX0FYSVMgOiBpbnQgb3B0ZGVmIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVkVSVElDQUxfQVhJUyA6IGludCBvcHRkZWYgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuYW5kIHRvdWNoRXZlbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGV2ZW50XG5cbiAgICBtZXRob2QgdG91Y2hlcyA6IHRvdWNoTGlzdCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB0YXJnZXRUb3VjaGVzIDogdG91Y2hMaXN0IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGNoYW5nZWRUb3VjaGVzIDogdG91Y2hMaXN0IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGN0cmxLZXkgOiBib29sIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHNoaWZ0S2V5IDogYm9vbCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBhbHRLZXkgOiBib29sIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG1ldGFLZXkgOiBib29sIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHJlbGF0ZWRUYXJnZXQgOiBlbGVtZW50IHQgb3B0IG9wdGRlZiByZWFkb25seV9wcm9wXG4gIGVuZFxuXG5hbmQgdG91Y2hMaXN0ID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGxlbmd0aCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgaXRlbSA6IGludCAtPiB0b3VjaCB0IG9wdGRlZiBtZXRoXG4gIGVuZFxuXG5hbmQgdG91Y2ggPVxuICBvYmplY3RcbiAgICBtZXRob2QgaWRlbnRpZmllciA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgdGFyZ2V0IDogZWxlbWVudCB0IG9wdGRlZiByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgc2NyZWVuWCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgc2NyZWVuWSA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgY2xpZW50WCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgY2xpZW50WSA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgcGFnZVggOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHBhZ2VZIDogaW50IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbmFuZCBzdWJtaXRFdmVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZXZlbnRcblxuICAgIG1ldGhvZCBzdWJtaXR0ZXIgOiBlbGVtZW50IHQgb3B0ZGVmIHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbmFuZCBkcmFnRXZlbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IG1vdXNlRXZlbnRcblxuICAgIG1ldGhvZCBkYXRhVHJhbnNmZXIgOiBkYXRhVHJhbnNmZXIgdCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG5hbmQgY2xpcGJvYXJkRXZlbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGV2ZW50XG5cbiAgICBtZXRob2QgY2xpcGJvYXJkRGF0YSA6IGRhdGFUcmFuc2ZlciB0IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbmFuZCBkYXRhVHJhbnNmZXIgPVxuICBvYmplY3RcbiAgICBtZXRob2QgZHJvcEVmZmVjdCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBlZmZlY3RBbGxvd2VkIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGZpbGVzIDogRmlsZS5maWxlTGlzdCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB0eXBlcyA6IGpzX3N0cmluZyB0IGpzX2FycmF5IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGFkZEVsZW1lbnQgOiBlbGVtZW50IHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY2xlYXJEYXRhIDoganNfc3RyaW5nIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY2xlYXJEYXRhX2FsbCA6IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGdldERhdGEgOiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0RGF0YSA6IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldERyYWdJbWFnZSA6IGVsZW1lbnQgdCAtPiBpbnQgLT4gaW50IC0+IHVuaXQgbWV0aFxuICBlbmRcblxuYW5kIGV2ZW50VGFyZ2V0ID1cbiAgb2JqZWN0ICgnc2VsZilcbiAgICBtZXRob2Qgb25jbGljayA6ICgnc2VsZiB0LCBtb3VzZUV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25kYmxjbGljayA6ICgnc2VsZiB0LCBtb3VzZUV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25tb3VzZWRvd24gOiAoJ3NlbGYgdCwgbW91c2VFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9ubW91c2V1cCA6ICgnc2VsZiB0LCBtb3VzZUV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25tb3VzZW92ZXIgOiAoJ3NlbGYgdCwgbW91c2VFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9ubW91c2Vtb3ZlIDogKCdzZWxmIHQsIG1vdXNlRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbm1vdXNlb3V0IDogKCdzZWxmIHQsIG1vdXNlRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbmtleXByZXNzIDogKCdzZWxmIHQsIGtleWJvYXJkRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbmtleWRvd24gOiAoJ3NlbGYgdCwga2V5Ym9hcmRFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9ua2V5dXAgOiAoJ3NlbGYgdCwga2V5Ym9hcmRFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9uc2Nyb2xsIDogKCdzZWxmIHQsIGV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb253aGVlbCA6ICgnc2VsZiB0LCBtb3VzZXdoZWVsRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbmRyYWdzdGFydCA6ICgnc2VsZiB0LCBkcmFnRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbmRyYWdlbmQgOiAoJ3NlbGYgdCwgZHJhZ0V2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25kcmFnZW50ZXIgOiAoJ3NlbGYgdCwgZHJhZ0V2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25kcmFnb3ZlciA6ICgnc2VsZiB0LCBkcmFnRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbmRyYWdsZWF2ZSA6ICgnc2VsZiB0LCBkcmFnRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbmRyYWcgOiAoJ3NlbGYgdCwgZHJhZ0V2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25kcm9wIDogKCdzZWxmIHQsIGRyYWdFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9uYW5pbWF0aW9uc3RhcnQgOiAoJ3NlbGYgdCwgYW5pbWF0aW9uRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbmFuaW1hdGlvbmVuZCA6ICgnc2VsZiB0LCBhbmltYXRpb25FdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9uYW5pbWF0aW9uaXRlcmF0aW9uIDpcbiAgICAgICgnc2VsZiB0LCBhbmltYXRpb25FdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9uYW5pbWF0aW9uY2FuY2VsIDogKCdzZWxmIHQsIGFuaW1hdGlvbkV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb250cmFuc2l0aW9ucnVuIDogKCdzZWxmIHQsIHRyYW5zaXRpb25FdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9udHJhbnNpdGlvbnN0YXJ0IDogKCdzZWxmIHQsIHRyYW5zaXRpb25FdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9udHJhbnNpdGlvbmVuZCA6ICgnc2VsZiB0LCB0cmFuc2l0aW9uRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbnRyYW5zaXRpb25jYW5jZWwgOiAoJ3NlbGYgdCwgdHJhbnNpdGlvbkV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25nb3Rwb2ludGVyY2FwdHVyZSA6ICgnc2VsZiB0LCBwb2ludGVyRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbmxvc3Rwb2ludGVyY2FwdHVyZSA6ICgnc2VsZiB0LCBwb2ludGVyRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbnBvaW50ZXJlbnRlciA6ICgnc2VsZiB0LCBwb2ludGVyRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbnBvaW50ZXJjYW5jZWwgOiAoJ3NlbGYgdCwgcG9pbnRlckV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25wb2ludGVyZG93biA6ICgnc2VsZiB0LCBwb2ludGVyRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbnBvaW50ZXJsZWF2ZSA6ICgnc2VsZiB0LCBwb2ludGVyRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbnBvaW50ZXJtb3ZlIDogKCdzZWxmIHQsIHBvaW50ZXJFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9ucG9pbnRlcm91dCA6ICgnc2VsZiB0LCBwb2ludGVyRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbnBvaW50ZXJvdmVyIDogKCdzZWxmIHQsIHBvaW50ZXJFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9ucG9pbnRlcnVwIDogKCdzZWxmIHQsIHBvaW50ZXJFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGRpc3BhdGNoRXZlbnQgOiBldmVudCB0IC0+IGJvb2wgdCBtZXRoXG4gIGVuZFxuXG5hbmQgcG9wU3RhdGVFdmVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZXZlbnRcblxuICAgIG1ldGhvZCBzdGF0ZSA6IEpzLlVuc2FmZS5hbnkgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuYW5kIHBvaW50ZXJFdmVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgbW91c2VFdmVudFxuXG4gICAgbWV0aG9kIHBvaW50ZXJJZCA6IGludCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgd2lkdGggOiBmbG9hdCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgaGVpZ2h0IDogZmxvYXQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHByZXNzdXJlIDogZmxvYXQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHRhbmdlbnRpYWxQcmVzc3VyZSA6IGZsb2F0IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB0aWx0WCA6IGludCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgdGlsdFkgOiBpbnQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHR3aXN0IDogaW50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBwb2ludGVyVHlwZSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBpc1ByaW1hcnkgOiBib29sIEpzLnQgSnMucmVhZG9ubHlfcHJvcFxuICBlbmRcblxuYW5kIHN0b3JhZ2VFdmVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZXZlbnRcblxuICAgIG1ldGhvZCBrZXkgOiBqc19zdHJpbmcgdCBvcHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9sZFZhbHVlIDoganNfc3RyaW5nIHQgb3B0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBuZXdWYWx1ZSA6IGpzX3N0cmluZyB0IG9wdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgdXJsIDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHN0b3JhZ2VBcmVhIDogc3RvcmFnZSB0IG9wdCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG5hbmQgc3RvcmFnZSA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBsZW5ndGggOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGtleSA6IGludCAtPiBqc19zdHJpbmcgdCBvcHQgbWV0aFxuXG4gICAgbWV0aG9kIGdldEl0ZW0gOiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCBvcHQgbWV0aFxuXG4gICAgbWV0aG9kIHNldEl0ZW0gOiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCByZW1vdmVJdGVtIDoganNfc3RyaW5nIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY2xlYXIgOiB1bml0IG1ldGhcbiAgZW5kXG5cbmFuZCBoYXNoQ2hhbmdlRXZlbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGV2ZW50XG5cbiAgICBtZXRob2Qgb2xkVVJMIDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG5ld1VSTCA6IGpzX3N0cmluZyB0IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbmFuZCBhbmltYXRpb25FdmVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZXZlbnRcblxuICAgIG1ldGhvZCBhbmltYXRpb25OYW1lIDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGVsYXBzZWRUaW1lIDogZmxvYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHBzZXVkb0VsZW1lbnQgOiBqc19zdHJpbmcgdCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG5hbmQgdHJhbnNpdGlvbkV2ZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBldmVudFxuXG4gICAgbWV0aG9kIHByb3BlcnR5TmFtZSA6IGpzX3N0cmluZyB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBlbGFwc2VkVGltZSA6IGZsb2F0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBwc2V1ZG9FbGVtZW50IDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuYW5kIG1lZGlhRXZlbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGV2ZW50XG4gIGVuZFxuXG5hbmQgbWVzc2FnZUV2ZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBldmVudFxuXG4gICAgbWV0aG9kIGRhdGEgOiBVbnNhZmUuYW55IG9wdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgc291cmNlIDogVW5zYWZlLmFueSBvcHQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuYW5kIG5vZGVTZWxlY3RvciA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBxdWVyeVNlbGVjdG9yIDoganNfc3RyaW5nIHQgLT4gZWxlbWVudCB0IG9wdCBtZXRoXG5cbiAgICBtZXRob2QgcXVlcnlTZWxlY3RvckFsbCA6IGpzX3N0cmluZyB0IC0+IGVsZW1lbnQgRG9tLm5vZGVMaXN0IHQgbWV0aFxuICBlbmRcblxuYW5kIHRva2VuTGlzdCA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBsZW5ndGggOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGl0ZW0gOiBpbnQgLT4ganNfc3RyaW5nIHQgb3B0ZGVmIG1ldGhcblxuICAgIG1ldGhvZCBjb250YWlucyA6IGpzX3N0cmluZyB0IC0+IGJvb2wgdCBtZXRoXG5cbiAgICBtZXRob2QgYWRkIDoganNfc3RyaW5nIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgcmVtb3ZlIDoganNfc3RyaW5nIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdG9nZ2xlIDoganNfc3RyaW5nIHQgLT4gYm9vbCB0IG1ldGhcblxuICAgIG1ldGhvZCBzdHJpbmdpZmllciA6IGpzX3N0cmluZyB0IHByb3BcbiAgZW5kXG5cbmFuZCBlbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBEb20uZWxlbWVudFxuXG4gICAgaW5oZXJpdCBub2RlU2VsZWN0b3JcblxuICAgIG1ldGhvZCBpZCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCB0aXRsZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBsYW5nIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGRpciA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBjbGFzc05hbWUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgY2xhc3NMaXN0IDogdG9rZW5MaXN0IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGNsb3Nlc3QgOiBqc19zdHJpbmcgdCAtPiBlbGVtZW50IHQgb3B0IG1ldGhcblxuICAgIG1ldGhvZCBzdHlsZSA6IGNzc1N0eWxlRGVjbGFyYXRpb24gdCBwcm9wXG5cbiAgICBtZXRob2QgaW5uZXJIVE1MIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIG91dGVySFRNTCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCB0ZXh0Q29udGVudCA6IGpzX3N0cmluZyB0IG9wdCBwcm9wXG5cbiAgICBtZXRob2QgaW5uZXJUZXh0IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGNsaWVudExlZnQgOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGNsaWVudFRvcCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgY2xpZW50V2lkdGggOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGNsaWVudEhlaWdodCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb2Zmc2V0TGVmdCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb2Zmc2V0VG9wIDogaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvZmZzZXRQYXJlbnQgOiBlbGVtZW50IHQgb3B0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvZmZzZXRXaWR0aCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb2Zmc2V0SGVpZ2h0IDogaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBzY3JvbGxMZWZ0IDogaW50IHByb3BcblxuICAgIG1ldGhvZCBzY3JvbGxUb3AgOiBpbnQgcHJvcFxuXG4gICAgbWV0aG9kIHNjcm9sbFdpZHRoIDogaW50IHByb3BcblxuICAgIG1ldGhvZCBzY3JvbGxIZWlnaHQgOiBpbnQgcHJvcFxuXG4gICAgbWV0aG9kIGdldENsaWVudFJlY3RzIDogY2xpZW50UmVjdExpc3QgdCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IDogY2xpZW50UmVjdCB0IG1ldGhcblxuICAgIG1ldGhvZCBzY3JvbGxJbnRvVmlldyA6IGJvb2wgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBjbGljayA6IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGZvY3VzIDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgYmx1ciA6IHVuaXQgbWV0aFxuXG4gICAgaW5oZXJpdCBldmVudFRhcmdldFxuICBlbmRcblxuYW5kIGNsaWVudFJlY3QgPVxuICBvYmplY3RcbiAgICBtZXRob2QgdG9wIDogZmxvYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHJpZ2h0IDogZmxvYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGJvdHRvbSA6IGZsb2F0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBsZWZ0IDogZmxvYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHdpZHRoIDogZmxvYXQgb3B0ZGVmIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBoZWlnaHQgOiBmbG9hdCBvcHRkZWYgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuYW5kIGNsaWVudFJlY3RMaXN0ID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGxlbmd0aCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgaXRlbSA6IGludCAtPiBjbGllbnRSZWN0IHQgb3B0IG1ldGhcbiAgZW5kXG5cbmxldCBub19oYW5kbGVyIDogKCdhLCAnYikgZXZlbnRfbGlzdGVuZXIgPSBEb20ubm9faGFuZGxlclxuXG5sZXQgaGFuZGxlciA9IERvbS5oYW5kbGVyXG5cbmxldCBmdWxsX2hhbmRsZXIgPSBEb20uZnVsbF9oYW5kbGVyXG5cbmxldCBpbnZva2VfaGFuZGxlciA9IERvbS5pbnZva2VfaGFuZGxlclxuXG5tb2R1bGUgRXZlbnQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0eXAgPSAnYSBEb20uRXZlbnQudHlwXG5cbiAgbGV0IGNsaWNrID0gRG9tLkV2ZW50Lm1ha2UgXCJjbGlja1wiXG5cbiAgbGV0IGNvcHkgPSBEb20uRXZlbnQubWFrZSBcImNvcHlcIlxuXG4gIGxldCBjdXQgPSBEb20uRXZlbnQubWFrZSBcImN1dFwiXG5cbiAgbGV0IHBhc3RlID0gRG9tLkV2ZW50Lm1ha2UgXCJwYXN0ZVwiXG5cbiAgbGV0IGRibGNsaWNrID0gRG9tLkV2ZW50Lm1ha2UgXCJkYmxjbGlja1wiXG5cbiAgbGV0IG1vdXNlZG93biA9IERvbS5FdmVudC5tYWtlIFwibW91c2Vkb3duXCJcblxuICBsZXQgbW91c2V1cCA9IERvbS5FdmVudC5tYWtlIFwibW91c2V1cFwiXG5cbiAgbGV0IG1vdXNlb3ZlciA9IERvbS5FdmVudC5tYWtlIFwibW91c2VvdmVyXCJcblxuICBsZXQgbW91c2Vtb3ZlID0gRG9tLkV2ZW50Lm1ha2UgXCJtb3VzZW1vdmVcIlxuXG4gIGxldCBtb3VzZW91dCA9IERvbS5FdmVudC5tYWtlIFwibW91c2VvdXRcIlxuXG4gIGxldCBrZXlwcmVzcyA9IERvbS5FdmVudC5tYWtlIFwia2V5cHJlc3NcIlxuXG4gIGxldCBrZXlkb3duID0gRG9tLkV2ZW50Lm1ha2UgXCJrZXlkb3duXCJcblxuICBsZXQga2V5dXAgPSBEb20uRXZlbnQubWFrZSBcImtleXVwXCJcblxuICBsZXQgbW91c2V3aGVlbCA9IERvbS5FdmVudC5tYWtlIFwibW91c2V3aGVlbFwiXG5cbiAgbGV0IHdoZWVsID0gRG9tLkV2ZW50Lm1ha2UgXCJ3aGVlbFwiXG5cbiAgbGV0IF9ET01Nb3VzZVNjcm9sbCA9IERvbS5FdmVudC5tYWtlIFwiRE9NTW91c2VTY3JvbGxcIlxuXG4gIGxldCB0b3VjaHN0YXJ0ID0gRG9tLkV2ZW50Lm1ha2UgXCJ0b3VjaHN0YXJ0XCJcblxuICBsZXQgdG91Y2htb3ZlID0gRG9tLkV2ZW50Lm1ha2UgXCJ0b3VjaG1vdmVcIlxuXG4gIGxldCB0b3VjaGVuZCA9IERvbS5FdmVudC5tYWtlIFwidG91Y2hlbmRcIlxuXG4gIGxldCB0b3VjaGNhbmNlbCA9IERvbS5FdmVudC5tYWtlIFwidG91Y2hjYW5jZWxcIlxuXG4gIGxldCBkcmFnc3RhcnQgPSBEb20uRXZlbnQubWFrZSBcImRyYWdzdGFydFwiXG5cbiAgbGV0IGRyYWdlbmQgPSBEb20uRXZlbnQubWFrZSBcImRyYWdlbmRcIlxuXG4gIGxldCBkcmFnZW50ZXIgPSBEb20uRXZlbnQubWFrZSBcImRyYWdlbnRlclwiXG5cbiAgbGV0IGRyYWdvdmVyID0gRG9tLkV2ZW50Lm1ha2UgXCJkcmFnb3ZlclwiXG5cbiAgbGV0IGRyYWdsZWF2ZSA9IERvbS5FdmVudC5tYWtlIFwiZHJhZ2xlYXZlXCJcblxuICBsZXQgZHJhZyA9IERvbS5FdmVudC5tYWtlIFwiZHJhZ1wiXG5cbiAgbGV0IGRyb3AgPSBEb20uRXZlbnQubWFrZSBcImRyb3BcIlxuXG4gIGxldCBoYXNoY2hhbmdlID0gRG9tLkV2ZW50Lm1ha2UgXCJoYXNoY2hhbmdlXCJcblxuICBsZXQgY2hhbmdlID0gRG9tLkV2ZW50Lm1ha2UgXCJjaGFuZ2VcIlxuXG4gIGxldCBpbnB1dCA9IERvbS5FdmVudC5tYWtlIFwiaW5wdXRcIlxuXG4gIGxldCB0aW1ldXBkYXRlID0gRG9tLkV2ZW50Lm1ha2UgXCJ0aW1ldXBkYXRlXCJcblxuICBsZXQgc3VibWl0ID0gRG9tLkV2ZW50Lm1ha2UgXCJzdWJtaXRcIlxuXG4gIGxldCBzY3JvbGwgPSBEb20uRXZlbnQubWFrZSBcInNjcm9sbFwiXG5cbiAgbGV0IGZvY3VzID0gRG9tLkV2ZW50Lm1ha2UgXCJmb2N1c1wiXG5cbiAgbGV0IGJsdXIgPSBEb20uRXZlbnQubWFrZSBcImJsdXJcIlxuXG4gIGxldCBsb2FkID0gRG9tLkV2ZW50Lm1ha2UgXCJsb2FkXCJcblxuICBsZXQgdW5sb2FkID0gRG9tLkV2ZW50Lm1ha2UgXCJ1bmxvYWRcIlxuXG4gIGxldCBiZWZvcmV1bmxvYWQgPSBEb20uRXZlbnQubWFrZSBcImJlZm9yZXVubG9hZFwiXG5cbiAgbGV0IHJlc2l6ZSA9IERvbS5FdmVudC5tYWtlIFwicmVzaXplXCJcblxuICBsZXQgb3JpZW50YXRpb25jaGFuZ2UgPSBEb20uRXZlbnQubWFrZSBcIm9yaWVudGF0aW9uY2hhbmdlXCJcblxuICBsZXQgcG9wc3RhdGUgPSBEb20uRXZlbnQubWFrZSBcInBvcHN0YXRlXCJcblxuICBsZXQgZXJyb3IgPSBEb20uRXZlbnQubWFrZSBcImVycm9yXCJcblxuICBsZXQgYWJvcnQgPSBEb20uRXZlbnQubWFrZSBcImFib3J0XCJcblxuICBsZXQgc2VsZWN0ID0gRG9tLkV2ZW50Lm1ha2UgXCJzZWxlY3RcIlxuXG4gIGxldCBvbmxpbmUgPSBEb20uRXZlbnQubWFrZSBcIm9ubGluZVwiXG5cbiAgbGV0IG9mZmxpbmUgPSBEb20uRXZlbnQubWFrZSBcIm9mZmxpbmVcIlxuXG4gIGxldCBjaGVja2luZyA9IERvbS5FdmVudC5tYWtlIFwiY2hlY2tpbmdcIlxuXG4gIGxldCBub3VwZGF0ZSA9IERvbS5FdmVudC5tYWtlIFwibm91cGRhdGVcIlxuXG4gIGxldCBkb3dubG9hZGluZyA9IERvbS5FdmVudC5tYWtlIFwiZG93bmxvYWRpbmdcIlxuXG4gIGxldCBwcm9ncmVzcyA9IERvbS5FdmVudC5tYWtlIFwicHJvZ3Jlc3NcIlxuXG4gIGxldCB1cGRhdGVyZWFkeSA9IERvbS5FdmVudC5tYWtlIFwidXBkYXRlcmVhZHlcIlxuXG4gIGxldCBjYWNoZWQgPSBEb20uRXZlbnQubWFrZSBcImNhY2hlZFwiXG5cbiAgbGV0IG9ic29sZXRlID0gRG9tLkV2ZW50Lm1ha2UgXCJvYnNvbGV0ZVwiXG5cbiAgbGV0IGRvbUNvbnRlbnRMb2FkZWQgPSBEb20uRXZlbnQubWFrZSBcIkRPTUNvbnRlbnRMb2FkZWRcIlxuXG4gIGxldCBhbmltYXRpb25zdGFydCA9IERvbS5FdmVudC5tYWtlIFwiYW5pbWF0aW9uc3RhcnRcIlxuXG4gIGxldCBhbmltYXRpb25lbmQgPSBEb20uRXZlbnQubWFrZSBcImFuaW1hdGlvbmVuZFwiXG5cbiAgbGV0IGFuaW1hdGlvbml0ZXJhdGlvbiA9IERvbS5FdmVudC5tYWtlIFwiYW5pbWF0aW9uaXRlcmF0aW9uXCJcblxuICBsZXQgYW5pbWF0aW9uY2FuY2VsID0gRG9tLkV2ZW50Lm1ha2UgXCJhbmltYXRpb25jYW5jZWxcIlxuXG4gIGxldCB0cmFuc2l0aW9ucnVuID0gRG9tLkV2ZW50Lm1ha2UgXCJ0cmFuc2l0aW9ucnVuXCJcblxuICBsZXQgdHJhbnNpdGlvbnN0YXJ0ID0gRG9tLkV2ZW50Lm1ha2UgXCJ0cmFuc2l0aW9uc3RhcnRcIlxuXG4gIGxldCB0cmFuc2l0aW9uZW5kID0gRG9tLkV2ZW50Lm1ha2UgXCJ0cmFuc2l0aW9uZW5kXCJcblxuICBsZXQgdHJhbnNpdGlvbmNhbmNlbCA9IERvbS5FdmVudC5tYWtlIFwidHJhbnNpdGlvbmNhbmNlbFwiXG5cbiAgbGV0IGNhbnBsYXkgPSBEb20uRXZlbnQubWFrZSBcImNhbnBsYXlcIlxuXG4gIGxldCBjYW5wbGF5dGhyb3VnaCA9IERvbS5FdmVudC5tYWtlIFwiY2FucGxheXRocm91Z2hcIlxuXG4gIGxldCBkdXJhdGlvbmNoYW5nZSA9IERvbS5FdmVudC5tYWtlIFwiZHVyYXRpb25jaGFuZ2VcIlxuXG4gIGxldCBlbXB0aWVkID0gRG9tLkV2ZW50Lm1ha2UgXCJlbXB0aWVkXCJcblxuICBsZXQgZW5kZWQgPSBEb20uRXZlbnQubWFrZSBcImVuZGVkXCJcblxuICBsZXQgZ290cG9pbnRlcmNhcHR1cmUgPSBEb20uRXZlbnQubWFrZSBcImdvdHBvaW50ZXJjYXB0dXJlXCJcblxuICBsZXQgbG9hZGVkZGF0YSA9IERvbS5FdmVudC5tYWtlIFwibG9hZGVkZGF0YVwiXG5cbiAgbGV0IGxvYWRlZG1ldGFkYXRhID0gRG9tLkV2ZW50Lm1ha2UgXCJsb2FkZWRtZXRhZGF0YVwiXG5cbiAgbGV0IGxvYWRzdGFydCA9IERvbS5FdmVudC5tYWtlIFwibG9hZHN0YXJ0XCJcblxuICBsZXQgbG9zdHBvaW50ZXJjYXB0dXJlID0gRG9tLkV2ZW50Lm1ha2UgXCJsb3N0cG9pbnRlcmNhcHR1cmVcIlxuXG4gIGxldCBtZXNzYWdlID0gRG9tLkV2ZW50Lm1ha2UgXCJtZXNzYWdlXCJcblxuICBsZXQgcGF1c2UgPSBEb20uRXZlbnQubWFrZSBcInBhdXNlXCJcblxuICBsZXQgcGxheSA9IERvbS5FdmVudC5tYWtlIFwicGxheVwiXG5cbiAgbGV0IHBsYXlpbmcgPSBEb20uRXZlbnQubWFrZSBcInBsYXlpbmdcIlxuXG4gIGxldCBwb2ludGVyZW50ZXIgPSBEb20uRXZlbnQubWFrZSBcInBvaW50ZXJlbnRlclwiXG5cbiAgbGV0IHBvaW50ZXJjYW5jZWwgPSBEb20uRXZlbnQubWFrZSBcInBvaW50ZXJjYW5jZWxcIlxuXG4gIGxldCBwb2ludGVyZG93biA9IERvbS5FdmVudC5tYWtlIFwicG9pbnRlcmRvd25cIlxuXG4gIGxldCBwb2ludGVybGVhdmUgPSBEb20uRXZlbnQubWFrZSBcInBvaW50ZXJsZWF2ZVwiXG5cbiAgbGV0IHBvaW50ZXJtb3ZlID0gRG9tLkV2ZW50Lm1ha2UgXCJwb2ludGVybW92ZVwiXG5cbiAgbGV0IHBvaW50ZXJvdXQgPSBEb20uRXZlbnQubWFrZSBcInBvaW50ZXJvdXRcIlxuXG4gIGxldCBwb2ludGVyb3ZlciA9IERvbS5FdmVudC5tYWtlIFwicG9pbnRlcm92ZXJcIlxuXG4gIGxldCBwb2ludGVydXAgPSBEb20uRXZlbnQubWFrZSBcInBvaW50ZXJ1cFwiXG5cbiAgbGV0IHJhdGVjaGFuZ2UgPSBEb20uRXZlbnQubWFrZSBcInJhdGVjaGFuZ2VcIlxuXG4gIGxldCBzZWVrZWQgPSBEb20uRXZlbnQubWFrZSBcInNlZWtlZFwiXG5cbiAgbGV0IHNlZWtpbmcgPSBEb20uRXZlbnQubWFrZSBcInNlZWtpbmdcIlxuXG4gIGxldCBzdGFsbGVkID0gRG9tLkV2ZW50Lm1ha2UgXCJzdGFsbGVkXCJcblxuICBsZXQgc3VzcGVuZCA9IERvbS5FdmVudC5tYWtlIFwic3VzcGVuZFwiXG5cbiAgbGV0IHZvbHVtZWNoYW5nZSA9IERvbS5FdmVudC5tYWtlIFwidm9sdW1lY2hhbmdlXCJcblxuICBsZXQgd2FpdGluZyA9IERvbS5FdmVudC5tYWtlIFwid2FpdGluZ1wiXG5cbiAgbGV0IG1ha2UgPSBEb20uRXZlbnQubWFrZVxuZW5kXG5cbnR5cGUgZXZlbnRfbGlzdGVuZXJfaWQgPSBEb20uZXZlbnRfbGlzdGVuZXJfaWRcblxubGV0IGFkZEV2ZW50TGlzdGVuZXIgPSBEb20uYWRkRXZlbnRMaXN0ZW5lclxuXG5sZXQgYWRkRXZlbnRMaXN0ZW5lcldpdGhPcHRpb25zID0gRG9tLmFkZEV2ZW50TGlzdGVuZXJXaXRoT3B0aW9uc1xuXG5sZXQgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IERvbS5yZW1vdmVFdmVudExpc3RlbmVyXG5cbmxldCBjcmVhdGVDdXN0b21FdmVudCA9IERvbS5jcmVhdGVDdXN0b21FdmVudFxuXG5jbGFzcyB0eXBlIFsnbm9kZV0gY29sbGVjdGlvbiA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBsZW5ndGggOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGl0ZW0gOiBpbnQgLT4gJ25vZGUgdCBvcHQgbWV0aFxuXG4gICAgbWV0aG9kIG5hbWVkSXRlbSA6IGpzX3N0cmluZyB0IC0+ICdub2RlIHQgb3B0IG1ldGhcbiAgZW5kXG5cbmNsYXNzIHR5cGUgaHRtbEVsZW1lbnQgPSBlbGVtZW50XG5cbmNsYXNzIHR5cGUgaGVhZEVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIG1ldGhvZCBwcm9maWxlIDoganNfc3RyaW5nIHQgcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSBsaW5rRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgbWV0aG9kIGRpc2FibGVkIDogYm9vbCB0IHByb3BcblxuICAgIG1ldGhvZCBjaGFyc2V0IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGNyb3Nzb3JpZ2luIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGhyZWYgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgaHJlZmxhbmcgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgbWVkaWEgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgcmVsIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHJldiA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCB0YXJnZXQgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgX3R5cGUgOiBqc19zdHJpbmcgdCBwcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIHRpdGxlRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgbWV0aG9kIHRleHQgOiBqc19zdHJpbmcgdCBwcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIG1ldGFFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBtZXRob2QgY29udGVudCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBodHRwRXF1aXYgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgbmFtZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBzY2hlbWUgOiBqc19zdHJpbmcgdCBwcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIGJhc2VFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBtZXRob2QgaHJlZiA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCB0YXJnZXQgOiBqc19zdHJpbmcgdCBwcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIHN0eWxlRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgbWV0aG9kIGRpc2FibGVkIDogYm9vbCB0IHByb3BcblxuICAgIG1ldGhvZCBtZWRpYSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBfdHlwZSA6IGpzX3N0cmluZyB0IHByb3BcbiAgZW5kXG5cbmNsYXNzIHR5cGUgYm9keUVsZW1lbnQgPSBlbGVtZW50XG5cbmNsYXNzIHR5cGUgZm9ybUVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIG1ldGhvZCBlbGVtZW50cyA6IGVsZW1lbnQgY29sbGVjdGlvbiB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBsZW5ndGggOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGFjY2VwdENoYXJzZXQgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYWN0aW9uIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGVuY3R5cGUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgX21ldGhvZCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCB0YXJnZXQgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2Qgc3VibWl0IDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgcmVzZXQgOiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBvbnN1Ym1pdCA6ICgnc2VsZiB0LCBzdWJtaXRFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSBvcHRHcm91cEVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIG1ldGhvZCBkaXNhYmxlZCA6IGJvb2wgdCBwcm9wXG5cbiAgICBtZXRob2QgbGFiZWwgOiBqc19zdHJpbmcgdCBwcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIG9wdGlvbkVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IG9wdEdyb3VwRWxlbWVudFxuXG4gICAgbWV0aG9kIGZvcm0gOiBmb3JtRWxlbWVudCB0IG9wdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgZGVmYXVsdFNlbGVjdGVkIDogYm9vbCB0IHByb3BcblxuICAgIG1ldGhvZCB0ZXh0IDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGluZGV4IDogaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBzZWxlY3RlZCA6IGJvb2wgdCBwcm9wXG5cbiAgICBtZXRob2QgdmFsdWUgOiBqc19zdHJpbmcgdCBwcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIHNlbGVjdEVsZW1lbnQgPVxuICBvYmplY3QgKCdzZWxmKVxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgbWV0aG9kIF90eXBlIDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHNlbGVjdGVkSW5kZXggOiBpbnQgcHJvcFxuXG4gICAgbWV0aG9kIHZhbHVlIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGxlbmd0aCA6IGludCBwcm9wXG5cbiAgICBtZXRob2QgZm9ybSA6IGZvcm1FbGVtZW50IHQgb3B0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvcHRpb25zIDogb3B0aW9uRWxlbWVudCBjb2xsZWN0aW9uIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGRpc2FibGVkIDogYm9vbCB0IHByb3BcblxuICAgIG1ldGhvZCBtdWx0aXBsZSA6IGJvb2wgdCBwcm9wXG5cbiAgICBtZXRob2QgbmFtZSA6IGpzX3N0cmluZyB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBzaXplIDogaW50IHByb3BcblxuICAgIG1ldGhvZCB0YWJJbmRleCA6IGludCBwcm9wXG5cbiAgICBtZXRob2QgYWRkIDogI29wdEdyb3VwRWxlbWVudCB0IC0+ICNvcHRHcm91cEVsZW1lbnQgdCBvcHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgcmVtb3ZlIDogaW50IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHJlcXVpcmVkIDogYm9vbCB0IHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25jaGFuZ2UgOiAoJ3NlbGYgdCwgZXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgcHJvcFxuXG4gICAgbWV0aG9kIG9uaW5wdXQgOiAoJ3NlbGYgdCwgZXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSBpbnB1dEVsZW1lbnQgPVxuICBvYmplY3QgKCdzZWxmKVxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgbWV0aG9kIGRlZmF1bHRWYWx1ZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBkZWZhdWx0Q2hlY2tlZCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBmb3JtIDogZm9ybUVsZW1lbnQgdCBvcHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGFjY2VwdCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBhY2Nlc3NLZXkgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYWxpZ24gOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYWx0IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGNoZWNrZWQgOiBib29sIHQgcHJvcFxuXG4gICAgbWV0aG9kIGRpc2FibGVkIDogYm9vbCB0IHByb3BcblxuICAgIG1ldGhvZCBtYXhMZW5ndGggOiBpbnQgcHJvcFxuXG4gICAgbWV0aG9kIG5hbWUgOiBqc19zdHJpbmcgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgcmVhZE9ubHkgOiBib29sIHQgcHJvcFxuXG4gICAgbWV0aG9kIHJlcXVpcmVkIDogYm9vbCB0IHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgc2l6ZSA6IGludCBwcm9wXG5cbiAgICBtZXRob2Qgc3JjIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHRhYkluZGV4IDogaW50IHByb3BcblxuICAgIG1ldGhvZCBfdHlwZSA6IGpzX3N0cmluZyB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB1c2VNYXAgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgdmFsdWUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2Qgc2VsZWN0IDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZmlsZXMgOiBGaWxlLmZpbGVMaXN0IHQgb3B0ZGVmIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBwbGFjZWhvbGRlciA6IGpzX3N0cmluZyB0IHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgc2VsZWN0aW9uRGlyZWN0aW9uIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHNlbGVjdGlvblN0YXJ0IDogaW50IHByb3BcblxuICAgIG1ldGhvZCBzZWxlY3Rpb25FbmQgOiBpbnQgcHJvcFxuXG4gICAgbWV0aG9kIG9uc2VsZWN0IDogKCdzZWxmIHQsIGV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHByb3BcblxuICAgIG1ldGhvZCBvbmNoYW5nZSA6ICgnc2VsZiB0LCBldmVudCB0KSBldmVudF9saXN0ZW5lciBwcm9wXG5cbiAgICBtZXRob2Qgb25pbnB1dCA6ICgnc2VsZiB0LCBldmVudCB0KSBldmVudF9saXN0ZW5lciBwcm9wXG5cbiAgICBtZXRob2Qgb25ibHVyIDogKCdzZWxmIHQsIGZvY3VzRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgcHJvcFxuXG4gICAgbWV0aG9kIG9uZm9jdXMgOiAoJ3NlbGYgdCwgZm9jdXNFdmVudCB0KSBldmVudF9saXN0ZW5lciBwcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIHRleHRBcmVhRWxlbWVudCA9XG4gIG9iamVjdCAoJ3NlbGYpXG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBtZXRob2QgZGVmYXVsdFZhbHVlIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGZvcm0gOiBmb3JtRWxlbWVudCB0IG9wdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgYWNjZXNzS2V5IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGNvbHMgOiBpbnQgcHJvcFxuXG4gICAgbWV0aG9kIGRpc2FibGVkIDogYm9vbCB0IHByb3BcblxuICAgIG1ldGhvZCBuYW1lIDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHJlYWRPbmx5IDogYm9vbCB0IHByb3BcblxuICAgIG1ldGhvZCByb3dzIDogaW50IHByb3BcblxuICAgIG1ldGhvZCBzZWxlY3Rpb25EaXJlY3Rpb24gOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2Qgc2VsZWN0aW9uRW5kIDogaW50IHByb3BcblxuICAgIG1ldGhvZCBzZWxlY3Rpb25TdGFydCA6IGludCBwcm9wXG5cbiAgICBtZXRob2QgdGFiSW5kZXggOiBpbnQgcHJvcFxuXG4gICAgbWV0aG9kIF90eXBlIDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHZhbHVlIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHNlbGVjdCA6IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHJlcXVpcmVkIDogYm9vbCB0IHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2QgcGxhY2Vob2xkZXIgOiBqc19zdHJpbmcgdCB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9uc2VsZWN0IDogKCdzZWxmIHQsIGV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHByb3BcblxuICAgIG1ldGhvZCBvbmNoYW5nZSA6ICgnc2VsZiB0LCBldmVudCB0KSBldmVudF9saXN0ZW5lciBwcm9wXG5cbiAgICBtZXRob2Qgb25pbnB1dCA6ICgnc2VsZiB0LCBldmVudCB0KSBldmVudF9saXN0ZW5lciBwcm9wXG5cbiAgICBtZXRob2Qgb25ibHVyIDogKCdzZWxmIHQsIGZvY3VzRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgcHJvcFxuXG4gICAgbWV0aG9kIG9uZm9jdXMgOiAoJ3NlbGYgdCwgZm9jdXNFdmVudCB0KSBldmVudF9saXN0ZW5lciBwcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIGJ1dHRvbkVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIG1ldGhvZCBmb3JtIDogZm9ybUVsZW1lbnQgdCBvcHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGFjY2Vzc0tleSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBkaXNhYmxlZCA6IGJvb2wgdCBwcm9wXG5cbiAgICBtZXRob2QgbmFtZSA6IGpzX3N0cmluZyB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB0YWJJbmRleCA6IGludCBwcm9wXG5cbiAgICBtZXRob2QgX3R5cGUgOiBqc19zdHJpbmcgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgdmFsdWUgOiBqc19zdHJpbmcgdCBwcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIGxhYmVsRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgbWV0aG9kIGZvcm0gOiBmb3JtRWxlbWVudCB0IG9wdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgYWNjZXNzS2V5IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGh0bWxGb3IgOiBqc19zdHJpbmcgdCBwcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIGZpZWxkU2V0RWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgbWV0aG9kIGZvcm0gOiBmb3JtRWxlbWVudCB0IG9wdCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIGxlZ2VuZEVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIG1ldGhvZCBmb3JtIDogZm9ybUVsZW1lbnQgdCBvcHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGFjY2Vzc0tleSA6IGpzX3N0cmluZyB0IHByb3BcbiAgZW5kXG5cbmNsYXNzIHR5cGUgdUxpc3RFbGVtZW50ID0gZWxlbWVudFxuXG5jbGFzcyB0eXBlIG9MaXN0RWxlbWVudCA9IGVsZW1lbnRcblxuY2xhc3MgdHlwZSBkTGlzdEVsZW1lbnQgPSBlbGVtZW50XG5cbmNsYXNzIHR5cGUgbGlFbGVtZW50ID0gZWxlbWVudFxuXG5jbGFzcyB0eXBlIGRpdkVsZW1lbnQgPSBlbGVtZW50XG5cbmNsYXNzIHR5cGUgcGFyYWdyYXBoRWxlbWVudCA9IGVsZW1lbnRcblxuY2xhc3MgdHlwZSBoZWFkaW5nRWxlbWVudCA9IGVsZW1lbnRcblxuY2xhc3MgdHlwZSBxdW90ZUVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIG1ldGhvZCBjaXRlIDoganNfc3RyaW5nIHQgcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSBwcmVFbGVtZW50ID0gZWxlbWVudFxuXG5jbGFzcyB0eXBlIGJyRWxlbWVudCA9IGVsZW1lbnRcblxuY2xhc3MgdHlwZSBockVsZW1lbnQgPSBlbGVtZW50XG5cbmNsYXNzIHR5cGUgbW9kRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgbWV0aG9kIGNpdGUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgZGF0ZVRpbWUgOiBqc19zdHJpbmcgdCBwcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIGFuY2hvckVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIG1ldGhvZCBhY2Nlc3NLZXkgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgY2hhcnNldCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBjb29yZHMgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgaHJlZiA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBocmVmbGFuZyA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBuYW1lIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHJlbCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCByZXYgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2Qgc2hhcGUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgdGFiSW5kZXggOiBpbnQgcHJvcFxuXG4gICAgbWV0aG9kIHRhcmdldCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBfdHlwZSA6IGpzX3N0cmluZyB0IHByb3BcbiAgZW5kXG5cbmNsYXNzIHR5cGUgaW1hZ2VFbGVtZW50ID1cbiAgb2JqZWN0ICgnc2VsZilcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIG1ldGhvZCBhbHQgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2Qgc3JjIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHVzZU1hcCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBpc01hcCA6IGJvb2wgdCBwcm9wXG5cbiAgICBtZXRob2Qgd2lkdGggOiBpbnQgcHJvcFxuXG4gICAgbWV0aG9kIGhlaWdodCA6IGludCBwcm9wXG5cbiAgICBtZXRob2QgbmF0dXJhbFdpZHRoIDogaW50IG9wdGRlZiByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgbmF0dXJhbEhlaWdodCA6IGludCBvcHRkZWYgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGNvbXBsZXRlIDogYm9vbCB0IHByb3BcblxuICAgIG1ldGhvZCBvbmxvYWQgOiAoJ3NlbGYgdCwgZXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgcHJvcFxuXG4gICAgbWV0aG9kIG9uZXJyb3IgOiAoJ3NlbGYgdCwgZXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgcHJvcFxuXG4gICAgbWV0aG9kIG9uYWJvcnQgOiAoJ3NlbGYgdCwgZXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSBvYmplY3RFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBtZXRob2QgZm9ybSA6IGZvcm1FbGVtZW50IHQgb3B0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBjb2RlIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGFyY2hpdmUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgY29kZUJhc2UgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgY29kZVR5cGUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgZGF0YSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBkZWNsYXJlIDogYm9vbCB0IHByb3BcblxuICAgIG1ldGhvZCBoZWlnaHQgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgbmFtZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBzdGFuZGJ5IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHRhYkluZGV4IDogaW50IHByb3BcblxuICAgIG1ldGhvZCBfdHlwZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCB1c2VNYXAgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2Qgd2lkdGggOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgZG9jdW1lbnQgOiBEb20uZWxlbWVudCBEb20uZG9jdW1lbnQgdCBvcHQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSBwYXJhbUVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIG1ldGhvZCBuYW1lIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIF90eXBlIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHZhbHVlIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHZhbHVlVHlwZSA6IGpzX3N0cmluZyB0IHByb3BcbiAgZW5kXG5cbmNsYXNzIHR5cGUgYXJlYUVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIG1ldGhvZCBhY2Nlc3NLZXkgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYWx0IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGNvb3JkcyA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBocmVmIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIG5vSHJlZiA6IGJvb2wgdCBwcm9wXG5cbiAgICBtZXRob2Qgc2hhcGUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgdGFiSW5kZXggOiBpbnQgcHJvcFxuXG4gICAgbWV0aG9kIHRhcmdldCA6IGpzX3N0cmluZyB0IHByb3BcbiAgZW5kXG5cbmNsYXNzIHR5cGUgbWFwRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgbWV0aG9kIGFyZWFzIDogYXJlYUVsZW1lbnQgY29sbGVjdGlvbiB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBuYW1lIDoganNfc3RyaW5nIHQgcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSBzY3JpcHRFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBtZXRob2QgdGV4dCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBjaGFyc2V0IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGRlZmVyIDogYm9vbCB0IHByb3BcblxuICAgIG1ldGhvZCBzcmMgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgX3R5cGUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYXN5bmMgOiBib29sIHQgcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSBlbWJlZEVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIG1ldGhvZCBzcmMgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgaGVpZ2h0IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHdpZHRoIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIF90eXBlIDoganNfc3RyaW5nIHQgcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSB0YWJsZUNlbGxFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBtZXRob2QgY2VsbEluZGV4IDogaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBhYmJyIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGFsaWduIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGF4aXMgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgY2ggOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgY2hPZmYgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgY29sU3BhbiA6IGludCBwcm9wXG5cbiAgICBtZXRob2QgaGVhZGVycyA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCByb3dTcGFuIDogaW50IHByb3BcblxuICAgIG1ldGhvZCBzY29wZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCB2QWxpZ24gOiBqc19zdHJpbmcgdCBwcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIHRhYmxlUm93RWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgbWV0aG9kIHJvd0luZGV4IDogaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBzZWN0aW9uUm93SW5kZXggOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGNlbGxzIDogdGFibGVDZWxsRWxlbWVudCBjb2xsZWN0aW9uIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGFsaWduIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGNoIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGNoT2ZmIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHZBbGlnbiA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBpbnNlcnRDZWxsIDogaW50IC0+IHRhYmxlQ2VsbEVsZW1lbnQgdCBtZXRoXG5cbiAgICBtZXRob2QgZGVsZXRlQ2VsbCA6IGludCAtPiB1bml0IG1ldGhcbiAgZW5kXG5cbmNsYXNzIHR5cGUgdGFibGVDb2xFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBtZXRob2QgYWxpZ24gOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgY2ggOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgY2hPZmYgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2Qgc3BhbiA6IGludCBwcm9wXG5cbiAgICBtZXRob2QgdkFsaWduIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHdpZHRoIDoganNfc3RyaW5nIHQgcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSB0YWJsZVNlY3Rpb25FbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBtZXRob2QgYWxpZ24gOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgY2ggOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgY2hPZmYgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgdkFsaWduIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHJvd3MgOiB0YWJsZVJvd0VsZW1lbnQgY29sbGVjdGlvbiB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBpbnNlcnRSb3cgOiBpbnQgLT4gdGFibGVSb3dFbGVtZW50IHQgbWV0aFxuXG4gICAgbWV0aG9kIGRlbGV0ZVJvdyA6IGludCAtPiB1bml0IG1ldGhcbiAgZW5kXG5cbmNsYXNzIHR5cGUgdGFibGVDYXB0aW9uRWxlbWVudCA9IGVsZW1lbnRcblxuY2xhc3MgdHlwZSB0YWJsZUVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIG1ldGhvZCBjYXB0aW9uIDogdGFibGVDYXB0aW9uRWxlbWVudCB0IHByb3BcblxuICAgIG1ldGhvZCB0SGVhZCA6IHRhYmxlU2VjdGlvbkVsZW1lbnQgdCBwcm9wXG5cbiAgICBtZXRob2QgdEZvb3QgOiB0YWJsZVNlY3Rpb25FbGVtZW50IHQgcHJvcFxuXG4gICAgbWV0aG9kIHJvd3MgOiB0YWJsZVJvd0VsZW1lbnQgY29sbGVjdGlvbiB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB0Qm9kaWVzIDogdGFibGVTZWN0aW9uRWxlbWVudCBjb2xsZWN0aW9uIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGFsaWduIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGJvcmRlciA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBjZWxsUGFkZGluZyA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBjZWxsU3BhY2luZyA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBmcmFtZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBydWxlcyA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBzdW1tYXJ5IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHdpZHRoIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGNyZWF0ZVRIZWFkIDogdGFibGVTZWN0aW9uRWxlbWVudCB0IG1ldGhcblxuICAgIG1ldGhvZCBkZWxldGVUSGVhZCA6IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGNyZWF0ZVRGb290IDogdGFibGVTZWN0aW9uRWxlbWVudCB0IG1ldGhcblxuICAgIG1ldGhvZCBkZWxldGVURm9vdCA6IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGNyZWF0ZUNhcHRpb24gOiB0YWJsZUNhcHRpb25FbGVtZW50IHQgbWV0aFxuXG4gICAgbWV0aG9kIGRlbGV0ZUNhcHRpb24gOiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBpbnNlcnRSb3cgOiBpbnQgLT4gdGFibGVSb3dFbGVtZW50IHQgbWV0aFxuXG4gICAgbWV0aG9kIGRlbGV0ZVJvdyA6IGludCAtPiB1bml0IG1ldGhcbiAgZW5kXG5cbmNsYXNzIHR5cGUgdGltZVJhbmdlcyA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBsZW5ndGggOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHN0YXJ0IDogaW50IC0+IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBlbmRfIDogaW50IC0+IGZsb2F0IG1ldGhcbiAgZW5kXG5cbnR5cGUgbmV0d29ya1N0YXRlID1cbiAgfCBORVRXT1JLX0VNUFRZXG4gIHwgTkVUV09SS19JRExFXG4gIHwgTkVUV09SS19MT0FESU5HXG4gIHwgTkVUV09SS19OT19TT1VSQ0VcblxudHlwZSByZWFkeVN0YXRlID1cbiAgfCBIQVZFX05PVEhJTkdcbiAgfCBIQVZFX01FVEFEQVRBXG4gIHwgSEFWRV9DVVJSRU5UX0RBVEFcbiAgfCBIQVZFX0ZVVFVSRV9EQVRBXG4gIHwgSEFWRV9FTk9VR0hfREFUQVxuXG4oKiBodHRwOi8vd3d3Lnczc2Nob29scy5jb20vdGFncy9yZWZfYXZfZG9tLmFzcCAqKVxuKCogb25seSBmZWF0dXJlcyBzdXBwb3J0ZWQgYnkgYWxsIGJyb3dzZXIuIChJRTkrKSAqKVxuY2xhc3MgdHlwZSBtZWRpYUVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIG1ldGhvZCBjYW5QbGF5VHlwZSA6IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IG1ldGhcblxuICAgIG1ldGhvZCBsb2FkIDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgcGxheSA6IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHBhdXNlIDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgYXV0b3BsYXkgOiBib29sIHQgcHJvcFxuXG4gICAgbWV0aG9kIGJ1ZmZlcmVkIDogdGltZVJhbmdlcyB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBjb250cm9scyA6IGJvb2wgdCBwcm9wXG5cbiAgICBtZXRob2QgY3VycmVudFNyYyA6IGpzX3N0cmluZyB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBjdXJyZW50VGltZSA6IGZsb2F0IHByb3BcblxuICAgIG1ldGhvZCBkdXJhdGlvbiA6IGZsb2F0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBlbmRlZCA6IGJvb2wgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgbG9vcCA6IGJvb2wgdCBwcm9wXG5cbiAgICBtZXRob2QgbWVkaWFncm91cCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBtdXRlZCA6IGJvb2wgdCBwcm9wXG5cbiAgICBtZXRob2QgbmV0d29ya1N0YXRlX2ludCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgbmV0d29ya1N0YXRlIDogbmV0d29ya1N0YXRlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBwYXVzZWQgOiBib29sIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHBsYXliYWNrUmF0ZSA6IGZsb2F0IHByb3BcblxuICAgIG1ldGhvZCBwbGF5ZWQgOiB0aW1lUmFuZ2VzIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHByZWxvYWQgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgcmVhZHlTdGF0ZV9pbnQgOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHJlYWR5U3RhdGUgOiByZWFkeVN0YXRlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBzZWVrYWJsZSA6IHRpbWVSYW5nZXMgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgc2Vla2luZyA6IGJvb2wgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgc3JjIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHZvbHVtZSA6IGZsb2F0IHByb3BcblxuICAgIG1ldGhvZCBvbmNhbnBsYXkgOiAoJ3NlbGYgdCwgbWVkaWFFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9uY2FucGxheXRocm91Z2ggOiAoJ3NlbGYgdCwgbWVkaWFFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9uZHVyYXRpb25jaGFuZ2UgOiAoJ3NlbGYgdCwgbWVkaWFFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9uZW1wdGllZCA6ICgnc2VsZiB0LCBtZWRpYUV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25lbmRlZCA6ICgnc2VsZiB0LCBtZWRpYUV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25sb2FkZWRkYXRhIDogKCdzZWxmIHQsIG1lZGlhRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbmxvYWRlZG1ldGFkYXRhIDogKCdzZWxmIHQsIG1lZGlhRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbmxvYWRzdGFydCA6ICgnc2VsZiB0LCBtZWRpYUV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25wYXVzZSA6ICgnc2VsZiB0LCBtZWRpYUV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25wbGF5IDogKCdzZWxmIHQsIG1lZGlhRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbnBsYXlpbmcgOiAoJ3NlbGYgdCwgbWVkaWFFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9ucmF0ZWNoYW5nZSA6ICgnc2VsZiB0LCBtZWRpYUV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25zZWVrZWQgOiAoJ3NlbGYgdCwgbWVkaWFFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9uc2Vla2luZyA6ICgnc2VsZiB0LCBtZWRpYUV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25zdGFsbGVkIDogKCdzZWxmIHQsIG1lZGlhRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbnN1c3BlbmQgOiAoJ3NlbGYgdCwgbWVkaWFFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9udm9sdW1lY2hhbmdlIDogKCdzZWxmIHQsIG1lZGlhRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbndhaXRpbmcgOiAoJ3NlbGYgdCwgbWVkaWFFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSBhdWRpb0VsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IG1lZGlhRWxlbWVudFxuICBlbmRcblxuY2xhc3MgdHlwZSB2aWRlb0VsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IG1lZGlhRWxlbWVudFxuICBlbmRcblxudHlwZSBjb250ZXh0ID0ganNfc3RyaW5nIHRcblxubGV0IF8yZF8gPSBKcy5zdHJpbmcgXCIyZFwiXG5cbnR5cGUgY2FudmFzUGF0dGVyblxuXG5jbGFzcyB0eXBlIGNhbnZhc0VsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIG1ldGhvZCB3aWR0aCA6IGludCBwcm9wXG5cbiAgICBtZXRob2QgaGVpZ2h0IDogaW50IHByb3BcblxuICAgIG1ldGhvZCB0b0RhdGFVUkwgOiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICBtZXRob2QgdG9EYXRhVVJMX3R5cGUgOiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICBtZXRob2QgdG9EYXRhVVJMX3R5cGVfY29tcHJlc3Npb24gOiBqc19zdHJpbmcgdCAtPiBmbG9hdCAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0Q29udGV4dCA6IGpzX3N0cmluZyB0IC0+IGNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB0IG1ldGhcbiAgZW5kXG5cbmFuZCBjYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPVxuICBvYmplY3RcbiAgICBtZXRob2QgY2FudmFzIDogY2FudmFzRWxlbWVudCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBzYXZlIDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgcmVzdG9yZSA6IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHNjYWxlIDogZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgcm90YXRlIDogZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdHJhbnNsYXRlIDogZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdHJhbnNmb3JtIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0VHJhbnNmb3JtIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZ2xvYmFsQWxwaGEgOiBmbG9hdCBwcm9wXG5cbiAgICBtZXRob2QgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHN0cm9rZVN0eWxlIDoganNfc3RyaW5nIHQgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBzdHJva2VTdHlsZV9ncmFkaWVudCA6IGNhbnZhc0dyYWRpZW50IHQgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBzdHJva2VTdHlsZV9wYXR0ZXJuIDogY2FudmFzUGF0dGVybiB0IHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2QgZmlsbFN0eWxlIDoganNfc3RyaW5nIHQgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBmaWxsU3R5bGVfZ3JhZGllbnQgOiBjYW52YXNHcmFkaWVudCB0IHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2QgZmlsbFN0eWxlX3BhdHRlcm4gOiBjYW52YXNQYXR0ZXJuIHQgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBjcmVhdGVMaW5lYXJHcmFkaWVudCA6XG4gICAgICBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBjYW52YXNHcmFkaWVudCB0IG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVSYWRpYWxHcmFkaWVudCA6XG4gICAgICBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBjYW52YXNHcmFkaWVudCB0IG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVQYXR0ZXJuIDogaW1hZ2VFbGVtZW50IHQgLT4ganNfc3RyaW5nIHQgLT4gY2FudmFzUGF0dGVybiB0IG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVQYXR0ZXJuX2Zyb21DYW52YXMgOlxuICAgICAgY2FudmFzRWxlbWVudCB0IC0+IGpzX3N0cmluZyB0IC0+IGNhbnZhc1BhdHRlcm4gdCBtZXRoXG5cbiAgICBtZXRob2QgY3JlYXRlUGF0dGVybl9mcm9tVmlkZW8gOiB2aWRlb0VsZW1lbnQgdCAtPiBqc19zdHJpbmcgdCAtPiBjYW52YXNQYXR0ZXJuIHQgbWV0aFxuXG4gICAgbWV0aG9kIGxpbmVXaWR0aCA6IGZsb2F0IHByb3BcblxuICAgIG1ldGhvZCBsaW5lQ2FwIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGxpbmVKb2luIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIG1pdGVyTGltaXQgOiBmbG9hdCBwcm9wXG5cbiAgICBtZXRob2Qgc2hhZG93T2Zmc2V0WCA6IGZsb2F0IHByb3BcblxuICAgIG1ldGhvZCBzaGFkb3dPZmZzZXRZIDogZmxvYXQgcHJvcFxuXG4gICAgbWV0aG9kIHNoYWRvd0JsdXIgOiBmbG9hdCBwcm9wXG5cbiAgICBtZXRob2Qgc2hhZG93Q29sb3IgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgY2xlYXJSZWN0IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZmlsbFJlY3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzdHJva2VSZWN0IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgYmVnaW5QYXRoIDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY2xvc2VQYXRoIDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgbW92ZVRvIDogZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgbGluZVRvIDogZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgcXVhZHJhdGljQ3VydmVUbyA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGJlemllckN1cnZlVG8gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBhcmNUbyA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHJlY3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBhcmMgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBib29sIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZmlsbCA6IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHN0cm9rZSA6IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGNsaXAgOiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBpc1BvaW50SW5QYXRoIDogZmxvYXQgLT4gZmxvYXQgLT4gYm9vbCB0IG1ldGhcblxuICAgIG1ldGhvZCBkcmF3Rm9jdXNSaW5nIDogI2VsZW1lbnQgdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBib29sIHQgLT4gYm9vbCB0IG1ldGhcblxuICAgIG1ldGhvZCBmb250IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHRleHRBbGlnbiA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCB0ZXh0QmFzZWxpbmUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgZmlsbFRleHQgOiBqc19zdHJpbmcgdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBmaWxsVGV4dF93aXRoV2lkdGggOiBqc19zdHJpbmcgdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzdHJva2VUZXh0IDoganNfc3RyaW5nIHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc3Ryb2tlVGV4dF93aXRoV2lkdGggOiBqc19zdHJpbmcgdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBtZWFzdXJlVGV4dCA6IGpzX3N0cmluZyB0IC0+IHRleHRNZXRyaWNzIHQgbWV0aFxuXG4gICAgbWV0aG9kIGRyYXdJbWFnZSA6IGltYWdlRWxlbWVudCB0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGRyYXdJbWFnZV93aXRoU2l6ZSA6XG4gICAgICBpbWFnZUVsZW1lbnQgdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBkcmF3SW1hZ2VfZnVsbCA6XG4gICAgICAgICBpbWFnZUVsZW1lbnQgdFxuICAgICAgLT4gZmxvYXRcbiAgICAgIC0+IGZsb2F0XG4gICAgICAtPiBmbG9hdFxuICAgICAgLT4gZmxvYXRcbiAgICAgIC0+IGZsb2F0XG4gICAgICAtPiBmbG9hdFxuICAgICAgLT4gZmxvYXRcbiAgICAgIC0+IGZsb2F0XG4gICAgICAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBkcmF3SW1hZ2VfZnJvbUNhbnZhcyA6IGNhbnZhc0VsZW1lbnQgdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBkcmF3SW1hZ2VfZnJvbUNhbnZhc1dpdGhTaXplIDpcbiAgICAgIGNhbnZhc0VsZW1lbnQgdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBkcmF3SW1hZ2VfZnVsbEZyb21DYW52YXMgOlxuICAgICAgICAgY2FudmFzRWxlbWVudCB0XG4gICAgICAtPiBmbG9hdFxuICAgICAgLT4gZmxvYXRcbiAgICAgIC0+IGZsb2F0XG4gICAgICAtPiBmbG9hdFxuICAgICAgLT4gZmxvYXRcbiAgICAgIC0+IGZsb2F0XG4gICAgICAtPiBmbG9hdFxuICAgICAgLT4gZmxvYXRcbiAgICAgIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGRyYXdJbWFnZV9mcm9tVmlkZW9XaXRoVmlkZW8gOiB2aWRlb0VsZW1lbnQgdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBkcmF3SW1hZ2VfZnJvbVZpZGVvV2l0aFNpemUgOlxuICAgICAgdmlkZW9FbGVtZW50IHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZHJhd0ltYWdlX2Z1bGxGcm9tVmlkZW8gOlxuICAgICAgICAgdmlkZW9FbGVtZW50IHRcbiAgICAgIC0+IGZsb2F0XG4gICAgICAtPiBmbG9hdFxuICAgICAgLT4gZmxvYXRcbiAgICAgIC0+IGZsb2F0XG4gICAgICAtPiBmbG9hdFxuICAgICAgLT4gZmxvYXRcbiAgICAgIC0+IGZsb2F0XG4gICAgICAtPiBmbG9hdFxuICAgICAgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY3JlYXRlSW1hZ2VEYXRhIDogaW50IC0+IGludCAtPiBpbWFnZURhdGEgdCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0SW1hZ2VEYXRhIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gaW1hZ2VEYXRhIHQgbWV0aFxuXG4gICAgbWV0aG9kIHB1dEltYWdlRGF0YSA6IGltYWdlRGF0YSB0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXQgbWV0aFxuICBlbmRcblxuYW5kIGNhbnZhc0dyYWRpZW50ID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGFkZENvbG9yU3RvcCA6IGZsb2F0IC0+IGpzX3N0cmluZyB0IC0+IHVuaXQgbWV0aFxuICBlbmRcblxuYW5kIHRleHRNZXRyaWNzID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIHdpZHRoIDogZmxvYXQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuYW5kIGltYWdlRGF0YSA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCB3aWR0aCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgaGVpZ2h0IDogaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBkYXRhIDogY2FudmFzUGl4ZWxBcnJheSB0IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbmFuZCBjYW52YXNQaXhlbEFycmF5ID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGxlbmd0aCA6IGludCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG5leHRlcm5hbCBwaXhlbF9nZXQgOiBjYW52YXNQaXhlbEFycmF5IHQgLT4gaW50IC0+IGludCA9IFwiY2FtbF9qc19nZXRcIlxuXG5leHRlcm5hbCBwaXhlbF9zZXQgOiBjYW52YXNQaXhlbEFycmF5IHQgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2pzX3NldFwiXG5cbmNsYXNzIHR5cGUgcmFuZ2UgPVxuICBvYmplY3RcbiAgICBtZXRob2QgY29sbGFwc2VkIDogYm9vbCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBzdGFydE9mZnNldCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgZW5kT2Zmc2V0IDogaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBzdGFydENvbnRhaW5lciA6IERvbS5ub2RlIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGVuZENvbnRhaW5lciA6IERvbS5ub2RlIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHNldFN0YXJ0IDogRG9tLm5vZGUgdCAtPiBpbnQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0RW5kIDogRG9tLm5vZGUgdCAtPiBpbnQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0U3RhcnRCZWZvcmUgOiBEb20ubm9kZSB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldEVuZEJlZm9yZSA6IERvbS5ub2RlIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0U3RhcnRBZnRlciA6IERvbS5ub2RlIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0RW5kQWZ0ZXIgOiBEb20ubm9kZSB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHNlbGVjdE5vZGUgOiBEb20ubm9kZSB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHNlbGVjdE5vZGVDb250ZW50cyA6IERvbS5ub2RlIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY29sbGFwc2UgOiBib29sIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY2xvbmVDb250ZW50cyA6IERvbS5kb2N1bWVudEZyYWdtZW50IHQgbWV0aFxuXG4gICAgbWV0aG9kIGV4dHJhY3RDb250ZW50cyA6IERvbS5kb2N1bWVudEZyYWdtZW50IHQgbWV0aFxuXG4gICAgbWV0aG9kIGRlbGV0ZUNvbnRlbnRzIDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgaW5zZXJ0Tm9kZSA6IERvbS5ub2RlIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc3Vycm91bmRDb250ZW50cyA6IERvbS5ub2RlIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY2xvbmVSYW5nZSA6IHJhbmdlIHQgbWV0aFxuXG4gICAgbWV0aG9kIHRvU3RyaW5nIDoganNfc3RyaW5nIHQgbWV0aFxuICBlbmRcblxuKCoqIEluZm9ybWF0aW9uIG9uIGN1cnJlbnQgc2VsZWN0aW9uICopXG5jbGFzcyB0eXBlIHNlbGVjdGlvbiA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBhbmNob3JOb2RlIDogRG9tLm5vZGUgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgYW5jaG9yT2Zmc2V0IDogaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBmb2N1c05vZGUgOiBEb20ubm9kZSB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBmb2N1c09mZnNldCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgaXNDb2xsYXBzZWQgOiBib29sIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHJhbmdlQ291bnQgOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGdldFJhbmdlQXQgOiBpbnQgLT4gcmFuZ2UgdCBtZXRoXG5cbiAgICBtZXRob2QgY29sbGFwc2UgOiBib29sIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZXh0ZW5kIDogRG9tLm5vZGUgdCAtPiBpbnQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgbW9kaWZ5IDoganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY29sbGFwc2VUb1N0YXJ0IDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY29sbGFwc2VUb0VuZCA6IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHNlbGVjdEFsbENoaWxkcmVuIDogRG9tLm5vZGUgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBhZGRSYW5nZSA6IHJhbmdlIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgcmVtb3ZlUmFuZ2UgOiByYW5nZSB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHJlbW92ZUFsbFJhbmdlcyA6IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGRlbGV0ZUZyb21Eb2N1bWVudCA6IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGNvbnRhaW5zTm9kZSA6IERvbS5ub2RlIHQgLT4gYm9vbCB0IC0+IGJvb2wgdCBtZXRoXG5cbiAgICBtZXRob2QgdG9TdHJpbmcgOiBqc19zdHJpbmcgdCBtZXRoXG4gIGVuZFxuXG5jbGFzcyB0eXBlIGRvY3VtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBbZWxlbWVudF0gRG9tLmRvY3VtZW50XG5cbiAgICBpbmhlcml0IG5vZGVTZWxlY3RvclxuXG4gICAgaW5oZXJpdCBldmVudFRhcmdldFxuXG4gICAgbWV0aG9kIHRpdGxlIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHJlZmVycmVyIDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGRvbWFpbiA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBfVVJMIDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGhlYWQgOiBoZWFkRWxlbWVudCB0IHByb3BcblxuICAgIG1ldGhvZCBib2R5IDogYm9keUVsZW1lbnQgdCBwcm9wXG5cbiAgICBtZXRob2QgZG9jdW1lbnRFbGVtZW50IDogaHRtbEVsZW1lbnQgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgaW1hZ2VzIDogaW1hZ2VFbGVtZW50IGNvbGxlY3Rpb24gdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgYXBwbGV0cyA6IGVsZW1lbnQgY29sbGVjdGlvbiB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBsaW5rcyA6IGVsZW1lbnQgY29sbGVjdGlvbiB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBmb3JtcyA6IGZvcm1FbGVtZW50IGNvbGxlY3Rpb24gdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgYW5jaG9ycyA6IGVsZW1lbnQgY29sbGVjdGlvbiB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBjb29raWUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgZGVzaWduTW9kZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBvcGVuXyA6IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGNsb3NlIDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgd3JpdGUgOiBqc19zdHJpbmcgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBleGVjQ29tbWFuZCA6IGpzX3N0cmluZyB0IC0+IGJvb2wgdCAtPiBqc19zdHJpbmcgdCBvcHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY3JlYXRlUmFuZ2UgOiByYW5nZSB0IG1ldGhcblxuICAgIG1ldGhvZCByZWFkeVN0YXRlIDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGdldEVsZW1lbnRzQnlDbGFzc05hbWUgOiBqc19zdHJpbmcgdCAtPiBlbGVtZW50IERvbS5ub2RlTGlzdCB0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRFbGVtZW50c0J5TmFtZSA6IGpzX3N0cmluZyB0IC0+IGVsZW1lbnQgRG9tLm5vZGVMaXN0IHQgbWV0aFxuXG4gICAgbWV0aG9kIGFjdGl2ZUVsZW1lbnQgOiBlbGVtZW50IHQgb3B0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBoaWRkZW4gOiBib29sIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9uZnVsbHNjcmVlbmNoYW5nZSA6IChkb2N1bWVudCB0LCBldmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9ud2Via2l0ZnVsbHNjcmVlbmNoYW5nZSA6IChkb2N1bWVudCB0LCBldmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgaW5oZXJpdCBldmVudFRhcmdldFxuICBlbmRcblxudHlwZSBpbnRlcnZhbF9pZFxuXG50eXBlIHRpbWVvdXRfaWRcblxudHlwZSBhbmltYXRpb25fZnJhbWVfcmVxdWVzdF9pZFxuXG5jbGFzcyB0eXBlIGxvY2F0aW9uID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGhyZWYgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgcHJvdG9jb2wgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgaG9zdCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBob3N0bmFtZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBvcmlnaW4gOiBqc19zdHJpbmcgdCBvcHRkZWYgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHBvcnQgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgcGF0aG5hbWUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2Qgc2VhcmNoIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGhhc2ggOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgYXNzaWduIDoganNfc3RyaW5nIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgcmVwbGFjZSA6IGpzX3N0cmluZyB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHJlbG9hZCA6IHVuaXQgbWV0aFxuICBlbmRcblxubGV0IGxvY2F0aW9uX29yaWdpbiAobG9jIDogbG9jYXRpb24gdCkgPVxuICBPcHRkZWYuY2FzZVxuICAgIGxvYyMjLm9yaWdpblxuICAgIChmdW4gKCkgLT5cbiAgICAgIGxldCBwcm90b2NvbCA9IGxvYyMjLnByb3RvY29sIGluXG4gICAgICBsZXQgaG9zdG5hbWUgPSBsb2MjIy5ob3N0bmFtZSBpblxuICAgICAgbGV0IHBvcnQgPSBsb2MjIy5wb3J0IGluXG4gICAgICBpZiBwcm90b2NvbCMjLmxlbmd0aCA9IDAgJiYgaG9zdG5hbWUjIy5sZW5ndGggPSAwXG4gICAgICB0aGVuIEpzLnN0cmluZyBcIlwiXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBvcmlnaW4gPSBwcm90b2NvbCMjY29uY2F0XzIgKEpzLnN0cmluZyBcIi8vXCIpIGhvc3RuYW1lIGluXG4gICAgICAgIGlmIHBvcnQjIy5sZW5ndGggPiAwIHRoZW4gb3JpZ2luIyNjb25jYXRfMiAoSnMuc3RyaW5nIFwiOlwiKSBsb2MjIy5wb3J0IGVsc2Ugb3JpZ2luKVxuICAgIChmdW4gbyAtPiBvKVxuXG5jbGFzcyB0eXBlIGhpc3RvcnkgPVxuICBvYmplY3RcbiAgICBtZXRob2QgbGVuZ3RoIDogaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBzdGF0ZSA6IEpzLlVuc2FmZS5hbnkgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGdvIDogaW50IG9wdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBiYWNrIDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZm9yd2FyZCA6IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHB1c2hTdGF0ZSA6ICdhLiAnYSAtPiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCBvcHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgcmVwbGFjZVN0YXRlIDogJ2EuICdhIC0+IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IG9wdCAtPiB1bml0IG1ldGhcbiAgZW5kXG5cbmNsYXNzIHR5cGUgdW5kb01hbmFnZXIgPSBvYmplY3QgZW5kXG5cbmNsYXNzIHR5cGUgbmF2aWdhdG9yID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGFwcENvZGVOYW1lIDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGFwcE5hbWUgOiBqc19zdHJpbmcgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgYXBwVmVyc2lvbiA6IGpzX3N0cmluZyB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBjb29raWVFbmFibGVkIDogYm9vbCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbkxpbmUgOiBib29sIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHBsYXRmb3JtIDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHZlbmRvciA6IGpzX3N0cmluZyB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB1c2VyQWdlbnQgOiBqc19zdHJpbmcgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgbGFuZ3VhZ2UgOiBqc19zdHJpbmcgdCBvcHRkZWYgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHVzZXJMYW5ndWFnZSA6IGpzX3N0cmluZyB0IG9wdGRlZiByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgbWF4VG91Y2hQb2ludHMgOiBpbnQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSBzY3JlZW4gPVxuICBvYmplY3RcbiAgICBtZXRob2Qgd2lkdGggOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGhlaWdodCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgYXZhaWxXaWR0aCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgYXZhaWxIZWlnaHQgOiBpbnQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSBhcHBsaWNhdGlvbkNhY2hlID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIHN0YXR1cyA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgdXBkYXRlIDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgYWJvcnQgOiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzd2FwQ2FjaGUgOiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBvbmNoZWNraW5nIDogKGFwcGxpY2F0aW9uQ2FjaGUgdCwgZXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgcHJvcFxuXG4gICAgbWV0aG9kIG9uZXJyb3IgOiAoYXBwbGljYXRpb25DYWNoZSB0LCBldmVudCB0KSBldmVudF9saXN0ZW5lciBwcm9wXG5cbiAgICBtZXRob2Qgb25ub3VwZGF0ZSA6IChhcHBsaWNhdGlvbkNhY2hlIHQsIGV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHByb3BcblxuICAgIG1ldGhvZCBvbmRvd25sb2FkaW5nIDogKGFwcGxpY2F0aW9uQ2FjaGUgdCwgZXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgcHJvcFxuXG4gICAgbWV0aG9kIG9ucHJvZ3Jlc3MgOiAoYXBwbGljYXRpb25DYWNoZSB0LCBldmVudCB0KSBldmVudF9saXN0ZW5lciBwcm9wXG5cbiAgICBtZXRob2Qgb251cGRhdGVyZWFkeSA6IChhcHBsaWNhdGlvbkNhY2hlIHQsIGV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHByb3BcblxuICAgIG1ldGhvZCBvbmNhY2hlZCA6IChhcHBsaWNhdGlvbkNhY2hlIHQsIGV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHByb3BcblxuICAgIG1ldGhvZCBvbm9ic29sZXRlIDogKGFwcGxpY2F0aW9uQ2FjaGUgdCwgZXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgcHJvcFxuXG4gICAgaW5oZXJpdCBldmVudFRhcmdldFxuICBlbmRcblxuY2xhc3MgdHlwZSBfVVJMID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGNyZWF0ZU9iamVjdFVSTCA6ICNGaWxlLmJsb2IgdCAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICBtZXRob2QgcmV2b2tlT2JqZWN0VVJMIDoganNfc3RyaW5nIHQgLT4gdW5pdCBtZXRoXG4gIGVuZFxuXG5jbGFzcyB0eXBlIHdpbmRvdyA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZXZlbnRUYXJnZXRcblxuICAgIG1ldGhvZCBkb2N1bWVudCA6IGRvY3VtZW50IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGFwcGxpY2F0aW9uQ2FjaGUgOiBhcHBsaWNhdGlvbkNhY2hlIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG5hbWUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgbG9jYXRpb24gOiBsb2NhdGlvbiB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBoaXN0b3J5IDogaGlzdG9yeSB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB1bmRvTWFuYWdlciA6IHVuZG9NYW5hZ2VyIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG5hdmlnYXRvciA6IG5hdmlnYXRvciB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBnZXRTZWxlY3Rpb24gOiBzZWxlY3Rpb24gdCBtZXRoXG5cbiAgICBtZXRob2QgY2xvc2UgOiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBjbG9zZWQgOiBib29sIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHN0b3AgOiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBmb2N1cyA6IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGJsdXIgOiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzY3JvbGwgOiBpbnQgLT4gaW50IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHNjcm9sbEJ5IDogaW50IC0+IGludCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzZXNzaW9uU3RvcmFnZSA6IHN0b3JhZ2UgdCBvcHRkZWYgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGxvY2FsU3RvcmFnZSA6IHN0b3JhZ2UgdCBvcHRkZWYgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHRvcCA6IHdpbmRvdyB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBwYXJlbnQgOiB3aW5kb3cgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgZnJhbWVFbGVtZW50IDogZWxlbWVudCB0IG9wdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb3Blbl8gOiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCBvcHQgLT4gd2luZG93IHQgb3B0IG1ldGhcblxuICAgIG1ldGhvZCBhbGVydCA6IGpzX3N0cmluZyB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGNvbmZpcm0gOiBqc19zdHJpbmcgdCAtPiBib29sIHQgbWV0aFxuXG4gICAgbWV0aG9kIHByb21wdCA6IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IC0+IGpzX3N0cmluZyB0IG9wdCBtZXRoXG5cbiAgICBtZXRob2QgcHJpbnQgOiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzZXRJbnRlcnZhbCA6ICh1bml0IC0+IHVuaXQpIEpzLmNhbGxiYWNrIC0+IGZsb2F0IC0+IGludGVydmFsX2lkIG1ldGhcblxuICAgIG1ldGhvZCBjbGVhckludGVydmFsIDogaW50ZXJ2YWxfaWQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0VGltZW91dCA6ICh1bml0IC0+IHVuaXQpIEpzLmNhbGxiYWNrIC0+IGZsb2F0IC0+IHRpbWVvdXRfaWQgbWV0aFxuXG4gICAgbWV0aG9kIGNsZWFyVGltZW91dCA6IHRpbWVvdXRfaWQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDpcbiAgICAgIChmbG9hdCAtPiB1bml0KSBKcy5jYWxsYmFjayAtPiBhbmltYXRpb25fZnJhbWVfcmVxdWVzdF9pZCBtZXRoXG5cbiAgICBtZXRob2QgY2FuY2VsQW5pbWF0aW9uRnJhbWUgOiBhbmltYXRpb25fZnJhbWVfcmVxdWVzdF9pZCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzY3JlZW4gOiBzY3JlZW4gdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgaW5uZXJXaWR0aCA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgaW5uZXJIZWlnaHQgOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG91dGVyV2lkdGggOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG91dGVySGVpZ2h0IDogaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBnZXRDb21wdXRlZFN0eWxlIDogI2VsZW1lbnQgdCAtPiBjc3NTdHlsZURlY2xhcmF0aW9uIHQgbWV0aFxuXG4gICAgbWV0aG9kIGdldENvbXB1dGVkU3R5bGVfcHNldWRvRWx0IDpcbiAgICAgICNlbGVtZW50IHQgLT4ganNfc3RyaW5nIHQgLT4gY3NzU3R5bGVEZWNsYXJhdGlvbiB0IG1ldGhcblxuICAgIG1ldGhvZCBhdG9iIDoganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIGJ0b2EgOiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICBtZXRob2Qgb25sb2FkIDogKHdpbmRvdyB0LCBldmVudCB0KSBldmVudF9saXN0ZW5lciBwcm9wXG5cbiAgICBtZXRob2Qgb251bmxvYWQgOiAod2luZG93IHQsIGV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHByb3BcblxuICAgIG1ldGhvZCBvbmJlZm9yZXVubG9hZCA6ICh3aW5kb3cgdCwgZXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgcHJvcFxuXG4gICAgbWV0aG9kIG9uYmx1ciA6ICh3aW5kb3cgdCwgZm9jdXNFdmVudCB0KSBldmVudF9saXN0ZW5lciBwcm9wXG5cbiAgICBtZXRob2Qgb25mb2N1cyA6ICh3aW5kb3cgdCwgZm9jdXNFdmVudCB0KSBldmVudF9saXN0ZW5lciBwcm9wXG5cbiAgICBtZXRob2Qgb25yZXNpemUgOiAod2luZG93IHQsIGV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHByb3BcblxuICAgIG1ldGhvZCBvbm9yaWVudGF0aW9uY2hhbmdlIDogKHdpbmRvdyB0LCBldmVudCB0KSBldmVudF9saXN0ZW5lciBwcm9wXG5cbiAgICBtZXRob2Qgb25wb3BzdGF0ZSA6ICh3aW5kb3cgdCwgcG9wU3RhdGVFdmVudCB0KSBldmVudF9saXN0ZW5lciBwcm9wXG5cbiAgICBtZXRob2Qgb25oYXNoY2hhbmdlIDogKHdpbmRvdyB0LCBoYXNoQ2hhbmdlRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgcHJvcFxuXG4gICAgbWV0aG9kIG9ub25saW5lIDogKHdpbmRvdyB0LCBldmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9ub2ZmbGluZSA6ICh3aW5kb3cgdCwgZXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVVJMIDogX1VSTCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBkZXZpY2VQaXhlbFJhdGlvIDogZmxvYXQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxubGV0IHdpbmRvdyA6IHdpbmRvdyB0ID0gSnMuVW5zYWZlLmdsb2JhbFxuXG4oKiBUaGUgdG9wbGV2ZWwgb2JqZWN0ICopXG5cbmxldCBkb2N1bWVudCA9IHdpbmRvdyMjLmRvY3VtZW50XG5cbmxldCBnZXRFbGVtZW50QnlJZCBpZCA9XG4gIEpzLk9wdC5jYXNlXG4gICAgKGRvY3VtZW50IyNnZXRFbGVtZW50QnlJZCAoSnMuc3RyaW5nIGlkKSlcbiAgICAoZnVuICgpIC0+IHJhaXNlIE5vdF9mb3VuZClcbiAgICAoZnVuIHBub2RlIC0+IHBub2RlKVxuXG5sZXQgZ2V0RWxlbWVudEJ5SWRfZXhuIGlkID1cbiAgSnMuT3B0LmNhc2VcbiAgICAoZG9jdW1lbnQjI2dldEVsZW1lbnRCeUlkIChKcy5zdHJpbmcgaWQpKVxuICAgIChmdW4gKCkgLT4gZmFpbHdpdGggKFByaW50Zi5zcHJpbnRmIFwiZ2V0RWxlbWVudEJ5SWRfZXhuOiAlUyBub3QgZm91bmRcIiBpZCkpXG4gICAgKGZ1biBwbm9kZSAtPiBwbm9kZSlcblxubGV0IGdldEVsZW1lbnRCeUlkX29wdCBpZCA9IEpzLk9wdC50b19vcHRpb24gKGRvY3VtZW50IyNnZXRFbGVtZW50QnlJZCAoSnMuc3RyaW5nIGlkKSlcblxubGV0IGdldEVsZW1lbnRCeUlkX2NvZXJjZSBpZCBjb2VyY2UgPVxuICBKcy5PcHQuY2FzZVxuICAgIChkb2N1bWVudCMjZ2V0RWxlbWVudEJ5SWQgKEpzLnN0cmluZyBpZCkpXG4gICAgKGZ1biAoKSAtPiBOb25lKVxuICAgIChmdW4gZSAtPiBKcy5PcHQudG9fb3B0aW9uIChjb2VyY2UgZSkpXG5cbigqKioqKVxuXG5jbGFzcyB0eXBlIGZyYW1lU2V0RWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgbWV0aG9kIGNvbHMgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2Qgcm93cyA6IGpzX3N0cmluZyB0IHByb3BcbiAgZW5kXG5cbmNsYXNzIHR5cGUgZnJhbWVFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBtZXRob2QgZnJhbWVCb3JkZXIgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgbG9uZ0Rlc2MgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgbWFyZ2luSGVpZ2h0IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIG1hcmdpbldpZHRoIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIG5hbWUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2Qgbm9SZXNpemUgOiBib29sIHQgcHJvcFxuXG4gICAgbWV0aG9kIHNjcm9sbGluZyA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBzcmMgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgY29udGVudERvY3VtZW50IDogZG9jdW1lbnQgdCBvcHQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSBpRnJhbWVFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBtZXRob2QgZnJhbWVCb3JkZXIgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgaGVpZ2h0IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHdpZHRoIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGxvbmdEZXNjIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIG1hcmdpbkhlaWdodCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBtYXJnaW5XaWR0aCA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBuYW1lIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHNjcm9sbGluZyA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBzcmMgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgY29udGVudERvY3VtZW50IDogZG9jdW1lbnQgdCBvcHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGNvbnRlbnRXaW5kb3cgOiB3aW5kb3cgdCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG4oKioqKilcblxuKCpYWFggU2hvdWxkIHByb3ZpZGUgY3JlYXRpb24gZnVuY3Rpb25zIGEgbGEgbGFibGd0ay4uLiAqKVxuXG5sZXQgb3B0X2l0ZXIgeCBmID1cbiAgbWF0Y2ggeCB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgdiAtPiBmIHZcblxubGV0IGNyZWF0ZUVsZW1lbnQgKGRvYyA6IGRvY3VtZW50IHQpIG5hbWUgPSBkb2MjI2NyZWF0ZUVsZW1lbnQgKEpzLnN0cmluZyBuYW1lKVxuXG5sZXQgdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgbmFtZSA9IEpzLlVuc2FmZS5jb2VyY2UgKGNyZWF0ZUVsZW1lbnQgZG9jIG5hbWUpXG5cbmxldCBjcmVhdGVFbGVtZW50U3ludGF4ID0gcmVmIGBVbmtub3duXG5cbmxldCByZWMgdW5zYWZlQ3JlYXRlRWxlbWVudEV4ID9fdHlwZSA/bmFtZSBkb2MgZWx0ID1cbiAgaWYgUG9seS4oX3R5cGUgPSBOb25lKSAmJiBQb2x5LihuYW1lID0gTm9uZSlcbiAgdGhlbiBKcy5VbnNhZmUuY29lcmNlIChjcmVhdGVFbGVtZW50IGRvYyBlbHQpXG4gIGVsc2VcbiAgICBtYXRjaCAhY3JlYXRlRWxlbWVudFN5bnRheCB3aXRoXG4gICAgfCBgU3RhbmRhcmQgLT5cbiAgICAgICAgbGV0IHJlcyA9IEpzLlVuc2FmZS5jb2VyY2UgKGNyZWF0ZUVsZW1lbnQgZG9jIGVsdCkgaW5cbiAgICAgICAgb3B0X2l0ZXIgX3R5cGUgKGZ1biB0IC0+IHJlcyMjLl90eXBlIDo9IHQpO1xuICAgICAgICBvcHRfaXRlciBuYW1lIChmdW4gbiAtPiByZXMjIy5uYW1lIDo9IG4pO1xuICAgICAgICByZXNcbiAgICB8IGBFeHRlbmRlZCAtPlxuICAgICAgICBsZXQgYSA9IG5ldyVqcyBKcy5hcnJheV9lbXB0eSBpblxuICAgICAgICBpZ25vcmUgKGEjI3B1c2hfMiAoSnMuc3RyaW5nIFwiPFwiKSAoSnMuc3RyaW5nIGVsdCkpO1xuICAgICAgICBvcHRfaXRlciBfdHlwZSAoZnVuIHQgLT5cbiAgICAgICAgICAgIGlnbm9yZSAoYSMjcHVzaF8zIChKcy5zdHJpbmcgXCIgdHlwZT1cXFwiXCIpIChodG1sX2VzY2FwZSB0KSAoSnMuc3RyaW5nIFwiXFxcIlwiKSkpO1xuICAgICAgICBvcHRfaXRlciBuYW1lIChmdW4gbiAtPlxuICAgICAgICAgICAgaWdub3JlIChhIyNwdXNoXzMgKEpzLnN0cmluZyBcIiBuYW1lPVxcXCJcIikgKGh0bWxfZXNjYXBlIG4pIChKcy5zdHJpbmcgXCJcXFwiXCIpKSk7XG4gICAgICAgIGlnbm9yZSAoYSMjcHVzaCAoSnMuc3RyaW5nIFwiPlwiKSk7XG4gICAgICAgIEpzLlVuc2FmZS5jb2VyY2UgKGRvYyMjY3JlYXRlRWxlbWVudCAoYSMjam9pbiAoSnMuc3RyaW5nIFwiXCIpKSlcbiAgICB8IGBVbmtub3duIC0+XG4gICAgICAgIGNyZWF0ZUVsZW1lbnRTeW50YXggOj1cbiAgICAgICAgICBpZiB0cnlcbiAgICAgICAgICAgICAgIGxldCBlbCA6IGlucHV0RWxlbWVudCBKcy50ID1cbiAgICAgICAgICAgICAgICAgSnMuVW5zYWZlLmNvZXJjZVxuICAgICAgICAgICAgICAgICAgIChkb2N1bWVudCMjY3JlYXRlRWxlbWVudCAoSnMuc3RyaW5nIFwiPGlucHV0IG5hbWU9XFxcInhcXFwiPlwiKSlcbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICBlbCMjLnRhZ05hbWUjI3RvTG93ZXJDYXNlID09IEpzLnN0cmluZyBcImlucHV0XCJcbiAgICAgICAgICAgICAgICYmIGVsIyMubmFtZSA9PSBKcy5zdHJpbmcgXCJ4XCJcbiAgICAgICAgICAgICB3aXRoIF8gLT4gZmFsc2VcbiAgICAgICAgICB0aGVuIGBFeHRlbmRlZFxuICAgICAgICAgIGVsc2UgYFN0YW5kYXJkO1xuICAgICAgICB1bnNhZmVDcmVhdGVFbGVtZW50RXggP190eXBlID9uYW1lIGRvYyBlbHRcblxubGV0IGNyZWF0ZUh0bWwgZG9jIDogaHRtbEVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiaHRtbFwiXG5cbmxldCBjcmVhdGVIZWFkIGRvYyA6IGhlYWRFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImhlYWRcIlxuXG5sZXQgY3JlYXRlTGluayBkb2MgOiBsaW5rRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJsaW5rXCJcblxubGV0IGNyZWF0ZVRpdGxlIGRvYyA6IHRpdGxlRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJ0aXRsZVwiXG5cbmxldCBjcmVhdGVNZXRhIGRvYyA6IG1ldGFFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcIm1ldGFcIlxuXG5sZXQgY3JlYXRlQmFzZSBkb2MgOiBiYXNlRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJiYXNlXCJcblxubGV0IGNyZWF0ZVN0eWxlIGRvYyA6IHN0eWxlRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJzdHlsZVwiXG5cbmxldCBjcmVhdGVCb2R5IGRvYyA6IGJvZHlFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImJvZHlcIlxuXG5sZXQgY3JlYXRlRm9ybSBkb2MgOiBmb3JtRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJmb3JtXCJcblxubGV0IGNyZWF0ZU9wdGdyb3VwIGRvYyA6IG9wdEdyb3VwRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJvcHRncm91cFwiXG5cbmxldCBjcmVhdGVPcHRpb24gZG9jIDogb3B0aW9uRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJvcHRpb25cIlxuXG5sZXQgY3JlYXRlU2VsZWN0ID9fdHlwZSA/bmFtZSBkb2MgOiBzZWxlY3RFbGVtZW50IHQgPVxuICB1bnNhZmVDcmVhdGVFbGVtZW50RXggP190eXBlID9uYW1lIGRvYyBcInNlbGVjdFwiXG5cbmxldCBjcmVhdGVJbnB1dCA/X3R5cGUgP25hbWUgZG9jIDogaW5wdXRFbGVtZW50IHQgPVxuICB1bnNhZmVDcmVhdGVFbGVtZW50RXggP190eXBlID9uYW1lIGRvYyBcImlucHV0XCJcblxubGV0IGNyZWF0ZVRleHRhcmVhID9fdHlwZSA/bmFtZSBkb2MgOiB0ZXh0QXJlYUVsZW1lbnQgdCA9XG4gIHVuc2FmZUNyZWF0ZUVsZW1lbnRFeCA/X3R5cGUgP25hbWUgZG9jIFwidGV4dGFyZWFcIlxuXG5sZXQgY3JlYXRlQnV0dG9uID9fdHlwZSA/bmFtZSBkb2MgOiBidXR0b25FbGVtZW50IHQgPVxuICB1bnNhZmVDcmVhdGVFbGVtZW50RXggP190eXBlID9uYW1lIGRvYyBcImJ1dHRvblwiXG5cbmxldCBjcmVhdGVMYWJlbCBkb2MgOiBsYWJlbEVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwibGFiZWxcIlxuXG5sZXQgY3JlYXRlRmllbGRzZXQgZG9jIDogZmllbGRTZXRFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImZpZWxkc2V0XCJcblxubGV0IGNyZWF0ZUxlZ2VuZCBkb2MgOiBsZWdlbmRFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImxlZ2VuZFwiXG5cbmxldCBjcmVhdGVVbCBkb2MgOiB1TGlzdEVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwidWxcIlxuXG5sZXQgY3JlYXRlT2wgZG9jIDogb0xpc3RFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcIm9sXCJcblxubGV0IGNyZWF0ZURsIGRvYyA6IGRMaXN0RWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJkbFwiXG5cbmxldCBjcmVhdGVMaSBkb2MgOiBsaUVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwibGlcIlxuXG5sZXQgY3JlYXRlRGl2IGRvYyA6IGRpdkVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiZGl2XCJcblxubGV0IGNyZWF0ZUVtYmVkIGRvYyA6IGVtYmVkRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJlbWJlZFwiXG5cbmxldCBjcmVhdGVQIGRvYyA6IHBhcmFncmFwaEVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwicFwiXG5cbmxldCBjcmVhdGVIMSBkb2MgOiBoZWFkaW5nRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJoMVwiXG5cbmxldCBjcmVhdGVIMiBkb2MgOiBoZWFkaW5nRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJoMlwiXG5cbmxldCBjcmVhdGVIMyBkb2MgOiBoZWFkaW5nRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJoM1wiXG5cbmxldCBjcmVhdGVINCBkb2MgOiBoZWFkaW5nRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJoNFwiXG5cbmxldCBjcmVhdGVINSBkb2MgOiBoZWFkaW5nRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJoNVwiXG5cbmxldCBjcmVhdGVINiBkb2MgOiBoZWFkaW5nRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJoNlwiXG5cbmxldCBjcmVhdGVRIGRvYyA6IHF1b3RlRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJxXCJcblxubGV0IGNyZWF0ZUJsb2NrcXVvdGUgZG9jIDogcXVvdGVFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImJsb2NrcXVvdGVcIlxuXG5sZXQgY3JlYXRlUHJlIGRvYyA6IHByZUVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwicHJlXCJcblxubGV0IGNyZWF0ZUJyIGRvYyA6IGJyRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJiclwiXG5cbmxldCBjcmVhdGVIciBkb2MgOiBockVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiaHJcIlxuXG5sZXQgY3JlYXRlSW5zIGRvYyA6IG1vZEVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiaW5zXCJcblxubGV0IGNyZWF0ZURlbCBkb2MgOiBtb2RFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImRlbFwiXG5cbmxldCBjcmVhdGVBIGRvYyA6IGFuY2hvckVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiYVwiXG5cbmxldCBjcmVhdGVJbWcgZG9jIDogaW1hZ2VFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImltZ1wiXG5cbmxldCBjcmVhdGVPYmplY3QgZG9jIDogb2JqZWN0RWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJvYmplY3RcIlxuXG5sZXQgY3JlYXRlUGFyYW0gZG9jIDogcGFyYW1FbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcInBhcmFtXCJcblxubGV0IGNyZWF0ZU1hcCBkb2MgOiBtYXBFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcIm1hcFwiXG5cbmxldCBjcmVhdGVBcmVhIGRvYyA6IGFyZWFFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImFyZWFcIlxuXG5sZXQgY3JlYXRlU2NyaXB0IGRvYyA6IHNjcmlwdEVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwic2NyaXB0XCJcblxubGV0IGNyZWF0ZVRhYmxlIGRvYyA6IHRhYmxlRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJ0YWJsZVwiXG5cbmxldCBjcmVhdGVDYXB0aW9uIGRvYyA6IHRhYmxlQ2FwdGlvbkVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiY2FwdGlvblwiXG5cbmxldCBjcmVhdGVDb2wgZG9jIDogdGFibGVDb2xFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImNvbFwiXG5cbmxldCBjcmVhdGVDb2xncm91cCBkb2MgOiB0YWJsZUNvbEVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiY29sZ3JvdXBcIlxuXG5sZXQgY3JlYXRlVGhlYWQgZG9jIDogdGFibGVTZWN0aW9uRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJ0aGVhZFwiXG5cbmxldCBjcmVhdGVUZm9vdCBkb2MgOiB0YWJsZVNlY3Rpb25FbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcInRmb290XCJcblxubGV0IGNyZWF0ZVRib2R5IGRvYyA6IHRhYmxlU2VjdGlvbkVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwidGJvZHlcIlxuXG5sZXQgY3JlYXRlVHIgZG9jIDogdGFibGVSb3dFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcInRyXCJcblxubGV0IGNyZWF0ZVRoIGRvYyA6IHRhYmxlQ2VsbEVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwidGhcIlxuXG5sZXQgY3JlYXRlVGQgZG9jIDogdGFibGVDZWxsRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJ0ZFwiXG5cbmxldCBjcmVhdGVTdWIgZG9jID0gY3JlYXRlRWxlbWVudCBkb2MgXCJzdWJcIlxuXG5sZXQgY3JlYXRlU3VwIGRvYyA9IGNyZWF0ZUVsZW1lbnQgZG9jIFwic3VwXCJcblxubGV0IGNyZWF0ZVNwYW4gZG9jID0gY3JlYXRlRWxlbWVudCBkb2MgXCJzcGFuXCJcblxubGV0IGNyZWF0ZVR0IGRvYyA9IGNyZWF0ZUVsZW1lbnQgZG9jIFwidHRcIlxuXG5sZXQgY3JlYXRlSSBkb2MgPSBjcmVhdGVFbGVtZW50IGRvYyBcImlcIlxuXG5sZXQgY3JlYXRlQiBkb2MgPSBjcmVhdGVFbGVtZW50IGRvYyBcImJcIlxuXG5sZXQgY3JlYXRlQmlnIGRvYyA9IGNyZWF0ZUVsZW1lbnQgZG9jIFwiYmlnXCJcblxubGV0IGNyZWF0ZVNtYWxsIGRvYyA9IGNyZWF0ZUVsZW1lbnQgZG9jIFwic21hbGxcIlxuXG5sZXQgY3JlYXRlRW0gZG9jID0gY3JlYXRlRWxlbWVudCBkb2MgXCJlbVwiXG5cbmxldCBjcmVhdGVTdHJvbmcgZG9jID0gY3JlYXRlRWxlbWVudCBkb2MgXCJzdHJvbmdcIlxuXG5sZXQgY3JlYXRlQ2l0ZSBkb2MgPSBjcmVhdGVFbGVtZW50IGRvYyBcImNpdGVcIlxuXG5sZXQgY3JlYXRlRGZuIGRvYyA9IGNyZWF0ZUVsZW1lbnQgZG9jIFwiZGZuXCJcblxubGV0IGNyZWF0ZUNvZGUgZG9jID0gY3JlYXRlRWxlbWVudCBkb2MgXCJjb2RlXCJcblxubGV0IGNyZWF0ZVNhbXAgZG9jID0gY3JlYXRlRWxlbWVudCBkb2MgXCJzYW1wXCJcblxubGV0IGNyZWF0ZUtiZCBkb2MgPSBjcmVhdGVFbGVtZW50IGRvYyBcImtiZFwiXG5cbmxldCBjcmVhdGVWYXIgZG9jID0gY3JlYXRlRWxlbWVudCBkb2MgXCJ2YXJcIlxuXG5sZXQgY3JlYXRlQWJiciBkb2MgPSBjcmVhdGVFbGVtZW50IGRvYyBcImFiYnJcIlxuXG5sZXQgY3JlYXRlRGQgZG9jID0gY3JlYXRlRWxlbWVudCBkb2MgXCJkZFwiXG5cbmxldCBjcmVhdGVEdCBkb2MgPSBjcmVhdGVFbGVtZW50IGRvYyBcImR0XCJcblxubGV0IGNyZWF0ZU5vc2NyaXB0IGRvYyA9IGNyZWF0ZUVsZW1lbnQgZG9jIFwibm9zY3JpcHRcIlxuXG5sZXQgY3JlYXRlQWRkcmVzcyBkb2MgPSBjcmVhdGVFbGVtZW50IGRvYyBcImFkZHJlc3NcIlxuXG5sZXQgY3JlYXRlRnJhbWVzZXQgZG9jIDogZnJhbWVTZXRFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImZyYW1lc2V0XCJcblxubGV0IGNyZWF0ZUZyYW1lIGRvYyA6IGZyYW1lRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJmcmFtZVwiXG5cbmxldCBjcmVhdGVJZnJhbWUgZG9jIDogaUZyYW1lRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJpZnJhbWVcIlxuXG5sZXQgY3JlYXRlQXVkaW8gZG9jIDogYXVkaW9FbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImF1ZGlvXCJcblxubGV0IGNyZWF0ZVZpZGVvIGRvYyA6IGF1ZGlvRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJ2aWRlb1wiXG5cbmV4Y2VwdGlvbiBDYW52YXNfbm90X2F2YWlsYWJsZVxuXG5sZXQgY3JlYXRlQ2FudmFzIGRvYyA6IGNhbnZhc0VsZW1lbnQgdCA9XG4gIGxldCBjID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJjYW52YXNcIiBpblxuICBpZiBub3QgKE9wdC50ZXN0IGMjIy5nZXRDb250ZXh0KSB0aGVuIHJhaXNlIENhbnZhc19ub3RfYXZhaWxhYmxlO1xuICBjXG5cbmxldCBodG1sX2VsZW1lbnQgOiBodG1sRWxlbWVudCB0IGNvbnN0ciA9IEpzLlVuc2FmZS5nbG9iYWwjIy5fSFRNTEVsZW1lbnRcblxubW9kdWxlIENvZXJjZVRvID0gc3RydWN0XG4gIGxldCBlbGVtZW50IDogI0RvbS5ub2RlIEpzLnQgLT4gZWxlbWVudCBKcy50IEpzLm9wdCA9XG4gICAgaWYgZGVmIGh0bWxfZWxlbWVudCA9PSB1bmRlZmluZWRcbiAgICB0aGVuXG4gICAgICAoKiBpZSA8IDkgZG9lcyBub3QgaGF2ZSBIVE1MRWxlbWVudDogd2UgaGF2ZSB0byBjaGVhdCB0byBjaGVja1xuICAgICAgICAgdGhhdCBzb21ldGhpbmcgaXMgYW4gaHRtbCBlbGVtZW50ICopXG4gICAgICBmdW4gZSAtPlxuICAgICAgaWYgZGVmIChKcy5VbnNhZmUuY29lcmNlIGUpIyMuaW5uZXJIVE1MID09IHVuZGVmaW5lZFxuICAgICAgdGhlbiBKcy5udWxsXG4gICAgICBlbHNlIEpzLnNvbWUgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICBlbHNlXG4gICAgICBmdW4gZSAtPlxuICAgICAgaWYgSnMuaW5zdGFuY2VvZiBlIGh0bWxfZWxlbWVudCB0aGVuIEpzLnNvbWUgKEpzLlVuc2FmZS5jb2VyY2UgZSkgZWxzZSBKcy5udWxsXG5cbiAgbGV0IHVuc2FmZUNvZXJjZSB0YWcgKGUgOiAjZWxlbWVudCB0KSA9XG4gICAgaWYgZSMjLnRhZ05hbWUjI3RvTG93ZXJDYXNlID09IEpzLnN0cmluZyB0YWdcbiAgICB0aGVuIEpzLnNvbWUgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICBlbHNlIEpzLm51bGxcblxuICBsZXQgYSBlID0gdW5zYWZlQ29lcmNlIFwiYVwiIGVcblxuICBsZXQgYXJlYSBlID0gdW5zYWZlQ29lcmNlIFwiYXJlYVwiIGVcblxuICBsZXQgYmFzZSBlID0gdW5zYWZlQ29lcmNlIFwiYmFzZVwiIGVcblxuICBsZXQgYmxvY2txdW90ZSBlID0gdW5zYWZlQ29lcmNlIFwiYmxvY2txdW90ZVwiIGVcblxuICBsZXQgYm9keSBlID0gdW5zYWZlQ29lcmNlIFwiYm9keVwiIGVcblxuICBsZXQgYnIgZSA9IHVuc2FmZUNvZXJjZSBcImJyXCIgZVxuXG4gIGxldCBidXR0b24gZSA9IHVuc2FmZUNvZXJjZSBcImJ1dHRvblwiIGVcblxuICBsZXQgY2FudmFzIGUgPSB1bnNhZmVDb2VyY2UgXCJjYW52YXNcIiBlXG5cbiAgbGV0IGNhcHRpb24gZSA9IHVuc2FmZUNvZXJjZSBcImNhcHRpb25cIiBlXG5cbiAgbGV0IGNvbCBlID0gdW5zYWZlQ29lcmNlIFwiY29sXCIgZVxuXG4gIGxldCBjb2xncm91cCBlID0gdW5zYWZlQ29lcmNlIFwiY29sZ3JvdXBcIiBlXG5cbiAgbGV0IGRlbCBlID0gdW5zYWZlQ29lcmNlIFwiZGVsXCIgZVxuXG4gIGxldCBkaXYgZSA9IHVuc2FmZUNvZXJjZSBcImRpdlwiIGVcblxuICBsZXQgZGwgZSA9IHVuc2FmZUNvZXJjZSBcImRsXCIgZVxuXG4gIGxldCBmaWVsZHNldCBlID0gdW5zYWZlQ29lcmNlIFwiZmllbGRzZXRcIiBlXG5cbiAgbGV0IGVtYmVkIGUgPSB1bnNhZmVDb2VyY2UgXCJlbWJlZFwiIGVcblxuICBsZXQgZm9ybSBlID0gdW5zYWZlQ29lcmNlIFwiZm9ybVwiIGVcblxuICBsZXQgZnJhbWVzZXQgZSA9IHVuc2FmZUNvZXJjZSBcImZyYW1lc2V0XCIgZVxuXG4gIGxldCBmcmFtZSBlID0gdW5zYWZlQ29lcmNlIFwiZnJhbWVcIiBlXG5cbiAgbGV0IGgxIGUgPSB1bnNhZmVDb2VyY2UgXCJoMVwiIGVcblxuICBsZXQgaDIgZSA9IHVuc2FmZUNvZXJjZSBcImgyXCIgZVxuXG4gIGxldCBoMyBlID0gdW5zYWZlQ29lcmNlIFwiaDNcIiBlXG5cbiAgbGV0IGg0IGUgPSB1bnNhZmVDb2VyY2UgXCJoNFwiIGVcblxuICBsZXQgaDUgZSA9IHVuc2FmZUNvZXJjZSBcImg1XCIgZVxuXG4gIGxldCBoNiBlID0gdW5zYWZlQ29lcmNlIFwiaDZcIiBlXG5cbiAgbGV0IGhlYWQgZSA9IHVuc2FmZUNvZXJjZSBcImhlYWRcIiBlXG5cbiAgbGV0IGhyIGUgPSB1bnNhZmVDb2VyY2UgXCJoclwiIGVcblxuICBsZXQgaHRtbCBlID0gdW5zYWZlQ29lcmNlIFwiaHRtbFwiIGVcblxuICBsZXQgaWZyYW1lIGUgPSB1bnNhZmVDb2VyY2UgXCJpZnJhbWVcIiBlXG5cbiAgbGV0IGltZyBlID0gdW5zYWZlQ29lcmNlIFwiaW1nXCIgZVxuXG4gIGxldCBpbnB1dCBlID0gdW5zYWZlQ29lcmNlIFwiaW5wdXRcIiBlXG5cbiAgbGV0IGlucyBlID0gdW5zYWZlQ29lcmNlIFwiaW5zXCIgZVxuXG4gIGxldCBsYWJlbCBlID0gdW5zYWZlQ29lcmNlIFwibGFiZWxcIiBlXG5cbiAgbGV0IGxlZ2VuZCBlID0gdW5zYWZlQ29lcmNlIFwibGVnZW5kXCIgZVxuXG4gIGxldCBsaSBlID0gdW5zYWZlQ29lcmNlIFwibGlcIiBlXG5cbiAgbGV0IGxpbmsgZSA9IHVuc2FmZUNvZXJjZSBcImxpbmtcIiBlXG5cbiAgbGV0IG1hcCBlID0gdW5zYWZlQ29lcmNlIFwibWFwXCIgZVxuXG4gIGxldCBtZXRhIGUgPSB1bnNhZmVDb2VyY2UgXCJtZXRhXCIgZVxuXG4gIGxldCBfb2JqZWN0IGUgPSB1bnNhZmVDb2VyY2UgXCJvYmplY3RcIiBlXG5cbiAgbGV0IG9sIGUgPSB1bnNhZmVDb2VyY2UgXCJvbFwiIGVcblxuICBsZXQgb3B0Z3JvdXAgZSA9IHVuc2FmZUNvZXJjZSBcIm9wdGdyb3VwXCIgZVxuXG4gIGxldCBvcHRpb24gZSA9IHVuc2FmZUNvZXJjZSBcIm9wdGlvblwiIGVcblxuICBsZXQgcCBlID0gdW5zYWZlQ29lcmNlIFwicFwiIGVcblxuICBsZXQgcGFyYW0gZSA9IHVuc2FmZUNvZXJjZSBcInBhcmFtXCIgZVxuXG4gIGxldCBwcmUgZSA9IHVuc2FmZUNvZXJjZSBcInByZVwiIGVcblxuICBsZXQgcSBlID0gdW5zYWZlQ29lcmNlIFwicVwiIGVcblxuICBsZXQgc2NyaXB0IGUgPSB1bnNhZmVDb2VyY2UgXCJzY3JpcHRcIiBlXG5cbiAgbGV0IHNlbGVjdCBlID0gdW5zYWZlQ29lcmNlIFwic2VsZWN0XCIgZVxuXG4gIGxldCBzdHlsZSBlID0gdW5zYWZlQ29lcmNlIFwic3R5bGVcIiBlXG5cbiAgbGV0IHRhYmxlIGUgPSB1bnNhZmVDb2VyY2UgXCJ0YWJsZVwiIGVcblxuICBsZXQgdGJvZHkgZSA9IHVuc2FmZUNvZXJjZSBcInRib2R5XCIgZVxuXG4gIGxldCB0ZCBlID0gdW5zYWZlQ29lcmNlIFwidGRcIiBlXG5cbiAgbGV0IHRleHRhcmVhIGUgPSB1bnNhZmVDb2VyY2UgXCJ0ZXh0YXJlYVwiIGVcblxuICBsZXQgdGZvb3QgZSA9IHVuc2FmZUNvZXJjZSBcInRmb290XCIgZVxuXG4gIGxldCB0aCBlID0gdW5zYWZlQ29lcmNlIFwidGhcIiBlXG5cbiAgbGV0IHRoZWFkIGUgPSB1bnNhZmVDb2VyY2UgXCJ0aGVhZFwiIGVcblxuICBsZXQgdGl0bGUgZSA9IHVuc2FmZUNvZXJjZSBcInRpdGxlXCIgZVxuXG4gIGxldCB0ciBlID0gdW5zYWZlQ29lcmNlIFwidHJcIiBlXG5cbiAgbGV0IHVsIGUgPSB1bnNhZmVDb2VyY2UgXCJ1bFwiIGVcblxuICBsZXQgYXVkaW8gZSA9IHVuc2FmZUNvZXJjZSBcImF1ZGlvXCIgZVxuXG4gIGxldCB2aWRlbyBlID0gdW5zYWZlQ29lcmNlIFwidmlkZW9cIiBlXG5cbiAgbGV0IHVuc2FmZUNvZXJjZUV2ZW50IGNvbnN0ciAoZXYgOiAjZXZlbnQgdCkgPVxuICAgIGlmIGRlZiBjb25zdHIgIT0gdW5kZWZpbmVkICYmIEpzLmluc3RhbmNlb2YgZXYgY29uc3RyXG4gICAgdGhlbiBKcy5zb21lIChKcy5VbnNhZmUuY29lcmNlIGV2KVxuICAgIGVsc2UgSnMubnVsbFxuXG4gIGxldCBtb3VzZUV2ZW50IGV2ID0gdW5zYWZlQ29lcmNlRXZlbnQgSnMuVW5zYWZlLmdsb2JhbCMjLl9Nb3VzZUV2ZW50IGV2XG5cbiAgbGV0IGtleWJvYXJkRXZlbnQgZXYgPSB1bnNhZmVDb2VyY2VFdmVudCBKcy5VbnNhZmUuZ2xvYmFsIyMuX0tleWJvYXJkRXZlbnQgZXZcblxuICBsZXQgd2hlZWxFdmVudCBldiA9IHVuc2FmZUNvZXJjZUV2ZW50IEpzLlVuc2FmZS5nbG9iYWwjIy5fV2hlZWxFdmVudCBldlxuXG4gIGxldCBtb3VzZVNjcm9sbEV2ZW50IGV2ID0gdW5zYWZlQ29lcmNlRXZlbnQgSnMuVW5zYWZlLmdsb2JhbCMjLl9Nb3VzZVNjcm9sbEV2ZW50IGV2XG5cbiAgbGV0IHBvcFN0YXRlRXZlbnQgZXYgPSB1bnNhZmVDb2VyY2VFdmVudCBKcy5VbnNhZmUuZ2xvYmFsIyMuX1BvcFN0YXRlRXZlbnQgZXZcblxuICBsZXQgbWVzc2FnZUV2ZW50IGV2ID0gdW5zYWZlQ29lcmNlRXZlbnQgSnMuVW5zYWZlLmdsb2JhbCMjLl9NZXNzYWdlRXZlbnQgZXZcbmVuZFxuXG4oKioqKilcblxubGV0IGV2ZW50VGFyZ2V0ID0gRG9tLmV2ZW50VGFyZ2V0XG5cbmxldCBldmVudFJlbGF0ZWRUYXJnZXQgKGUgOiAjbW91c2VFdmVudCB0KSA9XG4gIE9wdGRlZi5nZXQgZSMjLnJlbGF0ZWRUYXJnZXQgKGZ1biAoKSAtPlxuICAgICAgbWF0Y2ggSnMudG9fc3RyaW5nIGUjIy5fdHlwZSB3aXRoXG4gICAgICB8IFwibW91c2VvdmVyXCIgLT4gT3B0ZGVmLmdldCBlIyMuZnJvbUVsZW1lbnQgKGZ1biAoKSAtPiBhc3NlcnQgZmFsc2UpXG4gICAgICB8IFwibW91c2VvdXRcIiAtPiBPcHRkZWYuZ2V0IGUjIy50b0VsZW1lbnQgKGZ1biAoKSAtPiBhc3NlcnQgZmFsc2UpXG4gICAgICB8IF8gLT4gSnMubnVsbClcblxubGV0IGV2ZW50QWJzb2x1dGVQb3NpdGlvbicgKGUgOiAjbW91c2VFdmVudCB0KSA9XG4gIGxldCBib2R5ID0gZG9jdW1lbnQjIy5ib2R5IGluXG4gIGxldCBodG1sID0gZG9jdW1lbnQjIy5kb2N1bWVudEVsZW1lbnQgaW5cbiAgKCBlIyMuY2xpZW50WCArIGJvZHkjIy5zY3JvbGxMZWZ0ICsgaHRtbCMjLnNjcm9sbExlZnRcbiAgLCBlIyMuY2xpZW50WSArIGJvZHkjIy5zY3JvbGxUb3AgKyBodG1sIyMuc2Nyb2xsVG9wIClcblxubGV0IGV2ZW50QWJzb2x1dGVQb3NpdGlvbiAoZSA6ICNtb3VzZUV2ZW50IHQpID1cbiAgT3B0ZGVmLmNhc2VcbiAgICBlIyMucGFnZVhcbiAgICAoZnVuICgpIC0+IGV2ZW50QWJzb2x1dGVQb3NpdGlvbicgZSlcbiAgICAoZnVuIHggLT4gT3B0ZGVmLmNhc2UgZSMjLnBhZ2VZIChmdW4gKCkgLT4gZXZlbnRBYnNvbHV0ZVBvc2l0aW9uJyBlKSAoZnVuIHkgLT4geCwgeSkpXG5cbmxldCBlbGVtZW50Q2xpZW50UG9zaXRpb24gKGUgOiAjZWxlbWVudCB0KSA9XG4gIGxldCByID0gZSMjZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGluXG4gIGxldCBib2R5ID0gZG9jdW1lbnQjIy5ib2R5IGluXG4gIGxldCBodG1sID0gZG9jdW1lbnQjIy5kb2N1bWVudEVsZW1lbnQgaW5cbiAgKCB0cnVuY2F0ZSByIyMubGVmdCAtIGJvZHkjIy5jbGllbnRMZWZ0IC0gaHRtbCMjLmNsaWVudExlZnRcbiAgLCB0cnVuY2F0ZSByIyMudG9wIC0gYm9keSMjLmNsaWVudFRvcCAtIGh0bWwjIy5jbGllbnRUb3AgKVxuXG5sZXQgZ2V0RG9jdW1lbnRTY3JvbGwgKCkgPVxuICBsZXQgYm9keSA9IGRvY3VtZW50IyMuYm9keSBpblxuICBsZXQgaHRtbCA9IGRvY3VtZW50IyMuZG9jdW1lbnRFbGVtZW50IGluXG4gIGJvZHkjIy5zY3JvbGxMZWZ0ICsgaHRtbCMjLnNjcm9sbExlZnQsIGJvZHkjIy5zY3JvbGxUb3AgKyBodG1sIyMuc2Nyb2xsVG9wXG5cbmxldCBidXR0b25QcmVzc2VkIChldiA6ICNtb3VzZUV2ZW50IEpzLnQpID1cbiAgSnMuT3B0ZGVmLmNhc2VcbiAgICBldiMjLndoaWNoXG4gICAgKGZ1biAoKSAtPlxuICAgICAgbWF0Y2ggZXYjIy5idXR0b24gd2l0aFxuICAgICAgfCAxIC0+IExlZnRfYnV0dG9uXG4gICAgICB8IDIgLT4gUmlnaHRfYnV0dG9uXG4gICAgICB8IDQgLT4gTWlkZGxlX2J1dHRvblxuICAgICAgfCBfIC0+IE5vX2J1dHRvbilcbiAgICAoZnVuIHggLT4geClcblxubGV0IGFkZE1vdXNld2hlZWxFdmVudExpc3RlbmVyV2l0aE9wdGlvbnMgZSA/Y2FwdHVyZSA/b25jZSA/cGFzc2l2ZSBoID1cbiAgYWRkRXZlbnRMaXN0ZW5lcldpdGhPcHRpb25zXG4gICAgP2NhcHR1cmVcbiAgICA/b25jZVxuICAgID9wYXNzaXZlXG4gICAgZVxuICAgIEV2ZW50LndoZWVsXG4gICAgKGhhbmRsZXIgKGZ1biAoZSA6IG1vdXNld2hlZWxFdmVudCB0KSAtPlxuICAgICAgICAgbGV0IGR4ID0gLU9wdGRlZi5nZXQgZSMjLndoZWVsRGVsdGFYIChmdW4gKCkgLT4gMCkgLyA0MCBpblxuICAgICAgICAgbGV0IGR5ID0gLU9wdGRlZi5nZXQgZSMjLndoZWVsRGVsdGFZIChmdW4gKCkgLT4gZSMjLndoZWVsRGVsdGEpIC8gNDAgaW5cbiAgICAgICAgIGggKGUgOj4gbW91c2VFdmVudCB0KSB+ZHggfmR5KSlcblxubGV0IGFkZE1vdXNld2hlZWxFdmVudExpc3RlbmVyIGUgaCBjYXB0ID1cbiAgYWRkTW91c2V3aGVlbEV2ZW50TGlzdGVuZXJXaXRoT3B0aW9ucyB+Y2FwdHVyZTpjYXB0IGUgaFxuXG4oKioqKiopXG5cbm1vZHVsZSBLZXlib2FyZF9jb2RlID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBVbmlkZW50aWZpZWRcbiAgICAoKiBBbHBoYWJldGljIENoYXJhY3RlcnMgKilcbiAgICB8IEtleUFcbiAgICB8IEtleUJcbiAgICB8IEtleUNcbiAgICB8IEtleURcbiAgICB8IEtleUVcbiAgICB8IEtleUZcbiAgICB8IEtleUdcbiAgICB8IEtleUhcbiAgICB8IEtleUlcbiAgICB8IEtleUpcbiAgICB8IEtleUtcbiAgICB8IEtleUxcbiAgICB8IEtleU1cbiAgICB8IEtleU5cbiAgICB8IEtleU9cbiAgICB8IEtleVBcbiAgICB8IEtleVFcbiAgICB8IEtleVJcbiAgICB8IEtleVNcbiAgICB8IEtleVRcbiAgICB8IEtleVVcbiAgICB8IEtleVZcbiAgICB8IEtleVdcbiAgICB8IEtleVhcbiAgICB8IEtleVlcbiAgICB8IEtleVpcbiAgICAoKiBEaWdpdHMgKilcbiAgICB8IERpZ2l0MFxuICAgIHwgRGlnaXQxXG4gICAgfCBEaWdpdDJcbiAgICB8IERpZ2l0M1xuICAgIHwgRGlnaXQ0XG4gICAgfCBEaWdpdDVcbiAgICB8IERpZ2l0NlxuICAgIHwgRGlnaXQ3XG4gICAgfCBEaWdpdDhcbiAgICB8IERpZ2l0OVxuICAgIHwgTWludXNcbiAgICB8IEVxdWFsXG4gICAgKCogV2hpdGVzcGFjZSAqKVxuICAgIHwgVGFiXG4gICAgfCBFbnRlclxuICAgIHwgU3BhY2VcbiAgICAoKiBFZGl0aW5nICopXG4gICAgfCBFc2NhcGVcbiAgICB8IEJhY2tzcGFjZVxuICAgIHwgSW5zZXJ0XG4gICAgfCBEZWxldGVcbiAgICB8IENhcHNMb2NrXG4gICAgKCogTWlzYyBQcmludGFibGUgKilcbiAgICB8IEJyYWNrZXRMZWZ0XG4gICAgfCBCcmFja2V0UmlnaHRcbiAgICB8IFNlbWljb2xvblxuICAgIHwgUXVvdGVcbiAgICB8IEJhY2txdW90ZVxuICAgIHwgQmFja3NsYXNoXG4gICAgfCBDb21tYVxuICAgIHwgUGVyaW9kXG4gICAgfCBTbGFzaFxuICAgICgqIEZ1bmN0aW9uIGtleXMgKilcbiAgICB8IEYxXG4gICAgfCBGMlxuICAgIHwgRjNcbiAgICB8IEY0XG4gICAgfCBGNVxuICAgIHwgRjZcbiAgICB8IEY3XG4gICAgfCBGOFxuICAgIHwgRjlcbiAgICB8IEYxMFxuICAgIHwgRjExXG4gICAgfCBGMTJcbiAgICAoKiBOdW1wYWQga2V5cyAqKVxuICAgIHwgTnVtcGFkMFxuICAgIHwgTnVtcGFkMVxuICAgIHwgTnVtcGFkMlxuICAgIHwgTnVtcGFkM1xuICAgIHwgTnVtcGFkNFxuICAgIHwgTnVtcGFkNVxuICAgIHwgTnVtcGFkNlxuICAgIHwgTnVtcGFkN1xuICAgIHwgTnVtcGFkOFxuICAgIHwgTnVtcGFkOVxuICAgIHwgTnVtcGFkTXVsdGlwbHlcbiAgICB8IE51bXBhZFN1YnRyYWN0XG4gICAgfCBOdW1wYWRBZGRcbiAgICB8IE51bXBhZERlY2ltYWxcbiAgICB8IE51bXBhZEVxdWFsXG4gICAgfCBOdW1wYWRFbnRlclxuICAgIHwgTnVtcGFkRGl2aWRlXG4gICAgfCBOdW1Mb2NrXG4gICAgKCogTW9kaWZpZXIga2V5cyAqKVxuICAgIHwgQ29udHJvbExlZnRcbiAgICB8IENvbnRyb2xSaWdodFxuICAgIHwgTWV0YUxlZnRcbiAgICB8IE1ldGFSaWdodFxuICAgIHwgU2hpZnRMZWZ0XG4gICAgfCBTaGlmdFJpZ2h0XG4gICAgfCBBbHRMZWZ0XG4gICAgfCBBbHRSaWdodFxuICAgICgqIEFycm93IGtleXMgKilcbiAgICB8IEFycm93TGVmdFxuICAgIHwgQXJyb3dSaWdodFxuICAgIHwgQXJyb3dVcFxuICAgIHwgQXJyb3dEb3duXG4gICAgKCogTmF2aWdhdGlvbiAqKVxuICAgIHwgUGFnZVVwXG4gICAgfCBQYWdlRG93blxuICAgIHwgSG9tZVxuICAgIHwgRW5kXG4gICAgKCogU291bmQgKilcbiAgICB8IFZvbHVtZU11dGVcbiAgICB8IFZvbHVtZURvd25cbiAgICB8IFZvbHVtZVVwXG4gICAgKCogTWVkaWEgKilcbiAgICB8IE1lZGlhVHJhY2tQcmV2aW91c1xuICAgIHwgTWVkaWFUcmFja05leHRcbiAgICB8IE1lZGlhUGxheVBhdXNlXG4gICAgfCBNZWRpYVN0b3BcbiAgICAoKiBCcm93c2VyIHNwZWNpYWwgKilcbiAgICB8IENvbnRleHRNZW51XG4gICAgfCBCcm93c2VyU2VhcmNoXG4gICAgfCBCcm93c2VySG9tZVxuICAgIHwgQnJvd3NlckZhdm9yaXRlc1xuICAgIHwgQnJvd3NlclJlZnJlc2hcbiAgICB8IEJyb3dzZXJTdG9wXG4gICAgfCBCcm93c2VyRm9yd2FyZFxuICAgIHwgQnJvd3NlckJhY2tcbiAgICAoKiBNaXNjICopXG4gICAgfCBPU0xlZnRcbiAgICB8IE9TUmlnaHRcbiAgICB8IFNjcm9sbExvY2tcbiAgICB8IFByaW50U2NyZWVuXG4gICAgfCBJbnRsQmFja3NsYXNoXG4gICAgfCBJbnRsWWVuXG4gICAgfCBQYXVzZVxuXG4gIGxldCB0cnlfY29kZSB2ID1cbiAgICBtYXRjaCBKcy50b19zdHJpbmcgdiB3aXRoXG4gICAgKCogQWxwaGFiZXRpYyBDaGFyYWN0ZXJzICopXG4gICAgfCBcIktleUFcIiAtPiBLZXlBXG4gICAgfCBcIktleUJcIiAtPiBLZXlCXG4gICAgfCBcIktleUNcIiAtPiBLZXlDXG4gICAgfCBcIktleURcIiAtPiBLZXlEXG4gICAgfCBcIktleUVcIiAtPiBLZXlFXG4gICAgfCBcIktleUZcIiAtPiBLZXlGXG4gICAgfCBcIktleUdcIiAtPiBLZXlHXG4gICAgfCBcIktleUhcIiAtPiBLZXlIXG4gICAgfCBcIktleUlcIiAtPiBLZXlJXG4gICAgfCBcIktleUpcIiAtPiBLZXlKXG4gICAgfCBcIktleUtcIiAtPiBLZXlLXG4gICAgfCBcIktleUxcIiAtPiBLZXlMXG4gICAgfCBcIktleU1cIiAtPiBLZXlNXG4gICAgfCBcIktleU5cIiAtPiBLZXlOXG4gICAgfCBcIktleU9cIiAtPiBLZXlPXG4gICAgfCBcIktleVBcIiAtPiBLZXlQXG4gICAgfCBcIktleVFcIiAtPiBLZXlRXG4gICAgfCBcIktleVJcIiAtPiBLZXlSXG4gICAgfCBcIktleVNcIiAtPiBLZXlTXG4gICAgfCBcIktleVRcIiAtPiBLZXlUXG4gICAgfCBcIktleVVcIiAtPiBLZXlVXG4gICAgfCBcIktleVZcIiAtPiBLZXlWXG4gICAgfCBcIktleVdcIiAtPiBLZXlXXG4gICAgfCBcIktleVhcIiAtPiBLZXlYXG4gICAgfCBcIktleVlcIiAtPiBLZXlZXG4gICAgfCBcIktleVpcIiAtPiBLZXlaXG4gICAgKCogRGlnaXRzICopXG4gICAgfCBcIkRpZ2l0MFwiIC0+IERpZ2l0MFxuICAgIHwgXCJEaWdpdDFcIiAtPiBEaWdpdDFcbiAgICB8IFwiRGlnaXQyXCIgLT4gRGlnaXQyXG4gICAgfCBcIkRpZ2l0M1wiIC0+IERpZ2l0M1xuICAgIHwgXCJEaWdpdDRcIiAtPiBEaWdpdDRcbiAgICB8IFwiRGlnaXQ1XCIgLT4gRGlnaXQ1XG4gICAgfCBcIkRpZ2l0NlwiIC0+IERpZ2l0NlxuICAgIHwgXCJEaWdpdDdcIiAtPiBEaWdpdDdcbiAgICB8IFwiRGlnaXQ4XCIgLT4gRGlnaXQ4XG4gICAgfCBcIkRpZ2l0OVwiIC0+IERpZ2l0OVxuICAgIHwgXCJNaW51c1wiIC0+IE1pbnVzXG4gICAgfCBcIkVxdWFsXCIgLT4gRXF1YWxcbiAgICAoKiBXaGl0ZXNwYWNlICopXG4gICAgfCBcIlRhYlwiIC0+IFRhYlxuICAgIHwgXCJFbnRlclwiIC0+IEVudGVyXG4gICAgfCBcIlNwYWNlXCIgLT4gU3BhY2VcbiAgICAoKiBFZGl0aW5nICopXG4gICAgfCBcIkVzY2FwZVwiIC0+IEVzY2FwZVxuICAgIHwgXCJCYWNrc3BhY2VcIiAtPiBCYWNrc3BhY2VcbiAgICB8IFwiSW5zZXJ0XCIgLT4gSW5zZXJ0XG4gICAgfCBcIkRlbGV0ZVwiIC0+IERlbGV0ZVxuICAgIHwgXCJDYXBzTG9ja1wiIC0+IENhcHNMb2NrXG4gICAgKCogTWlzYyBQcmludGFibGUgKilcbiAgICB8IFwiQnJhY2tldExlZnRcIiAtPiBCcmFja2V0TGVmdFxuICAgIHwgXCJCcmFja2V0UmlnaHRcIiAtPiBCcmFja2V0UmlnaHRcbiAgICB8IFwiU2VtaWNvbG9uXCIgLT4gU2VtaWNvbG9uXG4gICAgfCBcIlF1b3RlXCIgLT4gUXVvdGVcbiAgICB8IFwiQmFja3F1b3RlXCIgLT4gQmFja3F1b3RlXG4gICAgfCBcIkJhY2tzbGFzaFwiIC0+IEJhY2tzbGFzaFxuICAgIHwgXCJDb21tYVwiIC0+IENvbW1hXG4gICAgfCBcIlBlcmlvZFwiIC0+IFBlcmlvZFxuICAgIHwgXCJTbGFzaFwiIC0+IFNsYXNoXG4gICAgKCogRnVuY3Rpb24ga2V5cyAqKVxuICAgIHwgXCJGMVwiIC0+IEYxXG4gICAgfCBcIkYyXCIgLT4gRjJcbiAgICB8IFwiRjNcIiAtPiBGM1xuICAgIHwgXCJGNFwiIC0+IEY0XG4gICAgfCBcIkY1XCIgLT4gRjVcbiAgICB8IFwiRjZcIiAtPiBGNlxuICAgIHwgXCJGN1wiIC0+IEY3XG4gICAgfCBcIkY4XCIgLT4gRjhcbiAgICB8IFwiRjlcIiAtPiBGOVxuICAgIHwgXCJGMTBcIiAtPiBGMTBcbiAgICB8IFwiRjExXCIgLT4gRjExXG4gICAgfCBcIkYxMlwiIC0+IEYxMlxuICAgICgqIE51bXBhZCBrZXlzICopXG4gICAgfCBcIk51bXBhZDBcIiAtPiBOdW1wYWQwXG4gICAgfCBcIk51bXBhZDFcIiAtPiBOdW1wYWQxXG4gICAgfCBcIk51bXBhZDJcIiAtPiBOdW1wYWQyXG4gICAgfCBcIk51bXBhZDNcIiAtPiBOdW1wYWQzXG4gICAgfCBcIk51bXBhZDRcIiAtPiBOdW1wYWQ0XG4gICAgfCBcIk51bXBhZDVcIiAtPiBOdW1wYWQ1XG4gICAgfCBcIk51bXBhZDZcIiAtPiBOdW1wYWQ2XG4gICAgfCBcIk51bXBhZDdcIiAtPiBOdW1wYWQ3XG4gICAgfCBcIk51bXBhZDhcIiAtPiBOdW1wYWQ4XG4gICAgfCBcIk51bXBhZDlcIiAtPiBOdW1wYWQ5XG4gICAgfCBcIk51bXBhZE11bHRpcGx5XCIgLT4gTnVtcGFkTXVsdGlwbHlcbiAgICB8IFwiTnVtcGFkU3VidHJhY3RcIiAtPiBOdW1wYWRTdWJ0cmFjdFxuICAgIHwgXCJOdW1wYWRBZGRcIiAtPiBOdW1wYWRBZGRcbiAgICB8IFwiTnVtcGFkRGVjaW1hbFwiIC0+IE51bXBhZERlY2ltYWxcbiAgICB8IFwiTnVtcGFkRXF1YWxcIiAtPiBOdW1wYWRFcXVhbFxuICAgIHwgXCJOdW1wYWRFbnRlclwiIC0+IE51bXBhZEVudGVyXG4gICAgfCBcIk51bXBhZERpdmlkZVwiIC0+IE51bXBhZERpdmlkZVxuICAgIHwgXCJOdW1Mb2NrXCIgLT4gTnVtTG9ja1xuICAgICgqIE1vZGlmaWVyIGtleXMgKilcbiAgICB8IFwiQ29udHJvbExlZnRcIiAtPiBDb250cm9sTGVmdFxuICAgIHwgXCJDb250cm9sUmlnaHRcIiAtPiBDb250cm9sUmlnaHRcbiAgICB8IFwiTWV0YUxlZnRcIiAtPiBNZXRhTGVmdFxuICAgIHwgXCJNZXRhUmlnaHRcIiAtPiBNZXRhUmlnaHRcbiAgICB8IFwiU2hpZnRMZWZ0XCIgLT4gU2hpZnRMZWZ0XG4gICAgfCBcIlNoaWZ0UmlnaHRcIiAtPiBTaGlmdFJpZ2h0XG4gICAgfCBcIkFsdExlZnRcIiAtPiBBbHRMZWZ0XG4gICAgfCBcIkFsdFJpZ2h0XCIgLT4gQWx0UmlnaHRcbiAgICAoKiBBcnJvdyBrZXlzICopXG4gICAgfCBcIkFycm93TGVmdFwiIC0+IEFycm93TGVmdFxuICAgIHwgXCJBcnJvd1JpZ2h0XCIgLT4gQXJyb3dSaWdodFxuICAgIHwgXCJBcnJvd1VwXCIgLT4gQXJyb3dVcFxuICAgIHwgXCJBcnJvd0Rvd25cIiAtPiBBcnJvd0Rvd25cbiAgICAoKiBOYXZpZ2F0aW9uICopXG4gICAgfCBcIlBhZ2VVcFwiIC0+IFBhZ2VVcFxuICAgIHwgXCJQYWdlRG93blwiIC0+IFBhZ2VEb3duXG4gICAgfCBcIkhvbWVcIiAtPiBIb21lXG4gICAgfCBcIkVuZFwiIC0+IEVuZFxuICAgICgqIFNvdW5kICopXG4gICAgfCBcIlZvbHVtZU11dGVcIiAtPiBWb2x1bWVNdXRlXG4gICAgfCBcIlZvbHVtZURvd25cIiAtPiBWb2x1bWVEb3duXG4gICAgfCBcIlZvbHVtZVVwXCIgLT4gVm9sdW1lVXBcbiAgICAoKiBNZWRpYSAqKVxuICAgIHwgXCJNZWRpYVRyYWNrUHJldmlvdXNcIiAtPiBNZWRpYVRyYWNrUHJldmlvdXNcbiAgICB8IFwiTWVkaWFUcmFja05leHRcIiAtPiBNZWRpYVRyYWNrTmV4dFxuICAgIHwgXCJNZWRpYVBsYXlQYXVzZVwiIC0+IE1lZGlhUGxheVBhdXNlXG4gICAgfCBcIk1lZGlhU3RvcFwiIC0+IE1lZGlhU3RvcFxuICAgICgqIEJyb3dzZXIgc3BlY2lhbCAqKVxuICAgIHwgXCJDb250ZXh0TWVudVwiIC0+IENvbnRleHRNZW51XG4gICAgfCBcIkJyb3dzZXJTZWFyY2hcIiAtPiBCcm93c2VyU2VhcmNoXG4gICAgfCBcIkJyb3dzZXJIb21lXCIgLT4gQnJvd3NlckhvbWVcbiAgICB8IFwiQnJvd3NlckZhdm9yaXRlc1wiIC0+IEJyb3dzZXJGYXZvcml0ZXNcbiAgICB8IFwiQnJvd3NlclJlZnJlc2hcIiAtPiBCcm93c2VyUmVmcmVzaFxuICAgIHwgXCJCcm93c2VyU3RvcFwiIC0+IEJyb3dzZXJTdG9wXG4gICAgfCBcIkJyb3dzZXJGb3J3YXJkXCIgLT4gQnJvd3NlckZvcndhcmRcbiAgICB8IFwiQnJvd3NlckJhY2tcIiAtPiBCcm93c2VyQmFja1xuICAgICgqIE1pc2MgKilcbiAgICB8IFwiT1NMZWZ0XCIgLT4gT1NMZWZ0XG4gICAgfCBcIk9TUmlnaHRcIiAtPiBPU1JpZ2h0XG4gICAgfCBcIlNjcm9sbExvY2tcIiAtPiBTY3JvbGxMb2NrXG4gICAgfCBcIlByaW50U2NyZWVuXCIgLT4gUHJpbnRTY3JlZW5cbiAgICB8IFwiSW50bEJhY2tzbGFzaFwiIC0+IEludGxCYWNrc2xhc2hcbiAgICB8IFwiSW50bFllblwiIC0+IEludGxZZW5cbiAgICB8IFwiUGF1c2VcIiAtPiBQYXVzZVxuICAgIHwgXyAtPiBVbmlkZW50aWZpZWRcblxuICBsZXQgdHJ5X2tleV9jb2RlX2xlZnQgPSBmdW5jdGlvblxuICAgIHwgMTYgLT4gU2hpZnRMZWZ0XG4gICAgfCAxNyAtPiBDb250cm9sTGVmdFxuICAgIHwgMTggLT4gQWx0TGVmdFxuICAgIHwgOTEgLT4gTWV0YUxlZnRcbiAgICB8IF8gLT4gVW5pZGVudGlmaWVkXG5cbiAgbGV0IHRyeV9rZXlfY29kZV9yaWdodCA9IGZ1bmN0aW9uXG4gICAgfCAxNiAtPiBTaGlmdFJpZ2h0XG4gICAgfCAxNyAtPiBDb250cm9sUmlnaHRcbiAgICB8IDE4IC0+IEFsdFJpZ2h0XG4gICAgfCA5MSAtPiBNZXRhUmlnaHRcbiAgICB8IF8gLT4gVW5pZGVudGlmaWVkXG5cbiAgbGV0IHRyeV9rZXlfY29kZV9udW1wYWQgPSBmdW5jdGlvblxuICAgIHwgNDYgLT4gTnVtcGFkRGVjaW1hbFxuICAgIHwgNDUgLT4gTnVtcGFkMFxuICAgIHwgMzUgLT4gTnVtcGFkMVxuICAgIHwgNDAgLT4gTnVtcGFkMlxuICAgIHwgMzQgLT4gTnVtcGFkM1xuICAgIHwgMzcgLT4gTnVtcGFkNFxuICAgIHwgMTIgLT4gTnVtcGFkNVxuICAgIHwgMzkgLT4gTnVtcGFkNlxuICAgIHwgMzYgLT4gTnVtcGFkN1xuICAgIHwgMzggLT4gTnVtcGFkOFxuICAgIHwgMzMgLT4gTnVtcGFkOVxuICAgIHwgMTMgLT4gTnVtcGFkRW50ZXJcbiAgICB8IDExMSAtPiBOdW1wYWREaXZpZGVcbiAgICB8IDEwNyAtPiBOdW1wYWRBZGRcbiAgICB8IDEwOSAtPiBOdW1wYWRTdWJ0cmFjdFxuICAgIHwgMTA2IC0+IE51bXBhZE11bHRpcGx5XG4gICAgfCAxMTAgLT4gTnVtcGFkRGVjaW1hbFxuICAgIHwgOTYgLT4gTnVtcGFkMFxuICAgIHwgOTcgLT4gTnVtcGFkMVxuICAgIHwgOTggLT4gTnVtcGFkMlxuICAgIHwgOTkgLT4gTnVtcGFkM1xuICAgIHwgMTAwIC0+IE51bXBhZDRcbiAgICB8IDEwMSAtPiBOdW1wYWQ1XG4gICAgfCAxMDIgLT4gTnVtcGFkNlxuICAgIHwgMTAzIC0+IE51bXBhZDdcbiAgICB8IDEwNCAtPiBOdW1wYWQ4XG4gICAgfCAxMDUgLT4gTnVtcGFkOVxuICAgIHwgXyAtPiBVbmlkZW50aWZpZWRcblxuICBsZXQgdHJ5X2tleV9jb2RlX25vcm1hbCA9IGZ1bmN0aW9uXG4gICAgfCAyNyAtPiBFc2NhcGVcbiAgICB8IDExMiAtPiBGMVxuICAgIHwgMTEzIC0+IEYyXG4gICAgfCAxMTQgLT4gRjNcbiAgICB8IDExNSAtPiBGNFxuICAgIHwgMTE2IC0+IEY1XG4gICAgfCAxMTcgLT4gRjZcbiAgICB8IDExOCAtPiBGN1xuICAgIHwgMTE5IC0+IEY4XG4gICAgfCAxMjAgLT4gRjlcbiAgICB8IDEyMSAtPiBGMTBcbiAgICB8IDEyMiAtPiBGMTFcbiAgICB8IDEyMyAtPiBGMTJcbiAgICB8IDQyIC0+IFByaW50U2NyZWVuXG4gICAgfCAxNDUgLT4gU2Nyb2xsTG9ja1xuICAgIHwgMTkgLT4gUGF1c2VcbiAgICB8IDE5MiAtPiBCYWNrcXVvdGVcbiAgICB8IDQ5IC0+IERpZ2l0MVxuICAgIHwgNTAgLT4gRGlnaXQyXG4gICAgfCA1MSAtPiBEaWdpdDNcbiAgICB8IDUyIC0+IERpZ2l0NFxuICAgIHwgNTMgLT4gRGlnaXQ1XG4gICAgfCA1NCAtPiBEaWdpdDZcbiAgICB8IDU1IC0+IERpZ2l0N1xuICAgIHwgNTYgLT4gRGlnaXQ4XG4gICAgfCA1NyAtPiBEaWdpdDlcbiAgICB8IDQ4IC0+IERpZ2l0MFxuICAgIHwgMTg5IC0+IE1pbnVzXG4gICAgfCAxODcgLT4gRXF1YWxcbiAgICB8IDggLT4gQmFja3NwYWNlXG4gICAgfCA5IC0+IFRhYlxuICAgIHwgODEgLT4gS2V5UVxuICAgIHwgODcgLT4gS2V5V1xuICAgIHwgNjkgLT4gS2V5RVxuICAgIHwgODIgLT4gS2V5UlxuICAgIHwgODQgLT4gS2V5VFxuICAgIHwgODkgLT4gS2V5WVxuICAgIHwgODUgLT4gS2V5VVxuICAgIHwgNzMgLT4gS2V5SVxuICAgIHwgNzkgLT4gS2V5T1xuICAgIHwgODAgLT4gS2V5UFxuICAgIHwgMjE5IC0+IEJyYWNrZXRMZWZ0XG4gICAgfCAyMjEgLT4gQnJhY2tldFJpZ2h0XG4gICAgfCAyMjAgLT4gQmFja3NsYXNoXG4gICAgfCAyMCAtPiBDYXBzTG9ja1xuICAgIHwgNjUgLT4gS2V5QVxuICAgIHwgODMgLT4gS2V5U1xuICAgIHwgNjggLT4gS2V5RFxuICAgIHwgNzAgLT4gS2V5RlxuICAgIHwgNzEgLT4gS2V5R1xuICAgIHwgNzIgLT4gS2V5SFxuICAgIHwgNzQgLT4gS2V5SlxuICAgIHwgNzUgLT4gS2V5S1xuICAgIHwgNzYgLT4gS2V5TFxuICAgIHwgMTg2IC0+IFNlbWljb2xvblxuICAgIHwgMjIyIC0+IFF1b3RlXG4gICAgfCAxMyAtPiBFbnRlclxuICAgIHwgOTAgLT4gS2V5WlxuICAgIHwgODggLT4gS2V5WFxuICAgIHwgNjcgLT4gS2V5Q1xuICAgIHwgODYgLT4gS2V5VlxuICAgIHwgNjYgLT4gS2V5QlxuICAgIHwgNzggLT4gS2V5TlxuICAgIHwgNzcgLT4gS2V5TVxuICAgIHwgMTg4IC0+IENvbW1hXG4gICAgfCAxOTAgLT4gUGVyaW9kXG4gICAgfCAxOTEgLT4gU2xhc2hcbiAgICB8IDMyIC0+IFNwYWNlXG4gICAgfCA5MyAtPiBDb250ZXh0TWVudVxuICAgIHwgNDUgLT4gSW5zZXJ0XG4gICAgfCAzNiAtPiBIb21lXG4gICAgfCAzMyAtPiBQYWdlVXBcbiAgICB8IDQ2IC0+IERlbGV0ZVxuICAgIHwgMzUgLT4gRW5kXG4gICAgfCAzNCAtPiBQYWdlRG93blxuICAgIHwgMzcgLT4gQXJyb3dMZWZ0XG4gICAgfCA0MCAtPiBBcnJvd0Rvd25cbiAgICB8IDM5IC0+IEFycm93UmlnaHRcbiAgICB8IDM4IC0+IEFycm93VXBcbiAgICB8IF8gLT4gVW5pZGVudGlmaWVkXG5cbiAgbGV0IG1ha2VfdW5pZGVudGlmaWVkIF8gPSBVbmlkZW50aWZpZWRcblxuICBsZXQgdHJ5X25leHQgdmFsdWUgZiA9IGZ1bmN0aW9uXG4gICAgfCBVbmlkZW50aWZpZWQgLT4gT3B0ZGVmLmNhc2UgdmFsdWUgbWFrZV91bmlkZW50aWZpZWQgZlxuICAgIHwgdiAtPiB2XG5cbiAgbGV0IHJ1bl9uZXh0IHZhbHVlIGYgPSBmdW5jdGlvblxuICAgIHwgVW5pZGVudGlmaWVkIC0+IGYgdmFsdWVcbiAgICB8IHYgLT4gdlxuXG4gIGxldCBnZXRfa2V5X2NvZGUgZXZ0ID0gZXZ0IyMua2V5Q29kZVxuXG4gIGxldCB0cnlfa2V5X2xvY2F0aW9uIGV2dCA9XG4gICAgbWF0Y2ggZXZ0IyMubG9jYXRpb24gd2l0aFxuICAgIHwgMSAtPiBydW5fbmV4dCAoZ2V0X2tleV9jb2RlIGV2dCkgdHJ5X2tleV9jb2RlX2xlZnRcbiAgICB8IDIgLT4gcnVuX25leHQgKGdldF9rZXlfY29kZSBldnQpIHRyeV9rZXlfY29kZV9yaWdodFxuICAgIHwgMyAtPiBydW5fbmV4dCAoZ2V0X2tleV9jb2RlIGV2dCkgdHJ5X2tleV9jb2RlX251bXBhZFxuICAgIHwgXyAtPiBtYWtlX3VuaWRlbnRpZmllZFxuXG4gIGxldCAoIHw+ICkgeCBmID0gZiB4XG5cbiAgbGV0IG9mX2V2ZW50IGV2dCA9XG4gICAgVW5pZGVudGlmaWVkXG4gICAgfD4gdHJ5X25leHQgZXZ0IyMuY29kZSB0cnlfY29kZVxuICAgIHw+IHRyeV9rZXlfbG9jYXRpb24gZXZ0XG4gICAgfD4gcnVuX25leHQgKGdldF9rZXlfY29kZSBldnQpIHRyeV9rZXlfY29kZV9ub3JtYWxcblxuICBsZXQgb2Zfa2V5X2NvZGUgPSB0cnlfa2V5X2NvZGVfbm9ybWFsXG5lbmRcblxubW9kdWxlIEtleWJvYXJkX2tleSA9IHN0cnVjdFxuICB0eXBlIHQgPSBVY2hhci50IG9wdGlvblxuXG4gIGxldCBjaGFyX29mX2ludCB2YWx1ZSA9XG4gICAgaWYgMCA8IHZhbHVlIHRoZW4gdHJ5IFNvbWUgKFVjaGFyLm9mX2ludCB2YWx1ZSkgd2l0aCBfIC0+IE5vbmUgZWxzZSBOb25lXG5cbiAgbGV0IGVtcHR5X3N0cmluZyBfID0gSnMuc3RyaW5nIFwiXCJcblxuICBsZXQgbm9uZSBfID0gTm9uZVxuXG4gIGxldCBvZl9ldmVudCBldnQgPVxuICAgIGxldCBrZXkgPSBPcHRkZWYuZ2V0IGV2dCMjLmtleSBlbXB0eV9zdHJpbmcgaW5cbiAgICBtYXRjaCBrZXkjIy5sZW5ndGggd2l0aFxuICAgIHwgMCAtPiBPcHRkZWYuY2FzZSBldnQjIy5jaGFyQ29kZSBub25lIGNoYXJfb2ZfaW50XG4gICAgfCAxIC0+IGNoYXJfb2ZfaW50IChpbnRfb2ZfZmxvYXQgKGtleSMjY2hhckNvZGVBdCAwKSlcbiAgICB8IF8gLT4gTm9uZVxuZW5kXG5cbigqKioqKilcblxubGV0IGVsZW1lbnQgOiAjRG9tLmVsZW1lbnQgdCAtPiBlbGVtZW50IHQgPSBKcy5VbnNhZmUuY29lcmNlXG5cbnR5cGUgdGFnZ2VkRWxlbWVudCA9XG4gIHwgQSBvZiBhbmNob3JFbGVtZW50IHRcbiAgfCBBcmVhIG9mIGFyZWFFbGVtZW50IHRcbiAgfCBBdWRpbyBvZiBhdWRpb0VsZW1lbnQgdFxuICB8IEJhc2Ugb2YgYmFzZUVsZW1lbnQgdFxuICB8IEJsb2NrcXVvdGUgb2YgcXVvdGVFbGVtZW50IHRcbiAgfCBCb2R5IG9mIGJvZHlFbGVtZW50IHRcbiAgfCBCciBvZiBickVsZW1lbnQgdFxuICB8IEJ1dHRvbiBvZiBidXR0b25FbGVtZW50IHRcbiAgfCBDYW52YXMgb2YgY2FudmFzRWxlbWVudCB0XG4gIHwgQ2FwdGlvbiBvZiB0YWJsZUNhcHRpb25FbGVtZW50IHRcbiAgfCBDb2wgb2YgdGFibGVDb2xFbGVtZW50IHRcbiAgfCBDb2xncm91cCBvZiB0YWJsZUNvbEVsZW1lbnQgdFxuICB8IERlbCBvZiBtb2RFbGVtZW50IHRcbiAgfCBEaXYgb2YgZGl2RWxlbWVudCB0XG4gIHwgRGwgb2YgZExpc3RFbGVtZW50IHRcbiAgfCBFbWJlZCBvZiBlbWJlZEVsZW1lbnQgdFxuICB8IEZpZWxkc2V0IG9mIGZpZWxkU2V0RWxlbWVudCB0XG4gIHwgRm9ybSBvZiBmb3JtRWxlbWVudCB0XG4gIHwgRnJhbWVzZXQgb2YgZnJhbWVTZXRFbGVtZW50IHRcbiAgfCBGcmFtZSBvZiBmcmFtZUVsZW1lbnQgdFxuICB8IEgxIG9mIGhlYWRpbmdFbGVtZW50IHRcbiAgfCBIMiBvZiBoZWFkaW5nRWxlbWVudCB0XG4gIHwgSDMgb2YgaGVhZGluZ0VsZW1lbnQgdFxuICB8IEg0IG9mIGhlYWRpbmdFbGVtZW50IHRcbiAgfCBINSBvZiBoZWFkaW5nRWxlbWVudCB0XG4gIHwgSDYgb2YgaGVhZGluZ0VsZW1lbnQgdFxuICB8IEhlYWQgb2YgaGVhZEVsZW1lbnQgdFxuICB8IEhyIG9mIGhyRWxlbWVudCB0XG4gIHwgSHRtbCBvZiBodG1sRWxlbWVudCB0XG4gIHwgSWZyYW1lIG9mIGlGcmFtZUVsZW1lbnQgdFxuICB8IEltZyBvZiBpbWFnZUVsZW1lbnQgdFxuICB8IElucHV0IG9mIGlucHV0RWxlbWVudCB0XG4gIHwgSW5zIG9mIG1vZEVsZW1lbnQgdFxuICB8IExhYmVsIG9mIGxhYmVsRWxlbWVudCB0XG4gIHwgTGVnZW5kIG9mIGxlZ2VuZEVsZW1lbnQgdFxuICB8IExpIG9mIGxpRWxlbWVudCB0XG4gIHwgTGluayBvZiBsaW5rRWxlbWVudCB0XG4gIHwgTWFwIG9mIG1hcEVsZW1lbnQgdFxuICB8IE1ldGEgb2YgbWV0YUVsZW1lbnQgdFxuICB8IE9iamVjdCBvZiBvYmplY3RFbGVtZW50IHRcbiAgfCBPbCBvZiBvTGlzdEVsZW1lbnQgdFxuICB8IE9wdGdyb3VwIG9mIG9wdEdyb3VwRWxlbWVudCB0XG4gIHwgT3B0aW9uIG9mIG9wdGlvbkVsZW1lbnQgdFxuICB8IFAgb2YgcGFyYW1FbGVtZW50IHRcbiAgfCBQYXJhbSBvZiBwYXJhbUVsZW1lbnQgdFxuICB8IFByZSBvZiBwcmVFbGVtZW50IHRcbiAgfCBRIG9mIHF1b3RlRWxlbWVudCB0XG4gIHwgU2NyaXB0IG9mIHNjcmlwdEVsZW1lbnQgdFxuICB8IFNlbGVjdCBvZiBzZWxlY3RFbGVtZW50IHRcbiAgfCBTdHlsZSBvZiBzdHlsZUVsZW1lbnQgdFxuICB8IFRhYmxlIG9mIHRhYmxlRWxlbWVudCB0XG4gIHwgVGJvZHkgb2YgdGFibGVTZWN0aW9uRWxlbWVudCB0XG4gIHwgVGQgb2YgdGFibGVDZWxsRWxlbWVudCB0XG4gIHwgVGV4dGFyZWEgb2YgdGV4dEFyZWFFbGVtZW50IHRcbiAgfCBUZm9vdCBvZiB0YWJsZVNlY3Rpb25FbGVtZW50IHRcbiAgfCBUaCBvZiB0YWJsZUNlbGxFbGVtZW50IHRcbiAgfCBUaGVhZCBvZiB0YWJsZVNlY3Rpb25FbGVtZW50IHRcbiAgfCBUaXRsZSBvZiB0aXRsZUVsZW1lbnQgdFxuICB8IFRyIG9mIHRhYmxlUm93RWxlbWVudCB0XG4gIHwgVWwgb2YgdUxpc3RFbGVtZW50IHRcbiAgfCBWaWRlbyBvZiB2aWRlb0VsZW1lbnQgdFxuICB8IE90aGVyIG9mIGVsZW1lbnQgdFxuXG5sZXQgb3RoZXIgZSA9IE90aGVyIChlIDogI2VsZW1lbnQgdCA6PiBlbGVtZW50IHQpXG5cbmxldCB0YWdnZWQgKGUgOiAjZWxlbWVudCB0KSA9XG4gIGxldCB0YWcgPSBKcy50b19ieXRlc3RyaW5nIGUjIy50YWdOYW1lIyN0b0xvd2VyQ2FzZSBpblxuICBpZiBTdHJpbmcubGVuZ3RoIHRhZyA9IDBcbiAgdGhlbiBvdGhlciBlXG4gIGVsc2VcbiAgICBtYXRjaCBTdHJpbmcudW5zYWZlX2dldCB0YWcgMCB3aXRoXG4gICAgfCAnYScgLT4gKFxuICAgICAgICBtYXRjaCB0YWcgd2l0aFxuICAgICAgICB8IFwiYVwiIC0+IEEgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBcImFyZWFcIiAtPiBBcmVhIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJhdWRpb1wiIC0+IEF1ZGlvIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXyAtPiBvdGhlciBlKVxuICAgIHwgJ2InIC0+IChcbiAgICAgICAgbWF0Y2ggdGFnIHdpdGhcbiAgICAgICAgfCBcImJhc2VcIiAtPiBCYXNlIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJibG9ja3F1b3RlXCIgLT4gQmxvY2txdW90ZSAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICAgICAgICB8IFwiYm9keVwiIC0+IEJvZHkgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBcImJyXCIgLT4gQnIgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBcImJ1dHRvblwiIC0+IEJ1dHRvbiAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICAgICAgICB8IF8gLT4gb3RoZXIgZSlcbiAgICB8ICdjJyAtPiAoXG4gICAgICAgIG1hdGNoIHRhZyB3aXRoXG4gICAgICAgIHwgXCJjYW52YXNcIiAtPiBDYW52YXMgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBcImNhcHRpb25cIiAtPiBDYXB0aW9uIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJjb2xcIiAtPiBDb2wgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBcImNvbGdyb3VwXCIgLT4gQ29sZ3JvdXAgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBfIC0+IG90aGVyIGUpXG4gICAgfCAnZCcgLT4gKFxuICAgICAgICBtYXRjaCB0YWcgd2l0aFxuICAgICAgICB8IFwiZGVsXCIgLT4gRGVsIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJkaXZcIiAtPiBEaXYgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBcImRsXCIgLT4gRGwgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBfIC0+IG90aGVyIGUpXG4gICAgfCAnZScgLT4gKFxuICAgICAgICBtYXRjaCB0YWcgd2l0aFxuICAgICAgICB8IFwiZW1iZWRcIiAtPiBFbWJlZCAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICAgICAgICB8IF8gLT4gb3RoZXIgZSlcbiAgICB8ICdmJyAtPiAoXG4gICAgICAgIG1hdGNoIHRhZyB3aXRoXG4gICAgICAgIHwgXCJmaWVsZHNldFwiIC0+IEZpZWxkc2V0IChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJmb3JtXCIgLT4gRm9ybSAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICAgICAgICB8IFwiZnJhbWVzZXRcIiAtPiBGcmFtZXNldCAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICAgICAgICB8IFwiZnJhbWVcIiAtPiBGcmFtZSAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICAgICAgICB8IF8gLT4gb3RoZXIgZSlcbiAgICB8ICdoJyAtPiAoXG4gICAgICAgIG1hdGNoIHRhZyB3aXRoXG4gICAgICAgIHwgXCJoMVwiIC0+IEgxIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJoMlwiIC0+IEgyIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJoM1wiIC0+IEgzIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJoNFwiIC0+IEg0IChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJoNVwiIC0+IEg1IChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJoNlwiIC0+IEg2IChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJoZWFkXCIgLT4gSGVhZCAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICAgICAgICB8IFwiaHJcIiAtPiBIciAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICAgICAgICB8IFwiaHRtbFwiIC0+IEh0bWwgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBfIC0+IG90aGVyIGUpXG4gICAgfCAnaScgLT4gKFxuICAgICAgICBtYXRjaCB0YWcgd2l0aFxuICAgICAgICB8IFwiaWZyYW1lXCIgLT4gSWZyYW1lIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJpbWdcIiAtPiBJbWcgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBcImlucHV0XCIgLT4gSW5wdXQgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBcImluc1wiIC0+IElucyAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICAgICAgICB8IF8gLT4gb3RoZXIgZSlcbiAgICB8ICdsJyAtPiAoXG4gICAgICAgIG1hdGNoIHRhZyB3aXRoXG4gICAgICAgIHwgXCJsYWJlbFwiIC0+IExhYmVsIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJsZWdlbmRcIiAtPiBMZWdlbmQgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBcImxpXCIgLT4gTGkgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBcImxpbmtcIiAtPiBMaW5rIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXyAtPiBvdGhlciBlKVxuICAgIHwgJ20nIC0+IChcbiAgICAgICAgbWF0Y2ggdGFnIHdpdGhcbiAgICAgICAgfCBcIm1hcFwiIC0+IE1hcCAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICAgICAgICB8IFwibWV0YVwiIC0+IE1ldGEgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBfIC0+IG90aGVyIGUpXG4gICAgfCAnbycgLT4gKFxuICAgICAgICBtYXRjaCB0YWcgd2l0aFxuICAgICAgICB8IFwib2JqZWN0XCIgLT4gT2JqZWN0IChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJvbFwiIC0+IE9sIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJvcHRncm91cFwiIC0+IE9wdGdyb3VwIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJvcHRpb25cIiAtPiBPcHRpb24gKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBfIC0+IG90aGVyIGUpXG4gICAgfCAncCcgLT4gKFxuICAgICAgICBtYXRjaCB0YWcgd2l0aFxuICAgICAgICB8IFwicFwiIC0+IFAgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBcInBhcmFtXCIgLT4gUGFyYW0gKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBcInByZVwiIC0+IFByZSAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICAgICAgICB8IF8gLT4gb3RoZXIgZSlcbiAgICB8ICdxJyAtPiAoXG4gICAgICAgIG1hdGNoIHRhZyB3aXRoXG4gICAgICAgIHwgXCJxXCIgLT4gUSAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICAgICAgICB8IF8gLT4gb3RoZXIgZSlcbiAgICB8ICdzJyAtPiAoXG4gICAgICAgIG1hdGNoIHRhZyB3aXRoXG4gICAgICAgIHwgXCJzY3JpcHRcIiAtPiBTY3JpcHQgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBcInNlbGVjdFwiIC0+IFNlbGVjdCAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICAgICAgICB8IFwic3R5bGVcIiAtPiBTdHlsZSAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICAgICAgICB8IF8gLT4gb3RoZXIgZSlcbiAgICB8ICd0JyAtPiAoXG4gICAgICAgIG1hdGNoIHRhZyB3aXRoXG4gICAgICAgIHwgXCJ0YWJsZVwiIC0+IFRhYmxlIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJ0Ym9keVwiIC0+IFRib2R5IChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJ0ZFwiIC0+IFRkIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJ0ZXh0YXJlYVwiIC0+IFRleHRhcmVhIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJ0Zm9vdFwiIC0+IFRmb290IChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJ0aFwiIC0+IFRoIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJ0aGVhZFwiIC0+IFRoZWFkIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJ0aXRsZVwiIC0+IFRpdGxlIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXCJ0clwiIC0+IFRyIChKcy5VbnNhZmUuY29lcmNlIGUpXG4gICAgICAgIHwgXyAtPiBvdGhlciBlKVxuICAgIHwgJ3UnIC0+IChcbiAgICAgICAgbWF0Y2ggdGFnIHdpdGhcbiAgICAgICAgfCBcInVsXCIgLT4gVWwgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICAgICAgfCBfIC0+IG90aGVyIGUpXG4gICAgfCAndicgLT4gKFxuICAgICAgICBtYXRjaCB0YWcgd2l0aFxuICAgICAgICB8IFwidmlkZW9cIiAtPiBWaWRlbyAoSnMuVW5zYWZlLmNvZXJjZSBlKVxuICAgICAgICB8IF8gLT4gb3RoZXIgZSlcbiAgICB8IF8gLT4gb3RoZXIgZVxuXG5sZXQgb3B0X3RhZ2dlZCBlID0gT3B0LmNhc2UgZSAoZnVuICgpIC0+IE5vbmUpIChmdW4gZSAtPiBTb21lICh0YWdnZWQgZSkpXG5cbnR5cGUgdGFnZ2VkRXZlbnQgPVxuICB8IE1vdXNlRXZlbnQgb2YgbW91c2VFdmVudCB0XG4gIHwgS2V5Ym9hcmRFdmVudCBvZiBrZXlib2FyZEV2ZW50IHRcbiAgfCBNZXNzYWdlRXZlbnQgb2YgbWVzc2FnZUV2ZW50IHRcbiAgfCBNb3VzZXdoZWVsRXZlbnQgb2YgbW91c2V3aGVlbEV2ZW50IHRcbiAgfCBNb3VzZVNjcm9sbEV2ZW50IG9mIG1vdXNlU2Nyb2xsRXZlbnQgdFxuICB8IFBvcFN0YXRlRXZlbnQgb2YgcG9wU3RhdGVFdmVudCB0XG4gIHwgT3RoZXJFdmVudCBvZiBldmVudCB0XG5cbmxldCB0YWdnZWRFdmVudCAoZXYgOiAjZXZlbnQgSnMudCkgPVxuICBKcy5PcHQuY2FzZVxuICAgIChDb2VyY2VUby5tb3VzZUV2ZW50IGV2KVxuICAgIChmdW4gKCkgLT5cbiAgICAgIEpzLk9wdC5jYXNlXG4gICAgICAgIChDb2VyY2VUby5rZXlib2FyZEV2ZW50IGV2KVxuICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgSnMuT3B0LmNhc2VcbiAgICAgICAgICAgIChDb2VyY2VUby53aGVlbEV2ZW50IGV2KVxuICAgICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICBKcy5PcHQuY2FzZVxuICAgICAgICAgICAgICAgIChDb2VyY2VUby5tb3VzZVNjcm9sbEV2ZW50IGV2KVxuICAgICAgICAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgICAgIEpzLk9wdC5jYXNlXG4gICAgICAgICAgICAgICAgICAgIChDb2VyY2VUby5wb3BTdGF0ZUV2ZW50IGV2KVxuICAgICAgICAgICAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgSnMuT3B0LmNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIChDb2VyY2VUby5tZXNzYWdlRXZlbnQgZXYpXG4gICAgICAgICAgICAgICAgICAgICAgICAoZnVuICgpIC0+IE90aGVyRXZlbnQgKGV2IDo+IGV2ZW50IHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1biBldiAtPiBNZXNzYWdlRXZlbnQgZXYpKVxuICAgICAgICAgICAgICAgICAgICAoZnVuIGV2IC0+IFBvcFN0YXRlRXZlbnQgZXYpKVxuICAgICAgICAgICAgICAgIChmdW4gZXYgLT4gTW91c2VTY3JvbGxFdmVudCBldikpXG4gICAgICAgICAgICAoZnVuIGV2IC0+IE1vdXNld2hlZWxFdmVudCBldikpXG4gICAgICAgIChmdW4gZXYgLT4gS2V5Ym9hcmRFdmVudCBldikpXG4gICAgKGZ1biBldiAtPiBNb3VzZUV2ZW50IGV2KVxuXG5sZXQgb3B0X3RhZ2dlZEV2ZW50IGV2ID0gT3B0LmNhc2UgZXYgKGZ1biAoKSAtPiBOb25lKSAoZnVuIGV2IC0+IFNvbWUgKHRhZ2dlZEV2ZW50IGV2KSlcblxubGV0IHN0b3BQcm9wYWdhdGlvbiBldiA9XG4gIGxldCBlID0gSnMuVW5zYWZlLmNvZXJjZSBldiBpblxuICBPcHRkZWYuY2FzZVxuICAgIGUjIy5zdG9wUHJvcGFnYXRpb25cbiAgICAoZnVuICgpIC0+IGUjIy5jYW5jZWxCdWJibGUgOj0gSnMuX3RydWUpXG4gICAgKGZ1biBfIC0+IGUjI19zdG9wUHJvcGFnYXRpb24pXG5cbmxldCBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogKHVuaXQgLT4gdW5pdCkgSnMuY2FsbGJhY2sgLT4gdW5pdCA9XG4gIEpzLlVuc2FmZS5wdXJlX2V4cHIgKGZ1biBfIC0+XG4gICAgICBsZXQgdyA9IEpzLlVuc2FmZS5jb2VyY2Ugd2luZG93IGluXG4gICAgICBsZXQgbCA9XG4gICAgICAgIFsgdyMjLnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICA7IHcjIy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgOyB3IyMud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgIDsgdyMjLm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgOyB3IyMubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgXVxuICAgICAgaW5cbiAgICAgIHRyeVxuICAgICAgICBsZXQgcmVxID0gTGlzdC5maW5kIChmdW4gYyAtPiBKcy5PcHRkZWYudGVzdCBjKSBsIGluXG4gICAgICAgIGZ1biBjYWxsYmFjayAtPiBKcy5VbnNhZmUuZnVuX2NhbGwgcmVxIFt8IEpzLlVuc2FmZS5pbmplY3QgY2FsbGJhY2sgfF1cbiAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgIGxldCBub3cgKCkgPSAobmV3JWpzIEpzLmRhdGVfbm93KSMjZ2V0VGltZSBpblxuICAgICAgICBsZXQgbGFzdCA9IHJlZiAobm93ICgpKSBpblxuICAgICAgICBmdW4gY2FsbGJhY2sgLT5cbiAgICAgICAgICBsZXQgdCA9IG5vdyAoKSBpblxuICAgICAgICAgIGxldCBkdCA9ICFsYXN0ICsuICgxMDAwLiAvLiA2MC4pIC0uIHQgaW5cbiAgICAgICAgICBsZXQgZHQgPSBpZiBQb2x5LihkdCA8IDAuKSB0aGVuIDAuIGVsc2UgZHQgaW5cbiAgICAgICAgICBsYXN0IDo9IHQ7XG4gICAgICAgICAgaWdub3JlICh3aW5kb3cjI3NldFRpbWVvdXQgY2FsbGJhY2sgZHQpKVxuXG4oKioqKilcblxubGV0IGhhc1B1c2hTdGF0ZSAoKSA9IEpzLk9wdGRlZi50ZXN0IChKcy5VbnNhZmUuY29lcmNlIHdpbmRvdyMjLmhpc3RvcnkpIyMucHVzaFN0YXRlXG5cbmxldCBoYXNQbGFjZWhvbGRlciAoKSA9XG4gIGxldCBpID0gY3JlYXRlSW5wdXQgZG9jdW1lbnQgaW5cbiAgSnMuT3B0ZGVmLnRlc3QgKEpzLlVuc2FmZS5jb2VyY2UgaSkjIy5wbGFjZWhvbGRlclxuXG5sZXQgaGFzUmVxdWlyZWQgKCkgPVxuICBsZXQgaSA9IGNyZWF0ZUlucHV0IGRvY3VtZW50IGluXG4gIEpzLk9wdGRlZi50ZXN0IChKcy5VbnNhZmUuY29lcmNlIGkpIyMucmVxdWlyZWRcblxubGV0IG92ZXJmbG93X2xpbWl0ID0gMjE0NzQ4M18wMDAuXG5cbigqIG1zICopXG5cbnR5cGUgdGltZW91dF9pZF9zYWZlID0gdGltZW91dF9pZCBvcHRpb24gcmVmXG5cbmxldCBzZXRUaW1lb3V0IGNhbGxiYWNrIGQgOiB0aW1lb3V0X2lkX3NhZmUgPVxuICBsZXQgaWQgPSByZWYgTm9uZSBpblxuICBsZXQgcmVjIGxvb3AgZCAoKSA9XG4gICAgbGV0IHN0ZXAsIHJlbWFpbiA9XG4gICAgICBpZiBQb2x5LihkID4gb3ZlcmZsb3dfbGltaXQpIHRoZW4gb3ZlcmZsb3dfbGltaXQsIGQgLS4gb3ZlcmZsb3dfbGltaXQgZWxzZSBkLCAwLlxuICAgIGluXG4gICAgbGV0IGNiID0gaWYgUG9seS4ocmVtYWluID0gMC4pIHRoZW4gY2FsbGJhY2sgZWxzZSBsb29wIHJlbWFpbiBpblxuICAgIGlkIDo9IFNvbWUgKHdpbmRvdyMjc2V0VGltZW91dCAoSnMud3JhcF9jYWxsYmFjayBjYikgc3RlcClcbiAgaW5cbiAgbG9vcCBkICgpO1xuICBpZFxuXG5sZXQgY2xlYXJUaW1lb3V0IChpZCA6IHRpbWVvdXRfaWRfc2FmZSkgPVxuICBtYXRjaCAhaWQgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIHggLT5cbiAgICAgIGlkIDo9IE5vbmU7XG4gICAgICB3aW5kb3cjI2NsZWFyVGltZW91dCB4XG5cbmxldCBqc19hcnJheV9vZl9jb2xsZWN0aW9uIChjIDogI2VsZW1lbnQgY29sbGVjdGlvbiBKcy50KSA6ICNlbGVtZW50IEpzLnQgSnMuanNfYXJyYXkgSnMudFxuICAgID1cbiAgSnMuVW5zYWZlLihtZXRoX2NhbGwgKGpzX2V4cHIgXCJbXS5zbGljZVwiKSBcImNhbGxcIiBbfCBpbmplY3QgYyB8XSlcbiIsIigqIEpzX29mX29jYW1sIGxpYnJhcnlcbiAqIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTEgUGllcnJlIENoYW1iYXJ0XG4gKiBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3RcbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuICogZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAqIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAqIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4gKilcblxub3BlbiBKc1xub3BlbiBEb21faHRtbFxub3BlbiEgSW1wb3J0XG5cbmNsYXNzIHR5cGUgZm9ybURhdGEgPVxuICBvYmplY3RcbiAgICBtZXRob2QgYXBwZW5kIDoganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgYXBwZW5kX2Jsb2IgOiBqc19zdHJpbmcgdCAtPiBGaWxlLmJsb2IgdCAtPiB1bml0IG1ldGhcbiAgZW5kXG5cbmxldCBmb3JtRGF0YSA6IGZvcm1EYXRhIHQgY29uc3RyID0gSnMuVW5zYWZlLmdsb2JhbCMjLl9Gb3JtRGF0YVxuXG5sZXQgZm9ybURhdGFfZm9ybSA6IChmb3JtRWxlbWVudCB0IC0+IGZvcm1EYXRhIHQpIGNvbnN0ciA9IEpzLlVuc2FmZS5nbG9iYWwjIy5fRm9ybURhdGFcblxudHlwZSBmb3JtX2VsdCA9XG4gIFsgYFN0cmluZyBvZiBqc19zdHJpbmcgdFxuICB8IGBGaWxlIG9mIEZpbGUuZmlsZSB0XG4gIF1cblxudHlwZSBmb3JtX2NvbnRlbnRzID1cbiAgWyBgRmllbGRzIG9mIChzdHJpbmcgKiBmb3JtX2VsdCkgbGlzdCByZWZcbiAgfCBgRm9ybURhdGEgb2YgZm9ybURhdGEgdFxuICBdXG5cbmxldCByZWMgZmlsdGVyX21hcCBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IHYgOjogcSAtPiAoXG4gICAgICBtYXRjaCBmIHYgd2l0aFxuICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXAgZiBxXG4gICAgICB8IFNvbWUgdicgLT4gdicgOjogZmlsdGVyX21hcCBmIHEpXG5cbmNsYXNzIHR5cGUgc3VibWl0dGFibGVFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGRpc2FibGVkIDogYm9vbCB0IHByb3BcblxuICAgIG1ldGhvZCBuYW1lIDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHZhbHVlIDoganNfc3RyaW5nIHQgcHJvcFxuICBlbmRcblxubGV0IGhhdmVfY29udGVudCAoZWx0IDogc3VibWl0dGFibGVFbGVtZW50IHQpID1cbiAgZWx0IyMubmFtZSMjLmxlbmd0aCA+IDAgJiYgbm90IChKcy50b19ib29sIGVsdCMjLmRpc2FibGVkKVxuXG5sZXQgZ2V0X3RleHRhcmVhX3ZhbCAoZWx0IDogdGV4dEFyZWFFbGVtZW50IHQpID1cbiAgaWYgaGF2ZV9jb250ZW50IChlbHQgOj4gc3VibWl0dGFibGVFbGVtZW50IHQpXG4gIHRoZW5cbiAgICBsZXQgbmFtZSA9IHRvX3N0cmluZyBlbHQjIy5uYW1lIGluXG4gICAgWyBuYW1lLCBgU3RyaW5nIGVsdCMjLnZhbHVlIF1cbiAgZWxzZSBbXVxuXG5sZXQgZ2V0X3NlbGVjdF92YWwgKGVsdCA6IHNlbGVjdEVsZW1lbnQgdCkgPVxuICBpZiBoYXZlX2NvbnRlbnQgKGVsdCA6PiBzdWJtaXR0YWJsZUVsZW1lbnQgdClcbiAgdGhlblxuICAgIGxldCBuYW1lID0gdG9fc3RyaW5nIGVsdCMjLm5hbWUgaW5cbiAgICBpZiB0b19ib29sIGVsdCMjLm11bHRpcGxlXG4gICAgdGhlblxuICAgICAgbGV0IG9wdGlvbnMgPVxuICAgICAgICBBcnJheS5pbml0IGVsdCMjLm9wdGlvbnMjIy5sZW5ndGggKGZ1biBpIC0+IE9wdC50b19vcHRpb24gKGVsdCMjLm9wdGlvbnMjI2l0ZW0gaSkpXG4gICAgICBpblxuICAgICAgZmlsdGVyX21hcFxuICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgIHwgU29tZSBlIC0+XG4gICAgICAgICAgICAgIGlmIEpzLnRvX2Jvb2wgZSMjLnNlbGVjdGVkIHRoZW4gU29tZSAobmFtZSwgYFN0cmluZyBlIyMudmFsdWUpIGVsc2UgTm9uZSlcbiAgICAgICAgKEFycmF5LnRvX2xpc3Qgb3B0aW9ucylcbiAgICBlbHNlIFsgbmFtZSwgYFN0cmluZyBlbHQjIy52YWx1ZSBdXG4gIGVsc2UgW11cblxuY2xhc3MgdHlwZSBmaWxlX2lucHV0ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBpbnB1dEVsZW1lbnRcblxuICAgIG1ldGhvZCBmaWxlcyA6IEZpbGUuZmlsZUxpc3QgdCBvcHRkZWYgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG11bHRpcGxlIDogYm9vbCBvcHRkZWYgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxubGV0IGdldF9pbnB1dF92YWwgPyhnZXQgPSBmYWxzZSkgKGVsdCA6IGlucHV0RWxlbWVudCB0KSA9XG4gIGlmIGhhdmVfY29udGVudCAoZWx0IDo+IHN1Ym1pdHRhYmxlRWxlbWVudCB0KVxuICB0aGVuXG4gICAgbGV0IG5hbWUgPSB0b19zdHJpbmcgZWx0IyMubmFtZSBpblxuICAgIGxldCB2YWx1ZSA9IGVsdCMjLnZhbHVlIGluXG4gICAgbWF0Y2ggdG9fYnl0ZXN0cmluZyBlbHQjIy5fdHlwZSMjdG9Mb3dlckNhc2Ugd2l0aFxuICAgIHwgXCJjaGVja2JveFwiIHwgXCJyYWRpb1wiIC0+XG4gICAgICAgIGlmIHRvX2Jvb2wgZWx0IyMuY2hlY2tlZCB0aGVuIFsgbmFtZSwgYFN0cmluZyB2YWx1ZSBdIGVsc2UgW11cbiAgICB8IFwic3VibWl0XCIgfCBcInJlc2V0XCIgLT4gW11cbiAgICB8IFwidGV4dFwiIHwgXCJwYXNzd29yZFwiIC0+IFsgbmFtZSwgYFN0cmluZyB2YWx1ZSBdXG4gICAgfCBcImZpbGVcIiAtPiAoXG4gICAgICAgIGlmIGdldFxuICAgICAgICB0aGVuIFsgbmFtZSwgYFN0cmluZyB2YWx1ZSBdXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgZWx0IDogZmlsZV9pbnB1dCB0ID0gVW5zYWZlLmNvZXJjZSBlbHQgaW5cbiAgICAgICAgICBtYXRjaCBPcHRkZWYudG9fb3B0aW9uIGVsdCMjLmZpbGVzIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gW11cbiAgICAgICAgICB8IFNvbWUgbGlzdCAtPiAoXG4gICAgICAgICAgICAgIGlmIGxpc3QjIy5sZW5ndGggPSAwXG4gICAgICAgICAgICAgIHRoZW4gWyBuYW1lLCBgU3RyaW5nIChKcy5zdHJpbmcgXCJcIikgXVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWF0Y2ggT3B0ZGVmLnRvX29wdGlvbiBlbHQjIy5tdWx0aXBsZSB3aXRoXG4gICAgICAgICAgICAgICAgfCBOb25lIHwgU29tZSBmYWxzZSAtPiAoXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoIE9wdC50b19vcHRpb24gKGxpc3QjI2l0ZW0gMCkgd2l0aFxuICAgICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gW11cbiAgICAgICAgICAgICAgICAgICAgfCBTb21lIGZpbGUgLT4gWyBuYW1lLCBgRmlsZSBmaWxlIF0pXG4gICAgICAgICAgICAgICAgfCBTb21lIHRydWUgLT5cbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyX21hcFxuICAgICAgICAgICAgICAgICAgICAgIChmdW4gZiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggT3B0LnRvX29wdGlvbiBmIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgICAgICAgICAgICAgICB8IFNvbWUgZmlsZSAtPiBTb21lIChuYW1lLCBgRmlsZSBmaWxlKSlcbiAgICAgICAgICAgICAgICAgICAgICAoQXJyYXkudG9fbGlzdCAoQXJyYXkuaW5pdCBsaXN0IyMubGVuZ3RoIChmdW4gaSAtPiBsaXN0IyNpdGVtIGkpKSkpKVxuICAgIHwgXyAtPiBbIG5hbWUsIGBTdHJpbmcgdmFsdWUgXVxuICBlbHNlIFtdXG5cbmxldCBnZXRfZm9ybV9lbGVtZW50cyAoZm9ybSA6IGZvcm1FbGVtZW50IHQpID1cbiAgbGV0IHJlYyBsb29wIGFjYyBpID1cbiAgICBpZiBpIDwgMFxuICAgIHRoZW4gYWNjXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggT3B0LnRvX29wdGlvbiAoZm9ybSMjLmVsZW1lbnRzIyNpdGVtIGkpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBsb29wIGFjYyAoaSAtIGkpXG4gICAgICB8IFNvbWUgeCAtPiBsb29wICh4IDo6IGFjYykgKGkgLSAxKVxuICBpblxuICBsb29wIFtdIChmb3JtIyMuZWxlbWVudHMjIy5sZW5ndGggLSAxKVxuXG5sZXQgZ2V0X2VsZW1lbnRfY29udGVudCA/Z2V0IHYgPVxuICBtYXRjaCB0YWdnZWQgdiB3aXRoXG4gIHwgU2VsZWN0IHYgLT4gZ2V0X3NlbGVjdF92YWwgdlxuICB8IElucHV0IHYgLT4gZ2V0X2lucHV0X3ZhbCA/Z2V0IHZcbiAgfCBUZXh0YXJlYSB2IC0+IGdldF90ZXh0YXJlYV92YWwgdlxuICB8IF8gLT4gW11cblxubGV0IGZvcm1fZWxlbWVudHMgP2dldCAoZm9ybSA6IGZvcm1FbGVtZW50IHQpID1cbiAgTGlzdC5mbGF0dGVuIChMaXN0Lm1hcCAoZnVuIHYgLT4gZ2V0X2VsZW1lbnRfY29udGVudCA/Z2V0IHYpIChnZXRfZm9ybV9lbGVtZW50cyBmb3JtKSlcblxubGV0IGFwcGVuZCAoZm9ybV9jb250ZW50cyA6IGZvcm1fY29udGVudHMpIChmb3JtX2VsdCA6IHN0cmluZyAqIGZvcm1fZWx0KSA9XG4gIG1hdGNoIGZvcm1fY29udGVudHMgd2l0aFxuICB8IGBGaWVsZHMgbGlzdCAtPiBsaXN0IDo9IGZvcm1fZWx0IDo6ICFsaXN0XG4gIHwgYEZvcm1EYXRhIGYgLT4gKFxuICAgICAgbWF0Y2ggZm9ybV9lbHQgd2l0aFxuICAgICAgfCBuYW1lLCBgU3RyaW5nIHMgLT4gZiMjYXBwZW5kIChzdHJpbmcgbmFtZSkgc1xuICAgICAgfCBuYW1lLCBgRmlsZSBmaWxlIC0+IGYjI2FwcGVuZF9ibG9iIChzdHJpbmcgbmFtZSkgKGZpbGUgOj4gRmlsZS5ibG9iIHQpKVxuXG5sZXQgZW1wdHlfZm9ybV9jb250ZW50cyAoKSA9XG4gIG1hdGNoIE9wdGRlZi50b19vcHRpb24gKEpzLmRlZiBmb3JtRGF0YSkgd2l0aFxuICB8IE5vbmUgLT4gYEZpZWxkcyAocmVmIFtdKVxuICB8IFNvbWUgY29uc3RyIC0+IGBGb3JtRGF0YSAobmV3JWpzIGNvbnN0cilcblxubGV0IHBvc3RfZm9ybV9jb250ZW50cyBmb3JtID1cbiAgbGV0IGNvbnRlbnRzID0gZW1wdHlfZm9ybV9jb250ZW50cyAoKSBpblxuICBMaXN0Lml0ZXIgKGFwcGVuZCBjb250ZW50cykgKGZvcm1fZWxlbWVudHMgZm9ybSk7XG4gIGNvbnRlbnRzXG5cbmxldCBnZXRfZm9ybV9jb250ZW50cyBmb3JtID1cbiAgTGlzdC5tYXBcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgbmFtZSwgYFN0cmluZyBzIC0+IG5hbWUsIHRvX3N0cmluZyBzXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICAgIChmb3JtX2VsZW1lbnRzIH5nZXQ6dHJ1ZSBmb3JtKVxuIiwiKCogSnNfb2Zfb2NhbWwgbGlicmFyeVxuICogaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbiAqIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuICogTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbiAqIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICopXG5cbm9wZW4gSnNcbm9wZW4hIEltcG9ydFxuXG50eXBlIHJlYWR5U3RhdGUgPVxuICB8IFVOU0VOVFxuICB8IE9QRU5FRFxuICB8IEhFQURFUlNfUkVDRUlWRURcbiAgfCBMT0FESU5HXG4gIHwgRE9ORVxuXG50eXBlIF8gcmVzcG9uc2UgPVxuICB8IEFycmF5QnVmZmVyIDogVHlwZWRfYXJyYXkuYXJyYXlCdWZmZXIgdCBPcHQudCByZXNwb25zZVxuICB8IEJsb2IgOiAjRmlsZS5ibG9iIHQgT3B0LnQgcmVzcG9uc2VcbiAgfCBEb2N1bWVudCA6IERvbS5lbGVtZW50IERvbS5kb2N1bWVudCB0IE9wdC50IHJlc3BvbnNlXG4gIHwgSlNPTiA6ICdhIE9wdC50IHJlc3BvbnNlXG4gIHwgVGV4dCA6IGpzX3N0cmluZyB0IHJlc3BvbnNlXG4gIHwgRGVmYXVsdCA6IHN0cmluZyByZXNwb25zZVxuXG5jbGFzcyB0eXBlIHhtbEh0dHBSZXF1ZXN0ID1cbiAgb2JqZWN0ICgnc2VsZilcbiAgICBtZXRob2Qgb25yZWFkeXN0YXRlY2hhbmdlIDogKHVuaXQgLT4gdW5pdCkgSnMuY2FsbGJhY2sgSnMud3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCByZWFkeVN0YXRlIDogcmVhZHlTdGF0ZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX29wZW4gOiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCAtPiBib29sIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgX29wZW5fZnVsbCA6XG4gICAgICAgICBqc19zdHJpbmcgdFxuICAgICAgLT4ganNfc3RyaW5nIHRcbiAgICAgIC0+IGJvb2wgdFxuICAgICAgLT4ganNfc3RyaW5nIHQgb3B0XG4gICAgICAtPiBqc19zdHJpbmcgdCBvcHRcbiAgICAgIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldFJlcXVlc3RIZWFkZXIgOiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBvdmVycmlkZU1pbWVUeXBlIDoganNfc3RyaW5nIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc2VuZCA6IGpzX3N0cmluZyB0IG9wdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzZW5kX2Jsb2IgOiAjRmlsZS5ibG9iIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc2VuZF9kb2N1bWVudCA6IERvbS5lbGVtZW50IERvbS5kb2N1bWVudCB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHNlbmRfZm9ybURhdGEgOiBGb3JtLmZvcm1EYXRhIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgYWJvcnQgOiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzdGF0dXMgOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHN0YXR1c1RleHQgOiBqc19zdHJpbmcgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgZ2V0UmVzcG9uc2VIZWFkZXIgOiBqc19zdHJpbmcgdCAtPiBqc19zdHJpbmcgdCBvcHQgbWV0aFxuXG4gICAgbWV0aG9kIGdldEFsbFJlc3BvbnNlSGVhZGVycyA6IGpzX3N0cmluZyB0IG1ldGhcblxuICAgIG1ldGhvZCByZXNwb25zZSA6IEZpbGUuZmlsZV9hbnkgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHJlc3BvbnNlVGV4dCA6IGpzX3N0cmluZyB0IG9wdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgcmVzcG9uc2VYTUwgOiBEb20uZWxlbWVudCBEb20uZG9jdW1lbnQgdCBvcHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHJlc3BvbnNlVHlwZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCB3aXRoQ3JlZGVudGlhbHMgOiBib29sIHQgd3JpdGVvbmx5X3Byb3BcblxuICAgIGluaGVyaXQgRmlsZS5wcm9ncmVzc0V2ZW50VGFyZ2V0XG5cbiAgICBtZXRob2Qgb250aW1lb3V0IDpcbiAgICAgICgnc2VsZiB0LCAnc2VsZiBGaWxlLnByb2dyZXNzRXZlbnQgdCkgRG9tLmV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2QgdXBsb2FkIDogeG1sSHR0cFJlcXVlc3RVcGxvYWQgdCBvcHRkZWYgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuYW5kIHhtbEh0dHBSZXF1ZXN0VXBsb2FkID1cbiAgb2JqZWN0ICgnc2VsZilcbiAgICBpbmhlcml0IEZpbGUucHJvZ3Jlc3NFdmVudFRhcmdldFxuICBlbmRcblxubW9kdWxlIEV2ZW50ID0gc3RydWN0XG4gIHR5cGUgdHlwID0geG1sSHR0cFJlcXVlc3QgRmlsZS5wcm9ncmVzc0V2ZW50IHQgRG9tLkV2ZW50LnR5cFxuXG4gIGxldCByZWFkeXN0YXRlY2hhbmdlID0gRG9tLkV2ZW50Lm1ha2UgXCJyZWFkeXN0YXRlY2hhbmdlXCJcblxuICBsZXQgbG9hZHN0YXJ0ID0gRG9tLkV2ZW50Lm1ha2UgXCJsb2Fkc3RhcnRcIlxuXG4gIGxldCBwcm9ncmVzcyA9IERvbS5FdmVudC5tYWtlIFwicHJvZ3Jlc3NcIlxuXG4gIGxldCBhYm9ydCA9IERvbS5FdmVudC5tYWtlIFwiYWJvcnRcIlxuXG4gIGxldCBlcnJvciA9IERvbS5FdmVudC5tYWtlIFwiZXJyb3JcIlxuXG4gIGxldCBsb2FkID0gRG9tLkV2ZW50Lm1ha2UgXCJsb2FkXCJcblxuICBsZXQgdGltZW91dCA9IERvbS5FdmVudC5tYWtlIFwidGltZW91dFwiXG5cbiAgbGV0IGxvYWRlbmQgPSBEb20uRXZlbnQubWFrZSBcImxvYWRlbmRcIlxuZW5kXG5cbmV4dGVybmFsIGNyZWF0ZSA6IHVuaXQgLT4geG1sSHR0cFJlcXVlc3QgSnMudCA9IFwiY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGVcIlxuIiwiKCogSnNfb2Zfb2NhbWwgbGlicmFyeVxuICogaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbiAqIENvcHlyaWdodCAoQykgMjAxNSBPQ2FtbFBybzogR3LDqWdvaXJlIEhlbnJ5LCDDh2HEn2RhxZ8gQm96bWFuLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4gKiBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICogRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbiAqKVxuXG5vcGVuIEpzXG5vcGVuIERvbV9odG1sXG5vcGVuISBJbXBvcnRcblxuY2xhc3MgdHlwZSBbJ2EsICdiXSB3b3JrZXIgPVxuICBvYmplY3QgKCdzZWxmKVxuICAgIGluaGVyaXQgZXZlbnRUYXJnZXRcblxuICAgIG1ldGhvZCBvbmVycm9yIDogKCdzZWxmIHQsIGVycm9yRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbm1lc3NhZ2UgOiAoJ3NlbGYgdCwgJ2IgbWVzc2FnZUV2ZW50IHQpIGV2ZW50X2xpc3RlbmVyIHdyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2QgcG9zdE1lc3NhZ2UgOiAnYSAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB0ZXJtaW5hdGUgOiB1bml0IG1ldGhcbiAgZW5kXG5cbmFuZCBlcnJvckV2ZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBldmVudFxuXG4gICAgbWV0aG9kIG1lc3NhZ2UgOiBqc19zdHJpbmcgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgZmlsZW5hbWUgOiBqc19zdHJpbmcgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgbGluZW5vIDogaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBjb2xubyA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgZXJyb3IgOiBVbnNhZmUuYW55IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbmFuZCBbJ2FdIG1lc3NhZ2VFdmVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZXZlbnRcblxuICAgIG1ldGhvZCBkYXRhIDogJ2EgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxubGV0IHdvcmtlciA9IFVuc2FmZS5nbG9iYWwjIy5fV29ya2VyXG5cbmxldCBjcmVhdGUgc2NyaXB0ID0gbmV3JWpzIHdvcmtlciAoc3RyaW5nIHNjcmlwdClcblxubGV0IGltcG9ydF9zY3JpcHRzIHNjcmlwdHMgOiB1bml0ID1cbiAgaWYgVW5zYWZlLmdsb2JhbCMjLmltcG9ydFNjcmlwdHMgPT0gdW5kZWZpbmVkXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJXb3JrZXIuaW1wb3J0X3NjcmlwdHMgaXMgdW5kZWZpbmVkXCI7XG4gIFVuc2FmZS5mdW5fY2FsbFxuICAgIFVuc2FmZS5nbG9iYWwjIy5pbXBvcnRTY3JpcHRzXG4gICAgKEFycmF5Lm1hcCAoZnVuIHMgLT4gVW5zYWZlLmluamVjdCAoc3RyaW5nIHMpKSAoQXJyYXkub2ZfbGlzdCBzY3JpcHRzKSlcblxubGV0IHNldF9vbm1lc3NhZ2UgaGFuZGxlciA9XG4gIGlmIFVuc2FmZS5nbG9iYWwjIy5vbm1lc3NhZ2UgPT0gdW5kZWZpbmVkXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJXb3JrZXIub25tZXNzYWdlIGlzIHVuZGVmaW5lZFwiO1xuICBsZXQganNfaGFuZGxlciAoZXYgOiAnYSBtZXNzYWdlRXZlbnQgSnMudCkgPSBoYW5kbGVyIGV2IyMuZGF0YSBpblxuICBVbnNhZmUuZ2xvYmFsIyMub25tZXNzYWdlIDo9IHdyYXBfY2FsbGJhY2sganNfaGFuZGxlclxuXG5sZXQgcG9zdF9tZXNzYWdlIG1zZyA9XG4gIGlmIFVuc2FmZS5nbG9iYWwjIy5wb3N0TWVzc2FnZSA9PSB1bmRlZmluZWRcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIldvcmtlci5vbm1lc3NhZ2UgaXMgdW5kZWZpbmVkXCI7XG4gIFVuc2FmZS5nbG9iYWwjI3Bvc3RNZXNzYWdlIG1zZ1xuIiwiKCogSnNfb2Zfb2NhbWwgbGlicmFyeVxuICogaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbiAqIENvcHlyaWdodCAoQykgMjAxMiBKYWNxdWVzLVBhc2NhbCBEZXBsYWl4XG4gKiBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3RcbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuICogZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAqIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAqIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4gKilcblxub3BlbiEgSW1wb3J0XG5cbnR5cGUgcmVhZHlTdGF0ZSA9XG4gIHwgQ09OTkVDVElOR1xuICB8IE9QRU5cbiAgfCBDTE9TSU5HXG4gIHwgQ0xPU0VEXG5cbmNsYXNzIHR5cGUgWydhXSBjbG9zZUV2ZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBbJ2FdIERvbS5ldmVudFxuXG4gICAgbWV0aG9kIGNvZGUgOiBpbnQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHJlYXNvbiA6IEpzLmpzX3N0cmluZyBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB3YXNDbGVhbiA6IGJvb2wgSnMudCBKcy5yZWFkb25seV9wcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIFsnYV0gbWVzc2FnZUV2ZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBbJ2FdIERvbS5ldmVudFxuXG4gICAgbWV0aG9kIGRhdGEgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgZGF0YV9idWZmZXIgOiBUeXBlZF9hcnJheS5hcnJheUJ1ZmZlciBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBkYXRhX2Jsb2IgOiBGaWxlLmJsb2IgSnMudCBKcy5yZWFkb25seV9wcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIHdlYlNvY2tldCA9XG4gIG9iamVjdCAoJ3NlbGYpXG4gICAgaW5oZXJpdCBEb21faHRtbC5ldmVudFRhcmdldFxuXG4gICAgbWV0aG9kIHVybCA6IEpzLmpzX3N0cmluZyBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCByZWFkeVN0YXRlIDogcmVhZHlTdGF0ZSBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgYnVmZmVyZWRBbW91bnQgOiBpbnQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9ub3BlbiA6XG4gICAgICAoJ3NlbGYgSnMudCwgJ3NlbGYgRG9tLmV2ZW50IEpzLnQpIERvbS5ldmVudF9saXN0ZW5lciBKcy53cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9uY2xvc2UgOlxuICAgICAgKCdzZWxmIEpzLnQsICdzZWxmIGNsb3NlRXZlbnQgSnMudCkgRG9tLmV2ZW50X2xpc3RlbmVyIEpzLndyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb25lcnJvciA6XG4gICAgICAoJ3NlbGYgSnMudCwgJ3NlbGYgRG9tLmV2ZW50IEpzLnQpIERvbS5ldmVudF9saXN0ZW5lciBKcy53cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGV4dGVuc2lvbnMgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgcHJvdG9jb2wgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgY2xvc2UgOiB1bml0IEpzLm1ldGhcblxuICAgIG1ldGhvZCBjbG9zZV93aXRoQ29kZSA6IGludCAtPiB1bml0IEpzLm1ldGhcblxuICAgIG1ldGhvZCBjbG9zZV93aXRoQ29kZUFuZFJlYXNvbiA6IGludCAtPiBKcy5qc19zdHJpbmcgSnMudCAtPiB1bml0IEpzLm1ldGhcblxuICAgIG1ldGhvZCBvbm1lc3NhZ2UgOlxuICAgICAgKCdzZWxmIEpzLnQsICdzZWxmIG1lc3NhZ2VFdmVudCBKcy50KSBEb20uZXZlbnRfbGlzdGVuZXIgSnMud3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBiaW5hcnlUeXBlIDogSnMuanNfc3RyaW5nIEpzLnQgSnMucHJvcFxuXG4gICAgbWV0aG9kIHNlbmQgOiBKcy5qc19zdHJpbmcgSnMudCAtPiB1bml0IEpzLm1ldGhcblxuICAgIG1ldGhvZCBzZW5kX2J1ZmZlciA6IFR5cGVkX2FycmF5LmFycmF5QnVmZmVyIEpzLnQgLT4gdW5pdCBKcy5tZXRoXG5cbiAgICBtZXRob2Qgc2VuZF9ibG9iIDogRmlsZS5ibG9iIEpzLnQgLT4gdW5pdCBKcy5tZXRoXG4gIGVuZFxuXG5sZXQgd2ViU29ja2V0ID0gSnMuVW5zYWZlLmdsb2JhbCMjLl9XZWJTb2NrZXRcblxubGV0IHdlYlNvY2tldF93aXRoUHJvdG9jb2wgPSB3ZWJTb2NrZXRcblxubGV0IHdlYlNvY2tldF93aXRoUHJvdG9jb2xzID0gd2ViU29ja2V0XG5cbmxldCBpc19zdXBwb3J0ZWQgKCkgPSBKcy5PcHRkZWYudGVzdCB3ZWJTb2NrZXRcbiIsIigqIEpzX29mX29jYW1sIGxpYnJhcnlcbiAqIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTIgSsOpcsO0bWUgVm91aWxsb25cbiAqIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4gKiBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICogRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbiAqKVxuXG5vcGVuIEpzXG5vcGVuISBJbXBvcnRcblxuKCoqIDUuMSBUeXBlcyAqKVxuXG50eXBlIHNpemVpID0gaW50XG5cbnR5cGUgc2l6ZWlwdHIgPSBpbnRcblxudHlwZSBpbnRwdHIgPSBpbnRcblxudHlwZSB1aW50ID0gaW50XG5cbnR5cGUgY2xhbXBmID0gZmxvYXRcblxudHlwZSB2b2lkXG5cbnR5cGUgY2xlYXJCdWZmZXJNYXNrID0gaW50XG5cbnR5cGUgYmVnaW5Nb2RlXG5cbnR5cGUgYmxlbmRpbmdGYWN0b3JcblxudHlwZSBibGVuZE1vZGVcblxudHlwZSBidWZmZXJUYXJnZXRcblxudHlwZSBidWZmZXJVc2FnZVxuXG50eXBlIGN1bGxGYWNlTW9kZVxuXG50eXBlIGRlcHRoRnVuY3Rpb25cblxudHlwZSBlbmFibGVDYXBcblxudHlwZSBlcnJvckNvZGVcblxudHlwZSBmcm9udEZhY2VEaXJcblxudHlwZSBoaW50VGFyZ2V0XG5cbnR5cGUgaGludE1vZGVcblxudHlwZSB0ZXh0dXJlVW5pdCA9IGludFxuXG50eXBlICdhIHBpeGVsU3RvcmVQYXJhbVxuXG50eXBlIHN0ZW5jaWxPcFxuXG50eXBlIGZiVGFyZ2V0XG5cbnR5cGUgYXR0YWNobWVudFBvaW50XG5cbnR5cGUgcmJUYXJnZXRcblxudHlwZSB0ZXhUYXJnZXRcblxudHlwZSAnYSBwYXJhbWV0ZXJcblxudHlwZSAnYSBidWZmZXJQYXJhbWV0ZXJcblxudHlwZSAnYSB2ZXJ0ZXhBdHRyaWJQYXJhbVxuXG50eXBlIHZlcnRleEF0dHJpYlBvaW50ZXJQYXJhbVxuXG50eXBlICdhIGF0dGFjaFBhcmFtXG5cbnR5cGUgZnJhbWVidWZmZXJTdGF0dXNcblxudHlwZSAnYSByZW5kZXJidWZmZXJQYXJhbVxuXG50eXBlIGZvcm1hdFxuXG50eXBlIHBpeGVsRm9ybWF0XG5cbnR5cGUgcGl4ZWxUeXBlXG5cbnR5cGUgJ2EgdGV4UGFyYW1cblxudHlwZSBkYXRhVHlwZVxuXG50eXBlIHNoYWRlclR5cGVcblxudHlwZSAnYSBwcm9ncmFtUGFyYW1cblxudHlwZSAnYSBzaGFkZXJQYXJhbVxuXG50eXBlIHRleHR1cmVGaWx0ZXJcblxudHlwZSB3cmFwTW9kZVxuXG50eXBlIHRleEZpbHRlclxuXG50eXBlIHVuaWZvcm1UeXBlXG5cbnR5cGUgY29sb3JzcGFjZUNvbnZlcnNpb25cblxudHlwZSBzaGFkZXJQcmVjaXNpb25UeXBlXG5cbnR5cGUgb2JqZWN0VHlwZVxuXG4oKiogNS4yIFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMgKilcbmNsYXNzIHR5cGUgY29udGV4dEF0dHJpYnV0ZXMgPVxuICBvYmplY3RcbiAgICBtZXRob2QgYWxwaGEgOiBib29sIHQgcHJvcFxuXG4gICAgbWV0aG9kIGRlcHRoIDogYm9vbCB0IHByb3BcblxuICAgIG1ldGhvZCBzdGVuY2lsIDogYm9vbCB0IHByb3BcblxuICAgIG1ldGhvZCBhbnRpYWxpYXMgOiBib29sIHQgcHJvcFxuXG4gICAgbWV0aG9kIHByZW11bHRpcGxpZWRBbHBoYSA6IGJvb2wgdCBwcm9wXG5cbiAgICBtZXRob2QgcHJlc2VydmVEcmF3aW5nQnVmZmVyIDogYm9vbCB0IHByb3BcblxuICAgIG1ldGhvZCBwcmVmZXJMb3dQb3dlclRvSGlnaFBlcmZvcm1hbmNlIDogYm9vbCB0IHByb3BcblxuICAgIG1ldGhvZCBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0IDogYm9vbCB0IHByb3BcbiAgZW5kXG5cbmxldCBkZWZhdWx0Q29udGV4dEF0dHJpYnV0ZXMgPVxuICBKcy5VbnNhZmUuKFxuICAgIG9ialxuICAgICAgW3wgXCJhbHBoYVwiLCBpbmplY3QgX3RydWVcbiAgICAgICA7IFwiZGVwdGhcIiwgaW5qZWN0IF90cnVlXG4gICAgICAgOyBcInN0ZW5jaWxcIiwgaW5qZWN0IF9mYWxzZVxuICAgICAgIDsgXCJhbnRpYWxpYXNcIiwgaW5qZWN0IF90cnVlXG4gICAgICAgOyBcInByZW11bHRpcGxpZWRBbHBoYVwiLCBpbmplY3QgX2ZhbHNlXG4gICAgICAgOyBcInByZXNlcnZlRHJhd2luZ0J1ZmZlclwiLCBpbmplY3QgX2ZhbHNlXG4gICAgICAgOyBcInByZWZlckxvd1Bvd2VyVG9IaWdoUGVyZm9ybWFuY2VcIiwgaW5qZWN0IF9mYWxzZVxuICAgICAgIDsgXCJmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0XCIsIGluamVjdCBfZmFsc2VcbiAgICAgIHxdKVxuXG50eXBlIGJ1ZmZlclxuXG50eXBlIGZyYW1lYnVmZmVyXG5cbnR5cGUgcHJvZ3JhbVxuXG50eXBlIHJlbmRlcmJ1ZmZlclxuXG50eXBlIHNoYWRlclxuXG50eXBlIHRleHR1cmVcblxudHlwZSAnYSB1bmlmb3JtTG9jYXRpb25cblxuY2xhc3MgdHlwZSBhY3RpdmVJbmZvID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIHNpemUgOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF90eXBlIDogdW5pZm9ybVR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG5hbWUgOiBqc19zdHJpbmcgdCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIHNoYWRlclByZWNpc2lvbkZvcm1hdCA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCByYW5nZU1pbiA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgcmFuZ2VNYXggOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHByZWNpc2lvbiA6IGludCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIHJlbmRlcmluZ0NvbnRleHQgPVxuICBvYmplY3RcblxuICAgICgqKiA1LjEzLjEgQXR0cmlidXRlcyAqKVxuXG4gICAgbWV0aG9kIGNhbnZhcyA6IERvbV9odG1sLmNhbnZhc0VsZW1lbnQgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgZHJhd2luZ0J1ZmZlcldpZHRoIDogc2l6ZWkgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGRyYXdpbmdCdWZmZXJIZWlnaHQgOiBzaXplaSByZWFkb25seV9wcm9wXG5cbiAgICAoKiogNS4xMy4yIEdldHRpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvbnRleHQgKilcblxuICAgIG1ldGhvZCBnZXRDb250ZXh0QXR0cmlidXRlcyA6IGNvbnRleHRBdHRyaWJ1dGVzIHQgbWV0aFxuXG4gICAgKCoqIDUuMTMuMyBTZXR0aW5nIGFuZCBnZXR0aW5nIHN0YXRlICopXG5cbiAgICBtZXRob2QgYWN0aXZlVGV4dHVyZSA6IHRleHR1cmVVbml0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGJsZW5kQ29sb3IgOiBjbGFtcGYgLT4gY2xhbXBmIC0+IGNsYW1wZiAtPiBjbGFtcGYgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgYmxlbmRFcXVhdGlvbiA6IGJsZW5kTW9kZSAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBibGVuZEVxdWF0aW9uU2VwYXJhdGUgOiBibGVuZE1vZGUgLT4gYmxlbmRNb2RlIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGJsZW5kRnVuYyA6IGJsZW5kaW5nRmFjdG9yIC0+IGJsZW5kaW5nRmFjdG9yIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGJsZW5kRnVuY1NlcGFyYXRlIDpcbiAgICAgIGJsZW5kaW5nRmFjdG9yIC0+IGJsZW5kaW5nRmFjdG9yIC0+IGJsZW5kaW5nRmFjdG9yIC0+IGJsZW5kaW5nRmFjdG9yIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGNsZWFyQ29sb3IgOiBjbGFtcGYgLT4gY2xhbXBmIC0+IGNsYW1wZiAtPiBjbGFtcGYgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY2xlYXJEZXB0aCA6IGNsYW1wZiAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBjbGVhclN0ZW5jaWwgOiBpbnQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY29sb3JNYXNrIDogYm9vbCB0IC0+IGJvb2wgdCAtPiBib29sIHQgLT4gYm9vbCB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGN1bGxGYWNlIDogY3VsbEZhY2VNb2RlIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGRlcHRoRnVuYyA6IGRlcHRoRnVuY3Rpb24gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZGVwdGhNYXNrIDogYm9vbCB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGRlcHRoUmFuZ2UgOiBjbGFtcGYgLT4gY2xhbXBmIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGRpc2FibGUgOiBlbmFibGVDYXAgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZW5hYmxlIDogZW5hYmxlQ2FwIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGZyb250RmFjZSA6IGZyb250RmFjZURpciAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRQYXJhbWV0ZXIgOiAnYS4gJ2EgcGFyYW1ldGVyIC0+ICdhIG1ldGhcblxuICAgIG1ldGhvZCBnZXRFcnJvciA6IGVycm9yQ29kZSBtZXRoXG5cbiAgICBtZXRob2QgaGludCA6IGhpbnRUYXJnZXQgLT4gaGludE1vZGUgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgaXNFbmFibGVkIDogZW5hYmxlQ2FwIC0+IGJvb2wgdCBtZXRoXG5cbiAgICBtZXRob2QgbGluZVdpZHRoIDogZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgcGl4ZWxTdG9yZWkgOiAnYS4gJ2EgcGl4ZWxTdG9yZVBhcmFtIC0+ICdhIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHBvbHlnb25PZmZzZXQgOiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzYW1wbGVDb3ZlcmFnZSA6IGNsYW1wZiAtPiBib29sIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc3RlbmNpbEZ1bmMgOiBkZXB0aEZ1bmN0aW9uIC0+IGludCAtPiB1aW50IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHN0ZW5jaWxGdW5jU2VwYXJhdGUgOiBjdWxsRmFjZU1vZGUgLT4gZGVwdGhGdW5jdGlvbiAtPiBpbnQgLT4gdWludCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzdGVuY2lsTWFzayA6IHVpbnQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc3RlbmNpbE1hc2tTZXBhcmF0ZSA6IGN1bGxGYWNlTW9kZSAtPiB1aW50IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHN0ZW5jaWxPcCA6IHN0ZW5jaWxPcCAtPiBzdGVuY2lsT3AgLT4gc3RlbmNpbE9wIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHN0ZW5jaWxPcFNlcGFyYXRlIDpcbiAgICAgIGN1bGxGYWNlTW9kZSAtPiBzdGVuY2lsT3AgLT4gc3RlbmNpbE9wIC0+IHN0ZW5jaWxPcCAtPiB1bml0IG1ldGhcblxuICAgICgqKiA1LjEzLjQgVmlld2luZyBhbmQgY2xpcHBpbmcgKilcblxuICAgIG1ldGhvZCBzY2lzc29yIDogaW50IC0+IGludCAtPiBzaXplaSAtPiBzaXplaSAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB2aWV3cG9ydCA6IGludCAtPiBpbnQgLT4gc2l6ZWkgLT4gc2l6ZWkgLT4gdW5pdCBtZXRoXG5cbiAgICAoKiogNS4xMy41IEJ1ZmZlciBvYmplY3RzICopXG5cbiAgICBtZXRob2QgYmluZEJ1ZmZlciA6IGJ1ZmZlclRhcmdldCAtPiBidWZmZXIgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBiaW5kQnVmZmVyXyA6IGJ1ZmZlclRhcmdldCAtPiBidWZmZXIgdCBvcHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgYnVmZmVyRGF0YV9jcmVhdGUgOiBidWZmZXJUYXJnZXQgLT4gc2l6ZWlwdHIgLT4gYnVmZmVyVXNhZ2UgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgYnVmZmVyRGF0YSA6XG4gICAgICBidWZmZXJUYXJnZXQgLT4gI1R5cGVkX2FycmF5LmFycmF5QnVmZmVyVmlldyB0IC0+IGJ1ZmZlclVzYWdlIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGJ1ZmZlckRhdGFfcmF3IDpcbiAgICAgIGJ1ZmZlclRhcmdldCAtPiBUeXBlZF9hcnJheS5hcnJheUJ1ZmZlciB0IC0+IGJ1ZmZlclVzYWdlIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGJ1ZmZlclN1YkRhdGEgOlxuICAgICAgYnVmZmVyVGFyZ2V0IC0+IGludHB0ciAtPiAjVHlwZWRfYXJyYXkuYXJyYXlCdWZmZXJWaWV3IHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgYnVmZmVyU3ViRGF0YV9yYXcgOlxuICAgICAgYnVmZmVyVGFyZ2V0IC0+IGludHB0ciAtPiBUeXBlZF9hcnJheS5hcnJheUJ1ZmZlciB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGNyZWF0ZUJ1ZmZlciA6IGJ1ZmZlciB0IG1ldGhcblxuICAgIG1ldGhvZCBkZWxldGVCdWZmZXIgOiBidWZmZXIgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRCdWZmZXJQYXJhbWV0ZXIgOiAnYS4gYnVmZmVyVGFyZ2V0IC0+ICdhIGJ1ZmZlclBhcmFtZXRlciAtPiAnYSBtZXRoXG5cbiAgICBtZXRob2QgaXNCdWZmZXIgOiBidWZmZXIgdCAtPiBib29sIHQgbWV0aFxuXG4gICAgKCoqIDUuMTMuNiBGcmFtZWJ1ZmZlciBvYmplY3RzICopXG5cbiAgICBtZXRob2QgYmluZEZyYW1lYnVmZmVyIDogZmJUYXJnZXQgLT4gZnJhbWVidWZmZXIgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBiaW5kRnJhbWVidWZmZXJfIDogZmJUYXJnZXQgLT4gZnJhbWVidWZmZXIgdCBvcHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyA6IGZiVGFyZ2V0IC0+IGZyYW1lYnVmZmVyU3RhdHVzIG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVGcmFtZWJ1ZmZlciA6IGZyYW1lYnVmZmVyIHQgbWV0aFxuXG4gICAgbWV0aG9kIGRlbGV0ZUZyYW1lYnVmZmVyIDogZnJhbWVidWZmZXIgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBmcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciA6XG4gICAgICBmYlRhcmdldCAtPiBhdHRhY2htZW50UG9pbnQgLT4gcmJUYXJnZXQgLT4gcmVuZGVyYnVmZmVyIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZnJhbWVidWZmZXJUZXh0dXJlMkQgOlxuICAgICAgZmJUYXJnZXQgLT4gYXR0YWNobWVudFBvaW50IC0+IHRleFRhcmdldCAtPiB0ZXh0dXJlIHQgLT4gaW50IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGdldEZyYW1lYnVmZmVyQXR0YWNobWVudFBhcmFtZXRlciA6XG4gICAgICAnYS4gZmJUYXJnZXQgLT4gYXR0YWNobWVudFBvaW50IC0+ICdhIGF0dGFjaFBhcmFtIC0+ICdhIG1ldGhcblxuICAgIG1ldGhvZCBpc0ZyYW1lYnVmZmVyIDogZnJhbWVidWZmZXIgdCAtPiBib29sIHQgbWV0aFxuXG4gICAgKCoqIDUuMTMuNyBSZW5kZXJidWZmZXIgb2JqZWN0cyAqKVxuXG4gICAgbWV0aG9kIGJpbmRSZW5kZXJidWZmZXIgOiByYlRhcmdldCAtPiByZW5kZXJidWZmZXIgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBiaW5kUmVuZGVyYnVmZmVyXyA6IHJiVGFyZ2V0IC0+IHJlbmRlcmJ1ZmZlciB0IG9wdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVSZW5kZXJidWZmZXIgOiByZW5kZXJidWZmZXIgdCBtZXRoXG5cbiAgICBtZXRob2QgZGVsZXRlUmVuZGVyYnVmZmVyIDogcmVuZGVyYnVmZmVyIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0UmVuZGVyYnVmZmVyUGFyYW1ldGVyIDogJ2EuIHJiVGFyZ2V0IC0+ICdhIHJlbmRlcmJ1ZmZlclBhcmFtIC0+ICdhIG1ldGhcblxuICAgIG1ldGhvZCBpc1JlbmRlcmJ1ZmZlciA6IHJlbmRlcmJ1ZmZlciB0IC0+IGJvb2wgdCBtZXRoXG5cbiAgICBtZXRob2QgcmVuZGVyYnVmZmVyU3RvcmFnZSA6IHJiVGFyZ2V0IC0+IGZvcm1hdCAtPiBzaXplaSAtPiBzaXplaSAtPiB1bml0IG1ldGhcblxuICAgICgqKiA1LjEzLjggVGV4dHVyZSBvYmplY3RzICopXG5cbiAgICBtZXRob2QgYmluZFRleHR1cmUgOiB0ZXhUYXJnZXQgLT4gdGV4dHVyZSB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGJpbmRUZXh0dXJlXyA6IHRleFRhcmdldCAtPiB0ZXh0dXJlIHQgb3B0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGNvbXByZXNzZWRUZXhJbWFnZTJEIDpcbiAgICAgICAgIHRleFRhcmdldFxuICAgICAgLT4gaW50XG4gICAgICAtPiBwaXhlbEZvcm1hdFxuICAgICAgLT4gc2l6ZWlcbiAgICAgIC0+IHNpemVpXG4gICAgICAtPiBpbnRcbiAgICAgIC0+ICNUeXBlZF9hcnJheS5hcnJheUJ1ZmZlclZpZXcgdFxuICAgICAgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY29tcHJlc3NlZFRleFN1YkltYWdlMkQgOlxuICAgICAgICAgdGV4VGFyZ2V0XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiBzaXplaVxuICAgICAgLT4gc2l6ZWlcbiAgICAgIC0+IHBpeGVsRm9ybWF0XG4gICAgICAtPiAjVHlwZWRfYXJyYXkuYXJyYXlCdWZmZXJWaWV3IHRcbiAgICAgIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGNvcHlUZXhJbWFnZTJEIDpcbiAgICAgIHRleFRhcmdldCAtPiBpbnQgLT4gcGl4ZWxGb3JtYXQgLT4gaW50IC0+IGludCAtPiBzaXplaSAtPiBzaXplaSAtPiBpbnQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY29weVRleFN1YkltYWdlMkQgOlxuICAgICAgdGV4VGFyZ2V0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gc2l6ZWkgLT4gc2l6ZWkgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY3JlYXRlVGV4dHVyZSA6IHRleHR1cmUgdCBtZXRoXG5cbiAgICBtZXRob2QgZGVsZXRlVGV4dHVyZSA6IHRleHR1cmUgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBnZW5lcmF0ZU1pcG1hcCA6IHRleFRhcmdldCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRUZXhQYXJhbWV0ZXIgOiB0ZXhUYXJnZXQgLT4gJ2EgdGV4UGFyYW0gLT4gJ2EgbWV0aFxuXG4gICAgbWV0aG9kIGlzVGV4dHVyZSA6IHRleHR1cmUgdCAtPiBib29sIHQgbWV0aFxuXG4gICAgbWV0aG9kIHRleEltYWdlMkRfbmV3IDpcbiAgICAgICAgIHRleFRhcmdldFxuICAgICAgLT4gaW50XG4gICAgICAtPiBwaXhlbEZvcm1hdFxuICAgICAgLT4gc2l6ZWlcbiAgICAgIC0+IHNpemVpXG4gICAgICAtPiBpbnRcbiAgICAgIC0+IHBpeGVsRm9ybWF0XG4gICAgICAtPiBwaXhlbFR5cGVcbiAgICAgIC0+IHZvaWQgb3B0XG4gICAgICAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB0ZXhJbWFnZTJEX2Zyb21WaWV3IDpcbiAgICAgICAgIHRleFRhcmdldFxuICAgICAgLT4gaW50XG4gICAgICAtPiBwaXhlbEZvcm1hdFxuICAgICAgLT4gc2l6ZWlcbiAgICAgIC0+IHNpemVpXG4gICAgICAtPiBpbnRcbiAgICAgIC0+IHBpeGVsRm9ybWF0XG4gICAgICAtPiBwaXhlbFR5cGVcbiAgICAgIC0+ICNUeXBlZF9hcnJheS5hcnJheUJ1ZmZlclZpZXcgdFxuICAgICAgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdGV4SW1hZ2UyRF9mcm9tSW1hZ2VEYXRhIDpcbiAgICAgICAgIHRleFRhcmdldFxuICAgICAgLT4gaW50XG4gICAgICAtPiBwaXhlbEZvcm1hdFxuICAgICAgLT4gcGl4ZWxGb3JtYXRcbiAgICAgIC0+IHBpeGVsVHlwZVxuICAgICAgLT4gRG9tX2h0bWwuaW1hZ2VEYXRhIHRcbiAgICAgIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHRleEltYWdlMkRfZnJvbUltYWdlIDpcbiAgICAgICAgIHRleFRhcmdldFxuICAgICAgLT4gaW50XG4gICAgICAtPiBwaXhlbEZvcm1hdFxuICAgICAgLT4gcGl4ZWxGb3JtYXRcbiAgICAgIC0+IHBpeGVsVHlwZVxuICAgICAgLT4gRG9tX2h0bWwuaW1hZ2VFbGVtZW50IHRcbiAgICAgIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHRleEltYWdlMkRfZnJvbUNhbnZhcyA6XG4gICAgICAgICB0ZXhUYXJnZXRcbiAgICAgIC0+IGludFxuICAgICAgLT4gcGl4ZWxGb3JtYXRcbiAgICAgIC0+IHBpeGVsRm9ybWF0XG4gICAgICAtPiBwaXhlbFR5cGVcbiAgICAgIC0+IERvbV9odG1sLmNhbnZhc0VsZW1lbnQgdFxuICAgICAgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdGV4SW1hZ2UyRF9mcm9tVmlkZW8gOlxuICAgICAgICAgdGV4VGFyZ2V0XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IHBpeGVsRm9ybWF0XG4gICAgICAtPiBwaXhlbEZvcm1hdFxuICAgICAgLT4gcGl4ZWxUeXBlXG4gICAgICAtPiBEb21faHRtbC52aWRlb0VsZW1lbnQgdFxuICAgICAgLT4gdW5pdCBtZXRoXG5cbiAgICAoKiB7W1xuICAgICAgICBtZXRob2QgdGV4UGFyYW1ldGVyZiA6IHRleFRhcmdldCAtPiB0ZXhQYXJhbSAtPiBmbG9hdCAtPiB1bml0IG1ldGhcbiAgICAgICBdfVxuICAgICopXG4gICAgbWV0aG9kIHRleFBhcmFtZXRlcmkgOiB0ZXhUYXJnZXQgLT4gJ2EgdGV4UGFyYW0gLT4gJ2EgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdGV4U3ViSW1hZ2UyRF9mcm9tVmlldyA6XG4gICAgICAgICB0ZXhUYXJnZXRcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IHNpemVpXG4gICAgICAtPiBzaXplaVxuICAgICAgLT4gcGl4ZWxGb3JtYXRcbiAgICAgIC0+IHBpeGVsVHlwZVxuICAgICAgLT4gI1R5cGVkX2FycmF5LmFycmF5QnVmZmVyVmlldyB0XG4gICAgICAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB0ZXhTdWJJbWFnZTJEX2Zyb21JbWFnZURhdGEgOlxuICAgICAgICAgdGV4VGFyZ2V0XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiBwaXhlbEZvcm1hdFxuICAgICAgLT4gcGl4ZWxUeXBlXG4gICAgICAtPiBEb21faHRtbC5pbWFnZURhdGEgdFxuICAgICAgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdGV4U3ViSW1hZ2UyRF9mcm9tSW1hZ2UgOlxuICAgICAgICAgdGV4VGFyZ2V0XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiBwaXhlbEZvcm1hdFxuICAgICAgLT4gcGl4ZWxUeXBlXG4gICAgICAtPiBEb21faHRtbC5pbWFnZUVsZW1lbnQgdFxuICAgICAgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdGV4U3ViSW1hZ2UyRF9mcm9tQ2FudmFzIDpcbiAgICAgICAgIHRleFRhcmdldFxuICAgICAgLT4gaW50XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gcGl4ZWxGb3JtYXRcbiAgICAgIC0+IHBpeGVsVHlwZVxuICAgICAgLT4gRG9tX2h0bWwuY2FudmFzRWxlbWVudCB0XG4gICAgICAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB0ZXhTdWJJbWFnZTJEX2Zyb21WaWRlbyA6XG4gICAgICAgICB0ZXhUYXJnZXRcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IHBpeGVsRm9ybWF0XG4gICAgICAtPiBwaXhlbFR5cGVcbiAgICAgIC0+IERvbV9odG1sLnZpZGVvRWxlbWVudCB0XG4gICAgICAtPiB1bml0IG1ldGhcblxuICAgICgqKiA1LjEzLjkgUHJvZ3JhbXMgYW5kIFNoYWRlcnMgKilcblxuICAgIG1ldGhvZCBhdHRhY2hTaGFkZXIgOiBwcm9ncmFtIHQgLT4gc2hhZGVyIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgYmluZEF0dHJpYkxvY2F0aW9uIDogcHJvZ3JhbSB0IC0+IHVpbnQgLT4ganNfc3RyaW5nIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY29tcGlsZVNoYWRlciA6IHNoYWRlciB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGNyZWF0ZVByb2dyYW0gOiBwcm9ncmFtIHQgbWV0aFxuXG4gICAgbWV0aG9kIGNyZWF0ZVNoYWRlciA6IHNoYWRlclR5cGUgLT4gc2hhZGVyIHQgbWV0aFxuXG4gICAgbWV0aG9kIGRlbGV0ZVByb2dyYW0gOiBwcm9ncmFtIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZGVsZXRlU2hhZGVyIDogc2hhZGVyIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZGV0YWNoU2hhZGVyIDogcHJvZ3JhbSB0IC0+IHNoYWRlciB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGdldEF0dGFjaGVkU2hhZGVycyA6IHByb2dyYW0gdCAtPiBzaGFkZXIgdCBqc19hcnJheSB0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRQcm9ncmFtUGFyYW1ldGVyIDogJ2EuIHByb2dyYW0gdCAtPiAnYSBwcm9ncmFtUGFyYW0gLT4gJ2EgbWV0aFxuXG4gICAgbWV0aG9kIGdldFByb2dyYW1JbmZvTG9nIDogcHJvZ3JhbSB0IC0+IGpzX3N0cmluZyB0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRTaGFkZXJQYXJhbWV0ZXIgOiAnYS4gc2hhZGVyIHQgLT4gJ2Egc2hhZGVyUGFyYW0gLT4gJ2EgbWV0aFxuXG4gICAgbWV0aG9kIGdldFNoYWRlclByZWNpc2lvbkZvcm1hdCA6XG4gICAgICBzaGFkZXJUeXBlIC0+IHNoYWRlclByZWNpc2lvblR5cGUgLT4gc2hhZGVyUHJlY2lzaW9uRm9ybWF0IHQgbWV0aFxuXG4gICAgbWV0aG9kIGdldFNoYWRlckluZm9Mb2cgOiBzaGFkZXIgdCAtPiBqc19zdHJpbmcgdCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0U2hhZGVyU291cmNlIDogc2hhZGVyIHQgLT4ganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIGlzUHJvZ3JhbSA6IHByb2dyYW0gdCAtPiBib29sIHQgbWV0aFxuXG4gICAgbWV0aG9kIGlzU2hhZGVyIDogc2hhZGVyIHQgLT4gYm9vbCB0IG1ldGhcblxuICAgIG1ldGhvZCBsaW5rUHJvZ3JhbSA6IHByb2dyYW0gdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzaGFkZXJTb3VyY2UgOiBzaGFkZXIgdCAtPiBqc19zdHJpbmcgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB1c2VQcm9ncmFtIDogcHJvZ3JhbSB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHZhbGlkYXRlUHJvZ3JhbSA6IHByb2dyYW0gdCAtPiB1bml0IG1ldGhcblxuICAgICgqKiA1LjEzLjEwIFVuaWZvcm1zIGFuZCBhdHRyaWJ1dGVzICopXG5cbiAgICBtZXRob2QgZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5IDogdWludCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSA6IHVpbnQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0QWN0aXZlQXR0cmliIDogcHJvZ3JhbSB0IC0+IHVpbnQgLT4gYWN0aXZlSW5mbyB0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRBY3RpdmVVbmlmb3JtIDogcHJvZ3JhbSB0IC0+IHVpbnQgLT4gYWN0aXZlSW5mbyB0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRBdHRyaWJMb2NhdGlvbiA6IHByb2dyYW0gdCAtPiBqc19zdHJpbmcgdCAtPiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIGdldFVuaWZvcm0gOiAnYSAnYi4gcHJvZ3JhbSB0IC0+ICdhIHVuaWZvcm1Mb2NhdGlvbiB0IC0+ICdiIG1ldGhcblxuICAgIG1ldGhvZCBnZXRVbmlmb3JtTG9jYXRpb24gOiAnYS4gcHJvZ3JhbSB0IC0+IGpzX3N0cmluZyB0IC0+ICdhIHVuaWZvcm1Mb2NhdGlvbiB0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRWZXJ0ZXhBdHRyaWIgOiAnYS4gdWludCAtPiAnYSB2ZXJ0ZXhBdHRyaWJQYXJhbSAtPiAnYSBtZXRoXG5cbiAgICBtZXRob2QgZ2V0VmVydGV4QXR0cmliT2Zmc2V0IDogdWludCAtPiB2ZXJ0ZXhBdHRyaWJQb2ludGVyUGFyYW0gLT4gc2l6ZWlwdHIgbWV0aFxuXG4gICAgbWV0aG9kIHVuaWZvcm0xZiA6IGZsb2F0IHVuaWZvcm1Mb2NhdGlvbiB0IC0+IGZsb2F0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHVuaWZvcm0xZnZfdHlwZWQgOlxuICAgICAgZmxvYXQgdW5pZm9ybUxvY2F0aW9uIHQgLT4gVHlwZWRfYXJyYXkuZmxvYXQzMkFycmF5IHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdW5pZm9ybTFmdiA6IGZsb2F0IHVuaWZvcm1Mb2NhdGlvbiB0IC0+IGZsb2F0IGpzX2FycmF5IHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdW5pZm9ybTFpIDogaW50IHVuaWZvcm1Mb2NhdGlvbiB0IC0+IGludCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB1bmlmb3JtMWl2X3R5cGVkIDpcbiAgICAgIGludCB1bmlmb3JtTG9jYXRpb24gdCAtPiBUeXBlZF9hcnJheS5pbnQzMkFycmF5IHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdW5pZm9ybTFpdiA6IGludCB1bmlmb3JtTG9jYXRpb24gdCAtPiBpbnQganNfYXJyYXkgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB1bmlmb3JtMmYgOiBbIGB2ZWMyIF0gdW5pZm9ybUxvY2F0aW9uIHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdW5pZm9ybTJmdl90eXBlZCA6XG4gICAgICBbIGB2ZWMyIF0gdW5pZm9ybUxvY2F0aW9uIHQgLT4gVHlwZWRfYXJyYXkuZmxvYXQzMkFycmF5IHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdW5pZm9ybTJmdiA6IFsgYHZlYzIgXSB1bmlmb3JtTG9jYXRpb24gdCAtPiBmbG9hdCBqc19hcnJheSB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHVuaWZvcm0yaSA6IFsgYGl2ZWMyIF0gdW5pZm9ybUxvY2F0aW9uIHQgLT4gaW50IC0+IGludCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB1bmlmb3JtMml2IDogWyBgaXZlYzIgXSB1bmlmb3JtTG9jYXRpb24gdCAtPiBpbnQganNfYXJyYXkgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB1bmlmb3JtMml2X3R5cGVkIDpcbiAgICAgIFsgYGl2ZWMyIF0gdW5pZm9ybUxvY2F0aW9uIHQgLT4gVHlwZWRfYXJyYXkuaW50MzJBcnJheSB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHVuaWZvcm0zZiA6IFsgYHZlYzMgXSB1bmlmb3JtTG9jYXRpb24gdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB1bmlmb3JtM2Z2X3R5cGVkIDpcbiAgICAgIFsgYHZlYzMgXSB1bmlmb3JtTG9jYXRpb24gdCAtPiBUeXBlZF9hcnJheS5mbG9hdDMyQXJyYXkgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB1bmlmb3JtM2Z2IDogWyBgdmVjMyBdIHVuaWZvcm1Mb2NhdGlvbiB0IC0+IGZsb2F0IGpzX2FycmF5IHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdW5pZm9ybTNpIDogWyBgaXZlYzMgXSB1bmlmb3JtTG9jYXRpb24gdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB1bmlmb3JtM2l2IDogWyBgaXZlYzMgXSB1bmlmb3JtTG9jYXRpb24gdCAtPiBpbnQganNfYXJyYXkgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB1bmlmb3JtM2l2X3R5cGVkIDpcbiAgICAgIFsgYGl2ZWMzIF0gdW5pZm9ybUxvY2F0aW9uIHQgLT4gVHlwZWRfYXJyYXkuaW50MzJBcnJheSB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHVuaWZvcm00ZiA6XG4gICAgICBbIGB2ZWM0IF0gdW5pZm9ybUxvY2F0aW9uIHQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdW5pZm9ybTRmdl90eXBlZCA6XG4gICAgICBbIGB2ZWM0IF0gdW5pZm9ybUxvY2F0aW9uIHQgLT4gVHlwZWRfYXJyYXkuZmxvYXQzMkFycmF5IHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdW5pZm9ybTRmdiA6IFsgYHZlYzQgXSB1bmlmb3JtTG9jYXRpb24gdCAtPiBmbG9hdCBqc19hcnJheSB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHVuaWZvcm00aSA6XG4gICAgICBbIGBpdmVjNCBdIHVuaWZvcm1Mb2NhdGlvbiB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB1bmlmb3JtNGl2IDogWyBgaXZlYzQgXSB1bmlmb3JtTG9jYXRpb24gdCAtPiBpbnQganNfYXJyYXkgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB1bmlmb3JtNGl2X3R5cGVkIDpcbiAgICAgIFsgYGl2ZWM0IF0gdW5pZm9ybUxvY2F0aW9uIHQgLT4gVHlwZWRfYXJyYXkuaW50MzJBcnJheSB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHVuaWZvcm1NYXRyaXgyZnYgOlxuICAgICAgWyBgbWF0MiBdIHVuaWZvcm1Mb2NhdGlvbiB0IC0+IGJvb2wgdCAtPiBmbG9hdCBqc19hcnJheSB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHVuaWZvcm1NYXRyaXgyZnZfdHlwZWQgOlxuICAgICAgWyBgbWF0MiBdIHVuaWZvcm1Mb2NhdGlvbiB0IC0+IGJvb2wgdCAtPiBUeXBlZF9hcnJheS5mbG9hdDMyQXJyYXkgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB1bmlmb3JtTWF0cml4M2Z2IDpcbiAgICAgIFsgYG1hdDMgXSB1bmlmb3JtTG9jYXRpb24gdCAtPiBib29sIHQgLT4gZmxvYXQganNfYXJyYXkgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB1bmlmb3JtTWF0cml4M2Z2X3R5cGVkIDpcbiAgICAgIFsgYG1hdDMgXSB1bmlmb3JtTG9jYXRpb24gdCAtPiBib29sIHQgLT4gVHlwZWRfYXJyYXkuZmxvYXQzMkFycmF5IHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdW5pZm9ybU1hdHJpeDRmdiA6XG4gICAgICBbIGBtYXQ0IF0gdW5pZm9ybUxvY2F0aW9uIHQgLT4gYm9vbCB0IC0+IGZsb2F0IGpzX2FycmF5IHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdW5pZm9ybU1hdHJpeDRmdl90eXBlZCA6XG4gICAgICBbIGBtYXQ0IF0gdW5pZm9ybUxvY2F0aW9uIHQgLT4gYm9vbCB0IC0+IFR5cGVkX2FycmF5LmZsb2F0MzJBcnJheSB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHZlcnRleEF0dHJpYjFmIDogdWludCAtPiBmbG9hdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB2ZXJ0ZXhBdHRyaWIxZnYgOiB1aW50IC0+IGZsb2F0IGpzX2FycmF5IHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdmVydGV4QXR0cmliMWZ2X3R5cGVkIDogdWludCAtPiBUeXBlZF9hcnJheS5mbG9hdDMyQXJyYXkgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB2ZXJ0ZXhBdHRyaWIyZiA6IHVpbnQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdmVydGV4QXR0cmliMmZ2IDogdWludCAtPiBmbG9hdCBqc19hcnJheSB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHZlcnRleEF0dHJpYjJmdl90eXBlZCA6IHVpbnQgLT4gVHlwZWRfYXJyYXkuZmxvYXQzMkFycmF5IHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdmVydGV4QXR0cmliM2YgOiB1aW50IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHZlcnRleEF0dHJpYjNmdiA6IHVpbnQgLT4gZmxvYXQganNfYXJyYXkgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB2ZXJ0ZXhBdHRyaWIzZnZfdHlwZWQgOiB1aW50IC0+IFR5cGVkX2FycmF5LmZsb2F0MzJBcnJheSB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHZlcnRleEF0dHJpYjRmIDogdWludCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB2ZXJ0ZXhBdHRyaWI0ZnYgOiB1aW50IC0+IGZsb2F0IGpzX2FycmF5IHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdmVydGV4QXR0cmliNGZ2X3R5cGVkIDogdWludCAtPiBUeXBlZF9hcnJheS5mbG9hdDMyQXJyYXkgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB2ZXJ0ZXhBdHRyaWJQb2ludGVyIDpcbiAgICAgIHVpbnQgLT4gaW50IC0+IGRhdGFUeXBlIC0+IGJvb2wgdCAtPiBzaXplaSAtPiBpbnRwdHIgLT4gdW5pdCBtZXRoXG5cbiAgICAoKiogNS4xMy4xMSBXcml0aW5nIHRvIHRoZSBkcmF3aW5nIGJ1ZmZlciAqKVxuXG4gICAgbWV0aG9kIGNsZWFyIDogY2xlYXJCdWZmZXJNYXNrIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGRyYXdBcnJheXMgOiBiZWdpbk1vZGUgLT4gaW50IC0+IHNpemVpIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGRyYXdFbGVtZW50cyA6IGJlZ2luTW9kZSAtPiBzaXplaSAtPiBkYXRhVHlwZSAtPiBpbnRwdHIgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZmluaXNoIDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZmx1c2ggOiB1bml0IG1ldGhcblxuICAgICgqKiA1LjEzLjEyIFJlYWRpbmcgYmFjayBwaXhlbHMgKilcblxuICAgIG1ldGhvZCByZWFkUGl4ZWxzIDpcbiAgICAgICAgIGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiBzaXplaVxuICAgICAgLT4gc2l6ZWlcbiAgICAgIC0+IHBpeGVsRm9ybWF0XG4gICAgICAtPiBwaXhlbFR5cGVcbiAgICAgIC0+ICNUeXBlZF9hcnJheS5hcnJheUJ1ZmZlclZpZXcgdFxuICAgICAgLT4gdW5pdCBtZXRoXG5cbiAgICAoKiogNS4xMy4xMyBEZXRlY3RpbmcgY29udGV4dCBsb3N0IGV2ZW50cyAqKVxuXG4gICAgbWV0aG9kIGlzQ29udGV4dExvc3QgOiBib29sIHQgbWV0aFxuXG4gICAgKCoqIDUuMTMuMTQgRGV0ZWN0aW5nIGFuZCBlbmFibGluZyBleHRlbnNpb25zICopXG5cbiAgICBtZXRob2QgZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucyA6IGpzX3N0cmluZyB0IGpzX2FycmF5IHQgbWV0aFxuXG4gICAgbWV0aG9kIGdldEV4dGVuc2lvbiA6ICdhLiBqc19zdHJpbmcgdCAtPiAnYSB0IG9wdCBtZXRoXG5cbiAgICAoKiBVbnR5cGVkISAqKVxuICAgICgqKiBDb25zdGFudHMgKilcblxuICAgIG1ldGhvZCBfREVQVEhfQlVGRkVSX0JJVF8gOiBjbGVhckJ1ZmZlck1hc2sgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9TVEVOQ0lMX0JVRkZFUl9CSVRfIDogY2xlYXJCdWZmZXJNYXNrIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQ09MT1JfQlVGRkVSX0JJVF8gOiBjbGVhckJ1ZmZlck1hc2sgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9QT0lOVFMgOiBiZWdpbk1vZGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9MSU5FUyA6IGJlZ2luTW9kZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0xJTkVfTE9PUF8gOiBiZWdpbk1vZGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9MSU5FX1NUUklQXyA6IGJlZ2luTW9kZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RSSUFOR0xFUyA6IGJlZ2luTW9kZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RSSUFOR0xFX1NUUklQXyA6IGJlZ2luTW9kZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RSSUFOR0xFX0ZBTl8gOiBiZWdpbk1vZGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9aRVJPIDogYmxlbmRpbmdGYWN0b3IgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9PTkUgOiBibGVuZGluZ0ZhY3RvciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NSQ19DT0xPUl8gOiBibGVuZGluZ0ZhY3RvciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX09ORV9NSU5VU19TUkNfQ09MT1JfIDogYmxlbmRpbmdGYWN0b3IgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9TUkNfQUxQSEFfIDogYmxlbmRpbmdGYWN0b3IgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9PTkVfTUlOVVNfU1JDX0FMUEhBXyA6IGJsZW5kaW5nRmFjdG9yIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfRFNUX0FMUEhBXyA6IGJsZW5kaW5nRmFjdG9yIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfT05FX01JTlVTX0RTVF9BTFBIQV8gOiBibGVuZGluZ0ZhY3RvciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0RTVF9DT0xPUl8gOiBibGVuZGluZ0ZhY3RvciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX09ORV9NSU5VU19EU1RfQ09MT1JfIDogYmxlbmRpbmdGYWN0b3IgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9TUkNfQUxQSEFfU0FUVVJBVEVfIDogYmxlbmRpbmdGYWN0b3IgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9GVU5DX0FERF8gOiBibGVuZE1vZGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9GVU5DX1NVQlRSQUNUXyA6IGJsZW5kTW9kZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0ZVTkNfUkVWRVJTRV9TVUJUUkFDVF8gOiBibGVuZE1vZGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9DT05TVEFOVF9DT0xPUl8gOiBibGVuZE1vZGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9PTkVfTUlOVVNfQ09OU1RBTlRfQ09MT1JfIDogYmxlbmRNb2RlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQ09OU1RBTlRfQUxQSEFfIDogYmxlbmRNb2RlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfT05FX01JTlVTX0NPTlNUQU5UX0FMUEhBXyA6IGJsZW5kTW9kZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0FSUkFZX0JVRkZFUl8gOiBidWZmZXJUYXJnZXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9FTEVNRU5UX0FSUkFZX0JVRkZFUl8gOiBidWZmZXJUYXJnZXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9TVFJFQU1fRFJBV18gOiBidWZmZXJVc2FnZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NUQVRJQ19EUkFXXyA6IGJ1ZmZlclVzYWdlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfRFlOQU1JQ19EUkFXXyA6IGJ1ZmZlclVzYWdlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfRlJPTlQgOiBjdWxsRmFjZU1vZGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9CQUNLIDogY3VsbEZhY2VNb2RlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfRlJPTlRfQU5EX0JBQ0tfIDogY3VsbEZhY2VNb2RlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQ1VMTF9GQUNFXyA6IGVuYWJsZUNhcCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0JMRU5EIDogZW5hYmxlQ2FwIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfRElUSEVSIDogZW5hYmxlQ2FwIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfU1RFTkNJTF9URVNUXyA6IGVuYWJsZUNhcCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0RFUFRIX1RFU1RfIDogZW5hYmxlQ2FwIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfU0NJU1NPUl9URVNUXyA6IGVuYWJsZUNhcCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1BPTFlHT05fT0ZGU0VUX0ZJTExfIDogZW5hYmxlQ2FwIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFXyA6IGVuYWJsZUNhcCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NBTVBMRV9DT1ZFUkFHRV8gOiBlbmFibGVDYXAgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9OT19FUlJPUl8gOiBlcnJvckNvZGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9JTlZBTElEX0VOVU1fIDogZXJyb3JDb2RlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfSU5WQUxJRF9WQUxVRV8gOiBlcnJvckNvZGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9JTlZBTElEX09QRVJBVElPTl8gOiBlcnJvckNvZGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9PVVRfT0ZfTUVNT1JZXyA6IGVycm9yQ29kZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0NPTlRFWFRfTE9TVF9XRUJHTF8gOiBlcnJvckNvZGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9JTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTl8gOiBlcnJvckNvZGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9DVyA6IGZyb250RmFjZURpciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0NDVyA6IGZyb250RmFjZURpciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0RPTlRfQ0FSRV8gOiBoaW50TW9kZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0ZBU1RFU1QgOiBoaW50TW9kZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX05JQ0VTVCA6IGhpbnRNb2RlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfR0VORVJBVEVfTUlQTUFQX0hJTlRfIDogaGludFRhcmdldCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0JMRU5EX0VRVUFUSU9OXyA6IGJsZW5kTW9kZSBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9CTEVORF9FUVVBVElPTl9SR0JfIDogYmxlbmRNb2RlIHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0JMRU5EX0VRVUFUSU9OX0FMUEhBXyA6IGJsZW5kTW9kZSBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9CTEVORF9EU1RfUkdCXyA6IGJsZW5kaW5nRmFjdG9yIHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0JMRU5EX1NSQ19SR0JfIDogYmxlbmRpbmdGYWN0b3IgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQkxFTkRfRFNUX0FMUEhBXyA6IGJsZW5kaW5nRmFjdG9yIHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0JMRU5EX1NSQ19BTFBIQV8gOiBibGVuZGluZ0ZhY3RvciBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9CTEVORF9DT0xPUl8gOiBUeXBlZF9hcnJheS5mbG9hdDMyQXJyYXkgdCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9BUlJBWV9CVUZGRVJfQklORElOR18gOiBidWZmZXIgdCBvcHQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfRUxFTUVOVF9BUlJBWV9CVUZGRVJfQklORElOR18gOiBidWZmZXIgdCBvcHQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQ1VMTF9GQUNFX1BBUkFNIDogYm9vbCB0IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0JMRU5EX1BBUkFNIDogYm9vbCB0IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0RJVEhFUl9QQVJBTSA6IGJvb2wgdCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9TVEVOQ0lMX1RFU1RfUEFSQU0gOiBib29sIHQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfREVQVEhfVEVTVF9QQVJBTSA6IGJvb2wgdCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9TQ0lTU09SX1RFU1RfUEFSQU0gOiBib29sIHQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfUE9MWUdPTl9PRkZTRVRfRklMTF9QQVJBTSA6IGJvb2wgdCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9MSU5FX1dJRFRIXyA6IGZsb2F0IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0FMSUFTRURfUE9JTlRfU0laRV9SQU5HRV8gOiBUeXBlZF9hcnJheS5mbG9hdDMyQXJyYXkgdCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9BTElBU0VEX0xJTkVfV0lEVEhfUkFOR0VfIDogVHlwZWRfYXJyYXkuZmxvYXQzMkFycmF5IHQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQ1VMTF9GQUNFX01PREVfIDogY3VsbEZhY2VNb2RlIHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0ZST05UX0ZBQ0VfIDogZnJvbnRGYWNlRGlyIHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0RFUFRIX1JBTkdFXyA6IFR5cGVkX2FycmF5LmZsb2F0MzJBcnJheSB0IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0RFUFRIX1dSSVRFTUFTS18gOiBib29sIHQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfREVQVEhfQ0xFQVJfVkFMVUVfIDogZmxvYXQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfREVQVEhfRlVOQ18gOiBkZXB0aEZ1bmN0aW9uIHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NURU5DSUxfQ0xFQVJfVkFMVUVfIDogaW50IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NURU5DSUxfRlVOQ18gOiBpbnQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfU1RFTkNJTF9GQUlMXyA6IGludCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9TVEVOQ0lMX1BBU1NfREVQVEhfRkFJTF8gOiBpbnQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfU1RFTkNJTF9QQVNTX0RFUFRIX1BBU1NfIDogaW50IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NURU5DSUxfUkVGXyA6IGludCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9TVEVOQ0lMX1ZBTFVFX01BU0tfIDogaW50IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NURU5DSUxfV1JJVEVNQVNLXyA6IGludCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9TVEVOQ0lMX0JBQ0tfRlVOQ18gOiBpbnQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfU1RFTkNJTF9CQUNLX0ZBSUxfIDogaW50IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NURU5DSUxfQkFDS19QQVNTX0RFUFRIX0ZBSUxfIDogaW50IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NURU5DSUxfQkFDS19QQVNTX0RFUFRIX1BBU1NfIDogaW50IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NURU5DSUxfQkFDS19SRUZfIDogaW50IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NURU5DSUxfQkFDS19WQUxVRV9NQVNLXyA6IGludCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9TVEVOQ0lMX0JBQ0tfV1JJVEVNQVNLXyA6IGludCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9WSUVXUE9SVCA6IFR5cGVkX2FycmF5LmludDMyQXJyYXkgdCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9TQ0lTU09SX0JPWF8gOiBUeXBlZF9hcnJheS5pbnQzMkFycmF5IHQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQ09MT1JfQ0xFQVJfVkFMVUVfIDogVHlwZWRfYXJyYXkuZmxvYXQzMkFycmF5IHQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQ09MT1JfV1JJVEVNQVNLXyA6IGJvb2wgdCBqc19hcnJheSB0IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1VOUEFDS19BTElHTk1FTlRfUEFSQU0gOiBpbnQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfUEFDS19BTElHTk1FTlRfIDogaW50IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX01BWF9URVhUVVJFX1NJWkVfIDogaW50IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX01BWF9WSUVXUE9SVF9ESU1TXyA6IFR5cGVkX2FycmF5LmludDMyQXJyYXkgdCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9TVUJQSVhFTF9CSVRTXyA6IGludCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9SRURfQklUU18gOiBpbnQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfR1JFRU5fQklUU18gOiBpbnQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQkxVRV9CSVRTXyA6IGludCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9BTFBIQV9CSVRTXyA6IGludCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9ERVBUSF9CSVRTXyA6IGludCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9TVEVOQ0lMX0JJVFNfIDogaW50IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1BPTFlHT05fT0ZGU0VUX1VOSVRTXyA6IGZsb2F0IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1BPTFlHT05fT0ZGU0VUX0ZBQ1RPUl8gOiBmbG9hdCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9URVhUVVJFX0JJTkRJTkdfMkRfIDogdGV4dHVyZSB0IG9wdCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9URVhUVVJFX0JJTkRJTkdfQ1VCRV9NQVBfIDogdGV4dHVyZSB0IG9wdCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9TQU1QTEVfQlVGRkVSU18gOiBpbnQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfU0FNUExFU18gOiBpbnQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfU0FNUExFX0NPVkVSQUdFX1ZBTFVFXyA6IGZsb2F0IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NBTVBMRV9DT1ZFUkFHRV9JTlZFUlRfIDogYm9vbCB0IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX05VTV9DT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUU18gOiBpbnQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFNfIDpcbiAgICAgIFR5cGVkX2FycmF5LnVpbnQzMkFycmF5IHQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfR0VORVJBVEVfTUlQTUFQX0hJTlRfUEFSQU1fIDogaGludE1vZGUgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQlVGRkVSX1NJWkVfIDogaW50IGJ1ZmZlclBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0JVRkZFUl9VU0FHRV8gOiBidWZmZXJVc2FnZSBidWZmZXJQYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9CWVRFIDogZGF0YVR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9VTlNJR05FRF9CWVRFX0RUIDogZGF0YVR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9TSE9SVCA6IGRhdGFUeXBlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVU5TSUdORURfU0hPUlRfIDogZGF0YVR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9JTlQgOiBkYXRhVHlwZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1VOU0lHTkVEX0lOVF8gOiBkYXRhVHlwZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0ZMT0FUIDogZGF0YVR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9VTlNJR05FRF9CWVRFXyA6IHBpeGVsVHlwZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1VOU0lHTkVEX1NIT1JUXzRfNF80XzRfIDogcGl4ZWxUeXBlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVU5TSUdORURfU0hPUlRfNV81XzVfMV8gOiBwaXhlbFR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9VTlNJR05FRF9TSE9SVF81XzZfNV8gOiBwaXhlbFR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9BTFBIQSA6IHBpeGVsRm9ybWF0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfUkdCIDogcGl4ZWxGb3JtYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9SR0JBIDogcGl4ZWxGb3JtYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9MVU1JTkFOQ0UgOiBwaXhlbEZvcm1hdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0xVTUlOQU5DRV9BTFBIQV8gOiBwaXhlbEZvcm1hdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NURU5DSUxfSU5ERVhfIDogcGl4ZWxGb3JtYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9ERVBUSF9TVEVOQ0lMXyA6IHBpeGVsRm9ybWF0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfREVQVEhfQ09NUE9ORU5UXyA6IHBpeGVsRm9ybWF0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfRlJBR01FTlRfU0hBREVSXyA6IHNoYWRlclR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9WRVJURVhfU0hBREVSXyA6IHNoYWRlclR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9NQVhfVkVSVEVYX0FUVFJJQlNfIDogaW50IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX01BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTXyA6IGludCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9NQVhfVkFSWUlOR19WRUNUT1JTXyA6IGludCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUU18gOiBpbnQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTXyA6IGludCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9NQVhfVEVYVFVSRV9JTUFHRV9VTklUU18gOiBpbnQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SU18gOiBpbnQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfU0hBREVSX1RZUEVfIDogc2hhZGVyVHlwZSBzaGFkZXJQYXJhbSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0RFTEVURV9TVEFUVVNfIDogYm9vbCB0IHNoYWRlclBhcmFtIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQ09NUElMRV9TVEFUVVNfIDogYm9vbCB0IHNoYWRlclBhcmFtIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfREVMRVRFX1NUQVRVU19QUk9HIDogYm9vbCB0IHByb2dyYW1QYXJhbSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0xJTktfU1RBVFVTXyA6IGJvb2wgdCBwcm9ncmFtUGFyYW0gcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9WQUxJREFURV9TVEFUVVNfIDogYm9vbCB0IHByb2dyYW1QYXJhbSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0FUVEFDSEVEX1NIQURFUlNfIDogaW50IHByb2dyYW1QYXJhbSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0FDVElWRV9VTklGT1JNU18gOiBpbnQgcHJvZ3JhbVBhcmFtIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQUNUSVZFX0FUVFJJQlVURVNfIDogaW50IHByb2dyYW1QYXJhbSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NIQURJTkdfTEFOR1VBR0VfVkVSU0lPTl8gOiBqc19zdHJpbmcgdCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9DVVJSRU5UX1BST0dSQU1fIDogcHJvZ3JhbSB0IG9wdCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9WRU5ET1IgOiBqc19zdHJpbmcgdCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9SRU5ERVJFUiA6IGpzX3N0cmluZyB0IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1ZFUlNJT04gOiBqc19zdHJpbmcgdCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFXyA6IGludCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9BQ1RJVkVfVEVYVFVSRV8gOiBpbnQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfRlJBTUVCVUZGRVJfQklORElOR18gOiBmcmFtZWJ1ZmZlciB0IG9wdCBwYXJhbWV0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9SRU5ERVJCVUZGRVJfQklORElOR18gOiByZW5kZXJidWZmZXIgdCBvcHQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfTUFYX1JFTkRFUkJVRkZFUl9TSVpFIDogaW50IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX05FVkVSIDogZGVwdGhGdW5jdGlvbiByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0xFU1MgOiBkZXB0aEZ1bmN0aW9uIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfRVFVQUwgOiBkZXB0aEZ1bmN0aW9uIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfTEVRVUFMIDogZGVwdGhGdW5jdGlvbiByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0dSRUFURVIgOiBkZXB0aEZ1bmN0aW9uIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfTk9URVFVQUwgOiBkZXB0aEZ1bmN0aW9uIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfR0VRVUFMIDogZGVwdGhGdW5jdGlvbiByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0FMV0FZUyA6IGRlcHRoRnVuY3Rpb24gcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9LRUVQIDogc3RlbmNpbE9wIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfUkVQTEFDRSA6IHN0ZW5jaWxPcCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0lOQ1IgOiBzdGVuY2lsT3AgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9ERUNSIDogc3RlbmNpbE9wIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfSU5WRVJUIDogc3RlbmNpbE9wIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfSU5DUl9XUkFQXyA6IHN0ZW5jaWxPcCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0RFQ1JfV1JBUF8gOiBzdGVuY2lsT3AgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9aRVJPXyA6IHN0ZW5jaWxPcCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX05FQVJFU1QgOiB0ZXhGaWx0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9MSU5FQVIgOiB0ZXhGaWx0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9ORUFSRVNUX01JUE1BUF9ORUFSRVNUXyA6IHRleEZpbHRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0xJTkVBUl9NSVBNQVBfTkVBUkVTVF8gOiB0ZXhGaWx0ZXIgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9ORUFSRVNUX01JUE1BUF9MSU5FQVJfIDogdGV4RmlsdGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfTElORUFSX01JUE1BUF9MSU5FQVJfIDogdGV4RmlsdGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVEVYVFVSRV9NQUdfRklMVEVSXyA6IHRleEZpbHRlciB0ZXhQYXJhbSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RFWFRVUkVfTUlOX0ZJTFRFUl8gOiB0ZXhGaWx0ZXIgdGV4UGFyYW0gcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9URVhUVVJFX1dSQVBfU18gOiB3cmFwTW9kZSB0ZXhQYXJhbSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RFWFRVUkVfV1JBUF9UXyA6IHdyYXBNb2RlIHRleFBhcmFtIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfTk9ORV9PVCA6IG9iamVjdFR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9URVhUVVJFX09UIDogb2JqZWN0VHlwZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1JFTkRFUkJVRkZFUl9PVCA6IG9iamVjdFR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9URVhUVVJFXzJEXyA6IHRleFRhcmdldCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RFWFRVUkVfQ1VCRV9NQVBfIDogdGV4VGFyZ2V0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YXyA6IHRleFRhcmdldCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWF8gOiB0ZXhUYXJnZXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1lfIDogdGV4VGFyZ2V0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZXyA6IHRleFRhcmdldCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWl8gOiB0ZXhUYXJnZXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1pfIDogdGV4VGFyZ2V0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVEVYVFVSRTAgOiB0ZXh0dXJlVW5pdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RFWFRVUkUxIDogdGV4dHVyZVVuaXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9URVhUVVJFMiA6IHRleHR1cmVVbml0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVEVYVFVSRTMgOiB0ZXh0dXJlVW5pdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RFWFRVUkU0IDogdGV4dHVyZVVuaXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9URVhUVVJFNSA6IHRleHR1cmVVbml0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVEVYVFVSRTYgOiB0ZXh0dXJlVW5pdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RFWFRVUkU3IDogdGV4dHVyZVVuaXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9URVhUVVJFOCA6IHRleHR1cmVVbml0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVEVYVFVSRTkgOiB0ZXh0dXJlVW5pdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RFWFRVUkUxMCA6IHRleHR1cmVVbml0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVEVYVFVSRTExIDogdGV4dHVyZVVuaXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9URVhUVVJFMTIgOiB0ZXh0dXJlVW5pdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RFWFRVUkUxMyA6IHRleHR1cmVVbml0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVEVYVFVSRTE0IDogdGV4dHVyZVVuaXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9URVhUVVJFMTUgOiB0ZXh0dXJlVW5pdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RFWFRVUkUxNiA6IHRleHR1cmVVbml0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVEVYVFVSRTE3IDogdGV4dHVyZVVuaXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9URVhUVVJFMTggOiB0ZXh0dXJlVW5pdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RFWFRVUkUxOSA6IHRleHR1cmVVbml0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVEVYVFVSRTIwIDogdGV4dHVyZVVuaXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9URVhUVVJFMjEgOiB0ZXh0dXJlVW5pdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RFWFRVUkUyMiA6IHRleHR1cmVVbml0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVEVYVFVSRTIzIDogdGV4dHVyZVVuaXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9URVhUVVJFMjQgOiB0ZXh0dXJlVW5pdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RFWFRVUkUyNSA6IHRleHR1cmVVbml0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVEVYVFVSRTI2IDogdGV4dHVyZVVuaXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9URVhUVVJFMjcgOiB0ZXh0dXJlVW5pdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RFWFRVUkUyOCA6IHRleHR1cmVVbml0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVEVYVFVSRTI5IDogdGV4dHVyZVVuaXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9URVhUVVJFMzAgOiB0ZXh0dXJlVW5pdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1RFWFRVUkUzMSA6IHRleHR1cmVVbml0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfUkVQRUFUIDogd3JhcE1vZGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9DTEFNUF9UT19FREdFXyA6IHdyYXBNb2RlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfTUlSUk9SRURfUkVQRUFUXyA6IHdyYXBNb2RlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfRkxPQVRfIDogdW5pZm9ybVR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9GTE9BVF9WRUMyXyA6IHVuaWZvcm1UeXBlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfRkxPQVRfVkVDM18gOiB1bmlmb3JtVHlwZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0ZMT0FUX1ZFQzRfIDogdW5pZm9ybVR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9JTlRfIDogdW5pZm9ybVR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9JTlRfVkVDMl8gOiB1bmlmb3JtVHlwZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0lOVF9WRUMzXyA6IHVuaWZvcm1UeXBlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfSU5UX1ZFQzRfIDogdW5pZm9ybVR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9CT09MXyA6IHVuaWZvcm1UeXBlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQk9PTF9WRUMyXyA6IHVuaWZvcm1UeXBlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQk9PTF9WRUMzXyA6IHVuaWZvcm1UeXBlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQk9PTF9WRUM0XyA6IHVuaWZvcm1UeXBlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfRkxPQVRfTUFUMl8gOiB1bmlmb3JtVHlwZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0ZMT0FUX01BVDNfIDogdW5pZm9ybVR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9GTE9BVF9NQVQ0XyA6IHVuaWZvcm1UeXBlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfU0FNUExFUl8yRF8gOiB1bmlmb3JtVHlwZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NBTVBMRVJfQ1VCRV8gOiB1bmlmb3JtVHlwZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1ZFUlRFWF9BVFRSSUJfQVJSQVlfRU5BQkxFRF8gOiBib29sIHQgdmVydGV4QXR0cmliUGFyYW0gcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9WRVJURVhfQVRUUklCX0FSUkFZX1NJWkVfIDogaW50IHZlcnRleEF0dHJpYlBhcmFtIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVkVSVEVYX0FUVFJJQl9BUlJBWV9TVFJJREVfIDogaW50IHZlcnRleEF0dHJpYlBhcmFtIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVkVSVEVYX0FUVFJJQl9BUlJBWV9UWVBFXyA6IGludCB2ZXJ0ZXhBdHRyaWJQYXJhbSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1ZFUlRFWF9BVFRSSUJfQVJSQVlfTk9STUFMSVpFRF8gOiBib29sIHQgdmVydGV4QXR0cmliUGFyYW0gcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9WRVJURVhfQVRUUklCX0FSUkFZX1BPSU5URVJfIDogdmVydGV4QXR0cmliUG9pbnRlclBhcmFtIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVkVSVEVYX0FUVFJJQl9BUlJBWV9CVUZGRVJfQklORElOR18gOlxuICAgICAgYnVmZmVyIHQgb3B0IHZlcnRleEF0dHJpYlBhcmFtIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQ1VSUkVOVF9WRVJURVhfQVRUUklCXyA6XG4gICAgICBUeXBlZF9hcnJheS5mbG9hdDMyQXJyYXkgdCB2ZXJ0ZXhBdHRyaWJQYXJhbSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0xPV19GTE9BVF8gOiBzaGFkZXJQcmVjaXNpb25UeXBlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfTUVESVVNX0ZMT0FUXyA6IHNoYWRlclByZWNpc2lvblR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9ISUdIX0ZMT0FUXyA6IHNoYWRlclByZWNpc2lvblR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9MT1dfSU5UXyA6IHNoYWRlclByZWNpc2lvblR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9NRURJVU1fSU5UXyA6IHNoYWRlclByZWNpc2lvblR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9ISUdIX0lOVF8gOiBzaGFkZXJQcmVjaXNpb25UeXBlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfRlJBTUVCVUZGRVIgOiBmYlRhcmdldCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1JFTkRFUkJVRkZFUiA6IHJiVGFyZ2V0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfUkdCQTQgOiBmb3JtYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9SR0I1X0ExXyA6IGZvcm1hdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1JHQjU2NSA6IGZvcm1hdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0RFUFRIX0NPTVBPTkVOVDE2XyA6IGZvcm1hdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1NURU5DSUxfSU5ERVg4XyA6IGZvcm1hdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1JFTkRFUkJVRkZFUl9XSURUSF8gOiBpbnQgcmVuZGVyYnVmZmVyUGFyYW0gcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9SRU5ERVJCVUZGRVJfSEVJR0hUXyA6IGludCByZW5kZXJidWZmZXJQYXJhbSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1JFTkRFUkJVRkZFUl9JTlRFUk5BTF9GT1JNQVRfIDogZm9ybWF0IHJlbmRlcmJ1ZmZlclBhcmFtIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfUkVOREVSQlVGRkVSX1JFRF9TSVpFXyA6IGludCByZW5kZXJidWZmZXJQYXJhbSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1JFTkRFUkJVRkZFUl9HUkVFTl9TSVpFXyA6IGludCByZW5kZXJidWZmZXJQYXJhbSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1JFTkRFUkJVRkZFUl9CTFVFX1NJWkVfIDogaW50IHJlbmRlcmJ1ZmZlclBhcmFtIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfUkVOREVSQlVGRkVSX0FMUEhBX1NJWkVfIDogaW50IHJlbmRlcmJ1ZmZlclBhcmFtIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfUkVOREVSQlVGRkVSX0RFUFRIX1NJWkVfIDogaW50IHJlbmRlcmJ1ZmZlclBhcmFtIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfUkVOREVSQlVGRkVSX1NURU5DSUxfU0laRV8gOiBpbnQgcmVuZGVyYnVmZmVyUGFyYW0gcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9GUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9UWVBFXyA6IG9iamVjdFR5cGUgYXR0YWNoUGFyYW0gcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9GUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9OQU1FX1JFTkRFUkJVRkZFUiA6XG4gICAgICByZW5kZXJidWZmZXIgdCBhdHRhY2hQYXJhbSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0ZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX05BTUVfVEVYVFVSRSA6XG4gICAgICB0ZXh0dXJlIHQgYXR0YWNoUGFyYW0gcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9GUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfTEVWRUxfIDogaW50IGF0dGFjaFBhcmFtIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0NVQkVfTUFQX0ZBQ0VfIDogaW50IGF0dGFjaFBhcmFtIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQ09MT1JfQVRUQUNITUVOVDBfIDogYXR0YWNobWVudFBvaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfREVQVEhfQVRUQUNITUVOVF8gOiBhdHRhY2htZW50UG9pbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9TVEVOQ0lMX0FUVEFDSE1FTlRfIDogYXR0YWNobWVudFBvaW50IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UXyA6IGF0dGFjaG1lbnRQb2ludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX0ZSQU1FQlVGRkVSX0NPTVBMRVRFXyA6IGZyYW1lYnVmZmVyU3RhdHVzIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UXyA6IGZyYW1lYnVmZmVyU3RhdHVzIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlRfIDogZnJhbWVidWZmZXJTdGF0dXMgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlNfIDogZnJhbWVidWZmZXJTdGF0dXMgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9GUkFNRUJVRkZFUl9VTlNVUFBPUlRFRF8gOiBmcmFtZWJ1ZmZlclN0YXR1cyByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1VOUEFDS19GTElQX1lfV0VCR0xfUEFSQU0gOiBib29sIHQgcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMX1BBUkFNIDogYm9vbCB0IHBhcmFtZXRlciByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1VOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0xfUEFSQU0gOlxuICAgICAgY29sb3JzcGFjZUNvbnZlcnNpb24gcGFyYW1ldGVyIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfTk9ORSA6IGNvbG9yc3BhY2VDb252ZXJzaW9uIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfQlJPV1NFUl9ERUZBVUxUX1dFQkdMXyA6IGNvbG9yc3BhY2VDb252ZXJzaW9uIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVU5QQUNLX0FMSUdOTUVOVF8gOiBpbnQgcGl4ZWxTdG9yZVBhcmFtIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVU5QQUNLX0ZMSVBfWV9XRUJHTF8gOiBib29sIHQgcGl4ZWxTdG9yZVBhcmFtIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMXyA6IGJvb2wgdCBwaXhlbFN0b3JlUGFyYW0gcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMXyA6IGludCBwaXhlbFN0b3JlUGFyYW0gcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuKCoqIDUuMTQgV2ViR0xDb250ZXh0RXZlbnQgKilcblxuY2xhc3MgdHlwZSBjb250ZXh0RXZlbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IERvbV9odG1sLmV2ZW50XG5cbiAgICBtZXRob2Qgc3RhdHVzTWVzc2FnZSA6IGpzX3N0cmluZyB0IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbm1vZHVsZSBFdmVudCA9IHN0cnVjdFxuICBsZXQgd2ViZ2xjb250ZXh0bG9zdCA9IERvbV9odG1sLkV2ZW50Lm1ha2UgXCJ3ZWJnbGNvbnRleHRsb3N0XCJcblxuICBsZXQgd2ViZ2xjb250ZXh0cmVzdG9yZWQgPSBEb21faHRtbC5FdmVudC5tYWtlIFwid2ViZ2xjb250ZXh0cmVzdG9yZWRcIlxuXG4gIGxldCB3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yID0gRG9tX2h0bWwuRXZlbnQubWFrZSBcIndlYmdsY29udGV4dGNyZWF0aW9uZXJyb3JcIlxuZW5kXG5cbigqKioqKVxuXG5jbGFzcyB0eXBlIGNhbnZhc0VsZW1lbnQgPVxuICBvYmplY3RcbiAgICBtZXRob2QgZ2V0Q29udGV4dCA6IGpzX3N0cmluZyB0IC0+IHJlbmRlcmluZ0NvbnRleHQgdCBvcHQgbWV0aFxuXG4gICAgbWV0aG9kIGdldENvbnRleHRfIDoganNfc3RyaW5nIHQgLT4gY29udGV4dEF0dHJpYnV0ZXMgdCAtPiByZW5kZXJpbmdDb250ZXh0IHQgb3B0IG1ldGhcbiAgZW5kXG5cbmxldCBnZXRDb250ZXh0IChjIDogRG9tX2h0bWwuY2FudmFzRWxlbWVudCB0KSA9XG4gIGxldCBjIDogY2FudmFzRWxlbWVudCB0ID0gSnMuVW5zYWZlLmNvZXJjZSBjIGluXG4gIGxldCBjdHggPSBjIyNnZXRDb250ZXh0IChKcy5zdHJpbmcgXCJ3ZWJnbFwiKSBpblxuICBpZiBPcHQudGVzdCBjdHggdGhlbiBjdHggZWxzZSBjICMjIChnZXRDb250ZXh0IChKcy5zdHJpbmcgXCJleHBlcmltZW50YWwtd2ViZ2xcIikpXG5cbmxldCBnZXRDb250ZXh0V2l0aEF0dHJpYnV0ZXMgKGMgOiBEb21faHRtbC5jYW52YXNFbGVtZW50IHQpIGF0dHJpYnMgPVxuICBsZXQgYyA6IGNhbnZhc0VsZW1lbnQgdCA9IEpzLlVuc2FmZS5jb2VyY2UgYyBpblxuICBsZXQgY3R4ID0gYyMjZ2V0Q29udGV4dF8gKEpzLnN0cmluZyBcIndlYmdsXCIpIGF0dHJpYnMgaW5cbiAgaWYgT3B0LnRlc3QgY3R4IHRoZW4gY3R4IGVsc2UgYyMjZ2V0Q29udGV4dF8gKEpzLnN0cmluZyBcImV4cGVyaW1lbnRhbC13ZWJnbFwiKSBhdHRyaWJzXG4iLCIoKiBKc19vZl9vY2FtbCBsaWJyYXJ5XG4gKiBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuICogQ29weXJpZ2h0IChDKSAyMDEwIFJhcGhhw6tsIFByb3VzdCwgSsOpcsO0bWUgVm91aWxsb25cbiAqIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4gKiBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICogRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbiAqKVxub3BlbiEgSW1wb3J0XG5cbnR5cGUgcmVnZXhwID0gSnMucmVnRXhwIEpzLnRcblxudHlwZSByZXN1bHQgPSBKcy5tYXRjaF9yZXN1bHQgSnMudFxuXG5sZXQgcmVnZXhwIHMgPSBuZXclanMgSnMucmVnRXhwX3dpdGhGbGFncyAoSnMuYnl0ZXN0cmluZyBzKSAoSnMuc3RyaW5nIFwiZ1wiKVxuXG5sZXQgcmVnZXhwX2Nhc2VfZm9sZCBzID0gbmV3JWpzIEpzLnJlZ0V4cF93aXRoRmxhZ3MgKEpzLmJ5dGVzdHJpbmcgcykgKEpzLnN0cmluZyBcImdpXCIpXG5cbmxldCByZWdleHBfd2l0aF9mbGFnIHMgZiA9XG4gIG5ldyVqcyBKcy5yZWdFeHBfd2l0aEZsYWdzIChKcy5ieXRlc3RyaW5nIHMpIChKcy5zdHJpbmcgKFwiZ1wiIF4gZikpXG5cbmxldCBibHVudF9zdHJfYXJyYXlfZ2V0IGEgaSA9XG4gIEpzLnRvX2J5dGVzdHJpbmcgKEpzLk9wdGRlZi5nZXQgKEpzLmFycmF5X2dldCBhIGkpIChmdW4gKCkgLT4gYXNzZXJ0IGZhbHNlKSlcblxubGV0IHN0cmluZ19tYXRjaCByIHMgaSA9XG4gIHIjIy5sYXN0SW5kZXggOj0gaTtcbiAgSnMuT3B0LnRvX29wdGlvbiAoSnMuT3B0Lm1hcCAociMjZXhlYyAoSnMuYnl0ZXN0cmluZyBzKSkgSnMubWF0Y2hfcmVzdWx0KVxuXG5sZXQgc2VhcmNoIHIgcyBpID1cbiAgciMjLmxhc3RJbmRleCA6PSBpO1xuICBKcy5PcHQudG9fb3B0aW9uXG4gICAgKEpzLk9wdC5tYXBcbiAgICAgICAociMjZXhlYyAoSnMuYnl0ZXN0cmluZyBzKSlcbiAgICAgICAoZnVuIHJlc19wcmUgLT5cbiAgICAgICAgIGxldCByZXMgPSBKcy5tYXRjaF9yZXN1bHQgcmVzX3ByZSBpblxuICAgICAgICAgcmVzIyMuaW5kZXgsIHJlcykpXG5cbmxldCBzZWFyY2hfZm9yd2FyZCA9IHNlYXJjaFxuXG5sZXQgbWF0Y2hlZF9zdHJpbmcgciA9IGJsdW50X3N0cl9hcnJheV9nZXQgciAwXG5cbmxldCBtYXRjaGVkX2dyb3VwIHIgaSA9XG4gIEpzLk9wdGRlZi50b19vcHRpb24gKEpzLk9wdGRlZi5tYXAgKEpzLmFycmF5X2dldCByIGkpIEpzLnRvX2J5dGVzdHJpbmcpXG5cbmxldCBxdW90ZV9yZXBsX3JlID0gbmV3JWpzIEpzLnJlZ0V4cF93aXRoRmxhZ3MgKEpzLnN0cmluZyBcIlskXVwiKSAoSnMuc3RyaW5nIFwiZ1wiKVxuXG5sZXQgcXVvdGVfcmVwbCBzID0gKEpzLmJ5dGVzdHJpbmcgcykjI3JlcGxhY2UgcXVvdGVfcmVwbF9yZSAoSnMuc3RyaW5nIFwiJCQkJFwiKVxuXG5sZXQgZ2xvYmFsX3JlcGxhY2UgciBzIHNfYnkgPVxuICByIyMubGFzdEluZGV4IDo9IDA7XG4gIEpzLnRvX2J5dGVzdHJpbmcgKEpzLmJ5dGVzdHJpbmcgcykgIyMgKHJlcGxhY2UgciAocXVvdGVfcmVwbCBzX2J5KSlcblxubGV0IHJlcGxhY2VfZmlyc3QgciBzIHNfYnkgPVxuICBsZXQgZmxhZ3MgPVxuICAgIG1hdGNoIEpzLnRvX2Jvb2wgciMjLmlnbm9yZUNhc2UsIEpzLnRvX2Jvb2wgciMjLm11bHRpbGluZSB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UgLT4gSnMuc3RyaW5nIFwiXCJcbiAgICB8IGZhbHNlLCB0cnVlIC0+IEpzLnN0cmluZyBcIm1cIlxuICAgIHwgdHJ1ZSwgZmFsc2UgLT4gSnMuc3RyaW5nIFwiaVwiXG4gICAgfCB0cnVlLCB0cnVlIC0+IEpzLnN0cmluZyBcIm1pXCJcbiAgaW5cbiAgbGV0IHInID0gbmV3JWpzIEpzLnJlZ0V4cF93aXRoRmxhZ3MgciMjLnNvdXJjZSBmbGFncyBpblxuICBKcy50b19ieXRlc3RyaW5nIChKcy5ieXRlc3RyaW5nIHMpICMjIChyZXBsYWNlIHInIChxdW90ZV9yZXBsIHNfYnkpKVxuXG5sZXQgbGlzdF9vZl9qc19hcnJheSBhID1cbiAgbGV0IHJlYyBhdXggYWNjdSBpZHggPVxuICAgIGlmIGlkeCA8IDAgdGhlbiBhY2N1IGVsc2UgYXV4IChibHVudF9zdHJfYXJyYXlfZ2V0IGEgaWR4IDo6IGFjY3UpIChpZHggLSAxKVxuICBpblxuICBhdXggW10gKGEjIy5sZW5ndGggLSAxKVxuXG5sZXQgc3BsaXQgciBzID1cbiAgciMjLmxhc3RJbmRleCA6PSAwO1xuICBsaXN0X29mX2pzX2FycmF5IChKcy5zdHJfYXJyYXkgKEpzLmJ5dGVzdHJpbmcgcykgIyMgKHNwbGl0X3JlZ0V4cCByKSlcblxubGV0IGJvdW5kZWRfc3BsaXQgciBzIGkgPVxuICByIyMubGFzdEluZGV4IDo9IDA7XG4gIGxpc3Rfb2ZfanNfYXJyYXkgKEpzLnN0cl9hcnJheSAoSnMuYnl0ZXN0cmluZyBzKSAjIyAoc3BsaXRfcmVnRXhwTGltaXRlZCByIGkpKVxuXG4oKiBNb3JlIGNvbnN0cnVjdG9ycyAqKVxuXG5sZXQgcXVvdGVfcmUgPSByZWdleHAgXCJbXFxcXF1bKClcXFxcXFxcXHwrKi4/e31eJF1cIlxuXG5sZXQgcXVvdGUgcyA9IEpzLnRvX2J5dGVzdHJpbmcgKEpzLmJ5dGVzdHJpbmcgcykgIyMgKHJlcGxhY2UgcXVvdGVfcmUgKEpzLnN0cmluZyBcIlxcXFwkJlwiKSlcblxubGV0IHJlZ2V4cF9zdHJpbmcgcyA9IHJlZ2V4cCAocXVvdGUgcylcblxubGV0IHJlZ2V4cF9zdHJpbmdfY2FzZV9mb2xkIHMgPSByZWdleHBfY2FzZV9mb2xkIChxdW90ZSBzKVxuIiwiKCogSnNfb2Zfb2NhbWwgbGlicmFyeVxuICogaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbiAqIENvcHlyaWdodCAoQykgMjAxMCBSYXBoYcOrbCBQcm91c3RcbiAqIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4gKiBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICogRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbiAqKVxub3BlbiEgSW1wb3J0XG5cbigqIFVybCB0YW1wZXJpbmcuICopXG5cbmxldCBzcGxpdCBjIHMgPSBKcy5zdHJfYXJyYXkgKHMjI3NwbGl0IChKcy5zdHJpbmcgKFN0cmluZy5tYWtlIDEgYykpKVxuXG5sZXQgc3BsaXRfMiBjIHMgPVxuICBsZXQgaW5kZXggPSBzIyNpbmRleE9mIChKcy5zdHJpbmcgKFN0cmluZy5tYWtlIDEgYykpIGluXG4gIGlmIGluZGV4IDwgMCB0aGVuIEpzLnVuZGVmaW5lZCBlbHNlIEpzLmRlZiAocyMjc2xpY2UgMCBpbmRleCwgcyMjc2xpY2VfZW5kIChpbmRleCArIDEpKVxuXG5leGNlcHRpb24gTG9jYWxfZXhuXG5cbmxldCBpbnRlcnJ1cHQgKCkgPSByYWlzZSBMb2NhbF9leG5cblxuKCogdXJsIChBS0EgcGVyY2VudCkgZW5jb2RpbmcvZGVjb2RpbmcgKilcblxubGV0IHBsdXNfcmUgPSBSZWdleHAucmVnZXhwX3N0cmluZyBcIitcIlxuXG5sZXQgZXNjYXBlX3BsdXMgcyA9IFJlZ2V4cC5nbG9iYWxfcmVwbGFjZSBwbHVzX3JlIHMgXCIlMkJcIlxuXG5sZXQgdW5lc2NhcGVfcGx1cyBzID0gUmVnZXhwLmdsb2JhbF9yZXBsYWNlIHBsdXNfcmUgcyBcIiBcIlxuXG5sZXQgcGx1c19yZV9qc19zdHJpbmcgPSBuZXclanMgSnMucmVnRXhwX3dpdGhGbGFncyAoSnMuc3RyaW5nIFwiXFxcXCtcIikgKEpzLnN0cmluZyBcImdcIilcblxubGV0IHVuZXNjYXBlX3BsdXNfanNfc3RyaW5nIHMgPVxuICBwbHVzX3JlX2pzX3N0cmluZyMjLmxhc3RJbmRleCA6PSAwO1xuICBzIyNyZXBsYWNlIHBsdXNfcmVfanNfc3RyaW5nIChKcy5zdHJpbmcgXCIgXCIpXG5cbmxldCB1cmxkZWNvZGVfanNfc3RyaW5nX3N0cmluZyBzID1cbiAgSnMudG9fYnl0ZXN0cmluZyAoSnMudW5lc2NhcGUgKHVuZXNjYXBlX3BsdXNfanNfc3RyaW5nIHMpKVxuXG5sZXQgdXJsZGVjb2RlIHMgPSBKcy50b19ieXRlc3RyaW5nIChKcy51bmVzY2FwZSAoSnMuYnl0ZXN0cmluZyAodW5lc2NhcGVfcGx1cyBzKSkpXG5cbigqbGV0IHVybGVuY29kZV9qc19zdHJpbmdfc3RyaW5nIHMgPVxuICBKcy50b19ieXRlc3RyaW5nIChKcy5lc2NhcGUgcykqKVxuXG5sZXQgdXJsZW5jb2RlID8od2l0aF9wbHVzID0gdHJ1ZSkgcyA9XG4gIGlmIHdpdGhfcGx1c1xuICB0aGVuIGVzY2FwZV9wbHVzIChKcy50b19ieXRlc3RyaW5nIChKcy5lc2NhcGUgKEpzLmJ5dGVzdHJpbmcgcykpKVxuICBlbHNlIEpzLnRvX2J5dGVzdHJpbmcgKEpzLmVzY2FwZSAoSnMuYnl0ZXN0cmluZyBzKSlcblxudHlwZSBodHRwX3VybCA9XG4gIHsgaHVfaG9zdCA6IHN0cmluZyAgKCoqIFRoZSBob3N0IHBhcnQgb2YgdGhlIHVybC4gKilcbiAgOyBodV9wb3J0IDogaW50ICAoKiogVGhlIHBvcnQgZm9yIHRoZSBjb25uZWN0aW9uIGlmIGFueS4gKilcbiAgOyBodV9wYXRoIDogc3RyaW5nIGxpc3QgICgqKiBUaGUgcGF0aCBzcGxpdCBvbiBbJy8nXSBjaGFyYWN0ZXJzLiAqKVxuICA7IGh1X3BhdGhfc3RyaW5nIDogc3RyaW5nICAoKiogVGhlIG9yaWdpbmFsIGVudGlyZSBwYXRoLiAqKVxuICA7IGh1X2FyZ3VtZW50cyA6IChzdHJpbmcgKiBzdHJpbmcpIGxpc3RcbiAgICAgICAgKCoqIEFyZ3VtZW50cyBhcyBhIGZpZWxkLXZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiBsaXN0LiopXG4gIDsgaHVfZnJhZ21lbnQgOiBzdHJpbmcgICgqKiBUaGUgZnJhZ21lbnQgcGFydCAoYWZ0ZXIgdGhlIFsnIyddIGNoYXJhY3RlcikuICopXG4gIH1cbigqKiBUaGUgdHlwZSBmb3IgSFRUUCB1cmwuICopXG5cbnR5cGUgZmlsZV91cmwgPVxuICB7IGZ1X3BhdGggOiBzdHJpbmcgbGlzdFxuICA7IGZ1X3BhdGhfc3RyaW5nIDogc3RyaW5nXG4gIDsgZnVfYXJndW1lbnRzIDogKHN0cmluZyAqIHN0cmluZykgbGlzdFxuICA7IGZ1X2ZyYWdtZW50IDogc3RyaW5nXG4gIH1cbigqKiBUaGUgdHlwZSBmb3IgbG9jYWwgZmlsZSB1cmxzLiAqKVxuXG50eXBlIHVybCA9XG4gIHwgSHR0cCBvZiBodHRwX3VybFxuICB8IEh0dHBzIG9mIGh0dHBfdXJsXG4gIHwgRmlsZSBvZiBmaWxlX3VybFxuICAgICAgKCoqIFRoZSB0eXBlIGZvciB1cmxzLiBbRmlsZV0gaXMgZm9yIGxvY2FsIGZpbGVzIGFuZCBbRXhvdGljIHNdIGlzIGZvclxuICAgIHVua25vd24vdW5zdXBwb3J0ZWQgcHJvdG9jb2xzLiAqKVxuXG5leGNlcHRpb24gTm90X2FuX2h0dHBfcHJvdG9jb2xcblxubGV0IGlzX3NlY3VyZSBwcm90X3N0cmluZyA9XG4gIG1hdGNoIEpzLnRvX2J5dGVzdHJpbmcgcHJvdF9zdHJpbmcjI3RvTG93ZXJDYXNlIHdpdGhcbiAgfCBcImh0dHBzOlwiIHwgXCJodHRwc1wiIC0+IHRydWVcbiAgfCBcImh0dHA6XCIgfCBcImh0dHBcIiAtPiBmYWxzZVxuICB8IFwiZmlsZTpcIiB8IFwiZmlsZVwiIHwgXyAtPiByYWlzZSBOb3RfYW5faHR0cF9wcm90b2NvbFxuXG4oKiBwb3J0IG51bWJlciAqKVxubGV0IGRlZmF1bHRfaHR0cF9wb3J0ID0gODBcblxubGV0IGRlZmF1bHRfaHR0cHNfcG9ydCA9IDQ0M1xuXG4oKiBwYXRoICopXG5sZXQgcGF0aF9vZl9wYXRoX3N0cmluZyBzID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgbGV0IGogPSB0cnkgU3RyaW5nLmluZGV4X2Zyb20gcyBpICcvJyB3aXRoIE5vdF9mb3VuZCAtPiBsIGluXG4gICAgbGV0IHdvcmQgPSBTdHJpbmcuc3ViIHMgaSAoaiAtIGkpIGluXG4gICAgaWYgaiA+PSBsIHRoZW4gWyB3b3JkIF0gZWxzZSB3b3JkIDo6IGF1eCAoaiArIDEpXG4gIGluXG4gIG1hdGNoIGF1eCAwIHdpdGhcbiAgfCBbIFwiXCIgXSAtPiBbXVxuICB8IFsgXCJcIjsgXCJcIiBdIC0+IFsgXCJcIiBdXG4gIHwgYSAtPiBhXG5cbigqIEFyZ3VtZW50cyAqKVxubGV0IGVuY29kZV9hcmd1bWVudHMgbCA9XG4gIFN0cmluZy5jb25jYXQgXCImXCIgKExpc3QubWFwIChmdW4gKG4sIHYpIC0+IHVybGVuY29kZSBuIF4gXCI9XCIgXiB1cmxlbmNvZGUgdikgbClcblxubGV0IGRlY29kZV9hcmd1bWVudHNfanNfc3RyaW5nIHMgPVxuICBsZXQgYXJyID0gc3BsaXQgJyYnIHMgaW5cbiAgbGV0IGxlbiA9IGFyciMjLmxlbmd0aCBpblxuICBsZXQgbmFtZV92YWx1ZV9zcGxpdCBzID0gc3BsaXRfMiAnPScgcyBpblxuICBsZXQgcmVjIGF1eCBhY2MgaWR4ID1cbiAgICBpZiBpZHggPCAwXG4gICAgdGhlbiBhY2NcbiAgICBlbHNlXG4gICAgICB0cnlcbiAgICAgICAgYXV4XG4gICAgICAgICAgKEpzLk9wdGRlZi5jYXNlIChKcy5hcnJheV9nZXQgYXJyIGlkeCkgaW50ZXJydXB0IChmdW4gcyAtPlxuICAgICAgICAgICAgICAgSnMuT3B0ZGVmLmNhc2UgKG5hbWVfdmFsdWVfc3BsaXQgcykgaW50ZXJydXB0IChmdW4gKHgsIHkpIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IGdldCA9IHVybGRlY29kZV9qc19zdHJpbmdfc3RyaW5nIGluXG4gICAgICAgICAgICAgICAgICAgZ2V0IHgsIGdldCB5KSlcbiAgICAgICAgICA6OiBhY2MpXG4gICAgICAgICAgKHByZWQgaWR4KVxuICAgICAgd2l0aCBMb2NhbF9leG4gLT4gYXV4IGFjYyAocHJlZCBpZHgpXG4gIGluXG4gIGF1eCBbXSAobGVuIC0gMSlcblxubGV0IGRlY29kZV9hcmd1bWVudHMgcyA9IGRlY29kZV9hcmd1bWVudHNfanNfc3RyaW5nIChKcy5ieXRlc3RyaW5nIHMpXG5cbmxldCB1cmxfcmUgPVxuICBuZXclanMgSnMucmVnRXhwXG4gICAgKEpzLmJ5dGVzdHJpbmdcbiAgICAgICBcIl4oW0hoXVtUdF1bVHRdW1BwXVtTc10/KTovLyhbMC05YS16QS1aLi1dK3xcXFxcW1swLTlhLXpBLVouLV0rXFxcXF18XFxcXFtbMC05QS1GYS1mOi5dK1xcXFxdKT8oOihbMC05XSspKT8oLyhbXlxcXFw/I10qKShcXFxcPyhbXiNdKikpPygjKC4qKSk/KT8kXCIpXG5cbmxldCBmaWxlX3JlID1cbiAgbmV3JWpzIEpzLnJlZ0V4cFxuICAgIChKcy5ieXRlc3RyaW5nIFwiXihbRmZdW0lpXVtMbF1bRWVdKTovLyhbXlxcXFw/I10qKShcXFxcPyhbXiNdKikpPygjKC4qKSk/JFwiKVxuXG5sZXQgdXJsX29mX2pzX3N0cmluZyBzID1cbiAgSnMuT3B0LmNhc2VcbiAgICAodXJsX3JlIyNleGVjIHMpXG4gICAgKGZ1biAoKSAtPlxuICAgICAgSnMuT3B0LmNhc2VcbiAgICAgICAgKGZpbGVfcmUjI2V4ZWMgcylcbiAgICAgICAgKGZ1biAoKSAtPiBOb25lKVxuICAgICAgICAoZnVuIGhhbmRsZSAtPlxuICAgICAgICAgIGxldCByZXMgPSBKcy5tYXRjaF9yZXN1bHQgaGFuZGxlIGluXG4gICAgICAgICAgbGV0IHBhdGhfc3RyID1cbiAgICAgICAgICAgIHVybGRlY29kZV9qc19zdHJpbmdfc3RyaW5nIChKcy5PcHRkZWYuZ2V0IChKcy5hcnJheV9nZXQgcmVzIDIpIGludGVycnVwdClcbiAgICAgICAgICBpblxuICAgICAgICAgIFNvbWVcbiAgICAgICAgICAgIChGaWxlXG4gICAgICAgICAgICAgICB7IGZ1X3BhdGggPSBwYXRoX29mX3BhdGhfc3RyaW5nIHBhdGhfc3RyXG4gICAgICAgICAgICAgICA7IGZ1X3BhdGhfc3RyaW5nID0gcGF0aF9zdHJcbiAgICAgICAgICAgICAgIDsgZnVfYXJndW1lbnRzID1cbiAgICAgICAgICAgICAgICAgICBkZWNvZGVfYXJndW1lbnRzX2pzX3N0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgKEpzLk9wdGRlZi5nZXQgKEpzLmFycmF5X2dldCByZXMgNCkgKGZ1biAoKSAtPiBKcy5ieXRlc3RyaW5nIFwiXCIpKVxuICAgICAgICAgICAgICAgOyBmdV9mcmFnbWVudCA9XG4gICAgICAgICAgICAgICAgICAgSnMudG9fYnl0ZXN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgKEpzLk9wdGRlZi5nZXQgKEpzLmFycmF5X2dldCByZXMgNikgKGZ1biAoKSAtPiBKcy5ieXRlc3RyaW5nIFwiXCIpKVxuICAgICAgICAgICAgICAgfSkpKVxuICAgIChmdW4gaGFuZGxlIC0+XG4gICAgICBsZXQgcmVzID0gSnMubWF0Y2hfcmVzdWx0IGhhbmRsZSBpblxuICAgICAgbGV0IHNzbCA9IGlzX3NlY3VyZSAoSnMuT3B0ZGVmLmdldCAoSnMuYXJyYXlfZ2V0IHJlcyAxKSBpbnRlcnJ1cHQpIGluXG4gICAgICBsZXQgcG9ydF9vZl9zdHJpbmcgPSBmdW5jdGlvblxuICAgICAgICB8IFwiXCIgLT4gaWYgc3NsIHRoZW4gNDQzIGVsc2UgODBcbiAgICAgICAgfCBzIC0+IGludF9vZl9zdHJpbmcgc1xuICAgICAgaW5cbiAgICAgIGxldCBwYXRoX3N0ciA9XG4gICAgICAgIHVybGRlY29kZV9qc19zdHJpbmdfc3RyaW5nXG4gICAgICAgICAgKEpzLk9wdGRlZi5nZXQgKEpzLmFycmF5X2dldCByZXMgNikgKGZ1biAoKSAtPiBKcy5ieXRlc3RyaW5nIFwiXCIpKVxuICAgICAgaW5cbiAgICAgIGxldCB1cmwgPVxuICAgICAgICB7IGh1X2hvc3QgPVxuICAgICAgICAgICAgdXJsZGVjb2RlX2pzX3N0cmluZ19zdHJpbmcgKEpzLk9wdGRlZi5nZXQgKEpzLmFycmF5X2dldCByZXMgMikgaW50ZXJydXB0KVxuICAgICAgICA7IGh1X3BvcnQgPVxuICAgICAgICAgICAgcG9ydF9vZl9zdHJpbmdcbiAgICAgICAgICAgICAgKEpzLnRvX2J5dGVzdHJpbmdcbiAgICAgICAgICAgICAgICAgKEpzLk9wdGRlZi5nZXQgKEpzLmFycmF5X2dldCByZXMgNCkgKGZ1biAoKSAtPiBKcy5ieXRlc3RyaW5nIFwiXCIpKSlcbiAgICAgICAgOyBodV9wYXRoID0gcGF0aF9vZl9wYXRoX3N0cmluZyBwYXRoX3N0clxuICAgICAgICA7IGh1X3BhdGhfc3RyaW5nID0gcGF0aF9zdHJcbiAgICAgICAgOyBodV9hcmd1bWVudHMgPVxuICAgICAgICAgICAgZGVjb2RlX2FyZ3VtZW50c19qc19zdHJpbmdcbiAgICAgICAgICAgICAgKEpzLk9wdGRlZi5nZXQgKEpzLmFycmF5X2dldCByZXMgOCkgKGZ1biAoKSAtPiBKcy5ieXRlc3RyaW5nIFwiXCIpKVxuICAgICAgICA7IGh1X2ZyYWdtZW50ID1cbiAgICAgICAgICAgIHVybGRlY29kZV9qc19zdHJpbmdfc3RyaW5nXG4gICAgICAgICAgICAgIChKcy5PcHRkZWYuZ2V0IChKcy5hcnJheV9nZXQgcmVzIDEwKSAoZnVuICgpIC0+IEpzLmJ5dGVzdHJpbmcgXCJcIikpXG4gICAgICAgIH1cbiAgICAgIGluXG4gICAgICBTb21lIChpZiBzc2wgdGhlbiBIdHRwcyB1cmwgZWxzZSBIdHRwIHVybCkpXG5cbmxldCB1cmxfb2Zfc3RyaW5nIHMgPSB1cmxfb2ZfanNfc3RyaW5nIChKcy5ieXRlc3RyaW5nIHMpXG5cbmxldCBzdHJpbmdfb2ZfdXJsID0gZnVuY3Rpb25cbiAgfCBGaWxlIHsgZnVfcGF0aCA9IHBhdGg7IGZ1X2FyZ3VtZW50cyA9IGFyZ3M7IGZ1X2ZyYWdtZW50ID0gZnJhZzsgXyB9IC0+IChcbiAgICAgIFwiZmlsZTovL1wiXG4gICAgICBeIFN0cmluZy5jb25jYXQgXCIvXCIgKExpc3QubWFwIChmdW4geCAtPiB1cmxlbmNvZGUgeCkgcGF0aClcbiAgICAgIF4gKG1hdGNoIGFyZ3Mgd2l0aFxuICAgICAgICB8IFtdIC0+IFwiXCJcbiAgICAgICAgfCBsIC0+IFwiP1wiIF4gZW5jb2RlX2FyZ3VtZW50cyBsKVxuICAgICAgXlxuICAgICAgbWF0Y2ggZnJhZyB3aXRoXG4gICAgICB8IFwiXCIgLT4gXCJcIlxuICAgICAgfCBzIC0+IFwiI1wiIF4gdXJsZW5jb2RlIHMpXG4gIHwgSHR0cFxuICAgICAgeyBodV9ob3N0ID0gaG9zdFxuICAgICAgOyBodV9wb3J0ID0gcG9ydFxuICAgICAgOyBodV9wYXRoID0gcGF0aFxuICAgICAgOyBodV9hcmd1bWVudHMgPSBhcmdzXG4gICAgICA7IGh1X2ZyYWdtZW50ID0gZnJhZ1xuICAgICAgOyBfXG4gICAgICB9IC0+IChcbiAgICAgIFwiaHR0cDovL1wiXG4gICAgICBeIHVybGVuY29kZSBob3N0XG4gICAgICBeIChtYXRjaCBwb3J0IHdpdGhcbiAgICAgICAgfCA4MCAtPiBcIlwiXG4gICAgICAgIHwgbiAtPiBcIjpcIiBeIHN0cmluZ19vZl9pbnQgbilcbiAgICAgIF4gXCIvXCJcbiAgICAgIF4gU3RyaW5nLmNvbmNhdCBcIi9cIiAoTGlzdC5tYXAgKGZ1biB4IC0+IHVybGVuY29kZSB4KSBwYXRoKVxuICAgICAgXiAobWF0Y2ggYXJncyB3aXRoXG4gICAgICAgIHwgW10gLT4gXCJcIlxuICAgICAgICB8IGwgLT4gXCI/XCIgXiBlbmNvZGVfYXJndW1lbnRzIGwpXG4gICAgICBeXG4gICAgICBtYXRjaCBmcmFnIHdpdGhcbiAgICAgIHwgXCJcIiAtPiBcIlwiXG4gICAgICB8IHMgLT4gXCIjXCIgXiB1cmxlbmNvZGUgcylcbiAgfCBIdHRwc1xuICAgICAgeyBodV9ob3N0ID0gaG9zdFxuICAgICAgOyBodV9wb3J0ID0gcG9ydFxuICAgICAgOyBodV9wYXRoID0gcGF0aFxuICAgICAgOyBodV9hcmd1bWVudHMgPSBhcmdzXG4gICAgICA7IGh1X2ZyYWdtZW50ID0gZnJhZ1xuICAgICAgOyBfXG4gICAgICB9IC0+IChcbiAgICAgIFwiaHR0cHM6Ly9cIlxuICAgICAgXiB1cmxlbmNvZGUgaG9zdFxuICAgICAgXiAobWF0Y2ggcG9ydCB3aXRoXG4gICAgICAgIHwgNDQzIC0+IFwiXCJcbiAgICAgICAgfCBuIC0+IFwiOlwiIF4gc3RyaW5nX29mX2ludCBuKVxuICAgICAgXiBcIi9cIlxuICAgICAgXiBTdHJpbmcuY29uY2F0IFwiL1wiIChMaXN0Lm1hcCAoZnVuIHggLT4gdXJsZW5jb2RlIHgpIHBhdGgpXG4gICAgICBeIChtYXRjaCBhcmdzIHdpdGhcbiAgICAgICAgfCBbXSAtPiBcIlwiXG4gICAgICAgIHwgbCAtPiBcIj9cIiBeIGVuY29kZV9hcmd1bWVudHMgbClcbiAgICAgIF5cbiAgICAgIG1hdGNoIGZyYWcgd2l0aFxuICAgICAgfCBcIlwiIC0+IFwiXCJcbiAgICAgIHwgcyAtPiBcIiNcIiBeIHVybGVuY29kZSBzKVxuXG5tb2R1bGUgQ3VycmVudCA9IHN0cnVjdFxuICBsZXQgbCA9XG4gICAgaWYgSnMuT3B0ZGVmLnRlc3QgKEpzLk9wdGRlZi5yZXR1cm4gRG9tX2h0bWwud2luZG93IyMubG9jYXRpb24pXG4gICAgdGhlbiBEb21faHRtbC53aW5kb3cjIy5sb2NhdGlvblxuICAgIGVsc2VcbiAgICAgIGxldCBlbXB0eSA9IEpzLnN0cmluZyBcIlwiIGluXG4gICAgICBvYmplY3QlanNcbiAgICAgICAgdmFsIG11dGFibGUgaHJlZiA9IGVtcHR5XG5cbiAgICAgICAgdmFsIG11dGFibGUgcHJvdG9jb2wgPSBlbXB0eVxuXG4gICAgICAgIHZhbCBtdXRhYmxlIGhvc3QgPSBlbXB0eVxuXG4gICAgICAgIHZhbCBtdXRhYmxlIGhvc3RuYW1lID0gZW1wdHlcblxuICAgICAgICB2YWwgbXV0YWJsZSBwb3J0ID0gZW1wdHlcblxuICAgICAgICB2YWwgbXV0YWJsZSBwYXRobmFtZSA9IGVtcHR5XG5cbiAgICAgICAgdmFsIG11dGFibGUgc2VhcmNoID0gZW1wdHlcblxuICAgICAgICB2YWwgbXV0YWJsZSBoYXNoID0gZW1wdHlcblxuICAgICAgICB2YWwgb3JpZ2luID0gSnMudW5kZWZpbmVkXG5cbiAgICAgICAgbWV0aG9kIHJlbG9hZCA9ICgpXG5cbiAgICAgICAgbWV0aG9kIHJlcGxhY2UgXyA9ICgpXG5cbiAgICAgICAgbWV0aG9kIGFzc2lnbiBfID0gKClcbiAgICAgIGVuZFxuXG4gIGxldCBob3N0ID0gdXJsZGVjb2RlX2pzX3N0cmluZ19zdHJpbmcgbCMjLmhvc3RuYW1lXG5cbiAgbGV0IHByb3RvY29sID0gdXJsZGVjb2RlX2pzX3N0cmluZ19zdHJpbmcgbCMjLnByb3RvY29sXG5cbiAgbGV0IHBvcnQgPVxuICAgIChmdW4gKCkgLT5cbiAgICAgIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIChKcy50b19ieXRlc3RyaW5nIGwjIy5wb3J0KSkgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZSlcbiAgICAgICgpXG5cbiAgbGV0IHBhdGhfc3RyaW5nID0gdXJsZGVjb2RlX2pzX3N0cmluZ19zdHJpbmcgbCMjLnBhdGhuYW1lXG5cbiAgbGV0IHBhdGggPSBwYXRoX29mX3BhdGhfc3RyaW5nIHBhdGhfc3RyaW5nXG5cbiAgbGV0IGFyZ3VtZW50cyA9XG4gICAgZGVjb2RlX2FyZ3VtZW50c19qc19zdHJpbmdcbiAgICAgIChpZiBsIyMuc2VhcmNoIyNjaGFyQXQgMCA9PSBKcy5zdHJpbmcgXCI/XCJcbiAgICAgICB0aGVuIGwjIy5zZWFyY2gjI3NsaWNlX2VuZCAxXG4gICAgICAgZWxzZSBsIyMuc2VhcmNoKVxuXG4gIGxldCBnZXRfZnJhZ21lbnQgKCkgPVxuICAgICgqIGxvY2F0aW9uLmhhc2ggZG9lc24ndCBoYXZlIHRoZSBzYW1lIGJlaGF2aW9yIGRlcGVuZGluZyBvbiB0aGUgYnJvd3NlclxuICAgICAgIEZpcmVmb3ggYnVnIDogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDgzMzA0ICopXG4gICAgKCogbGV0IHMgPSBKcy50b19ieXRlc3RyaW5nIChsIyNoYXNoKSBpbiAqKVxuICAgICgqIGlmIFN0cmluZy5sZW5ndGggcyA+IDAgJiYgcy5bMF0gPSAnIycgKilcbiAgICAoKiB0aGVuIFN0cmluZy5zdWIgcyAxIChTdHJpbmcubGVuZ3RoIHMgLSAxKSAqKVxuICAgICgqIGVsc2UgczsgKilcbiAgICBKcy5PcHQuY2FzZVxuICAgICAgKGwjIy5ocmVmIyNfbWF0Y2ggKG5ldyVqcyBKcy5yZWdFeHAgKEpzLnN0cmluZyBcIiMoLiopXCIpKSlcbiAgICAgIChmdW4gKCkgLT4gXCJcIilcbiAgICAgIChmdW4gcmVzIC0+XG4gICAgICAgIGxldCByZXMgPSBKcy5tYXRjaF9yZXN1bHQgcmVzIGluXG4gICAgICAgIEpzLnRvX3N0cmluZyAoSnMuVW5zYWZlLmdldCByZXMgMSkpXG5cbiAgbGV0IHNldF9mcmFnbWVudCBzID0gbCMjLmhhc2ggOj0gSnMuYnl0ZXN0cmluZyAodXJsZW5jb2RlIHMpXG5cbiAgbGV0IGdldCAoKSA9IHVybF9vZl9qc19zdHJpbmcgbCMjLmhyZWZcblxuICBsZXQgc2V0IHUgPSBsIyMuaHJlZiA6PSBKcy5ieXRlc3RyaW5nIChzdHJpbmdfb2ZfdXJsIHUpXG5cbiAgbGV0IGFzX3N0cmluZyA9IHVybGRlY29kZV9qc19zdHJpbmdfc3RyaW5nIGwjIy5ocmVmXG5lbmRcbiIsIigqIEpzX29mX29jYW1sIGxpYnJhcnlcbiAqIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTQgSHVnbyBIZXV6YXJkXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbiAqIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICopXG5vcGVuISBJbXBvcnRcblxuZXh0ZXJuYWwgY3JlYXRlX2ZpbGUgOiBuYW1lOnN0cmluZyAtPiBjb250ZW50OnN0cmluZyAtPiB1bml0ID0gXCJjYW1sX2NyZWF0ZV9maWxlXCJcblxuZXh0ZXJuYWwgcmVhZF9maWxlIDogbmFtZTpzdHJpbmcgLT4gc3RyaW5nID0gXCJjYW1sX3JlYWRfZmlsZV9jb250ZW50XCJcblxubGV0IHVwZGF0ZV9maWxlIH5uYW1lIH5jb250ZW50ID1cbiAgbGV0IG9jID0gb3Blbl9vdXQgbmFtZSBpblxuICBvdXRwdXRfc3RyaW5nIG9jIGNvbnRlbnQ7XG4gIGNsb3NlX291dCBvY1xuXG5leHRlcm5hbCBzZXRfY2hhbm5lbF9vdXRwdXQnIDpcbiAgb3V0X2NoYW5uZWwgLT4gKEpzLmpzX3N0cmluZyBKcy50IC0+IHVuaXQpIEpzLmNhbGxiYWNrIC0+IHVuaXRcbiAgPSBcImNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0XCJcblxuZXh0ZXJuYWwgc2V0X2NoYW5uZWxfaW5wdXQnIDogaW5fY2hhbm5lbCAtPiAodW5pdCAtPiBzdHJpbmcpIEpzLmNhbGxiYWNrIC0+IHVuaXRcbiAgPSBcImNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsXCJcblxubGV0IHNldF9jaGFubmVsX2ZsdXNoZXIgKG91dF9jaGFubmVsIDogb3V0X2NoYW5uZWwpIChmIDogc3RyaW5nIC0+IHVuaXQpID1cbiAgbGV0IGYnIDogKEpzLmpzX3N0cmluZyBKcy50IC0+IHVuaXQpIEpzLmNhbGxiYWNrID1cbiAgICBKcy53cmFwX2NhbGxiYWNrIChmdW4gcyAtPiBmIChKcy50b19ieXRlc3RyaW5nIHMpKVxuICBpblxuICBzZXRfY2hhbm5lbF9vdXRwdXQnIG91dF9jaGFubmVsIGYnXG5cbmxldCBzZXRfY2hhbm5lbF9maWxsZXIgKGluX2NoYW5uZWwgOiBpbl9jaGFubmVsKSAoZiA6IHVuaXQgLT4gc3RyaW5nKSA9XG4gIGxldCBmJyA6ICh1bml0IC0+IHN0cmluZykgSnMuY2FsbGJhY2sgPSBKcy53cmFwX2NhbGxiYWNrIGYgaW5cbiAgc2V0X2NoYW5uZWxfaW5wdXQnIGluX2NoYW5uZWwgZidcblxuZXh0ZXJuYWwgbW91bnRfcG9pbnQgOiB1bml0IC0+IHN0cmluZyBsaXN0ID0gXCJjYW1sX2xpc3RfbW91bnRfcG9pbnRcIlxuXG5leHRlcm5hbCBtb3VudF9hdXRvbG9hZCA6XG4gIHN0cmluZyAtPiAoc3RyaW5nIC0+IHN0cmluZyAtPiBzdHJpbmcgb3B0aW9uKSBKcy5jYWxsYmFjayAtPiB1bml0XG4gID0gXCJjYW1sX21vdW50X2F1dG9sb2FkXCJcblxuZXh0ZXJuYWwgdW5tb3VudCA6IHN0cmluZyAtPiB1bml0ID0gXCJjYW1sX3VubW91bnRcIlxuXG5sZXQgbW91bnQgfnBhdGggZiA9XG4gIG1vdW50X2F1dG9sb2FkIHBhdGggKEpzLndyYXBfY2FsbGJhY2sgKGZ1biBwcmVmaXggcGF0aCAtPiBmIH5wcmVmaXggfnBhdGgpKVxuXG5sZXQgdW5tb3VudCB+cGF0aCA9IHVubW91bnQgcGF0aFxuXG5sZXQganNfb2Zfb2NhbWxfdmVyc2lvbiA9XG4gIGlmIFN0cmluZy5lcXVhbCBMaWJfdmVyc2lvbi5naXRfdmVyc2lvbiBcIlwiXG4gIHRoZW4gTGliX3ZlcnNpb24uc1xuICBlbHNlIExpYl92ZXJzaW9uLnMgXiBcIitcIiBeIExpYl92ZXJzaW9uLmdpdF92ZXJzaW9uXG4iLCIoKiBKc19vZl9vY2FtbCBsaWJyYXJ5XG4gKiBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuICogQ29weXJpZ2h0IChDKSAyMDE5IEFsZXhhbmRlciBZYW5pblxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4gKiBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICogRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbiAqKVxub3BlbiEgSW1wb3J0XG5cbmNsYXNzIHR5cGUgcmVzaXplT2JzZXJ2ZXJTaXplID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGlubGluZVNpemUgOiBmbG9hdCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgYmxvY2tTaXplIDogZmxvYXQgSnMucmVhZG9ubHlfcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSByZXNpemVPYnNlcnZlckVudHJ5ID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIHRhcmdldCA6IERvbS5ub2RlIEpzLnQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGNvbnRlbnRSZWN0IDogRG9tX2h0bWwuY2xpZW50UmVjdCBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBib3JkZXJCb3hTaXplIDogcmVzaXplT2JzZXJ2ZXJTaXplIEpzLnQgSnMuanNfYXJyYXkgSnMudCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgY29udGVudEJveFNpemUgOiByZXNpemVPYnNlcnZlclNpemUgSnMudCBKcy5qc19hcnJheSBKcy50IEpzLnJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbmNsYXNzIHR5cGUgcmVzaXplT2JzZXJ2ZXJPcHRpb25zID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGJveCA6IEpzLmpzX3N0cmluZyBKcy50IEpzLndyaXRlb25seV9wcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIHJlc2l6ZU9ic2VydmVyID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIG9ic2VydmUgOiAjRG9tLm5vZGUgSnMudCAtPiB1bml0IEpzLm1ldGhcblxuICAgIG1ldGhvZCBvYnNlcnZlX3dpdGhPcHRpb25zIDpcbiAgICAgICNEb20ubm9kZSBKcy50IC0+IHJlc2l6ZU9ic2VydmVyT3B0aW9ucyBKcy50IC0+IHVuaXQgSnMubWV0aFxuXG4gICAgbWV0aG9kIHVub2JzZXJ2ZSA6ICNEb20ubm9kZSBKcy50IC0+IHVuaXQgSnMubWV0aFxuXG4gICAgbWV0aG9kIGRpc2Nvbm5lY3QgOiB1bml0IEpzLm1ldGhcbiAgZW5kXG5cbmxldCBlbXB0eV9yZXNpemVfb2JzZXJ2ZXJfb3B0aW9ucyAoKSA6IHJlc2l6ZU9ic2VydmVyT3B0aW9ucyBKcy50ID0gSnMuVW5zYWZlLm9iaiBbfHxdXG5cbmxldCByZXNpemVPYnNlcnZlciA9IEpzLlVuc2FmZS5nbG9iYWwjIy5fUmVzaXplT2JzZXJ2ZXJcblxubGV0IGlzX3N1cHBvcnRlZCAoKSA9IEpzLk9wdGRlZi50ZXN0IHJlc2l6ZU9ic2VydmVyXG5cbmxldCByZXNpemVPYnNlcnZlciA6XG4gICAgKCAgIChyZXNpemVPYnNlcnZlckVudHJ5IEpzLnQgSnMuanNfYXJyYXkgSnMudCAtPiByZXNpemVPYnNlcnZlciBKcy50IC0+IHVuaXQpXG4gICAgICAgIEpzLmNhbGxiYWNrXG4gICAgIC0+IHJlc2l6ZU9ic2VydmVyIEpzLnQpXG4gICAgSnMuY29uc3RyID1cbiAgcmVzaXplT2JzZXJ2ZXJcblxubGV0IG9ic2VydmVcbiAgICB+KG5vZGUgOiAjRG9tLm5vZGUgSnMudClcbiAgICB+KGYgOiByZXNpemVPYnNlcnZlckVudHJ5IEpzLnQgSnMuanNfYXJyYXkgSnMudCAtPiByZXNpemVPYnNlcnZlciBKcy50IC0+IHVuaXQpXG4gICAgPyhib3ggOiBKcy5qc19zdHJpbmcgSnMudCBvcHRpb24pXG4gICAgKCkgOiByZXNpemVPYnNlcnZlciBKcy50ID1cbiAgbGV0IG9icyA9IG5ldyVqcyByZXNpemVPYnNlcnZlciAoSnMud3JhcF9jYWxsYmFjayBmKSBpblxuICAobWF0Y2ggYm94IHdpdGhcbiAgfCBOb25lIC0+IG9icyMjb2JzZXJ2ZSBub2RlXG4gIHwgU29tZSBib3ggLT5cbiAgICAgIGxldCBvcHRzID0gZW1wdHlfcmVzaXplX29ic2VydmVyX29wdGlvbnMgKCkgaW5cbiAgICAgIG9wdHMjIy5ib3ggOj0gYm94O1xuICAgICAgb2JzIyNvYnNlcnZlX3dpdGhPcHRpb25zIG5vZGUgb3B0cyk7XG4gIG9ic1xuIiwiKCogSnNfb2Zfb2NhbWwgbGlicmFyeVxuICogaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbiAqIENvcHlyaWdodCAoQykgMjAyMSBQaGlsaXAgV2hpdGVcbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuICogZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAqIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAqIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4gKilcblxub3BlbiEgSW1wb3J0XG5cbmNsYXNzIHR5cGUgcGVyZm9ybWFuY2VPYnNlcnZlckluaXQgPVxuICBvYmplY3RcbiAgICBtZXRob2QgZW50cnlUeXBlcyA6IEpzLmpzX3N0cmluZyBKcy50IEpzLmpzX2FycmF5IEpzLnQgSnMud3JpdGVvbmx5X3Byb3BcbiAgZW5kXG5cbmNsYXNzIHR5cGUgcGVyZm9ybWFuY2VFbnRyeSA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBuYW1lIDogSnMuanNfc3RyaW5nIEpzLnQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGVudHJ5VHlwZSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBzdGFydFRpbWUgOiBmbG9hdCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgZHVyYXRpb24gOiBmbG9hdCBKcy5yZWFkb25seV9wcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIHBlcmZvcm1hbmNlT2JzZXJ2ZXJFbnRyeUxpc3QgPVxuICBvYmplY3RcbiAgICBtZXRob2QgZ2V0RW50cmllcyA6IHBlcmZvcm1hbmNlRW50cnkgSnMudCBKcy5qc19hcnJheSBKcy50IEpzLm1ldGhcbiAgZW5kXG5cbmNsYXNzIHR5cGUgcGVyZm9ybWFuY2VPYnNlcnZlciA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBvYnNlcnZlIDogcGVyZm9ybWFuY2VPYnNlcnZlckluaXQgSnMudCAtPiB1bml0IEpzLm1ldGhcblxuICAgIG1ldGhvZCBkaXNjb25uZWN0IDogdW5pdCBKcy5tZXRoXG5cbiAgICBtZXRob2QgdGFrZVJlY29yZHMgOiBwZXJmb3JtYW5jZUVudHJ5IEpzLnQgSnMuanNfYXJyYXkgSnMudCBKcy5tZXRoXG4gIGVuZFxuXG5sZXQgcGVyZm9ybWFuY2VPYnNlcnZlciA9IEpzLlVuc2FmZS5nbG9iYWwjIy5fUGVyZm9ybWFuY2VPYnNlcnZlclxuXG5sZXQgaXNfc3VwcG9ydGVkICgpID0gSnMuT3B0ZGVmLnRlc3QgcGVyZm9ybWFuY2VPYnNlcnZlclxuXG5sZXQgcGVyZm9ybWFuY2VPYnNlcnZlciA6XG4gICAgKCAgIChwZXJmb3JtYW5jZU9ic2VydmVyRW50cnlMaXN0IEpzLnQgLT4gcGVyZm9ybWFuY2VPYnNlcnZlciBKcy50IC0+IHVuaXQpIEpzLmNhbGxiYWNrXG4gICAgIC0+IHBlcmZvcm1hbmNlT2JzZXJ2ZXIgSnMudClcbiAgICBKcy5jb25zdHIgPVxuICBwZXJmb3JtYW5jZU9ic2VydmVyXG5cbmxldCBvYnNlcnZlIH5lbnRyeV90eXBlcyB+ZiA9XG4gIGxldCBlbnRyeV90eXBlcyA9IGVudHJ5X3R5cGVzIHw+IExpc3QubWFwIEpzLnN0cmluZyB8PiBBcnJheS5vZl9saXN0IHw+IEpzLmFycmF5IGluXG4gIGxldCBwZXJmb3JtYW5jZV9vYnNlcnZlcl9pbml0IDogcGVyZm9ybWFuY2VPYnNlcnZlckluaXQgSnMudCA9IEpzLlVuc2FmZS5vYmogW3x8XSBpblxuICBsZXQgKCkgPSBwZXJmb3JtYW5jZV9vYnNlcnZlcl9pbml0IyMuZW50cnlUeXBlcyA6PSBlbnRyeV90eXBlcyBpblxuICBsZXQgb2JzID0gbmV3JWpzIHBlcmZvcm1hbmNlT2JzZXJ2ZXIgKEpzLndyYXBfY2FsbGJhY2sgZikgaW5cbiAgbGV0ICgpID0gb2JzIyNvYnNlcnZlIHBlcmZvcm1hbmNlX29ic2VydmVyX2luaXQgaW5cbiAgb2JzXG4iLCIoKiBKc19vZl9vY2FtbCBsaWJyYXJ5XG4gKiBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuICogQ29weXJpZ2h0IChDKSAyMDE1IFN0w6lwaGFuZSBMZWdyYW5kXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbiAqIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICopXG5vcGVuISBJbXBvcnRcblxuY2xhc3MgdHlwZSBtdXRhdGlvbk9ic2VydmVySW5pdCA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBjaGlsZExpc3QgOiBib29sIEpzLndyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2QgYXR0cmlidXRlcyA6IGJvb2wgSnMud3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBjaGFyYWN0ZXJEYXRhIDogYm9vbCBKcy53cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHN1YnRyZWUgOiBib29sIEpzLndyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2QgYXR0cmlidXRlT2xkVmFsdWUgOiBib29sIEpzLndyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2QgY2hhcmFjdGVyRGF0YU9sZFZhbHVlIDogYm9vbCBKcy53cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGF0dHJpYnV0ZUZpbHRlciA6IEpzLmpzX3N0cmluZyBKcy50IEpzLmpzX2FycmF5IEpzLnQgSnMud3JpdGVvbmx5X3Byb3BcbiAgZW5kXG5cbmNsYXNzIHR5cGUgbXV0YXRpb25SZWNvcmQgPVxuICBvYmplY3RcbiAgICBtZXRob2QgX3R5cGUgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgdGFyZ2V0IDogRG9tLm5vZGUgSnMudCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgYWRkZWROb2RlcyA6IERvbS5ub2RlIERvbS5ub2RlTGlzdCBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCByZW1vdmVkTm9kZXMgOiBEb20ubm9kZSBEb20ubm9kZUxpc3QgSnMudCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgcHJldmlvdXNTaWJsaW5nIDogRG9tLm5vZGUgSnMudCBKcy5vcHQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG5leHRTaWJsaW5nIDogRG9tLm5vZGUgSnMudCBKcy5vcHQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGF0dHJpYnV0ZU5hbWUgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5vcHQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGF0dHJpYnV0ZU5hbWVzcGFjZSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLm9wdCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgb2xkVmFsdWUgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5vcHQgSnMucmVhZG9ubHlfcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSBtdXRhdGlvbk9ic2VydmVyID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIG9ic2VydmUgOiAjRG9tLm5vZGUgSnMudCAtPiBtdXRhdGlvbk9ic2VydmVySW5pdCBKcy50IC0+IHVuaXQgSnMubWV0aFxuXG4gICAgbWV0aG9kIGRpc2Nvbm5lY3QgOiB1bml0IEpzLm1ldGhcblxuICAgIG1ldGhvZCB0YWtlUmVjb3JkcyA6IG11dGF0aW9uUmVjb3JkIEpzLnQgSnMuanNfYXJyYXkgSnMudCBKcy5tZXRoXG4gIGVuZFxuXG5sZXQgZW1wdHlfbXV0YXRpb25fb2JzZXJ2ZXJfaW5pdCAoKSA6IG11dGF0aW9uT2JzZXJ2ZXJJbml0IEpzLnQgPSBKcy5VbnNhZmUub2JqIFt8fF1cblxubGV0IG11dGF0aW9uT2JzZXJ2ZXIgPSBKcy5VbnNhZmUuZ2xvYmFsIyMuX011dGF0aW9uT2JzZXJ2ZXJcblxubGV0IGlzX3N1cHBvcnRlZCAoKSA9IEpzLk9wdGRlZi50ZXN0IG11dGF0aW9uT2JzZXJ2ZXJcblxubGV0IG11dGF0aW9uT2JzZXJ2ZXIgOlxuICAgICggICAobXV0YXRpb25SZWNvcmQgSnMudCBKcy5qc19hcnJheSBKcy50IC0+IG11dGF0aW9uT2JzZXJ2ZXIgSnMudCAtPiB1bml0KSBKcy5jYWxsYmFja1xuICAgICAtPiBtdXRhdGlvbk9ic2VydmVyIEpzLnQpXG4gICAgSnMuY29uc3RyID1cbiAgbXV0YXRpb25PYnNlcnZlclxuXG5sZXQgb2JzZXJ2ZVxuICAgIH4obm9kZSA6ICNEb20ubm9kZSBKcy50KVxuICAgIH4oZiA6IG11dGF0aW9uUmVjb3JkIEpzLnQgSnMuanNfYXJyYXkgSnMudCAtPiBtdXRhdGlvbk9ic2VydmVyIEpzLnQgLT4gdW5pdClcbiAgICA/KGNoaWxkX2xpc3QgOiBib29sIG9wdGlvbilcbiAgICA/KGF0dHJpYnV0ZXMgOiBib29sIG9wdGlvbilcbiAgICA/KGNoYXJhY3Rlcl9kYXRhIDogYm9vbCBvcHRpb24pXG4gICAgPyhzdWJ0cmVlIDogYm9vbCBvcHRpb24pXG4gICAgPyhhdHRyaWJ1dGVfb2xkX3ZhbHVlIDogYm9vbCBvcHRpb24pXG4gICAgPyhjaGFyYWN0ZXJfZGF0YV9vbGRfdmFsdWUgOiBib29sIG9wdGlvbilcbiAgICA/KGF0dHJpYnV0ZV9maWx0ZXIgOiBKcy5qc19zdHJpbmcgSnMudCBsaXN0IG9wdGlvbilcbiAgICAoKSA6IG11dGF0aW9uT2JzZXJ2ZXIgSnMudCA9XG4gIGxldCBvcHRfaXRlciB4IGYgPVxuICAgIG1hdGNoIHggd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSB4IC0+IGYgeFxuICBpblxuICBsZXQgb2JzID0gbmV3JWpzIG11dGF0aW9uT2JzZXJ2ZXIgKEpzLndyYXBfY2FsbGJhY2sgZikgaW5cbiAgbGV0IGNmZyA9IGVtcHR5X211dGF0aW9uX29ic2VydmVyX2luaXQgKCkgaW5cbiAgbGV0ICgpID0gb3B0X2l0ZXIgY2hpbGRfbGlzdCAoZnVuIHYgLT4gY2ZnIyMuY2hpbGRMaXN0IDo9IHYpIGluXG4gIGxldCAoKSA9IG9wdF9pdGVyIGF0dHJpYnV0ZXMgKGZ1biB2IC0+IGNmZyMjLmF0dHJpYnV0ZXMgOj0gdikgaW5cbiAgbGV0ICgpID0gb3B0X2l0ZXIgY2hhcmFjdGVyX2RhdGEgKGZ1biB2IC0+IGNmZyMjLmNoYXJhY3RlckRhdGEgOj0gdikgaW5cbiAgbGV0ICgpID0gb3B0X2l0ZXIgc3VidHJlZSAoZnVuIHYgLT4gY2ZnIyMuc3VidHJlZSA6PSB2KSBpblxuICBsZXQgKCkgPSBvcHRfaXRlciBhdHRyaWJ1dGVfb2xkX3ZhbHVlIChmdW4gdiAtPiBjZmcjIy5hdHRyaWJ1dGVPbGRWYWx1ZSA6PSB2KSBpblxuICBsZXQgKCkgPVxuICAgIG9wdF9pdGVyIGNoYXJhY3Rlcl9kYXRhX29sZF92YWx1ZSAoZnVuIHYgLT4gY2ZnIyMuY2hhcmFjdGVyRGF0YU9sZFZhbHVlIDo9IHYpXG4gIGluXG4gIGxldCAoKSA9XG4gICAgb3B0X2l0ZXIgYXR0cmlidXRlX2ZpbHRlciAoZnVuIGwgLT5cbiAgICAgICAgY2ZnIyMuYXR0cmlidXRlRmlsdGVyIDo9IEpzLmFycmF5IChBcnJheS5vZl9saXN0IGwpKVxuICBpblxuICBsZXQgKCkgPSBvYnMjI29ic2VydmUgbm9kZSBjZmcgaW5cbiAgb2JzXG4iLCIoKiBKc19vZl9vY2FtbCBsaWJyYXJ5XG4gKiBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuICogQ29weXJpZ2h0IFBpZXJyZSBDaGFtYmFydCAyMDEyLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4gKiBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICogRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbiAqKVxub3BlbiEgSW1wb3J0XG5cbnR5cGUgJ2EgdCA9IDwgPiBKcy50XG5cbmxldCBvYmogPSBKcy5VbnNhZmUuZ2xvYmFsIyMuX09iamVjdFxuXG5sZXQgY3JlYXRlICgpIDogJ2EgdCA9IG5ldyVqcyBvYmpcblxubGV0IGFkZCAodCA6ICdhIHQpIChrIDogSnMuanNfc3RyaW5nIEpzLnQpICh2IDogJ2EpID1cbiAgKCogJ18nIGlzIGFkZGVkIHRvIGF2b2lkIGNvbmZsaWN0cyB3aXRoIG9iamVjdHMgbWV0aG9kcyAqKVxuICBKcy5VbnNhZmUuc2V0IHQgKGsjI2NvbmNhdCAoSnMuc3RyaW5nIFwiX1wiKSkgdlxuXG5sZXQgcmVtb3ZlICh0IDogJ2EgdCkgKGsgOiBKcy5qc19zdHJpbmcgSnMudCkgPVxuICBKcy5VbnNhZmUuZGVsZXRlIHQgKGsjI2NvbmNhdCAoSnMuc3RyaW5nIFwiX1wiKSlcblxubGV0IGZpbmQgKHQgOiAnYSB0KSAoayA6IEpzLmpzX3N0cmluZyBKcy50KSA6ICdhIEpzLk9wdGRlZi50ID1cbiAgSnMuVW5zYWZlLmdldCB0IChrIyNjb25jYXQgKEpzLnN0cmluZyBcIl9cIikpXG5cbmxldCBrZXlzICh0IDogJ2EgdCkgOiBKcy5qc19zdHJpbmcgSnMudCBsaXN0ID1cbiAgbGV0IGtleV9hcnJheSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLmpzX2FycmF5IEpzLnQgPVxuICAgIEpzLlVuc2FmZS5nbG9iYWwjIy5fT2JqZWN0IyNrZXlzIHRcbiAgaW5cbiAgbGV0IHJlcyA9IHJlZiBbXSBpblxuICBmb3IgaSA9IDAgdG8gcHJlZCBrZXlfYXJyYXkjIy5sZW5ndGggZG9cbiAgICBsZXQga2V5ID1cbiAgICAgIEpzLk9wdGRlZi5nZXQgKEpzLmFycmF5X2dldCBrZXlfYXJyYXkgaSkgKGZ1biAoKSAtPiBmYWlsd2l0aCBcIkpzdGFibGUua2V5c1wiKVxuICAgIGluXG4gICAgcmVzIDo9IGtleSMjc3Vic3RyaW5nIDAgKHByZWQga2V5IyMubGVuZ3RoKSA6OiAhcmVzXG4gIGRvbmU7XG4gIExpc3QucmV2ICFyZXNcbiIsIigqIEpzX29mX29jYW1sIGxpYnJhcnlcbiAqIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4gKiBDb3B5cmlnaHQgR3LDqWdvaXJlIEhlbnJ5IDIwMTAuXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbiAqIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICopXG5cbm9wZW4gSnNcbm9wZW4hIEltcG9ydFxuXG5jbGFzcyB0eXBlIGpzb24gPVxuICBvYmplY3RcbiAgICBtZXRob2QgcGFyc2UgOiAnYS4ganNfc3RyaW5nIHQgLT4gJ2EgbWV0aFxuXG4gICAgbWV0aG9kIHBhcnNlXyA6XG4gICAgICAnYSAnYiAnYyAnZC4ganNfc3RyaW5nIHQgLT4gKCdiIHQsIGpzX3N0cmluZyB0IC0+ICdjIC0+ICdkKSBtZXRoX2NhbGxiYWNrIC0+ICdhIG1ldGhcblxuICAgIG1ldGhvZCBzdHJpbmdpZnkgOiAnYS4gJ2EgLT4ganNfc3RyaW5nIHQgbWV0aFxuXG4gICAgbWV0aG9kIHN0cmluZ2lmeV8gOlxuICAgICAgJ2EgJ2IgJ2MgJ2QuICdhIC0+ICgnYiwganNfc3RyaW5nIHQgLT4gJ2MgLT4gJ2QpIG1ldGhfY2FsbGJhY2sgLT4ganNfc3RyaW5nIHQgbWV0aFxuICBlbmRcblxubGV0IGpzb24gOiBqc29uIEpzLnQgPSBVbnNhZmUuZ2xvYmFsIyMuX0pTT05cblxubGV0IGlucHV0X3Jldml2ZXIgPVxuICBsZXQgcmV2aXZlciBfdGhpcyBfa2V5ICh2YWx1ZSA6IFVuc2FmZS5hbnkpIDogT2JqLnQgPVxuICAgIGlmIHR5cGVvZiB2YWx1ZSA9PSBzdHJpbmcgXCJzdHJpbmdcIlxuICAgIHRoZW4gT2JqLnJlcHIgKHRvX2J5dGVzdHJpbmcgKFVuc2FmZS5jb2VyY2UgdmFsdWUpKVxuICAgIGVsc2UgaWYgaW5zdGFuY2VvZiB2YWx1ZSBKcy5hcnJheV9lbXB0eVxuICAgICAgICAgICAgJiYgKFVuc2FmZS5jb2VyY2UgdmFsdWUpIyMubGVuZ3RoID09IDRcbiAgICAgICAgICAgICYmIFVuc2FmZS5nZXQgdmFsdWUgMCA9PSAyNTVcbiAgICB0aGVuXG4gICAgICBPYmoucmVwclxuICAgICAgICAoSnNvb19ydW50aW1lLkludDY0LmNyZWF0ZV9pbnQ2NF9sb19taV9oaVxuICAgICAgICAgICAoVW5zYWZlLmdldCB2YWx1ZSAxKVxuICAgICAgICAgICAoVW5zYWZlLmdldCB2YWx1ZSAyKVxuICAgICAgICAgICAoVW5zYWZlLmdldCB2YWx1ZSAzKSlcbiAgICBlbHNlIE9iai5yZXByIHZhbHVlXG4gIGluXG4gIHdyYXBfbWV0aF9jYWxsYmFjayByZXZpdmVyXG5cbmxldCB1bnNhZmVfaW5wdXQgcyA9IGpzb24jI3BhcnNlXyBzIGlucHV0X3Jldml2ZXJcblxuY2xhc3MgdHlwZSBvYmogPVxuICBvYmplY3RcbiAgICBtZXRob2QgY29uc3RydWN0b3IgOiAnYS4gJ2EgY29uc3RyIEpzLnJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbmxldCBtbEludDY0X2NvbnN0ciA9XG4gIGxldCBkdW1teV9pbnQ2NCA9IDFMIGluXG4gIGxldCBkdW1teV9vYmogOiBvYmogdCA9IE9iai5tYWdpYyBkdW1teV9pbnQ2NCBpblxuICBkdW1teV9vYmojIy5jb25zdHJ1Y3RvclxuXG5sZXQgb3V0cHV0X3Jldml2ZXIgX2tleSAodmFsdWUgOiBVbnNhZmUuYW55KSA6IE9iai50ID1cbiAgaWYgT2JqLnRhZyAoT2JqLnJlcHIgdmFsdWUpID0gT2JqLnN0cmluZ190YWdcbiAgdGhlbiBPYmoucmVwciAoYnl0ZXN0cmluZyAoT2JqLm1hZ2ljIHZhbHVlIDogc3RyaW5nKSlcbiAgZWxzZSBpZiBpbnN0YW5jZW9mIHZhbHVlIG1sSW50NjRfY29uc3RyXG4gIHRoZW5cbiAgICBsZXQgdmFsdWUgPSBVbnNhZmUuY29lcmNlIHZhbHVlIGluXG4gICAgT2JqLnJlcHIgKGFycmF5IFt8IDI1NTsgdmFsdWUjIy5sbzsgdmFsdWUjIy5taTsgdmFsdWUjIy5oaSB8XSlcbiAgZWxzZSBPYmoucmVwciB2YWx1ZVxuXG5sZXQgb3V0cHV0IG9iaiA9IGpzb24jI3N0cmluZ2lmeV8gb2JqIChKcy53cmFwX2NhbGxiYWNrIG91dHB1dF9yZXZpdmVyKVxuIiwiKCogSnNfb2Zfb2NhbWwgbGlicmFyeVxuICogaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbiAqIENvcHlyaWdodCAoQykgMjAxMCBSYXBoYcOrbCBQcm91c3RcbiAqIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4gKiBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICogRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbiAqKVxuXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIENvbG9yID0gc3RydWN0XG4gICgqIFRoZSB0eXBlIG9mIENTUyBjb2xvcnMuIEZpcnN0IGJ5IG5hbWUgYW5kIHRoZW4gYnkgY29uc3RydWN0b3IuICopXG4gIHR5cGUgbmFtZSA9XG4gICAgfCBBbGljZWJsdWVcbiAgICB8IEFudGlxdWV3aGl0ZVxuICAgIHwgQXF1YVxuICAgIHwgQXF1YW1hcmluZVxuICAgIHwgQXp1cmVcbiAgICB8IEJlaWdlXG4gICAgfCBCaXNxdWVcbiAgICB8IEJsYWNrXG4gICAgfCBCbGFuY2hlZGFsbW9uZFxuICAgIHwgQmx1ZVxuICAgIHwgQmx1ZXZpb2xldFxuICAgIHwgQnJvd25cbiAgICB8IEJ1cmx5d29vZFxuICAgIHwgQ2FkZXRibHVlXG4gICAgfCBDaGFydHJldXNlXG4gICAgfCBDaG9jb2xhdGVcbiAgICB8IENvcmFsXG4gICAgfCBDb3JuZmxvd2VyYmx1ZVxuICAgIHwgQ29ybnNpbGtcbiAgICB8IENyaW1zb25cbiAgICB8IEN5YW5cbiAgICB8IERhcmtibHVlXG4gICAgfCBEYXJrY3lhblxuICAgIHwgRGFya2dvbGRlbnJvZFxuICAgIHwgRGFya2dyYXlcbiAgICB8IERhcmtncmVlblxuICAgIHwgRGFya2dyZXlcbiAgICB8IERhcmtraGFraVxuICAgIHwgRGFya21hZ2VudGFcbiAgICB8IERhcmtvbGl2ZWdyZWVuXG4gICAgfCBEYXJrb3JhbmdlXG4gICAgfCBEYXJrb3JjaGlkXG4gICAgfCBEYXJrcmVkXG4gICAgfCBEYXJrc2FsbW9uXG4gICAgfCBEYXJrc2VhZ3JlZW5cbiAgICB8IERhcmtzbGF0ZWJsdWVcbiAgICB8IERhcmtzbGF0ZWdyYXlcbiAgICB8IERhcmtzbGF0ZWdyZXlcbiAgICB8IERhcmt0dXJxdW9pc2VcbiAgICB8IERhcmt2aW9sZXRcbiAgICB8IERlZXBwaW5rXG4gICAgfCBEZWVwc2t5Ymx1ZVxuICAgIHwgRGltZ3JheVxuICAgIHwgRGltZ3JleVxuICAgIHwgRG9kZ2VyYmx1ZVxuICAgIHwgRmlyZWJyaWNrXG4gICAgfCBGbG9yYWx3aGl0ZVxuICAgIHwgRm9yZXN0Z3JlZW5cbiAgICB8IEZ1Y2hzaWFcbiAgICB8IEdhaW5zYm9yb1xuICAgIHwgR2hvc3R3aGl0ZVxuICAgIHwgR29sZFxuICAgIHwgR29sZGVucm9kXG4gICAgfCBHcmF5XG4gICAgfCBHcmV5XG4gICAgfCBHcmVlblxuICAgIHwgR3JlZW55ZWxsb3dcbiAgICB8IEhvbmV5ZGV3XG4gICAgfCBIb3RwaW5rXG4gICAgfCBJbmRpYW5yZWRcbiAgICB8IEluZGlnb1xuICAgIHwgSXZvcnlcbiAgICB8IEtoYWtpXG4gICAgfCBMYXZlbmRlclxuICAgIHwgTGF2ZW5kZXJibHVzaFxuICAgIHwgTGF3bmdyZWVuXG4gICAgfCBMZW1vbmNoaWZmb25cbiAgICB8IExpZ2h0Ymx1ZVxuICAgIHwgTGlnaHRjb3JhbFxuICAgIHwgTGlnaHRjeWFuXG4gICAgfCBMaWdodGdvbGRlbnJvZHllbGxvd1xuICAgIHwgTGlnaHRncmF5XG4gICAgfCBMaWdodGdyZWVuXG4gICAgfCBMaWdodGdyZXlcbiAgICB8IExpZ2h0cGlua1xuICAgIHwgTGlnaHRzYWxtb25cbiAgICB8IExpZ2h0c2VhZ3JlZW5cbiAgICB8IExpZ2h0c2t5Ymx1ZVxuICAgIHwgTGlnaHRzbGF0ZWdyYXlcbiAgICB8IExpZ2h0c2xhdGVncmV5XG4gICAgfCBMaWdodHN0ZWVsYmx1ZVxuICAgIHwgTGlnaHR5ZWxsb3dcbiAgICB8IExpbWVcbiAgICB8IExpbWVncmVlblxuICAgIHwgTGluZW5cbiAgICB8IE1hZ2VudGFcbiAgICB8IE1hcm9vblxuICAgIHwgTWVkaXVtYXF1YW1hcmluZVxuICAgIHwgTWVkaXVtYmx1ZVxuICAgIHwgTWVkaXVtb3JjaGlkXG4gICAgfCBNZWRpdW1wdXJwbGVcbiAgICB8IE1lZGl1bXNlYWdyZWVuXG4gICAgfCBNZWRpdW1zbGF0ZWJsdWVcbiAgICB8IE1lZGl1bXNwcmluZ2dyZWVuXG4gICAgfCBNZWRpdW10dXJxdW9pc2VcbiAgICB8IE1lZGl1bXZpb2xldHJlZFxuICAgIHwgTWlkbmlnaHRibHVlXG4gICAgfCBNaW50Y3JlYW1cbiAgICB8IE1pc3R5cm9zZVxuICAgIHwgTW9jY2FzaW5cbiAgICB8IE5hdmFqb3doaXRlXG4gICAgfCBOYXZ5XG4gICAgfCBPbGRsYWNlXG4gICAgfCBPbGl2ZVxuICAgIHwgT2xpdmVkcmFiXG4gICAgfCBPcmFuZ2VcbiAgICB8IE9yYW5nZXJlZFxuICAgIHwgT3JjaGlkXG4gICAgfCBQYWxlZ29sZGVucm9kXG4gICAgfCBQYWxlZ3JlZW5cbiAgICB8IFBhbGV0dXJxdW9pc2VcbiAgICB8IFBhbGV2aW9sZXRyZWRcbiAgICB8IFBhcGF5YXdoaXBcbiAgICB8IFBlYWNocHVmZlxuICAgIHwgUGVydVxuICAgIHwgUGlua1xuICAgIHwgUGx1bVxuICAgIHwgUG93ZGVyYmx1ZVxuICAgIHwgUHVycGxlXG4gICAgfCBSZWRcbiAgICB8IFJvc3licm93blxuICAgIHwgUm95YWxibHVlXG4gICAgfCBTYWRkbGVicm93blxuICAgIHwgU2FsbW9uXG4gICAgfCBTYW5keWJyb3duXG4gICAgfCBTZWFncmVlblxuICAgIHwgU2Vhc2hlbGxcbiAgICB8IFNpZW5uYVxuICAgIHwgU2lsdmVyXG4gICAgfCBTa3libHVlXG4gICAgfCBTbGF0ZWJsdWVcbiAgICB8IFNsYXRlZ3JheVxuICAgIHwgU2xhdGVncmV5XG4gICAgfCBTbm93XG4gICAgfCBTcHJpbmdncmVlblxuICAgIHwgU3RlZWxibHVlXG4gICAgfCBUYW5cbiAgICB8IFRlYWxcbiAgICB8IFRoaXN0bGVcbiAgICB8IFRvbWF0b1xuICAgIHwgVHVycXVvaXNlXG4gICAgfCBWaW9sZXRcbiAgICB8IFdoZWF0XG4gICAgfCBXaGl0ZVxuICAgIHwgV2hpdGVzbW9rZVxuICAgIHwgWWVsbG93XG4gICAgfCBZZWxsb3dncmVlblxuXG4gIGxldCBzdHJpbmdfb2ZfbmFtZSA9IGZ1bmN0aW9uXG4gICAgfCBBbGljZWJsdWUgLT4gXCJhbGljZWJsdWVcIlxuICAgIHwgQW50aXF1ZXdoaXRlIC0+IFwiYW50aXF1ZXdoaXRlXCJcbiAgICB8IEFxdWEgLT4gXCJhcXVhXCJcbiAgICB8IEFxdWFtYXJpbmUgLT4gXCJhcXVhbWFyaW5lXCJcbiAgICB8IEF6dXJlIC0+IFwiYXp1cmVcIlxuICAgIHwgQmVpZ2UgLT4gXCJiZWlnZVwiXG4gICAgfCBCaXNxdWUgLT4gXCJiaXNxdWVcIlxuICAgIHwgQmxhY2sgLT4gXCJibGFja1wiXG4gICAgfCBCbGFuY2hlZGFsbW9uZCAtPiBcImJsYW5jaGVkYWxtb25kXCJcbiAgICB8IEJsdWUgLT4gXCJibHVlXCJcbiAgICB8IEJsdWV2aW9sZXQgLT4gXCJibHVldmlvbGV0XCJcbiAgICB8IEJyb3duIC0+IFwiYnJvd25cIlxuICAgIHwgQnVybHl3b29kIC0+IFwiYnVybHl3b29kXCJcbiAgICB8IENhZGV0Ymx1ZSAtPiBcImNhZGV0Ymx1ZVwiXG4gICAgfCBDaGFydHJldXNlIC0+IFwiY2hhcnRyZXVzZVwiXG4gICAgfCBDaG9jb2xhdGUgLT4gXCJjaG9jb2xhdGVcIlxuICAgIHwgQ29yYWwgLT4gXCJjb3JhbFwiXG4gICAgfCBDb3JuZmxvd2VyYmx1ZSAtPiBcImNvcm5mbG93ZXJibHVlXCJcbiAgICB8IENvcm5zaWxrIC0+IFwiY29ybnNpbGtcIlxuICAgIHwgQ3JpbXNvbiAtPiBcImNyaW1zb25cIlxuICAgIHwgQ3lhbiAtPiBcImN5YW5cIlxuICAgIHwgRGFya2JsdWUgLT4gXCJkYXJrYmx1ZVwiXG4gICAgfCBEYXJrY3lhbiAtPiBcImRhcmtjeWFuXCJcbiAgICB8IERhcmtnb2xkZW5yb2QgLT4gXCJkYXJrZ29sZGVucm9kXCJcbiAgICB8IERhcmtncmF5IC0+IFwiZGFya2dyYXlcIlxuICAgIHwgRGFya2dyZWVuIC0+IFwiZGFya2dyZWVuXCJcbiAgICB8IERhcmtncmV5IC0+IFwiZGFya2dyZXlcIlxuICAgIHwgRGFya2toYWtpIC0+IFwiZGFya2toYWtpXCJcbiAgICB8IERhcmttYWdlbnRhIC0+IFwiZGFya21hZ2VudGFcIlxuICAgIHwgRGFya29saXZlZ3JlZW4gLT4gXCJkYXJrb2xpdmVncmVlblwiXG4gICAgfCBEYXJrb3JhbmdlIC0+IFwiZGFya29yYW5nZVwiXG4gICAgfCBEYXJrb3JjaGlkIC0+IFwiZGFya29yY2hpZFwiXG4gICAgfCBEYXJrcmVkIC0+IFwiZGFya3JlZFwiXG4gICAgfCBEYXJrc2FsbW9uIC0+IFwiZGFya3NhbG1vblwiXG4gICAgfCBEYXJrc2VhZ3JlZW4gLT4gXCJkYXJrc2VhZ3JlZW5cIlxuICAgIHwgRGFya3NsYXRlYmx1ZSAtPiBcImRhcmtzbGF0ZWJsdWVcIlxuICAgIHwgRGFya3NsYXRlZ3JheSAtPiBcImRhcmtzbGF0ZWdyYXlcIlxuICAgIHwgRGFya3NsYXRlZ3JleSAtPiBcImRhcmtzbGF0ZWdyZXlcIlxuICAgIHwgRGFya3R1cnF1b2lzZSAtPiBcImRhcmt0dXJxdW9pc2VcIlxuICAgIHwgRGFya3Zpb2xldCAtPiBcImRhcmt2aW9sZXRcIlxuICAgIHwgRGVlcHBpbmsgLT4gXCJkZWVwcGlua1wiXG4gICAgfCBEZWVwc2t5Ymx1ZSAtPiBcImRlZXBza3libHVlXCJcbiAgICB8IERpbWdyYXkgLT4gXCJkaW1ncmF5XCJcbiAgICB8IERpbWdyZXkgLT4gXCJkaW1ncmV5XCJcbiAgICB8IERvZGdlcmJsdWUgLT4gXCJkb2RnZXJibHVlXCJcbiAgICB8IEZpcmVicmljayAtPiBcImZpcmVicmlja1wiXG4gICAgfCBGbG9yYWx3aGl0ZSAtPiBcImZsb3JhbHdoaXRlXCJcbiAgICB8IEZvcmVzdGdyZWVuIC0+IFwiZm9yZXN0Z3JlZW5cIlxuICAgIHwgRnVjaHNpYSAtPiBcImZ1Y2hzaWFcIlxuICAgIHwgR2FpbnNib3JvIC0+IFwiZ2FpbnNib3JvXCJcbiAgICB8IEdob3N0d2hpdGUgLT4gXCJnaG9zdHdoaXRlXCJcbiAgICB8IEdvbGQgLT4gXCJnb2xkXCJcbiAgICB8IEdvbGRlbnJvZCAtPiBcImdvbGRlbnJvZFwiXG4gICAgfCBHcmF5IC0+IFwiZ3JheVwiXG4gICAgfCBHcmVlbiAtPiBcImdyZWVuXCJcbiAgICB8IEdyZWVueWVsbG93IC0+IFwiZ3JlZW55ZWxsb3dcIlxuICAgIHwgR3JleSAtPiBcImdyZXlcIlxuICAgIHwgSG9uZXlkZXcgLT4gXCJob25leWRld1wiXG4gICAgfCBIb3RwaW5rIC0+IFwiaG90cGlua1wiXG4gICAgfCBJbmRpYW5yZWQgLT4gXCJpbmRpYW5yZWRcIlxuICAgIHwgSW5kaWdvIC0+IFwiaW5kaWdvXCJcbiAgICB8IEl2b3J5IC0+IFwiaXZvcnlcIlxuICAgIHwgS2hha2kgLT4gXCJraGFraVwiXG4gICAgfCBMYXZlbmRlciAtPiBcImxhdmVuZGVyXCJcbiAgICB8IExhdmVuZGVyYmx1c2ggLT4gXCJsYXZlbmRlcmJsdXNoXCJcbiAgICB8IExhd25ncmVlbiAtPiBcImxhd25ncmVlblwiXG4gICAgfCBMZW1vbmNoaWZmb24gLT4gXCJsZW1vbmNoaWZmb25cIlxuICAgIHwgTGlnaHRibHVlIC0+IFwibGlnaHRibHVlXCJcbiAgICB8IExpZ2h0Y29yYWwgLT4gXCJsaWdodGNvcmFsXCJcbiAgICB8IExpZ2h0Y3lhbiAtPiBcImxpZ2h0Y3lhblwiXG4gICAgfCBMaWdodGdvbGRlbnJvZHllbGxvdyAtPiBcImxpZ2h0Z29sZGVucm9keWVsbG93XCJcbiAgICB8IExpZ2h0Z3JheSAtPiBcImxpZ2h0Z3JheVwiXG4gICAgfCBMaWdodGdyZWVuIC0+IFwibGlnaHRncmVlblwiXG4gICAgfCBMaWdodGdyZXkgLT4gXCJsaWdodGdyZXlcIlxuICAgIHwgTGlnaHRwaW5rIC0+IFwibGlnaHRwaW5rXCJcbiAgICB8IExpZ2h0c2FsbW9uIC0+IFwibGlnaHRzYWxtb25cIlxuICAgIHwgTGlnaHRzZWFncmVlbiAtPiBcImxpZ2h0c2VhZ3JlZW5cIlxuICAgIHwgTGlnaHRza3libHVlIC0+IFwibGlnaHRza3libHVlXCJcbiAgICB8IExpZ2h0c2xhdGVncmF5IC0+IFwibGlnaHRzbGF0ZWdyYXlcIlxuICAgIHwgTGlnaHRzbGF0ZWdyZXkgLT4gXCJsaWdodHNsYXRlZ3JleVwiXG4gICAgfCBMaWdodHN0ZWVsYmx1ZSAtPiBcImxpZ2h0c3RlZWxibHVlXCJcbiAgICB8IExpZ2h0eWVsbG93IC0+IFwibGlnaHR5ZWxsb3dcIlxuICAgIHwgTGltZSAtPiBcImxpbWVcIlxuICAgIHwgTGltZWdyZWVuIC0+IFwibGltZWdyZWVuXCJcbiAgICB8IExpbmVuIC0+IFwibGluZW5cIlxuICAgIHwgTWFnZW50YSAtPiBcIm1hZ2VudGFcIlxuICAgIHwgTWFyb29uIC0+IFwibWFyb29uXCJcbiAgICB8IE1lZGl1bWFxdWFtYXJpbmUgLT4gXCJtZWRpdW1hcXVhbWFyaW5lXCJcbiAgICB8IE1lZGl1bWJsdWUgLT4gXCJtZWRpdW1ibHVlXCJcbiAgICB8IE1lZGl1bW9yY2hpZCAtPiBcIm1lZGl1bW9yY2hpZFwiXG4gICAgfCBNZWRpdW1wdXJwbGUgLT4gXCJtZWRpdW1wdXJwbGVcIlxuICAgIHwgTWVkaXVtc2VhZ3JlZW4gLT4gXCJtZWRpdW1zZWFncmVlblwiXG4gICAgfCBNZWRpdW1zbGF0ZWJsdWUgLT4gXCJtZWRpdW1zbGF0ZWJsdWVcIlxuICAgIHwgTWVkaXVtc3ByaW5nZ3JlZW4gLT4gXCJtZWRpdW1zcHJpbmdncmVlblwiXG4gICAgfCBNZWRpdW10dXJxdW9pc2UgLT4gXCJtZWRpdW10dXJxdW9pc2VcIlxuICAgIHwgTWVkaXVtdmlvbGV0cmVkIC0+IFwibWVkaXVtdmlvbGV0cmVkXCJcbiAgICB8IE1pZG5pZ2h0Ymx1ZSAtPiBcIm1pZG5pZ2h0Ymx1ZVwiXG4gICAgfCBNaW50Y3JlYW0gLT4gXCJtaW50Y3JlYW1cIlxuICAgIHwgTWlzdHlyb3NlIC0+IFwibWlzdHlyb3NlXCJcbiAgICB8IE1vY2Nhc2luIC0+IFwibW9jY2FzaW5cIlxuICAgIHwgTmF2YWpvd2hpdGUgLT4gXCJuYXZham93aGl0ZVwiXG4gICAgfCBOYXZ5IC0+IFwibmF2eVwiXG4gICAgfCBPbGRsYWNlIC0+IFwib2xkbGFjZVwiXG4gICAgfCBPbGl2ZSAtPiBcIm9saXZlXCJcbiAgICB8IE9saXZlZHJhYiAtPiBcIm9saXZlZHJhYlwiXG4gICAgfCBPcmFuZ2UgLT4gXCJvcmFuZ2VcIlxuICAgIHwgT3JhbmdlcmVkIC0+IFwib3JhbmdlcmVkXCJcbiAgICB8IE9yY2hpZCAtPiBcIm9yY2hpZFwiXG4gICAgfCBQYWxlZ29sZGVucm9kIC0+IFwicGFsZWdvbGRlbnJvZFwiXG4gICAgfCBQYWxlZ3JlZW4gLT4gXCJwYWxlZ3JlZW5cIlxuICAgIHwgUGFsZXR1cnF1b2lzZSAtPiBcInBhbGV0dXJxdW9pc2VcIlxuICAgIHwgUGFsZXZpb2xldHJlZCAtPiBcInBhbGV2aW9sZXRyZWRcIlxuICAgIHwgUGFwYXlhd2hpcCAtPiBcInBhcGF5YXdoaXBcIlxuICAgIHwgUGVhY2hwdWZmIC0+IFwicGVhY2hwdWZmXCJcbiAgICB8IFBlcnUgLT4gXCJwZXJ1XCJcbiAgICB8IFBpbmsgLT4gXCJwaW5rXCJcbiAgICB8IFBsdW0gLT4gXCJwbHVtXCJcbiAgICB8IFBvd2RlcmJsdWUgLT4gXCJwb3dkZXJibHVlXCJcbiAgICB8IFB1cnBsZSAtPiBcInB1cnBsZVwiXG4gICAgfCBSZWQgLT4gXCJyZWRcIlxuICAgIHwgUm9zeWJyb3duIC0+IFwicm9zeWJyb3duXCJcbiAgICB8IFJveWFsYmx1ZSAtPiBcInJveWFsYmx1ZVwiXG4gICAgfCBTYWRkbGVicm93biAtPiBcInNhZGRsZWJyb3duXCJcbiAgICB8IFNhbG1vbiAtPiBcInNhbG1vblwiXG4gICAgfCBTYW5keWJyb3duIC0+IFwic2FuZHlicm93blwiXG4gICAgfCBTZWFncmVlbiAtPiBcInNlYWdyZWVuXCJcbiAgICB8IFNlYXNoZWxsIC0+IFwic2Vhc2hlbGxcIlxuICAgIHwgU2llbm5hIC0+IFwic2llbm5hXCJcbiAgICB8IFNpbHZlciAtPiBcInNpbHZlclwiXG4gICAgfCBTa3libHVlIC0+IFwic2t5Ymx1ZVwiXG4gICAgfCBTbGF0ZWJsdWUgLT4gXCJzbGF0ZWJsdWVcIlxuICAgIHwgU2xhdGVncmF5IC0+IFwic2xhdGVncmF5XCJcbiAgICB8IFNsYXRlZ3JleSAtPiBcInNsYXRlZ3JleVwiXG4gICAgfCBTbm93IC0+IFwic25vd1wiXG4gICAgfCBTcHJpbmdncmVlbiAtPiBcInNwcmluZ2dyZWVuXCJcbiAgICB8IFN0ZWVsYmx1ZSAtPiBcInN0ZWVsYmx1ZVwiXG4gICAgfCBUYW4gLT4gXCJ0YW5cIlxuICAgIHwgVGVhbCAtPiBcInRlYWxcIlxuICAgIHwgVGhpc3RsZSAtPiBcInRoaXN0bGVcIlxuICAgIHwgVG9tYXRvIC0+IFwidG9tYXRvXCJcbiAgICB8IFR1cnF1b2lzZSAtPiBcInR1cnF1b2lzZVwiXG4gICAgfCBWaW9sZXQgLT4gXCJ2aW9sZXRcIlxuICAgIHwgV2hlYXQgLT4gXCJ3aGVhdFwiXG4gICAgfCBXaGl0ZSAtPiBcIndoaXRlXCJcbiAgICB8IFdoaXRlc21va2UgLT4gXCJ3aGl0ZXNtb2tlXCJcbiAgICB8IFllbGxvdyAtPiBcInllbGxvd1wiXG4gICAgfCBZZWxsb3dncmVlbiAtPiBcInllbGxvd2dyZWVuXCJcblxuICBsZXQgbmFtZV9vZl9zdHJpbmcgPSBmdW5jdGlvblxuICAgIHwgXCJhbGljZWJsdWVcIiAtPiBBbGljZWJsdWVcbiAgICB8IFwiYW50aXF1ZXdoaXRlXCIgLT4gQW50aXF1ZXdoaXRlXG4gICAgfCBcImFxdWFcIiAtPiBBcXVhXG4gICAgfCBcImFxdWFtYXJpbmVcIiAtPiBBcXVhbWFyaW5lXG4gICAgfCBcImF6dXJlXCIgLT4gQXp1cmVcbiAgICB8IFwiYmVpZ2VcIiAtPiBCZWlnZVxuICAgIHwgXCJiaXNxdWVcIiAtPiBCaXNxdWVcbiAgICB8IFwiYmxhY2tcIiAtPiBCbGFja1xuICAgIHwgXCJibGFuY2hlZGFsbW9uZFwiIC0+IEJsYW5jaGVkYWxtb25kXG4gICAgfCBcImJsdWVcIiAtPiBCbHVlXG4gICAgfCBcImJsdWV2aW9sZXRcIiAtPiBCbHVldmlvbGV0XG4gICAgfCBcImJyb3duXCIgLT4gQnJvd25cbiAgICB8IFwiYnVybHl3b29kXCIgLT4gQnVybHl3b29kXG4gICAgfCBcImNhZGV0Ymx1ZVwiIC0+IENhZGV0Ymx1ZVxuICAgIHwgXCJjaGFydHJldXNlXCIgLT4gQ2hhcnRyZXVzZVxuICAgIHwgXCJjaG9jb2xhdGVcIiAtPiBDaG9jb2xhdGVcbiAgICB8IFwiY29yYWxcIiAtPiBDb3JhbFxuICAgIHwgXCJjb3JuZmxvd2VyYmx1ZVwiIC0+IENvcm5mbG93ZXJibHVlXG4gICAgfCBcImNvcm5zaWxrXCIgLT4gQ29ybnNpbGtcbiAgICB8IFwiY3JpbXNvblwiIC0+IENyaW1zb25cbiAgICB8IFwiY3lhblwiIC0+IEN5YW5cbiAgICB8IFwiZGFya2JsdWVcIiAtPiBEYXJrYmx1ZVxuICAgIHwgXCJkYXJrY3lhblwiIC0+IERhcmtjeWFuXG4gICAgfCBcImRhcmtnb2xkZW5yb2RcIiAtPiBEYXJrZ29sZGVucm9kXG4gICAgfCBcImRhcmtncmF5XCIgLT4gRGFya2dyYXlcbiAgICB8IFwiZGFya2dyZWVuXCIgLT4gRGFya2dyZWVuXG4gICAgfCBcImRhcmtncmV5XCIgLT4gRGFya2dyZXlcbiAgICB8IFwiZGFya2toYWtpXCIgLT4gRGFya2toYWtpXG4gICAgfCBcImRhcmttYWdlbnRhXCIgLT4gRGFya21hZ2VudGFcbiAgICB8IFwiZGFya29saXZlZ3JlZW5cIiAtPiBEYXJrb2xpdmVncmVlblxuICAgIHwgXCJkYXJrb3JhbmdlXCIgLT4gRGFya29yYW5nZVxuICAgIHwgXCJkYXJrb3JjaGlkXCIgLT4gRGFya29yY2hpZFxuICAgIHwgXCJkYXJrcmVkXCIgLT4gRGFya3JlZFxuICAgIHwgXCJkYXJrc2FsbW9uXCIgLT4gRGFya3NhbG1vblxuICAgIHwgXCJkYXJrc2VhZ3JlZW5cIiAtPiBEYXJrc2VhZ3JlZW5cbiAgICB8IFwiZGFya3NsYXRlYmx1ZVwiIC0+IERhcmtzbGF0ZWJsdWVcbiAgICB8IFwiZGFya3NsYXRlZ3JheVwiIC0+IERhcmtzbGF0ZWdyYXlcbiAgICB8IFwiZGFya3NsYXRlZ3JleVwiIC0+IERhcmtzbGF0ZWdyZXlcbiAgICB8IFwiZGFya3R1cnF1b2lzZVwiIC0+IERhcmt0dXJxdW9pc2VcbiAgICB8IFwiZGFya3Zpb2xldFwiIC0+IERhcmt2aW9sZXRcbiAgICB8IFwiZGVlcHBpbmtcIiAtPiBEZWVwcGlua1xuICAgIHwgXCJkZWVwc2t5Ymx1ZVwiIC0+IERlZXBza3libHVlXG4gICAgfCBcImRpbWdyYXlcIiAtPiBEaW1ncmF5XG4gICAgfCBcImRpbWdyZXlcIiAtPiBEaW1ncmV5XG4gICAgfCBcImRvZGdlcmJsdWVcIiAtPiBEb2RnZXJibHVlXG4gICAgfCBcImZpcmVicmlja1wiIC0+IEZpcmVicmlja1xuICAgIHwgXCJmbG9yYWx3aGl0ZVwiIC0+IEZsb3JhbHdoaXRlXG4gICAgfCBcImZvcmVzdGdyZWVuXCIgLT4gRm9yZXN0Z3JlZW5cbiAgICB8IFwiZnVjaHNpYVwiIC0+IEZ1Y2hzaWFcbiAgICB8IFwiZ2FpbnNib3JvXCIgLT4gR2FpbnNib3JvXG4gICAgfCBcImdob3N0d2hpdGVcIiAtPiBHaG9zdHdoaXRlXG4gICAgfCBcImdvbGRcIiAtPiBHb2xkXG4gICAgfCBcImdvbGRlbnJvZFwiIC0+IEdvbGRlbnJvZFxuICAgIHwgXCJncmF5XCIgLT4gR3JheVxuICAgIHwgXCJncmVlblwiIC0+IEdyZWVuXG4gICAgfCBcImdyZWVueWVsbG93XCIgLT4gR3JlZW55ZWxsb3dcbiAgICB8IFwiZ3JleVwiIC0+IEdyZXlcbiAgICB8IFwiaG9uZXlkZXdcIiAtPiBIb25leWRld1xuICAgIHwgXCJob3RwaW5rXCIgLT4gSG90cGlua1xuICAgIHwgXCJpbmRpYW5yZWRcIiAtPiBJbmRpYW5yZWRcbiAgICB8IFwiaW5kaWdvXCIgLT4gSW5kaWdvXG4gICAgfCBcIml2b3J5XCIgLT4gSXZvcnlcbiAgICB8IFwia2hha2lcIiAtPiBLaGFraVxuICAgIHwgXCJsYXZlbmRlclwiIC0+IExhdmVuZGVyXG4gICAgfCBcImxhdmVuZGVyYmx1c2hcIiAtPiBMYXZlbmRlcmJsdXNoXG4gICAgfCBcImxhd25ncmVlblwiIC0+IExhd25ncmVlblxuICAgIHwgXCJsZW1vbmNoaWZmb25cIiAtPiBMZW1vbmNoaWZmb25cbiAgICB8IFwibGlnaHRibHVlXCIgLT4gTGlnaHRibHVlXG4gICAgfCBcImxpZ2h0Y29yYWxcIiAtPiBMaWdodGNvcmFsXG4gICAgfCBcImxpZ2h0Y3lhblwiIC0+IExpZ2h0Y3lhblxuICAgIHwgXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiIC0+IExpZ2h0Z29sZGVucm9keWVsbG93XG4gICAgfCBcImxpZ2h0Z3JheVwiIC0+IExpZ2h0Z3JheVxuICAgIHwgXCJsaWdodGdyZWVuXCIgLT4gTGlnaHRncmVlblxuICAgIHwgXCJsaWdodGdyZXlcIiAtPiBMaWdodGdyZXlcbiAgICB8IFwibGlnaHRwaW5rXCIgLT4gTGlnaHRwaW5rXG4gICAgfCBcImxpZ2h0c2FsbW9uXCIgLT4gTGlnaHRzYWxtb25cbiAgICB8IFwibGlnaHRzZWFncmVlblwiIC0+IExpZ2h0c2VhZ3JlZW5cbiAgICB8IFwibGlnaHRza3libHVlXCIgLT4gTGlnaHRza3libHVlXG4gICAgfCBcImxpZ2h0c2xhdGVncmF5XCIgLT4gTGlnaHRzbGF0ZWdyYXlcbiAgICB8IFwibGlnaHRzbGF0ZWdyZXlcIiAtPiBMaWdodHNsYXRlZ3JleVxuICAgIHwgXCJsaWdodHN0ZWVsYmx1ZVwiIC0+IExpZ2h0c3RlZWxibHVlXG4gICAgfCBcImxpZ2h0eWVsbG93XCIgLT4gTGlnaHR5ZWxsb3dcbiAgICB8IFwibGltZVwiIC0+IExpbWVcbiAgICB8IFwibGltZWdyZWVuXCIgLT4gTGltZWdyZWVuXG4gICAgfCBcImxpbmVuXCIgLT4gTGluZW5cbiAgICB8IFwibWFnZW50YVwiIC0+IE1hZ2VudGFcbiAgICB8IFwibWFyb29uXCIgLT4gTWFyb29uXG4gICAgfCBcIm1lZGl1bWFxdWFtYXJpbmVcIiAtPiBNZWRpdW1hcXVhbWFyaW5lXG4gICAgfCBcIm1lZGl1bWJsdWVcIiAtPiBNZWRpdW1ibHVlXG4gICAgfCBcIm1lZGl1bW9yY2hpZFwiIC0+IE1lZGl1bW9yY2hpZFxuICAgIHwgXCJtZWRpdW1wdXJwbGVcIiAtPiBNZWRpdW1wdXJwbGVcbiAgICB8IFwibWVkaXVtc2VhZ3JlZW5cIiAtPiBNZWRpdW1zZWFncmVlblxuICAgIHwgXCJtZWRpdW1zbGF0ZWJsdWVcIiAtPiBNZWRpdW1zbGF0ZWJsdWVcbiAgICB8IFwibWVkaXVtc3ByaW5nZ3JlZW5cIiAtPiBNZWRpdW1zcHJpbmdncmVlblxuICAgIHwgXCJtZWRpdW10dXJxdW9pc2VcIiAtPiBNZWRpdW10dXJxdW9pc2VcbiAgICB8IFwibWVkaXVtdmlvbGV0cmVkXCIgLT4gTWVkaXVtdmlvbGV0cmVkXG4gICAgfCBcIm1pZG5pZ2h0Ymx1ZVwiIC0+IE1pZG5pZ2h0Ymx1ZVxuICAgIHwgXCJtaW50Y3JlYW1cIiAtPiBNaW50Y3JlYW1cbiAgICB8IFwibWlzdHlyb3NlXCIgLT4gTWlzdHlyb3NlXG4gICAgfCBcIm1vY2Nhc2luXCIgLT4gTW9jY2FzaW5cbiAgICB8IFwibmF2YWpvd2hpdGVcIiAtPiBOYXZham93aGl0ZVxuICAgIHwgXCJuYXZ5XCIgLT4gTmF2eVxuICAgIHwgXCJvbGRsYWNlXCIgLT4gT2xkbGFjZVxuICAgIHwgXCJvbGl2ZVwiIC0+IE9saXZlXG4gICAgfCBcIm9saXZlZHJhYlwiIC0+IE9saXZlZHJhYlxuICAgIHwgXCJvcmFuZ2VcIiAtPiBPcmFuZ2VcbiAgICB8IFwib3JhbmdlcmVkXCIgLT4gT3JhbmdlcmVkXG4gICAgfCBcIm9yY2hpZFwiIC0+IE9yY2hpZFxuICAgIHwgXCJwYWxlZ29sZGVucm9kXCIgLT4gUGFsZWdvbGRlbnJvZFxuICAgIHwgXCJwYWxlZ3JlZW5cIiAtPiBQYWxlZ3JlZW5cbiAgICB8IFwicGFsZXR1cnF1b2lzZVwiIC0+IFBhbGV0dXJxdW9pc2VcbiAgICB8IFwicGFsZXZpb2xldHJlZFwiIC0+IFBhbGV2aW9sZXRyZWRcbiAgICB8IFwicGFwYXlhd2hpcFwiIC0+IFBhcGF5YXdoaXBcbiAgICB8IFwicGVhY2hwdWZmXCIgLT4gUGVhY2hwdWZmXG4gICAgfCBcInBlcnVcIiAtPiBQZXJ1XG4gICAgfCBcInBpbmtcIiAtPiBQaW5rXG4gICAgfCBcInBsdW1cIiAtPiBQbHVtXG4gICAgfCBcInBvd2RlcmJsdWVcIiAtPiBQb3dkZXJibHVlXG4gICAgfCBcInB1cnBsZVwiIC0+IFB1cnBsZVxuICAgIHwgXCJyZWRcIiAtPiBSZWRcbiAgICB8IFwicm9zeWJyb3duXCIgLT4gUm9zeWJyb3duXG4gICAgfCBcInJveWFsYmx1ZVwiIC0+IFJveWFsYmx1ZVxuICAgIHwgXCJzYWRkbGVicm93blwiIC0+IFNhZGRsZWJyb3duXG4gICAgfCBcInNhbG1vblwiIC0+IFNhbG1vblxuICAgIHwgXCJzYW5keWJyb3duXCIgLT4gU2FuZHlicm93blxuICAgIHwgXCJzZWFncmVlblwiIC0+IFNlYWdyZWVuXG4gICAgfCBcInNlYXNoZWxsXCIgLT4gU2Vhc2hlbGxcbiAgICB8IFwic2llbm5hXCIgLT4gU2llbm5hXG4gICAgfCBcInNpbHZlclwiIC0+IFNpbHZlclxuICAgIHwgXCJza3libHVlXCIgLT4gU2t5Ymx1ZVxuICAgIHwgXCJzbGF0ZWJsdWVcIiAtPiBTbGF0ZWJsdWVcbiAgICB8IFwic2xhdGVncmF5XCIgLT4gU2xhdGVncmF5XG4gICAgfCBcInNsYXRlZ3JleVwiIC0+IFNsYXRlZ3JleVxuICAgIHwgXCJzbm93XCIgLT4gU25vd1xuICAgIHwgXCJzcHJpbmdncmVlblwiIC0+IFNwcmluZ2dyZWVuXG4gICAgfCBcInN0ZWVsYmx1ZVwiIC0+IFN0ZWVsYmx1ZVxuICAgIHwgXCJ0YW5cIiAtPiBUYW5cbiAgICB8IFwidGVhbFwiIC0+IFRlYWxcbiAgICB8IFwidGhpc3RsZVwiIC0+IFRoaXN0bGVcbiAgICB8IFwidG9tYXRvXCIgLT4gVG9tYXRvXG4gICAgfCBcInR1cnF1b2lzZVwiIC0+IFR1cnF1b2lzZVxuICAgIHwgXCJ2aW9sZXRcIiAtPiBWaW9sZXRcbiAgICB8IFwid2hlYXRcIiAtPiBXaGVhdFxuICAgIHwgXCJ3aGl0ZVwiIC0+IFdoaXRlXG4gICAgfCBcIndoaXRlc21va2VcIiAtPiBXaGl0ZXNtb2tlXG4gICAgfCBcInllbGxvd1wiIC0+IFllbGxvd1xuICAgIHwgXCJ5ZWxsb3dncmVlblwiIC0+IFllbGxvd2dyZWVuXG4gICAgfCBzIC0+IHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IChzIF4gXCIgaXMgbm90IGEgdmFsaWQgY29sb3IgbmFtZVwiKSlcblxuICBsZXQgcmdiX29mX25hbWUgPSBmdW5jdGlvblxuICAgIHwgQWxpY2VibHVlIC0+IDI0MCwgMjQ4LCAyNTVcbiAgICB8IEFudGlxdWV3aGl0ZSAtPiAyNTAsIDIzNSwgMjE1XG4gICAgfCBBcXVhIC0+IDAsIDI1NSwgMjU1XG4gICAgfCBBcXVhbWFyaW5lIC0+IDEyNywgMjU1LCAyMTJcbiAgICB8IEF6dXJlIC0+IDI0MCwgMjU1LCAyNTVcbiAgICB8IEJlaWdlIC0+IDI0NSwgMjQ1LCAyMjBcbiAgICB8IEJpc3F1ZSAtPiAyNTUsIDIyOCwgMTk2XG4gICAgfCBCbGFjayAtPiAwLCAwLCAwXG4gICAgfCBCbGFuY2hlZGFsbW9uZCAtPiAyNTUsIDIzNSwgMjA1XG4gICAgfCBCbHVlIC0+IDAsIDAsIDI1NVxuICAgIHwgQmx1ZXZpb2xldCAtPiAxMzgsIDQzLCAyMjZcbiAgICB8IEJyb3duIC0+IDE2NSwgNDIsIDQyXG4gICAgfCBCdXJseXdvb2QgLT4gMjIyLCAxODQsIDEzNVxuICAgIHwgQ2FkZXRibHVlIC0+IDk1LCAxNTgsIDE2MFxuICAgIHwgQ2hhcnRyZXVzZSAtPiAxMjcsIDI1NSwgMFxuICAgIHwgQ2hvY29sYXRlIC0+IDIxMCwgMTA1LCAzMFxuICAgIHwgQ29yYWwgLT4gMjU1LCAxMjcsIDgwXG4gICAgfCBDb3JuZmxvd2VyYmx1ZSAtPiAxMDAsIDE0OSwgMjM3XG4gICAgfCBDb3Juc2lsayAtPiAyNTUsIDI0OCwgMjIwXG4gICAgfCBDcmltc29uIC0+IDIyMCwgMjAsIDYwXG4gICAgfCBDeWFuIC0+IDAsIDI1NSwgMjU1XG4gICAgfCBEYXJrYmx1ZSAtPiAwLCAwLCAxMzlcbiAgICB8IERhcmtjeWFuIC0+IDAsIDEzOSwgMTM5XG4gICAgfCBEYXJrZ29sZGVucm9kIC0+IDE4NCwgMTM0LCAxMVxuICAgIHwgRGFya2dyYXkgLT4gMTY5LCAxNjksIDE2OVxuICAgIHwgRGFya2dyZWVuIC0+IDAsIDEwMCwgMFxuICAgIHwgRGFya2dyZXkgLT4gMTY5LCAxNjksIDE2OVxuICAgIHwgRGFya2toYWtpIC0+IDE4OSwgMTgzLCAxMDdcbiAgICB8IERhcmttYWdlbnRhIC0+IDEzOSwgMCwgMTM5XG4gICAgfCBEYXJrb2xpdmVncmVlbiAtPiA4NSwgMTA3LCA0N1xuICAgIHwgRGFya29yYW5nZSAtPiAyNTUsIDE0MCwgMFxuICAgIHwgRGFya29yY2hpZCAtPiAxNTMsIDUwLCAyMDRcbiAgICB8IERhcmtyZWQgLT4gMTM5LCAwLCAwXG4gICAgfCBEYXJrc2FsbW9uIC0+IDIzMywgMTUwLCAxMjJcbiAgICB8IERhcmtzZWFncmVlbiAtPiAxNDMsIDE4OCwgMTQzXG4gICAgfCBEYXJrc2xhdGVibHVlIC0+IDcyLCA2MSwgMTM5XG4gICAgfCBEYXJrc2xhdGVncmF5IC0+IDQ3LCA3OSwgNzlcbiAgICB8IERhcmtzbGF0ZWdyZXkgLT4gNDcsIDc5LCA3OVxuICAgIHwgRGFya3R1cnF1b2lzZSAtPiAwLCAyMDYsIDIwOVxuICAgIHwgRGFya3Zpb2xldCAtPiAxNDgsIDAsIDIxMVxuICAgIHwgRGVlcHBpbmsgLT4gMjU1LCAyMCwgMTQ3XG4gICAgfCBEZWVwc2t5Ymx1ZSAtPiAwLCAxOTEsIDI1NVxuICAgIHwgRGltZ3JheSAtPiAxMDUsIDEwNSwgMTA1XG4gICAgfCBEaW1ncmV5IC0+IDEwNSwgMTA1LCAxMDVcbiAgICB8IERvZGdlcmJsdWUgLT4gMzAsIDE0NCwgMjU1XG4gICAgfCBGaXJlYnJpY2sgLT4gMTc4LCAzNCwgMzRcbiAgICB8IEZsb3JhbHdoaXRlIC0+IDI1NSwgMjUwLCAyNDBcbiAgICB8IEZvcmVzdGdyZWVuIC0+IDM0LCAxMzksIDM0XG4gICAgfCBGdWNoc2lhIC0+IDI1NSwgMCwgMjU1XG4gICAgfCBHYWluc2Jvcm8gLT4gMjIwLCAyMjAsIDIyMFxuICAgIHwgR2hvc3R3aGl0ZSAtPiAyNDgsIDI0OCwgMjU1XG4gICAgfCBHb2xkIC0+IDI1NSwgMjE1LCAwXG4gICAgfCBHb2xkZW5yb2QgLT4gMjE4LCAxNjUsIDMyXG4gICAgfCBHcmF5IC0+IDEyOCwgMTI4LCAxMjhcbiAgICB8IEdyZWVuIC0+IDAsIDEyOCwgMFxuICAgIHwgR3JlZW55ZWxsb3cgLT4gMTczLCAyNTUsIDQ3XG4gICAgfCBHcmV5IC0+IDEyOCwgMTI4LCAxMjhcbiAgICB8IEhvbmV5ZGV3IC0+IDI0MCwgMjU1LCAyNDBcbiAgICB8IEhvdHBpbmsgLT4gMjU1LCAxMDUsIDE4MFxuICAgIHwgSW5kaWFucmVkIC0+IDIwNSwgOTIsIDkyXG4gICAgfCBJbmRpZ28gLT4gNzUsIDAsIDEzMFxuICAgIHwgSXZvcnkgLT4gMjU1LCAyNTUsIDI0MFxuICAgIHwgS2hha2kgLT4gMjQwLCAyMzAsIDE0MFxuICAgIHwgTGF2ZW5kZXIgLT4gMjMwLCAyMzAsIDI1MFxuICAgIHwgTGF2ZW5kZXJibHVzaCAtPiAyNTUsIDI0MCwgMjQ1XG4gICAgfCBMYXduZ3JlZW4gLT4gMTI0LCAyNTIsIDBcbiAgICB8IExlbW9uY2hpZmZvbiAtPiAyNTUsIDI1MCwgMjA1XG4gICAgfCBMaWdodGJsdWUgLT4gMTczLCAyMTYsIDIzMFxuICAgIHwgTGlnaHRjb3JhbCAtPiAyNDAsIDEyOCwgMTI4XG4gICAgfCBMaWdodGN5YW4gLT4gMjI0LCAyNTUsIDI1NVxuICAgIHwgTGlnaHRnb2xkZW5yb2R5ZWxsb3cgLT4gMjUwLCAyNTAsIDIxMFxuICAgIHwgTGlnaHRncmF5IC0+IDIxMSwgMjExLCAyMTFcbiAgICB8IExpZ2h0Z3JlZW4gLT4gMTQ0LCAyMzgsIDE0NFxuICAgIHwgTGlnaHRncmV5IC0+IDIxMSwgMjExLCAyMTFcbiAgICB8IExpZ2h0cGluayAtPiAyNTUsIDE4MiwgMTkzXG4gICAgfCBMaWdodHNhbG1vbiAtPiAyNTUsIDE2MCwgMTIyXG4gICAgfCBMaWdodHNlYWdyZWVuIC0+IDMyLCAxNzgsIDE3MFxuICAgIHwgTGlnaHRza3libHVlIC0+IDEzNSwgMjA2LCAyNTBcbiAgICB8IExpZ2h0c2xhdGVncmF5IC0+IDExOSwgMTM2LCAxNTNcbiAgICB8IExpZ2h0c2xhdGVncmV5IC0+IDExOSwgMTM2LCAxNTNcbiAgICB8IExpZ2h0c3RlZWxibHVlIC0+IDE3NiwgMTk2LCAyMjJcbiAgICB8IExpZ2h0eWVsbG93IC0+IDI1NSwgMjU1LCAyMjRcbiAgICB8IExpbWUgLT4gMCwgMjU1LCAwXG4gICAgfCBMaW1lZ3JlZW4gLT4gNTAsIDIwNSwgNTBcbiAgICB8IExpbmVuIC0+IDI1MCwgMjQwLCAyMzBcbiAgICB8IE1hZ2VudGEgLT4gMjU1LCAwLCAyNTVcbiAgICB8IE1hcm9vbiAtPiAxMjgsIDAsIDBcbiAgICB8IE1lZGl1bWFxdWFtYXJpbmUgLT4gMTAyLCAyMDUsIDE3MFxuICAgIHwgTWVkaXVtYmx1ZSAtPiAwLCAwLCAyMDVcbiAgICB8IE1lZGl1bW9yY2hpZCAtPiAxODYsIDg1LCAyMTFcbiAgICB8IE1lZGl1bXB1cnBsZSAtPiAxNDcsIDExMiwgMjE5XG4gICAgfCBNZWRpdW1zZWFncmVlbiAtPiA2MCwgMTc5LCAxMTNcbiAgICB8IE1lZGl1bXNsYXRlYmx1ZSAtPiAxMjMsIDEwNCwgMjM4XG4gICAgfCBNZWRpdW1zcHJpbmdncmVlbiAtPiAwLCAyNTAsIDE1NFxuICAgIHwgTWVkaXVtdHVycXVvaXNlIC0+IDcyLCAyMDksIDIwNFxuICAgIHwgTWVkaXVtdmlvbGV0cmVkIC0+IDE5OSwgMjEsIDEzM1xuICAgIHwgTWlkbmlnaHRibHVlIC0+IDI1LCAyNSwgMTEyXG4gICAgfCBNaW50Y3JlYW0gLT4gMjQ1LCAyNTUsIDI1MFxuICAgIHwgTWlzdHlyb3NlIC0+IDI1NSwgMjI4LCAyMjVcbiAgICB8IE1vY2Nhc2luIC0+IDI1NSwgMjI4LCAxODFcbiAgICB8IE5hdmFqb3doaXRlIC0+IDI1NSwgMjIyLCAxNzNcbiAgICB8IE5hdnkgLT4gMCwgMCwgMTI4XG4gICAgfCBPbGRsYWNlIC0+IDI1MywgMjQ1LCAyMzBcbiAgICB8IE9saXZlIC0+IDEyOCwgMTI4LCAwXG4gICAgfCBPbGl2ZWRyYWIgLT4gMTA3LCAxNDIsIDM1XG4gICAgfCBPcmFuZ2UgLT4gMjU1LCAxNjUsIDBcbiAgICB8IE9yYW5nZXJlZCAtPiAyNTUsIDY5LCAwXG4gICAgfCBPcmNoaWQgLT4gMjE4LCAxMTIsIDIxNFxuICAgIHwgUGFsZWdvbGRlbnJvZCAtPiAyMzgsIDIzMiwgMTcwXG4gICAgfCBQYWxlZ3JlZW4gLT4gMTUyLCAyNTEsIDE1MlxuICAgIHwgUGFsZXR1cnF1b2lzZSAtPiAxNzUsIDIzOCwgMjM4XG4gICAgfCBQYWxldmlvbGV0cmVkIC0+IDIxOSwgMTEyLCAxNDdcbiAgICB8IFBhcGF5YXdoaXAgLT4gMjU1LCAyMzksIDIxM1xuICAgIHwgUGVhY2hwdWZmIC0+IDI1NSwgMjE4LCAxODVcbiAgICB8IFBlcnUgLT4gMjA1LCAxMzMsIDYzXG4gICAgfCBQaW5rIC0+IDI1NSwgMTkyLCAyMDNcbiAgICB8IFBsdW0gLT4gMjIxLCAxNjAsIDIyMVxuICAgIHwgUG93ZGVyYmx1ZSAtPiAxNzYsIDIyNCwgMjMwXG4gICAgfCBQdXJwbGUgLT4gMTI4LCAwLCAxMjhcbiAgICB8IFJlZCAtPiAyNTUsIDAsIDBcbiAgICB8IFJvc3licm93biAtPiAxODgsIDE0MywgMTQzXG4gICAgfCBSb3lhbGJsdWUgLT4gNjUsIDEwNSwgMjI1XG4gICAgfCBTYWRkbGVicm93biAtPiAxMzksIDY5LCAxOVxuICAgIHwgU2FsbW9uIC0+IDI1MCwgMTI4LCAxMTRcbiAgICB8IFNhbmR5YnJvd24gLT4gMjQ0LCAxNjQsIDk2XG4gICAgfCBTZWFncmVlbiAtPiA0NiwgMTM5LCA4N1xuICAgIHwgU2Vhc2hlbGwgLT4gMjU1LCAyNDUsIDIzOFxuICAgIHwgU2llbm5hIC0+IDE2MCwgODIsIDQ1XG4gICAgfCBTaWx2ZXIgLT4gMTkyLCAxOTIsIDE5MlxuICAgIHwgU2t5Ymx1ZSAtPiAxMzUsIDIwNiwgMjM1XG4gICAgfCBTbGF0ZWJsdWUgLT4gMTA2LCA5MCwgMjA1XG4gICAgfCBTbGF0ZWdyYXkgLT4gMTEyLCAxMjgsIDE0NFxuICAgIHwgU2xhdGVncmV5IC0+IDExMiwgMTI4LCAxNDRcbiAgICB8IFNub3cgLT4gMjU1LCAyNTAsIDI1MFxuICAgIHwgU3ByaW5nZ3JlZW4gLT4gMCwgMjU1LCAxMjdcbiAgICB8IFN0ZWVsYmx1ZSAtPiA3MCwgMTMwLCAxODBcbiAgICB8IFRhbiAtPiAyMTAsIDE4MCwgMTQwXG4gICAgfCBUZWFsIC0+IDAsIDEyOCwgMTI4XG4gICAgfCBUaGlzdGxlIC0+IDIxNiwgMTkxLCAyMTZcbiAgICB8IFRvbWF0byAtPiAyNTUsIDk5LCA3MVxuICAgIHwgVHVycXVvaXNlIC0+IDY0LCAyMjQsIDIwOFxuICAgIHwgVmlvbGV0IC0+IDIzOCwgMTMwLCAyMzhcbiAgICB8IFdoZWF0IC0+IDI0NSwgMjIyLCAxNzlcbiAgICB8IFdoaXRlIC0+IDI1NSwgMjU1LCAyNTVcbiAgICB8IFdoaXRlc21va2UgLT4gMjQ1LCAyNDUsIDI0NVxuICAgIHwgWWVsbG93IC0+IDI1NSwgMjU1LCAwXG4gICAgfCBZZWxsb3dncmVlbiAtPiAxNTQsIDIwNSwgNTBcblxuICB0eXBlIHQgPVxuICAgIHwgTmFtZSBvZiBuYW1lXG4gICAgfCBSR0Igb2YgKGludCAqIGludCAqIGludClcbiAgICAgICAgKCoqIFJlZCwgR3JlZW4gYW5kIEJsdWUgdmFsdWVzLiBDbGlwcGVkIHRvIFtbMC4uMjU1XV0gYnkgbW9zdCAoQWxsPylcbiAgICAgICAgICAgIGJyb3dzZXJzLiAqKVxuICAgIHwgUkdCX3BlcmNlbnQgb2YgKGludCAqIGludCAqIGludClcbiAgICAgICAgKCoqIFJHQiBjaGFubmVscyBhcmUgc3BlY2lmaWVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGVpciBtYXhpbWFsIHZhbHVlLiAqKVxuICAgIHwgUkdCQSBvZiAoaW50ICogaW50ICogaW50ICogZmxvYXQpXG4gICAgICAgICgqKiBTYW1lIGFzIFJHQiB3aXRoIGFkZGl0aW9uYWwgdHJhbnNwYXJlbmN5IGFyZ3VtZW50LiBPcGFjaXR5IHNob3VsZCBiZSBpblxuICAgICAgICAgICAgWzAuXSAoY29tcGxldGVseSB0cmFuc3BhcmVudCkgYW5kIFsxLl0gKGNvbXBsZXRlbHkgb3BhcXVlKS4gKilcbiAgICB8IFJHQkFfcGVyY2VudCBvZiAoaW50ICogaW50ICogaW50ICogZmxvYXQpXG4gICAgICAgICgqKiBSR0IgY2hhbm5lbHMgc3BlY2lmaWVkIGFzIHBlcmNlbnRhZ2Ugb2YgdGhlaXIgbWF4aW1hbCB2YWx1ZS4gQWxwaGFcbiAgICAgICAgICAgIGNoYW5uZWwgKG9wYWNpdHkpIGlzIHN0aWxsIGEgWzAuXSB0byBbMS5dIGZsb2F0LiAqKVxuICAgIHwgSFNMIG9mIChpbnQgKiBpbnQgKiBpbnQpXG4gICAgICAgICgqKiBIdWUsIFNhdHVyYXRpb24gYW5kIExpZ2h0bmVzcyB2YWx1ZXMuIEh1ZSBpcyBhbiBhbmdsZSBpbiBkZWdyZWUgKGluXG4gICAgICAgICAgICBpbnRlcnZhbCBbWzAuLjM2MFtdKS4gU2F0dXJhdGlvbiBpcyBhIHBlcmNlbnRhZ2UgKFtbMC4uMTAwXV0pIHdpdGggWzBdXG4gICAgICAgICAgICBiZWluZyBjb2xvcmxlc3MuIExpZ2h0bmVzcyBpcyBhbHNvIGEgcGVyY2VudGFnZSAoW1swLi4xMDBdXSkgd2l0aCBbMF1cbiAgICAgICAgICAgIGJlaW5nIGJsYWNrLiAqKVxuICAgIHwgSFNMQSBvZiAoaW50ICogaW50ICogaW50ICogZmxvYXQpXG4gICAgICAgICgqKiBTYW1lIGFzIEhTTCB3aXRoIGFuIG9wYWNpdHkgYXJndW1lbnQgYmV0d2VlbiBbMC5dIGFuZCBbMS5dLiAqKVxuXG4gIGxldCByZ2IgP2EgciBnIGIgPVxuICAgIG1hdGNoIGEgd2l0aFxuICAgIHwgTm9uZSAtPiBSR0IgKHIsIGcsIGIpXG4gICAgfCBTb21lIGEgLT4gUkdCQSAociwgZywgYiwgYSlcblxuICBsZXQgaHNsID9hIGggcyBsID1cbiAgICBtYXRjaCBhIHdpdGhcbiAgICB8IE5vbmUgLT4gSFNMIChoLCBzLCBsKVxuICAgIHwgU29tZSBhIC0+IEhTTEEgKGgsIHMsIGwsIGEpXG5cbiAgbGV0IHN0cmluZ19vZl90ID0gZnVuY3Rpb25cbiAgICB8IE5hbWUgbiAtPiBzdHJpbmdfb2ZfbmFtZSBuXG4gICAgfCBSR0IgKHIsIGcsIGIpIC0+IFByaW50Zi5zcHJpbnRmIFwicmdiKCVkLCVkLCVkKVwiIHIgZyBiXG4gICAgfCBSR0JfcGVyY2VudCAociwgZywgYikgLT4gUHJpbnRmLnNwcmludGYgXCJyZ2IoJWQlJSwlZCUlLCVkJSUpXCIgciBnIGJcbiAgICB8IFJHQkEgKHIsIGcsIGIsIGEpIC0+IFByaW50Zi5zcHJpbnRmIFwicmdiYSglZCwlZCwlZCwlZilcIiByIGcgYiBhXG4gICAgfCBSR0JBX3BlcmNlbnQgKHIsIGcsIGIsIGEpIC0+IFByaW50Zi5zcHJpbnRmIFwicmdiYSglZCUlLCVkJSUsJWQlJSwlZilcIiByIGcgYiBhXG4gICAgfCBIU0wgKGgsIHMsIGwpIC0+IFByaW50Zi5zcHJpbnRmIFwiaHNsKCVkLCVkJSUsJWQlJSlcIiBoIHMgbFxuICAgIHwgSFNMQSAoaCwgcywgbCwgYSkgLT4gUHJpbnRmLnNwcmludGYgXCJoc2xhKCVkLCVkJSUsJWQlJSwlZilcIiBoIHMgbCBhXG5cbiAgbGV0IGhleF9vZl9yZ2IgKHJlZCwgZ3JlZW4sIGJsdWUpID1cbiAgICBsZXQgaW5fcmFuZ2UgaSA9XG4gICAgICBpZiBpIDwgMCB8fCBpID4gMjU1XG4gICAgICB0aGVuIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IChzdHJpbmdfb2ZfaW50IGkgXiBcIiBpcyBvdXQgb2YgdmFsaWQgcmFuZ2VcIikpXG4gICAgaW5cbiAgICBpbl9yYW5nZSByZWQ7XG4gICAgaW5fcmFuZ2UgZ3JlZW47XG4gICAgaW5fcmFuZ2UgYmx1ZTtcbiAgICBQcmludGYuc3ByaW50ZiBcIiMlMDJYJTAyWCUwMlhcIiByZWQgZ3JlZW4gYmx1ZVxuXG4gICgqIE9jYW1sIDwtPiBKUyByZXByZXNlbnRhdGlvbiAqKVxuICB0eXBlIGpzX3QgPSBKcy5qc19zdHJpbmcgSnMudFxuXG4gICgqIFRPRE8/IGJlIG1vcmUgcmVzdHJpY3RpdmUsIGNsaXAgdmFsdWVzIGludG8gc3RhbmRhcmQgcmFuZ2UgKilcbiAgbGV0IGpzX3Rfb2ZfanNfc3RyaW5nIHMgPVxuICAgIGxldCByZ2JfcmUgPVxuICAgICAgbmV3JWpzIEpzLnJlZ0V4cCAoSnMuYnl0ZXN0cmluZyBcIl5yZ2JcXFxcKFxcXFxzKlxcXFxkKixcXFxccypcXFxcZCosXFxcXHMqXFxcXGQqXFxcXCkkXCIpXG4gICAgaW5cbiAgICBsZXQgcmdiX3BjdF9yZSA9XG4gICAgICBuZXclanMgSnMucmVnRXhwIChKcy5ieXRlc3RyaW5nIFwiXnJnYlxcXFwoXFxcXHMqXFxcXGQqJSxcXFxccypcXFxcZColLFxcXFxzKlxcXFxkKiVcXFxcKSRcIilcbiAgICBpblxuICAgIGxldCByZ2JhX3JlID1cbiAgICAgIG5ldyVqcyBKcy5yZWdFeHBcbiAgICAgICAgKEpzLmJ5dGVzdHJpbmcgXCJecmdiYVxcXFwoXFxcXHMqXFxcXGQqLFxcXFxzKlxcXFxkKixcXFxccypcXFxcZCosXFxcXGQqXFxcXC4/XFxcXGQqXFxcXCkkXCIpXG4gICAgaW5cbiAgICBsZXQgcmdiYV9wY3RfcmUgPVxuICAgICAgbmV3JWpzIEpzLnJlZ0V4cFxuICAgICAgICAoSnMuYnl0ZXN0cmluZyBcIl5yZ2JhXFxcXChcXFxccypcXFxcZColLFxcXFxzKlxcXFxkKiUsXFxcXHMqXFxcXGQqJSxcXFxcZCpcXFxcLj9cXFxcZCpcXFxcKSRcIilcbiAgICBpblxuICAgIGxldCBoc2xfcmUgPVxuICAgICAgbmV3JWpzIEpzLnJlZ0V4cCAoSnMuYnl0ZXN0cmluZyBcIl5oc2xcXFxcKFxcXFxzKlxcXFxkKixcXFxccypcXFxcZColLFxcXFxzKlxcXFxkKiVcXFxcKSRcIilcbiAgICBpblxuICAgIGxldCBoc2xhX3JlID1cbiAgICAgIG5ldyVqcyBKcy5yZWdFeHBcbiAgICAgICAgKEpzLmJ5dGVzdHJpbmcgXCJeaHNsYVxcXFwoXFxcXHMqXFxcXGQqLFxcXFxzKlxcXFxkKiUsXFxcXHMqXFxcXGQqJSxcXFxcZCpcXFxcLj9cXFxcZCpcXFxcKSRcIilcbiAgICBpblxuICAgIGlmIEpzLnRvX2Jvb2wgKHJnYl9yZSMjdGVzdCBzKVxuICAgICAgIHx8IEpzLnRvX2Jvb2wgKHJnYmFfcmUjI3Rlc3QgcylcbiAgICAgICB8fCBKcy50b19ib29sIChyZ2JfcGN0X3JlIyN0ZXN0IHMpXG4gICAgICAgfHwgSnMudG9fYm9vbCAocmdiYV9wY3RfcmUjI3Rlc3QgcylcbiAgICAgICB8fCBKcy50b19ib29sIChoc2xfcmUjI3Rlc3QgcylcbiAgICAgICB8fCBKcy50b19ib29sIChoc2xhX3JlIyN0ZXN0IHMpXG4gICAgdGhlbiBzXG4gICAgZWxzZSBpZiBMaXN0Lm1lbVxuICAgICAgICAgICAgICAoSnMudG9fc3RyaW5nIHMpXG4gICAgICAgICAgICAgIFsgXCJhbGljZWJsdWVcIlxuICAgICAgICAgICAgICA7IFwiYW50aXF1ZXdoaXRlXCJcbiAgICAgICAgICAgICAgOyBcImFxdWFcIlxuICAgICAgICAgICAgICA7IFwiYXF1YW1hcmluZVwiXG4gICAgICAgICAgICAgIDsgXCJhenVyZVwiXG4gICAgICAgICAgICAgIDsgXCJiZWlnZVwiXG4gICAgICAgICAgICAgIDsgXCJiaXNxdWVcIlxuICAgICAgICAgICAgICA7IFwiYmxhY2tcIlxuICAgICAgICAgICAgICA7IFwiYmxhbmNoZWRhbG1vbmRcIlxuICAgICAgICAgICAgICA7IFwiYmx1ZVwiXG4gICAgICAgICAgICAgIDsgXCJibHVldmlvbGV0XCJcbiAgICAgICAgICAgICAgOyBcImJyb3duXCJcbiAgICAgICAgICAgICAgOyBcImJ1cmx5d29vZFwiXG4gICAgICAgICAgICAgIDsgXCJjYWRldGJsdWVcIlxuICAgICAgICAgICAgICA7IFwiY2hhcnRyZXVzZVwiXG4gICAgICAgICAgICAgIDsgXCJjaG9jb2xhdGVcIlxuICAgICAgICAgICAgICA7IFwiY29yYWxcIlxuICAgICAgICAgICAgICA7IFwiY29ybmZsb3dlcmJsdWVcIlxuICAgICAgICAgICAgICA7IFwiY29ybnNpbGtcIlxuICAgICAgICAgICAgICA7IFwiY3JpbXNvblwiXG4gICAgICAgICAgICAgIDsgXCJjeWFuXCJcbiAgICAgICAgICAgICAgOyBcImRhcmtibHVlXCJcbiAgICAgICAgICAgICAgOyBcImRhcmtjeWFuXCJcbiAgICAgICAgICAgICAgOyBcImRhcmtnb2xkZW5yb2RcIlxuICAgICAgICAgICAgICA7IFwiZGFya2dyYXlcIlxuICAgICAgICAgICAgICA7IFwiZGFya2dyZWVuXCJcbiAgICAgICAgICAgICAgOyBcImRhcmtncmV5XCJcbiAgICAgICAgICAgICAgOyBcImRhcmtraGFraVwiXG4gICAgICAgICAgICAgIDsgXCJkYXJrbWFnZW50YVwiXG4gICAgICAgICAgICAgIDsgXCJkYXJrb2xpdmVncmVlblwiXG4gICAgICAgICAgICAgIDsgXCJkYXJrb3JhbmdlXCJcbiAgICAgICAgICAgICAgOyBcImRhcmtvcmNoaWRcIlxuICAgICAgICAgICAgICA7IFwiZGFya3JlZFwiXG4gICAgICAgICAgICAgIDsgXCJkYXJrc2FsbW9uXCJcbiAgICAgICAgICAgICAgOyBcImRhcmtzZWFncmVlblwiXG4gICAgICAgICAgICAgIDsgXCJkYXJrc2xhdGVibHVlXCJcbiAgICAgICAgICAgICAgOyBcImRhcmtzbGF0ZWdyYXlcIlxuICAgICAgICAgICAgICA7IFwiZGFya3NsYXRlZ3JleVwiXG4gICAgICAgICAgICAgIDsgXCJkYXJrdHVycXVvaXNlXCJcbiAgICAgICAgICAgICAgOyBcImRhcmt2aW9sZXRcIlxuICAgICAgICAgICAgICA7IFwiZGVlcHBpbmtcIlxuICAgICAgICAgICAgICA7IFwiZGVlcHNreWJsdWVcIlxuICAgICAgICAgICAgICA7IFwiZGltZ3JheVwiXG4gICAgICAgICAgICAgIDsgXCJkaW1ncmV5XCJcbiAgICAgICAgICAgICAgOyBcImRvZGdlcmJsdWVcIlxuICAgICAgICAgICAgICA7IFwiZmlyZWJyaWNrXCJcbiAgICAgICAgICAgICAgOyBcImZsb3JhbHdoaXRlXCJcbiAgICAgICAgICAgICAgOyBcImZvcmVzdGdyZWVuXCJcbiAgICAgICAgICAgICAgOyBcImZ1Y2hzaWFcIlxuICAgICAgICAgICAgICA7IFwiZ2FpbnNib3JvXCJcbiAgICAgICAgICAgICAgOyBcImdob3N0d2hpdGVcIlxuICAgICAgICAgICAgICA7IFwiZ29sZFwiXG4gICAgICAgICAgICAgIDsgXCJnb2xkZW5yb2RcIlxuICAgICAgICAgICAgICA7IFwiZ3JheVwiXG4gICAgICAgICAgICAgIDsgXCJncmVlblwiXG4gICAgICAgICAgICAgIDsgXCJncmVlbnllbGxvd1wiXG4gICAgICAgICAgICAgIDsgXCJncmV5XCJcbiAgICAgICAgICAgICAgOyBcImhvbmV5ZGV3XCJcbiAgICAgICAgICAgICAgOyBcImhvdHBpbmtcIlxuICAgICAgICAgICAgICA7IFwiaW5kaWFucmVkXCJcbiAgICAgICAgICAgICAgOyBcImluZGlnb1wiXG4gICAgICAgICAgICAgIDsgXCJpdm9yeVwiXG4gICAgICAgICAgICAgIDsgXCJraGFraVwiXG4gICAgICAgICAgICAgIDsgXCJsYXZlbmRlclwiXG4gICAgICAgICAgICAgIDsgXCJsYXZlbmRlcmJsdXNoXCJcbiAgICAgICAgICAgICAgOyBcImxhd25ncmVlblwiXG4gICAgICAgICAgICAgIDsgXCJsZW1vbmNoaWZmb25cIlxuICAgICAgICAgICAgICA7IFwibGlnaHRibHVlXCJcbiAgICAgICAgICAgICAgOyBcImxpZ2h0Y29yYWxcIlxuICAgICAgICAgICAgICA7IFwibGlnaHRjeWFuXCJcbiAgICAgICAgICAgICAgOyBcImxpZ2h0Z29sZGVucm9keWVsbG93XCJcbiAgICAgICAgICAgICAgOyBcImxpZ2h0Z3JheVwiXG4gICAgICAgICAgICAgIDsgXCJsaWdodGdyZWVuXCJcbiAgICAgICAgICAgICAgOyBcImxpZ2h0Z3JleVwiXG4gICAgICAgICAgICAgIDsgXCJsaWdodHBpbmtcIlxuICAgICAgICAgICAgICA7IFwibGlnaHRzYWxtb25cIlxuICAgICAgICAgICAgICA7IFwibGlnaHRzZWFncmVlblwiXG4gICAgICAgICAgICAgIDsgXCJsaWdodHNreWJsdWVcIlxuICAgICAgICAgICAgICA7IFwibGlnaHRzbGF0ZWdyYXlcIlxuICAgICAgICAgICAgICA7IFwibGlnaHRzbGF0ZWdyZXlcIlxuICAgICAgICAgICAgICA7IFwibGlnaHRzdGVlbGJsdWVcIlxuICAgICAgICAgICAgICA7IFwibGlnaHR5ZWxsb3dcIlxuICAgICAgICAgICAgICA7IFwibGltZVwiXG4gICAgICAgICAgICAgIDsgXCJsaW1lZ3JlZW5cIlxuICAgICAgICAgICAgICA7IFwibGluZW5cIlxuICAgICAgICAgICAgICA7IFwibWFnZW50YVwiXG4gICAgICAgICAgICAgIDsgXCJtYXJvb25cIlxuICAgICAgICAgICAgICA7IFwibWVkaXVtYXF1YW1hcmluZVwiXG4gICAgICAgICAgICAgIDsgXCJtZWRpdW1ibHVlXCJcbiAgICAgICAgICAgICAgOyBcIm1lZGl1bW9yY2hpZFwiXG4gICAgICAgICAgICAgIDsgXCJtZWRpdW1wdXJwbGVcIlxuICAgICAgICAgICAgICA7IFwibWVkaXVtc2VhZ3JlZW5cIlxuICAgICAgICAgICAgICA7IFwibWVkaXVtc2xhdGVibHVlXCJcbiAgICAgICAgICAgICAgOyBcIm1lZGl1bXNwcmluZ2dyZWVuXCJcbiAgICAgICAgICAgICAgOyBcIm1lZGl1bXR1cnF1b2lzZVwiXG4gICAgICAgICAgICAgIDsgXCJtZWRpdW12aW9sZXRyZWRcIlxuICAgICAgICAgICAgICA7IFwibWlkbmlnaHRibHVlXCJcbiAgICAgICAgICAgICAgOyBcIm1pbnRjcmVhbVwiXG4gICAgICAgICAgICAgIDsgXCJtaXN0eXJvc2VcIlxuICAgICAgICAgICAgICA7IFwibW9jY2FzaW5cIlxuICAgICAgICAgICAgICA7IFwibmF2YWpvd2hpdGVcIlxuICAgICAgICAgICAgICA7IFwibmF2eVwiXG4gICAgICAgICAgICAgIDsgXCJvbGRsYWNlXCJcbiAgICAgICAgICAgICAgOyBcIm9saXZlXCJcbiAgICAgICAgICAgICAgOyBcIm9saXZlZHJhYlwiXG4gICAgICAgICAgICAgIDsgXCJvcmFuZ2VcIlxuICAgICAgICAgICAgICA7IFwib3JhbmdlcmVkXCJcbiAgICAgICAgICAgICAgOyBcIm9yY2hpZFwiXG4gICAgICAgICAgICAgIDsgXCJwYWxlZ29sZGVucm9kXCJcbiAgICAgICAgICAgICAgOyBcInBhbGVncmVlblwiXG4gICAgICAgICAgICAgIDsgXCJwYWxldHVycXVvaXNlXCJcbiAgICAgICAgICAgICAgOyBcInBhbGV2aW9sZXRyZWRcIlxuICAgICAgICAgICAgICA7IFwicGFwYXlhd2hpcFwiXG4gICAgICAgICAgICAgIDsgXCJwZWFjaHB1ZmZcIlxuICAgICAgICAgICAgICA7IFwicGVydVwiXG4gICAgICAgICAgICAgIDsgXCJwaW5rXCJcbiAgICAgICAgICAgICAgOyBcInBsdW1cIlxuICAgICAgICAgICAgICA7IFwicG93ZGVyYmx1ZVwiXG4gICAgICAgICAgICAgIDsgXCJwdXJwbGVcIlxuICAgICAgICAgICAgICA7IFwicmVkXCJcbiAgICAgICAgICAgICAgOyBcInJvc3licm93blwiXG4gICAgICAgICAgICAgIDsgXCJyb3lhbGJsdWVcIlxuICAgICAgICAgICAgICA7IFwic2FkZGxlYnJvd25cIlxuICAgICAgICAgICAgICA7IFwic2FsbW9uXCJcbiAgICAgICAgICAgICAgOyBcInNhbmR5YnJvd25cIlxuICAgICAgICAgICAgICA7IFwic2VhZ3JlZW5cIlxuICAgICAgICAgICAgICA7IFwic2Vhc2hlbGxcIlxuICAgICAgICAgICAgICA7IFwic2llbm5hXCJcbiAgICAgICAgICAgICAgOyBcInNpbHZlclwiXG4gICAgICAgICAgICAgIDsgXCJza3libHVlXCJcbiAgICAgICAgICAgICAgOyBcInNsYXRlYmx1ZVwiXG4gICAgICAgICAgICAgIDsgXCJzbGF0ZWdyYXlcIlxuICAgICAgICAgICAgICA7IFwic2xhdGVncmV5XCJcbiAgICAgICAgICAgICAgOyBcInNub3dcIlxuICAgICAgICAgICAgICA7IFwic3ByaW5nZ3JlZW5cIlxuICAgICAgICAgICAgICA7IFwic3RlZWxibHVlXCJcbiAgICAgICAgICAgICAgOyBcInRhblwiXG4gICAgICAgICAgICAgIDsgXCJ0ZWFsXCJcbiAgICAgICAgICAgICAgOyBcInRoaXN0bGVcIlxuICAgICAgICAgICAgICA7IFwidG9tYXRvXCJcbiAgICAgICAgICAgICAgOyBcInR1cnF1b2lzZVwiXG4gICAgICAgICAgICAgIDsgXCJ2aW9sZXRcIlxuICAgICAgICAgICAgICA7IFwid2hlYXRcIlxuICAgICAgICAgICAgICA7IFwid2hpdGVcIlxuICAgICAgICAgICAgICA7IFwid2hpdGVzbW9rZVwiXG4gICAgICAgICAgICAgIDsgXCJ5ZWxsb3dcIlxuICAgICAgICAgICAgICA7IFwieWVsbG93Z3JlZW5cIlxuICAgICAgICAgICAgICBdXG4gICAgdGhlbiBzXG4gICAgZWxzZSByYWlzZSAoSW52YWxpZF9hcmd1bWVudCAoSnMudG9fc3RyaW5nIHMgXiBcIiBpcyBub3QgYSB2YWxpZCBjb2xvclwiKSlcblxuICBsZXQgbmFtZSBjbiA9IEpzLnN0cmluZyAoc3RyaW5nX29mX25hbWUgY24pXG5cbiAgbGV0IGpzID0gZnVuY3Rpb25cbiAgICB8IE5hbWUgbiAtPiBuYW1lIG5cbiAgICB8IChSR0IgXyB8IFJHQl9wZXJjZW50IF8gfCBSR0JBIF8gfCBSR0JBX3BlcmNlbnQgXyB8IEhTTCBfIHwgSFNMQSBfKSBhcyBjIC0+XG4gICAgICAgIEpzLnN0cmluZyAoc3RyaW5nX29mX3QgYylcblxuICBsZXQgbWwgYyA9XG4gICAgbGV0IHMgPSBKcy50b19zdHJpbmcgYyBpblxuICAgIHRyeSBOYW1lIChuYW1lX29mX3N0cmluZyBzKVxuICAgIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+IChcbiAgICAgIGxldCBmYWlsICgpID0gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgKHMgXiBcIiBpcyBub3QgYSB2YWxpZCBjb2xvclwiKSkgaW5cbiAgICAgIGxldCByZV9yZ2IgPVxuICAgICAgICBSZWdleHAucmVnZXhwIFwiKHJnYmE/KVxcXFwoKD86KFxcXFxkKiksKFxcXFxkKiksKFxcXFxkKikoPzosKFxcXFxkKig/OlxcXFwuXFxcXGQqKT8pKT8pXFxcXClcIlxuICAgICAgaW5cbiAgICAgIGxldCByZV9yZ2JfcGN0ID1cbiAgICAgICAgUmVnZXhwLnJlZ2V4cCBcIihyZ2JhPylcXFxcKCg/OihcXFxcZCopJSwoXFxcXGQqKSUsKFxcXFxkKiklKD86LChcXFxcZCooPzpcXFxcLlxcXFxkKik/KSk/KVxcXFwpXCJcbiAgICAgIGluXG4gICAgICBsZXQgcmVfaHNsID1cbiAgICAgICAgUmVnZXhwLnJlZ2V4cCBcIihoc2xhPylcXFxcKCg/OihcXFxcZCopLChcXFxcZCopJSwoXFxcXGQqKSUoPzosKFxcXFxkKig/OlxcXFwuXFxcXGQqKT8pKT8pXFxcXClcIlxuICAgICAgaW5cbiAgICAgIGxldCBpX29mX3NfbyA9IGZ1bmN0aW9uXG4gICAgICAgIHwgTm9uZSAtPiBmYWlsICgpXG4gICAgICAgIHwgU29tZSBpIC0+IChcbiAgICAgICAgICAgIHRyeSBpbnRfb2Zfc3RyaW5nIGlcbiAgICAgICAgICAgIHdpdGggSW52YWxpZF9hcmd1bWVudCBzIHwgRmFpbHVyZSBzIC0+XG4gICAgICAgICAgICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IChcImNvbG9yIGNvbnZlcnNpb24gZXJyb3IgKFwiIF4gaSBeIFwiKTogXCIgXiBzKSkpXG4gICAgICBpblxuICAgICAgbGV0IGZfb2ZfcyBmID1cbiAgICAgICAgdHJ5IGZsb2F0X29mX3N0cmluZyBmXG4gICAgICAgIHdpdGggSW52YWxpZF9hcmd1bWVudCBzIHwgRmFpbHVyZSBzIC0+XG4gICAgICAgICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgKFwiY29sb3IgY29udmVyc2lvbiBlcnJvciAoXCIgXiBmIF4gXCIpOiBcIiBeIHMpKVxuICAgICAgaW5cbiAgICAgIG1hdGNoIFJlZ2V4cC5zdHJpbmdfbWF0Y2ggcmVfcmdiIHMgMCB3aXRoXG4gICAgICB8IFNvbWUgciAtPiAoXG4gICAgICAgICAgbGV0IHJlZCA9IFJlZ2V4cC5tYXRjaGVkX2dyb3VwIHIgMiBpblxuICAgICAgICAgIGxldCBncmVlbiA9IFJlZ2V4cC5tYXRjaGVkX2dyb3VwIHIgMyBpblxuICAgICAgICAgIGxldCBibHVlID0gUmVnZXhwLm1hdGNoZWRfZ3JvdXAgciA0IGluXG4gICAgICAgICAgbGV0IGFscGhhID0gUmVnZXhwLm1hdGNoZWRfZ3JvdXAgciA1IGluXG4gICAgICAgICAgbWF0Y2ggUmVnZXhwLm1hdGNoZWRfZ3JvdXAgciAxIHdpdGhcbiAgICAgICAgICB8IFNvbWUgXCJyZ2JcIiAtPiAoXG4gICAgICAgICAgICAgIG1hdGNoIGFscGhhIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIF8gLT4gZmFpbCAoKVxuICAgICAgICAgICAgICB8IE5vbmUgLT4gUkdCIChpX29mX3NfbyByZWQsIGlfb2Zfc19vIGdyZWVuLCBpX29mX3NfbyBibHVlKSlcbiAgICAgICAgICB8IFNvbWUgXCJyZ2JhXCIgLT4gKFxuICAgICAgICAgICAgICBtYXRjaCBhbHBoYSB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBmYWlsICgpXG4gICAgICAgICAgICAgIHwgU29tZSBhIC0+IFJHQkEgKGlfb2Zfc19vIHJlZCwgaV9vZl9zX28gZ3JlZW4sIGlfb2Zfc19vIGJsdWUsIGZfb2ZfcyBhKSlcbiAgICAgICAgICB8IFNvbWUgXyB8IE5vbmUgLT4gZmFpbCAoKSlcbiAgICAgIHwgTm9uZSAtPiAoXG4gICAgICAgICAgbWF0Y2ggUmVnZXhwLnN0cmluZ19tYXRjaCByZV9yZ2JfcGN0IHMgMCB3aXRoXG4gICAgICAgICAgfCBTb21lIHIgLT4gKFxuICAgICAgICAgICAgICBsZXQgcmVkID0gUmVnZXhwLm1hdGNoZWRfZ3JvdXAgciAyIGluXG4gICAgICAgICAgICAgIGxldCBncmVlbiA9IFJlZ2V4cC5tYXRjaGVkX2dyb3VwIHIgMyBpblxuICAgICAgICAgICAgICBsZXQgYmx1ZSA9IFJlZ2V4cC5tYXRjaGVkX2dyb3VwIHIgNCBpblxuICAgICAgICAgICAgICBsZXQgYWxwaGEgPSBSZWdleHAubWF0Y2hlZF9ncm91cCByIDUgaW5cbiAgICAgICAgICAgICAgbWF0Y2ggUmVnZXhwLm1hdGNoZWRfZ3JvdXAgciAxIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIFwicmdiXCIgLT4gKFxuICAgICAgICAgICAgICAgICAgbWF0Y2ggYWxwaGEgd2l0aFxuICAgICAgICAgICAgICAgICAgfCBTb21lIF8gLT4gZmFpbCAoKVxuICAgICAgICAgICAgICAgICAgfCBOb25lIC0+IFJHQl9wZXJjZW50IChpX29mX3NfbyByZWQsIGlfb2Zfc19vIGdyZWVuLCBpX29mX3NfbyBibHVlKSlcbiAgICAgICAgICAgICAgfCBTb21lIFwicmdiYVwiIC0+IChcbiAgICAgICAgICAgICAgICAgIG1hdGNoIGFscGhhIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiBmYWlsICgpXG4gICAgICAgICAgICAgICAgICB8IFNvbWUgYSAtPlxuICAgICAgICAgICAgICAgICAgICAgIFJHQkFfcGVyY2VudCAoaV9vZl9zX28gcmVkLCBpX29mX3NfbyBncmVlbiwgaV9vZl9zX28gYmx1ZSwgZl9vZl9zIGEpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIHwgU29tZSBfIHwgTm9uZSAtPiBmYWlsICgpKVxuICAgICAgICAgIHwgTm9uZSAtPiAoXG4gICAgICAgICAgICAgIG1hdGNoIFJlZ2V4cC5zdHJpbmdfbWF0Y2ggcmVfaHNsIHMgMCB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSByIC0+IChcbiAgICAgICAgICAgICAgICAgIGxldCByZWQgPSBSZWdleHAubWF0Y2hlZF9ncm91cCByIDIgaW5cbiAgICAgICAgICAgICAgICAgIGxldCBncmVlbiA9IFJlZ2V4cC5tYXRjaGVkX2dyb3VwIHIgMyBpblxuICAgICAgICAgICAgICAgICAgbGV0IGJsdWUgPSBSZWdleHAubWF0Y2hlZF9ncm91cCByIDQgaW5cbiAgICAgICAgICAgICAgICAgIGxldCBhbHBoYSA9IFJlZ2V4cC5tYXRjaGVkX2dyb3VwIHIgNSBpblxuICAgICAgICAgICAgICAgICAgbWF0Y2ggUmVnZXhwLm1hdGNoZWRfZ3JvdXAgciAxIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgU29tZSBcImhzbFwiIC0+IChcbiAgICAgICAgICAgICAgICAgICAgICBtYXRjaCBhbHBoYSB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgfCBTb21lIF8gLT4gZmFpbCAoKVxuICAgICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiBIU0wgKGlfb2Zfc19vIHJlZCwgaV9vZl9zX28gZ3JlZW4sIGlfb2Zfc19vIGJsdWUpKVxuICAgICAgICAgICAgICAgICAgfCBTb21lIFwiaHNsYVwiIC0+IChcbiAgICAgICAgICAgICAgICAgICAgICBtYXRjaCBhbHBoYSB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgfCBOb25lIC0+IGZhaWwgKClcbiAgICAgICAgICAgICAgICAgICAgICB8IFNvbWUgYSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICBIU0xBIChpX29mX3NfbyByZWQsIGlfb2Zfc19vIGdyZWVuLCBpX29mX3NfbyBibHVlLCBmX29mX3MgYSkpXG4gICAgICAgICAgICAgICAgICB8IFNvbWUgXyB8IE5vbmUgLT4gZmFpbCAoKSlcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGZhaWwgKCkpKSlcbmVuZFxuXG5tb2R1bGUgTGVuZ3RoID0gc3RydWN0XG4gICgqIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtdmFsdWVzLyNsZW5ndGhzICopXG5cbiAgKCogVE9ETzpcbiAgICAge1tcbiAgICAgICB0eXBlIGpzX3QgPSBwcml2YXRlIEpzLnN0cmluZyBKcy50XG4gICAgICAgdmFsIGpzX3Rfb2ZfdFxuICAgICAgIHZhbCB0X29mX2pzX3RcbiAgICAgICB2YWwgdF9vZl9zdHJpbmdcbiAgICAgXX1cbiAgKilcblxuICB0eXBlIHQgPVxuICAgIHwgWmVyb1xuICAgICgqIHJlbGF0aXZlICopXG4gICAgfCBFbSBvZiBmbG9hdFxuICAgIHwgRXggb2YgZmxvYXRcbiAgICB8IFB4IG9mIGZsb2F0XG4gICAgfCBHZCBvZiBmbG9hdFxuICAgIHwgUmVtIG9mIGZsb2F0XG4gICAgfCBWdyBvZiBmbG9hdFxuICAgIHwgVmggb2YgZmxvYXRcbiAgICB8IFZtIG9mIGZsb2F0XG4gICAgfCBDaCBvZiBmbG9hdFxuICAgICgqIGFic29sdXRlICopXG4gICAgfCBNbSBvZiBmbG9hdFxuICAgIHwgQ20gb2YgZmxvYXRcbiAgICB8IEluIG9mIGZsb2F0XG4gICAgfCBQdCBvZiBmbG9hdFxuICAgIHwgUGMgb2YgZmxvYXRcblxuICBsZXQgc3RyaW5nX29mX3QgPSBmdW5jdGlvblxuICAgIHwgWmVybyAtPiBcIjBcIlxuICAgIHwgRW0gZiAtPiBQcmludGYuc3ByaW50ZiBcIiVmJXNcIiBmIFwiZW1cIlxuICAgIHwgRXggZiAtPiBQcmludGYuc3ByaW50ZiBcIiVmJXNcIiBmIFwiZXhcIlxuICAgIHwgUHggZiAtPiBQcmludGYuc3ByaW50ZiBcIiVmJXNcIiBmIFwicHhcIlxuICAgIHwgR2QgZiAtPiBQcmludGYuc3ByaW50ZiBcIiVmJXNcIiBmIFwiZ2RcIlxuICAgIHwgUmVtIGYgLT4gUHJpbnRmLnNwcmludGYgXCIlZiVzXCIgZiBcInJlbVwiXG4gICAgfCBWdyBmIC0+IFByaW50Zi5zcHJpbnRmIFwiJWYlc1wiIGYgXCJ2d1wiXG4gICAgfCBWaCBmIC0+IFByaW50Zi5zcHJpbnRmIFwiJWYlc1wiIGYgXCJ2aFwiXG4gICAgfCBWbSBmIC0+IFByaW50Zi5zcHJpbnRmIFwiJWYlc1wiIGYgXCJ2bVwiXG4gICAgfCBDaCBmIC0+IFByaW50Zi5zcHJpbnRmIFwiJWYlc1wiIGYgXCJjaFwiXG4gICAgfCBNbSBmIC0+IFByaW50Zi5zcHJpbnRmIFwiJWYlc1wiIGYgXCJtbVwiXG4gICAgfCBDbSBmIC0+IFByaW50Zi5zcHJpbnRmIFwiJWYlc1wiIGYgXCJjbVwiXG4gICAgfCBJbiBmIC0+IFByaW50Zi5zcHJpbnRmIFwiJWYlc1wiIGYgXCJpblwiXG4gICAgfCBQdCBmIC0+IFByaW50Zi5zcHJpbnRmIFwiJWYlc1wiIGYgXCJwdFwiXG4gICAgfCBQYyBmIC0+IFByaW50Zi5zcHJpbnRmIFwiJWYlc1wiIGYgXCJwY1wiXG5cbiAgdHlwZSBqc190ID0gSnMuanNfc3RyaW5nIEpzLnRcblxuICBsZXQganMgdCA9IEpzLnN0cmluZyAoc3RyaW5nX29mX3QgdClcblxuICBsZXQgbWwgdCA9XG4gICAgbGV0IHMgPSBKcy50b19zdHJpbmcgdCBpblxuICAgIGlmIFN0cmluZy5lcXVhbCBzIFwiMFwiXG4gICAgdGhlbiBaZXJvXG4gICAgZWxzZVxuICAgICAgbGV0IGZhaWwgKCkgPSByYWlzZSAoSW52YWxpZF9hcmd1bWVudCAocyBeIFwiIGlzIG5vdCBhIHZhbGlkIGxlbmd0aFwiKSkgaW5cbiAgICAgIGxldCByZSA9IFJlZ2V4cC5yZWdleHAgXCJeKFxcXFxkKig/OlxcXFwuXFxcXGQqKT8pXFxcXHMqKFxcXFxTKikkXCIgaW5cbiAgICAgIG1hdGNoIFJlZ2V4cC5zdHJpbmdfbWF0Y2ggcmUgcyAwIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBmYWlsICgpXG4gICAgICB8IFNvbWUgciAtPiAoXG4gICAgICAgICAgbGV0IGYgPVxuICAgICAgICAgICAgbWF0Y2ggUmVnZXhwLm1hdGNoZWRfZ3JvdXAgciAxIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBmYWlsICgpXG4gICAgICAgICAgICB8IFNvbWUgZiAtPiAoXG4gICAgICAgICAgICAgICAgdHJ5IGZsb2F0X29mX3N0cmluZyBmXG4gICAgICAgICAgICAgICAgd2l0aCBJbnZhbGlkX2FyZ3VtZW50IHMgLT5cbiAgICAgICAgICAgICAgICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IChcImxlbmd0aCBjb252ZXJzaW9uIGVycm9yOiBcIiBeIHMpKSlcbiAgICAgICAgICBpblxuICAgICAgICAgIG1hdGNoIFJlZ2V4cC5tYXRjaGVkX2dyb3VwIHIgMiB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGZhaWwgKClcbiAgICAgICAgICB8IFNvbWUgXCJlbVwiIC0+IEVtIGZcbiAgICAgICAgICB8IFNvbWUgXCJleFwiIC0+IEV4IGZcbiAgICAgICAgICB8IFNvbWUgXCJweFwiIC0+IFB4IGZcbiAgICAgICAgICB8IFNvbWUgXCJnZFwiIC0+IEdkIGZcbiAgICAgICAgICB8IFNvbWUgXCJyZW1cIiAtPiBSZW0gZlxuICAgICAgICAgIHwgU29tZSBcInZ3XCIgLT4gVncgZlxuICAgICAgICAgIHwgU29tZSBcInZoXCIgLT4gVmggZlxuICAgICAgICAgIHwgU29tZSBcInZtXCIgLT4gVm0gZlxuICAgICAgICAgIHwgU29tZSBcImNoXCIgLT4gQ2ggZlxuICAgICAgICAgIHwgU29tZSBcIm1tXCIgLT4gTW0gZlxuICAgICAgICAgIHwgU29tZSBcImNtXCIgLT4gQ20gZlxuICAgICAgICAgIHwgU29tZSBcImluXCIgLT4gSW4gZlxuICAgICAgICAgIHwgU29tZSBcInB0XCIgLT4gUHQgZlxuICAgICAgICAgIHwgU29tZSBcInBjXCIgLT4gUGMgZlxuICAgICAgICAgIHwgU29tZSBfIC0+IGZhaWwgKCkpXG5lbmRcblxubW9kdWxlIEFuZ2xlID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBEZWcgb2YgZmxvYXRcbiAgICB8IEdyYWQgb2YgZmxvYXRcbiAgICB8IFJhZCBvZiBmbG9hdFxuICAgIHwgVHVybnMgb2YgZmxvYXRcblxuICBsZXQgc3RyaW5nX29mX3QgPSBmdW5jdGlvblxuICAgIHwgRGVnIGYgLT4gUHJpbnRmLnNwcmludGYgXCIlZiVzXCIgZiBcImRlZ1wiXG4gICAgfCBHcmFkIGYgLT4gUHJpbnRmLnNwcmludGYgXCIlZiVzXCIgZiBcImdyYWRcIlxuICAgIHwgUmFkIGYgLT4gUHJpbnRmLnNwcmludGYgXCIlZiVzXCIgZiBcInJhZFwiXG4gICAgfCBUdXJucyBmIC0+IFByaW50Zi5zcHJpbnRmIFwiJWYlc1wiIGYgXCJ0dXJuc1wiXG5cbiAgdHlwZSBqc190ID0gSnMuanNfc3RyaW5nIEpzLnRcblxuICBsZXQganMgdCA9IEpzLnN0cmluZyAoc3RyaW5nX29mX3QgdClcblxuICBsZXQgbWwgaiA9XG4gICAgbGV0IHMgPSBKcy50b19zdHJpbmcgaiBpblxuICAgIGxldCByZSA9IFJlZ2V4cC5yZWdleHAgXCJeKFxcXFxkKig/OlxcXFwuXFxcXGQqKSkoZGVnfGdyYWR8cmFkfHR1cm5zKSRcIiBpblxuICAgIGxldCBmYWlsICgpID0gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgKHMgXiBcIiBpcyBub3QgYSB2YWxpZCBsZW5ndGhcIikpIGluXG4gICAgbWF0Y2ggUmVnZXhwLnN0cmluZ19tYXRjaCByZSBzIDAgd2l0aFxuICAgIHwgTm9uZSAtPiBmYWlsICgpXG4gICAgfCBTb21lIHIgLT4gKFxuICAgICAgICBsZXQgZiA9XG4gICAgICAgICAgbWF0Y2ggUmVnZXhwLm1hdGNoZWRfZ3JvdXAgciAxIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gZmFpbCAoKVxuICAgICAgICAgIHwgU29tZSBmIC0+IChcbiAgICAgICAgICAgICAgdHJ5IGZsb2F0X29mX3N0cmluZyBmXG4gICAgICAgICAgICAgIHdpdGggSW52YWxpZF9hcmd1bWVudCBzIC0+XG4gICAgICAgICAgICAgICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgKFwibGVuZ3RoIGNvbnZlcnNpb24gZXJyb3I6IFwiIF4gcykpKVxuICAgICAgICBpblxuICAgICAgICBtYXRjaCBSZWdleHAubWF0Y2hlZF9ncm91cCByIDIgd2l0aFxuICAgICAgICB8IFNvbWUgXCJkZWdcIiAtPiBEZWcgZlxuICAgICAgICB8IFNvbWUgXCJncmFkXCIgLT4gR3JhZCBmXG4gICAgICAgIHwgU29tZSBcInJhZFwiIC0+IFJhZCBmXG4gICAgICAgIHwgU29tZSBcInR1cm5zXCIgLT4gVHVybnMgZlxuICAgICAgICB8IFNvbWUgXyB8IE5vbmUgLT4gZmFpbCAoKSlcbmVuZFxuIiwiKCogSnNfb2Zfb2NhbWwgbGlicmFyeVxuICogaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbiAqIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuICogTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbiAqIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICopXG5cbigqKiBKYXZhc2NyaXB0IGV2ZW50cy4gKilcblxub3BlbiEgSW1wb3J0XG5tb2R1bGUgVHlwID0gRG9tX2h0bWwuRXZlbnRcblxudHlwZSBsaXN0ZW5lciA9IERvbV9odG1sLmV2ZW50X2xpc3RlbmVyX2lkXG5cbmxldCBsaXN0ZW4gPyhjYXB0dXJlID0gZmFsc2UpIHRhcmdldCB0eXAgY2IgPVxuICBEb21faHRtbC5hZGRFdmVudExpc3RlbmVyXG4gICAgdGFyZ2V0XG4gICAgdHlwXG4gICAgKERvbV9odG1sLmZ1bGxfaGFuZGxlciAoZnVuIG4gZSAtPiBKcy5ib29sIChjYiBuIGUpKSlcbiAgICAoSnMuYm9vbCBjYXB0dXJlKVxuXG5sZXQgc3RvcF9saXN0ZW4gPSBEb21faHRtbC5yZW1vdmVFdmVudExpc3RlbmVyXG4iLCIoKiBKc19vZl9vY2FtbCBsaWJyYXJ5XG4gKiBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuICogQ29weXJpZ2h0IChDKSAyMDE0IEh1Z28gSGV1emFyZFxuICogQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbiAqIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICopXG5cbm9wZW4gSnNcbm9wZW4hIEltcG9ydFxuXG5sZXQgeG1sbnMgPSBKcy5zdHJpbmcgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG5cbigqIHRyYW5zbGF0ZSBzcGVjIGZyb20gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2lkbC5odG1sICopXG4oKiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwgKilcblxudHlwZSBlcnJvcl9jb2RlID1cbiAgfCBXUk9OR19UWVBFX0VSUlxuICB8IElOVkFMSURfVkFMVUVfRVJSXG4gIHwgTUFUUklYX05PVF9JTlZFUlRBQkxFXG5cbmNsYXNzIHR5cGUgc3ZnX2Vycm9yID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBKcy5lcnJvclxuXG4gICAgbWV0aG9kIGNvZGUgOiBlcnJvcl9jb2RlIHQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuZXhjZXB0aW9uIFNWR0Vycm9yIG9mIHN2Z19lcnJvclxuXG50eXBlIGxlbmd0aFVuaXRUeXBlID1cbiAgfCBMRU5HVEhUWVBFX1VOS05PV05cbiAgfCBMRU5HVEhUWVBFX05VTUJFUlxuICB8IExFTkdUSFRZUEVfUEVSQ0VOVEFHRVxuICB8IExFTkdUSFRZUEVfRU1TXG4gIHwgTEVOR1RIVFlQRV9FWFNcbiAgfCBMRU5HVEhUWVBFX1BYXG4gIHwgTEVOR1RIVFlQRV9DTVxuICB8IExFTkdUSFRZUEVfTU1cbiAgfCBMRU5HVEhUWVBFX0lOXG4gIHwgTEVOR1RIVFlQRV9QVFxuICB8IExFTkdUSFRZUEVfUENcblxudHlwZSBhbmdsZVVuaXRUeXBlID1cbiAgfCBBTkdMRVRZUEVfVU5LTk9XTlxuICB8IEFOR0xFVFlQRV9VTlNQRUNJRklFRFxuICB8IEFOR0xFVFlQRV9ERUdcbiAgfCBBTkdMRVRZUEVfUkFEXG4gIHwgQU5HTEVUWVBFX0dSQURcblxudHlwZSBjb2xvclR5cGUgPVxuICB8IENPTE9SVFlQRV9VTktOT1dOXG4gIHwgQ09MT1JUWVBFX1JHQkNPTE9SXG4gIHwgQ09MT1JUWVBFX1JHQkNPTE9SX0lDQ0NPTE9SXG4gIHwgQ09MT1JUWVBFX0NVUlJFTlRDT0xPUlxuXG50eXBlIGFsaWdubWVudFR5cGUgPVxuICB8IFBSRVNFUlZFQVNQRUNUUkFUSU9fVU5LTk9XTlxuICB8IFBSRVNFUlZFQVNQRUNUUkFUSU9fTk9ORVxuICB8IFBSRVNFUlZFQVNQRUNUUkFUSU9fWE1JTllNSU5cbiAgfCBQUkVTRVJWRUFTUEVDVFJBVElPX1hNSURZTUlOXG4gIHwgUFJFU0VSVkVBU1BFQ1RSQVRJT19YTUFYWU1JTlxuICB8IFBSRVNFUlZFQVNQRUNUUkFUSU9fWE1JTllNSURcbiAgfCBQUkVTRVJWRUFTUEVDVFJBVElPX1hNSURZTUlEXG4gIHwgUFJFU0VSVkVBU1BFQ1RSQVRJT19YTUFYWU1JRFxuICB8IFBSRVNFUlZFQVNQRUNUUkFUSU9fWE1JTllNQVhcbiAgfCBQUkVTRVJWRUFTUEVDVFJBVElPX1hNSURZTUFYXG4gIHwgUFJFU0VSVkVBU1BFQ1RSQVRJT19YTUFYWU1BWFxuXG50eXBlIG1lZXRPclNsaWNlVHlwZSA9XG4gIHwgTUVFVE9SU0xJQ0VfVU5LTk9XTlxuICB8IE1FRVRPUlNMSUNFX01FRVRcbiAgfCBNRUVUT1JTTElDRV9TTElDRVxuXG50eXBlIHRyYW5zZm9ybVR5cGUgPVxuICB8IFRSQU5TRk9STV9VTktOT1dOXG4gIHwgVFJBTlNGT1JNX01BVFJJWFxuICB8IFRSQU5TRk9STV9UUkFOU0xBVEVcbiAgfCBUUkFOU0ZPUk1fU0NBTEVcbiAgfCBUUkFOU0ZPUk1fUk9UQVRFXG4gIHwgVFJBTlNGT1JNX1NLRVdYXG4gIHwgVFJBTlNGT1JNX1NLRVdZXG5cbnR5cGUgem9vbUFuZFBhblR5cGUgPVxuICB8IFpPT01BTkRQQU5fVU5LTk9XTlxuICB8IFpPT01BTkRQQU5fRElTQUJMRVxuICB8IFpPT01BTkRQQU5fTUFHTklGWVxuXG50eXBlIGxlbmd0aEFkanVzdCA9XG4gIHwgTEVOR1RIQURKVVNUX1VOS05PV05cbiAgfCBMRU5HVEhBREpVU1RfU1BBQ0lOR1xuICB8IExFTkdUSEFESlVTVF9TUEFDSU5HQU5ER0xZUEhTXG5cbnR5cGUgdW5pdFR5cGUgPVxuICB8IFVOSVRfVFlQRV9VTktOT1dOXG4gIHwgVU5JVF9UWVBFX1VTRVJTUEFDRU9OVVNFXG4gIHwgVU5JVF9UWVBFX09CSkVDVEJPVU5ESU5HQk9YXG5cbigqIGludGVyZmFjZSBTVkdSZW5kZXJpbmdJbnRlbnQgKilcbnR5cGUgaW50ZW50VHlwZSA9XG4gIHwgUkVOREVSSU5HX0lOVEVOVF9VTktOT1dOXG4gIHwgUkVOREVSSU5HX0lOVEVOVF9BVVRPXG4gIHwgUkVOREVSSU5HX0lOVEVOVF9QRVJDRVBUVUFMXG4gIHwgUkVOREVSSU5HX0lOVEVOVF9SRUxBVElWRV9DT0xPUklNRVRSSUNcbiAgfCBSRU5ERVJJTkdfSU5URU5UX1NBVFVSQVRJT05cbiAgfCBSRU5ERVJJTkdfSU5URU5UX0FCU09MVVRFX0NPTE9SSU1FVFJJQ1xuXG4oKiBQYXRoIFNlZ21lbnQgVHlwZXMgKilcbnR5cGUgcGF0aFNlZ21lbnRUeXBlID1cbiAgfCBQQVRIU0VHX1VOS05PV05cbiAgfCBQQVRIU0VHX0NMT1NFUEFUSFxuICB8IFBBVEhTRUdfTU9WRVRPX0FCU1xuICB8IFBBVEhTRUdfTU9WRVRPX1JFTFxuICB8IFBBVEhTRUdfTElORVRPX0FCU1xuICB8IFBBVEhTRUdfTElORVRPX1JFTFxuICB8IFBBVEhTRUdfQ1VSVkVUT19DVUJJQ19BQlNcbiAgfCBQQVRIU0VHX0NVUlZFVE9fQ1VCSUNfUkVMXG4gIHwgUEFUSFNFR19DVVJWRVRPX1FVQURSQVRJQ19BQlNcbiAgfCBQQVRIU0VHX0NVUlZFVE9fUVVBRFJBVElDX1JFTFxuICB8IFBBVEhTRUdfQVJDX0FCU1xuICB8IFBBVEhTRUdfQVJDX1JFTFxuICB8IFBBVEhTRUdfTElORVRPX0hPUklaT05UQUxfQUJTXG4gIHwgUEFUSFNFR19MSU5FVE9fSE9SSVpPTlRBTF9SRUxcbiAgfCBQQVRIU0VHX0xJTkVUT19WRVJUSUNBTF9BQlNcbiAgfCBQQVRIU0VHX0xJTkVUT19WRVJUSUNBTF9SRUxcbiAgfCBQQVRIU0VHX0NVUlZFVE9fQ1VCSUNfU01PT1RIX0FCU1xuICB8IFBBVEhTRUdfQ1VSVkVUT19DVUJJQ19TTU9PVEhfUkVMXG4gIHwgUEFUSFNFR19DVVJWRVRPX1FVQURSQVRJQ19TTU9PVEhfQUJTXG4gIHwgUEFUSFNFR19DVVJWRVRPX1FVQURSQVRJQ19TTU9PVEhfUkVMXG5cbigqIHRleHRQYXRoIE1ldGhvZCBUeXBlcyAqKVxudHlwZSB0ZXh0UGF0aE1ldGhvZFR5cGUgPVxuICB8IFRFWFRQQVRIX01FVEhPRFRZUEVfVU5LTk9XTlxuICB8IFRFWFRQQVRIX01FVEhPRFRZUEVfQUxJR05cbiAgfCBURVhUUEFUSF9NRVRIT0RUWVBFX1NUUkVUQ0hcblxuKCogdGV4dFBhdGggU3BhY2luZyBUeXBlcyAqKVxudHlwZSB0ZXh0UGF0aFNwYWNpbmdUeXBlID1cbiAgfCBURVhUUEFUSF9TUEFDSU5HVFlQRV9VTktOT1dOXG4gIHwgVEVYVFBBVEhfU1BBQ0lOR1RZUEVfQVVUT1xuICB8IFRFWFRQQVRIX1NQQUNJTkdUWVBFX0VYQUNUXG5cbigqIFNwcmVhZCBNZXRob2QgVHlwZXMgKilcbnR5cGUgc3ByZWFkTWV0aG9kVHlwZSA9XG4gIHwgU1BSRUFETUVUSE9EX1VOS05PV05cbiAgfCBTUFJFQURNRVRIT0RfUEFEXG4gIHwgU1BSRUFETUVUSE9EX1JFRkxFQ1RcbiAgfCBTUFJFQURNRVRIT0RfUkVQRUFUXG5cbnR5cGUgc3VzcGVuZEhhbmRsZUlEXG5cbigqKioqKVxuXG5jbGFzcyB0eXBlIFsnYV0gYW5pbWF0ZWQgPVxuICBvYmplY3RcbiAgICBtZXRob2QgYmFzZVZhbCA6ICdhIHByb3BcblxuICAgIG1ldGhvZCBhbmltVmFsIDogJ2EgcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSBbJ2FdIGxpc3QgPVxuICBvYmplY3RcbiAgICBtZXRob2QgbnVtYmVyT2ZJdGVtcyA6IGludCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgY2xlYXIgOiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBpbml0aWFsaXplIDogJ2EgLT4gJ2EgbWV0aFxuXG4gICAgbWV0aG9kIGdldEl0ZW0gOiBpbnQgLT4gJ2EgbWV0aFxuXG4gICAgbWV0aG9kIGluc2VydEl0ZW1CZWZvcmUgOiAnYSAtPiBpbnQgLT4gJ2EgbWV0aFxuXG4gICAgbWV0aG9kIHJlcGxhY2VJdGVtIDogJ2EgLT4gaW50IC0+ICdhIG1ldGhcblxuICAgIG1ldGhvZCByZW1vdmVJdGVtIDogaW50IC0+ICdhIG1ldGhcblxuICAgIG1ldGhvZCBhcHBlbmRJdGVtIDogJ2EgLT4gJ2EgbWV0aFxuICBlbmRcblxuKCoqKiopXG5cbigqIGludGVyZmFjZSBTVkdFbGVtZW50ICopXG5jbGFzcyB0eXBlIGVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IERvbS5lbGVtZW50XG5cbiAgICBtZXRob2QgaWQgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgeG1sYmFzZSA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBvd25lclNWR0VsZW1lbnQgOiBzdmdFbGVtZW50IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHZpZXdwb3J0RWxlbWVudCA6IGVsZW1lbnQgdCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHQW5pbWF0ZWRTdHJpbmcgKilcbmFuZCBhbmltYXRlZFN0cmluZyA9IFtqc19zdHJpbmcgdF0gYW5pbWF0ZWRcblxuKCogaW50ZXJmYWNlIFNWR0FuaW1hdGVkQm9vbGVhbiAqKVxuYW5kIGFuaW1hdGVkQm9vbGVhbiA9IFtib29sIHRdIGFuaW1hdGVkXG5cbigqIGludGVyZmFjZSBTVkdTdHJpbmdMaXN0ICopXG5hbmQgc3RyaW5nTGlzdCA9IFtqc19zdHJpbmcgdF0gbGlzdFxuXG4oKiBpbnRlcmZhY2UgU1ZHQW5pbWF0ZWRFbnVtZXJhdGlvbiAqKVxuYW5kIGFuaW1hdGVkRW51bWVyYXRpb24gPSBbaW50ICgqc2hvcnQqKV0gYW5pbWF0ZWRcblxuKCogaW50ZXJmYWNlIFNWR0FuaW1hdGVkSW50ZWdlciAqKVxuYW5kIGFuaW1hdGVkSW50ZWdlciA9IFtpbnRdIGFuaW1hdGVkXG5cbigqIGludGVyZmFjZSBTVkdBbmltYXRlZE51bWJlciAqKVxuYW5kIGFuaW1hdGVkTnVtYmVyID0gW2Zsb2F0XSBhbmltYXRlZFxuXG4oKiBpbnRlcmZhY2UgU1ZHTnVtYmVyTGlzdCAqKVxuYW5kIG51bWJlckxpc3QgPSBbbnVtYmVyIHRdIGxpc3RcblxuKCogaW50ZXJmYWNlIFNWR0FuaW1hdGVkTnVtYmVyTGlzdCAqKVxuYW5kIGFuaW1hdGVkTnVtYmVyTGlzdCA9IFtudW1iZXJMaXN0IHRdIGFuaW1hdGVkXG5cbigqIGludGVyZmFjZSBTVkdMZW5ndGggKilcbmFuZCBsZW5ndGggPVxuICBvYmplY3RcbiAgICBtZXRob2QgdW5pdFR5cGUgOiBsZW5ndGhVbml0VHlwZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgdmFsdWUgOiBmbG9hdCBwcm9wXG5cbiAgICBtZXRob2QgdmFsdWVJblNwZWNpZmllZFVuaXRzIDogZmxvYXQgcHJvcFxuXG4gICAgbWV0aG9kIHZhbHVlQXNTdHJpbmcgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgbmV3VmFsdWVTcGVjaWZpZWRVbml0cyA6IGxlbmd0aFVuaXRUeXBlIC0+IGZsb2F0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGNvbnZlcnRUb1NwZWNpZmllZFVuaXRzIDogbGVuZ3RoVW5pdFR5cGUgLT4gdW5pdCBtZXRoXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHQW5pbWF0ZWRMZW5ndGggKilcbmFuZCBhbmltYXRlZExlbmd0aCA9IFtsZW5ndGggdF0gYW5pbWF0ZWRcblxuKCogaW50ZXJmYWNlIFNWR0xlbmd0aExpc3QgKilcbmFuZCBsZW5ndGhMaXN0ID0gW2xlbmd0aCB0XSBsaXN0XG5cbigqIGludGVyZmFjZSBTVkdBbmltYXRlZExlbmd0aExpc3QgKilcbmFuZCBhbmltYXRlZExlbmd0aExpc3QgPSBbbGVuZ3RoTGlzdCB0XSBhbmltYXRlZFxuXG4oKiBpbnRlcmZhY2UgU1ZHQW5nbGUgKilcbmFuZCBhbmdsZSA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCB1bml0VHlwZSA6IGFuZ2xlVW5pdFR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHZhbHVlIDogZmxvYXQgcHJvcFxuXG4gICAgbWV0aG9kIHZhbHVlSW5TcGVjaWZpZWRVbml0cyA6IGZsb2F0IHByb3BcblxuICAgIG1ldGhvZCB2YWx1ZUFzU3RyaW5nIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIG5ld1ZhbHVlU3BlY2lmaWVkVW5pdHMgOiBhbmdsZVVuaXRUeXBlIC0+IGZsb2F0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGNvbnZlcnRUb1NwZWNpZmllZFVuaXRzIDogYW5nbGVVbml0VHlwZSAtPiB1bml0IG1ldGhcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdBbmltYXRlZEFuZ2xlICopXG5hbmQgYW5pbWF0ZWRBbmdsZSA9IFthbmdsZSB0XSBhbmltYXRlZFxuXG4oKiBYWFhYWCBNb3ZlIGl0ICopXG5hbmQgcmdiQ29sb3IgPSBvYmplY3QgZW5kXG5cbigqIGludGVyZmFjZSBTVkdDb2xvciAqKVxuYW5kIGNvbG9yID1cbiAgb2JqZWN0XG4gICAgKCogWFhYIGluaGVyaXQgY3NzVmFsdWUgKilcbiAgICBtZXRob2QgY29sb3JUeXBlIDogY29sb3JUeXBlIHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCByZ2JDb2xvciA6IHJnYkNvbG9yIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGljY0NvbG9yIDogaWNjQ29sb3IgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgc2V0UkdCQ29sb3IgOiBqc19zdHJpbmcgdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzZXRSR0JDb2xvcklDQ0NvbG9yIDoganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0Q29sb3IgOiBjb2xvclR5cGUgLT4ganNfc3RyaW5nIHQgLT4ganNfc3RyaW5nIHQgLT4gdW5pdCBtZXRoXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHSUNDQ29sb3IgKilcbmFuZCBpY2NDb2xvciA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBjb2xvclByb2ZpbGUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgY29sb3JzIDogbnVtYmVyTGlzdCB0IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdSZWN0ICopXG5hbmQgcmVjdCA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCB4IDogZmxvYXQgcHJvcFxuXG4gICAgbWV0aG9kIHkgOiBmbG9hdCBwcm9wXG5cbiAgICBtZXRob2Qgd2lkdGggOiBmbG9hdCBwcm9wXG5cbiAgICBtZXRob2QgaGVpZ2h0IDogZmxvYXQgcHJvcFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR0FuaW1hdGVkUmVjdCAqKVxuYW5kIGFuaW1hdGVkUmVjdCA9IFtyZWN0IHRdIGFuaW1hdGVkXG5cbigqIGludGVyZmFjZSBTVkdTdHlsYWJsZSAqKVxuYW5kIHN0eWxhYmxlID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGNsYXNzTmFtZSA6IGFuaW1hdGVkU3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHN0eWxlIDogRG9tX2h0bWwuY3NzU3R5bGVEZWNsYXJhdGlvbiB0IHJlYWRvbmx5X3Byb3BcbiAgICAoKiAgIENTU1ZhbHVlIGdldFByZXNlbnRhdGlvbkF0dHJpYnV0ZShpbiBET01TdHJpbmcgbmFtZSk7ICopXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHTG9jYXRhYmxlICopXG5hbmQgbG9jYXRhYmxlID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIG5lYXJlc3RWaWV3cG9ydEVsZW1lbnQgOiBlbGVtZW50IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGZhcnRoZXN0Vmlld3BvcnRFbGVtZW50IDogZWxlbWVudCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBnZXRCQm94IDogcmVjdCB0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRDVE0gOiBtYXRyaXggdCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0U2NyZWVuQ1RNIDogbWF0cml4IHQgbWV0aFxuXG4gICAgbWV0aG9kIGdldFRyYW5zZm9ybVRvRWxlbWVudCA6IGVsZW1lbnQgdCAtPiBtYXRyaXggdCBtZXRoXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHVHJhbnNmb3JtYWJsZSAqKVxuYW5kIHRyYW5zZm9ybWFibGUgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGxvY2F0YWJsZVxuXG4gICAgbWV0aG9kIHRyYW5zZm9ybSA6IGFuaW1hdGVkVHJhbnNmb3JtTGlzdCB0IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdUZXN0cyAqKVxuYW5kIHRlc3RzID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIHJlcXVpcmVkRmVhdHVyZXMgOiBzdHJpbmdMaXN0IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHJlcXVpcmVkRXh0ZW5zaW9ucyA6IHN0cmluZ0xpc3QgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgc3lzdGVtTGFuZ3VhZ2UgOiBzdHJpbmdMaXN0IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGhhc0V4dGVuc2lvbiA6IGpzX3N0cmluZyB0IC0+IGJvb2wgdCBtZXRoXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHTGFuZ1NwYWNlICopXG5hbmQgbGFuZ1NwYWNlID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIHhtbGxhbmcgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgeG1sc3BhY2UgOiBqc19zdHJpbmcgdCBwcm9wXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHRXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCAqKVxuYW5kIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQgPVxuICBvYmplY3RcbiAgICBtZXRob2QgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCA6IGFuaW1hdGVkQm9vbGVhbiB0IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdGaXRUb1ZpZXdCb3ggKilcbmFuZCBmaXRUb1ZpZXdCb3ggPVxuICBvYmplY3RcbiAgICBtZXRob2Qgdmlld0JveCA6IGFuaW1hdGVkUmVjdCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBwcmVzZXJ2ZUFzcGVjdFJhdGlvIDogYW5pbWF0ZWRQcmVzZXJ2ZUFzcGVjdFJhdGlvIHQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR1pvb21BbmRQYW4gKilcbmFuZCB6b29tQW5kUGFuID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIHpvb21BbmRQYW4gOiB6b29tQW5kUGFuVHlwZSBwcm9wXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHVmlld1NwZWMgKilcbmFuZCB2aWV3U3BlYyA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgem9vbUFuZFBhblxuXG4gICAgaW5oZXJpdCBmaXRUb1ZpZXdCb3hcblxuICAgIG1ldGhvZCB0cmFuc2Zvcm0gOiB0cmFuc2Zvcm1MaXN0IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHZpZXdUYXJnZXQgOiBlbGVtZW50IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHZpZXdCb3hTdHJpbmcgOiBqc19zdHJpbmcgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgcHJlc2VydmVBc3BlY3RSYXRpb1N0cmluZyA6IGpzX3N0cmluZyB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB0cmFuc2Zvcm1TdHJpbmcgOiBqc19zdHJpbmcgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgdmlld1RhcmdldFN0cmluZyA6IGpzX3N0cmluZyB0IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdVUklSZWZlcmVuY2UgKilcbmFuZCB1cmlSZWZlcmVuY2UgPVxuICBvYmplY3RcbiAgICBtZXRob2QgaHJlZiA6IGFuaW1hdGVkU3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR0NTU1J1bGUgOiBDU1NSdWxlICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IENPTE9SX1BST0ZJTEVfUlVMRSA9IDc7ICopXG4oKiB9OyAqKVxuXG4oKiBpbnRlcmZhY2UgU1ZHRG9jdW1lbnQgKilcbmFuZCBkb2N1bWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgW2VsZW1lbnRdIERvbS5kb2N1bWVudFxuXG4gICAgKCpYWFggaW5oZXJpdCBkb2N1bWVudEV2ZW50ICopXG4gICAgbWV0aG9kIHRpdGxlIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHJlZmVycmVyIDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGRvbWFpbiA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBfVVJMIDoganNfc3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHJvb3RFbGVtZW50IDogc3ZnRWxlbWVudCB0IG9wdCByZWFkb25seV9wcm9wXG4gICAgKCogcm9vdEVsZW1lbnQgd2lsbCBiZSBudWxsIG9yIHVuZGVmaW5lZCBpbiBhbiBodG1sIGNvbnRleHQgKilcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdTVkdFbGVtZW50ICopXG5hbmQgc3ZnRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgaW5oZXJpdCB0ZXN0c1xuXG4gICAgaW5oZXJpdCBsYW5nU3BhY2VcblxuICAgIGluaGVyaXQgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFxuXG4gICAgaW5oZXJpdCBzdHlsYWJsZVxuXG4gICAgaW5oZXJpdCBsb2NhdGFibGVcblxuICAgIGluaGVyaXQgZml0VG9WaWV3Qm94XG5cbiAgICBpbmhlcml0IHpvb21BbmRQYW5cblxuICAgICgqWFhYIGluaGVyaXQgZG9jdW1lbnRldmVudCwgdmlld2NzcywgZG9jdW1lbnRjc3MgKilcbiAgICBtZXRob2QgeCA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHkgOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB3aWR0aCA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGhlaWdodCA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGNvbnRlbnRTY3JpcHRUeXBlIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIGNvbnRlbnRTdHlsZVR5cGUgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2Qgdmlld3BvcnQgOiByZWN0IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHBpeGVsVW5pdFRvTWlsbGltZXRlclggOiBmbG9hdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgcGl4ZWxVbml0VG9NaWxsaW1ldGVyWSA6IGZsb2F0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBzY3JlZW5QaXhlbFVuaXRUb01pbGxpbWV0ZXJYIDogZmxvYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHNjcmVlblBpeGVsVW5pdFRvTWlsbGltZXRlclkgOiBmbG9hdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgdXNlQ3VycmVudFZpZXcgOiBib29sIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGN1cnJlbnRWaWV3IDogdmlld1NwZWMgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgY3VycmVudFNjYWxlIDogZmxvYXQgcHJvcFxuXG4gICAgbWV0aG9kIGN1cnJlbnRUcmFuc2xhdGUgOiBwb2ludCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBzdXNwZW5kUmVkcmF3IDogaW50IC0+IHN1c3BlbmRIYW5kbGVJRCBtZXRoXG5cbiAgICBtZXRob2QgdW5zdXNwZW5kUmVkcmF3IDogc3VzcGVuZEhhbmRsZUlEIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHVuc3VzcGVuZFJlZHJhd0FsbCA6IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGZvcmNlUmVkcmF3IDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgcGF1c2VBbmltYXRpb25zIDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdW5wYXVzZUFuaW1hdGlvbnMgOiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBhbmltYXRpb25zUGF1c2VkIDogYm9vbCB0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRDdXJyZW50VGltZSA6IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBzZXRDdXJyZW50VGltZSA6IGludCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRJbnRlcnNlY3Rpb25MaXN0IDogcmVjdCB0IC0+IGVsZW1lbnQgdCAtPiBlbGVtZW50IERvbS5ub2RlTGlzdCB0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRFbmNsb3N1cmVMaXN0IDogcmVjdCB0IC0+IGVsZW1lbnQgdCAtPiBlbGVtZW50IERvbS5ub2RlTGlzdCB0IG1ldGhcblxuICAgIG1ldGhvZCBjaGVja0ludGVyc2VjdGlvbiA6IGVsZW1lbnQgdCAtPiByZWN0IHQgLT4gYm9vbCB0XG5cbiAgICBtZXRob2QgY2hlY2tFbmNsb3N1cmUgOiBlbGVtZW50IHQgLT4gcmVjdCB0IC0+IGJvb2wgdFxuXG4gICAgbWV0aG9kIGRlc2VsZWN0QWxsIDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgY3JlYXRlU1ZHTnVtYmVyIDogbnVtYmVyIHQgbWV0aFxuXG4gICAgbWV0aG9kIGNyZWF0ZVNWR0xlbmd0aCA6IGxlbmd0aCB0IG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVTVkdBbmdsZSA6IGFuZ2xlIHQgbWV0aFxuXG4gICAgbWV0aG9kIGNyZWF0ZVNWR1BvaW50IDogcG9pbnQgdCBtZXRoXG5cbiAgICBtZXRob2QgY3JlYXRlU1ZHTWF0cml4IDogbWF0cml4IHQgbWV0aFxuXG4gICAgbWV0aG9kIGNyZWF0ZVNWR1JlY3QgOiByZWN0IHQgbWV0aFxuXG4gICAgbWV0aG9kIGNyZWF0ZVNWR1RyYW5zZm9ybSA6IHRyYW5zZm9ybSB0IG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVTVkdUcmFuc2Zvcm1Gcm9tTWF0cml4IDogbWF0cml4IHQgLT4gdHJhbnNmb3JtIHQgbWV0aFxuXG4gICAgbWV0aG9kIGdldEVsZW1lbnRCeUlkIDoganNfc3RyaW5nIHQgLT4gRG9tLmVsZW1lbnQgdCBtZXRoXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHR0VsZW1lbnQgKilcbmFuZCBnRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgaW5oZXJpdCB0ZXN0c1xuXG4gICAgaW5oZXJpdCBsYW5nU3BhY2VcblxuICAgIGluaGVyaXQgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFxuXG4gICAgaW5oZXJpdCBzdHlsYWJsZVxuXG4gICAgaW5oZXJpdCB0cmFuc2Zvcm1hYmxlXG5cbiAgICBpbmhlcml0IERvbV9odG1sLmV2ZW50VGFyZ2V0XG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHRGVmc0VsZW1lbnQgKilcbmFuZCBkZWZzRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgaW5oZXJpdCB0ZXN0c1xuXG4gICAgaW5oZXJpdCBsYW5nU3BhY2VcblxuICAgIGluaGVyaXQgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFxuXG4gICAgaW5oZXJpdCBzdHlsYWJsZVxuXG4gICAgaW5oZXJpdCB0cmFuc2Zvcm1hYmxlXG4gICAgKCogWFhYWFhYWCA/IGluaGVyaXQgRG9tX2h0bWwuZXZlbnRUYXJnZXQgKilcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdEZXNjRWxlbWVudCAqKVxuYW5kIGRlc2NFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBpbmhlcml0IGxhbmdTcGFjZVxuXG4gICAgaW5oZXJpdCBzdHlsYWJsZVxuICAgICgqIFhYWFhYWFggPyBpbmhlcml0IERvbV9odG1sLmV2ZW50VGFyZ2V0ICopXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHVGl0bGVFbGVtZW50ICopXG5hbmQgdGl0bGVFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBpbmhlcml0IGxhbmdTcGFjZVxuXG4gICAgaW5oZXJpdCBzdHlsYWJsZVxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR1N5bWJvbEVsZW1lbnQgKilcbmFuZCBzeW1ib2xFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBpbmhlcml0IGxhbmdTcGFjZVxuXG4gICAgaW5oZXJpdCBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXG5cbiAgICBpbmhlcml0IHN0eWxhYmxlXG5cbiAgICBpbmhlcml0IGZpdFRvVmlld0JveFxuXG4gICAgaW5oZXJpdCBEb21faHRtbC5ldmVudFRhcmdldFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR1VzZUVsZW1lbnQgKilcbmFuZCB1c2VFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBpbmhlcml0IHVyaVJlZmVyZW5jZVxuXG4gICAgaW5oZXJpdCB0ZXN0c1xuXG4gICAgaW5oZXJpdCBsYW5nU3BhY2VcblxuICAgIGluaGVyaXQgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFxuXG4gICAgaW5oZXJpdCBzdHlsYWJsZVxuXG4gICAgaW5oZXJpdCB0cmFuc2Zvcm1hYmxlXG5cbiAgICBtZXRob2QgeCA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHkgOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB3aWR0aCA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGhlaWdodCA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGluc3RhbmNlUm9vdCA6IGVsZW1lbnRJbnN0YW5jZSB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBhbmltYXRlZEluc3RhbmNlUm9vdCA6IGVsZW1lbnRJbnN0YW5jZSB0IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbmFuZCBlbGVtZW50SW5zdGFuY2UgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IERvbV9odG1sLmV2ZW50VGFyZ2V0XG5cbiAgICBtZXRob2QgY29ycmVzcG9uZGluZ0VsZW1lbnQgOiBlbGVtZW50IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGNvcnJlc3BvbmRpbmdVc2VFbGVtZW50IDogdXNlRWxlbWVudCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBwYXJlbnROb2RlIDogZWxlbWVudEluc3RhbmNlIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGNoaWxkTm9kZXMgOiBlbGVtZW50SW5zdGFuY2VMaXN0IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGZpcnN0Q2hpbGQgOiBlbGVtZW50SW5zdGFuY2UgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgbGFzdENoaWxkIDogZWxlbWVudEluc3RhbmNlIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHByZXZpb3VzU2libGluZyA6IGVsZW1lbnRJbnN0YW5jZSB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBuZXh0U2libGluZyA6IGVsZW1lbnRJbnN0YW5jZSB0IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdFbGVtZW50SW5zdGFuY2VMaXN0ICopXG5hbmQgZWxlbWVudEluc3RhbmNlTGlzdCA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBsZW5ndGggOiBpbnQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGl0ZW0gOiBpbnQgLT4gZWxlbWVudEluc3RhbmNlIHRcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdJbWFnZUVsZW1lbnQgKilcbmFuZCBpbWFnZUVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIGluaGVyaXQgdXJpUmVmZXJlbmNlXG5cbiAgICBpbmhlcml0IHRlc3RzXG5cbiAgICBpbmhlcml0IGxhbmdTcGFjZVxuXG4gICAgaW5oZXJpdCBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXG5cbiAgICBpbmhlcml0IHN0eWxhYmxlXG5cbiAgICBpbmhlcml0IHRyYW5zZm9ybWFibGVcblxuICAgIG1ldGhvZCB4IDogYW5pbWF0ZWRMZW5ndGggdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgeSA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHdpZHRoIDogYW5pbWF0ZWRMZW5ndGggdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgaGVpZ2h0IDogYW5pbWF0ZWRMZW5ndGggdCByZWFkb25seV9wcm9wXG4gICAgKCogcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkUHJlc2VydmVBc3BlY3RSYXRpbyBwcmVzZXJ2ZUFzcGVjdFJhdGlvICopXG4gIGVuZFxuXG5hbmQgc3dpdGNoRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgaW5oZXJpdCB0ZXN0c1xuXG4gICAgaW5oZXJpdCBsYW5nU3BhY2VcblxuICAgIGluaGVyaXQgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFxuXG4gICAgaW5oZXJpdCBzdHlsYWJsZVxuXG4gICAgaW5oZXJpdCB0cmFuc2Zvcm1hYmxlXG4gIGVuZFxuXG4oKiBYWFggZGVwcmVjYXRlZCA9PiBpbnRlcmZhY2UgR2V0U1ZHRG9jdW1lbnQgPT4gU1ZHRG9jdW1lbnQgZ2V0U1ZHRG9jdW1lbnQoKSAqKVxuXG4oKiBpbnRlcmZhY2UgU1ZHU3R5bGVFbGVtZW50ICopXG5hbmQgc3R5bGVFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBpbmhlcml0IGxhbmdTcGFjZVxuXG4gICAgbWV0aG9kIHR5cGVfIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIG1lZGlhIDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHRpdGxlIDoganNfc3RyaW5nIHQgcHJvcFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR1BvaW50ICopXG5hbmQgcG9pbnQgPVxuICBvYmplY3RcbiAgICBtZXRob2QgeCA6IGZsb2F0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB5IDogZmxvYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG1hdHJpeFRyYW5zZm9ybSA6IG1hdHJpeCB0IC0+IHBvaW50IHQgbWV0aFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR1BvaW50TGlzdCAqKVxuYW5kIHBvaW50TGlzdCA9IFtwb2ludCB0XSBsaXN0XG5cbigqIGludGVyZmFjZSBTVkdNYXRyaXggKilcbmFuZCBtYXRyaXggPVxuICBvYmplY3RcbiAgICBtZXRob2QgYSA6IGZsb2F0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBiIDogZmxvYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGMgOiBmbG9hdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgZCA6IGZsb2F0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBlIDogZmxvYXQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGYgOiBmbG9hdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgbXVsdGlwbHkgOiBtYXRyaXggdCAtPiBtYXRyaXggdCBtZXRoXG5cbiAgICBtZXRob2QgaW52ZXJzZSA6IG1hdHJpeCB0IG1ldGhcblxuICAgIG1ldGhvZCB0cmFuc2xhdGUgOiBmbG9hdCAtPiBmbG9hdCAtPiBtYXRyaXggdCBtZXRoXG5cbiAgICBtZXRob2Qgc2NhbGUgOiBmbG9hdCAtPiBtYXRyaXggdCBtZXRoXG5cbiAgICBtZXRob2Qgc2NhbGVOb25Vbmlmb3JtIDogZmxvYXQgLT4gZmxvYXQgLT4gbWF0cml4IHQgbWV0aFxuXG4gICAgbWV0aG9kIHJvdGF0ZSA6IGZsb2F0IC0+IG1hdHJpeCB0IG1ldGhcblxuICAgIG1ldGhvZCByb3RhdGVGcm9tVmVjdG9yIDogZmxvYXQgLT4gZmxvYXQgLT4gbWF0cml4IHQgbWV0aFxuXG4gICAgbWV0aG9kIGZsaXBYIDogbWF0cml4IHQgbWV0aFxuXG4gICAgbWV0aG9kIGZsaXBZIDogbWF0cml4IHQgbWV0aFxuXG4gICAgbWV0aG9kIHNrZXdYIDogZmxvYXQgLT4gbWF0cml4IHQgbWV0aFxuXG4gICAgbWV0aG9kIHNrZXdZIDogZmxvYXQgLT4gbWF0cml4IHQgbWV0aFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR1RyYW5zZm9ybSAqKVxuYW5kIHRyYW5zZm9ybSA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBfdHlwZSA6IHRyYW5zZm9ybVR5cGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG1hdHJpeCA6IG1hdHJpeCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBhbmdsZSA6IGZsb2F0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBzZXRNYXRyaXggOiBtYXRyaXggdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzZXRUcmFuc2xhdGUgOiBmbG9hdCAtPiBmbG9hdCAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBzZXRTY2FsZSA6IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldFJvdGF0ZSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHNldFNrZXdYIDogZmxvYXQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgc2V0U2tld1kgOiBmbG9hdCAtPiB1bml0IG1ldGhcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdUcmFuc2Zvcm1MaXN0ICopXG5hbmQgdHJhbnNmb3JtTGlzdCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgW3RyYW5zZm9ybSB0XSBsaXN0XG5cbiAgICBtZXRob2QgY3JlYXRlU1ZHVHJhbnNmb3JtRnJvbU1hdHJpeCA6IG1hdHJpeCAtPiB0cmFuc2Zvcm0gdCBtZXRoXG5cbiAgICBtZXRob2QgY29uc29saWRhdGUgOiB0cmFuc2Zvcm0gdCBtZXRoXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHQW5pbWF0ZWRUcmFuc2Zvcm1MaXN0ICopXG5hbmQgYW5pbWF0ZWRUcmFuc2Zvcm1MaXN0ID0gW3RyYW5zZm9ybUxpc3QgdF0gYW5pbWF0ZWRcblxuKCogaW50ZXJmYWNlIFNWR1ByZXNlcnZlQXNwZWN0UmF0aW8gKilcbmFuZCBwcmVzZXJ2ZUFzcGVjdFJhdGlvID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGFsaWduIDogYWxpZ25tZW50VHlwZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgbWVldE9yU2xpY2UgOiBtZWV0T3JTbGljZVR5cGUgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR0FuaW1hdGVkUHJlc2VydmVBc3BlY3RSYXRpbyAqKVxuYW5kIGFuaW1hdGVkUHJlc2VydmVBc3BlY3RSYXRpbyA9IFtwcmVzZXJ2ZUFzcGVjdFJhdGlvIHRdIGFuaW1hdGVkXG5cbigqIGludGVyZmFjZSBTVkdQYXRoU2VnICopXG5hbmQgcGF0aFNlZyA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBwYXRoU2VnVHlwZSA6IHBhdGhTZWdtZW50VHlwZSByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgcGF0aFNlZ1R5cGVBc0xldHRlciA6IGpzX3N0cmluZyB0IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdQYXRoU2VnQ2xvc2VQYXRoICopXG5hbmQgcGF0aFNlZ0Nsb3NlUGF0aCA9IHBhdGhTZWdcblxuKCogaW50ZXJmYWNlIFNWR1BhdGhTZWdNb3ZldG9BYnMgKilcbigqIGludGVyZmFjZSBTVkdQYXRoU2VnTW92ZXRvUmVsICopXG5hbmQgcGF0aFNlZ01vdmV0byA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgcGF0aFNlZ1xuXG4gICAgbWV0aG9kIHggOiBmbG9hdCBwcm9wXG5cbiAgICBtZXRob2QgeSA6IGZsb2F0IHByb3BcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdQYXRoU2VnTGluZXRvQWJzICopXG4oKiBpbnRlcmZhY2UgU1ZHUGF0aFNlZ0xpbmV0b1JlbCAqKVxuYW5kIHBhdGhTZWdMaW5ldG8gPVxuICBvYmplY3RcbiAgICBpbmhlcml0IHBhdGhTZWdcblxuICAgIG1ldGhvZCB4IDogZmxvYXQgcHJvcFxuXG4gICAgbWV0aG9kIHkgOiBmbG9hdCBwcm9wXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY0FicyAqKVxuKCogaW50ZXJmYWNlIFNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNSZWwgKilcbmFuZCBwYXRoU2VnQ3VydmV0b0N1YmljID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBwYXRoU2VnXG5cbiAgICBtZXRob2QgeCA6IGZsb2F0IHByb3BcblxuICAgIG1ldGhvZCB5IDogZmxvYXQgcHJvcFxuXG4gICAgbWV0aG9kIHgxIDogZmxvYXQgcHJvcFxuXG4gICAgbWV0aG9kIHkxIDogZmxvYXQgcHJvcFxuXG4gICAgbWV0aG9kIHgyIDogZmxvYXQgcHJvcFxuXG4gICAgbWV0aG9kIHkyIDogZmxvYXQgcHJvcFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljQWJzICopXG4oKiBpbnRlcmZhY2UgU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNSZWwgKilcbmFuZCBwYXRoU2VnQ3VydmV0b1F1YWRyYXRpYyA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgcGF0aFNlZ1xuXG4gICAgbWV0aG9kIHggOiBmbG9hdCBwcm9wXG5cbiAgICBtZXRob2QgeSA6IGZsb2F0IHByb3BcblxuICAgIG1ldGhvZCB4MSA6IGZsb2F0IHByb3BcblxuICAgIG1ldGhvZCB5MSA6IGZsb2F0IHByb3BcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdQYXRoU2VnQXJjQWJzICopXG4oKiBpbnRlcmZhY2UgU1ZHUGF0aFNlZ0FyY1JlbCopXG5hbmQgcGF0aFNlZ0FyYyA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgcGF0aFNlZ1xuXG4gICAgbWV0aG9kIHkgOiBmbG9hdCBwcm9wXG5cbiAgICBtZXRob2QgcjEgOiBmbG9hdCBwcm9wXG5cbiAgICBtZXRob2QgcjIgOiBmbG9hdCBwcm9wXG5cbiAgICBtZXRob2QgYW5nbGUgOiBmbG9hdCBwcm9wXG5cbiAgICBtZXRob2QgbGFyZ2VBcmNGbGFnIDogYm9vbCB0IHByb3BcblxuICAgIG1ldGhvZCBzd2VlcEZsYWcgOiBib29sIHQgcHJvcFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsQWJzICopXG4oKiBpbnRlcmZhY2UgU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxSZWwgKilcbmFuZCBwYXRoU2VnTGluZXRvSG9yaXpvbnRhbCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgcGF0aFNlZ1xuXG4gICAgbWV0aG9kIHggOiBmbG9hdFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbEFicyAqKVxuKCogaW50ZXJmYWNlIFNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbFJlbCAqKVxuYW5kIHBhdGhTZWdMaW5ldG9WZXJ0aWNhbCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgcGF0aFNlZ1xuXG4gICAgbWV0aG9kIHkgOiBmbG9hdFxuICBlbmRcblxuYW5kIHBhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGggPVxuICBvYmplY3RcbiAgICBpbmhlcml0IHBhdGhTZWdcblxuICAgIG1ldGhvZCB4IDogZmxvYXRcblxuICAgIG1ldGhvZCB5IDogZmxvYXRcblxuICAgIG1ldGhvZCB4MiA6IGZsb2F0XG5cbiAgICBtZXRob2QgeTIgOiBmbG9hdFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoQWJzICopXG4oKiBpbnRlcmZhY2UgU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNTbW9vdGhSZWwgICopXG5hbmQgcGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNTbW9vdGggPVxuICBvYmplY3RcbiAgICBpbmhlcml0IHBhdGhTZWdcblxuICAgIG1ldGhvZCB4IDogZmxvYXRcblxuICAgIG1ldGhvZCB5IDogZmxvYXRcbiAgZW5kXG5cbmFuZCBwYXRoU2VnTGlzdCA9IFtwYXRoU2VnIHRdIGxpc3RcblxuKCogaW50ZXJmYWNlIFNWR0FuaW1hdGVkUGF0aERhdGEgKilcbmFuZCBhbmltYXRlZFBhdGhEYXRhID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIHBhdGhTZWdMaXN0IDogcGF0aFNlZ0xpc3QgdCBwcm9wXG5cbiAgICBtZXRob2Qgbm9ybWFsaXplZFBhdGhTZWdMaXN0IDogcGF0aFNlZ0xpc3QgdCBwcm9wXG5cbiAgICBtZXRob2QgYW5pbWF0ZWRQYXRoU2VnTGlzdCA6IHBhdGhTZWdMaXN0IHQgcHJvcFxuXG4gICAgbWV0aG9kIGFuaW1hdGVkTm9ybWFsaXplZFBhdGhTZWdMaXN0IDogcGF0aFNlZ0xpc3QgdCBwcm9wXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHUGF0aEVsZW1lbnQgKilcbmFuZCBwYXRoRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgaW5oZXJpdCB0ZXN0c1xuXG4gICAgaW5oZXJpdCBsYW5nU3BhY2VcblxuICAgIGluaGVyaXQgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFxuXG4gICAgaW5oZXJpdCBzdHlsYWJsZVxuXG4gICAgaW5oZXJpdCB0cmFuc2Zvcm1hYmxlXG5cbiAgICBpbmhlcml0IGFuaW1hdGVkUGF0aERhdGFcblxuICAgIG1ldGhvZCBwYXRoTGVuZ3RoIDogYW5pbWF0ZWROdW1iZXIgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgZ2V0VG90YWxMZW5ndGggOiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0UG9pbnRBdExlbmd0aCA6IGZsb2F0IC0+IHBvaW50IHQgbWV0aFxuXG4gICAgbWV0aG9kIGdldFBhdGhTZWdBdExlbmd0aCA6IGZsb2F0IC0+IGludFxuXG4gICAgbWV0aG9kIGNyZWF0ZVNWR1BhdGhTZWdDbG9zZVBhdGggOiBwYXRoU2VnQ2xvc2VQYXRoIG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVTVkdQYXRoU2VnTW92ZXRvQWJzIDogZmxvYXQgLT4gZmxvYXQgLT4gcGF0aFNlZ01vdmV0byBtZXRoXG5cbiAgICBtZXRob2QgY3JlYXRlU1ZHUGF0aFNlZ01vdmV0b1JlbCA6IGZsb2F0IC0+IGZsb2F0IC0+IHBhdGhTZWdNb3ZldG8gbWV0aFxuXG4gICAgbWV0aG9kIGNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9BYnMgOiBmbG9hdCAtPiBmbG9hdCAtPiBwYXRoU2VnTGluZXRvIG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVTVkdQYXRoU2VnTGluZXRvUmVsIDogZmxvYXQgLT4gZmxvYXQgLT4gcGF0aFNlZ0xpbmV0byBtZXRoXG5cbiAgICBtZXRob2QgY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY0FicyA6XG4gICAgICBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBwYXRoU2VnQ3VydmV0b0N1YmljIG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b0N1YmljUmVsIDpcbiAgICAgIGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHBhdGhTZWdDdXJ2ZXRvQ3ViaWMgbWV0aFxuXG4gICAgbWV0aG9kIGNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljQWJzIDpcbiAgICAgIGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHBhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljIG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1JlbCA6XG4gICAgICBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBwYXRoU2VnQ3VydmV0b1F1YWRyYXRpYyBtZXRoXG5cbiAgICBtZXRob2QgY3JlYXRlU1ZHUGF0aFNlZ0FyY0FicyA6XG4gICAgICBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBib29sIHQgLT4gYm9vbCB0IC0+IHBhdGhTZWdBcmMgbWV0aFxuXG4gICAgbWV0aG9kIGNyZWF0ZVNWR1BhdGhTZWdBcmNSZWwgOlxuICAgICAgZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gYm9vbCB0IC0+IGJvb2wgdCAtPiBwYXRoU2VnQXJjIG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVTVkdQYXRoU2VnTGluZXRvSG9yaXpvbnRhbEFicyA6IGZsb2F0IC0+IHBhdGhTZWdMaW5ldG9Ib3Jpem9udGFsIG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVTVkdQYXRoU2VnTGluZXRvSG9yaXpvbnRhbFJlbCA6IGZsb2F0IC0+IHBhdGhTZWdMaW5ldG9Ib3Jpem9udGFsIG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVTVkdQYXRoU2VnTGluZXRvVmVydGljYWxBYnMgOiBmbG9hdCAtPiBwYXRoU2VnTGluZXRvVmVydGljYWwgbWV0aFxuXG4gICAgbWV0aG9kIGNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbFJlbCA6IGZsb2F0IC0+IHBhdGhTZWdMaW5ldG9WZXJ0aWNhbCBtZXRoXG5cbiAgICBtZXRob2QgY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aEFicyA6XG4gICAgICBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBwYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoIG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoUmVsIDpcbiAgICAgIGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IHBhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGggbWV0aFxuXG4gICAgbWV0aG9kIGNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoQWJzIDpcbiAgICAgIGZsb2F0IC0+IGZsb2F0IC0+IHBhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoIG1ldGhcblxuICAgIG1ldGhvZCBjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aFJlbCA6XG4gICAgICBmbG9hdCAtPiBmbG9hdCAtPiBwYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aCBtZXRoXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHUmVjdEVsZW1lbnQgKilcbmFuZCByZWN0RWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgaW5oZXJpdCB0ZXN0c1xuXG4gICAgaW5oZXJpdCBsYW5nU3BhY2VcblxuICAgIGluaGVyaXQgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFxuXG4gICAgaW5oZXJpdCBzdHlsYWJsZVxuXG4gICAgaW5oZXJpdCB0cmFuc2Zvcm1hYmxlXG5cbiAgICBtZXRob2QgeCA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHkgOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB3aWR0aCA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGhlaWdodCA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHJ4IDogYW5pbWF0ZWRMZW5ndGggdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgcnkgOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdDaXJjbGVFbGVtZW50ICopXG5hbmQgY2lyY2xlRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgaW5oZXJpdCB0ZXN0c1xuXG4gICAgaW5oZXJpdCBsYW5nU3BhY2VcblxuICAgIGluaGVyaXQgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFxuXG4gICAgaW5oZXJpdCBzdHlsYWJsZVxuXG4gICAgaW5oZXJpdCB0cmFuc2Zvcm1hYmxlXG5cbiAgICBtZXRob2QgY3ggOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBjeSA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHIgOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdFbGxpcHNlRWxlbWVudCAqKVxuYW5kIGVsbGlwc2VFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBpbmhlcml0IHRlc3RzXG5cbiAgICBpbmhlcml0IGxhbmdTcGFjZVxuXG4gICAgaW5oZXJpdCBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXG5cbiAgICBpbmhlcml0IHN0eWxhYmxlXG5cbiAgICBpbmhlcml0IHRyYW5zZm9ybWFibGVcblxuICAgIG1ldGhvZCBjeCA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGN5IDogYW5pbWF0ZWRMZW5ndGggdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgcnggOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCByeSA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR0xpbmVFbGVtZW50ICopXG5jbGFzcyB0eXBlIGxpbmVFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBpbmhlcml0IHRlc3RzXG5cbiAgICBpbmhlcml0IGxhbmdTcGFjZVxuXG4gICAgaW5oZXJpdCBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXG5cbiAgICBpbmhlcml0IHN0eWxhYmxlXG5cbiAgICBpbmhlcml0IHRyYW5zZm9ybWFibGVcblxuICAgIGluaGVyaXQgRG9tX2h0bWwuZXZlbnRUYXJnZXRcblxuICAgIG1ldGhvZCB4MSA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHkxIDogYW5pbWF0ZWRMZW5ndGggdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgeDIgOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB5MiA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR0FuaW1hdGVkUG9pbnRzICopXG5hbmQgYW5pbWF0ZWRQb2ludHMgPVxuICBvYmplY3RcbiAgICBtZXRob2QgcG9pbnRzIDogcG9pbnRMaXN0IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGFuaW1hdGVkcG9pbnRzIDogcG9pbnRMaXN0IHQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR1BvbHlsaW5lRWxlbWVudCAqKVxuYW5kIHBvbHlMaW5lRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgaW5oZXJpdCB0ZXN0c1xuXG4gICAgaW5oZXJpdCBsYW5nU3BhY2VcblxuICAgIGluaGVyaXQgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFxuXG4gICAgaW5oZXJpdCBzdHlsYWJsZVxuXG4gICAgaW5oZXJpdCB0cmFuc2Zvcm1hYmxlXG5cbiAgICBpbmhlcml0IGFuaW1hdGVkUG9pbnRzXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHUG9seWdvbkVsZW1lbnQgKilcbmFuZCBwb2x5Z29uRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgaW5oZXJpdCB0ZXN0c1xuXG4gICAgaW5oZXJpdCBsYW5nU3BhY2VcblxuICAgIGluaGVyaXQgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFxuXG4gICAgaW5oZXJpdCBzdHlsYWJsZVxuXG4gICAgaW5oZXJpdCB0cmFuc2Zvcm1hYmxlXG5cbiAgICBpbmhlcml0IGFuaW1hdGVkUG9pbnRzXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHVGV4dENvbnRlbnRFbGVtZW50ICopXG5hbmQgdGV4dENvbnRlbnRFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBpbmhlcml0IHRlc3RzXG5cbiAgICBpbmhlcml0IGxhbmdTcGFjZVxuXG4gICAgaW5oZXJpdCBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXG5cbiAgICBpbmhlcml0IHN0eWxhYmxlXG5cbiAgICBpbmhlcml0IERvbV9odG1sLmV2ZW50VGFyZ2V0XG5cbiAgICBtZXRob2QgdGV4dExlbmd0aCA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGxlbmd0aEFkanVzdCA6IGxlbmd0aEFkanVzdCBhbmltYXRlZCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBnZXROdW1iZXJPZkNoYXJzIDogaW50IG1ldGhcblxuICAgIG1ldGhvZCBnZXRDb21wdXRlZFRleHRMZW5ndGggOiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0U3ViU3RyaW5nTGVuZ3RoIDogaW50IC0+IGludCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0U3RhcnRQb3NpdGlvbk9mQ2hhciA6IGludCAtPiBwb2ludCB0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRFbmRQb3NpdGlvbk9mQ2hhciA6IGludCAtPiBwb2ludCB0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRFeHRlbnRPZkNoYXIgOiBpbnQgLT4gcmVjdCB0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRSb3RhdGlvbk9mQ2hhciA6IGludCAtPiBmbG9hdCBtZXRoXG5cbiAgICBtZXRob2QgZ2V0Q2hhck51bUF0UG9zaXRpb24gOiBwb2ludCAtPiBpbnQgbWV0aFxuXG4gICAgbWV0aG9kIHNlbGVjdFN1YlN0cmluZyA6IGludCAtPiBpbnQgLT4gdW5pdCBtZXRoXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHVGV4dFBvc2l0aW9uaW5nRWxlbWVudCAqKVxuYW5kIHRleHRQb3NpdGlvbmluZ0VsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IHRleHRDb250ZW50RWxlbWVudFxuXG4gICAgbWV0aG9kIHggOiBhbmltYXRlZExlbmd0aExpc3QgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgeSA6IGFuaW1hdGVkTGVuZ3RoTGlzdCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBkeCA6IGFuaW1hdGVkTGVuZ3RoTGlzdCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBkeSA6IGFuaW1hdGVkTGVuZ3RoTGlzdCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCByb3RhdGUgOiBhbmltYXRlZE51bWJlckxpc3QgdCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHVGV4dEVsZW1lbnQgKilcbmFuZCB0ZXh0RWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgdGV4dFBvc2l0aW9uaW5nRWxlbWVudFxuXG4gICAgaW5oZXJpdCB0cmFuc2Zvcm1hYmxlXG4gIGVuZFxuXG5hbmQgdHNwYW5FbGVtZW50ID0gdGV4dFBvc2l0aW9uaW5nRWxlbWVudFxuXG5hbmQgdHJlZkVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IHRleHRQb3NpdGlvbmluZ0VsZW1lbnRcblxuICAgIGluaGVyaXQgdXJpUmVmZXJlbmNlXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHVGV4dFBhdGhFbGVtZW50ICopXG5hbmQgdGV4dFBhdGhFbGVtZW50TWV0aG9kID0gW3RleHRQYXRoTWV0aG9kVHlwZV0gYW5pbWF0ZWRcblxuYW5kIHRleHRQYXRoRWxlbWVudFNwYWNpbmcgPSBbdGV4dFBhdGhTcGFjaW5nVHlwZV0gYW5pbWF0ZWRcblxuYW5kIHRleHRQYXRoRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgdGV4dENvbnRlbnRFbGVtZW50XG5cbiAgICBpbmhlcml0IHVyaVJlZmVyZW5jZVxuXG4gICAgbWV0aG9kIHN0YXJ0T2Zmc2V0IDogYW5pbWF0ZWRMZW5ndGggdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgbWV0aG9kXyA6IHRleHRQYXRoRWxlbWVudE1ldGhvZCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgc3BhY2luZyA6IHRleHRQYXRoRWxlbWVudFNwYWNpbmcgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR0FsdEdseXBoRWxlbWVudCAqKVxuYW5kIGFsdEdseXBoRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgdGV4dFBvc2l0aW9uaW5nRWxlbWVudFxuXG4gICAgaW5oZXJpdCB1cmlSZWZlcmVuY2VcblxuICAgIG1ldGhvZCBnbHlwaFJlZiA6IGpzX3N0cmluZyB0IHByb3BcblxuICAgIG1ldGhvZCBmb3JtYXQgOiBqc19zdHJpbmcgdCBwcm9wXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHQWx0R2x5cGhEZWZFbGVtZW50ICopXG5hbmQgYWx0R2x5cGhEZWZFbGVtZW50ID0gZWxlbWVudFxuXG4oKiBpbnRlcmZhY2UgU1ZHQWx0R2x5cGhJdGVtRWxlbWVudCAqKVxuYW5kIGFsdEdseXBoSXRlbUVsZW1lbnQgPSBlbGVtZW50XG5cbigqIGludGVyZmFjZSBTVkdHbHlwaFJlZkVsZW1lbnQgKilcbmFuZCBnbHlwaFJlZkVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIGluaGVyaXQgdXJpUmVmZXJlbmNlXG5cbiAgICBpbmhlcml0IHN0eWxhYmxlXG5cbiAgICBtZXRob2QgZ2x5cGhSZWYgOiBqc19zdHJpbmcgdCBwcm9wXG5cbiAgICBtZXRob2QgZm9ybWF0IDoganNfc3RyaW5nIHQgcHJvcFxuXG4gICAgbWV0aG9kIHggOiBmbG9hdCBwcm9wXG5cbiAgICBtZXRob2QgeSA6IGZsb2F0IHByb3BcblxuICAgIG1ldGhvZCBkeCA6IGZsb2F0IHByb3BcblxuICAgIG1ldGhvZCBkeSA6IGZsb2F0IHByb3BcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdQYWludCA6IFNWR0NvbG9yIHsgKilcblxuKCogICAvLyBQYWludCBUeXBlcyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfUEFJTlRUWVBFX1VOS05PV04gPSAwOyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfUEFJTlRUWVBFX1JHQkNPTE9SID0gMTsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX1BBSU5UVFlQRV9SR0JDT0xPUl9JQ0NDT0xPUiA9IDI7ICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19QQUlOVFRZUEVfTk9ORSA9IDEwMTsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX1BBSU5UVFlQRV9DVVJSRU5UQ09MT1IgPSAxMDI7ICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19QQUlOVFRZUEVfVVJJX05PTkUgPSAxMDM7ICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19QQUlOVFRZUEVfVVJJX0NVUlJFTlRDT0xPUiA9IDEwNDsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX1BBSU5UVFlQRV9VUklfUkdCQ09MT1IgPSAxMDU7ICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19QQUlOVFRZUEVfVVJJX1JHQkNPTE9SX0lDQ0NPTE9SID0gMTA2OyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfUEFJTlRUWVBFX1VSSSA9IDEwNzsgKilcblxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgdW5zaWduZWQgc2hvcnQgcGFpbnRUeXBlOyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgRE9NU3RyaW5nIHVyaTsgKilcblxuKCogICB2b2lkIHNldFVyaShpbiBET01TdHJpbmcgdXJpKTsgKilcbigqICAgdm9pZCBzZXRQYWludChpbiB1bnNpZ25lZCBzaG9ydCBwYWludFR5cGUsIGluIERPTVN0cmluZyB1cmksIGluIERPTVN0cmluZyByZ2JDb2xvciwgaW4gRE9NU3RyaW5nIGljY0NvbG9yKSByYWlzZXMoU1ZHRXhjZXB0aW9uKTsgKilcbigqIH07ICopXG5cbigqIGludGVyZmFjZSBTVkdNYXJrZXJFbGVtZW50IDogU1ZHRWxlbWVudCwgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU1ZHTGFuZ1NwYWNlLCAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTVkdFeHRlcm5hbFJlc291cmNlc1JlcXVpcmVkLCAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTVkdTdHlsYWJsZSwgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU1ZHRml0VG9WaWV3Qm94IHsgKilcblxuKCogICAvLyBNYXJrZXIgVW5pdCBUeXBlcyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfTUFSS0VSVU5JVFNfVU5LTk9XTiA9IDA7ICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19NQVJLRVJVTklUU19VU0VSU1BBQ0VPTlVTRSA9IDE7ICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19NQVJLRVJVTklUU19TVFJPS0VXSURUSCA9IDI7ICopXG5cbigqICAgLy8gTWFya2VyIE9yaWVudGF0aW9uIFR5cGVzICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19NQVJLRVJfT1JJRU5UX1VOS05PV04gPSAwOyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfTUFSS0VSX09SSUVOVF9BVVRPID0gMTsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX01BUktFUl9PUklFTlRfQU5HTEUgPSAyOyAqKVxuXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZExlbmd0aCByZWZYOyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRMZW5ndGggcmVmWTsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkRW51bWVyYXRpb24gbWFya2VyVW5pdHM7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZExlbmd0aCBtYXJrZXJXaWR0aDsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkTGVuZ3RoIG1hcmtlckhlaWdodDsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkRW51bWVyYXRpb24gb3JpZW50VHlwZTsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkQW5nbGUgb3JpZW50QW5nbGU7ICopXG5cbigqICAgdm9pZCBzZXRPcmllbnRUb0F1dG8oKSByYWlzZXMoRE9NRXhjZXB0aW9uKTsgKilcbigqICAgdm9pZCBzZXRPcmllbnRUb0FuZ2xlKGluIFNWR0FuZ2xlIGFuZ2xlKSByYWlzZXMoRE9NRXhjZXB0aW9uKTsgKilcbigqIH07ICopXG5cbigqIGludGVyZmFjZSBTVkdDb2xvclByb2ZpbGVFbGVtZW50IDogU1ZHRWxlbWVudCwgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU1ZHVVJJUmVmZXJlbmNlLCAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTVkdSZW5kZXJpbmdJbnRlbnQgeyAqKVxuKCogICBhdHRyaWJ1dGUgRE9NU3RyaW5nIGxvY2FsOyAqKVxuKCogICBhdHRyaWJ1dGUgRE9NU3RyaW5nIG5hbWU7ICopXG4oKiAgIGF0dHJpYnV0ZSB1bnNpZ25lZCBzaG9ydCByZW5kZXJpbmdJbnRlbnQ7ICopXG4oKiB9OyAqKVxuXG4oKiBpbnRlcmZhY2UgU1ZHQ29sb3JQcm9maWxlUnVsZSA6IFNWR0NTU1J1bGUsICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNWR1JlbmRlcmluZ0ludGVudCB7ICopXG4oKiAgIGF0dHJpYnV0ZSBET01TdHJpbmcgc3JjIHNldHJhaXNlcyhET01FeGNlcHRpb24pOyAqKVxuKCogICBhdHRyaWJ1dGUgRE9NU3RyaW5nIG5hbWUgc2V0cmFpc2VzKERPTUV4Y2VwdGlvbik7ICopXG4oKiAgIGF0dHJpYnV0ZSB1bnNpZ25lZCBzaG9ydCByZW5kZXJpbmdJbnRlbnQgc2V0cmFpc2VzKERPTUV4Y2VwdGlvbik7ICopXG4oKiB9OyAqKVxuXG4oKiBpbnRlcmZhY2UgU1ZHR3JhZGllbnRFbGVtZW50ICopXG5hbmQgYW5pbWF0ZWRTcHJlYWRNZXRob2QgPSBbc3ByZWFkTWV0aG9kVHlwZV0gYW5pbWF0ZWRcblxuYW5kIGdyYWRpZW50RWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgaW5oZXJpdCB1cmlSZWZlcmVuY2VcblxuICAgIGluaGVyaXQgc3R5bGFibGVcblxuICAgICgqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkRW51bWVyYXRpb24gZ3JhZGllbnRVbml0czsgKilcbiAgICBtZXRob2QgZ3JhZGllbnRUcmFuc2Zvcm0gOiBhbmltYXRlZFRyYW5zZm9ybUxpc3QgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgc3ByZWFkTWV0aG9kIDogYW5pbWF0ZWRTcHJlYWRNZXRob2QgdCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHTGluZWFyR3JhZGllbnRFbGVtZW50ICopXG5hbmQgbGluZWFyR3JhZGllbnRFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBncmFkaWVudEVsZW1lbnRcblxuICAgIG1ldGhvZCB4MSA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHkxIDogYW5pbWF0ZWRMZW5ndGggdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgeDIgOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB5MiA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR1JhZGlhbEdyYWRpZW50RWxlbWVudCAqKVxuYW5kIHJhZGlhbEdyYWRpZW50RWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZ3JhZGllbnRFbGVtZW50XG5cbiAgICBtZXRob2QgY3ggOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBjeSA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHIgOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBmeCA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGZ5IDogYW5pbWF0ZWRMZW5ndGggdCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHU3RvcEVsZW1lbnQgKilcbmFuZCBzdG9wRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgaW5oZXJpdCBzdHlsYWJsZVxuXG4gICAgbWV0aG9kIG9mZnNldCA6IGFuaW1hdGVkTnVtYmVyIHQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR1BhdHRlcm5FbGVtZW50ICopXG5hbmQgcGF0dGVybkVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIGluaGVyaXQgdXJpUmVmZXJlbmNlXG5cbiAgICBpbmhlcml0IHRlc3RzXG5cbiAgICBpbmhlcml0IGxhbmdTcGFjZVxuXG4gICAgaW5oZXJpdCBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXG5cbiAgICBpbmhlcml0IHN0eWxhYmxlXG5cbiAgICBpbmhlcml0IGZpdFRvVmlld0JveFxuXG4gICAgKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRFbnVtZXJhdGlvbiBwYXR0ZXJuVW5pdHM7ICopXG4gICAgKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRFbnVtZXJhdGlvbiBwYXR0ZXJuQ29udGVudFVuaXRzOyAqKVxuICAgIG1ldGhvZCBwYXR0ZXJuVHJhbnNmb3JtIDogYW5pbWF0ZWRUcmFuc2Zvcm1MaXN0IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHggOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB5IDogYW5pbWF0ZWRMZW5ndGggdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgd2lkdGggOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBoZWlnaHQgOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdDbGlwUGF0aEVsZW1lbnQgKilcbmFuZCBjbGlwUGF0aEVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIGluaGVyaXQgdGVzdHNcblxuICAgIGluaGVyaXQgbGFuZ1NwYWNlXG5cbiAgICBpbmhlcml0IGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcblxuICAgIGluaGVyaXQgc3R5bGFibGVcblxuICAgIGluaGVyaXQgdHJhbnNmb3JtYWJsZVxuICAgICgqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkRW51bWVyYXRpb24gY2xpcFBhdGhVbml0czsgKilcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdNYXNrRWxlbWVudCAqKVxuYW5kIG1hc2tFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBpbmhlcml0IHRlc3RzXG5cbiAgICBpbmhlcml0IGxhbmdTcGFjZVxuXG4gICAgaW5oZXJpdCBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXG5cbiAgICBpbmhlcml0IHN0eWxhYmxlXG5cbiAgICAoKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZEVudW1lcmF0aW9uIG1hc2tVbml0czsgKilcbiAgICAoKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZEVudW1lcmF0aW9uIG1hc2tDb250ZW50VW5pdHM7ICopXG4gICAgbWV0aG9kIHggOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB5IDogYW5pbWF0ZWRMZW5ndGggdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgd2lkdGggOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBoZWlnaHQgOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdGaWx0ZXJFbGVtZW50ICopXG5hbmQgZmlsdGVyRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgaW5oZXJpdCB1cmlSZWZlcmVuY2VcblxuICAgIGluaGVyaXQgbGFuZ1NwYWNlXG5cbiAgICBpbmhlcml0IGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcblxuICAgIGluaGVyaXQgc3R5bGFibGVcblxuICAgICgqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkRW51bWVyYXRpb24gZmlsdGVyVW5pdHM7ICopXG4gICAgKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRFbnVtZXJhdGlvbiBwcmltaXRpdmVVbml0czsgKilcbiAgICBtZXRob2QgeCA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHkgOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB3aWR0aCA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGhlaWdodCA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGZpbHRlclJlc1ggOiBhbmltYXRlZEludGVnZXIgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgZmlsdGVyUmVzWSA6IGFuaW1hdGVkSW50ZWdlciB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBzZXRGaWx0ZXJSZXMgOiBpbnQgLT4gaW50IC0+IHVuaXQgbWV0aFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR0ZpbHRlclByaW1pdGl2ZVN0YW5kYXJkQXR0cmlidXRlcyA6IFNWR1N0eWxhYmxlIHsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkTGVuZ3RoIHg7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZExlbmd0aCB5OyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRMZW5ndGggd2lkdGg7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZExlbmd0aCBoZWlnaHQ7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZFN0cmluZyByZXN1bHQ7ICopXG4oKiB9OyAqKVxuXG4oKiBpbnRlcmZhY2UgU1ZHRkVCbGVuZEVsZW1lbnQgOiBTVkdFbGVtZW50LCAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU1ZHRmlsdGVyUHJpbWl0aXZlU3RhbmRhcmRBdHRyaWJ1dGVzIHsgKilcblxuKCogICAvLyBCbGVuZCBNb2RlIFR5cGVzICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19GRUJMRU5EX01PREVfVU5LTk9XTiA9IDA7ICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19GRUJMRU5EX01PREVfTk9STUFMID0gMTsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX0ZFQkxFTkRfTU9ERV9NVUxUSVBMWSA9IDI7ICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19GRUJMRU5EX01PREVfU0NSRUVOID0gMzsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX0ZFQkxFTkRfTU9ERV9EQVJLRU4gPSA0OyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfRkVCTEVORF9NT0RFX0xJR0hURU4gPSA1OyAqKVxuXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZFN0cmluZyBpbjE7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZFN0cmluZyBpbjI7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZEVudW1lcmF0aW9uIG1vZGU7ICopXG4oKiB9OyAqKVxuXG4oKiBpbnRlcmZhY2UgU1ZHRkVDb2xvck1hdHJpeEVsZW1lbnQgOiBTVkdFbGVtZW50LCAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU1ZHRmlsdGVyUHJpbWl0aXZlU3RhbmRhcmRBdHRyaWJ1dGVzIHsgKilcblxuKCogICAvLyBDb2xvciBNYXRyaXggVHlwZXMgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX0ZFQ09MT1JNQVRSSVhfVFlQRV9VTktOT1dOID0gMDsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX0ZFQ09MT1JNQVRSSVhfVFlQRV9NQVRSSVggPSAxOyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfRkVDT0xPUk1BVFJJWF9UWVBFX1NBVFVSQVRFID0gMjsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX0ZFQ09MT1JNQVRSSVhfVFlQRV9IVUVST1RBVEUgPSAzOyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfRkVDT0xPUk1BVFJJWF9UWVBFX0xVTUlOQU5DRVRPQUxQSEEgPSA0OyAqKVxuXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZFN0cmluZyBpbjE7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZEVudW1lcmF0aW9uIHR5cGU7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlckxpc3QgdmFsdWVzOyAqKVxuKCogfTsgKilcblxuKCogaW50ZXJmYWNlIFNWR0ZFQ29tcG9uZW50VHJhbnNmZXJFbGVtZW50IDogU1ZHRWxlbWVudCwgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNWR0ZpbHRlclByaW1pdGl2ZVN0YW5kYXJkQXR0cmlidXRlcyB7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZFN0cmluZyBpbjE7ICopXG4oKiB9OyAqKVxuXG4oKiBpbnRlcmZhY2UgU1ZHQ29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbkVsZW1lbnQgOiBTVkdFbGVtZW50IHsgKilcblxuKCogICAvLyBDb21wb25lbnQgVHJhbnNmZXIgVHlwZXMgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX0ZFQ09NUE9ORU5UVFJBTlNGRVJfVFlQRV9VTktOT1dOID0gMDsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX0ZFQ09NUE9ORU5UVFJBTlNGRVJfVFlQRV9JREVOVElUWSA9IDE7ICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19GRUNPTVBPTkVOVFRSQU5TRkVSX1RZUEVfVEFCTEUgPSAyOyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfRkVDT01QT05FTlRUUkFOU0ZFUl9UWVBFX0RJU0NSRVRFID0gMzsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX0ZFQ09NUE9ORU5UVFJBTlNGRVJfVFlQRV9MSU5FQVIgPSA0OyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfRkVDT01QT05FTlRUUkFOU0ZFUl9UWVBFX0dBTU1BID0gNTsgKilcblxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRFbnVtZXJhdGlvbiB0eXBlOyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWROdW1iZXJMaXN0IHRhYmxlVmFsdWVzOyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWROdW1iZXIgc2xvcGU7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciBpbnRlcmNlcHQ7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciBhbXBsaXR1ZGU7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciBleHBvbmVudDsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkTnVtYmVyIG9mZnNldDsgKilcbigqIH07ICopXG5cbigqIGludGVyZmFjZSBTVkdGRUZ1bmNSRWxlbWVudCA6IFNWR0NvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb25FbGVtZW50IHsgKilcbigqIH07ICopXG5cbigqIGludGVyZmFjZSBTVkdGRUZ1bmNHRWxlbWVudCA6IFNWR0NvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb25FbGVtZW50IHsgKilcbigqIH07ICopXG5cbigqIGludGVyZmFjZSBTVkdGRUZ1bmNCRWxlbWVudCA6IFNWR0NvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb25FbGVtZW50IHsgKilcbigqIH07ICopXG5cbigqIGludGVyZmFjZSBTVkdGRUZ1bmNBRWxlbWVudCA6IFNWR0NvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb25FbGVtZW50IHsgKilcbigqIH07ICopXG5cbigqIGludGVyZmFjZSBTVkdGRUNvbXBvc2l0ZUVsZW1lbnQgOiBTVkdFbGVtZW50LCAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNWR0ZpbHRlclByaW1pdGl2ZVN0YW5kYXJkQXR0cmlidXRlcyB7ICopXG5cbigqICAgLy8gQ29tcG9zaXRlIE9wZXJhdG9ycyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfRkVDT01QT1NJVEVfT1BFUkFUT1JfVU5LTk9XTiA9IDA7ICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19GRUNPTVBPU0lURV9PUEVSQVRPUl9PVkVSID0gMTsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX0ZFQ09NUE9TSVRFX09QRVJBVE9SX0lOID0gMjsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX0ZFQ09NUE9TSVRFX09QRVJBVE9SX09VVCA9IDM7ICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19GRUNPTVBPU0lURV9PUEVSQVRPUl9BVE9QID0gNDsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX0ZFQ09NUE9TSVRFX09QRVJBVE9SX1hPUiA9IDU7ICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19GRUNPTVBPU0lURV9PUEVSQVRPUl9BUklUSE1FVElDID0gNjsgKilcblxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRTdHJpbmcgaW4xOyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRTdHJpbmcgaW4yOyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRFbnVtZXJhdGlvbiBvcGVyYXRvcjsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkTnVtYmVyIGsxOyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWROdW1iZXIgazI7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciBrMzsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkTnVtYmVyIGs0OyAqKVxuKCogfTsgKilcblxuKCogaW50ZXJmYWNlIFNWR0ZFQ29udm9sdmVNYXRyaXhFbGVtZW50IDogU1ZHRWxlbWVudCwgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNWR0ZpbHRlclByaW1pdGl2ZVN0YW5kYXJkQXR0cmlidXRlcyB7ICopXG5cbigqICAgLy8gRWRnZSBNb2RlIFZhbHVlcyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfRURHRU1PREVfVU5LTk9XTiA9IDA7ICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19FREdFTU9ERV9EVVBMSUNBVEUgPSAxOyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfRURHRU1PREVfV1JBUCA9IDI7ICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19FREdFTU9ERV9OT05FID0gMzsgKilcblxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRTdHJpbmcgaW4xOyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRJbnRlZ2VyIG9yZGVyWDsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkSW50ZWdlciBvcmRlclk7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlckxpc3Qga2VybmVsTWF0cml4OyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWROdW1iZXIgZGl2aXNvcjsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkTnVtYmVyIGJpYXM7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZEludGVnZXIgdGFyZ2V0WDsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkSW50ZWdlciB0YXJnZXRZOyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRFbnVtZXJhdGlvbiBlZGdlTW9kZTsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkTnVtYmVyIGtlcm5lbFVuaXRMZW5ndGhYOyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWROdW1iZXIga2VybmVsVW5pdExlbmd0aFk7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZEJvb2xlYW4gcHJlc2VydmVBbHBoYTsgKilcbigqIH07ICopXG5cbigqIGludGVyZmFjZSBTVkdGRURpZmZ1c2VMaWdodGluZ0VsZW1lbnQgOiBTVkdFbGVtZW50LCAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNWR0ZpbHRlclByaW1pdGl2ZVN0YW5kYXJkQXR0cmlidXRlcyB7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZFN0cmluZyBpbjE7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciBzdXJmYWNlU2NhbGU7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciBkaWZmdXNlQ29uc3RhbnQ7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciBrZXJuZWxVbml0TGVuZ3RoWDsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkTnVtYmVyIGtlcm5lbFVuaXRMZW5ndGhZOyAqKVxuKCogfTsgKilcblxuKCogaW50ZXJmYWNlIFNWR0ZFRGlzdGFudExpZ2h0RWxlbWVudCA6IFNWR0VsZW1lbnQgeyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWROdW1iZXIgYXppbXV0aDsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkTnVtYmVyIGVsZXZhdGlvbjsgKilcbigqIH07ICopXG5cbigqIGludGVyZmFjZSBTVkdGRVBvaW50TGlnaHRFbGVtZW50IDogU1ZHRWxlbWVudCB7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciB4OyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWROdW1iZXIgeTsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkTnVtYmVyIHo7ICopXG4oKiB9OyAqKVxuXG4oKiBpbnRlcmZhY2UgU1ZHRkVTcG90TGlnaHRFbGVtZW50IDogU1ZHRWxlbWVudCB7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciB4OyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWROdW1iZXIgeTsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkTnVtYmVyIHo7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciBwb2ludHNBdFg7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciBwb2ludHNBdFk7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciBwb2ludHNBdFo7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciBzcGVjdWxhckV4cG9uZW50OyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWROdW1iZXIgbGltaXRpbmdDb25lQW5nbGU7ICopXG4oKiB9OyAqKVxuXG4oKiBpbnRlcmZhY2UgU1ZHRkVEaXNwbGFjZW1lbnRNYXBFbGVtZW50IDogU1ZHRWxlbWVudCwgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTVkdGaWx0ZXJQcmltaXRpdmVTdGFuZGFyZEF0dHJpYnV0ZXMgeyAqKVxuXG4oKiAgIC8vIENoYW5uZWwgU2VsZWN0b3JzICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19DSEFOTkVMX1VOS05PV04gPSAwOyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfQ0hBTk5FTF9SID0gMTsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX0NIQU5ORUxfRyA9IDI7ICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19DSEFOTkVMX0IgPSAzOyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfQ0hBTk5FTF9BID0gNDsgKilcblxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRTdHJpbmcgaW4xOyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRTdHJpbmcgaW4yOyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWROdW1iZXIgc2NhbGU7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZEVudW1lcmF0aW9uIHhDaGFubmVsU2VsZWN0b3I7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZEVudW1lcmF0aW9uIHlDaGFubmVsU2VsZWN0b3I7ICopXG4oKiB9OyAqKVxuXG4oKiBpbnRlcmZhY2UgU1ZHRkVGbG9vZEVsZW1lbnQgOiBTVkdFbGVtZW50LCAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU1ZHRmlsdGVyUHJpbWl0aXZlU3RhbmRhcmRBdHRyaWJ1dGVzIHsgKilcbigqIH07ICopXG5cbigqIGludGVyZmFjZSBTVkdGRUdhdXNzaWFuQmx1ckVsZW1lbnQgOiBTVkdFbGVtZW50LCAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNWR0ZpbHRlclByaW1pdGl2ZVN0YW5kYXJkQXR0cmlidXRlcyB7ICopXG5cbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkU3RyaW5nIGluMTsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkTnVtYmVyIHN0ZERldmlhdGlvblg7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciBzdGREZXZpYXRpb25ZOyAqKVxuXG4oKiAgIHZvaWQgc2V0U3RkRGV2aWF0aW9uKGluIGZsb2F0IHN0ZERldmlhdGlvblgsIGluIGZsb2F0IHN0ZERldmlhdGlvblkpIHJhaXNlcyhET01FeGNlcHRpb24pOyAqKVxuKCogfTsgKilcblxuKCogaW50ZXJmYWNlIFNWR0ZFSW1hZ2VFbGVtZW50IDogU1ZHRWxlbWVudCwgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNWR1VSSVJlZmVyZW5jZSwgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNWR0xhbmdTcGFjZSwgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNWR0V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQsICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTVkdGaWx0ZXJQcmltaXRpdmVTdGFuZGFyZEF0dHJpYnV0ZXMgeyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRQcmVzZXJ2ZUFzcGVjdFJhdGlvIHByZXNlcnZlQXNwZWN0UmF0aW87ICopXG4oKiB9OyAqKVxuXG4oKiBpbnRlcmZhY2UgU1ZHRkVNZXJnZUVsZW1lbnQgOiBTVkdFbGVtZW50LCAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU1ZHRmlsdGVyUHJpbWl0aXZlU3RhbmRhcmRBdHRyaWJ1dGVzIHsgKilcbigqIH07ICopXG5cbigqIGludGVyZmFjZSBTVkdGRU1lcmdlTm9kZUVsZW1lbnQgOiBTVkdFbGVtZW50IHsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkU3RyaW5nIGluMTsgKilcbigqIH07ICopXG5cbigqIGludGVyZmFjZSBTVkdGRU1vcnBob2xvZ3lFbGVtZW50IDogU1ZHRWxlbWVudCwgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU1ZHRmlsdGVyUHJpbWl0aXZlU3RhbmRhcmRBdHRyaWJ1dGVzIHsgKilcblxuKCogICAvLyBNb3JwaG9sb2d5IE9wZXJhdG9ycyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfTU9SUEhPTE9HWV9PUEVSQVRPUl9VTktOT1dOID0gMDsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX01PUlBIT0xPR1lfT1BFUkFUT1JfRVJPREUgPSAxOyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfTU9SUEhPTE9HWV9PUEVSQVRPUl9ESUxBVEUgPSAyOyAqKVxuXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZFN0cmluZyBpbjE7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZEVudW1lcmF0aW9uIG9wZXJhdG9yOyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWROdW1iZXIgcmFkaXVzWDsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkTnVtYmVyIHJhZGl1c1k7ICopXG4oKiB9OyAqKVxuXG4oKiBpbnRlcmZhY2UgU1ZHRkVPZmZzZXRFbGVtZW50IDogU1ZHRWxlbWVudCwgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTVkdGaWx0ZXJQcmltaXRpdmVTdGFuZGFyZEF0dHJpYnV0ZXMgeyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRTdHJpbmcgaW4xOyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWROdW1iZXIgZHg7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciBkeTsgKilcbigqIH07ICopXG5cbigqIGludGVyZmFjZSBTVkdGRVNwZWN1bGFyTGlnaHRpbmdFbGVtZW50IDogU1ZHRWxlbWVudCwgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU1ZHRmlsdGVyUHJpbWl0aXZlU3RhbmRhcmRBdHRyaWJ1dGVzIHsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkU3RyaW5nIGluMTsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkTnVtYmVyIHN1cmZhY2VTY2FsZTsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkTnVtYmVyIHNwZWN1bGFyQ29uc3RhbnQ7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciBzcGVjdWxhckV4cG9uZW50OyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWROdW1iZXIga2VybmVsVW5pdExlbmd0aFg7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciBrZXJuZWxVbml0TGVuZ3RoWTsgKilcbigqIH07ICopXG5cbigqIGludGVyZmFjZSBTVkdGRVRpbGVFbGVtZW50IDogU1ZHRWxlbWVudCwgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU1ZHRmlsdGVyUHJpbWl0aXZlU3RhbmRhcmRBdHRyaWJ1dGVzIHsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkU3RyaW5nIGluMTsgKilcbigqIH07ICopXG5cbigqIGludGVyZmFjZSBTVkdGRVR1cmJ1bGVuY2VFbGVtZW50IDogU1ZHRWxlbWVudCwgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU1ZHRmlsdGVyUHJpbWl0aXZlU3RhbmRhcmRBdHRyaWJ1dGVzIHsgKilcblxuKCogICAvLyBUdXJidWxlbmNlIFR5cGVzICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19UVVJCVUxFTkNFX1RZUEVfVU5LTk9XTiA9IDA7ICopXG4oKiAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IFNWR19UVVJCVUxFTkNFX1RZUEVfRlJBQ1RBTE5PSVNFID0gMTsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX1RVUkJVTEVOQ0VfVFlQRV9UVVJCVUxFTkNFID0gMjsgKilcblxuKCogICAvLyBTdGl0Y2ggT3B0aW9ucyAqKVxuKCogICBjb25zdCB1bnNpZ25lZCBzaG9ydCBTVkdfU1RJVENIVFlQRV9VTktOT1dOID0gMDsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX1NUSVRDSFRZUEVfU1RJVENIID0gMTsgKilcbigqICAgY29uc3QgdW5zaWduZWQgc2hvcnQgU1ZHX1NUSVRDSFRZUEVfTk9TVElUQ0ggPSAyOyAqKVxuXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciBiYXNlRnJlcXVlbmN5WDsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkTnVtYmVyIGJhc2VGcmVxdWVuY3lZOyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRJbnRlZ2VyIG51bU9jdGF2ZXM7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdBbmltYXRlZE51bWJlciBzZWVkOyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHQW5pbWF0ZWRFbnVtZXJhdGlvbiBzdGl0Y2hUaWxlczsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIFNWR0FuaW1hdGVkRW51bWVyYXRpb24gdHlwZTsgKilcbigqIH07ICopXG5cbigqIGludGVyZmFjZSBTVkdDdXJzb3JFbGVtZW50ICopXG5hbmQgY3Vyc29yRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgaW5oZXJpdCB1cmlSZWZlcmVuY2VcblxuICAgIGluaGVyaXQgdGVzdHNcblxuICAgIGluaGVyaXQgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFxuXG4gICAgbWV0aG9kIHggOiBhbmltYXRlZExlbmd0aCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB5IDogYW5pbWF0ZWRMZW5ndGggdCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHQUVsZW1lbnQgKilcbmFuZCBhRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgaW5oZXJpdCB1cmlSZWZlcmVuY2VcblxuICAgIGluaGVyaXQgdGVzdHNcblxuICAgIGluaGVyaXQgbGFuZ1NwYWNlXG5cbiAgICBpbmhlcml0IGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcblxuICAgIGluaGVyaXQgc3R5bGFibGVcblxuICAgIGluaGVyaXQgdHJhbnNmb3JtYWJsZVxuXG4gICAgbWV0aG9kIHRhcmdldCA6IGFuaW1hdGVkU3RyaW5nIHQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR1ZpZXdFbGVtZW50ICopXG5hbmQgdmlld0VsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGVsZW1lbnRcblxuICAgIGluaGVyaXQgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFxuXG4gICAgaW5oZXJpdCBmaXRUb1ZpZXdCb3hcblxuICAgIGluaGVyaXQgem9vbUFuZFBhblxuXG4gICAgbWV0aG9kIHZpZXdUYXJnZXQgOiBzdHJpbmdMaXN0IHQgcmVhZG9ubHlfcHJvcFxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR1NjcmlwdEVsZW1lbnQgKilcbmFuZCBzY3JpcHRFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBpbmhlcml0IHVyaVJlZmVyZW5jZVxuXG4gICAgaW5oZXJpdCBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXG5cbiAgICBtZXRob2QgdHlwZV8gOiBqc19zdHJpbmcgdCBwcm9wXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHWm9vbUV2ZW50IDogVUlFdmVudCAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHUmVjdCB6b29tUmVjdFNjcmVlbjsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIGZsb2F0IHByZXZpb3VzU2NhbGU7ICopXG4oKiAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBTVkdQb2ludCBwcmV2aW91c1RyYW5zbGF0ZTsgKilcbigqICAgcmVhZG9ubHkgYXR0cmlidXRlIGZsb2F0IG5ld1NjYWxlOyAqKVxuKCogICByZWFkb25seSBhdHRyaWJ1dGUgU1ZHUG9pbnQgbmV3VHJhbnNsYXRlOyAqKVxuKCogfTsgKilcblxuKCogaW50ZXJmYWNlIFNWR0FuaW1hdGlvbkVsZW1lbnQgKilcbmFuZCBhbmltYXRpb25FbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBpbmhlcml0IHRlc3RzXG5cbiAgICBpbmhlcml0IGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcblxuICAgICgqIGluaGVyaXQgZWxlbWVudFRpbWVDb250cm9sICopXG4gICAgbWV0aG9kIHRhcmdldEVsZW1lbnQgOiBlbGVtZW50IHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGdldFN0YXJ0VGltZSA6IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRDdXJyZW50VGltZSA6IGZsb2F0IG1ldGhcblxuICAgIG1ldGhvZCBnZXRTaW1wbGVEdXJhdGlvbiA6IGZsb2F0IG1ldGhcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdBbmltYXRlRWxlbWVudCAqKVxuYW5kIGFuaW1hdGVFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBhbmltYXRpb25FbGVtZW50XG5cbiAgICBpbmhlcml0IHN0eWxhYmxlXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHU2V0RWxlbWVudCAqKVxuYW5kIHNldEVsZW1lbnQgPSBhbmltYXRpb25FbGVtZW50XG5cbigqIGludGVyZmFjZSBTVkdBbmltYXRlTW90aW9uRWxlbWVudCAqKVxuYW5kIGFuaW1hdGVNb3Rpb25FbGVtZW50ID0gYW5pbWF0aW9uRWxlbWVudFxuXG4oKiBpbnRlcmZhY2UgU1ZHTVBhdGhFbGVtZW50ICopXG5hbmQgbVBhdGhFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBpbmhlcml0IHVyaVJlZmVyZW5jZVxuXG4gICAgaW5oZXJpdCBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXG4gIGVuZFxuXG4oKiBpbnRlcmZhY2UgU1ZHQW5pbWF0ZUNvbG9yRWxlbWVudCAqKVxuYW5kIGFuaW1hdGVDb2xvckVsZW1lbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IGFuaW1hdGlvbkVsZW1lbnRcblxuICAgIGluaGVyaXQgc3R5bGFibGVcbiAgZW5kXG5cbigqIGludGVyZmFjZSBTVkdBbmltYXRlVHJhbnNmb3JtRWxlbWVudCAqKVxuYW5kIGFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50ID0gYW5pbWF0aW9uRWxlbWVudFxuXG4oKiBpbnRlcmZhY2UgU1ZHRm9udEVsZW1lbnQgKilcbmFuZCBmb250RWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgaW5oZXJpdCBzdHlsYWJsZVxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR0dseXBoRWxlbWVudCAqKVxuKCogaW50ZXJmYWNlIFNWR01pc3NpbmdHbHlwaEVsZW1lbnQqKVxuYW5kIGdseXBoRWxlbWVudCA9XG4gIG9iamVjdFxuICAgIGluaGVyaXQgZWxlbWVudFxuXG4gICAgaW5oZXJpdCBzdHlsYWJsZVxuICBlbmRcblxuKCogaW50ZXJmYWNlIFNWR0hLZXJuRWxlbWVudCA6IFNWR0VsZW1lbnQgKilcbigqIGludGVyZmFjZSBTVkdWS2VybkVsZW1lbnQgOiBTVkdFbGVtZW50ICopXG5cbigqIGludGVyZmFjZSBTVkdGb250RmFjZUVsZW1lbnQgKilcbmNsYXNzIHR5cGUgZm9udEZhY2VFbGVtZW50ID0gZWxlbWVudFxuXG4oKiBpbnRlcmZhY2UgU1ZHRm9udEZhY2VTcmNFbGVtZW50ICopXG5jbGFzcyB0eXBlIGZvbnRGYWNlU3JjRWxlbWVudCA9IGVsZW1lbnRcblxuKCogaW50ZXJmYWNlIFNWR0ZvbnRGYWNlVXJpRWxlbWVudCAqKVxuY2xhc3MgdHlwZSBmb250RmFjZVVyaUVsZW1lbnQgPSBlbGVtZW50XG5cbigqIGludGVyZmFjZSBTVkdGb250RmFjZUZvcm1hdEVsZW1lbnQgKilcbmNsYXNzIHR5cGUgZm9udEZhY2VGb3JtYXRFbGVtZW50ID0gZWxlbWVudFxuXG4oKiBpbnRlcmZhY2UgU1ZHRm9udEZhY2VOYW1lRWxlbWVudCAqKVxuY2xhc3MgdHlwZSBmb250RmFjZU5hbWVFbGVtZW50ID0gZWxlbWVudFxuXG4oKiBpbnRlcmZhY2UgU1ZHTWV0YWRhdGFFbGVtZW50ICopXG5jbGFzcyB0eXBlIG1ldGFkYXRhRWxlbWVudCA9IGVsZW1lbnRcblxuKCogaW50ZXJmYWNlIFNWR0ZvcmVpZ25PYmplY3RFbGVtZW50ICopXG5jbGFzcyB0eXBlIGZvcmVpZ25PYmplY3RFbGVtZW50ID1cbiAgb2JqZWN0XG4gICAgaW5oZXJpdCBlbGVtZW50XG5cbiAgICBpbmhlcml0IHRlc3RzXG5cbiAgICBpbmhlcml0IGxhbmdTcGFjZVxuXG4gICAgaW5oZXJpdCBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXG5cbiAgICBpbmhlcml0IHN0eWxhYmxlXG5cbiAgICBpbmhlcml0IHRyYW5zZm9ybWFibGVcblxuICAgIG1ldGhvZCB4IDogYW5pbWF0ZWRMZW5ndGggdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgeSA6IGFuaW1hdGVkTGVuZ3RoIHQgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHdpZHRoIDogYW5pbWF0ZWRMZW5ndGggdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgaGVpZ2h0IDogYW5pbWF0ZWRMZW5ndGggdCByZWFkb25seV9wcm9wXG4gIGVuZFxuXG5sZXQgY3JlYXRlRWxlbWVudCAoZG9jIDogZG9jdW1lbnQgdCkgbmFtZSA9IGRvYyMjY3JlYXRlRWxlbWVudE5TIHhtbG5zIChKcy5zdHJpbmcgbmFtZSlcblxubGV0IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIG5hbWUgPSBKcy5VbnNhZmUuY29lcmNlIChjcmVhdGVFbGVtZW50IGRvYyBuYW1lKVxuXG5sZXQgY3JlYXRlQSBkb2MgOiBhRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJhXCJcblxubGV0IGNyZWF0ZUFsdEdseXBoIGRvYyA6IGFsdEdseXBoRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJhbHRnbHlwaFwiXG5cbmxldCBjcmVhdGVBbHRHbHlwaERlZiBkb2MgOiBhbHRHbHlwaERlZkVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiYWx0Z2x5cGhkZWZcIlxuXG5sZXQgY3JlYXRlQWx0R2x5cGhJdGVtIGRvYyA6IGFsdEdseXBoSXRlbUVsZW1lbnQgdCA9XG4gIHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiYWx0Z2x5cGhpdGVtXCJcblxubGV0IGNyZWF0ZUFuaW1hdGUgZG9jIDogYW5pbWF0ZUVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiYW5pbWF0ZVwiXG5cbmxldCBjcmVhdGVBbmltYXRlQ29sb3IgZG9jIDogYW5pbWF0ZUNvbG9yRWxlbWVudCB0ID1cbiAgdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJhbmltYXRlY29sb3JcIlxuXG5sZXQgY3JlYXRlQW5pbWF0ZU1vdGlvbiBkb2MgOiBhbmltYXRlTW90aW9uRWxlbWVudCB0ID1cbiAgdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJhbmltYXRlbW90aW9uXCJcblxubGV0IGNyZWF0ZUFuaW1hdGVUcmFuc2Zvcm0gZG9jIDogYW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQgdCA9XG4gIHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiYW5pbWF0ZXRyYW5zZm9ybVwiXG5cbmxldCBjcmVhdGVDaXJjbGUgZG9jIDogY2lyY2xlRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJjaXJjbGVcIlxuXG5sZXQgY3JlYXRlQ2xpcFBhdGggZG9jIDogY2xpcFBhdGhFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImNsaXBwYXRoXCJcblxuKCogbGV0IGNyZWF0ZUNvbG9yUHJvZmlsZSBkb2MgOiBjb2xvclByb2ZpbGUgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiY29sb3ItcHJvZmlsZVwiICopXG5sZXQgY3JlYXRlQ3Vyc29yIGRvYyA6IGN1cnNvckVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiY3Vyc29yXCJcblxubGV0IGNyZWF0ZURlZnMgZG9jIDogZGVmc0VsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiZGVmc1wiXG5cbmxldCBjcmVhdGVEZXNjIGRvYyA6IGRlc2NFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImRlc2NcIlxuXG5sZXQgY3JlYXRlRWxsaXBzZSBkb2MgOiBlbGxpcHNlRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJlbGxpcHNlXCJcblxuKCogbGV0IGNyZWF0ZUZlKiAqKVxubGV0IGNyZWF0ZUZpbHRlciBkb2MgOiBmaWx0ZXJFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImZpbHRlclwiXG5cbmxldCBjcmVhdGVGb250IGRvYyA6IGZvbnRFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImZvbnRcIlxuXG5sZXQgY3JlYXRlRm9udEZhY2UgZG9jIDogZm9udEVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiZm9udC1mYWNlXCJcblxubGV0IGNyZWF0ZUZvbnRGYWNlRm9ybWF0IGRvYyA6IGZvbnRFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImZvbnQtZmFjZS1mb3JtYXRcIlxuXG5sZXQgY3JlYXRlRm9udEZhY2VOYW1lIGRvYyA6IGZvbnRFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImZvbnQtZmFjZS1uYW1lXCJcblxubGV0IGNyZWF0ZUZvbnRGYWNlU3JjIGRvYyA6IGZvbnRFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImZvbnQtZmFjZS1zcmNcIlxuXG5sZXQgY3JlYXRlRm9udEZhY2VVcmkgZG9jIDogZm9udEVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiZm9udC1mYWNlLXVyaVwiXG5cbmxldCBjcmVhdGVGb3JlaWduT2JqZWN0IGRvYyA6IGZvcmVpZ25PYmplY3RFbGVtZW50IHQgPVxuICB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcImZvcmVpZ25PYmplY3RcIlxuXG5sZXQgY3JlYXRlRyBkb2MgOiBnRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJnXCJcblxubGV0IGNyZWF0ZUdseXBoIGRvYyA6IGdseXBoRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJnbHlwaFwiXG5cbmxldCBjcmVhdGVHbHlwaFJlZiBkb2MgOiBnbHlwaEVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiZ2x5cGhyZWZcIlxuXG5sZXQgY3JlYXRlaGtlcm4gZG9jIDogZWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJoa2VyblwiXG5cbmxldCBjcmVhdGVJbWFnZSBkb2MgOiBpbWFnZUVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwiaW1hZ2VcIlxuXG5sZXQgY3JlYXRlTGluZUVsZW1lbnQgZG9jIDogbGluZUVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwibGluZVwiXG5cbmxldCBjcmVhdGVMaW5lYXJFbGVtZW50IGRvYyA6IGxpbmVhckdyYWRpZW50RWxlbWVudCB0ID1cbiAgdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJsaW5lYXJncmFkaWVudFwiXG5cbigqIGxldCBjcmVhdGVNYXJrZXIgZG9jIDogbWFya2VyRWxlbWVudCAqKVxubGV0IGNyZWF0ZU1hc2sgZG9jIDogbWFza0VsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwibWFza1wiXG5cbmxldCBjcmVhdGVNZXRhRGF0YSBkb2MgOiBtZXRhZGF0YUVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwibWV0YWRhdGFcIlxuXG5sZXQgY3JlYXRlTWlzc2luZ0dseXBoIGRvYyA6IGdseXBoRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJtaXNzaW5nLWdseXBoXCJcblxubGV0IGNyZWF0ZU1QYXRoIGRvYyA6IG1QYXRoRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJtcGF0aFwiXG5cbmxldCBjcmVhdGVQYXRoIGRvYyA6IHBhdGhFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcInBhdGhcIlxuXG5sZXQgY3JlYXRlUGF0dGVybiBkb2MgOiBwYXR0ZXJuRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJwYXR0ZXJuXCJcblxubGV0IGNyZWF0ZVBvbHlnb24gZG9jIDogcG9seWdvbkVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwicG9seWdvblwiXG5cbmxldCBjcmVhdGVQb2x5bGluZSBkb2MgOiBwb2x5TGluZUVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwicG9seWxpbmVcIlxuXG5sZXQgY3JlYXRlUmFkaWFsZ3JhZGllbnQgZG9jIDogcmFkaWFsR3JhZGllbnRFbGVtZW50IHQgPVxuICB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcInJhZGlhbGdyYWRpZW50XCJcblxubGV0IGNyZWF0ZVJlY3QgZG9jIDogcmVjdEVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwicmVjdFwiXG5cbmxldCBjcmVhdGVTY3JpcHQgZG9jIDogc2NyaXB0RWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJzY3JpcHRcIlxuXG5sZXQgY3JlYXRlU2V0IGRvYyA6IHNldEVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwic2V0XCJcblxubGV0IGNyZWF0ZVN0b3AgZG9jIDogc3RvcEVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwic3RvcFwiXG5cbmxldCBjcmVhdGVTdHlsZSBkb2MgOiBzdHlsZUVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwic3R5bGVcIlxuXG5sZXQgY3JlYXRlU3ZnIGRvYyA6IHN2Z0VsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwic3ZnXCJcblxubGV0IGNyZWF0ZVN3aXRjaCBkb2MgOiBzd2l0Y2hFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcInN3aXRjaFwiXG5cbmxldCBjcmVhdGVTeW1ib2wgZG9jIDogc3ltYm9sRWxlbWVudCB0ID0gdW5zYWZlQ3JlYXRlRWxlbWVudCBkb2MgXCJzeW1ib2xcIlxuXG5sZXQgY3JlYXRlVGV4dEVsZW1lbnQgZG9jIDogdGV4dEVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwidGV4dFwiXG5cbmxldCBjcmVhdGVUZXh0cGF0aCBkb2MgOiB0ZXh0UGF0aEVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwidGV4dHBhdGhcIlxuXG5sZXQgY3JlYXRlVGl0bGUgZG9jIDogdGl0bGVFbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcInRpdGxlXCJcblxubGV0IGNyZWF0ZVRyZWYgZG9jIDogdHJlZkVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwidHJlZlwiXG5cbmxldCBjcmVhdGVUc3BhbiBkb2MgOiB0c3BhbkVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwidHNwYW5cIlxuXG5sZXQgY3JlYXRlVXNlIGRvYyA6IHVzZUVsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwidXNlXCJcblxubGV0IGNyZWF0ZVZpZXcgZG9jIDogdmlld0VsZW1lbnQgdCA9IHVuc2FmZUNyZWF0ZUVsZW1lbnQgZG9jIFwidmlld1wiXG5cbmxldCBjcmVhdGV2a2VybiBkb2MgOiBlbGVtZW50IHQgPSB1bnNhZmVDcmVhdGVFbGVtZW50IGRvYyBcInZrZXJuXCJcblxuKCoqKiopXG5cbmxldCBzdmdfZWxlbWVudCA6IGVsZW1lbnQgdCBjb25zdHIgPSBKcy5VbnNhZmUuZ2xvYmFsIyMuX1NWR0VsZW1lbnRcblxubGV0IGRvY3VtZW50ID0gSnMuVW5zYWZlLmdsb2JhbCMjLmRvY3VtZW50XG5cbmxldCBnZXRFbGVtZW50QnlJZCBpZCA6IGVsZW1lbnQgdCA9XG4gIEpzLk9wdC5jYXNlXG4gICAgKEpzLlVuc2FmZS5nbG9iYWwjIy5kb2N1bWVudCMjZ2V0RWxlbWVudEJ5SWQgKEpzLnN0cmluZyBpZCkpXG4gICAgKGZ1biAoKSAtPiByYWlzZSBOb3RfZm91bmQpXG4gICAgKGZ1biBlIC0+IGlmIEpzLmluc3RhbmNlb2YgZSBzdmdfZWxlbWVudCB0aGVuIGUgZWxzZSByYWlzZSBOb3RfZm91bmQpXG5cbm1vZHVsZSBDb2VyY2VUbyA9IHN0cnVjdFxuICBsZXQgZWxlbWVudCAoZSA6ICNEb20ubm9kZSBKcy50KSA6IGVsZW1lbnQgSnMudCBKcy5vcHQgPVxuICAgIGlmIEpzLmluc3RhbmNlb2YgZSBzdmdfZWxlbWVudCB0aGVuIEpzLnNvbWUgKEpzLlVuc2FmZS5jb2VyY2UgZSkgZWxzZSBKcy5udWxsXG5cbiAgbGV0IHVuc2FmZUNvZXJjZSAoZSA6ICNlbGVtZW50IHQpIHRhZyA9XG4gICAgaWYgZSMjLnRhZ05hbWUjI3RvTG93ZXJDYXNlID09IEpzLnN0cmluZyB0YWdcbiAgICB0aGVuIEpzLnNvbWUgKEpzLlVuc2FmZS5jb2VyY2UgZSlcbiAgICBlbHNlIEpzLm51bGxcblxuICBsZXQgYSBlIDogYUVsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcImFcIlxuXG4gIGxldCBhbHRHbHlwaCBlIDogYWx0R2x5cGhFbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJhbHRnbHlwaFwiXG5cbiAgbGV0IGFsdEdseXBoRGVmIGUgOiBhbHRHbHlwaERlZkVsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcImFsdGdseXBoZGVmXCJcblxuICBsZXQgYWx0R2x5cGhJdGVtIGUgOiBhbHRHbHlwaEl0ZW1FbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJhbHRnbHlwaGl0ZW1cIlxuXG4gIGxldCBhbmltYXRlIGUgOiBhbmltYXRlRWxlbWVudCB0IG9wdCA9IHVuc2FmZUNvZXJjZSBlIFwiYW5pbWF0ZVwiXG5cbiAgbGV0IGFuaW1hdGVDb2xvciBlIDogYW5pbWF0ZUNvbG9yRWxlbWVudCB0IG9wdCA9IHVuc2FmZUNvZXJjZSBlIFwiYW5pbWF0ZWNvbG9yXCJcblxuICBsZXQgYW5pbWF0ZU1vdGlvbiBlIDogYW5pbWF0ZU1vdGlvbkVsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcImFuaW1hdGVtb3Rpb25cIlxuXG4gIGxldCBhbmltYXRlVHJhbnNmb3JtIGUgOiBhbmltYXRlVHJhbnNmb3JtRWxlbWVudCB0IG9wdCA9XG4gICAgdW5zYWZlQ29lcmNlIGUgXCJhbmltYXRldHJhbnNmb3JtXCJcblxuICBsZXQgY2lyY2xlIGUgOiBjaXJjbGVFbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJjaXJjbGVcIlxuXG4gIGxldCBjbGlwUGF0aCBlIDogY2xpcFBhdGhFbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJjbGlwcGF0aFwiXG5cbiAgKCogbGV0IENvbG9yUHJvZmlsZSBlIDogY29sb3JQcm9maWxlIHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJjb2xvci1wcm9maWxlXCIgKilcbiAgbGV0IGN1cnNvciBlIDogY3Vyc29yRWxlbWVudCB0IG9wdCA9IHVuc2FmZUNvZXJjZSBlIFwiY3Vyc29yXCJcblxuICBsZXQgZGVmcyBlIDogZGVmc0VsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcImRlZnNcIlxuXG4gIGxldCBkZXNjIGUgOiBkZXNjRWxlbWVudCB0IG9wdCA9IHVuc2FmZUNvZXJjZSBlIFwiZGVzY1wiXG5cbiAgbGV0IGVsbGlwc2UgZSA6IGVsbGlwc2VFbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJlbGxpcHNlXCJcblxuICAoKiBsZXQgRmUqICopXG4gIGxldCBmaWx0ZXIgZSA6IGZpbHRlckVsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcImZpbHRlclwiXG5cbiAgbGV0IGZvbnQgZSA6IGZvbnRFbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJmb250XCJcblxuICBsZXQgZm9udEZhY2UgZSA6IGZvbnRFbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJmb250LWZhY2VcIlxuXG4gIGxldCBmb250RmFjZUZvcm1hdCBlIDogZm9udEVsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcImZvbnQtZmFjZS1mb3JtYXRcIlxuXG4gIGxldCBmb250RmFjZU5hbWUgZSA6IGZvbnRFbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJmb250LWZhY2UtbmFtZVwiXG5cbiAgbGV0IGZvbnRGYWNlU3JjIGUgOiBmb250RWxlbWVudCB0IG9wdCA9IHVuc2FmZUNvZXJjZSBlIFwiZm9udC1mYWNlLXNyY1wiXG5cbiAgbGV0IGZvbnRGYWNlVXJpIGUgOiBmb250RWxlbWVudCB0IG9wdCA9IHVuc2FmZUNvZXJjZSBlIFwiZm9udC1mYWNlLXVyaVwiXG5cbiAgbGV0IGZvcmVpZ25PYmplY3QgZSA6IGZvcmVpZ25PYmplY3RFbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJmb3JlaWdub2JqZWN0XCJcblxuICBsZXQgZyBlIDogZ0VsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcImdcIlxuXG4gIGxldCBnbHlwaCBlIDogZ2x5cGhFbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJnbHlwaFwiXG5cbiAgbGV0IGdseXBoUmVmIGUgOiBnbHlwaEVsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcImdseXBocmVmXCJcblxuICBsZXQgaGtlcm4gZSA6IGVsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcImhrZXJuXCJcblxuICBsZXQgaW1hZ2UgZSA6IGltYWdlRWxlbWVudCB0IG9wdCA9IHVuc2FmZUNvZXJjZSBlIFwiaW1hZ2VcIlxuXG4gIGxldCBsaW5lRWxlbWVudCBlIDogbGluZUVsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcImxpbmVcIlxuXG4gIGxldCBsaW5lYXJFbGVtZW50IGUgOiBsaW5lYXJHcmFkaWVudEVsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcImxpbmVhcmdyYWRpZW50XCJcblxuICAoKiBsZXQgTWFya2VyIGUgOiBtYXJrZXJFbGVtZW50ICopXG4gIGxldCBtYXNrIGUgOiBtYXNrRWxlbWVudCB0IG9wdCA9IHVuc2FmZUNvZXJjZSBlIFwibWFza1wiXG5cbiAgbGV0IG1ldGFEYXRhIGUgOiBtZXRhZGF0YUVsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcIm1ldGFkYXRhXCJcblxuICBsZXQgbWlzc2luZ0dseXBoIGUgOiBnbHlwaEVsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcIm1pc3NpbmctZ2x5cGhcIlxuXG4gIGxldCBtUGF0aCBlIDogbVBhdGhFbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJtcGF0aFwiXG5cbiAgbGV0IHBhdGggZSA6IHBhdGhFbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJwYXRoXCJcblxuICBsZXQgcGF0dGVybiBlIDogcGF0dGVybkVsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcInBhdHRlcm5cIlxuXG4gIGxldCBwb2x5Z29uIGUgOiBwb2x5Z29uRWxlbWVudCB0IG9wdCA9IHVuc2FmZUNvZXJjZSBlIFwicG9seWdvblwiXG5cbiAgbGV0IHBvbHlsaW5lIGUgOiBwb2x5TGluZUVsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcInBvbHlsaW5lXCJcblxuICBsZXQgcmFkaWFsZ3JhZGllbnQgZSA6IHJhZGlhbEdyYWRpZW50RWxlbWVudCB0IG9wdCA9IHVuc2FmZUNvZXJjZSBlIFwicmFkaWFsZ3JhZGllbnRcIlxuXG4gIGxldCByZWN0IGUgOiByZWN0RWxlbWVudCB0IG9wdCA9IHVuc2FmZUNvZXJjZSBlIFwicmVjdFwiXG5cbiAgbGV0IHNjcmlwdCBlIDogc2NyaXB0RWxlbWVudCB0IG9wdCA9IHVuc2FmZUNvZXJjZSBlIFwic2NyaXB0XCJcblxuICBsZXQgc2V0IGUgOiBzZXRFbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJzZXRcIlxuXG4gIGxldCBzdG9wIGUgOiBzdG9wRWxlbWVudCB0IG9wdCA9IHVuc2FmZUNvZXJjZSBlIFwic3RvcFwiXG5cbiAgbGV0IHN0eWxlIGUgOiBzdHlsZUVsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcInN0eWxlXCJcblxuICBsZXQgc3ZnIGUgOiBzdmdFbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJzdmdcIlxuXG4gIGxldCBzd2l0Y2ggZSA6IHN3aXRjaEVsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcInN3aXRjaFwiXG5cbiAgbGV0IHN5bWJvbCBlIDogc3ltYm9sRWxlbWVudCB0IG9wdCA9IHVuc2FmZUNvZXJjZSBlIFwic3ltYm9sXCJcblxuICBsZXQgdGV4dEVsZW1lbnQgZSA6IHRleHRFbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJ0ZXh0XCJcblxuICBsZXQgdGV4dHBhdGggZSA6IHRleHRQYXRoRWxlbWVudCB0IG9wdCA9IHVuc2FmZUNvZXJjZSBlIFwidGV4dHBhdGhcIlxuXG4gIGxldCB0aXRsZSBlIDogdGl0bGVFbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJ0aXRsZVwiXG5cbiAgbGV0IHRyZWYgZSA6IHRyZWZFbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJ0cmVmXCJcblxuICBsZXQgdHNwYW4gZSA6IHRzcGFuRWxlbWVudCB0IG9wdCA9IHVuc2FmZUNvZXJjZSBlIFwidHNwYW5cIlxuXG4gIGxldCB1c2UgZSA6IHVzZUVsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcInVzZVwiXG5cbiAgbGV0IHZpZXcgZSA6IHZpZXdFbGVtZW50IHQgb3B0ID0gdW5zYWZlQ29lcmNlIGUgXCJ2aWV3XCJcblxuICBsZXQgdmtlcm4gZSA6IGVsZW1lbnQgdCBvcHQgPSB1bnNhZmVDb2VyY2UgZSBcInZrZXJuXCJcbmVuZFxuIiwiKCogSnNfb2Zfb2NhbWwgbGlicmFyeVxuICogaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbiAqIENvcHlyaWdodCAoQykgMjAxNCBIdWdvIEhldXphcmRcbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuICogZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAqIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAqIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4gKilcblxuKCogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50U291cmNlICopXG5vcGVuIEpzXG5vcGVuIERvbVxub3BlbiEgSW1wb3J0XG5cbnR5cGUgc3RhdGUgPVxuICB8IENPTk5FQ1RJTkdcbiAgfCBPUEVOXG4gIHwgQ0xPU0VEXG5cbmNsYXNzIHR5cGUgWydhXSBtZXNzYWdlRXZlbnQgPVxuICBvYmplY3RcbiAgICBpbmhlcml0IFsnYV0gRG9tLmV2ZW50XG5cbiAgICBtZXRob2QgZGF0YSA6IGpzX3N0cmluZyB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvcmlnaW4gOiBqc19zdHJpbmcgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgbGFzdEV2ZW50SWQgOiBqc19zdHJpbmcgdCByZWFkb25seV9wcm9wXG4gICAgKCogbWV0aG9kIHNvdXJjZSA6IHVuaXQgKilcbiAgZW5kXG5cbmNsYXNzIHR5cGUgZXZlbnRTb3VyY2UgPVxuICBvYmplY3QgKCdzZWxmKVxuICAgIG1ldGhvZCB1cmwgOiBzdHJpbmcgdCByZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgd2l0aENyZWRlbnRpYWxzIDogYm9vbCB0IHJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCByZWFkeVN0YXRlIDogc3RhdGUgcmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGNsb3NlIDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgb25vcGVuIDogKCdzZWxmIHQsICdzZWxmIG1lc3NhZ2VFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG9ubWVzc2FnZSA6ICgnc2VsZiB0LCAnc2VsZiBtZXNzYWdlRXZlbnQgdCkgZXZlbnRfbGlzdGVuZXIgd3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvbmVycm9yIDogKCdzZWxmIHQsICdzZWxmIG1lc3NhZ2VFdmVudCB0KSBldmVudF9saXN0ZW5lciB3cml0ZW9ubHlfcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSBvcHRpb25zID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIHdpdGhDcmVkZW50aWFscyA6IGJvb2wgdCB3cml0ZW9ubHlfcHJvcFxuICBlbmRcblxubGV0IHdpdGhDcmVkZW50aWFscyBiIDogb3B0aW9ucyB0ID1cbiAgbGV0IGluaXQgPSBKcy5VbnNhZmUub2JqIFt8fF0gaW5cbiAgaW5pdCMjLndpdGhDcmVkZW50aWFscyA6PSBKcy5ib29sIGI7XG4gIGluaXRcblxubGV0IGV2ZW50U291cmNlID0gSnMuVW5zYWZlLmdsb2JhbCMjLl9FdmVudFNvdXJjZVxuXG5sZXQgZXZlbnRTb3VyY2Vfb3B0aW9ucyA9IEpzLlVuc2FmZS5nbG9iYWwjIy5fRXZlbnRTb3VyY2VcblxubGV0IGFkZEV2ZW50TGlzdGVuZXIgPSBEb20uYWRkRXZlbnRMaXN0ZW5lclxuIiwiKCogSnNfb2Zfb2NhbWwgbGlicmFyeVxuICogaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbiAqIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuICogTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbiAqIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICopXG5cbm9wZW4gSnNcbm9wZW4hIEltcG9ydFxuXG5jbGFzcyB0eXBlIGNvbnNvbGUgPVxuICBvYmplY3RcbiAgICBtZXRob2QgbG9nIDogXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBsb2dfMiA6IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBsb2dfMyA6IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGxvZ180IDogXyAtPiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBsb2dfNSA6IF8gLT4gXyAtPiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBsb2dfNiA6IF8gLT4gXyAtPiBfIC0+IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGxvZ183IDogXyAtPiBfIC0+IF8gLT4gXyAtPiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBsb2dfOCA6IF8gLT4gXyAtPiBfIC0+IF8gLT4gXyAtPiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBkZWJ1ZyA6IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZGVidWdfMiA6IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBkZWJ1Z18zIDogXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZGVidWdfNCA6IF8gLT4gXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZGVidWdfNSA6IF8gLT4gXyAtPiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBpbmZvIDogXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBpbmZvXzIgOiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgaW5mb18zIDogXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgaW5mb180IDogXyAtPiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBpbmZvXzUgOiBfIC0+IF8gLT4gXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgd2FybiA6IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgd2Fybl8yIDogXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHdhcm5fMyA6IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHdhcm5fNCA6IF8gLT4gXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2Qgd2Fybl81IDogXyAtPiBfIC0+IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGVycm9yIDogXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBlcnJvcl8yIDogXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGVycm9yXzMgOiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBlcnJvcl80IDogXyAtPiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBlcnJvcl81IDogXyAtPiBfIC0+IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGFzc2VydF8gOiBib29sIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgYXNzZXJ0XzEgOiBib29sIHQgLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBhc3NlcnRfMiA6IGJvb2wgdCAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgYXNzZXJ0XzMgOiBib29sIHQgLT4gXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgYXNzZXJ0XzQgOiBib29sIHQgLT4gXyAtPiBfIC0+IF8gLT4gXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBhc3NlcnRfNSA6IGJvb2wgdCAtPiBfIC0+IF8gLT4gXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZGlyIDogXyAtPiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCBkaXJ4bWwgOiBEb20ubm9kZSB0IC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIHRyYWNlIDogdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZ3JvdXAgOiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGdyb3VwXzIgOiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZ3JvdXBfMyA6IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGdyb3VwXzQgOiBfIC0+IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGdyb3VwXzUgOiBfIC0+IF8gLT4gXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZ3JvdXBDb2xsYXBzZWQgOiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGdyb3VwQ29sbGFwc2VkXzIgOiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZ3JvdXBDb2xsYXBzZWRfMyA6IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGdyb3VwQ29sbGFwc2VkXzQgOiBfIC0+IF8gLT4gXyAtPiBfIC0+IHVuaXQgbWV0aFxuXG4gICAgbWV0aG9kIGdyb3VwQ29sbGFwc2VkXzUgOiBfIC0+IF8gLT4gXyAtPiBfIC0+IF8gLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgZ3JvdXBFbmQgOiB1bml0IG1ldGhcblxuICAgIG1ldGhvZCB0aW1lIDoganNfc3RyaW5nIHQgLT4gdW5pdCBtZXRoXG5cbiAgICBtZXRob2QgdGltZUVuZCA6IGpzX3N0cmluZyB0IC0+IHVuaXQgbWV0aFxuICBlbmRcblxuZXh0ZXJuYWwgZ2V0X2NvbnNvbGUgOiB1bml0IC0+IGNvbnNvbGUgdCA9IFwiY2FtbF9qc19nZXRfY29uc29sZVwiXG5cbmxldCBjb25zb2xlID0gZ2V0X2NvbnNvbGUgKClcbiIsIigqIEpzX29mX29jYW1sIGxpYnJhcnlcbiAqIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTUgU3TDqXBoYW5lIExlZ3JhbmRcbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuICogZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAqIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAqIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4gKilcbm9wZW4hIEltcG9ydFxuXG50eXBlIHBvc2l0aW9uRXJyb3JDb2RlXG5cbnR5cGUgd2F0Y2hJZFxuXG5jbGFzcyB0eXBlIGNvb3JkaW5hdGVzID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGxhdGl0dWRlIDogZmxvYXQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIGxvbmdpdHVkZSA6IGZsb2F0IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBhbHRpdHVkZSA6IGZsb2F0IEpzLm9wdCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgYWNjdXJhY3kgOiBmbG9hdCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgYWx0aXR1ZGVBY2N1cmFjeSA6IGZsb2F0IEpzLm9wdCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgaGVhZGluZyA6IGZsb2F0IEpzLm9wdCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2Qgc3BlZWQgOiBmbG9hdCBKcy5vcHQgSnMucmVhZG9ubHlfcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSBwb3NpdGlvbiA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBjb29yZHMgOiBjb29yZGluYXRlcyBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB0aW1lc3RhbXAgOiBKcy5kYXRlIEpzLnJlYWRvbmx5X3Byb3BcbiAgZW5kXG5cbmNsYXNzIHR5cGUgcG9zaXRpb25PcHRpb25zID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGVuYWJsZUhpZ2hBY2N1cmFjeSA6IGJvb2wgSnMud3JpdGVvbmx5X3Byb3BcblxuICAgIG1ldGhvZCB0aW1lb3V0IDogaW50IEpzLndyaXRlb25seV9wcm9wXG5cbiAgICBtZXRob2QgbWF4aW11bUFnZSA6IGludCBKcy53cml0ZW9ubHlfcHJvcFxuICBlbmRcblxuY2xhc3MgdHlwZSBwb3NpdGlvbkVycm9yID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIF9QRVJNSVNTSU9OX0RFTklFRF8gOiBwb3NpdGlvbkVycm9yQ29kZSBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX1BPU0lUSU9OX1VOQVZBSUxBQkxFXyA6IHBvc2l0aW9uRXJyb3JDb2RlIEpzLnJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBfVElNRU9VVCA6IHBvc2l0aW9uRXJyb3JDb2RlIEpzLnJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBjb2RlIDogcG9zaXRpb25FcnJvckNvZGUgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIG1lc3NhZ2UgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5yZWFkb25seV9wcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIGdlb2xvY2F0aW9uID1cbiAgb2JqZWN0XG4gICAgbWV0aG9kIGdldEN1cnJlbnRQb3NpdGlvbiA6XG4gICAgICAgICAocG9zaXRpb24gSnMudCAtPiB1bml0KSBKcy5jYWxsYmFja1xuICAgICAgLT4gKHBvc2l0aW9uRXJyb3IgSnMudCAtPiB1bml0KSBKcy5jYWxsYmFja1xuICAgICAgLT4gcG9zaXRpb25PcHRpb25zIEpzLnRcbiAgICAgIC0+IHVuaXQgSnMubWV0aFxuXG4gICAgbWV0aG9kIHdhdGNoUG9zaXRpb24gOlxuICAgICAgICAgKHBvc2l0aW9uIEpzLnQgLT4gdW5pdCkgSnMuY2FsbGJhY2tcbiAgICAgIC0+IChwb3NpdGlvbkVycm9yIEpzLnQgLT4gdW5pdCkgSnMuY2FsbGJhY2tcbiAgICAgIC0+IHBvc2l0aW9uT3B0aW9ucyBKcy50XG4gICAgICAtPiB3YXRjaElkIEpzLm1ldGhcblxuICAgIG1ldGhvZCBjbGVhcldhdGNoIDogd2F0Y2hJZCAtPiB1bml0IEpzLm1ldGhcbiAgZW5kXG5cbmxldCBlbXB0eV9wb3NpdGlvbl9vcHRpb25zICgpID0gSnMuVW5zYWZlLm9iaiBbfHxdXG5cbmxldCBnZW9sb2NhdGlvbiA9XG4gIGxldCB4ID0gSnMuVW5zYWZlLmdsb2JhbCMjLm5hdmlnYXRvciBpblxuICBpZiBKcy5PcHRkZWYudGVzdCB4IHRoZW4geCMjLmdlb2xvY2F0aW9uIGVsc2UgeFxuXG4oKiB1bmRlZmluZWQgKilcblxubGV0IGlzX3N1cHBvcnRlZCAoKSA9IEpzLk9wdGRlZi50ZXN0IGdlb2xvY2F0aW9uXG4iLCJjbGFzcyB0eXBlIGludGVyc2VjdGlvbk9ic2VydmVyRW50cnkgPVxuICBvYmplY3RcbiAgICBtZXRob2QgdGFyZ2V0IDogRG9tLm5vZGUgSnMudCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgYm91bmRpbmdDbGllbnRSZWN0IDogRG9tX2h0bWwuY2xpZW50UmVjdCBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCByb290Qm91bmRzIDogRG9tX2h0bWwuY2xpZW50UmVjdCBKcy50IEpzLm9wdCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgaW50ZXJzZWN0aW9uUmVjdCA6IERvbV9odG1sLmNsaWVudFJlY3QgSnMudCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgaW50ZXJzZWN0aW9uUmF0aW8gOiBmbG9hdCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgaXNJbnRlcnNlY3RpbmcgOiBib29sIEpzLnQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHRpbWUgOiBmbG9hdCBKcy5yZWFkb25seV9wcm9wXG4gIGVuZFxuXG5jbGFzcyB0eXBlIGludGVyc2VjdGlvbk9ic2VydmVyT3B0aW9ucyA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCByb290IDogRG9tLm5vZGUgSnMudCBKcy53cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHJvb3RNYXJnaW4gOiBKcy5qc19zdHJpbmcgSnMudCBKcy53cml0ZW9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHRocmVzaG9sZCA6IGZsb2F0IEpzLmpzX2FycmF5IEpzLnQgSnMud3JpdGVvbmx5X3Byb3BcbiAgZW5kXG5cbmNsYXNzIHR5cGUgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPVxuICBvYmplY3RcbiAgICBtZXRob2Qgcm9vdCA6IERvbS5ub2RlIEpzLnQgSnMub3B0IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCByb290TWFyZ2luIDogSnMuanNfc3RyaW5nIEpzLnQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIHRocmVzaG9sZHMgOiBmbG9hdCBKcy5qc19hcnJheSBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgIG1ldGhvZCBvYnNlcnZlIDogI0RvbS5ub2RlIEpzLnQgLT4gdW5pdCBKcy5tZXRoXG5cbiAgICBtZXRob2QgdW5vYnNlcnZlIDogI0RvbS5ub2RlIEpzLnQgLT4gdW5pdCBKcy5tZXRoXG5cbiAgICBtZXRob2QgZGlzY29ubmVjdCA6IHVuaXQgSnMubWV0aFxuXG4gICAgbWV0aG9kIHRha2VSZWNvcmRzIDogaW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSBKcy50IEpzLmpzX2FycmF5IEpzLm1ldGhcbiAgZW5kXG5cbmxldCBlbXB0eV9pbnRlcnNlY3Rpb25fb2JzZXJ2ZXJfb3B0aW9ucyAoKSA6IGludGVyc2VjdGlvbk9ic2VydmVyT3B0aW9ucyBKcy50ID1cbiAgSnMuVW5zYWZlLm9iaiBbfHxdXG5cbmxldCBpbnRlcnNlY3Rpb25PYnNlcnZlcl91bnNhZmUgPSBKcy5VbnNhZmUuZ2xvYmFsIyMuX0ludGVyc2VjdGlvbk9ic2VydmVyXG5cbmxldCBpc19zdXBwb3J0ZWQgKCkgPSBKcy5PcHRkZWYudGVzdCBpbnRlcnNlY3Rpb25PYnNlcnZlcl91bnNhZmVcblxubGV0IGludGVyc2VjdGlvbk9ic2VydmVyIDpcbiAgICAoICAgKCAgIGludGVyc2VjdGlvbk9ic2VydmVyRW50cnkgSnMudCBKcy5qc19hcnJheSBKcy50XG4gICAgICAgICAtPiBpbnRlcnNlY3Rpb25PYnNlcnZlciBKcy50XG4gICAgICAgICAtPiB1bml0KVxuICAgICAgICBKcy5jYWxsYmFja1xuICAgICAtPiBpbnRlcnNlY3Rpb25PYnNlcnZlck9wdGlvbnMgSnMudFxuICAgICAtPiBpbnRlcnNlY3Rpb25PYnNlcnZlciBKcy50KVxuICAgIEpzLmNvbnN0ciA9XG4gIGludGVyc2VjdGlvbk9ic2VydmVyX3Vuc2FmZVxuIiwiKCogSnNfb2Zfb2NhbWwgbGlicmFyeVxuICogaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbiAqIENvcHlyaWdodCAoQykgMjAxOCBTdMOpcGhhbmUgTGVncmFuZFxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4gKiBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICogRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbiAqKVxub3BlbiEgSW1wb3J0XG5cbm1vZHVsZSB0eXBlIFNoYXJlZCA9IHNpZ1xuICBjbGFzcyB0eXBlIG9iamVjdF9vcHRpb25zID1cbiAgICBvYmplY3RcbiAgICAgIG1ldGhvZCBsb2NhbGVNYXRjaGVyIDogSnMuanNfc3RyaW5nIEpzLnQgSnMucHJvcFxuICAgIGVuZFxuXG4gIHZhbCBvYmplY3Rfb3B0aW9ucyA6IHVuaXQgLT4gb2JqZWN0X29wdGlvbnMgSnMudFxuXG4gIGNsYXNzIHR5cGUgX29iamVjdCA9XG4gICAgb2JqZWN0XG4gICAgICBtZXRob2Qgc3VwcG9ydGVkTG9jYWxlc09mIDpcbiAgICAgICAgICAgSnMuanNfc3RyaW5nIEpzLnQgSnMuanNfYXJyYXkgSnMudFxuICAgICAgICAtPiBvYmplY3Rfb3B0aW9ucyBKcy50IEpzLm9wdGRlZlxuICAgICAgICAtPiBKcy5qc19zdHJpbmcgSnMudCBKcy5qc19hcnJheSBKcy50IEpzLm1ldGhcbiAgICBlbmRcbmVuZFxuXG5tb2R1bGUgU2hhcmVkIDogU2hhcmVkID0gc3RydWN0XG4gIGNsYXNzIHR5cGUgb2JqZWN0X29wdGlvbnMgPVxuICAgIG9iamVjdFxuICAgICAgbWV0aG9kIGxvY2FsZU1hdGNoZXIgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5wcm9wXG4gICAgZW5kXG5cbiAgbGV0IG9iamVjdF9vcHRpb25zICgpID1cbiAgICBvYmplY3QlanNcbiAgICAgIHZhbCBtdXRhYmxlIGxvY2FsZU1hdGNoZXIgPSBKcy5zdHJpbmcgXCJiZXN0IGZpdFwiXG4gICAgZW5kXG5cbiAgY2xhc3MgdHlwZSBfb2JqZWN0ID1cbiAgICBvYmplY3RcbiAgICAgIG1ldGhvZCBzdXBwb3J0ZWRMb2NhbGVzT2YgOlxuICAgICAgICAgICBKcy5qc19zdHJpbmcgSnMudCBKcy5qc19hcnJheSBKcy50XG4gICAgICAgIC0+IG9iamVjdF9vcHRpb25zIEpzLnQgSnMub3B0ZGVmXG4gICAgICAgIC0+IEpzLmpzX3N0cmluZyBKcy50IEpzLmpzX2FycmF5IEpzLnQgSnMubWV0aFxuICAgIGVuZFxuZW5kXG5cbm1vZHVsZSBDb2xsYXRvciA9IHN0cnVjdFxuICBpbmNsdWRlIFNoYXJlZFxuXG4gIGNsYXNzIHR5cGUgcmVzb2x2ZWRfb3B0aW9ucyA9XG4gICAgb2JqZWN0XG4gICAgICBtZXRob2QgbG9jYWxlIDogSnMuanNfc3RyaW5nIEpzLnQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgICBtZXRob2QgdXNhZ2UgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICAgIG1ldGhvZCBzZW5zaXRpdml0eSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgICAgbWV0aG9kIGlnbm9yZVB1bmN0dWF0aW9uIDogYm9vbCBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgICAgbWV0aG9kIGNvbGxhdGlvbiA6IEpzLmpzX3N0cmluZyBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgICAgbWV0aG9kIG51bWVyaWMgOiBib29sIEpzLnQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgICBtZXRob2QgY2FzZUZpcnN0IDogSnMuanNfc3RyaW5nIEpzLnQgSnMucmVhZG9ubHlfcHJvcFxuICAgIGVuZFxuXG4gIGNsYXNzIHR5cGUgb3B0aW9ucyA9XG4gICAgb2JqZWN0XG4gICAgICBtZXRob2QgbG9jYWxlTWF0Y2hlciA6IEpzLmpzX3N0cmluZyBKcy50IEpzLnByb3BcblxuICAgICAgbWV0aG9kIHVzYWdlIDogSnMuanNfc3RyaW5nIEpzLnQgSnMucHJvcFxuXG4gICAgICBtZXRob2Qgc2Vuc2l0aXZpdHkgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5wcm9wXG5cbiAgICAgIG1ldGhvZCBpZ25vcmVQdW5jdHVhdGlvbiA6IGJvb2wgSnMudCBKcy5wcm9wXG5cbiAgICAgIG1ldGhvZCBudW1lcmljIDogYm9vbCBKcy50IEpzLnByb3BcblxuICAgICAgbWV0aG9kIGNhc2VGaXJzdCA6IEpzLmpzX3N0cmluZyBKcy50IEpzLnByb3BcbiAgICBlbmRcblxuICBsZXQgb3B0aW9ucyAoKSA9XG4gICAgb2JqZWN0JWpzXG4gICAgICB2YWwgbXV0YWJsZSBsb2NhbGVNYXRjaGVyID0gSnMuc3RyaW5nIFwiYmVzdCBmaXRcIlxuXG4gICAgICB2YWwgbXV0YWJsZSB1c2FnZSA9IEpzLnN0cmluZyBcInNvcnRcIlxuXG4gICAgICB2YWwgbXV0YWJsZSBzZW5zaXRpdml0eSA9IEpzLnN0cmluZyBcInZhcmlhbnRcIlxuXG4gICAgICB2YWwgbXV0YWJsZSBpZ25vcmVQdW5jdHVhdGlvbiA9IEpzLl9mYWxzZVxuXG4gICAgICB2YWwgbXV0YWJsZSBudW1lcmljID0gSnMuX2ZhbHNlXG5cbiAgICAgIHZhbCBtdXRhYmxlIGNhc2VGaXJzdCA9IEpzLnN0cmluZyBcImZhbHNlXCJcbiAgICBlbmRcblxuICBjbGFzcyB0eXBlIHQgPVxuICAgIG9iamVjdFxuICAgICAgbWV0aG9kIGNvbXBhcmUgOiAoSnMuanNfc3RyaW5nIEpzLnQgLT4gSnMuanNfc3RyaW5nIEpzLnQgLT4gaW50KSBKcy5yZWFkb25seV9wcm9wXG5cbiAgICAgIG1ldGhvZCByZXNvbHZlZE9wdGlvbnMgOiB1bml0IC0+IHJlc29sdmVkX29wdGlvbnMgSnMudCBKcy5tZXRoXG4gICAgZW5kXG5lbmRcblxubW9kdWxlIERhdGVUaW1lRm9ybWF0ID0gc3RydWN0XG4gIGluY2x1ZGUgU2hhcmVkXG5cbiAgY2xhc3MgdHlwZSByZXNvbHZlZF9vcHRpb25zID1cbiAgICBvYmplY3RcbiAgICAgIG1ldGhvZCBsb2NhbGUgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICAgIG1ldGhvZCBjYWxlbmRhciA6IEpzLmpzX3N0cmluZyBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgICAgbWV0aG9kIG51bWJlcmluZ1N5c3RlbSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgICAgbWV0aG9kIHRpbWVab25lIDogSnMuanNfc3RyaW5nIEpzLnQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgICBtZXRob2QgaG91cjEyIDogYm9vbCBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgICAgbWV0aG9kIHdlZWtkYXkgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5vcHRkZWZfcHJvcFxuXG4gICAgICBtZXRob2QgZXJhIDogSnMuanNfc3RyaW5nIEpzLnQgSnMub3B0ZGVmX3Byb3BcblxuICAgICAgbWV0aG9kIHllYXIgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5vcHRkZWZfcHJvcFxuXG4gICAgICBtZXRob2QgbW9udGggOiBKcy5qc19zdHJpbmcgSnMudCBKcy5vcHRkZWZfcHJvcFxuXG4gICAgICBtZXRob2QgZGF5IDogSnMuanNfc3RyaW5nIEpzLnQgSnMub3B0ZGVmX3Byb3BcblxuICAgICAgbWV0aG9kIGhvdXIgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5vcHRkZWZfcHJvcFxuXG4gICAgICBtZXRob2QgbWludXRlIDogSnMuanNfc3RyaW5nIEpzLnQgSnMub3B0ZGVmX3Byb3BcblxuICAgICAgbWV0aG9kIHNlY29uZCA6IEpzLmpzX3N0cmluZyBKcy50IEpzLm9wdGRlZl9wcm9wXG5cbiAgICAgIG1ldGhvZCB0aW1lWm9uZU5hbWUgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5vcHRkZWZfcHJvcFxuICAgIGVuZFxuXG4gIGNsYXNzIHR5cGUgb3B0aW9ucyA9XG4gICAgb2JqZWN0XG4gICAgICBtZXRob2QgZGF0ZVN0eWxlIDogSnMuanNfc3RyaW5nIEpzLnQgSnMub3B0ZGVmIEpzLnByb3BcblxuICAgICAgbWV0aG9kIHRpbWVTdHlsZSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLm9wdGRlZiBKcy5wcm9wXG5cbiAgICAgIG1ldGhvZCBjYWxlbmRhciA6IEpzLmpzX3N0cmluZyBKcy50IEpzLm9wdGRlZiBKcy5wcm9wXG5cbiAgICAgIG1ldGhvZCBkYXlQZXJpb2QgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5vcHRkZWYgSnMucHJvcFxuXG4gICAgICBtZXRob2QgbnVtYmVyaW5nU3lzdGVtIDogSnMuanNfc3RyaW5nIEpzLnQgSnMub3B0ZGVmIEpzLnByb3BcblxuICAgICAgbWV0aG9kIGxvY2FsZU1hdGNoZXIgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5wcm9wXG5cbiAgICAgIG1ldGhvZCB0aW1lWm9uZSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLm9wdGRlZiBKcy5wcm9wXG5cbiAgICAgIG1ldGhvZCBob3VyMTIgOiBib29sIEpzLnQgSnMub3B0ZGVmIEpzLnByb3BcblxuICAgICAgbWV0aG9kIGhvdXJDeWNsZSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLm9wdGRlZiBKcy5wcm9wXG5cbiAgICAgIG1ldGhvZCBmb3JtYXRNYXRjaGVyIDogSnMuanNfc3RyaW5nIEpzLnQgSnMucHJvcFxuXG4gICAgICBtZXRob2Qgd2Vla2RheSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLm9wdGRlZiBKcy5wcm9wXG5cbiAgICAgIG1ldGhvZCBlcmEgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5vcHRkZWYgSnMucHJvcFxuXG4gICAgICBtZXRob2QgeWVhciA6IEpzLmpzX3N0cmluZyBKcy50IEpzLm9wdGRlZiBKcy5wcm9wXG5cbiAgICAgIG1ldGhvZCBtb250aCA6IEpzLmpzX3N0cmluZyBKcy50IEpzLm9wdGRlZiBKcy5wcm9wXG5cbiAgICAgIG1ldGhvZCBkYXkgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5vcHRkZWYgSnMucHJvcFxuXG4gICAgICBtZXRob2QgaG91ciA6IEpzLmpzX3N0cmluZyBKcy50IEpzLm9wdGRlZiBKcy5wcm9wXG5cbiAgICAgIG1ldGhvZCBtaW51dGUgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5vcHRkZWYgSnMucHJvcFxuXG4gICAgICBtZXRob2Qgc2Vjb25kIDogSnMuanNfc3RyaW5nIEpzLnQgSnMub3B0ZGVmIEpzLnByb3BcblxuICAgICAgbWV0aG9kIGZyYWN0aW9uYWxTZWNvbmREaWdpdHMgOiBpbnQgSnMub3B0ZGVmIEpzLnByb3BcblxuICAgICAgbWV0aG9kIHRpbWVab25lTmFtZSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLm9wdGRlZiBKcy5wcm9wXG4gICAgZW5kXG5cbiAgbGV0IG9wdGlvbnMgKCkgOiBvcHRpb25zIEpzLnQgPVxuICAgIG9iamVjdCVqc1xuICAgICAgdmFsIG11dGFibGUgZGF0ZVN0eWxlID0gSnMudW5kZWZpbmVkXG5cbiAgICAgIHZhbCBtdXRhYmxlIHRpbWVTdHlsZSA9IEpzLnVuZGVmaW5lZFxuXG4gICAgICB2YWwgbXV0YWJsZSBjYWxlbmRhciA9IEpzLnVuZGVmaW5lZFxuXG4gICAgICB2YWwgbXV0YWJsZSBkYXlQZXJpb2QgPSBKcy51bmRlZmluZWRcblxuICAgICAgdmFsIG11dGFibGUgbnVtYmVyaW5nU3lzdGVtID0gSnMudW5kZWZpbmVkXG5cbiAgICAgIHZhbCBtdXRhYmxlIGxvY2FsZU1hdGNoZXIgPSBKcy5zdHJpbmcgXCJiZXN0IGZpdFwiXG5cbiAgICAgIHZhbCBtdXRhYmxlIHRpbWVab25lID0gSnMudW5kZWZpbmVkXG5cbiAgICAgIHZhbCBtdXRhYmxlIGhvdXIxMiA9IEpzLnVuZGVmaW5lZFxuXG4gICAgICB2YWwgbXV0YWJsZSBob3VyQ3ljbGUgPSBKcy51bmRlZmluZWRcblxuICAgICAgdmFsIG11dGFibGUgZm9ybWF0TWF0Y2hlciA9IEpzLnN0cmluZyBcImJlc3QgZml0XCJcblxuICAgICAgdmFsIG11dGFibGUgd2Vla2RheSA9IEpzLnVuZGVmaW5lZFxuXG4gICAgICB2YWwgbXV0YWJsZSBlcmEgPSBKcy51bmRlZmluZWRcblxuICAgICAgdmFsIG11dGFibGUgeWVhciA9IEpzLnVuZGVmaW5lZFxuXG4gICAgICB2YWwgbXV0YWJsZSBtb250aCA9IEpzLnVuZGVmaW5lZFxuXG4gICAgICB2YWwgbXV0YWJsZSBkYXkgPSBKcy51bmRlZmluZWRcblxuICAgICAgdmFsIG11dGFibGUgaG91ciA9IEpzLnVuZGVmaW5lZFxuXG4gICAgICB2YWwgbXV0YWJsZSBtaW51dGUgPSBKcy51bmRlZmluZWRcblxuICAgICAgdmFsIG11dGFibGUgc2Vjb25kID0gSnMudW5kZWZpbmVkXG5cbiAgICAgIHZhbCBtdXRhYmxlIGZyYWN0aW9uYWxTZWNvbmREaWdpdHMgPSBKcy51bmRlZmluZWRcblxuICAgICAgdmFsIG11dGFibGUgdGltZVpvbmVOYW1lID0gSnMudW5kZWZpbmVkXG4gICAgZW5kXG5cbiAgY2xhc3MgdHlwZSBmb3JtYXRfcGFydCA9XG4gICAgb2JqZWN0XG4gICAgICBtZXRob2QgX3R5cGUgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICAgIG1ldGhvZCBfdmFsdWUgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5yZWFkb25seV9wcm9wXG4gICAgZW5kXG5cbiAgY2xhc3MgdHlwZSB0ID1cbiAgICBvYmplY3RcbiAgICAgIG1ldGhvZCBmb3JtYXQgOiAoSnMuZGF0ZSBKcy50IC0+IEpzLmpzX3N0cmluZyBKcy50KSBKcy5yZWFkb25seV9wcm9wXG5cbiAgICAgIG1ldGhvZCBmb3JtYXRUb1BhcnRzIDpcbiAgICAgICAgSnMuZGF0ZSBKcy50IEpzLm9wdGRlZiAtPiBmb3JtYXRfcGFydCBKcy50IEpzLmpzX2FycmF5IEpzLnQgSnMubWV0aFxuXG4gICAgICBtZXRob2QgcmVzb2x2ZWRPcHRpb25zIDogdW5pdCAtPiByZXNvbHZlZF9vcHRpb25zIEpzLnQgSnMubWV0aFxuICAgIGVuZFxuZW5kXG5cbm1vZHVsZSBOdW1iZXJGb3JtYXQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTaGFyZWRcblxuICBjbGFzcyB0eXBlIHJlc29sdmVkX29wdGlvbnMgPVxuICAgIG9iamVjdFxuICAgICAgbWV0aG9kIGxvY2FsZSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgICAgbWV0aG9kIG51bWJlcmluZ1N5c3RlbSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgICAgbWV0aG9kIHN0eWxlIDogSnMuanNfc3RyaW5nIEpzLnQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgICBtZXRob2QgY3VycmVuY3kgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5vcHRkZWZfcHJvcFxuXG4gICAgICBtZXRob2QgY3VycmVuY3lEaXNwbGF5IDogSnMuanNfc3RyaW5nIEpzLnQgSnMub3B0ZGVmX3Byb3BcblxuICAgICAgbWV0aG9kIHVzZUdyb3VwaW5nIDogYm9vbCBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgICAgbWV0aG9kIG1pbmltdW1JbnRlZ2VyRGlnaXRzIDogaW50IEpzLm9wdGRlZl9wcm9wXG5cbiAgICAgIG1ldGhvZCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgOiBpbnQgSnMub3B0ZGVmX3Byb3BcblxuICAgICAgbWV0aG9kIG1heGltdW1GcmFjdGlvbkRpZ2l0cyA6IGludCBKcy5vcHRkZWZfcHJvcFxuXG4gICAgICBtZXRob2QgbWluaW11bVNpZ25pZmljYW50RGlnaXRzIDogaW50IEpzLm9wdGRlZl9wcm9wXG5cbiAgICAgIG1ldGhvZCBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgOiBpbnQgSnMub3B0ZGVmX3Byb3BcbiAgICBlbmRcblxuICBjbGFzcyB0eXBlIG9wdGlvbnMgPVxuICAgIG9iamVjdFxuICAgICAgbWV0aG9kIGNvbXBhY3REaXNwbGF5IDogSnMuanNfc3RyaW5nIEpzLnQgSnMub3B0ZGVmIEpzLnByb3BcblxuICAgICAgbWV0aG9kIGN1cnJlbmN5IDogSnMuanNfc3RyaW5nIEpzLnQgSnMub3B0ZGVmIEpzLnByb3BcblxuICAgICAgbWV0aG9kIGN1cnJlbmN5RGlzcGxheSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLm9wdGRlZiBKcy5wcm9wXG5cbiAgICAgIG1ldGhvZCBjdXJyZW5jeVNpZ24gOiBKcy5qc19zdHJpbmcgSnMudCBKcy5vcHRkZWYgSnMucHJvcFxuXG4gICAgICBtZXRob2QgbG9jYWxlTWF0Y2hlciA6IEpzLmpzX3N0cmluZyBKcy50IEpzLnByb3BcblxuICAgICAgbWV0aG9kIG5vdGF0aW9uIDogSnMuanNfc3RyaW5nIEpzLnQgSnMub3B0ZGVmIEpzLnByb3BcblxuICAgICAgbWV0aG9kIG51bWJlcmluZ1N5c3RlbSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLm9wdGRlZiBKcy5wcm9wXG5cbiAgICAgIG1ldGhvZCBzaWduRGlzcGxheSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLm9wdGRlZiBKcy5wcm9wXG5cbiAgICAgIG1ldGhvZCBzdHlsZSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLnByb3BcblxuICAgICAgbWV0aG9kIHVuaXQgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5vcHRkZWYgSnMucHJvcFxuXG4gICAgICBtZXRob2QgdW5pdERpc3BsYXkgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5vcHRkZWYgSnMucHJvcFxuXG4gICAgICBtZXRob2QgdXNlR3JvdXBpbmcgOiBib29sIEpzLnQgSnMucHJvcFxuXG4gICAgICBtZXRob2Qgcm91bmRpbmdNb2RlIDogSnMuanNfc3RyaW5nIEpzLnQgSnMub3B0ZGVmIEpzLnByb3BcblxuICAgICAgbWV0aG9kIHJvdW5kaW5nUHJpb3JpdHkgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5vcHRkZWYgSnMucHJvcFxuXG4gICAgICBtZXRob2Qgcm91bmRpbmdJbmNyZW1lbnQgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5vcHRkZWYgSnMucHJvcFxuXG4gICAgICBtZXRob2QgdHJhaWxpbmdaZXJvRGlzcGxheSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLm9wdGRlZiBKcy5wcm9wXG5cbiAgICAgIG1ldGhvZCBtaW5pbXVtSW50ZWdlckRpZ2l0cyA6IGludCBKcy5vcHRkZWYgSnMucHJvcFxuXG4gICAgICBtZXRob2QgbWluaW11bUZyYWN0aW9uRGlnaXRzIDogaW50IEpzLm9wdGRlZiBKcy5wcm9wXG5cbiAgICAgIG1ldGhvZCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgOiBpbnQgSnMub3B0ZGVmIEpzLnByb3BcblxuICAgICAgbWV0aG9kIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyA6IGludCBKcy5vcHRkZWYgSnMucHJvcFxuXG4gICAgICBtZXRob2QgbWF4aW11bVNpZ25pZmljYW50RGlnaXRzIDogaW50IEpzLm9wdGRlZiBKcy5wcm9wXG4gICAgZW5kXG5cbiAgbGV0IG9wdGlvbnMgKCkgOiBvcHRpb25zIEpzLnQgPVxuICAgIG9iamVjdCVqc1xuICAgICAgdmFsIG11dGFibGUgY29tcGFjdERpc3BsYXkgPSBKcy51bmRlZmluZWRcblxuICAgICAgdmFsIG11dGFibGUgY3VycmVuY3kgPSBKcy51bmRlZmluZWRcblxuICAgICAgdmFsIG11dGFibGUgY3VycmVuY3lEaXNwbGF5ID0gSnMudW5kZWZpbmVkXG5cbiAgICAgIHZhbCBtdXRhYmxlIGN1cnJlbmN5U2lnbiA9IEpzLnVuZGVmaW5lZFxuXG4gICAgICB2YWwgbXV0YWJsZSBsb2NhbGVNYXRjaGVyID0gSnMuc3RyaW5nIFwiYmVzdCBmaXRcIlxuXG4gICAgICB2YWwgbXV0YWJsZSBub3RhdGlvbiA9IEpzLnVuZGVmaW5lZFxuXG4gICAgICB2YWwgbXV0YWJsZSBudW1iZXJpbmdTeXN0ZW0gPSBKcy51bmRlZmluZWRcblxuICAgICAgdmFsIG11dGFibGUgc2lnbkRpc3BsYXkgPSBKcy51bmRlZmluZWRcblxuICAgICAgdmFsIG11dGFibGUgc3R5bGUgPSBKcy5zdHJpbmcgXCJkZWNpbWFsXCJcblxuICAgICAgdmFsIG11dGFibGUgdW5pdCA9IEpzLnVuZGVmaW5lZFxuXG4gICAgICB2YWwgbXV0YWJsZSB1bml0RGlzcGxheSA9IEpzLnVuZGVmaW5lZFxuXG4gICAgICB2YWwgbXV0YWJsZSB1c2VHcm91cGluZyA9IEpzLl90cnVlXG5cbiAgICAgIHZhbCBtdXRhYmxlIHJvdW5kaW5nTW9kZSA9IEpzLnVuZGVmaW5lZFxuXG4gICAgICB2YWwgbXV0YWJsZSByb3VuZGluZ1ByaW9yaXR5ID0gSnMudW5kZWZpbmVkXG5cbiAgICAgIHZhbCBtdXRhYmxlIHJvdW5kaW5nSW5jcmVtZW50ID0gSnMudW5kZWZpbmVkXG5cbiAgICAgIHZhbCBtdXRhYmxlIHRyYWlsaW5nWmVyb0Rpc3BsYXkgPSBKcy51bmRlZmluZWRcblxuICAgICAgdmFsIG11dGFibGUgbWluaW11bUludGVnZXJEaWdpdHMgPSBKcy51bmRlZmluZWRcblxuICAgICAgdmFsIG11dGFibGUgbWluaW11bUZyYWN0aW9uRGlnaXRzID0gSnMudW5kZWZpbmVkXG5cbiAgICAgIHZhbCBtdXRhYmxlIG1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IEpzLnVuZGVmaW5lZFxuXG4gICAgICB2YWwgbXV0YWJsZSBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgPSBKcy51bmRlZmluZWRcblxuICAgICAgdmFsIG11dGFibGUgbWF4aW11bVNpZ25pZmljYW50RGlnaXRzID0gSnMudW5kZWZpbmVkXG4gICAgZW5kXG5cbiAgY2xhc3MgdHlwZSBmb3JtYXRfcGFydCA9XG4gICAgb2JqZWN0XG4gICAgICBtZXRob2QgX3R5cGUgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICAgIG1ldGhvZCBfdmFsdWUgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5yZWFkb25seV9wcm9wXG4gICAgZW5kXG5cbiAgY2xhc3MgdHlwZSB0ID1cbiAgICBvYmplY3RcbiAgICAgIG1ldGhvZCBmb3JtYXQgOiAoSnMubnVtYmVyIEpzLnQgLT4gSnMuanNfc3RyaW5nIEpzLnQpIEpzLnJlYWRvbmx5X3Byb3BcblxuICAgICAgbWV0aG9kIGZvcm1hdFRvUGFydHMgOlxuICAgICAgICBKcy5udW1iZXIgSnMudCBKcy5vcHRkZWYgLT4gZm9ybWF0X3BhcnQgSnMudCBKcy5qc19hcnJheSBKcy50IEpzLm1ldGhcblxuICAgICAgbWV0aG9kIHJlc29sdmVkT3B0aW9ucyA6IHVuaXQgLT4gcmVzb2x2ZWRfb3B0aW9ucyBKcy50IEpzLm1ldGhcbiAgICBlbmRcbmVuZFxuXG5tb2R1bGUgUGx1cmFsUnVsZXMgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTaGFyZWRcblxuICBjbGFzcyB0eXBlIHJlc29sdmVkX29wdGlvbnMgPVxuICAgIG9iamVjdFxuICAgICAgbWV0aG9kIGxvY2FsZSA6IEpzLmpzX3N0cmluZyBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgICAgbWV0aG9kIHBsdXJhbENhdGVnb3JpZXMgOiBKcy5qc19zdHJpbmcgSnMudCBKcy5qc19hcnJheSBKcy50IEpzLnJlYWRvbmx5X3Byb3BcblxuICAgICAgbWV0aG9kIF90eXBlIDogSnMuanNfc3RyaW5nIEpzLnQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgICBtZXRob2QgbWluaW11bUludGVnZXJEaWdpdHMgOiBpbnQgSnMub3B0ZGVmX3Byb3BcblxuICAgICAgbWV0aG9kIG1pbmltdW1GcmFjdGlvbkRpZ2l0cyA6IGludCBKcy5vcHRkZWZfcHJvcFxuXG4gICAgICBtZXRob2QgbWF4aW11bUZyYWN0aW9uRGlnaXRzIDogaW50IEpzLm9wdGRlZl9wcm9wXG5cbiAgICAgIG1ldGhvZCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgOiBpbnQgSnMub3B0ZGVmX3Byb3BcblxuICAgICAgbWV0aG9kIG1heGltdW1TaWduaWZpY2FudERpZ2l0cyA6IGludCBKcy5vcHRkZWZfcHJvcFxuICAgIGVuZFxuXG4gIGNsYXNzIHR5cGUgb3B0aW9ucyA9XG4gICAgb2JqZWN0XG4gICAgICBtZXRob2QgbG9jYWxlTWF0Y2hlciA6IEpzLmpzX3N0cmluZyBKcy50IEpzLnByb3BcblxuICAgICAgbWV0aG9kIF90eXBlIDogSnMuanNfc3RyaW5nIEpzLnQgSnMucHJvcFxuICAgIGVuZFxuXG4gIGxldCBvcHRpb25zICgpIDogb3B0aW9ucyBKcy50ID1cbiAgICBvYmplY3QlanNcbiAgICAgIHZhbCBtdXRhYmxlIGxvY2FsZU1hdGNoZXIgPSBKcy5zdHJpbmcgXCJiZXN0IGZpdFwiXG5cbiAgICAgIHZhbCBtdXRhYmxlIF90eXBlID0gSnMuc3RyaW5nIFwiY2FyZGluYWxcIlxuICAgIGVuZFxuXG4gIGNsYXNzIHR5cGUgdCA9XG4gICAgb2JqZWN0XG4gICAgICBtZXRob2Qgc2VsZWN0IDogSnMubnVtYmVyIEpzLnQgLT4gSnMuanNfc3RyaW5nIEpzLnQgSnMubWV0aFxuXG4gICAgICBtZXRob2QgcmVzb2x2ZWRPcHRpb25zIDogdW5pdCAtPiByZXNvbHZlZF9vcHRpb25zIEpzLnQgSnMubWV0aFxuICAgIGVuZFxuZW5kXG5cbmNsYXNzIHR5cGUgaW50bCA9XG4gIG9iamVjdFxuICAgIG1ldGhvZCBfQ29sbGF0b3IgOiBDb2xsYXRvci5fb2JqZWN0IEpzLnQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9EYXRlVGltZUZvcm1hdCA6IERhdGVUaW1lRm9ybWF0Ll9vYmplY3QgSnMudCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgX051bWJlckZvcm1hdCA6IE51bWJlckZvcm1hdC5fb2JqZWN0IEpzLnQgSnMucmVhZG9ubHlfcHJvcFxuXG4gICAgbWV0aG9kIF9QbHVyYWxSdWxlcyA6IFBsdXJhbFJ1bGVzLl9vYmplY3QgSnMudCBKcy5yZWFkb25seV9wcm9wXG5cbiAgICBtZXRob2QgZ2V0Q2Fub25pY2FsTG9jYWxlcyA6XG4gICAgICBKcy5qc19zdHJpbmcgSnMudCBKcy5qc19hcnJheSBKcy50IC0+IEpzLmpzX3N0cmluZyBKcy50IEpzLmpzX2FycmF5IEpzLnQgSnMubWV0aFxuICBlbmRcblxubGV0IGludGwgPSBKcy5VbnNhZmUuZ2xvYmFsIyMuX0ludGxcblxubGV0IGNvbGxhdG9yX2NvbnN0ciA9IEpzLlVuc2FmZS5nbG9iYWwjIy5fSW50bCMjLl9Db2xsYXRvclxuXG5sZXQgZGF0ZVRpbWVGb3JtYXRfY29uc3RyID0gSnMuVW5zYWZlLmdsb2JhbCMjLl9JbnRsIyMuX0RhdGVUaW1lRm9ybWF0XG5cbmxldCBudW1iZXJGb3JtYXRfY29uc3RyID0gSnMuVW5zYWZlLmdsb2JhbCMjLl9JbnRsIyMuX051bWJlckZvcm1hdFxuXG5sZXQgcGx1cmFsUnVsZXNfY29uc3RyID0gSnMuVW5zYWZlLmdsb2JhbCMjLl9JbnRsIyMuX1BsdXJhbFJ1bGVzXG5cbmxldCBpc19zdXBwb3J0ZWQgKCkgPSBKcy5PcHRkZWYudGVzdCBpbnRsXG4iLCJvcGVuIEFsZ1xuXG5sZXQgc3ltcyA9IHJlZiAoW10gOiBUZXJtLk9wLnQgbGlzdClcblxuIiwiJXtcbm9wZW4gQWxnXG5vcGVuIFRlcm1cblxubGV0IHZhcnMgPSByZWYgW11cblxubGV0IHZhciB4ID1cbiAgaWYgbm90IChMaXN0Lm1lbV9hc3NvYyB4ICF2YXJzKSB0aGVuIHZhcnMgOj0gKHgsIFRlcm0udmFyICgpKSA6OiAhdmFycztcbiAgTGlzdC5hc3NvYyB4ICF2YXJzXG5cbmxldCBpc19zeW0gZiA9IExpc3QuZXhpc3RzIChmdW4gZyAtPiBPcC5uYW1lIGcgPSBmKSAhUGFyc2VyUmVmcy5zeW1zXG5sZXQgc3ltIGYgPSBMaXN0LmZpbmQgKGZ1biBnIC0+IE9wLm5hbWUgZyA9IGYpICFQYXJzZXJSZWZzLnN5bXNcblxubGV0IGFwcCBmIGFyZ3MgPVxuICBsZXQgZiA9IHN5bSBmIGluXG4gIGlmIExpc3QubGVuZ3RoIGFyZ3MgPD4gT3AuYXJpdHkgZiB0aGVuIGZhaWx3aXRoIChcImFyaXR5IG1pc21hdGNoIGZvciBcIiBeIE9wLm5hbWUgZik7XG4gIGFwcCBmIGFyZ3NcbiV9XG5cbiV0b2tlbiA8c3RyaW5nPiBJREVOVFxuJXRva2VuIExQQVIgUlBBUiBDT01NQSBFUVxuJXRva2VuIEVPRlxuXG4lc3RhcnQgbWFpblxuJXR5cGUgPChBbGcuVGVybS50ICogQWxnLlRlcm0udCkgbGlzdD4gbWFpblxuJSVcblxubWFpbjpcbiAgfCBydWxlcyBFT0YgeyAkMSB9XG5cbnJ1bGVzOlxuICB8IHsgW10gfVxuICB8IHJ1bGUgcnVsZXMgeyAkMSA6OiAkMiB9XG5cbnJ1bGU6XG4gIHwgdGVybSBFUSB0ZXJtIHsgJDEsICQzIH1cblxudGVybTpcbiAgfCBJREVOVCBMUEFSIHRlcm1zIFJQQVIgeyBhcHAgJDEgJDMgfVxuICB8IElERU5UIHsgaWYgaXNfc3ltICQxIHRoZW4gYXBwICQxIFtdIGVsc2UgdmFyICQxIH1cbjtcblxudGVybXM6XG4gIHwgdGVybSBDT01NQSB0ZXJtcyB7ICQxOjokMyB9XG4gIHwgdGVybSB7IFskMV0gfVxuICB8IHsgW10gfVxuIiwidHlwZSB0b2tlbiA9XG4gIHwgSURFTlQgb2YgKHN0cmluZylcbiAgfCBMUEFSXG4gIHwgUlBBUlxuICB8IENPTU1BXG4gIHwgRVFcbiAgfCBFT0Zcblxub3BlbiBQYXJzaW5nOztcbmxldCBfID0gcGFyc2VfZXJyb3I7O1xuIyAyIFwidG9vbHMva2IvcGFyc2VyLm1seVwiXG5vcGVuIEFsZ1xub3BlbiBUZXJtXG5cbmxldCB2YXJzID0gcmVmIFtdXG5cbmxldCB2YXIgeCA9XG4gIGlmIG5vdCAoTGlzdC5tZW1fYXNzb2MgeCAhdmFycykgdGhlbiB2YXJzIDo9ICh4LCBUZXJtLnZhciAoKSkgOjogIXZhcnM7XG4gIExpc3QuYXNzb2MgeCAhdmFyc1xuXG5sZXQgaXNfc3ltIGYgPSBMaXN0LmV4aXN0cyAoZnVuIGcgLT4gT3AubmFtZSBnID0gZikgIVBhcnNlclJlZnMuc3ltc1xubGV0IHN5bSBmID0gTGlzdC5maW5kIChmdW4gZyAtPiBPcC5uYW1lIGcgPSBmKSAhUGFyc2VyUmVmcy5zeW1zXG5cbmxldCBhcHAgZiBhcmdzID1cbiAgbGV0IGYgPSBzeW0gZiBpblxuICBpZiBMaXN0Lmxlbmd0aCBhcmdzIDw+IE9wLmFyaXR5IGYgdGhlbiBmYWlsd2l0aCAoXCJhcml0eSBtaXNtYXRjaCBmb3IgXCIgXiBPcC5uYW1lIGYpO1xuICBhcHAgZiBhcmdzXG4jIDI5IFwidG9vbHMva2IvcGFyc2VyLm1sXCJcbmxldCB5eXRyYW5zbF9jb25zdCA9IFt8XG4gIDI1OCAoKiBMUEFSICopO1xuICAyNTkgKCogUlBBUiAqKTtcbiAgMjYwICgqIENPTU1BICopO1xuICAyNjEgKCogRVEgKik7XG4gICAgMCAoKiBFT0YgKik7XG4gICAgMHxdXG5cbmxldCB5eXRyYW5zbF9ibG9jayA9IFt8XG4gIDI1NyAoKiBJREVOVCAqKTtcbiAgICAwfF1cblxubGV0IHl5bGhzID0gXCJcXDI1NVxcMjU1XFxcblxcMDAxXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAzXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcblxcMDA1XFwwMDBcXDAwMFxcMDAwXCJcblxubGV0IHl5bGVuID0gXCJcXDAwMlxcMDAwXFxcblxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAzXFwwMDBcXDAwNFxcMDAwXFwwMDFcXDAwMFxcMDAzXFwwMDBcXDAwMVxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMlxcMDAwXCJcblxubGV0IHl5ZGVmcmVkID0gXCJcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDEwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAxXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFxcblxcMDA3XFwwMDBcIlxuXG5sZXQgeXlkZ290byA9IFwiXFwwMDJcXDAwMFxcXG5cXDAwNFxcMDAwXFwwMDVcXDAwMFxcMDA2XFwwMDBcXDAwN1xcMDAwXFwwMTNcXDAwMFwiXG5cbmxldCB5eXNpbmRleCA9IFwiXFwwMDNcXDAwMFxcXG5cXDAwMVxcMjU1XFwwMDBcXDAwMFxcMDAzXFwyNTVcXDAwMFxcMDAwXFwwMDZcXDAwMFxcMDAxXFwyNTVcXDAwNFxcMjU1XFwwMDFcXDI1NVxcXG5cXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwyNTVcXDAwNlxcMjU1XFwwMDVcXDI1NVxcMDAwXFwwMDBcXDAwMVxcMjU1XFwwMDBcXDAwMFxcXG5cXDAwMFxcMDAwXCJcblxubGV0IHl5cmluZGV4ID0gXCJcXDAwMFxcMDAwXFxcblxcMDExXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTFcXDAwMFxcMDAwXFwwMDBcXDAwOVxcMjU1XFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDEwXFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA5XFwyNTVcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcIlxuXG5sZXQgeXlnaW5kZXggPSBcIlxcMDAwXFwwMDBcXFxuXFwwMDBcXDAwMFxcMDA4XFwwMDBcXDAwMFxcMDAwXFwyNDhcXDI1NVxcMDAyXFwwMDBcIlxuXG5sZXQgeXl0YWJsZXNpemUgPSAyNjJcbmxldCB5eXRhYmxlID0gXCJcXDAxMlxcMDAwXFxcblxcMDA2XFwwMDBcXDAwM1xcMDAwXFwwMTRcXDAwMFxcMDAxXFwwMDBcXDAwOFxcMDAwXFwwMDlcXDAwMFxcMDEyXFwwMDBcXDAxNlxcMDAwXFxcblxcMDExXFwwMDBcXDAxNVxcMDAwXFwwMDJcXDAwMFxcMDA5XFwwMDBcXDAwOFxcMDAwXFwwMTBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDE3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwNlxcMDAwXFwwMDBcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFwiXG5cbmxldCB5eWNoZWNrID0gXCJcXDAwOFxcMDAwXFxcblxcMDAwXFwwMDBcXDAwMVxcMDAxXFwwMTFcXDAwMFxcMDAxXFwwMDBcXDAwMlxcMDAxXFwwMDBcXDAwMFxcMDE1XFwwMDBcXDAwM1xcMDAxXFxcblxcMDA1XFwwMDFcXDAwNFxcMDAxXFwwMDBcXDAwMFxcMDAzXFwwMDFcXDAwM1xcMDAxXFwwMDZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMDE1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcblxcMjU1XFwyNTVcXDAwMVxcMDAxXFwyNTVcXDI1NVxcMDAzXFwwMDFcXDAwNFxcMDAxXFwwMDVcXDAwMVwiXG5cbmxldCB5eW5hbWVzX2NvbnN0ID0gXCJcXFxuICBMUEFSXFwwMDBcXFxuICBSUEFSXFwwMDBcXFxuICBDT01NQVxcMDAwXFxcbiAgRVFcXDAwMFxcXG4gIEVPRlxcMDAwXFxcbiAgXCJcblxubGV0IHl5bmFtZXNfYmxvY2sgPSBcIlxcXG4gIElERU5UXFwwMDBcXFxuICBcIlxuXG5sZXQgeXlhY3QgPSBbfFxuICAoZnVuIF8gLT4gZmFpbHdpdGggXCJwYXJzZXJcIilcbjsgKGZ1biBfX2NhbWxfcGFyc2VyX2VudiAtPlxuICAgIGxldCBfMSA9IChQYXJzaW5nLnBlZWtfdmFsIF9fY2FtbF9wYXJzZXJfZW52IDEgOiAncnVsZXMpIGluXG4gICAgT2JqLnJlcHIoXG4jIDI5IFwidG9vbHMva2IvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICggXzEgKVxuIyAxNjEgXCJ0b29scy9rYi9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgOiAoQWxnLlRlcm0udCAqIEFsZy5UZXJtLnQpIGxpc3QpKVxuOyAoZnVuIF9fY2FtbF9wYXJzZXJfZW52IC0+XG4gICAgT2JqLnJlcHIoXG4jIDMyIFwidG9vbHMva2IvcGFyc2VyLm1seVwiXG4gICAgKCBbXSApXG4jIDE2NyBcInRvb2xzL2tiL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICA6ICdydWxlcykpXG47IChmdW4gX19jYW1sX3BhcnNlcl9lbnYgLT5cbiAgICBsZXQgXzEgPSAoUGFyc2luZy5wZWVrX3ZhbCBfX2NhbWxfcGFyc2VyX2VudiAxIDogJ3J1bGUpIGluXG4gICAgbGV0IF8yID0gKFBhcnNpbmcucGVla192YWwgX19jYW1sX3BhcnNlcl9lbnYgMCA6ICdydWxlcykgaW5cbiAgICBPYmoucmVwcihcbiMgMzMgXCJ0b29scy9rYi9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICggXzEgOjogXzIgKVxuIyAxNzUgXCJ0b29scy9rYi9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgOiAncnVsZXMpKVxuOyAoZnVuIF9fY2FtbF9wYXJzZXJfZW52IC0+XG4gICAgbGV0IF8xID0gKFBhcnNpbmcucGVla192YWwgX19jYW1sX3BhcnNlcl9lbnYgMiA6ICd0ZXJtKSBpblxuICAgIGxldCBfMyA9IChQYXJzaW5nLnBlZWtfdmFsIF9fY2FtbF9wYXJzZXJfZW52IDAgOiAndGVybSkgaW5cbiAgICBPYmoucmVwcihcbiMgMzYgXCJ0b29scy9rYi9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgKCBfMSwgXzMgKVxuIyAxODMgXCJ0b29scy9rYi9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgOiAncnVsZSkpXG47IChmdW4gX19jYW1sX3BhcnNlcl9lbnYgLT5cbiAgICBsZXQgXzEgPSAoUGFyc2luZy5wZWVrX3ZhbCBfX2NhbWxfcGFyc2VyX2VudiAzIDogc3RyaW5nKSBpblxuICAgIGxldCBfMyA9IChQYXJzaW5nLnBlZWtfdmFsIF9fY2FtbF9wYXJzZXJfZW52IDEgOiAndGVybXMpIGluXG4gICAgT2JqLnJlcHIoXG4jIDM5IFwidG9vbHMva2IvcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICggYXBwIF8xIF8zIClcbiMgMTkxIFwidG9vbHMva2IvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgIDogJ3Rlcm0pKVxuOyAoZnVuIF9fY2FtbF9wYXJzZXJfZW52IC0+XG4gICAgbGV0IF8xID0gKFBhcnNpbmcucGVla192YWwgX19jYW1sX3BhcnNlcl9lbnYgMCA6IHN0cmluZykgaW5cbiAgICBPYmoucmVwcihcbiMgNDAgXCJ0b29scy9rYi9wYXJzZXIubWx5XCJcbiAgICAgICAgICAoIGlmIGlzX3N5bSBfMSB0aGVuIGFwcCBfMSBbXSBlbHNlIHZhciBfMSApXG4jIDE5OCBcInRvb2xzL2tiL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICA6ICd0ZXJtKSlcbjsgKGZ1biBfX2NhbWxfcGFyc2VyX2VudiAtPlxuICAgIGxldCBfMSA9IChQYXJzaW5nLnBlZWtfdmFsIF9fY2FtbF9wYXJzZXJfZW52IDIgOiAndGVybSkgaW5cbiAgICBsZXQgXzMgPSAoUGFyc2luZy5wZWVrX3ZhbCBfX2NhbWxfcGFyc2VyX2VudiAwIDogJ3Rlcm1zKSBpblxuICAgIE9iai5yZXByKFxuIyA0NCBcInRvb2xzL2tiL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgKCBfMTo6XzMgKVxuIyAyMDYgXCJ0b29scy9rYi9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgOiAndGVybXMpKVxuOyAoZnVuIF9fY2FtbF9wYXJzZXJfZW52IC0+XG4gICAgbGV0IF8xID0gKFBhcnNpbmcucGVla192YWwgX19jYW1sX3BhcnNlcl9lbnYgMCA6ICd0ZXJtKSBpblxuICAgIE9iai5yZXByKFxuIyA0NSBcInRvb2xzL2tiL3BhcnNlci5tbHlcIlxuICAgICAgICAgKCBbXzFdIClcbiMgMjEzIFwidG9vbHMva2IvcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgIDogJ3Rlcm1zKSlcbjsgKGZ1biBfX2NhbWxfcGFyc2VyX2VudiAtPlxuICAgIE9iai5yZXByKFxuIyA0NiBcInRvb2xzL2tiL3BhcnNlci5tbHlcIlxuICAgICggW10gKVxuIyAyMTkgXCJ0b29scy9rYi9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgOiAndGVybXMpKVxuKCogRW50cnkgbWFpbiAqKVxuOyAoZnVuIF9fY2FtbF9wYXJzZXJfZW52IC0+IHJhaXNlIChQYXJzaW5nLllZZXhpdCAoUGFyc2luZy5wZWVrX3ZhbCBfX2NhbWxfcGFyc2VyX2VudiAwKSkpXG58XVxubGV0IHl5dGFibGVzID1cbiAgeyBQYXJzaW5nLmFjdGlvbnM9eXlhY3Q7XG4gICAgUGFyc2luZy50cmFuc2xfY29uc3Q9eXl0cmFuc2xfY29uc3Q7XG4gICAgUGFyc2luZy50cmFuc2xfYmxvY2s9eXl0cmFuc2xfYmxvY2s7XG4gICAgUGFyc2luZy5saHM9eXlsaHM7XG4gICAgUGFyc2luZy5sZW49eXlsZW47XG4gICAgUGFyc2luZy5kZWZyZWQ9eXlkZWZyZWQ7XG4gICAgUGFyc2luZy5kZ290bz15eWRnb3RvO1xuICAgIFBhcnNpbmcuc2luZGV4PXl5c2luZGV4O1xuICAgIFBhcnNpbmcucmluZGV4PXl5cmluZGV4O1xuICAgIFBhcnNpbmcuZ2luZGV4PXl5Z2luZGV4O1xuICAgIFBhcnNpbmcudGFibGVzaXplPXl5dGFibGVzaXplO1xuICAgIFBhcnNpbmcudGFibGU9eXl0YWJsZTtcbiAgICBQYXJzaW5nLmNoZWNrPXl5Y2hlY2s7XG4gICAgUGFyc2luZy5lcnJvcl9mdW5jdGlvbj1wYXJzZV9lcnJvcjtcbiAgICBQYXJzaW5nLm5hbWVzX2NvbnN0PXl5bmFtZXNfY29uc3Q7XG4gICAgUGFyc2luZy5uYW1lc19ibG9jaz15eW5hbWVzX2Jsb2NrIH1cbmxldCBtYWluIChsZXhmdW4gOiBMZXhpbmcubGV4YnVmIC0+IHRva2VuKSAobGV4YnVmIDogTGV4aW5nLmxleGJ1ZikgPVxuICAgKFBhcnNpbmcueXlwYXJzZSB5eXRhYmxlcyAxIGxleGZ1biBsZXhidWYgOiAoQWxnLlRlcm0udCAqIEFsZy5UZXJtLnQpIGxpc3QpXG4iLCIjIDEgXCJ0b29scy9rYi9sZXhlci5tbGxcIlxuIFxub3BlbiBQYXJzZXJcblxuIyA2IFwidG9vbHMva2IvbGV4ZXIubWxcIlxubGV0IF9fb2NhbWxfbGV4X3RhYmxlcyA9IHtcbiAgTGV4aW5nLmxleF9iYXNlID1cbiAgIFwiXFwwMDBcXDAwMFxcMjQ5XFwyNTVcXDAwMlxcMDAwXFwwMjZcXDAwMFxcMjUyXFwyNTVcXDI1M1xcMjU1XFwyNTRcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFwiO1xuICBMZXhpbmcubGV4X2JhY2t0cmsgPVxuICAgXCJcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAwNFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXCI7XG4gIExleGluZy5sZXhfZGVmYXVsdCA9XG4gICBcIlxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcIjtcbiAgTGV4aW5nLmxleF90cmFucyA9XG4gICBcIlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMlxcMDAwXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXCI7XG4gIExleGluZy5sZXhfY2hlY2sgPVxuICAgXCJcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMDAyXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAwMlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVwiO1xuICBMZXhpbmcubGV4X2Jhc2VfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2JhY2t0cmtfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2RlZmF1bHRfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X3RyYW5zX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9jaGVja19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfY29kZSA9XG4gICBcIlwiO1xufVxuXG5sZXQgcmVjIHRva2VuIGxleGJ1ZiA9XG4gICBfX29jYW1sX2xleF90b2tlbl9yZWMgbGV4YnVmIDBcbmFuZCBfX29jYW1sX2xleF90b2tlbl9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlID1cbiAgbWF0Y2ggTGV4aW5nLmVuZ2luZSBfX29jYW1sX2xleF90YWJsZXMgX19vY2FtbF9sZXhfc3RhdGUgbGV4YnVmIHdpdGhcbiAgICAgIHwgMCAtPlxuIyA4IFwidG9vbHMva2IvbGV4ZXIubWxsXCJcbiAgICAgICAgKCBFUSApXG4jIDExMiBcInRvb2xzL2tiL2xleGVyLm1sXCJcblxuICB8IDEgLT5cbiMgOSBcInRvb2xzL2tiL2xleGVyLm1sbFwiXG4gICAgICAgICggTFBBUiApXG4jIDExNyBcInRvb2xzL2tiL2xleGVyLm1sXCJcblxuICB8IDIgLT5cbiMgMTAgXCJ0b29scy9rYi9sZXhlci5tbGxcIlxuICAgICAgICAoIFJQQVIgKVxuIyAxMjIgXCJ0b29scy9rYi9sZXhlci5tbFwiXG5cbiAgfCAzIC0+XG4jIDExIFwidG9vbHMva2IvbGV4ZXIubWxsXCJcbiAgICAgICAgKCBDT01NQSApXG4jIDEyNyBcInRvb2xzL2tiL2xleGVyLm1sXCJcblxuICB8IDQgLT5cbmxldFxuIyAxMiBcInRvb2xzL2tiL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgc1xuIyAxMzMgXCJ0b29scy9rYi9sZXhlci5tbFwiXG49IExleGluZy5zdWJfbGV4ZW1lIGxleGJ1ZiBsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wb3MgbGV4YnVmLkxleGluZy5sZXhfY3Vycl9wb3MgaW5cbiMgMTIgXCJ0b29scy9rYi9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICggSURFTlQgcyApXG4jIDEzNyBcInRvb2xzL2tiL2xleGVyLm1sXCJcblxuICB8IDUgLT5cbiMgMTMgXCJ0b29scy9rYi9sZXhlci5tbGxcIlxuICAgICAgICAgICAoIHRva2VuIGxleGJ1ZiApXG4jIDE0MiBcInRvb2xzL2tiL2xleGVyLm1sXCJcblxuICB8IDYgLT5cbiMgMTQgXCJ0b29scy9rYi9sZXhlci5tbGxcIlxuICAgICAgICAoIEVPRiApXG4jIDE0NyBcInRvb2xzL2tiL2xleGVyLm1sXCJcblxuICB8IF9fb2NhbWxfbGV4X3N0YXRlIC0+IGxleGJ1Zi5MZXhpbmcucmVmaWxsX2J1ZmYgbGV4YnVmO1xuICAgICAgX19vY2FtbF9sZXhfdG9rZW5fcmVjIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZVxuXG47O1xuXG4iLCJ7XG5vcGVuIFBhcnNlclxufVxuXG5sZXQgc3BhY2UgPSAnICcgfCAnXFx0JyB8ICdcXHInIHwgJ1xcbidcblxucnVsZSB0b2tlbiA9IHBhcnNlXG4gIHwgXCI9XCIgeyBFUSB9XG4gIHwgXCIoXCIgeyBMUEFSIH1cbiAgfCBcIilcIiB7IFJQQVIgfVxuICB8IFwiLFwiIHsgQ09NTUEgfVxuICB8IChbJ2EnLSd6J10rIGFzIHMpIHsgSURFTlQgcyB9XG4gIHwgc3BhY2UrIHsgdG9rZW4gbGV4YnVmIH1cbiAgfCBlb2YgeyBFT0YgfVxuIiwib3BlbiBKc19vZl9vY2FtbFxub3BlbiBBbGdcbm9wZW4gVGVybVxuXG5tb2R1bGUgSHRtbCA9IERvbV9odG1sXG5cbmxldCBkb2MgPSBIdG1sLmRvY3VtZW50XG5sZXQgYnV0dG9uIHR4dCBhY3Rpb24gPVxuICBsZXQgYnV0dG9uX3R5cGUgPSBKcy5zdHJpbmcgXCJidXR0b25cIiBpblxuICBsZXQgYiA9IEh0bWwuY3JlYXRlSW5wdXQgfl90eXBlOmJ1dHRvbl90eXBlIGRvYyBpblxuICBiIyMudmFsdWUgOj0gSnMuc3RyaW5nIHR4dDtcbiAgYiMjLm9uY2xpY2sgOj0gRG9tX2h0bWwuaGFuZGxlciAoZnVuIF8gLT4gYWN0aW9uICgpOyBKcy5fdHJ1ZSk7XG4gIGJcblxubGV0IGRlYnVnIHMgPSBGaXJlYnVnLmNvbnNvbGUjI2RlYnVnIChKcy5zdHJpbmcgcylcblxubGV0IGpzZ2V0IHggPSBKcy5PcHQuZ2V0IHggKGZ1biAoKSAtPiBhc3NlcnQgZmFsc2UpXG5cbmxldCBwYXJzZV9ycyBzeW1zIHJ1bGVzID1cbiAgbGV0IHMgPSBzeW1zIGluXG4gIGxldCBzID0gU3RyaW5nLnNwbGl0X29uX2NoYXIgJywnIHMgaW5cbiAgbGV0IHMgPSBMaXN0Lm1hcCBTdHJpbmcudHJpbSBzIGluXG4gIGxldCBzID0gTGlzdC5tYXAgKGZ1biBzIC0+IFN0cmluZy5zcGxpdF9vbl9jaGFyICc6JyBzKSBzIGluXG4gIGxldCB3ID0gcmVmIDAgaW5cbiAgbGV0IHMgPSBMaXN0Lm1hcCAoZnVuY3Rpb24gKGY6Om46Ol8pIC0+IGRlY3IgdzsgT3AubWFrZSB+d2VpZ2h0OighdykgZiAoaW50X29mX3N0cmluZyBuKSB8IF8gLT4gZmFpbHdpdGggXCJ1bmtub3duIGFyaXR5XCIpIHMgaW5cbiAgUGFyc2VyUmVmcy5zeW1zIDo9IHM7XG4gIGxldCBycyA9IFBhcnNlci5tYWluIExleGVyLnRva2VuIChMZXhpbmcuZnJvbV9zdHJpbmcgcnVsZXMpIGluXG4gIGxldCBuYW1lID1cbiAgICBsZXQgbiA9IHJlZiAwIGluXG4gICAgZnVuICgpIC0+IGluY3IgbjsgXCJSPHN1Yj5cIiBeIHN0cmluZ19vZl9pbnQgIW4gXiBcIjwvc3ViPlwiXG4gIGluXG4gIGxldCBycyA9IExpc3QubWFwIChmdW4gKHMsdCkgLT4gUlMuUnVsZS5tYWtlIChuYW1lICgpKSBzIHQpIHJzIGluXG4gIFJTLm1ha2UgcyByc1xuXG4oKiogUmVwbGFjZSBbY10gYnkgW3RdIGluIFtzXS4gKilcbmxldCByZWMgcmVwbGFjZSBjIHQgcyA9XG4gIHRyeVxuICAgIGxldCBuID0gU3RyaW5nLmluZGV4IHMgYyBpblxuICAgIHJlcGxhY2UgYyB0IChTdHJpbmcuc3ViIHMgMCBuIF4gdCBeIFN0cmluZy5zdWIgcyAobisxKSAoU3RyaW5nLmxlbmd0aCBzLShuKzEpKSlcbiAgd2l0aFxuICB8IE5vdF9mb3VuZCAtPiBzXG5cbmxldCBydW4gXyA9XG4gIGxldCBzeW1zID0ganNnZXQgKEh0bWwuQ29lcmNlVG8udGV4dGFyZWEgKGpzZ2V0IChkb2MjI2dldEVsZW1lbnRCeUlkKEpzLnN0cmluZyBcInN5bWJvbHNcIikpKSkgaW5cbiAgbGV0IHJ1bGVzID0ganNnZXQgKEh0bWwuQ29lcmNlVG8udGV4dGFyZWEgKGpzZ2V0IChkb2MjI2dldEVsZW1lbnRCeUlkKEpzLnN0cmluZyBcInJ1bGVzXCIpKSkpIGluXG4gIGxldCBjb21wbGV0aW9uID0ganNnZXQgKGRvYyMjZ2V0RWxlbWVudEJ5SWQoSnMuc3RyaW5nIFwiY29tcGxldGlvblwiKSkgaW5cbiAgbGV0IHNxdWllciA9IGpzZ2V0IChkb2MjI2dldEVsZW1lbnRCeUlkKEpzLnN0cmluZyBcInNxdWllclwiKSkgaW5cbiAgbGV0IGdvID0ganNnZXQgKGRvYyMjZ2V0RWxlbWVudEJ5SWQoSnMuc3RyaW5nIFwiZ29cIikpIGluXG4gIGxldCBzdGF0dXMgPSBqc2dldCAoZG9jIyNnZXRFbGVtZW50QnlJZChKcy5zdHJpbmcgXCJzdGF0dXNcIikpIGluXG4gIGxldCBzdGF0dXMgcyA9IHN0YXR1cyMjLmlubmVySFRNTCA6PSBKcy5zdHJpbmcgcyBpblxuICBsZXQgZXJyb3IgcyA9IHN0YXR1cyAoXCI8ZW0gc3R5bGU9XFxcImNvbG9yOnJlZFxcXCI+XCIgXiBzIF4gXCI8L2VtPlwiKSBpblxuXG4gIGdvIyMub25jbGljayA6PVxuICAgIEh0bWwuaGFuZGxlclxuICAgICAgKGZ1biBfIC0+XG4gICAgICAgICB0cnlcbiAgICAgICAgICAgc3RhdHVzIFwiU3RhcnRlZCBjb21wdXRhdGlvbi4uLlwiO1xuICAgICAgICAgICBsZXQgc3ltcyA9IEpzLnRvX3N0cmluZyBzeW1zIyMudmFsdWUgaW5cbiAgICAgICAgICAgbGV0IHJ1bGVzID0gSnMudG9fc3RyaW5nIHJ1bGVzIyMudmFsdWUgaW5cblxuICAgICAgICAgICBzdGF0dXMgXCJQYXJzaW5nIHJld3JpdGluZyBzeXN0ZW0uLi5cIjtcbiAgICAgICAgICAgbGV0IHJzID0gcGFyc2VfcnMgc3ltcyBydWxlcyBpblxuICAgICAgICAgICBzdGF0dXMgKFwiUGFyc2VkOiBcIiBeIFJTLnRvX3N0cmluZyBycyk7XG5cbiAgICAgICAgICAgc3RhdHVzIFwiQ29tcHV0aW5nIEtudXRoLUJlbmRpeCBjb21wbGV0aW9uLi4uXCI7XG4gICAgICAgICAgIGxldCBkaXNwbGF5IHJzID1cbiAgICAgICAgICAgICBjb21wbGV0aW9uIyMuaW5uZXJIVE1MIDo9IEpzLnN0cmluZyAocmVwbGFjZSAnXFxuJyBcIjxici8+XCIgKFJTLnRvX3N0cmluZyB+dmFyOlZhci5uYW1lcl9uYXR1cmFsIHJzKSlcbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgbGV0IG5hbWVyID1cbiAgICAgICAgICAgICBsZXQgbiA9IHJlZiAwIGluXG4gICAgICAgICAgICAgZnVuICgpIC0+IGluY3IgbjsgUHJpbnRmLnNwcmludGYgXCJLPHN1Yj4lZDwvc3ViPlwiICFuXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIGxldCBycyA9IFJTLmtudXRoX2JlbmRpeCB+bmFtZXIgfmNhbGxiYWNrOmRpc3BsYXkgcnMgaW5cbiAgICAgICAgICAgZGlzcGxheSBycztcblxuICAgICAgICAgICBzdGF0dXMgXCJDb21wdXRpbmcgU3F1aWVyIGNvbXBsZXRpb24uLi5cIjtcbiAgICAgICAgICAgbGV0IHNxID0gUlMuc3F1aWVyIHJzIGluXG4gICAgICAgICAgIGxldCBzcXMgPVxuICAgICAgICAgICAgIGxldCBydWxlX25hbWUgPSBVdGlscy5uYW1lciAoZnVuIChzMSxzMikgKHMxJyxzMicpIC0+IFJTLlBhdGguZXEgczEgczEnICYmIFJTLlBhdGguZXEgczIgczInKSBpblxuICAgICAgICAgICAgIGxldCBhbnMgPSByZWYgXCJcIiBpblxuICAgICAgICAgICAgIExpc3QuaXRlclxuICAgICAgICAgICAgICAgKGZ1biAoczEsczIpIC0+XG4gICAgICAgICAgICAgICAgICBsZXQgbiA9IHJ1bGVfbmFtZSAoczEsczIpICsgMSBpblxuICAgICAgICAgICAgICAgICAgbGV0IHZhciA9IFZhci5uYW1lcl9uYXR1cmFsICgpIGluXG4gICAgICAgICAgICAgICAgICBhbnMgOj0gUHJpbnRmLnNwcmludGYgXCIlczxoMz5DPHN1Yj4lZDwvc3ViPjwvaDM+PHA+JXM8YnIvPiVzPC9wPiUhXCIgIWFucyBuIChSUy5QYXRoLnRvX3N0cmluZyB+dmFyIHMxKSAoUlMuUGF0aC50b19zdHJpbmcgfnZhciBzMilcbiAgICAgICAgICAgICAgICkgc3E7XG4gICAgICAgICAgICAgIWFuc1xuICAgICAgICAgICBpblxuICAgICAgICAgICBzcXVpZXIjIy5pbm5lckhUTUwgOj0gSnMuc3RyaW5nIHNxcztcblxuICAgICAgICAgICBzdGF0dXMgXCJEb25lLlwiO1xuICAgICAgICAgICBKcy5fdHJ1ZVxuICAgICAgICAgd2l0aFxuICAgICAgICAgfCBFeGl0IC0+XG4gICAgICAgICAgIEpzLl9mYWxzZVxuICAgICAgICAgfCBGYWlsdXJlIHMgLT5cbiAgICAgICAgICAgZXJyb3IgKFwiRXJyb3I6IFwiIF4gcyk7XG4gICAgICAgICAgIEpzLl9mYWxzZVxuICAgICAgICAgfCBlIC0+XG4gICAgICAgICAgIGVycm9yIChQcmludGV4Yy50b19zdHJpbmcgZSk7XG4gICAgICAgICAgIEpzLl9mYWxzZVxuICAgICAgKTtcblxuICBKcy5fdHJ1ZVxuXG5sZXQgKCkgPVxuICBIdG1sLndpbmRvdyMjLm9ubG9hZCA6PSBIdG1sLmhhbmRsZXIgcnVuXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEVuc3VyZSB0aGF0IFthdF9leGl0XSBmdW5jdGlvbnMgYXJlIGNhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IHByb2dyYW0gKilcblxubGV0IF8gPSBkb19hdF9leGl0KClcbiJdfQ==
